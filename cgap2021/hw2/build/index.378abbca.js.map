{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;QCtBO;mBACmB;uBAET;;;uBAEA;;IAEbA,OAAOC,QAAQ;EACfD,OAAOC,OAAO;;MAEZC,OAAO;MACLF,OAAOC,QAAQ;;aAERD,OAAOC,QAAQ;;;;AAK9BC,IAAIC,MAAMC,SAASC;;;AClBnB;qBAE6B;EAC3BC,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpEA;qBAE6B;EAC3BF,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACr9FA;qBAE6B;EAC3BF,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjgJA;qBAE6B;EAC3BF,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;;AAEAC,OAAOC,eAAeH,SAAS;EAAgBI,OAAO;;;;;;;;;AAStD,iBAAiBC,KAAKC;QACZC,MAAML,OAAOM,OAAO;QACpBC,OAAOJ,IAAIK,MAAM;WACdC,IAAI,GAAGA,IAAIF,KAAKG,QAAQD;IAC7BJ,IAAIE,KAAKE,MAAM;;SAEZL,mBAAmB,AAAAO,SAASN,IAAIM,IAAIC,iBAAiB,AAAAD,SAASN,IAAIM;;;;;MAMvEE;GACD;GAAgB;GAChB;GAAiB;GACjB;GAAiB;GACjB;GAAiB;GACjB;GAAuB;GACvB;GAA2B;GAC3B;GAA4B;GAC5B;GAA4B;GAC5B;GAA8B;GAC9B;GAAwB;GACxB;GAA4B;G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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;A;A;A;ACnYA,MAAMmD,UAAU,GAAG,IAAnB;AACA,MAAMC,UAAU,GAAG,IAAnB;AACA,MAAMC,MAAM,GAAG,IAAf;AACA,MAAMC,QA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AAeE,YAAYp9C,OAAO28C;WACjC,MAAMO,SAASN,MAAMf,KAAK;;EAGlC5pE,QAAQorE,YAAYA;EACpBprE,QAAQqrE,OAAOA;EAEfnrE,OAAOC,eAAeH,SAAS;IAAgBI,OAAO;;;;;ACrVvD;qBAE6B;EAC3BL,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3vCA;qBAE6B;EAC3BF,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/nLA;qBAE6B;EAC3BF,OAAOC,UAAUC,QAAQ;;EAEzBF,OAAOC,UAAUC,QAAQ;;;;ACL3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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MAAM,OAAO,MAAM;;;;;;UAM7B,WAAW;MACb,OAAO,KAAK,gBAAgB;;QAG5B;QACA;UACE,UAAU;YACN,MAAM,SAAS,cAAc;MACnC,IAAI,OAAO;MACX,IAAI,SAAS;MACb,IAAI,WAAW;cACL,QAAQ,IAAI;cACZ,aAAa;QACnB,OAAO,iBAAiB,WAAW;cAC3B,UAAU;UACd,IAAI,SAAS;gBACL,KAAK,SAAS,OAAO,OAAO,QAAQ,cAC/B,KAAK,SAAS,OAAO,OAAO,QAAQ;YAC7C,aAAa;;UAEjB,IAAI,MAAc,OAAO;;QAE7B,OAAO,cAAc,MAAM;;MAE/B,IAAI;;;MAIJ;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;MACA;MACA;MAEA;MAEA;MAEA;MACA;;;;;;;;AC9YZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;mB;M,wC;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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACn1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC73DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACx3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC15BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;mB;M,wC;M,sB,Q,C,M;6Cd/pBU,OAAA,wBAzCQ;IAJN,KAAI;IACG,QAAgB,QAAA,KAAK,MAAa,YAAA,KAAM,OAAA;IAC/C,OAAM;IACN,QAAO;K,M,qBAWF;IARE;MAAyC,eAAA,KAAI,QAAA;MAAkD,iBAAA,KAAI,QAAA;OAIpG;IACD,SAAS,OAAA,OAAA,OAAA,KAAA,AAAA;;OAAA,KAAI,OAAgB,YAAA,KAAG,IAAC,KAAI;;KAC7C,oBAED,qBAUS;IARE;MAAyC,eAAA,KAAI,QAAA;MAA6C,iBAAA,KAAI,QAAA;OAI/F;IACD,SAAS,OAAA,OAAA,OAAA,KAAA,AAAA;;OAAA,KAAI,OAAW,OAAA,KAAG,IAAC,KAAI;;KACxC,SAED,qBAUS;IARE;MAAyC,eAAA,KAAI,QAAA;MAA6C,iBAAA,KAAI,QAAA;OAI/F;IACD,SAAS,OAAA,OAAA,OAAA,KAAA,AAAA;;OAAA,KAAI,OAAW,OAAA,KAAG,IAAC,KAAI;;KACxC,SAED,qBAUM,OAAA,4CADA;IANE,MAAK;IACL,KAAI;IACJ,KAAI;IACJ,MAAK;IACI,uBAAA,OAAA,OAAA,OAAA,KAAA,AAAA,UAAA,KAAI,OAAA;IACR,SAAO,OAAA,OAAA,OAAA,KAAA,AAAA,UAAA,KAAG,IAAC,KAAI;K,M,yBADX,KAAI,mDAEZ,KAAI,OAAA;;;;;;IA7CjB5yE,OAAO;kBAEI,AAAAyjE","sources":["./node_modules/@parcel/runtime-js/lib/JSRuntime.js","./node_modules/@parcel/runtime-js/lib/bundle-manifest.js","./cgap2021/hw2/dev/src/index.ts","./node_modules/vue/index.js","./node_modules/vue/dist/vue.cjs.prod.js","./node_modules/@vue/compiler-dom/index.js","./node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.prod.js","./node_modules/@vue/compiler-core/index.js","./node_modules/@vue/compiler-core/dist/compiler-core.cjs.prod.js","./node_modules/@vue/shared/index.js","./node_modules/@vue/shared/dist/shared.cjs.prod.js","./node_modules/source-map/source-map.js","./node_modules/source-map/lib/source-map-generator.js","./node_modules/source-map/lib/base64-vlq.js","./node_modules/source-map/lib/base64.js","./node_modules/source-map/lib/util.js","./node_modules/source-map/lib/array-set.js","./node_modules/source-map/lib/mapping-list.js","./node_modules/source-map/lib/source-map-consumer.js","./node_modules/source-map/lib/binary-search.js","./node_modules/source-map/lib/quick-sort.js","./node_modules/source-map/lib/source-node.js","./node_modules/@babel/parser/src/tokenizer/types.js","./node_modules/@babel/parser/src/util/whitespace.js","./node_modules/@babel/parser/src/util/location.js","./node_modules/@babel/parser/src/parser/base.js","./node_modules/@babel/parser/src/parser/comments.js","./node_modules/@babel/parser/src/parser/error-message.js","./node_modules/@babel/parser/src/parser/error.js","./node_modules/@babel/parser/src/plugins/estree.js","./node_modules/@babel/parser/src/tokenizer/context.js","./node_modules/@babel/babel-helper-validator-identifier/src/identifier.ts","./node_modules/@babel/babel-helper-validator-identifier/src/keyword.ts","./node_modules/@babel/parser/src/util/identifier.js","./node_modules/@babel/parser/src/util/scopeflags.js","./node_modules/@babel/parser/src/util/scope.js","./node_modules/@babel/parser/src/plugins/flow/scope.js","./node_modules/@babel/parser/src/plugins/flow/index.js","./node_modules/@babel/parser/src/plugins/jsx/xhtml.js","./node_modules/@babel/parser/src/plugins/jsx/index.js","./node_modules/@babel/parser/src/plugins/typescript/scope.js","./node_modules/@babel/parser/src/util/production-parameter.js","./node_modules/@babel/parser/src/plugins/typescript/index.js","./node_modules/@babel/parser/src/plugins/placeholders.js","./node_modules/@babel/parser/src/plugins/v8intrinsic.js","./node_modules/@babel/parser/src/plugin-utils.js","./node_modules/@babel/parser/src/options.js","./node_modules/@babel/parser/src/tokenizer/state.js","./node_modules/@babel/parser/src/tokenizer/index.js","./node_modules/@babel/parser/src/util/class-scope.js","./node_modules/@babel/parser/src/util/expression-scope.js","./node_modules/@babel/parser/src/parser/util.js","./node_modules/@babel/parser/src/parser/node.js","./node_modules/@babel/parser/src/parser/lval.js","./node_modules/@babel/parser/src/parser/expression.js","./node_modules/@babel/parser/src/parser/statement.js","./node_modules/@babel/parser/src/parser/index.js","./node_modules/@babel/parser/src/index.js","./node_modules/estree-walker/dist/umd/estree-walker.js","./node_modules/@vue/runtime-dom/index.js","./node_modules/@vue/runtime-dom/dist/runtime-dom.cjs.prod.js","./node_modules/@vue/runtime-core/index.js","./node_modules/@vue/runtime-core/dist/runtime-core.cjs.prod.js","./node_modules/@vue/reactivity/index.js","./node_modules/@vue/reactivity/dist/reactivity.cjs.prod.js","./cgap2021/hw2/dev/src/Ctrl.vue","./node_modules/@parcel/runtime-js/lib/bundle-url.js","./node_modules/@parcel/runtime-js/lib/relative-path.js","./node_modules/@parcel/transformer-js/lib/esmodule-helpers.js","./cgap2021/hw2/dev/src/View.vue","./cgap2021/hw2/dev/src/imgMorph.ts","./cgap2021/hw2/dev/src/shader.ts","./cgap2021/hw2/dev/src/pose.ts","./node_modules/gl-matrix/cjs/index.js","./node_modules/gl-matrix/cjs/common.js","./node_modules/gl-matrix/cjs/mat2.js","./node_modules/gl-matrix/cjs/mat2d.js","./node_modules/gl-matrix/cjs/mat3.js","./node_modules/gl-matrix/cjs/mat4.js","./node_modules/gl-matrix/cjs/quat.js","./node_modules/gl-matrix/cjs/vec3.js","./node_modules/gl-matrix/cjs/vec4.js","./node_modules/gl-matrix/cjs/quat2.js","./node_modules/gl-matrix/cjs/vec2.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _plugin() {\n  const data = require(\"@parcel/plugin\");\n\n  _plugin = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _utils() {\n  const data = require(\"@parcel/utils\");\n\n  _utils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _nullthrows() {\n  const data = _interopRequireDefault(require(\"nullthrows\"));\n\n  _nullthrows = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// List of browsers that support dynamic import natively\n// https://caniuse.com/#feat=es6-module-dynamic-import\nconst DYNAMIC_IMPORT_BROWSERS = {\n  edge: '76',\n  firefox: '67',\n  chrome: '63',\n  safari: '11.1',\n  opera: '50'\n}; // Used for as=\"\" in preload/prefetch\n\nconst TYPE_TO_RESOURCE_PRIORITY = {\n  css: 'style',\n  js: 'script'\n};\nconst BROWSER_PRELOAD_LOADER = './loaders/browser/preload-loader';\nconst BROWSER_PREFETCH_LOADER = './loaders/browser/prefetch-loader';\nconst LOADERS = {\n  browser: {\n    css: './loaders/browser/css-loader',\n    html: './loaders/browser/html-loader',\n    js: './loaders/browser/js-loader',\n    wasm: './loaders/browser/wasm-loader',\n    IMPORT_POLYFILL: './loaders/browser/import-polyfill'\n  },\n  worker: {\n    js: './loaders/worker/js-loader',\n    wasm: './loaders/worker/wasm-loader',\n    IMPORT_POLYFILL: false\n  },\n  node: {\n    css: './loaders/node/css-loader',\n    html: './loaders/node/html-loader',\n    js: './loaders/node/js-loader',\n    wasm: './loaders/node/wasm-loader',\n    IMPORT_POLYFILL: null\n  }\n};\n\nfunction getLoaders(ctx) {\n  if (ctx.isWorker()) return LOADERS.worker;\n  if (ctx.isBrowser()) return LOADERS.browser;\n  if (ctx.isNode()) return LOADERS.node;\n  return null;\n} // This cache should be invalidated if new dependencies get added to the bundle without the bundle objects changing\n// This can happen when we reuse the BundleGraph between subsequent builds\n\n\nlet bundleDependencies = new WeakMap();\n\nvar _default = new (_plugin().Runtime)({\n  apply({\n    bundle,\n    bundleGraph,\n    options\n  }) {\n    // Dependency ids in code replaced with referenced bundle names\n    // Loader runtime added for bundle groups that don't have a native loader (e.g. HTML/CSS/Worker - isURL?),\n    // and which are not loaded by a parent bundle.\n    // Loaders also added for modules that were moved to a separate bundle because they are a different type\n    // (e.g. WASM, HTML). These should be preloaded prior to the bundle being executed. Replace the entry asset(s)\n    // with the preload module.\n    if (bundle.type !== 'js') {\n      return;\n    }\n\n    let {\n      asyncDependencies,\n      otherDependencies\n    } = getDependencies(bundle);\n    let assets = [];\n\n    for (let dependency of asyncDependencies) {\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if (resolved == null) {\n        continue;\n      }\n\n      if (resolved.type === 'asset') {\n        if (!bundle.env.shouldScopeHoist) {\n          // If this bundle already has the asset this dependency references,\n          // return a simple runtime of `Promise.resolve(internalRequire(assetId))`.\n          // The linker handles this for scope-hoisting.\n          assets.push({\n            filePath: __filename,\n            code: `module.exports = Promise.resolve(module.bundle.root(${JSON.stringify(bundleGraph.getAssetPublicId(resolved.value))}))`,\n            dependency\n          });\n        }\n      } else {\n        let loaderRuntime = getLoaderRuntime({\n          bundle,\n          dependency,\n          bundleGraph,\n          bundleGroup: resolved.value,\n          options\n        });\n\n        if (loaderRuntime != null) {\n          assets.push(loaderRuntime);\n        }\n      }\n    }\n\n    for (let dependency of otherDependencies) {\n      // Resolve the dependency to a bundle. If inline, export the dependency id,\n      // which will be replaced with the contents of that bundle later.\n      let referencedBundle = bundleGraph.getReferencedBundle(dependency, bundle);\n\n      if (referencedBundle !== null && referencedBundle !== void 0 && referencedBundle.isInline) {\n        assets.push({\n          filePath: _path().default.join(__dirname, `/bundles/${referencedBundle.id}.js`),\n          code: `module.exports = ${JSON.stringify(dependency.id)};`,\n          dependency\n        });\n        continue;\n      } // Otherwise, try to resolve the dependency to an external bundle group\n      // and insert a URL to that bundle.\n\n\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if (dependency.isURL && resolved == null) {\n        // If a URL dependency was not able to be resolved, add a runtime that\n        // exports the original moduleSpecifier.\n        assets.push({\n          filePath: __filename,\n          code: `module.exports = ${JSON.stringify(dependency.moduleSpecifier)}`,\n          dependency\n        });\n        continue;\n      }\n\n      if (resolved == null || resolved.type !== 'bundle_group') {\n        continue;\n      }\n\n      let bundleGroup = resolved.value;\n      let mainBundle = (0, _nullthrows().default)(bundleGraph.getBundlesInBundleGroup(bundleGroup).find(b => {\n        let entries = b.getEntryAssets();\n        return entries.some(e => bundleGroup.entryAssetId === e.id);\n      }));\n\n      if (bundle.env.outputFormat === 'commonjs' && mainBundle.type === 'js') {\n        assets.push({\n          filePath: __filename,\n          dependency,\n          code: `module.exports = require(\"./\" + ${getRelativePathExpr(bundle, mainBundle, options)})`\n        });\n        continue;\n      } // URL dependency or not, fall back to including a runtime that exports the url\n\n\n      assets.push(getURLRuntime(dependency, bundle, mainBundle, options));\n    } // In development, bundles can be created lazily. This means that the parent bundle may not\n    // know about all of the sibling bundles of a child when it is written for the first time.\n    // Therefore, we need to also ensure that the siblings are loaded when the child loads.\n\n\n    if (options.shouldBuildLazily && bundle.env.outputFormat === 'global') {\n      let referenced = bundleGraph.getReferencedBundles(bundle).filter(b => !b.isInline);\n\n      for (let referencedBundle of referenced) {\n        let loaders = getLoaders(bundle.env);\n\n        if (!loaders) {\n          continue;\n        }\n\n        let loader = loaders[referencedBundle.type];\n\n        if (!loader) {\n          continue;\n        }\n\n        let relativePathExpr = getRelativePathExpr(bundle, referencedBundle, options);\n        let loaderCode = `require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr})`;\n        assets.push({\n          filePath: __filename,\n          code: loaderCode,\n          isEntry: true\n        });\n      }\n    }\n\n    if (shouldUseRuntimeManifest(bundle, options) && bundleGraph.getChildBundles(bundle).length > 0 && isNewContext(bundle, bundleGraph)) {\n      assets.push({\n        filePath: __filename,\n        code: getRegisterCode(bundle, bundleGraph),\n        isEntry: true\n      });\n    }\n\n    return assets;\n  }\n\n});\n\nexports.default = _default;\n\nfunction getDependencies(bundle) {\n  let cachedDependencies = bundleDependencies.get(bundle);\n\n  if (cachedDependencies) {\n    return cachedDependencies;\n  } else {\n    let asyncDependencies = [];\n    let otherDependencies = [];\n    bundle.traverse(node => {\n      if (node.type !== 'dependency') {\n        return;\n      }\n\n      let dependency = node.value;\n\n      if (dependency.isAsync && !dependency.isURL) {\n        asyncDependencies.push(dependency);\n      } else {\n        otherDependencies.push(dependency);\n      }\n    });\n    bundleDependencies.set(bundle, {\n      asyncDependencies,\n      otherDependencies\n    });\n    return {\n      asyncDependencies,\n      otherDependencies\n    };\n  }\n}\n\nfunction getLoaderRuntime({\n  bundle,\n  dependency,\n  bundleGroup,\n  bundleGraph,\n  options\n}) {\n  let loaders = getLoaders(bundle.env);\n\n  if (loaders == null) {\n    return;\n  }\n\n  let externalBundles = bundleGraph.getBundlesInBundleGroup(bundleGroup).filter(bundle => !bundle.isInline);\n  let mainBundle = (0, _nullthrows().default)(externalBundles.find(bundle => {\n    var _bundle$getMainEntry;\n\n    return ((_bundle$getMainEntry = bundle.getMainEntry()) === null || _bundle$getMainEntry === void 0 ? void 0 : _bundle$getMainEntry.id) === bundleGroup.entryAssetId;\n  })); // CommonJS is a synchronous module system, so there is no need to load bundles in parallel.\n  // Importing of the other bundles will be handled by the bundle group entry.\n  // Do the same thing in library mode for ES modules, as we are building for another bundler\n  // and the imports for sibling bundles will be in the target bundle.\n  // Also do this when building lazily or the runtime itself could get deduplicated and only\n  // exist in the parent. This causes errors if an old version of the parent without the runtime\n  // is already loaded.\n\n  if (bundle.env.outputFormat === 'commonjs' || bundle.env.isLibrary || options.shouldBuildLazily) {\n    externalBundles = [mainBundle];\n  } else {\n    // Otherwise, load the bundle group entry after the others.\n    externalBundles.splice(externalBundles.indexOf(mainBundle), 1);\n    externalBundles.reverse().push(mainBundle);\n  } // Determine if we need to add a dynamic import() polyfill, or if all target browsers support it natively.\n\n\n  let needsDynamicImportPolyfill = false;\n\n  if (bundle.env.isBrowser() && bundle.env.outputFormat === 'esmodule') {\n    needsDynamicImportPolyfill = !bundle.env.matchesEngines(DYNAMIC_IMPORT_BROWSERS);\n  }\n\n  let loaderModules = externalBundles.map(to => {\n    let loader = loaders[to.type];\n\n    if (!loader) {\n      return;\n    }\n\n    let relativePathExpr = getRelativePathExpr(bundle, to, options); // Use esmodule loader if possible\n\n    if (to.type === 'js' && to.env.outputFormat === 'esmodule') {\n      if (!needsDynamicImportPolyfill) {\n        return `import(\"./\" + ${relativePathExpr})`;\n      }\n\n      loader = (0, _nullthrows().default)(loaders.IMPORT_POLYFILL, `No import() polyfill available for context '${bundle.env.context}'`);\n    } else if (to.type === 'js' && to.env.outputFormat === 'commonjs') {\n      return `Promise.resolve(require(\"./\" + ${relativePathExpr}))`;\n    }\n\n    let code = `require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr})`; // In development, clear the require cache when an error occurs so the\n    // user can try again (e.g. after fixing a build error).\n\n    if (options.mode === 'development' && bundle.env.outputFormat === 'global') {\n      code += '.catch(err => {delete module.bundle.cache[module.id]; throw err;})';\n    }\n\n    return code;\n  }).filter(Boolean);\n\n  if (bundle.env.context === 'browser' && !options.shouldBuildLazily) {\n    loaderModules.push(...externalBundles // TODO: Allow css to preload resources as well\n    .filter(to => to.type === 'js').flatMap(from => {\n      let {\n        preload,\n        prefetch\n      } = getHintedBundleGroups(bundleGraph, from);\n      return [...getHintLoaders(bundleGraph, bundle, preload, BROWSER_PRELOAD_LOADER, options), ...getHintLoaders(bundleGraph, bundle, prefetch, BROWSER_PREFETCH_LOADER, options)];\n    }));\n  }\n\n  if (loaderModules.length === 0) {\n    return;\n  }\n\n  let loaderCode = loaderModules.join(', ');\n\n  if (loaderModules.length > 1 && (bundle.env.outputFormat === 'global' || !externalBundles.every(b => b.type === 'js'))) {\n    loaderCode = `Promise.all([${loaderCode}])`;\n\n    if (bundle.env.outputFormat !== 'global') {\n      loaderCode += `.then(r => r[r.length - 1])`;\n    }\n  } else {\n    loaderCode = `(${loaderCode})`;\n  }\n\n  if (bundle.env.outputFormat === 'global' && mainBundle.type === 'js') {\n    loaderCode += `.then(() => module.bundle.root('${bundleGraph.getAssetPublicId(bundleGraph.getAssetById(bundleGroup.entryAssetId))}')${// In global output with scope hoisting, functions return exports are\n    // always returned. Otherwise, the exports are returned.\n    bundle.env.shouldScopeHoist ? '()' : ''})`;\n  }\n\n  return {\n    filePath: __filename,\n    code: `module.exports = ${loaderCode};`,\n    dependency\n  };\n}\n\nfunction getHintedBundleGroups(bundleGraph, bundle) {\n  let preload = [];\n  let prefetch = [];\n  let {\n    asyncDependencies\n  } = getDependencies(bundle);\n\n  for (let dependency of asyncDependencies) {\n    var _dependency$meta;\n\n    let attributes = (_dependency$meta = dependency.meta) === null || _dependency$meta === void 0 ? void 0 : _dependency$meta.importAttributes;\n\n    if (typeof attributes === 'object' && attributes != null && ( // $FlowFixMe\n    attributes.preload || attributes.prefetch)) {\n      let resolved = bundleGraph.resolveAsyncDependency(dependency, bundle);\n\n      if ((resolved === null || resolved === void 0 ? void 0 : resolved.type) === 'bundle_group') {\n        // === true for flow\n        if (attributes.preload === true) {\n          preload.push(resolved.value);\n        }\n\n        if (attributes.prefetch === true) {\n          prefetch.push(resolved.value);\n        }\n      }\n    }\n  }\n\n  return {\n    preload,\n    prefetch\n  };\n}\n\nfunction getHintLoaders(bundleGraph, from, bundleGroups, loader, options) {\n  let hintLoaders = [];\n\n  for (let bundleGroupToPreload of bundleGroups) {\n    let bundlesToPreload = bundleGraph.getBundlesInBundleGroup(bundleGroupToPreload);\n\n    for (let bundleToPreload of bundlesToPreload) {\n      let relativePathExpr = getRelativePathExpr(from, bundleToPreload, options);\n      let priority = TYPE_TO_RESOURCE_PRIORITY[bundleToPreload.type];\n      hintLoaders.push(`require(${JSON.stringify(loader)})(require('./bundle-url').getBundleURL() + ${relativePathExpr}, ${priority ? JSON.stringify(priority) : 'null'}, ${JSON.stringify(bundleToPreload.target.env.outputFormat === 'esmodule')})`);\n    }\n  }\n\n  return hintLoaders;\n}\n\nfunction isNewContext(bundle, bundleGraph) {\n  let parents = bundleGraph.getParentBundles(bundle);\n  return bundle.isEntry || parents.length === 0 || parents.some(parent => parent.env.context !== bundle.env.context || parent.type !== 'js');\n}\n\nfunction getURLRuntime(dependency, from, to, options) {\n  let relativePathExpr = getRelativePathExpr(from, to, options);\n\n  if (dependency.meta.webworker === true) {\n    return {\n      filePath: __filename,\n      code: `module.exports = require('./get-worker-url')(${relativePathExpr});`,\n      dependency\n    };\n  }\n\n  return {\n    filePath: __filename,\n    code: `module.exports = require('./bundle-url').getBundleURL() + ${relativePathExpr}`,\n    dependency\n  };\n}\n\nfunction getRegisterCode(entryBundle, bundleGraph) {\n  let idToName = {};\n  bundleGraph.traverseBundles((bundle, _, actions) => {\n    if (bundle.isInline) {\n      return;\n    }\n\n    idToName[bundle.publicId] = (0, _nullthrows().default)(bundle.name);\n\n    if (bundle !== entryBundle && isNewContext(bundle, bundleGraph)) {\n      // New contexts have their own manifests, so there's no need to continue.\n      actions.skipChildren();\n    }\n  }, entryBundle);\n  return \"require('./bundle-manifest').register(JSON.parse(\" + JSON.stringify(JSON.stringify(idToName)) + '));';\n}\n\nfunction getRelativePathExpr(from, to, options) {\n  if (shouldUseRuntimeManifest(from, options)) {\n    return `require('./relative-path')(${JSON.stringify(from.publicId)}, ${JSON.stringify(to.publicId)})`;\n  }\n\n  return JSON.stringify((0, _utils().relativeBundlePath)(from, to, {\n    leadingDotSlash: false\n  }));\n}\n\nfunction shouldUseRuntimeManifest(bundle, options) {\n  let env = bundle.env;\n  return !env.isLibrary && env.outputFormat === 'global' && env.isBrowser() && options.mode === 'production';\n}","\"use strict\";\n\nvar mapping = {};\n\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\n\nfunction resolve(id) {\n  var resolved = mapping[id];\n\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n\n  return resolved;\n}\n\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","import \"../../../../css/build/main.css\"\r\nimport { createApp } from \"vue\"\r\n// @ts-ignore\r\nimport Ctrl from \"./Ctrl.vue\"\r\n// @ts-ignore\r\nimport View from \"./View.vue\"\r\n\r\nif (window.name == \"\") {\r\n    window.name = \"image morphing control\"\r\n}\r\nconst app = (() => {\r\n    if (window.name == \"image morphing control\") {\r\n        return createApp(Ctrl)\r\n    } else if (window.name == \"image morphing view\") {\r\n        return createApp(View)\r\n    }\r\n})()\r\n\r\napp.mount(document.body)\r\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/vue.cjs.prod.js')\n} else {\n  module.exports = require('./dist/vue.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerDom = require('@vue/compiler-dom');\nvar runtimeDom = require('@vue/runtime-dom');\nvar shared = require('@vue/shared');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      n[k] = e[k];\n    });\n  }\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar runtimeDom__namespace = /*#__PURE__*/_interopNamespace(runtimeDom);\n\n// This entry is the \"full-build\" that includes both the runtime\r\nconst compileCache = Object.create(null);\r\nfunction compileToFunction(template, options) {\r\n    if (!shared.isString(template)) {\r\n        if (template.nodeType) {\r\n            template = template.innerHTML;\r\n        }\r\n        else {\r\n            return shared.NOOP;\r\n        }\r\n    }\r\n    const key = template;\r\n    const cached = compileCache[key];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    if (template[0] === '#') {\r\n        const el = document.querySelector(template);\r\n        // __UNSAFE__\r\n        // Reason: potential execution of JS expressions in in-DOM template.\r\n        // The user must make sure the in-DOM template is trusted. If it's rendered\r\n        // by the server, the template should not contain any user data.\r\n        template = el ? el.innerHTML : ``;\r\n    }\r\n    const { code } = compilerDom.compile(template, shared.extend({\r\n        hoistStatic: true,\r\n        onError(err) {\r\n            {\r\n                /* istanbul ignore next */\r\n                throw err;\r\n            }\r\n        }\r\n    }, options));\r\n    // The wildcard import results in a huge object with every export\r\n    // with keys that cannot be mangled, and can be quite heavy size-wise.\r\n    // In the global build we know `Vue` is available globally so we can avoid\r\n    // the wildcard object.\r\n    const render = (new Function('Vue', code)(runtimeDom__namespace));\r\n    render._rc = true;\r\n    return (compileCache[key] = render);\r\n}\r\nruntimeDom.registerRuntimeCompiler(compileToFunction);\n\nObject.keys(runtimeDom).forEach(function (k) {\n  if (k !== 'default') exports[k] = runtimeDom[k];\n});\nexports.compile = compileToFunction;\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/compiler-dom.cjs.prod.js')\n} else {\n  module.exports = require('./dist/compiler-dom.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerCore = require('@vue/compiler-core');\nvar shared = require('@vue/shared');\n\nconst V_MODEL_RADIO = Symbol(``);\r\nconst V_MODEL_CHECKBOX = Symbol(``);\r\nconst V_MODEL_TEXT = Symbol(``);\r\nconst V_MODEL_SELECT = Symbol(``);\r\nconst V_MODEL_DYNAMIC = Symbol(``);\r\nconst V_ON_WITH_MODIFIERS = Symbol(``);\r\nconst V_ON_WITH_KEYS = Symbol(``);\r\nconst V_SHOW = Symbol(``);\r\nconst TRANSITION = Symbol(``);\r\nconst TRANSITION_GROUP = Symbol(``);\r\ncompilerCore.registerRuntimeHelpers({\r\n    [V_MODEL_RADIO]: `vModelRadio`,\r\n    [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n    [V_MODEL_TEXT]: `vModelText`,\r\n    [V_MODEL_SELECT]: `vModelSelect`,\r\n    [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n    [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n    [V_ON_WITH_KEYS]: `withKeys`,\r\n    [V_SHOW]: `vShow`,\r\n    [TRANSITION]: `Transition`,\r\n    [TRANSITION_GROUP]: `TransitionGroup`\r\n});\n\nvar namedCharacterReferences = {\n\tGT: \">\",\n\tgt: \">\",\n\tLT: \"<\",\n\tlt: \"<\",\n\t\"ac;\": \"\",\n\t\"af;\": \"\",\n\tAMP: \"&\",\n\tamp: \"&\",\n\t\"ap;\": \"\",\n\t\"DD;\": \"\",\n\t\"dd;\": \"\",\n\tdeg: \"\",\n\t\"ee;\": \"\",\n\t\"eg;\": \"\",\n\t\"el;\": \"\",\n\tETH: \"\",\n\teth: \"\",\n\t\"gE;\": \"\",\n\t\"ge;\": \"\",\n\t\"Gg;\": \"\",\n\t\"gg;\": \"\",\n\t\"gl;\": \"\",\n\t\"GT;\": \">\",\n\t\"Gt;\": \"\",\n\t\"gt;\": \">\",\n\t\"ic;\": \"\",\n\t\"ii;\": \"\",\n\t\"Im;\": \"\",\n\t\"in;\": \"\",\n\t\"it;\": \"\",\n\t\"lE;\": \"\",\n\t\"le;\": \"\",\n\t\"lg;\": \"\",\n\t\"Ll;\": \"\",\n\t\"ll;\": \"\",\n\t\"LT;\": \"<\",\n\t\"Lt;\": \"\",\n\t\"lt;\": \"<\",\n\t\"mp;\": \"\",\n\t\"Mu;\": \"\",\n\t\"mu;\": \"\",\n\t\"ne;\": \"\",\n\t\"ni;\": \"\",\n\tnot: \"\",\n\t\"Nu;\": \"\",\n\t\"nu;\": \"\",\n\t\"Or;\": \"\",\n\t\"or;\": \"\",\n\t\"oS;\": \"\",\n\t\"Pi;\": \"\",\n\t\"pi;\": \"\",\n\t\"pm;\": \"\",\n\t\"Pr;\": \"\",\n\t\"pr;\": \"\",\n\t\"Re;\": \"\",\n\tREG: \"\",\n\treg: \"\",\n\t\"rx;\": \"\",\n\t\"Sc;\": \"\",\n\t\"sc;\": \"\",\n\tshy: \"\",\n\tuml: \"\",\n\t\"wp;\": \"\",\n\t\"wr;\": \"\",\n\t\"Xi;\": \"\",\n\t\"xi;\": \"\",\n\tyen: \"\",\n\t\"acd;\": \"\",\n\t\"acE;\": \"\",\n\t\"Acy;\": \"\",\n\t\"acy;\": \"\",\n\t\"Afr;\": \"\",\n\t\"afr;\": \"\",\n\t\"AMP;\": \"&\",\n\t\"amp;\": \"&\",\n\t\"And;\": \"\",\n\t\"and;\": \"\",\n\t\"ang;\": \"\",\n\t\"apE;\": \"\",\n\t\"ape;\": \"\",\n\t\"ast;\": \"*\",\n\tAuml: \"\",\n\tauml: \"\",\n\t\"Bcy;\": \"\",\n\t\"bcy;\": \"\",\n\t\"Bfr;\": \"\",\n\t\"bfr;\": \"\",\n\t\"bne;\": \"=\",\n\t\"bot;\": \"\",\n\t\"Cap;\": \"\",\n\t\"cap;\": \"\",\n\tcent: \"\",\n\t\"Cfr;\": \"\",\n\t\"cfr;\": \"\",\n\t\"Chi;\": \"\",\n\t\"chi;\": \"\",\n\t\"cir;\": \"\",\n\tCOPY: \"\",\n\tcopy: \"\",\n\t\"Cup;\": \"\",\n\t\"cup;\": \"\",\n\t\"Dcy;\": \"\",\n\t\"dcy;\": \"\",\n\t\"deg;\": \"\",\n\t\"Del;\": \"\",\n\t\"Dfr;\": \"\",\n\t\"dfr;\": \"\",\n\t\"die;\": \"\",\n\t\"div;\": \"\",\n\t\"Dot;\": \"\",\n\t\"dot;\": \"\",\n\t\"Ecy;\": \"\",\n\t\"ecy;\": \"\",\n\t\"Efr;\": \"\",\n\t\"efr;\": \"\",\n\t\"egs;\": \"\",\n\t\"ell;\": \"\",\n\t\"els;\": \"\",\n\t\"ENG;\": \"\",\n\t\"eng;\": \"\",\n\t\"Eta;\": \"\",\n\t\"eta;\": \"\",\n\t\"ETH;\": \"\",\n\t\"eth;\": \"\",\n\tEuml: \"\",\n\teuml: \"\",\n\t\"Fcy;\": \"\",\n\t\"fcy;\": \"\",\n\t\"Ffr;\": \"\",\n\t\"ffr;\": \"\",\n\t\"gap;\": \"\",\n\t\"Gcy;\": \"\",\n\t\"gcy;\": \"\",\n\t\"gEl;\": \"\",\n\t\"gel;\": \"\",\n\t\"geq;\": \"\",\n\t\"ges;\": \"\",\n\t\"Gfr;\": \"\",\n\t\"gfr;\": \"\",\n\t\"ggg;\": \"\",\n\t\"gla;\": \"\",\n\t\"glE;\": \"\",\n\t\"glj;\": \"\",\n\t\"gnE;\": \"\",\n\t\"gne;\": \"\",\n\t\"Hat;\": \"^\",\n\t\"Hfr;\": \"\",\n\t\"hfr;\": \"\",\n\t\"Icy;\": \"\",\n\t\"icy;\": \"\",\n\t\"iff;\": \"\",\n\t\"Ifr;\": \"\",\n\t\"ifr;\": \"\",\n\t\"Int;\": \"\",\n\t\"int;\": \"\",\n\tIuml: \"\",\n\tiuml: \"\",\n\t\"Jcy;\": \"\",\n\t\"jcy;\": \"\",\n\t\"Jfr;\": \"\",\n\t\"jfr;\": \"\",\n\t\"Kcy;\": \"\",\n\t\"kcy;\": \"\",\n\t\"Kfr;\": \"\",\n\t\"kfr;\": \"\",\n\t\"lap;\": \"\",\n\t\"lat;\": \"\",\n\t\"Lcy;\": \"\",\n\t\"lcy;\": \"\",\n\t\"lEg;\": \"\",\n\t\"leg;\": \"\",\n\t\"leq;\": \"\",\n\t\"les;\": \"\",\n\t\"Lfr;\": \"\",\n\t\"lfr;\": \"\",\n\t\"lgE;\": \"\",\n\t\"lnE;\": \"\",\n\t\"lne;\": \"\",\n\t\"loz;\": \"\",\n\t\"lrm;\": \"\",\n\t\"Lsh;\": \"\",\n\t\"lsh;\": \"\",\n\tmacr: \"\",\n\t\"Map;\": \"\",\n\t\"map;\": \"\",\n\t\"Mcy;\": \"\",\n\t\"mcy;\": \"\",\n\t\"Mfr;\": \"\",\n\t\"mfr;\": \"\",\n\t\"mho;\": \"\",\n\t\"mid;\": \"\",\n\t\"nap;\": \"\",\n\tnbsp: \"\",\n\t\"Ncy;\": \"\",\n\t\"ncy;\": \"\",\n\t\"Nfr;\": \"\",\n\t\"nfr;\": \"\",\n\t\"ngE;\": \"\",\n\t\"nge;\": \"\",\n\t\"nGg;\": \"\",\n\t\"nGt;\": \"\",\n\t\"ngt;\": \"\",\n\t\"nis;\": \"\",\n\t\"niv;\": \"\",\n\t\"nlE;\": \"\",\n\t\"nle;\": \"\",\n\t\"nLl;\": \"\",\n\t\"nLt;\": \"\",\n\t\"nlt;\": \"\",\n\t\"Not;\": \"\",\n\t\"not;\": \"\",\n\t\"npr;\": \"\",\n\t\"nsc;\": \"\",\n\t\"num;\": \"#\",\n\t\"Ocy;\": \"\",\n\t\"ocy;\": \"\",\n\t\"Ofr;\": \"\",\n\t\"ofr;\": \"\",\n\t\"ogt;\": \"\",\n\t\"ohm;\": \"\",\n\t\"olt;\": \"\",\n\t\"ord;\": \"\",\n\tordf: \"\",\n\tordm: \"\",\n\t\"orv;\": \"\",\n\tOuml: \"\",\n\touml: \"\",\n\t\"par;\": \"\",\n\tpara: \"\",\n\t\"Pcy;\": \"\",\n\t\"pcy;\": \"\",\n\t\"Pfr;\": \"\",\n\t\"pfr;\": \"\",\n\t\"Phi;\": \"\",\n\t\"phi;\": \"\",\n\t\"piv;\": \"\",\n\t\"prE;\": \"\",\n\t\"pre;\": \"\",\n\t\"Psi;\": \"\",\n\t\"psi;\": \"\",\n\t\"Qfr;\": \"\",\n\t\"qfr;\": \"\",\n\tQUOT: \"\\\"\",\n\tquot: \"\\\"\",\n\t\"Rcy;\": \"\",\n\t\"rcy;\": \"\",\n\t\"REG;\": \"\",\n\t\"reg;\": \"\",\n\t\"Rfr;\": \"\",\n\t\"rfr;\": \"\",\n\t\"Rho;\": \"\",\n\t\"rho;\": \"\",\n\t\"rlm;\": \"\",\n\t\"Rsh;\": \"\",\n\t\"rsh;\": \"\",\n\t\"scE;\": \"\",\n\t\"sce;\": \"\",\n\t\"Scy;\": \"\",\n\t\"scy;\": \"\",\n\tsect: \"\",\n\t\"Sfr;\": \"\",\n\t\"sfr;\": \"\",\n\t\"shy;\": \"\",\n\t\"sim;\": \"\",\n\t\"smt;\": \"\",\n\t\"sol;\": \"/\",\n\t\"squ;\": \"\",\n\t\"Sub;\": \"\",\n\t\"sub;\": \"\",\n\t\"Sum;\": \"\",\n\t\"sum;\": \"\",\n\t\"Sup;\": \"\",\n\t\"sup;\": \"\",\n\tsup1: \"\",\n\tsup2: \"\",\n\tsup3: \"\",\n\t\"Tab;\": \"\\t\",\n\t\"Tau;\": \"\",\n\t\"tau;\": \"\",\n\t\"Tcy;\": \"\",\n\t\"tcy;\": \"\",\n\t\"Tfr;\": \"\",\n\t\"tfr;\": \"\",\n\t\"top;\": \"\",\n\t\"Ucy;\": \"\",\n\t\"ucy;\": \"\",\n\t\"Ufr;\": \"\",\n\t\"ufr;\": \"\",\n\t\"uml;\": \"\",\n\tUuml: \"\",\n\tuuml: \"\",\n\t\"Vcy;\": \"\",\n\t\"vcy;\": \"\",\n\t\"Vee;\": \"\",\n\t\"vee;\": \"\",\n\t\"Vfr;\": \"\",\n\t\"vfr;\": \"\",\n\t\"Wfr;\": \"\",\n\t\"wfr;\": \"\",\n\t\"Xfr;\": \"\",\n\t\"xfr;\": \"\",\n\t\"Ycy;\": \"\",\n\t\"ycy;\": \"\",\n\t\"yen;\": \"\",\n\t\"Yfr;\": \"\",\n\t\"yfr;\": \"\",\n\tyuml: \"\",\n\t\"Zcy;\": \"\",\n\t\"zcy;\": \"\",\n\t\"Zfr;\": \"\",\n\t\"zfr;\": \"\",\n\t\"zwj;\": \"\",\n\tAcirc: \"\",\n\tacirc: \"\",\n\tacute: \"\",\n\tAElig: \"\",\n\taelig: \"\",\n\t\"andd;\": \"\",\n\t\"andv;\": \"\",\n\t\"ange;\": \"\",\n\t\"Aopf;\": \"\",\n\t\"aopf;\": \"\",\n\t\"apid;\": \"\",\n\t\"apos;\": \"'\",\n\tAring: \"\",\n\taring: \"\",\n\t\"Ascr;\": \"\",\n\t\"ascr;\": \"\",\n\t\"Auml;\": \"\",\n\t\"auml;\": \"\",\n\t\"Barv;\": \"\",\n\t\"bbrk;\": \"\",\n\t\"Beta;\": \"\",\n\t\"beta;\": \"\",\n\t\"beth;\": \"\",\n\t\"bNot;\": \"\",\n\t\"bnot;\": \"\",\n\t\"Bopf;\": \"\",\n\t\"bopf;\": \"\",\n\t\"boxH;\": \"\",\n\t\"boxh;\": \"\",\n\t\"boxV;\": \"\",\n\t\"boxv;\": \"\",\n\t\"Bscr;\": \"\",\n\t\"bscr;\": \"\",\n\t\"bsim;\": \"\",\n\t\"bsol;\": \"\\\\\",\n\t\"bull;\": \"\",\n\t\"bump;\": \"\",\n\t\"caps;\": \"\",\n\t\"Cdot;\": \"\",\n\t\"cdot;\": \"\",\n\tcedil: \"\",\n\t\"cent;\": \"\",\n\t\"CHcy;\": \"\",\n\t\"chcy;\": \"\",\n\t\"circ;\": \"\",\n\t\"cirE;\": \"\",\n\t\"cire;\": \"\",\n\t\"comp;\": \"\",\n\t\"cong;\": \"\",\n\t\"Copf;\": \"\",\n\t\"copf;\": \"\",\n\t\"COPY;\": \"\",\n\t\"copy;\": \"\",\n\t\"Cscr;\": \"\",\n\t\"cscr;\": \"\",\n\t\"csub;\": \"\",\n\t\"csup;\": \"\",\n\t\"cups;\": \"\",\n\t\"Darr;\": \"\",\n\t\"dArr;\": \"\",\n\t\"darr;\": \"\",\n\t\"dash;\": \"\",\n\t\"dHar;\": \"\",\n\t\"diam;\": \"\",\n\t\"DJcy;\": \"\",\n\t\"djcy;\": \"\",\n\t\"Dopf;\": \"\",\n\t\"dopf;\": \"\",\n\t\"Dscr;\": \"\",\n\t\"dscr;\": \"\",\n\t\"DScy;\": \"\",\n\t\"dscy;\": \"\",\n\t\"dsol;\": \"\",\n\t\"dtri;\": \"\",\n\t\"DZcy;\": \"\",\n\t\"dzcy;\": \"\",\n\t\"ecir;\": \"\",\n\tEcirc: \"\",\n\tecirc: \"\",\n\t\"Edot;\": \"\",\n\t\"eDot;\": \"\",\n\t\"edot;\": \"\",\n\t\"emsp;\": \"\",\n\t\"ensp;\": \"\",\n\t\"Eopf;\": \"\",\n\t\"eopf;\": \"\",\n\t\"epar;\": \"\",\n\t\"epsi;\": \"\",\n\t\"Escr;\": \"\",\n\t\"escr;\": \"\",\n\t\"Esim;\": \"\",\n\t\"esim;\": \"\",\n\t\"Euml;\": \"\",\n\t\"euml;\": \"\",\n\t\"euro;\": \"\",\n\t\"excl;\": \"!\",\n\t\"flat;\": \"\",\n\t\"fnof;\": \"\",\n\t\"Fopf;\": \"\",\n\t\"fopf;\": \"\",\n\t\"fork;\": \"\",\n\t\"Fscr;\": \"\",\n\t\"fscr;\": \"\",\n\t\"Gdot;\": \"\",\n\t\"gdot;\": \"\",\n\t\"geqq;\": \"\",\n\t\"gesl;\": \"\",\n\t\"GJcy;\": \"\",\n\t\"gjcy;\": \"\",\n\t\"gnap;\": \"\",\n\t\"gneq;\": \"\",\n\t\"Gopf;\": \"\",\n\t\"gopf;\": \"\",\n\t\"Gscr;\": \"\",\n\t\"gscr;\": \"\",\n\t\"gsim;\": \"\",\n\t\"gtcc;\": \"\",\n\t\"gvnE;\": \"\",\n\t\"half;\": \"\",\n\t\"hArr;\": \"\",\n\t\"harr;\": \"\",\n\t\"hbar;\": \"\",\n\t\"Hopf;\": \"\",\n\t\"hopf;\": \"\",\n\t\"Hscr;\": \"\",\n\t\"hscr;\": \"\",\n\tIcirc: \"\",\n\ticirc: \"\",\n\t\"Idot;\": \"\",\n\t\"IEcy;\": \"\",\n\t\"iecy;\": \"\",\n\tiexcl: \"\",\n\t\"imof;\": \"\",\n\t\"IOcy;\": \"\",\n\t\"iocy;\": \"\",\n\t\"Iopf;\": \"\",\n\t\"iopf;\": \"\",\n\t\"Iota;\": \"\",\n\t\"iota;\": \"\",\n\t\"Iscr;\": \"\",\n\t\"iscr;\": \"\",\n\t\"isin;\": \"\",\n\t\"Iuml;\": \"\",\n\t\"iuml;\": \"\",\n\t\"Jopf;\": \"\",\n\t\"jopf;\": \"\",\n\t\"Jscr;\": \"\",\n\t\"jscr;\": \"\",\n\t\"KHcy;\": \"\",\n\t\"khcy;\": \"\",\n\t\"KJcy;\": \"\",\n\t\"kjcy;\": \"\",\n\t\"Kopf;\": \"\",\n\t\"kopf;\": \"\",\n\t\"Kscr;\": \"\",\n\t\"kscr;\": \"\",\n\t\"Lang;\": \"\",\n\t\"lang;\": \"\",\n\tlaquo: \"\",\n\t\"Larr;\": \"\",\n\t\"lArr;\": \"\",\n\t\"larr;\": \"\",\n\t\"late;\": \"\",\n\t\"lcub;\": \"{\",\n\t\"ldca;\": \"\",\n\t\"ldsh;\": \"\",\n\t\"leqq;\": \"\",\n\t\"lesg;\": \"\",\n\t\"lHar;\": \"\",\n\t\"LJcy;\": \"\",\n\t\"ljcy;\": \"\",\n\t\"lnap;\": \"\",\n\t\"lneq;\": \"\",\n\t\"Lopf;\": \"\",\n\t\"lopf;\": \"\",\n\t\"lozf;\": \"\",\n\t\"lpar;\": \"(\",\n\t\"Lscr;\": \"\",\n\t\"lscr;\": \"\",\n\t\"lsim;\": \"\",\n\t\"lsqb;\": \"[\",\n\t\"ltcc;\": \"\",\n\t\"ltri;\": \"\",\n\t\"lvnE;\": \"\",\n\t\"macr;\": \"\",\n\t\"male;\": \"\",\n\t\"malt;\": \"\",\n\tmicro: \"\",\n\t\"mlcp;\": \"\",\n\t\"mldr;\": \"\",\n\t\"Mopf;\": \"\",\n\t\"mopf;\": \"\",\n\t\"Mscr;\": \"\",\n\t\"mscr;\": \"\",\n\t\"nang;\": \"\",\n\t\"napE;\": \"\",\n\t\"nbsp;\": \"\",\n\t\"ncap;\": \"\",\n\t\"ncup;\": \"\",\n\t\"ngeq;\": \"\",\n\t\"nges;\": \"\",\n\t\"ngtr;\": \"\",\n\t\"nGtv;\": \"\",\n\t\"nisd;\": \"\",\n\t\"NJcy;\": \"\",\n\t\"njcy;\": \"\",\n\t\"nldr;\": \"\",\n\t\"nleq;\": \"\",\n\t\"nles;\": \"\",\n\t\"nLtv;\": \"\",\n\t\"nmid;\": \"\",\n\t\"Nopf;\": \"\",\n\t\"nopf;\": \"\",\n\t\"npar;\": \"\",\n\t\"npre;\": \"\",\n\t\"nsce;\": \"\",\n\t\"Nscr;\": \"\",\n\t\"nscr;\": \"\",\n\t\"nsim;\": \"\",\n\t\"nsub;\": \"\",\n\t\"nsup;\": \"\",\n\t\"ntgl;\": \"\",\n\t\"ntlg;\": \"\",\n\t\"nvap;\": \"\",\n\t\"nvge;\": \"\",\n\t\"nvgt;\": \">\",\n\t\"nvle;\": \"\",\n\t\"nvlt;\": \"<\",\n\t\"oast;\": \"\",\n\t\"ocir;\": \"\",\n\tOcirc: \"\",\n\tocirc: \"\",\n\t\"odiv;\": \"\",\n\t\"odot;\": \"\",\n\t\"ogon;\": \"\",\n\t\"oint;\": \"\",\n\t\"omid;\": \"\",\n\t\"Oopf;\": \"\",\n\t\"oopf;\": \"\",\n\t\"opar;\": \"\",\n\t\"ordf;\": \"\",\n\t\"ordm;\": \"\",\n\t\"oror;\": \"\",\n\t\"Oscr;\": \"\",\n\t\"oscr;\": \"\",\n\t\"osol;\": \"\",\n\t\"Ouml;\": \"\",\n\t\"ouml;\": \"\",\n\t\"para;\": \"\",\n\t\"part;\": \"\",\n\t\"perp;\": \"\",\n\t\"phiv;\": \"\",\n\t\"plus;\": \"+\",\n\t\"Popf;\": \"\",\n\t\"popf;\": \"\",\n\tpound: \"\",\n\t\"prap;\": \"\",\n\t\"prec;\": \"\",\n\t\"prnE;\": \"\",\n\t\"prod;\": \"\",\n\t\"prop;\": \"\",\n\t\"Pscr;\": \"\",\n\t\"pscr;\": \"\",\n\t\"qint;\": \"\",\n\t\"Qopf;\": \"\",\n\t\"qopf;\": \"\",\n\t\"Qscr;\": \"\",\n\t\"qscr;\": \"\",\n\t\"QUOT;\": \"\\\"\",\n\t\"quot;\": \"\\\"\",\n\t\"race;\": \"\",\n\t\"Rang;\": \"\",\n\t\"rang;\": \"\",\n\traquo: \"\",\n\t\"Rarr;\": \"\",\n\t\"rArr;\": \"\",\n\t\"rarr;\": \"\",\n\t\"rcub;\": \"}\",\n\t\"rdca;\": \"\",\n\t\"rdsh;\": \"\",\n\t\"real;\": \"\",\n\t\"rect;\": \"\",\n\t\"rHar;\": \"\",\n\t\"rhov;\": \"\",\n\t\"ring;\": \"\",\n\t\"Ropf;\": \"\",\n\t\"ropf;\": \"\",\n\t\"rpar;\": \")\",\n\t\"Rscr;\": \"\",\n\t\"rscr;\": \"\",\n\t\"rsqb;\": \"]\",\n\t\"rtri;\": \"\",\n\t\"scap;\": \"\",\n\t\"scnE;\": \"\",\n\t\"sdot;\": \"\",\n\t\"sect;\": \"\",\n\t\"semi;\": \";\",\n\t\"sext;\": \"\",\n\t\"SHcy;\": \"\",\n\t\"shcy;\": \"\",\n\t\"sime;\": \"\",\n\t\"simg;\": \"\",\n\t\"siml;\": \"\",\n\t\"smid;\": \"\",\n\t\"smte;\": \"\",\n\t\"solb;\": \"\",\n\t\"Sopf;\": \"\",\n\t\"sopf;\": \"\",\n\t\"spar;\": \"\",\n\t\"Sqrt;\": \"\",\n\t\"squf;\": \"\",\n\t\"Sscr;\": \"\",\n\t\"sscr;\": \"\",\n\t\"Star;\": \"\",\n\t\"star;\": \"\",\n\t\"subE;\": \"\",\n\t\"sube;\": \"\",\n\t\"succ;\": \"\",\n\t\"sung;\": \"\",\n\t\"sup1;\": \"\",\n\t\"sup2;\": \"\",\n\t\"sup3;\": \"\",\n\t\"supE;\": \"\",\n\t\"supe;\": \"\",\n\tszlig: \"\",\n\t\"tbrk;\": \"\",\n\t\"tdot;\": \"\",\n\tTHORN: \"\",\n\tthorn: \"\",\n\ttimes: \"\",\n\t\"tint;\": \"\",\n\t\"toea;\": \"\",\n\t\"Topf;\": \"\",\n\t\"topf;\": \"\",\n\t\"tosa;\": \"\",\n\t\"trie;\": \"\",\n\t\"Tscr;\": \"\",\n\t\"tscr;\": \"\",\n\t\"TScy;\": \"\",\n\t\"tscy;\": \"\",\n\t\"Uarr;\": \"\",\n\t\"uArr;\": \"\",\n\t\"uarr;\": \"\",\n\tUcirc: \"\",\n\tucirc: \"\",\n\t\"uHar;\": \"\",\n\t\"Uopf;\": \"\",\n\t\"uopf;\": \"\",\n\t\"Upsi;\": \"\",\n\t\"upsi;\": \"\",\n\t\"Uscr;\": \"\",\n\t\"uscr;\": \"\",\n\t\"utri;\": \"\",\n\t\"Uuml;\": \"\",\n\t\"uuml;\": \"\",\n\t\"vArr;\": \"\",\n\t\"varr;\": \"\",\n\t\"Vbar;\": \"\",\n\t\"vBar;\": \"\",\n\t\"Vert;\": \"\",\n\t\"vert;\": \"|\",\n\t\"Vopf;\": \"\",\n\t\"vopf;\": \"\",\n\t\"Vscr;\": \"\",\n\t\"vscr;\": \"\",\n\t\"Wopf;\": \"\",\n\t\"wopf;\": \"\",\n\t\"Wscr;\": \"\",\n\t\"wscr;\": \"\",\n\t\"xcap;\": \"\",\n\t\"xcup;\": \"\",\n\t\"xmap;\": \"\",\n\t\"xnis;\": \"\",\n\t\"Xopf;\": \"\",\n\t\"xopf;\": \"\",\n\t\"Xscr;\": \"\",\n\t\"xscr;\": \"\",\n\t\"xvee;\": \"\",\n\t\"YAcy;\": \"\",\n\t\"yacy;\": \"\",\n\t\"YIcy;\": \"\",\n\t\"yicy;\": \"\",\n\t\"Yopf;\": \"\",\n\t\"yopf;\": \"\",\n\t\"Yscr;\": \"\",\n\t\"yscr;\": \"\",\n\t\"YUcy;\": \"\",\n\t\"yucy;\": \"\",\n\t\"Yuml;\": \"\",\n\t\"yuml;\": \"\",\n\t\"Zdot;\": \"\",\n\t\"zdot;\": \"\",\n\t\"Zeta;\": \"\",\n\t\"zeta;\": \"\",\n\t\"ZHcy;\": \"\",\n\t\"zhcy;\": \"\",\n\t\"Zopf;\": \"\",\n\t\"zopf;\": \"\",\n\t\"Zscr;\": \"\",\n\t\"zscr;\": \"\",\n\t\"zwnj;\": \"\",\n\tAacute: \"\",\n\taacute: \"\",\n\t\"Acirc;\": \"\",\n\t\"acirc;\": \"\",\n\t\"acute;\": \"\",\n\t\"AElig;\": \"\",\n\t\"aelig;\": \"\",\n\tAgrave: \"\",\n\tagrave: \"\",\n\t\"aleph;\": \"\",\n\t\"Alpha;\": \"\",\n\t\"alpha;\": \"\",\n\t\"Amacr;\": \"\",\n\t\"amacr;\": \"\",\n\t\"amalg;\": \"\",\n\t\"angle;\": \"\",\n\t\"angrt;\": \"\",\n\t\"angst;\": \"\",\n\t\"Aogon;\": \"\",\n\t\"aogon;\": \"\",\n\t\"Aring;\": \"\",\n\t\"aring;\": \"\",\n\t\"asymp;\": \"\",\n\tAtilde: \"\",\n\tatilde: \"\",\n\t\"awint;\": \"\",\n\t\"bcong;\": \"\",\n\t\"bdquo;\": \"\",\n\t\"bepsi;\": \"\",\n\t\"blank;\": \"\",\n\t\"blk12;\": \"\",\n\t\"blk14;\": \"\",\n\t\"blk34;\": \"\",\n\t\"block;\": \"\",\n\t\"boxDL;\": \"\",\n\t\"boxDl;\": \"\",\n\t\"boxdL;\": \"\",\n\t\"boxdl;\": \"\",\n\t\"boxDR;\": \"\",\n\t\"boxDr;\": \"\",\n\t\"boxdR;\": \"\",\n\t\"boxdr;\": \"\",\n\t\"boxHD;\": \"\",\n\t\"boxHd;\": \"\",\n\t\"boxhD;\": \"\",\n\t\"boxhd;\": \"\",\n\t\"boxHU;\": \"\",\n\t\"boxHu;\": \"\",\n\t\"boxhU;\": \"\",\n\t\"boxhu;\": \"\",\n\t\"boxUL;\": \"\",\n\t\"boxUl;\": \"\",\n\t\"boxuL;\": \"\",\n\t\"boxul;\": \"\",\n\t\"boxUR;\": \"\",\n\t\"boxUr;\": \"\",\n\t\"boxuR;\": \"\",\n\t\"boxur;\": \"\",\n\t\"boxVH;\": \"\",\n\t\"boxVh;\": \"\",\n\t\"boxvH;\": \"\",\n\t\"boxvh;\": \"\",\n\t\"boxVL;\": \"\",\n\t\"boxVl;\": \"\",\n\t\"boxvL;\": \"\",\n\t\"boxvl;\": \"\",\n\t\"boxVR;\": \"\",\n\t\"boxVr;\": \"\",\n\t\"boxvR;\": \"\",\n\t\"boxvr;\": \"\",\n\t\"Breve;\": \"\",\n\t\"breve;\": \"\",\n\tbrvbar: \"\",\n\t\"bsemi;\": \"\",\n\t\"bsime;\": \"\",\n\t\"bsolb;\": \"\",\n\t\"bumpE;\": \"\",\n\t\"bumpe;\": \"\",\n\t\"caret;\": \"\",\n\t\"caron;\": \"\",\n\t\"ccaps;\": \"\",\n\tCcedil: \"\",\n\tccedil: \"\",\n\t\"Ccirc;\": \"\",\n\t\"ccirc;\": \"\",\n\t\"ccups;\": \"\",\n\t\"cedil;\": \"\",\n\t\"check;\": \"\",\n\t\"clubs;\": \"\",\n\t\"Colon;\": \"\",\n\t\"colon;\": \":\",\n\t\"comma;\": \",\",\n\t\"crarr;\": \"\",\n\t\"Cross;\": \"\",\n\t\"cross;\": \"\",\n\t\"csube;\": \"\",\n\t\"csupe;\": \"\",\n\t\"ctdot;\": \"\",\n\t\"cuepr;\": \"\",\n\t\"cuesc;\": \"\",\n\t\"cupor;\": \"\",\n\tcurren: \"\",\n\t\"cuvee;\": \"\",\n\t\"cuwed;\": \"\",\n\t\"cwint;\": \"\",\n\t\"Dashv;\": \"\",\n\t\"dashv;\": \"\",\n\t\"dblac;\": \"\",\n\t\"ddarr;\": \"\",\n\t\"Delta;\": \"\",\n\t\"delta;\": \"\",\n\t\"dharl;\": \"\",\n\t\"dharr;\": \"\",\n\t\"diams;\": \"\",\n\t\"disin;\": \"\",\n\tdivide: \"\",\n\t\"doteq;\": \"\",\n\t\"dtdot;\": \"\",\n\t\"dtrif;\": \"\",\n\t\"duarr;\": \"\",\n\t\"duhar;\": \"\",\n\tEacute: \"\",\n\teacute: \"\",\n\t\"Ecirc;\": \"\",\n\t\"ecirc;\": \"\",\n\t\"eDDot;\": \"\",\n\t\"efDot;\": \"\",\n\tEgrave: \"\",\n\tegrave: \"\",\n\t\"Emacr;\": \"\",\n\t\"emacr;\": \"\",\n\t\"empty;\": \"\",\n\t\"Eogon;\": \"\",\n\t\"eogon;\": \"\",\n\t\"eplus;\": \"\",\n\t\"epsiv;\": \"\",\n\t\"eqsim;\": \"\",\n\t\"Equal;\": \"\",\n\t\"equiv;\": \"\",\n\t\"erarr;\": \"\",\n\t\"erDot;\": \"\",\n\t\"esdot;\": \"\",\n\t\"exist;\": \"\",\n\t\"fflig;\": \"\",\n\t\"filig;\": \"\",\n\t\"fjlig;\": \"fj\",\n\t\"fllig;\": \"\",\n\t\"fltns;\": \"\",\n\t\"forkv;\": \"\",\n\tfrac12: \"\",\n\tfrac14: \"\",\n\tfrac34: \"\",\n\t\"frasl;\": \"\",\n\t\"frown;\": \"\",\n\t\"Gamma;\": \"\",\n\t\"gamma;\": \"\",\n\t\"Gcirc;\": \"\",\n\t\"gcirc;\": \"\",\n\t\"gescc;\": \"\",\n\t\"gimel;\": \"\",\n\t\"gneqq;\": \"\",\n\t\"gnsim;\": \"\",\n\t\"grave;\": \"`\",\n\t\"gsime;\": \"\",\n\t\"gsiml;\": \"\",\n\t\"gtcir;\": \"\",\n\t\"gtdot;\": \"\",\n\t\"Hacek;\": \"\",\n\t\"harrw;\": \"\",\n\t\"Hcirc;\": \"\",\n\t\"hcirc;\": \"\",\n\t\"hoarr;\": \"\",\n\tIacute: \"\",\n\tiacute: \"\",\n\t\"Icirc;\": \"\",\n\t\"icirc;\": \"\",\n\t\"iexcl;\": \"\",\n\tIgrave: \"\",\n\tigrave: \"\",\n\t\"iiint;\": \"\",\n\t\"iiota;\": \"\",\n\t\"IJlig;\": \"\",\n\t\"ijlig;\": \"\",\n\t\"Imacr;\": \"\",\n\t\"imacr;\": \"\",\n\t\"image;\": \"\",\n\t\"imath;\": \"\",\n\t\"imped;\": \"\",\n\t\"infin;\": \"\",\n\t\"Iogon;\": \"\",\n\t\"iogon;\": \"\",\n\t\"iprod;\": \"\",\n\tiquest: \"\",\n\t\"isinE;\": \"\",\n\t\"isins;\": \"\",\n\t\"isinv;\": \"\",\n\t\"Iukcy;\": \"\",\n\t\"iukcy;\": \"\",\n\t\"Jcirc;\": \"\",\n\t\"jcirc;\": \"\",\n\t\"jmath;\": \"\",\n\t\"Jukcy;\": \"\",\n\t\"jukcy;\": \"\",\n\t\"Kappa;\": \"\",\n\t\"kappa;\": \"\",\n\t\"lAarr;\": \"\",\n\t\"langd;\": \"\",\n\t\"laquo;\": \"\",\n\t\"larrb;\": \"\",\n\t\"lates;\": \"\",\n\t\"lBarr;\": \"\",\n\t\"lbarr;\": \"\",\n\t\"lbbrk;\": \"\",\n\t\"lbrke;\": \"\",\n\t\"lceil;\": \"\",\n\t\"ldquo;\": \"\",\n\t\"lescc;\": \"\",\n\t\"lhard;\": \"\",\n\t\"lharu;\": \"\",\n\t\"lhblk;\": \"\",\n\t\"llarr;\": \"\",\n\t\"lltri;\": \"\",\n\t\"lneqq;\": \"\",\n\t\"lnsim;\": \"\",\n\t\"loang;\": \"\",\n\t\"loarr;\": \"\",\n\t\"lobrk;\": \"\",\n\t\"lopar;\": \"\",\n\t\"lrarr;\": \"\",\n\t\"lrhar;\": \"\",\n\t\"lrtri;\": \"\",\n\t\"lsime;\": \"\",\n\t\"lsimg;\": \"\",\n\t\"lsquo;\": \"\",\n\t\"ltcir;\": \"\",\n\t\"ltdot;\": \"\",\n\t\"ltrie;\": \"\",\n\t\"ltrif;\": \"\",\n\t\"mdash;\": \"\",\n\t\"mDDot;\": \"\",\n\t\"micro;\": \"\",\n\tmiddot: \"\",\n\t\"minus;\": \"\",\n\t\"mumap;\": \"\",\n\t\"nabla;\": \"\",\n\t\"napid;\": \"\",\n\t\"napos;\": \"\",\n\t\"natur;\": \"\",\n\t\"nbump;\": \"\",\n\t\"ncong;\": \"\",\n\t\"ndash;\": \"\",\n\t\"neArr;\": \"\",\n\t\"nearr;\": \"\",\n\t\"nedot;\": \"\",\n\t\"nesim;\": \"\",\n\t\"ngeqq;\": \"\",\n\t\"ngsim;\": \"\",\n\t\"nhArr;\": \"\",\n\t\"nharr;\": \"\",\n\t\"nhpar;\": \"\",\n\t\"nlArr;\": \"\",\n\t\"nlarr;\": \"\",\n\t\"nleqq;\": \"\",\n\t\"nless;\": \"\",\n\t\"nlsim;\": \"\",\n\t\"nltri;\": \"\",\n\t\"notin;\": \"\",\n\t\"notni;\": \"\",\n\t\"npart;\": \"\",\n\t\"nprec;\": \"\",\n\t\"nrArr;\": \"\",\n\t\"nrarr;\": \"\",\n\t\"nrtri;\": \"\",\n\t\"nsime;\": \"\",\n\t\"nsmid;\": \"\",\n\t\"nspar;\": \"\",\n\t\"nsubE;\": \"\",\n\t\"nsube;\": \"\",\n\t\"nsucc;\": \"\",\n\t\"nsupE;\": \"\",\n\t\"nsupe;\": \"\",\n\tNtilde: \"\",\n\tntilde: \"\",\n\t\"numsp;\": \"\",\n\t\"nvsim;\": \"\",\n\t\"nwArr;\": \"\",\n\t\"nwarr;\": \"\",\n\tOacute: \"\",\n\toacute: \"\",\n\t\"Ocirc;\": \"\",\n\t\"ocirc;\": \"\",\n\t\"odash;\": \"\",\n\t\"OElig;\": \"\",\n\t\"oelig;\": \"\",\n\t\"ofcir;\": \"\",\n\tOgrave: \"\",\n\tograve: \"\",\n\t\"ohbar;\": \"\",\n\t\"olarr;\": \"\",\n\t\"olcir;\": \"\",\n\t\"oline;\": \"\",\n\t\"Omacr;\": \"\",\n\t\"omacr;\": \"\",\n\t\"Omega;\": \"\",\n\t\"omega;\": \"\",\n\t\"operp;\": \"\",\n\t\"oplus;\": \"\",\n\t\"orarr;\": \"\",\n\t\"order;\": \"\",\n\tOslash: \"\",\n\toslash: \"\",\n\tOtilde: \"\",\n\totilde: \"\",\n\t\"ovbar;\": \"\",\n\t\"parsl;\": \"\",\n\t\"phone;\": \"\",\n\t\"plusb;\": \"\",\n\t\"pluse;\": \"\",\n\tplusmn: \"\",\n\t\"pound;\": \"\",\n\t\"prcue;\": \"\",\n\t\"Prime;\": \"\",\n\t\"prime;\": \"\",\n\t\"prnap;\": \"\",\n\t\"prsim;\": \"\",\n\t\"quest;\": \"?\",\n\t\"rAarr;\": \"\",\n\t\"radic;\": \"\",\n\t\"rangd;\": \"\",\n\t\"range;\": \"\",\n\t\"raquo;\": \"\",\n\t\"rarrb;\": \"\",\n\t\"rarrc;\": \"\",\n\t\"rarrw;\": \"\",\n\t\"ratio;\": \"\",\n\t\"RBarr;\": \"\",\n\t\"rBarr;\": \"\",\n\t\"rbarr;\": \"\",\n\t\"rbbrk;\": \"\",\n\t\"rbrke;\": \"\",\n\t\"rceil;\": \"\",\n\t\"rdquo;\": \"\",\n\t\"reals;\": \"\",\n\t\"rhard;\": \"\",\n\t\"rharu;\": \"\",\n\t\"rlarr;\": \"\",\n\t\"rlhar;\": \"\",\n\t\"rnmid;\": \"\",\n\t\"roang;\": \"\",\n\t\"roarr;\": \"\",\n\t\"robrk;\": \"\",\n\t\"ropar;\": \"\",\n\t\"rrarr;\": \"\",\n\t\"rsquo;\": \"\",\n\t\"rtrie;\": \"\",\n\t\"rtrif;\": \"\",\n\t\"sbquo;\": \"\",\n\t\"sccue;\": \"\",\n\t\"Scirc;\": \"\",\n\t\"scirc;\": \"\",\n\t\"scnap;\": \"\",\n\t\"scsim;\": \"\",\n\t\"sdotb;\": \"\",\n\t\"sdote;\": \"\",\n\t\"seArr;\": \"\",\n\t\"searr;\": \"\",\n\t\"setmn;\": \"\",\n\t\"sharp;\": \"\",\n\t\"Sigma;\": \"\",\n\t\"sigma;\": \"\",\n\t\"simeq;\": \"\",\n\t\"simgE;\": \"\",\n\t\"simlE;\": \"\",\n\t\"simne;\": \"\",\n\t\"slarr;\": \"\",\n\t\"smile;\": \"\",\n\t\"smtes;\": \"\",\n\t\"sqcap;\": \"\",\n\t\"sqcup;\": \"\",\n\t\"sqsub;\": \"\",\n\t\"sqsup;\": \"\",\n\t\"srarr;\": \"\",\n\t\"starf;\": \"\",\n\t\"strns;\": \"\",\n\t\"subnE;\": \"\",\n\t\"subne;\": \"\",\n\t\"supnE;\": \"\",\n\t\"supne;\": \"\",\n\t\"swArr;\": \"\",\n\t\"swarr;\": \"\",\n\t\"szlig;\": \"\",\n\t\"Theta;\": \"\",\n\t\"theta;\": \"\",\n\t\"thkap;\": \"\",\n\t\"THORN;\": \"\",\n\t\"thorn;\": \"\",\n\t\"Tilde;\": \"\",\n\t\"tilde;\": \"\",\n\t\"times;\": \"\",\n\t\"TRADE;\": \"\",\n\t\"trade;\": \"\",\n\t\"trisb;\": \"\",\n\t\"TSHcy;\": \"\",\n\t\"tshcy;\": \"\",\n\t\"twixt;\": \"\",\n\tUacute: \"\",\n\tuacute: \"\",\n\t\"Ubrcy;\": \"\",\n\t\"ubrcy;\": \"\",\n\t\"Ucirc;\": \"\",\n\t\"ucirc;\": \"\",\n\t\"udarr;\": \"\",\n\t\"udhar;\": \"\",\n\tUgrave: \"\",\n\tugrave: \"\",\n\t\"uharl;\": \"\",\n\t\"uharr;\": \"\",\n\t\"uhblk;\": \"\",\n\t\"ultri;\": \"\",\n\t\"Umacr;\": \"\",\n\t\"umacr;\": \"\",\n\t\"Union;\": \"\",\n\t\"Uogon;\": \"\",\n\t\"uogon;\": \"\",\n\t\"uplus;\": \"\",\n\t\"upsih;\": \"\",\n\t\"UpTee;\": \"\",\n\t\"Uring;\": \"\",\n\t\"uring;\": \"\",\n\t\"urtri;\": \"\",\n\t\"utdot;\": \"\",\n\t\"utrif;\": \"\",\n\t\"uuarr;\": \"\",\n\t\"varpi;\": \"\",\n\t\"vBarv;\": \"\",\n\t\"VDash;\": \"\",\n\t\"Vdash;\": \"\",\n\t\"vDash;\": \"\",\n\t\"vdash;\": \"\",\n\t\"veeeq;\": \"\",\n\t\"vltri;\": \"\",\n\t\"vnsub;\": \"\",\n\t\"vnsup;\": \"\",\n\t\"vprop;\": \"\",\n\t\"vrtri;\": \"\",\n\t\"Wcirc;\": \"\",\n\t\"wcirc;\": \"\",\n\t\"Wedge;\": \"\",\n\t\"wedge;\": \"\",\n\t\"xcirc;\": \"\",\n\t\"xdtri;\": \"\",\n\t\"xhArr;\": \"\",\n\t\"xharr;\": \"\",\n\t\"xlArr;\": \"\",\n\t\"xlarr;\": \"\",\n\t\"xodot;\": \"\",\n\t\"xrArr;\": \"\",\n\t\"xrarr;\": \"\",\n\t\"xutri;\": \"\",\n\tYacute: \"\",\n\tyacute: \"\",\n\t\"Ycirc;\": \"\",\n\t\"ycirc;\": \"\",\n\t\"Aacute;\": \"\",\n\t\"aacute;\": \"\",\n\t\"Abreve;\": \"\",\n\t\"abreve;\": \"\",\n\t\"Agrave;\": \"\",\n\t\"agrave;\": \"\",\n\t\"andand;\": \"\",\n\t\"angmsd;\": \"\",\n\t\"angsph;\": \"\",\n\t\"apacir;\": \"\",\n\t\"approx;\": \"\",\n\t\"Assign;\": \"\",\n\t\"Atilde;\": \"\",\n\t\"atilde;\": \"\",\n\t\"barvee;\": \"\",\n\t\"Barwed;\": \"\",\n\t\"barwed;\": \"\",\n\t\"becaus;\": \"\",\n\t\"bernou;\": \"\",\n\t\"bigcap;\": \"\",\n\t\"bigcup;\": \"\",\n\t\"bigvee;\": \"\",\n\t\"bkarow;\": \"\",\n\t\"bottom;\": \"\",\n\t\"bowtie;\": \"\",\n\t\"boxbox;\": \"\",\n\t\"bprime;\": \"\",\n\t\"brvbar;\": \"\",\n\t\"bullet;\": \"\",\n\t\"Bumpeq;\": \"\",\n\t\"bumpeq;\": \"\",\n\t\"Cacute;\": \"\",\n\t\"cacute;\": \"\",\n\t\"capand;\": \"\",\n\t\"capcap;\": \"\",\n\t\"capcup;\": \"\",\n\t\"capdot;\": \"\",\n\t\"Ccaron;\": \"\",\n\t\"ccaron;\": \"\",\n\t\"Ccedil;\": \"\",\n\t\"ccedil;\": \"\",\n\t\"circeq;\": \"\",\n\t\"cirmid;\": \"\",\n\t\"Colone;\": \"\",\n\t\"colone;\": \"\",\n\t\"commat;\": \"@\",\n\t\"compfn;\": \"\",\n\t\"Conint;\": \"\",\n\t\"conint;\": \"\",\n\t\"coprod;\": \"\",\n\t\"copysr;\": \"\",\n\t\"cularr;\": \"\",\n\t\"CupCap;\": \"\",\n\t\"cupcap;\": \"\",\n\t\"cupcup;\": \"\",\n\t\"cupdot;\": \"\",\n\t\"curarr;\": \"\",\n\t\"curren;\": \"\",\n\t\"cylcty;\": \"\",\n\t\"Dagger;\": \"\",\n\t\"dagger;\": \"\",\n\t\"daleth;\": \"\",\n\t\"Dcaron;\": \"\",\n\t\"dcaron;\": \"\",\n\t\"dfisht;\": \"\",\n\t\"divide;\": \"\",\n\t\"divonx;\": \"\",\n\t\"dlcorn;\": \"\",\n\t\"dlcrop;\": \"\",\n\t\"dollar;\": \"$\",\n\t\"DotDot;\": \"\",\n\t\"drcorn;\": \"\",\n\t\"drcrop;\": \"\",\n\t\"Dstrok;\": \"\",\n\t\"dstrok;\": \"\",\n\t\"Eacute;\": \"\",\n\t\"eacute;\": \"\",\n\t\"easter;\": \"\",\n\t\"Ecaron;\": \"\",\n\t\"ecaron;\": \"\",\n\t\"ecolon;\": \"\",\n\t\"Egrave;\": \"\",\n\t\"egrave;\": \"\",\n\t\"egsdot;\": \"\",\n\t\"elsdot;\": \"\",\n\t\"emptyv;\": \"\",\n\t\"emsp13;\": \"\",\n\t\"emsp14;\": \"\",\n\t\"eparsl;\": \"\",\n\t\"eqcirc;\": \"\",\n\t\"equals;\": \"=\",\n\t\"equest;\": \"\",\n\t\"Exists;\": \"\",\n\t\"female;\": \"\",\n\t\"ffilig;\": \"\",\n\t\"ffllig;\": \"\",\n\t\"ForAll;\": \"\",\n\t\"forall;\": \"\",\n\t\"frac12;\": \"\",\n\t\"frac13;\": \"\",\n\t\"frac14;\": \"\",\n\t\"frac15;\": \"\",\n\t\"frac16;\": \"\",\n\t\"frac18;\": \"\",\n\t\"frac23;\": \"\",\n\t\"frac25;\": \"\",\n\t\"frac34;\": \"\",\n\t\"frac35;\": \"\",\n\t\"frac38;\": \"\",\n\t\"frac45;\": \"\",\n\t\"frac56;\": \"\",\n\t\"frac58;\": \"\",\n\t\"frac78;\": \"\",\n\t\"gacute;\": \"\",\n\t\"Gammad;\": \"\",\n\t\"gammad;\": \"\",\n\t\"Gbreve;\": \"\",\n\t\"gbreve;\": \"\",\n\t\"Gcedil;\": \"\",\n\t\"gesdot;\": \"\",\n\t\"gesles;\": \"\",\n\t\"gtlPar;\": \"\",\n\t\"gtrarr;\": \"\",\n\t\"gtrdot;\": \"\",\n\t\"gtrsim;\": \"\",\n\t\"hairsp;\": \"\",\n\t\"hamilt;\": \"\",\n\t\"HARDcy;\": \"\",\n\t\"hardcy;\": \"\",\n\t\"hearts;\": \"\",\n\t\"hellip;\": \"\",\n\t\"hercon;\": \"\",\n\t\"homtht;\": \"\",\n\t\"horbar;\": \"\",\n\t\"hslash;\": \"\",\n\t\"Hstrok;\": \"\",\n\t\"hstrok;\": \"\",\n\t\"hybull;\": \"\",\n\t\"hyphen;\": \"\",\n\t\"Iacute;\": \"\",\n\t\"iacute;\": \"\",\n\t\"Igrave;\": \"\",\n\t\"igrave;\": \"\",\n\t\"iiiint;\": \"\",\n\t\"iinfin;\": \"\",\n\t\"incare;\": \"\",\n\t\"inodot;\": \"\",\n\t\"intcal;\": \"\",\n\t\"iquest;\": \"\",\n\t\"isinsv;\": \"\",\n\t\"Itilde;\": \"\",\n\t\"itilde;\": \"\",\n\t\"Jsercy;\": \"\",\n\t\"jsercy;\": \"\",\n\t\"kappav;\": \"\",\n\t\"Kcedil;\": \"\",\n\t\"kcedil;\": \"\",\n\t\"kgreen;\": \"\",\n\t\"Lacute;\": \"\",\n\t\"lacute;\": \"\",\n\t\"lagran;\": \"\",\n\t\"Lambda;\": \"\",\n\t\"lambda;\": \"\",\n\t\"langle;\": \"\",\n\t\"larrfs;\": \"\",\n\t\"larrhk;\": \"\",\n\t\"larrlp;\": \"\",\n\t\"larrpl;\": \"\",\n\t\"larrtl;\": \"\",\n\t\"lAtail;\": \"\",\n\t\"latail;\": \"\",\n\t\"lbrace;\": \"{\",\n\t\"lbrack;\": \"[\",\n\t\"Lcaron;\": \"\",\n\t\"lcaron;\": \"\",\n\t\"Lcedil;\": \"\",\n\t\"lcedil;\": \"\",\n\t\"ldquor;\": \"\",\n\t\"lesdot;\": \"\",\n\t\"lesges;\": \"\",\n\t\"lfisht;\": \"\",\n\t\"lfloor;\": \"\",\n\t\"lharul;\": \"\",\n\t\"llhard;\": \"\",\n\t\"Lmidot;\": \"\",\n\t\"lmidot;\": \"\",\n\t\"lmoust;\": \"\",\n\t\"loplus;\": \"\",\n\t\"lowast;\": \"\",\n\t\"lowbar;\": \"_\",\n\t\"lparlt;\": \"\",\n\t\"lrhard;\": \"\",\n\t\"lsaquo;\": \"\",\n\t\"lsquor;\": \"\",\n\t\"Lstrok;\": \"\",\n\t\"lstrok;\": \"\",\n\t\"lthree;\": \"\",\n\t\"ltimes;\": \"\",\n\t\"ltlarr;\": \"\",\n\t\"ltrPar;\": \"\",\n\t\"mapsto;\": \"\",\n\t\"marker;\": \"\",\n\t\"mcomma;\": \"\",\n\t\"midast;\": \"*\",\n\t\"midcir;\": \"\",\n\t\"middot;\": \"\",\n\t\"minusb;\": \"\",\n\t\"minusd;\": \"\",\n\t\"mnplus;\": \"\",\n\t\"models;\": \"\",\n\t\"mstpos;\": \"\",\n\t\"Nacute;\": \"\",\n\t\"nacute;\": \"\",\n\t\"nbumpe;\": \"\",\n\t\"Ncaron;\": \"\",\n\t\"ncaron;\": \"\",\n\t\"Ncedil;\": \"\",\n\t\"ncedil;\": \"\",\n\t\"nearhk;\": \"\",\n\t\"nequiv;\": \"\",\n\t\"nesear;\": \"\",\n\t\"nexist;\": \"\",\n\t\"nltrie;\": \"\",\n\t\"notinE;\": \"\",\n\t\"nparsl;\": \"\",\n\t\"nprcue;\": \"\",\n\t\"nrarrc;\": \"\",\n\t\"nrarrw;\": \"\",\n\t\"nrtrie;\": \"\",\n\t\"nsccue;\": \"\",\n\t\"nsimeq;\": \"\",\n\t\"Ntilde;\": \"\",\n\t\"ntilde;\": \"\",\n\t\"numero;\": \"\",\n\t\"nVDash;\": \"\",\n\t\"nVdash;\": \"\",\n\t\"nvDash;\": \"\",\n\t\"nvdash;\": \"\",\n\t\"nvHarr;\": \"\",\n\t\"nvlArr;\": \"\",\n\t\"nvrArr;\": \"\",\n\t\"nwarhk;\": \"\",\n\t\"nwnear;\": \"\",\n\t\"Oacute;\": \"\",\n\t\"oacute;\": \"\",\n\t\"Odblac;\": \"\",\n\t\"odblac;\": \"\",\n\t\"odsold;\": \"\",\n\t\"Ograve;\": \"\",\n\t\"ograve;\": \"\",\n\t\"ominus;\": \"\",\n\t\"origof;\": \"\",\n\t\"Oslash;\": \"\",\n\t\"oslash;\": \"\",\n\t\"Otilde;\": \"\",\n\t\"otilde;\": \"\",\n\t\"Otimes;\": \"\",\n\t\"otimes;\": \"\",\n\t\"parsim;\": \"\",\n\t\"percnt;\": \"%\",\n\t\"period;\": \".\",\n\t\"permil;\": \"\",\n\t\"phmmat;\": \"\",\n\t\"planck;\": \"\",\n\t\"plankv;\": \"\",\n\t\"plusdo;\": \"\",\n\t\"plusdu;\": \"\",\n\t\"plusmn;\": \"\",\n\t\"preceq;\": \"\",\n\t\"primes;\": \"\",\n\t\"prnsim;\": \"\",\n\t\"propto;\": \"\",\n\t\"prurel;\": \"\",\n\t\"puncsp;\": \"\",\n\t\"qprime;\": \"\",\n\t\"Racute;\": \"\",\n\t\"racute;\": \"\",\n\t\"rangle;\": \"\",\n\t\"rarrap;\": \"\",\n\t\"rarrfs;\": \"\",\n\t\"rarrhk;\": \"\",\n\t\"rarrlp;\": \"\",\n\t\"rarrpl;\": \"\",\n\t\"Rarrtl;\": \"\",\n\t\"rarrtl;\": \"\",\n\t\"rAtail;\": \"\",\n\t\"ratail;\": \"\",\n\t\"rbrace;\": \"}\",\n\t\"rbrack;\": \"]\",\n\t\"Rcaron;\": \"\",\n\t\"rcaron;\": \"\",\n\t\"Rcedil;\": \"\",\n\t\"rcedil;\": \"\",\n\t\"rdquor;\": \"\",\n\t\"rfisht;\": \"\",\n\t\"rfloor;\": \"\",\n\t\"rharul;\": \"\",\n\t\"rmoust;\": \"\",\n\t\"roplus;\": \"\",\n\t\"rpargt;\": \"\",\n\t\"rsaquo;\": \"\",\n\t\"rsquor;\": \"\",\n\t\"rthree;\": \"\",\n\t\"rtimes;\": \"\",\n\t\"Sacute;\": \"\",\n\t\"sacute;\": \"\",\n\t\"Scaron;\": \"\",\n\t\"scaron;\": \"\",\n\t\"Scedil;\": \"\",\n\t\"scedil;\": \"\",\n\t\"scnsim;\": \"\",\n\t\"searhk;\": \"\",\n\t\"seswar;\": \"\",\n\t\"sfrown;\": \"\",\n\t\"SHCHcy;\": \"\",\n\t\"shchcy;\": \"\",\n\t\"sigmaf;\": \"\",\n\t\"sigmav;\": \"\",\n\t\"simdot;\": \"\",\n\t\"smashp;\": \"\",\n\t\"SOFTcy;\": \"\",\n\t\"softcy;\": \"\",\n\t\"solbar;\": \"\",\n\t\"spades;\": \"\",\n\t\"sqcaps;\": \"\",\n\t\"sqcups;\": \"\",\n\t\"sqsube;\": \"\",\n\t\"sqsupe;\": \"\",\n\t\"Square;\": \"\",\n\t\"square;\": \"\",\n\t\"squarf;\": \"\",\n\t\"ssetmn;\": \"\",\n\t\"ssmile;\": \"\",\n\t\"sstarf;\": \"\",\n\t\"subdot;\": \"\",\n\t\"Subset;\": \"\",\n\t\"subset;\": \"\",\n\t\"subsim;\": \"\",\n\t\"subsub;\": \"\",\n\t\"subsup;\": \"\",\n\t\"succeq;\": \"\",\n\t\"supdot;\": \"\",\n\t\"Supset;\": \"\",\n\t\"supset;\": \"\",\n\t\"supsim;\": \"\",\n\t\"supsub;\": \"\",\n\t\"supsup;\": \"\",\n\t\"swarhk;\": \"\",\n\t\"swnwar;\": \"\",\n\t\"target;\": \"\",\n\t\"Tcaron;\": \"\",\n\t\"tcaron;\": \"\",\n\t\"Tcedil;\": \"\",\n\t\"tcedil;\": \"\",\n\t\"telrec;\": \"\",\n\t\"there4;\": \"\",\n\t\"thetav;\": \"\",\n\t\"thinsp;\": \"\",\n\t\"thksim;\": \"\",\n\t\"timesb;\": \"\",\n\t\"timesd;\": \"\",\n\t\"topbot;\": \"\",\n\t\"topcir;\": \"\",\n\t\"tprime;\": \"\",\n\t\"tridot;\": \"\",\n\t\"Tstrok;\": \"\",\n\t\"tstrok;\": \"\",\n\t\"Uacute;\": \"\",\n\t\"uacute;\": \"\",\n\t\"Ubreve;\": \"\",\n\t\"ubreve;\": \"\",\n\t\"Udblac;\": \"\",\n\t\"udblac;\": \"\",\n\t\"ufisht;\": \"\",\n\t\"Ugrave;\": \"\",\n\t\"ugrave;\": \"\",\n\t\"ulcorn;\": \"\",\n\t\"ulcrop;\": \"\",\n\t\"urcorn;\": \"\",\n\t\"urcrop;\": \"\",\n\t\"Utilde;\": \"\",\n\t\"utilde;\": \"\",\n\t\"vangrt;\": \"\",\n\t\"varphi;\": \"\",\n\t\"varrho;\": \"\",\n\t\"Vdashl;\": \"\",\n\t\"veebar;\": \"\",\n\t\"vellip;\": \"\",\n\t\"Verbar;\": \"\",\n\t\"verbar;\": \"|\",\n\t\"vsubnE;\": \"\",\n\t\"vsubne;\": \"\",\n\t\"vsupnE;\": \"\",\n\t\"vsupne;\": \"\",\n\t\"Vvdash;\": \"\",\n\t\"wedbar;\": \"\",\n\t\"wedgeq;\": \"\",\n\t\"weierp;\": \"\",\n\t\"wreath;\": \"\",\n\t\"xoplus;\": \"\",\n\t\"xotime;\": \"\",\n\t\"xsqcup;\": \"\",\n\t\"xuplus;\": \"\",\n\t\"xwedge;\": \"\",\n\t\"Yacute;\": \"\",\n\t\"yacute;\": \"\",\n\t\"Zacute;\": \"\",\n\t\"zacute;\": \"\",\n\t\"Zcaron;\": \"\",\n\t\"zcaron;\": \"\",\n\t\"zeetrf;\": \"\",\n\t\"alefsym;\": \"\",\n\t\"angrtvb;\": \"\",\n\t\"angzarr;\": \"\",\n\t\"asympeq;\": \"\",\n\t\"backsim;\": \"\",\n\t\"Because;\": \"\",\n\t\"because;\": \"\",\n\t\"bemptyv;\": \"\",\n\t\"between;\": \"\",\n\t\"bigcirc;\": \"\",\n\t\"bigodot;\": \"\",\n\t\"bigstar;\": \"\",\n\t\"bnequiv;\": \"\",\n\t\"boxplus;\": \"\",\n\t\"Cayleys;\": \"\",\n\t\"Cconint;\": \"\",\n\t\"ccupssm;\": \"\",\n\t\"Cedilla;\": \"\",\n\t\"cemptyv;\": \"\",\n\t\"cirscir;\": \"\",\n\t\"coloneq;\": \"\",\n\t\"congdot;\": \"\",\n\t\"cudarrl;\": \"\",\n\t\"cudarrr;\": \"\",\n\t\"cularrp;\": \"\",\n\t\"curarrm;\": \"\",\n\t\"dbkarow;\": \"\",\n\t\"ddagger;\": \"\",\n\t\"ddotseq;\": \"\",\n\t\"demptyv;\": \"\",\n\t\"Diamond;\": \"\",\n\t\"diamond;\": \"\",\n\t\"digamma;\": \"\",\n\t\"dotplus;\": \"\",\n\t\"DownTee;\": \"\",\n\t\"dwangle;\": \"\",\n\t\"Element;\": \"\",\n\t\"Epsilon;\": \"\",\n\t\"epsilon;\": \"\",\n\t\"eqcolon;\": \"\",\n\t\"equivDD;\": \"\",\n\t\"gesdoto;\": \"\",\n\t\"gtquest;\": \"\",\n\t\"gtrless;\": \"\",\n\t\"harrcir;\": \"\",\n\t\"Implies;\": \"\",\n\t\"intprod;\": \"\",\n\t\"isindot;\": \"\",\n\t\"larrbfs;\": \"\",\n\t\"larrsim;\": \"\",\n\t\"lbrksld;\": \"\",\n\t\"lbrkslu;\": \"\",\n\t\"ldrdhar;\": \"\",\n\t\"LeftTee;\": \"\",\n\t\"lesdoto;\": \"\",\n\t\"lessdot;\": \"\",\n\t\"lessgtr;\": \"\",\n\t\"lesssim;\": \"\",\n\t\"lotimes;\": \"\",\n\t\"lozenge;\": \"\",\n\t\"ltquest;\": \"\",\n\t\"luruhar;\": \"\",\n\t\"maltese;\": \"\",\n\t\"minusdu;\": \"\",\n\t\"napprox;\": \"\",\n\t\"natural;\": \"\",\n\t\"nearrow;\": \"\",\n\t\"NewLine;\": \"\\n\",\n\t\"nexists;\": \"\",\n\t\"NoBreak;\": \"\",\n\t\"notinva;\": \"\",\n\t\"notinvb;\": \"\",\n\t\"notinvc;\": \"\",\n\t\"NotLess;\": \"\",\n\t\"notniva;\": \"\",\n\t\"notnivb;\": \"\",\n\t\"notnivc;\": \"\",\n\t\"npolint;\": \"\",\n\t\"npreceq;\": \"\",\n\t\"nsqsube;\": \"\",\n\t\"nsqsupe;\": \"\",\n\t\"nsubset;\": \"\",\n\t\"nsucceq;\": \"\",\n\t\"nsupset;\": \"\",\n\t\"nvinfin;\": \"\",\n\t\"nvltrie;\": \"\",\n\t\"nvrtrie;\": \"\",\n\t\"nwarrow;\": \"\",\n\t\"olcross;\": \"\",\n\t\"Omicron;\": \"\",\n\t\"omicron;\": \"\",\n\t\"orderof;\": \"\",\n\t\"orslope;\": \"\",\n\t\"OverBar;\": \"\",\n\t\"pertenk;\": \"\",\n\t\"planckh;\": \"\",\n\t\"pluscir;\": \"\",\n\t\"plussim;\": \"\",\n\t\"plustwo;\": \"\",\n\t\"precsim;\": \"\",\n\t\"Product;\": \"\",\n\t\"quatint;\": \"\",\n\t\"questeq;\": \"\",\n\t\"rarrbfs;\": \"\",\n\t\"rarrsim;\": \"\",\n\t\"rbrksld;\": \"\",\n\t\"rbrkslu;\": \"\",\n\t\"rdldhar;\": \"\",\n\t\"realine;\": \"\",\n\t\"rotimes;\": \"\",\n\t\"ruluhar;\": \"\",\n\t\"searrow;\": \"\",\n\t\"simplus;\": \"\",\n\t\"simrarr;\": \"\",\n\t\"subedot;\": \"\",\n\t\"submult;\": \"\",\n\t\"subplus;\": \"\",\n\t\"subrarr;\": \"\",\n\t\"succsim;\": \"\",\n\t\"supdsub;\": \"\",\n\t\"supedot;\": \"\",\n\t\"suphsol;\": \"\",\n\t\"suphsub;\": \"\",\n\t\"suplarr;\": \"\",\n\t\"supmult;\": \"\",\n\t\"supplus;\": \"\",\n\t\"swarrow;\": \"\",\n\t\"topfork;\": \"\",\n\t\"triplus;\": \"\",\n\t\"tritime;\": \"\",\n\t\"UpArrow;\": \"\",\n\t\"Uparrow;\": \"\",\n\t\"uparrow;\": \"\",\n\t\"Upsilon;\": \"\",\n\t\"upsilon;\": \"\",\n\t\"uwangle;\": \"\",\n\t\"vzigzag;\": \"\",\n\t\"zigrarr;\": \"\",\n\t\"andslope;\": \"\",\n\t\"angmsdaa;\": \"\",\n\t\"angmsdab;\": \"\",\n\t\"angmsdac;\": \"\",\n\t\"angmsdad;\": \"\",\n\t\"angmsdae;\": \"\",\n\t\"angmsdaf;\": \"\",\n\t\"angmsdag;\": \"\",\n\t\"angmsdah;\": \"\",\n\t\"angrtvbd;\": \"\",\n\t\"approxeq;\": \"\",\n\t\"awconint;\": \"\",\n\t\"backcong;\": \"\",\n\t\"barwedge;\": \"\",\n\t\"bbrktbrk;\": \"\",\n\t\"bigoplus;\": \"\",\n\t\"bigsqcup;\": \"\",\n\t\"biguplus;\": \"\",\n\t\"bigwedge;\": \"\",\n\t\"boxminus;\": \"\",\n\t\"boxtimes;\": \"\",\n\t\"bsolhsub;\": \"\",\n\t\"capbrcup;\": \"\",\n\t\"circledR;\": \"\",\n\t\"circledS;\": \"\",\n\t\"cirfnint;\": \"\",\n\t\"clubsuit;\": \"\",\n\t\"cupbrcap;\": \"\",\n\t\"curlyvee;\": \"\",\n\t\"cwconint;\": \"\",\n\t\"DDotrahd;\": \"\",\n\t\"doteqdot;\": \"\",\n\t\"DotEqual;\": \"\",\n\t\"dotminus;\": \"\",\n\t\"drbkarow;\": \"\",\n\t\"dzigrarr;\": \"\",\n\t\"elinters;\": \"\",\n\t\"emptyset;\": \"\",\n\t\"eqvparsl;\": \"\",\n\t\"fpartint;\": \"\",\n\t\"geqslant;\": \"\",\n\t\"gesdotol;\": \"\",\n\t\"gnapprox;\": \"\",\n\t\"hksearow;\": \"\",\n\t\"hkswarow;\": \"\",\n\t\"imagline;\": \"\",\n\t\"imagpart;\": \"\",\n\t\"infintie;\": \"\",\n\t\"integers;\": \"\",\n\t\"Integral;\": \"\",\n\t\"intercal;\": \"\",\n\t\"intlarhk;\": \"\",\n\t\"laemptyv;\": \"\",\n\t\"ldrushar;\": \"\",\n\t\"leqslant;\": \"\",\n\t\"lesdotor;\": \"\",\n\t\"LessLess;\": \"\",\n\t\"llcorner;\": \"\",\n\t\"lnapprox;\": \"\",\n\t\"lrcorner;\": \"\",\n\t\"lurdshar;\": \"\",\n\t\"mapstoup;\": \"\",\n\t\"multimap;\": \"\",\n\t\"naturals;\": \"\",\n\t\"ncongdot;\": \"\",\n\t\"NotEqual;\": \"\",\n\t\"notindot;\": \"\",\n\t\"NotTilde;\": \"\",\n\t\"otimesas;\": \"\",\n\t\"parallel;\": \"\",\n\t\"PartialD;\": \"\",\n\t\"plusacir;\": \"\",\n\t\"pointint;\": \"\",\n\t\"Precedes;\": \"\",\n\t\"precneqq;\": \"\",\n\t\"precnsim;\": \"\",\n\t\"profalar;\": \"\",\n\t\"profline;\": \"\",\n\t\"profsurf;\": \"\",\n\t\"raemptyv;\": \"\",\n\t\"realpart;\": \"\",\n\t\"RightTee;\": \"\",\n\t\"rppolint;\": \"\",\n\t\"rtriltri;\": \"\",\n\t\"scpolint;\": \"\",\n\t\"setminus;\": \"\",\n\t\"shortmid;\": \"\",\n\t\"smeparsl;\": \"\",\n\t\"sqsubset;\": \"\",\n\t\"sqsupset;\": \"\",\n\t\"subseteq;\": \"\",\n\t\"Succeeds;\": \"\",\n\t\"succneqq;\": \"\",\n\t\"succnsim;\": \"\",\n\t\"SuchThat;\": \"\",\n\t\"Superset;\": \"\",\n\t\"supseteq;\": \"\",\n\t\"thetasym;\": \"\",\n\t\"thicksim;\": \"\",\n\t\"timesbar;\": \"\",\n\t\"triangle;\": \"\",\n\t\"triminus;\": \"\",\n\t\"trpezium;\": \"\",\n\t\"Uarrocir;\": \"\",\n\t\"ulcorner;\": \"\",\n\t\"UnderBar;\": \"_\",\n\t\"urcorner;\": \"\",\n\t\"varkappa;\": \"\",\n\t\"varsigma;\": \"\",\n\t\"vartheta;\": \"\",\n\t\"backprime;\": \"\",\n\t\"backsimeq;\": \"\",\n\t\"Backslash;\": \"\",\n\t\"bigotimes;\": \"\",\n\t\"CenterDot;\": \"\",\n\t\"centerdot;\": \"\",\n\t\"checkmark;\": \"\",\n\t\"CircleDot;\": \"\",\n\t\"complexes;\": \"\",\n\t\"Congruent;\": \"\",\n\t\"Coproduct;\": \"\",\n\t\"dotsquare;\": \"\",\n\t\"DoubleDot;\": \"\",\n\t\"DownArrow;\": \"\",\n\t\"Downarrow;\": \"\",\n\t\"downarrow;\": \"\",\n\t\"DownBreve;\": \"\",\n\t\"gtrapprox;\": \"\",\n\t\"gtreqless;\": \"\",\n\t\"gvertneqq;\": \"\",\n\t\"heartsuit;\": \"\",\n\t\"HumpEqual;\": \"\",\n\t\"LeftArrow;\": \"\",\n\t\"Leftarrow;\": \"\",\n\t\"leftarrow;\": \"\",\n\t\"LeftFloor;\": \"\",\n\t\"lesseqgtr;\": \"\",\n\t\"LessTilde;\": \"\",\n\t\"lvertneqq;\": \"\",\n\t\"Mellintrf;\": \"\",\n\t\"MinusPlus;\": \"\",\n\t\"ngeqslant;\": \"\",\n\t\"nleqslant;\": \"\",\n\t\"NotCupCap;\": \"\",\n\t\"NotExists;\": \"\",\n\t\"NotSubset;\": \"\",\n\t\"nparallel;\": \"\",\n\t\"nshortmid;\": \"\",\n\t\"nsubseteq;\": \"\",\n\t\"nsupseteq;\": \"\",\n\t\"OverBrace;\": \"\",\n\t\"pitchfork;\": \"\",\n\t\"PlusMinus;\": \"\",\n\t\"rationals;\": \"\",\n\t\"spadesuit;\": \"\",\n\t\"subseteqq;\": \"\",\n\t\"subsetneq;\": \"\",\n\t\"supseteqq;\": \"\",\n\t\"supsetneq;\": \"\",\n\t\"Therefore;\": \"\",\n\t\"therefore;\": \"\",\n\t\"ThinSpace;\": \"\",\n\t\"triangleq;\": \"\",\n\t\"TripleDot;\": \"\",\n\t\"UnionPlus;\": \"\",\n\t\"varpropto;\": \"\",\n\t\"Bernoullis;\": \"\",\n\t\"circledast;\": \"\",\n\t\"CirclePlus;\": \"\",\n\t\"complement;\": \"\",\n\t\"curlywedge;\": \"\",\n\t\"eqslantgtr;\": \"\",\n\t\"EqualTilde;\": \"\",\n\t\"Fouriertrf;\": \"\",\n\t\"gtreqqless;\": \"\",\n\t\"ImaginaryI;\": \"\",\n\t\"Laplacetrf;\": \"\",\n\t\"LeftVector;\": \"\",\n\t\"lessapprox;\": \"\",\n\t\"lesseqqgtr;\": \"\",\n\t\"Lleftarrow;\": \"\",\n\t\"lmoustache;\": \"\",\n\t\"longmapsto;\": \"\",\n\t\"mapstodown;\": \"\",\n\t\"mapstoleft;\": \"\",\n\t\"nLeftarrow;\": \"\",\n\t\"nleftarrow;\": \"\",\n\t\"NotElement;\": \"\",\n\t\"NotGreater;\": \"\",\n\t\"nsubseteqq;\": \"\",\n\t\"nsupseteqq;\": \"\",\n\t\"precapprox;\": \"\",\n\t\"Proportion;\": \"\",\n\t\"RightArrow;\": \"\",\n\t\"Rightarrow;\": \"\",\n\t\"rightarrow;\": \"\",\n\t\"RightFloor;\": \"\",\n\t\"rmoustache;\": \"\",\n\t\"sqsubseteq;\": \"\",\n\t\"sqsupseteq;\": \"\",\n\t\"subsetneqq;\": \"\",\n\t\"succapprox;\": \"\",\n\t\"supsetneqq;\": \"\",\n\t\"ThickSpace;\": \"\",\n\t\"TildeEqual;\": \"\",\n\t\"TildeTilde;\": \"\",\n\t\"UnderBrace;\": \"\",\n\t\"UpArrowBar;\": \"\",\n\t\"UpTeeArrow;\": \"\",\n\t\"upuparrows;\": \"\",\n\t\"varepsilon;\": \"\",\n\t\"varnothing;\": \"\",\n\t\"backepsilon;\": \"\",\n\t\"blacksquare;\": \"\",\n\t\"circledcirc;\": \"\",\n\t\"circleddash;\": \"\",\n\t\"CircleMinus;\": \"\",\n\t\"CircleTimes;\": \"\",\n\t\"curlyeqprec;\": \"\",\n\t\"curlyeqsucc;\": \"\",\n\t\"diamondsuit;\": \"\",\n\t\"eqslantless;\": \"\",\n\t\"Equilibrium;\": \"\",\n\t\"expectation;\": \"\",\n\t\"GreaterLess;\": \"\",\n\t\"LeftCeiling;\": \"\",\n\t\"LessGreater;\": \"\",\n\t\"MediumSpace;\": \"\",\n\t\"NotLessLess;\": \"\",\n\t\"NotPrecedes;\": \"\",\n\t\"NotSucceeds;\": \"\",\n\t\"NotSuperset;\": \"\",\n\t\"nRightarrow;\": \"\",\n\t\"nrightarrow;\": \"\",\n\t\"OverBracket;\": \"\",\n\t\"preccurlyeq;\": \"\",\n\t\"precnapprox;\": \"\",\n\t\"quaternions;\": \"\",\n\t\"RightVector;\": \"\",\n\t\"Rrightarrow;\": \"\",\n\t\"RuleDelayed;\": \"\",\n\t\"SmallCircle;\": \"\",\n\t\"SquareUnion;\": \"\",\n\t\"straightphi;\": \"\",\n\t\"SubsetEqual;\": \"\",\n\t\"succcurlyeq;\": \"\",\n\t\"succnapprox;\": \"\",\n\t\"thickapprox;\": \"\",\n\t\"UpDownArrow;\": \"\",\n\t\"Updownarrow;\": \"\",\n\t\"updownarrow;\": \"\",\n\t\"VerticalBar;\": \"\",\n\t\"blacklozenge;\": \"\",\n\t\"DownArrowBar;\": \"\",\n\t\"DownTeeArrow;\": \"\",\n\t\"ExponentialE;\": \"\",\n\t\"exponentiale;\": \"\",\n\t\"GreaterEqual;\": \"\",\n\t\"GreaterTilde;\": \"\",\n\t\"HilbertSpace;\": \"\",\n\t\"HumpDownHump;\": \"\",\n\t\"Intersection;\": \"\",\n\t\"LeftArrowBar;\": \"\",\n\t\"LeftTeeArrow;\": \"\",\n\t\"LeftTriangle;\": \"\",\n\t\"LeftUpVector;\": \"\",\n\t\"NotCongruent;\": \"\",\n\t\"NotHumpEqual;\": \"\",\n\t\"NotLessEqual;\": \"\",\n\t\"NotLessTilde;\": \"\",\n\t\"Proportional;\": \"\",\n\t\"RightCeiling;\": \"\",\n\t\"risingdotseq;\": \"\",\n\t\"RoundImplies;\": \"\",\n\t\"ShortUpArrow;\": \"\",\n\t\"SquareSubset;\": \"\",\n\t\"triangledown;\": \"\",\n\t\"triangleleft;\": \"\",\n\t\"UnderBracket;\": \"\",\n\t\"varsubsetneq;\": \"\",\n\t\"varsupsetneq;\": \"\",\n\t\"VerticalLine;\": \"|\",\n\t\"ApplyFunction;\": \"\",\n\t\"bigtriangleup;\": \"\",\n\t\"blacktriangle;\": \"\",\n\t\"DifferentialD;\": \"\",\n\t\"divideontimes;\": \"\",\n\t\"DoubleLeftTee;\": \"\",\n\t\"DoubleUpArrow;\": \"\",\n\t\"fallingdotseq;\": \"\",\n\t\"hookleftarrow;\": \"\",\n\t\"leftarrowtail;\": \"\",\n\t\"leftharpoonup;\": \"\",\n\t\"LeftTeeVector;\": \"\",\n\t\"LeftVectorBar;\": \"\",\n\t\"LessFullEqual;\": \"\",\n\t\"LongLeftArrow;\": \"\",\n\t\"Longleftarrow;\": \"\",\n\t\"longleftarrow;\": \"\",\n\t\"looparrowleft;\": \"\",\n\t\"measuredangle;\": \"\",\n\t\"NotEqualTilde;\": \"\",\n\t\"NotTildeEqual;\": \"\",\n\t\"NotTildeTilde;\": \"\",\n\t\"ntriangleleft;\": \"\",\n\t\"Poincareplane;\": \"\",\n\t\"PrecedesEqual;\": \"\",\n\t\"PrecedesTilde;\": \"\",\n\t\"RightArrowBar;\": \"\",\n\t\"RightTeeArrow;\": \"\",\n\t\"RightTriangle;\": \"\",\n\t\"RightUpVector;\": \"\",\n\t\"shortparallel;\": \"\",\n\t\"smallsetminus;\": \"\",\n\t\"SucceedsEqual;\": \"\",\n\t\"SucceedsTilde;\": \"\",\n\t\"SupersetEqual;\": \"\",\n\t\"triangleright;\": \"\",\n\t\"UpEquilibrium;\": \"\",\n\t\"upharpoonleft;\": \"\",\n\t\"varsubsetneqq;\": \"\",\n\t\"varsupsetneqq;\": \"\",\n\t\"VerticalTilde;\": \"\",\n\t\"VeryThinSpace;\": \"\",\n\t\"curvearrowleft;\": \"\",\n\t\"DiacriticalDot;\": \"\",\n\t\"doublebarwedge;\": \"\",\n\t\"DoubleRightTee;\": \"\",\n\t\"downdownarrows;\": \"\",\n\t\"DownLeftVector;\": \"\",\n\t\"GreaterGreater;\": \"\",\n\t\"hookrightarrow;\": \"\",\n\t\"HorizontalLine;\": \"\",\n\t\"InvisibleComma;\": \"\",\n\t\"InvisibleTimes;\": \"\",\n\t\"LeftDownVector;\": \"\",\n\t\"leftleftarrows;\": \"\",\n\t\"LeftRightArrow;\": \"\",\n\t\"Leftrightarrow;\": \"\",\n\t\"leftrightarrow;\": \"\",\n\t\"leftthreetimes;\": \"\",\n\t\"LessSlantEqual;\": \"\",\n\t\"LongRightArrow;\": \"\",\n\t\"Longrightarrow;\": \"\",\n\t\"longrightarrow;\": \"\",\n\t\"looparrowright;\": \"\",\n\t\"LowerLeftArrow;\": \"\",\n\t\"NestedLessLess;\": \"\",\n\t\"NotGreaterLess;\": \"\",\n\t\"NotLessGreater;\": \"\",\n\t\"NotSubsetEqual;\": \"\",\n\t\"NotVerticalBar;\": \"\",\n\t\"nshortparallel;\": \"\",\n\t\"ntriangleright;\": \"\",\n\t\"OpenCurlyQuote;\": \"\",\n\t\"ReverseElement;\": \"\",\n\t\"rightarrowtail;\": \"\",\n\t\"rightharpoonup;\": \"\",\n\t\"RightTeeVector;\": \"\",\n\t\"RightVectorBar;\": \"\",\n\t\"ShortDownArrow;\": \"\",\n\t\"ShortLeftArrow;\": \"\",\n\t\"SquareSuperset;\": \"\",\n\t\"TildeFullEqual;\": \"\",\n\t\"trianglelefteq;\": \"\",\n\t\"upharpoonright;\": \"\",\n\t\"UpperLeftArrow;\": \"\",\n\t\"ZeroWidthSpace;\": \"\",\n\t\"bigtriangledown;\": \"\",\n\t\"circlearrowleft;\": \"\",\n\t\"CloseCurlyQuote;\": \"\",\n\t\"ContourIntegral;\": \"\",\n\t\"curvearrowright;\": \"\",\n\t\"DoubleDownArrow;\": \"\",\n\t\"DoubleLeftArrow;\": \"\",\n\t\"downharpoonleft;\": \"\",\n\t\"DownRightVector;\": \"\",\n\t\"leftharpoondown;\": \"\",\n\t\"leftrightarrows;\": \"\",\n\t\"LeftRightVector;\": \"\",\n\t\"LeftTriangleBar;\": \"\",\n\t\"LeftUpTeeVector;\": \"\",\n\t\"LeftUpVectorBar;\": \"\",\n\t\"LowerRightArrow;\": \"\",\n\t\"nLeftrightarrow;\": \"\",\n\t\"nleftrightarrow;\": \"\",\n\t\"NotGreaterEqual;\": \"\",\n\t\"NotGreaterTilde;\": \"\",\n\t\"NotHumpDownHump;\": \"\",\n\t\"NotLeftTriangle;\": \"\",\n\t\"NotSquareSubset;\": \"\",\n\t\"ntrianglelefteq;\": \"\",\n\t\"OverParenthesis;\": \"\",\n\t\"RightDownVector;\": \"\",\n\t\"rightleftarrows;\": \"\",\n\t\"rightsquigarrow;\": \"\",\n\t\"rightthreetimes;\": \"\",\n\t\"ShortRightArrow;\": \"\",\n\t\"straightepsilon;\": \"\",\n\t\"trianglerighteq;\": \"\",\n\t\"UpperRightArrow;\": \"\",\n\t\"vartriangleleft;\": \"\",\n\t\"circlearrowright;\": \"\",\n\t\"DiacriticalAcute;\": \"\",\n\t\"DiacriticalGrave;\": \"`\",\n\t\"DiacriticalTilde;\": \"\",\n\t\"DoubleRightArrow;\": \"\",\n\t\"DownArrowUpArrow;\": \"\",\n\t\"downharpoonright;\": \"\",\n\t\"EmptySmallSquare;\": \"\",\n\t\"GreaterEqualLess;\": \"\",\n\t\"GreaterFullEqual;\": \"\",\n\t\"LeftAngleBracket;\": \"\",\n\t\"LeftUpDownVector;\": \"\",\n\t\"LessEqualGreater;\": \"\",\n\t\"NonBreakingSpace;\": \"\",\n\t\"NotPrecedesEqual;\": \"\",\n\t\"NotRightTriangle;\": \"\",\n\t\"NotSucceedsEqual;\": \"\",\n\t\"NotSucceedsTilde;\": \"\",\n\t\"NotSupersetEqual;\": \"\",\n\t\"ntrianglerighteq;\": \"\",\n\t\"rightharpoondown;\": \"\",\n\t\"rightrightarrows;\": \"\",\n\t\"RightTriangleBar;\": \"\",\n\t\"RightUpTeeVector;\": \"\",\n\t\"RightUpVectorBar;\": \"\",\n\t\"twoheadleftarrow;\": \"\",\n\t\"UnderParenthesis;\": \"\",\n\t\"UpArrowDownArrow;\": \"\",\n\t\"vartriangleright;\": \"\",\n\t\"blacktriangledown;\": \"\",\n\t\"blacktriangleleft;\": \"\",\n\t\"DoubleUpDownArrow;\": \"\",\n\t\"DoubleVerticalBar;\": \"\",\n\t\"DownLeftTeeVector;\": \"\",\n\t\"DownLeftVectorBar;\": \"\",\n\t\"FilledSmallSquare;\": \"\",\n\t\"GreaterSlantEqual;\": \"\",\n\t\"LeftDoubleBracket;\": \"\",\n\t\"LeftDownTeeVector;\": \"\",\n\t\"LeftDownVectorBar;\": \"\",\n\t\"leftrightharpoons;\": \"\",\n\t\"LeftTriangleEqual;\": \"\",\n\t\"NegativeThinSpace;\": \"\",\n\t\"NotGreaterGreater;\": \"\",\n\t\"NotLessSlantEqual;\": \"\",\n\t\"NotNestedLessLess;\": \"\",\n\t\"NotReverseElement;\": \"\",\n\t\"NotSquareSuperset;\": \"\",\n\t\"NotTildeFullEqual;\": \"\",\n\t\"RightAngleBracket;\": \"\",\n\t\"rightleftharpoons;\": \"\",\n\t\"RightUpDownVector;\": \"\",\n\t\"SquareSubsetEqual;\": \"\",\n\t\"twoheadrightarrow;\": \"\",\n\t\"VerticalSeparator;\": \"\",\n\t\"blacktriangleright;\": \"\",\n\t\"DownRightTeeVector;\": \"\",\n\t\"DownRightVectorBar;\": \"\",\n\t\"LongLeftRightArrow;\": \"\",\n\t\"Longleftrightarrow;\": \"\",\n\t\"longleftrightarrow;\": \"\",\n\t\"NegativeThickSpace;\": \"\",\n\t\"NotLeftTriangleBar;\": \"\",\n\t\"PrecedesSlantEqual;\": \"\",\n\t\"ReverseEquilibrium;\": \"\",\n\t\"RightDoubleBracket;\": \"\",\n\t\"RightDownTeeVector;\": \"\",\n\t\"RightDownVectorBar;\": \"\",\n\t\"RightTriangleEqual;\": \"\",\n\t\"SquareIntersection;\": \"\",\n\t\"SucceedsSlantEqual;\": \"\",\n\t\"DoubleLongLeftArrow;\": \"\",\n\t\"DownLeftRightVector;\": \"\",\n\t\"LeftArrowRightArrow;\": \"\",\n\t\"leftrightsquigarrow;\": \"\",\n\t\"NegativeMediumSpace;\": \"\",\n\t\"NotGreaterFullEqual;\": \"\",\n\t\"NotRightTriangleBar;\": \"\",\n\t\"RightArrowLeftArrow;\": \"\",\n\t\"SquareSupersetEqual;\": \"\",\n\t\"CapitalDifferentialD;\": \"\",\n\t\"DoubleLeftRightArrow;\": \"\",\n\t\"DoubleLongRightArrow;\": \"\",\n\t\"EmptyVerySmallSquare;\": \"\",\n\t\"NestedGreaterGreater;\": \"\",\n\t\"NotDoubleVerticalBar;\": \"\",\n\t\"NotGreaterSlantEqual;\": \"\",\n\t\"NotLeftTriangleEqual;\": \"\",\n\t\"NotSquareSubsetEqual;\": \"\",\n\t\"OpenCurlyDoubleQuote;\": \"\",\n\t\"ReverseUpEquilibrium;\": \"\",\n\t\"CloseCurlyDoubleQuote;\": \"\",\n\t\"DoubleContourIntegral;\": \"\",\n\t\"FilledVerySmallSquare;\": \"\",\n\t\"NegativeVeryThinSpace;\": \"\",\n\t\"NotPrecedesSlantEqual;\": \"\",\n\t\"NotRightTriangleEqual;\": \"\",\n\t\"NotSucceedsSlantEqual;\": \"\",\n\t\"DiacriticalDoubleAcute;\": \"\",\n\t\"NotSquareSupersetEqual;\": \"\",\n\t\"NotNestedGreaterGreater;\": \"\",\n\t\"ClockwiseContourIntegral;\": \"\",\n\t\"DoubleLongLeftRightArrow;\": \"\",\n\t\"CounterClockwiseContourIntegral;\": \"\"\n};\n\n// lazy compute this to make this file tree-shakable for browser\r\nlet maxCRNameLength;\r\nconst decodeHtml = (rawText, asAttr) => {\r\n    let offset = 0;\r\n    const end = rawText.length;\r\n    let decodedText = '';\r\n    function advance(length) {\r\n        offset += length;\r\n        rawText = rawText.slice(length);\r\n    }\r\n    while (offset < end) {\r\n        const head = /&(?:#x?)?/i.exec(rawText);\r\n        if (!head || offset + head.index >= end) {\r\n            const remaining = end - offset;\r\n            decodedText += rawText.slice(0, remaining);\r\n            advance(remaining);\r\n            break;\r\n        }\r\n        // Advance to the \"&\".\r\n        decodedText += rawText.slice(0, head.index);\r\n        advance(head.index);\r\n        if (head[0] === '&') {\r\n            // Named character reference.\r\n            let name = '';\r\n            let value = undefined;\r\n            if (/[0-9a-z]/i.test(rawText[1])) {\r\n                if (!maxCRNameLength) {\r\n                    maxCRNameLength = Object.keys(namedCharacterReferences).reduce((max, name) => Math.max(max, name.length), 0);\r\n                }\r\n                for (let length = maxCRNameLength; !value && length > 0; --length) {\r\n                    name = rawText.substr(1, length);\r\n                    value = namedCharacterReferences[name];\r\n                }\r\n                if (value) {\r\n                    const semi = name.endsWith(';');\r\n                    if (asAttr &&\r\n                        !semi &&\r\n                        /[=a-z0-9]/i.test(rawText[name.length + 1] || '')) {\r\n                        decodedText += '&' + name;\r\n                        advance(1 + name.length);\r\n                    }\r\n                    else {\r\n                        decodedText += value;\r\n                        advance(1 + name.length);\r\n                    }\r\n                }\r\n                else {\r\n                    decodedText += '&' + name;\r\n                    advance(1 + name.length);\r\n                }\r\n            }\r\n            else {\r\n                decodedText += '&';\r\n                advance(1);\r\n            }\r\n        }\r\n        else {\r\n            // Numeric character reference.\r\n            const hex = head[0] === '&#x';\r\n            const pattern = hex ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/;\r\n            const body = pattern.exec(rawText);\r\n            if (!body) {\r\n                decodedText += head[0];\r\n                advance(head[0].length);\r\n            }\r\n            else {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\r\n                let cp = Number.parseInt(body[1], hex ? 16 : 10);\r\n                if (cp === 0) {\r\n                    cp = 0xfffd;\r\n                }\r\n                else if (cp > 0x10ffff) {\r\n                    cp = 0xfffd;\r\n                }\r\n                else if (cp >= 0xd800 && cp <= 0xdfff) {\r\n                    cp = 0xfffd;\r\n                }\r\n                else if ((cp >= 0xfdd0 && cp <= 0xfdef) || (cp & 0xfffe) === 0xfffe) ;\r\n                else if ((cp >= 0x01 && cp <= 0x08) ||\r\n                    cp === 0x0b ||\r\n                    (cp >= 0x0d && cp <= 0x1f) ||\r\n                    (cp >= 0x7f && cp <= 0x9f)) {\r\n                    cp = CCR_REPLACEMENTS[cp] || cp;\r\n                }\r\n                decodedText += String.fromCodePoint(cp);\r\n                advance(body[0].length);\r\n            }\r\n        }\r\n    }\r\n    return decodedText;\r\n};\r\n// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\r\nconst CCR_REPLACEMENTS = {\r\n    0x80: 0x20ac,\r\n    0x82: 0x201a,\r\n    0x83: 0x0192,\r\n    0x84: 0x201e,\r\n    0x85: 0x2026,\r\n    0x86: 0x2020,\r\n    0x87: 0x2021,\r\n    0x88: 0x02c6,\r\n    0x89: 0x2030,\r\n    0x8a: 0x0160,\r\n    0x8b: 0x2039,\r\n    0x8c: 0x0152,\r\n    0x8e: 0x017d,\r\n    0x91: 0x2018,\r\n    0x92: 0x2019,\r\n    0x93: 0x201c,\r\n    0x94: 0x201d,\r\n    0x95: 0x2022,\r\n    0x96: 0x2013,\r\n    0x97: 0x2014,\r\n    0x98: 0x02dc,\r\n    0x99: 0x2122,\r\n    0x9a: 0x0161,\r\n    0x9b: 0x203a,\r\n    0x9c: 0x0153,\r\n    0x9e: 0x017e,\r\n    0x9f: 0x0178\r\n};\n\nconst isRawTextContainer = /*#__PURE__*/ shared.makeMap('style,iframe,script,noscript', true);\r\nconst parserOptions = {\r\n    isVoidTag: shared.isVoidTag,\r\n    isNativeTag: tag => shared.isHTMLTag(tag) || shared.isSVGTag(tag),\r\n    isPreTag: tag => tag === 'pre',\r\n    decodeEntities: decodeHtml,\r\n    isBuiltInComponent: (tag) => {\r\n        if (compilerCore.isBuiltInType(tag, `Transition`)) {\r\n            return TRANSITION;\r\n        }\r\n        else if (compilerCore.isBuiltInType(tag, `TransitionGroup`)) {\r\n            return TRANSITION_GROUP;\r\n        }\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n    getNamespace(tag, parent) {\r\n        let ns = parent ? parent.ns : 0 /* HTML */;\r\n        if (parent && ns === 2 /* MATH_ML */) {\r\n            if (parent.tag === 'annotation-xml') {\r\n                if (tag === 'svg') {\r\n                    return 1 /* SVG */;\r\n                }\r\n                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&\r\n                    a.name === 'encoding' &&\r\n                    a.value != null &&\r\n                    (a.value.content === 'text/html' ||\r\n                        a.value.content === 'application/xhtml+xml'))) {\r\n                    ns = 0 /* HTML */;\r\n                }\r\n            }\r\n            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\r\n                tag !== 'mglyph' &&\r\n                tag !== 'malignmark') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        else if (parent && ns === 1 /* SVG */) {\r\n            if (parent.tag === 'foreignObject' ||\r\n                parent.tag === 'desc' ||\r\n                parent.tag === 'title') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === 'svg') {\r\n                return 1 /* SVG */;\r\n            }\r\n            if (tag === 'math') {\r\n                return 2 /* MATH_ML */;\r\n            }\r\n        }\r\n        return ns;\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n    getTextMode({ tag, ns }) {\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === 'textarea' || tag === 'title') {\r\n                return 1 /* RCDATA */;\r\n            }\r\n            if (isRawTextContainer(tag)) {\r\n                return 2 /* RAWTEXT */;\r\n            }\r\n        }\r\n        return 0 /* DATA */;\r\n    }\r\n};\n\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nconst transformStyle = node => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        node.props.forEach((p, i) => {\r\n            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {\r\n                // replace p with an expression node\r\n                node.props[i] = {\r\n                    type: 7 /* DIRECTIVE */,\r\n                    name: `bind`,\r\n                    arg: compilerCore.createSimpleExpression(`style`, true, p.loc),\r\n                    exp: parseInlineCSS(p.value.content, p.loc),\r\n                    modifiers: [],\r\n                    loc: p.loc\r\n                };\r\n            }\r\n        });\r\n    }\r\n};\r\nconst parseInlineCSS = (cssText, loc) => {\r\n    const normalized = shared.parseStringStyle(cssText);\r\n    return compilerCore.createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);\r\n};\n\nfunction createDOMCompilerError(code, loc) {\r\n    return compilerCore.createCompilerError(code, loc, DOMErrorMessages );\r\n}\r\nconst DOMErrorMessages = {\r\n    [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\r\n    [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\r\n    [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\r\n    [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\r\n    [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n    [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\r\n    [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n    [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\r\n    [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\r\n    [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\r\n    [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n};\n\nconst transformVHtml = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`innerHTML`, true, loc), exp || compilerCore.createSimpleExpression('', true))\r\n        ]\r\n    };\r\n};\n\nconst transformVText = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            compilerCore.createObjectProperty(compilerCore.createSimpleExpression(`textContent`, true), exp\r\n                ? compilerCore.createCallExpression(context.helperString(compilerCore.TO_DISPLAY_STRING), [exp], loc)\r\n                : compilerCore.createSimpleExpression('', true))\r\n        ]\r\n    };\r\n};\n\nconst transformModel = (dir, node, context) => {\r\n    const baseResult = compilerCore.transformModel(dir, node, context);\r\n    // base transform has errors OR component v-model (only need props)\r\n    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {\r\n        return baseResult;\r\n    }\r\n    if (dir.arg) {\r\n        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\r\n    }\r\n    const { tag } = node;\r\n    const isCustomElement = context.isCustomElement(tag);\r\n    if (tag === 'input' ||\r\n        tag === 'textarea' ||\r\n        tag === 'select' ||\r\n        isCustomElement) {\r\n        let directiveToUse = V_MODEL_TEXT;\r\n        let isInvalidType = false;\r\n        if (tag === 'input' || isCustomElement) {\r\n            const type = compilerCore.findProp(node, `type`);\r\n            if (type) {\r\n                if (type.type === 7 /* DIRECTIVE */) {\r\n                    // :type=\"foo\"\r\n                    directiveToUse = V_MODEL_DYNAMIC;\r\n                }\r\n                else if (type.value) {\r\n                    switch (type.value.content) {\r\n                        case 'radio':\r\n                            directiveToUse = V_MODEL_RADIO;\r\n                            break;\r\n                        case 'checkbox':\r\n                            directiveToUse = V_MODEL_CHECKBOX;\r\n                            break;\r\n                        case 'file':\r\n                            isInvalidType = true;\r\n                            context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            else if (compilerCore.hasDynamicKeyVBind(node)) {\r\n                // element has bindings with dynamic keys, which can possibly contain\r\n                // \"type\".\r\n                directiveToUse = V_MODEL_DYNAMIC;\r\n            }\r\n            else ;\r\n        }\r\n        else if (tag === 'select') {\r\n            directiveToUse = V_MODEL_SELECT;\r\n        }\r\n        else ;\r\n        // inject runtime directive\r\n        // by returning the helper symbol via needRuntime\r\n        // the import will replaced a resolveDirective call.\r\n        if (!isInvalidType) {\r\n            baseResult.needRuntime = context.helper(directiveToUse);\r\n        }\r\n    }\r\n    else {\r\n        context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\r\n    }\r\n    // native vmodel doesn't need the `modelValue` props since they are also\r\n    // passed to the runtime as `binding.value`. removing it reduces code size.\r\n    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n        p.key.content === 'modelValue'));\r\n    return baseResult;\r\n};\n\nconst isEventOptionModifier = /*#__PURE__*/ shared.makeMap(`passive,once,capture`);\r\nconst isNonKeyModifier = /*#__PURE__*/ shared.makeMap(\r\n// event propagation management\r\n`stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`);\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ shared.makeMap('left,right');\r\nconst isKeyboardEvent = /*#__PURE__*/ shared.makeMap(`onkeyup,onkeydown,onkeypress`, true);\r\nconst resolveModifiers = (key, modifiers) => {\r\n    const keyModifiers = [];\r\n    const nonKeyModifiers = [];\r\n    const eventOptionModifiers = [];\r\n    for (let i = 0; i < modifiers.length; i++) {\r\n        const modifier = modifiers[i];\r\n        if (isEventOptionModifier(modifier)) {\r\n            // eventOptionModifiers: modifiers for addEventListener() options,\r\n            // e.g. .passive & .capture\r\n            eventOptionModifiers.push(modifier);\r\n        }\r\n        else {\r\n            // runtimeModifiers: modifiers that needs runtime guards\r\n            if (maybeKeyModifier(modifier)) {\r\n                if (compilerCore.isStaticExp(key)) {\r\n                    if (isKeyboardEvent(key.content)) {\r\n                        keyModifiers.push(modifier);\r\n                    }\r\n                    else {\r\n                        nonKeyModifiers.push(modifier);\r\n                    }\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n            }\r\n            else {\r\n                if (isNonKeyModifier(modifier)) {\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        keyModifiers,\r\n        nonKeyModifiers,\r\n        eventOptionModifiers\r\n    };\r\n};\r\nconst transformClick = (key, event) => {\r\n    const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === 'onclick';\r\n    return isStaticClick\r\n        ? compilerCore.createSimpleExpression(event, true)\r\n        : key.type !== 4 /* SIMPLE_EXPRESSION */\r\n            ? compilerCore.createCompoundExpression([\r\n                `(`,\r\n                key,\r\n                `) === \"onClick\" ? \"${event}\" : (`,\r\n                key,\r\n                `)`\r\n            ])\r\n            : key;\r\n};\r\nconst transformOn = (dir, node, context) => {\r\n    return compilerCore.transformOn(dir, node, context, baseResult => {\r\n        const { modifiers } = dir;\r\n        if (!modifiers.length)\r\n            return baseResult;\r\n        let { key, value: handlerExp } = baseResult.props[0];\r\n        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);\r\n        // normalize click.right and click.middle since they don't actually fire\r\n        if (nonKeyModifiers.includes('right')) {\r\n            key = transformClick(key, `onContextmenu`);\r\n        }\r\n        if (nonKeyModifiers.includes('middle')) {\r\n            key = transformClick(key, `onMouseup`);\r\n        }\r\n        if (nonKeyModifiers.length) {\r\n            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n                handlerExp,\r\n                JSON.stringify(nonKeyModifiers)\r\n            ]);\r\n        }\r\n        if (keyModifiers.length &&\r\n            // if event name is dynamic, always wrap with keys guard\r\n            (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content))) {\r\n            handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n                handlerExp,\r\n                JSON.stringify(keyModifiers)\r\n            ]);\r\n        }\r\n        if (eventOptionModifiers.length) {\r\n            const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join('');\r\n            key = compilerCore.isStaticExp(key)\r\n                ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n                : compilerCore.createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\r\n        }\r\n        return {\r\n            props: [compilerCore.createObjectProperty(key, handlerExp)]\r\n        };\r\n    });\r\n};\n\nconst transformShow = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));\r\n    }\r\n    return {\r\n        props: [],\r\n        needRuntime: context.helper(V_SHOW)\r\n    };\r\n};\n\n/**\r\n * This module is Node-only.\r\n */\r\n/**\r\n * Turn eligible hoisted static trees into stringified static nodes, e.g.\r\n *\r\n * ```js\r\n * const _hoisted_1 = createStaticVNode(`<div class=\"foo\">bar</div>`)\r\n * ```\r\n *\r\n * A single static vnode can contain stringified content for **multiple**\r\n * consecutive nodes (element and plain text), called a \"chunk\".\r\n * `@vue/runtime-dom` will create the content via innerHTML in a hidden\r\n * container element and insert all the nodes in place. The call must also\r\n * provide the number of nodes contained in the chunk so that during hydration\r\n * we can know how many nodes the static vnode should adopt.\r\n *\r\n * The optimization scans a children list that contains hoisted nodes, and\r\n * tries to find the largest chunk of consecutive hoisted nodes before running\r\n * into a non-hoisted node or the end of the list. A chunk is then converted\r\n * into a single static vnode and replaces the hoisted expression of the first\r\n * node in the chunk. Other nodes in the chunk are considered \"merged\" and\r\n * therefore removed from both the hoist list and the children array.\r\n *\r\n * This optimization is only performed in Node.js.\r\n */\r\nconst stringifyStatic = (children, context, parent) => {\r\n    // bail stringification for slot content\r\n    if (context.scopes.vSlot > 0) {\r\n        return;\r\n    }\r\n    let nc = 0; // current node count\r\n    let ec = 0; // current element with binding count\r\n    const currentChunk = [];\r\n    const stringifyCurrentChunk = (currentIndex) => {\r\n        if (nc >= 20 /* NODE_COUNT */ ||\r\n            ec >= 5 /* ELEMENT_WITH_BINDING_COUNT */) {\r\n            // combine all currently eligible nodes into a single static vnode call\r\n            const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [\r\n                JSON.stringify(currentChunk.map(node => stringifyNode(node, context)).join('')),\r\n                // the 2nd argument indicates the number of DOM nodes this static vnode\r\n                // will insert / hydrate\r\n                String(currentChunk.length)\r\n            ]);\r\n            // replace the first node's hoisted expression with the static vnode call\r\n            replaceHoist(currentChunk[0], staticCall, context);\r\n            if (currentChunk.length > 1) {\r\n                for (let i = 1; i < currentChunk.length; i++) {\r\n                    // for the merged nodes, set their hoisted expression to null\r\n                    replaceHoist(currentChunk[i], null, context);\r\n                }\r\n                // also remove merged nodes from children\r\n                const deleteCount = currentChunk.length - 1;\r\n                children.splice(currentIndex - currentChunk.length + 1, deleteCount);\r\n                return deleteCount;\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    let i = 0;\r\n    for (; i < children.length; i++) {\r\n        const child = children[i];\r\n        const hoisted = getHoistedNode(child);\r\n        if (hoisted) {\r\n            // presence of hoisted means child must be a stringifiable node\r\n            const node = child;\r\n            const result = analyzeNode(node);\r\n            if (result) {\r\n                // node is stringifiable, record state\r\n                nc += result[0];\r\n                ec += result[1];\r\n                currentChunk.push(node);\r\n                continue;\r\n            }\r\n        }\r\n        // we only reach here if we ran into a node that is not stringifiable\r\n        // check if currently analyzed nodes meet criteria for stringification.\r\n        // adjust iteration index\r\n        i -= stringifyCurrentChunk(i);\r\n        // reset state\r\n        nc = 0;\r\n        ec = 0;\r\n        currentChunk.length = 0;\r\n    }\r\n    // in case the last node was also stringifiable\r\n    stringifyCurrentChunk(i);\r\n};\r\nconst getHoistedNode = (node) => ((node.type === 1 /* ELEMENT */ && node.tagType === 0 /* ELEMENT */) ||\r\n    node.type == 12 /* TEXT_CALL */) &&\r\n    node.codegenNode &&\r\n    node.codegenNode.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n    node.codegenNode.hoisted;\r\nconst dataAriaRE = /^(data|aria)-/;\r\nconst isStringifiableAttr = (name) => {\r\n    return shared.isKnownAttr(name) || dataAriaRE.test(name);\r\n};\r\nconst replaceHoist = (node, replacement, context) => {\r\n    const hoistToReplace = node.codegenNode.hoisted;\r\n    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;\r\n};\r\nconst isNonStringifiable = /*#__PURE__*/ shared.makeMap(`caption,thead,tr,th,tbody,td,tfoot,colgroup,col`);\r\n/**\r\n * for a hoisted node, analyze it and return:\r\n * - false: bailed (contains runtime constant)\r\n * - [nc, ec] where\r\n *   - nc is the number of nodes inside\r\n *   - ec is the number of element with bindings inside\r\n */\r\nfunction analyzeNode(node) {\r\n    if (node.type === 1 /* ELEMENT */ && isNonStringifiable(node.tag)) {\r\n        return false;\r\n    }\r\n    if (node.type === 12 /* TEXT_CALL */) {\r\n        return [1, 0];\r\n    }\r\n    let nc = 1; // node count\r\n    let ec = node.props.length > 0 ? 1 : 0; // element w/ binding count\r\n    let bailed = false;\r\n    const bail = () => {\r\n        bailed = true;\r\n        return false;\r\n    };\r\n    // TODO: check for cases where using innerHTML will result in different\r\n    // output compared to imperative node insertions.\r\n    // probably only need to check for most common case\r\n    // i.e. non-phrasing-content tags inside `<p>`\r\n    function walk(node) {\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const p = node.props[i];\r\n            // bail on non-attr bindings\r\n            if (p.type === 6 /* ATTRIBUTE */ && !isStringifiableAttr(p.name)) {\r\n                return bail();\r\n            }\r\n            if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind') {\r\n                // bail on non-attr bindings\r\n                if (p.arg &&\r\n                    (p.arg.type === 8 /* COMPOUND_EXPRESSION */ ||\r\n                        (p.arg.isStatic && !isStringifiableAttr(p.arg.content)))) {\r\n                    return bail();\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            nc++;\r\n            const child = node.children[i];\r\n            if (child.type === 1 /* ELEMENT */) {\r\n                if (child.props.length > 0) {\r\n                    ec++;\r\n                }\r\n                walk(child);\r\n                if (bailed) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return walk(node) ? [nc, ec] : false;\r\n}\r\nfunction stringifyNode(node, context) {\r\n    if (shared.isString(node)) {\r\n        return node;\r\n    }\r\n    if (shared.isSymbol(node)) {\r\n        return ``;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            return stringifyElement(node, context);\r\n        case 2 /* TEXT */:\r\n            return shared.escapeHtml(node.content);\r\n        case 3 /* COMMENT */:\r\n            return `<!--${shared.escapeHtml(node.content)}-->`;\r\n        case 5 /* INTERPOLATION */:\r\n            return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            return shared.escapeHtml(evaluateConstant(node));\r\n        case 12 /* TEXT_CALL */:\r\n            return stringifyNode(node.content, context);\r\n        default:\r\n            // static trees will not contain if/for nodes\r\n            return '';\r\n    }\r\n}\r\nfunction stringifyElement(node, context) {\r\n    let res = `<${node.tag}`;\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            res += ` ${p.name}`;\r\n            if (p.value) {\r\n                res += `=\"${shared.escapeHtml(p.value.content)}\"`;\r\n            }\r\n        }\r\n        else if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind') {\r\n            // constant v-bind, e.g. :foo=\"1\"\r\n            let evaluated = evaluateConstant(p.exp);\r\n            if (evaluated != null) {\r\n                const arg = p.arg && p.arg.content;\r\n                if (arg === 'class') {\r\n                    evaluated = shared.normalizeClass(evaluated);\r\n                }\r\n                else if (arg === 'style') {\r\n                    evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));\r\n                }\r\n                res += ` ${p.arg.content}=\"${shared.escapeHtml(evaluated)}\"`;\r\n            }\r\n        }\r\n    }\r\n    if (context.scopeId) {\r\n        res += ` ${context.scopeId}`;\r\n    }\r\n    res += `>`;\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        res += stringifyNode(node.children[i], context);\r\n    }\r\n    if (!shared.isVoidTag(node.tag)) {\r\n        res += `</${node.tag}>`;\r\n    }\r\n    return res;\r\n}\r\n// __UNSAFE__\r\n// Reason: eval.\r\n// It's technically safe to eval because only constant expressions are possible\r\n// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`\r\n// in addition, constant exps bail on presence of parens so you can't even\r\n// run JSFuck in here. But we mark it unsafe for security review purposes.\r\n// (see compiler-core/src/transformExpressions)\r\nfunction evaluateConstant(exp) {\r\n    if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        return new Function(`return ${exp.content}`)();\r\n    }\r\n    else {\r\n        // compound\r\n        let res = ``;\r\n        exp.children.forEach(c => {\r\n            if (shared.isString(c) || shared.isSymbol(c)) {\r\n                return;\r\n            }\r\n            if (c.type === 2 /* TEXT */) {\r\n                res += c.content;\r\n            }\r\n            else if (c.type === 5 /* INTERPOLATION */) {\r\n                res += shared.toDisplayString(evaluateConstant(c.content));\r\n            }\r\n            else {\r\n                res += evaluateConstant(c);\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n}\n\nconst ignoreSideEffectTags = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 0 /* ELEMENT */ &&\r\n        (node.tag === 'script' || node.tag === 'style')) {\r\n        context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\r\n        context.removeNode();\r\n    }\r\n};\n\nconst DOMNodeTransforms = [\r\n    transformStyle,\r\n    ...([])\r\n];\r\nconst DOMDirectiveTransforms = {\r\n    cloak: compilerCore.noopDirectiveTransform,\r\n    html: transformVHtml,\r\n    text: transformVText,\r\n    model: transformModel,\r\n    on: transformOn,\r\n    show: transformShow\r\n};\r\nfunction compile(template, options = {}) {\r\n    return compilerCore.baseCompile(template, shared.extend({}, parserOptions, options, {\r\n        nodeTransforms: [\r\n            // ignore <script> and <tag>\r\n            // this is not put inside DOMNodeTransforms because that list is used\r\n            // by compiler-ssr to generate vnode fallback branches\r\n            ignoreSideEffectTags,\r\n            ...DOMNodeTransforms,\r\n            ...(options.nodeTransforms || [])\r\n        ],\r\n        directiveTransforms: shared.extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\r\n        transformHoist: stringifyStatic\r\n    }));\r\n}\r\nfunction parse(template, options = {}) {\r\n    return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));\r\n}\n\nObject.keys(compilerCore).forEach(function (k) {\n  if (k !== 'default') exports[k] = compilerCore[k];\n});\nexports.DOMDirectiveTransforms = DOMDirectiveTransforms;\nexports.DOMNodeTransforms = DOMNodeTransforms;\nexports.TRANSITION = TRANSITION;\nexports.TRANSITION_GROUP = TRANSITION_GROUP;\nexports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;\nexports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;\nexports.V_MODEL_RADIO = V_MODEL_RADIO;\nexports.V_MODEL_SELECT = V_MODEL_SELECT;\nexports.V_MODEL_TEXT = V_MODEL_TEXT;\nexports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;\nexports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;\nexports.V_SHOW = V_SHOW;\nexports.compile = compile;\nexports.createDOMCompilerError = createDOMCompilerError;\nexports.parse = parse;\nexports.parserOptions = parserOptions;\nexports.transformStyle = transformStyle;\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/compiler-core.cjs.prod.js')\n} else {\n  module.exports = require('./dist/compiler-core.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar shared = require('@vue/shared');\nvar sourceMap = require('source-map');\nvar parser = require('@babel/parser');\nvar estreeWalker = require('estree-walker');\n\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\r\nfunction createCompilerError(code, loc, messages, additionalMessage) {\r\n    const msg = (messages || errorMessages)[code] + (additionalMessage || ``)\r\n        ;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    error.loc = loc;\r\n    return error;\r\n}\r\nconst errorMessages = {\r\n    // parse errors\r\n    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',\r\n    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',\r\n    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',\r\n    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',\r\n    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: \"Illegal '/' in tags.\",\r\n    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',\r\n    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',\r\n    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',\r\n    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',\r\n    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',\r\n    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',\r\n    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',\r\n    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: \"Illegal tag name. Use '&lt;' to print '<'.\",\r\n    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',\r\n    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',\r\n    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',\r\n    [16 /* NESTED_COMMENT */]: \"Unexpected '<!--' in comment.\",\r\n    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\r\n    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\r\n    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: \"Attribute name cannot start with '='.\",\r\n    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: \"'<?' is allowed only in XML context.\",\r\n    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: \"Illegal '/' in tags.\",\r\n    // Vue-specific parse errors\r\n    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',\r\n    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',\r\n    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',\r\n    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +\r\n        'Note that dynamic directive argument cannot contain spaces.',\r\n    // transform errors\r\n    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\r\n    [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\r\n    [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,\r\n    [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\r\n    [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\r\n    [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\r\n    [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\r\n    [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\r\n    [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\r\n    [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +\r\n        `When there are multiple named slots, all slots should use <template> ` +\r\n        `syntax to avoid scope ambiguity.`,\r\n    [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\r\n    [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\r\n        `default slot. These children will be ignored.`,\r\n    [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\r\n    [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\r\n    [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\r\n    [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n    [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\r\n    [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\r\n    // generic errors\r\n    [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\r\n    [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\r\n    [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\r\n    [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `\"scopeId\" option is only supported in module mode.`\r\n};\n\nconst FRAGMENT = Symbol(``);\r\nconst TELEPORT = Symbol(``);\r\nconst SUSPENSE = Symbol(``);\r\nconst KEEP_ALIVE = Symbol(``);\r\nconst BASE_TRANSITION = Symbol(``);\r\nconst OPEN_BLOCK = Symbol(``);\r\nconst CREATE_BLOCK = Symbol(``);\r\nconst CREATE_VNODE = Symbol(``);\r\nconst CREATE_COMMENT = Symbol(``);\r\nconst CREATE_TEXT = Symbol(``);\r\nconst CREATE_STATIC = Symbol(``);\r\nconst RESOLVE_COMPONENT = Symbol(``);\r\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol(``);\r\nconst RESOLVE_DIRECTIVE = Symbol(``);\r\nconst WITH_DIRECTIVES = Symbol(``);\r\nconst RENDER_LIST = Symbol(``);\r\nconst RENDER_SLOT = Symbol(``);\r\nconst CREATE_SLOTS = Symbol(``);\r\nconst TO_DISPLAY_STRING = Symbol(``);\r\nconst MERGE_PROPS = Symbol(``);\r\nconst TO_HANDLERS = Symbol(``);\r\nconst CAMELIZE = Symbol(``);\r\nconst CAPITALIZE = Symbol(``);\r\nconst TO_HANDLER_KEY = Symbol(``);\r\nconst SET_BLOCK_TRACKING = Symbol(``);\r\nconst PUSH_SCOPE_ID = Symbol(``);\r\nconst POP_SCOPE_ID = Symbol(``);\r\nconst WITH_SCOPE_ID = Symbol(``);\r\nconst WITH_CTX = Symbol(``);\r\nconst UNREF = Symbol(``);\r\nconst IS_REF = Symbol(``);\r\n// Name mapping for runtime helpers that need to be imported from 'vue' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\n// Using `any` here because TS doesn't allow symbols as index type.\r\nconst helperNameMap = {\r\n    [FRAGMENT]: `Fragment`,\r\n    [TELEPORT]: `Teleport`,\r\n    [SUSPENSE]: `Suspense`,\r\n    [KEEP_ALIVE]: `KeepAlive`,\r\n    [BASE_TRANSITION]: `BaseTransition`,\r\n    [OPEN_BLOCK]: `openBlock`,\r\n    [CREATE_BLOCK]: `createBlock`,\r\n    [CREATE_VNODE]: `createVNode`,\r\n    [CREATE_COMMENT]: `createCommentVNode`,\r\n    [CREATE_TEXT]: `createTextVNode`,\r\n    [CREATE_STATIC]: `createStaticVNode`,\r\n    [RESOLVE_COMPONENT]: `resolveComponent`,\r\n    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n    [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n    [WITH_DIRECTIVES]: `withDirectives`,\r\n    [RENDER_LIST]: `renderList`,\r\n    [RENDER_SLOT]: `renderSlot`,\r\n    [CREATE_SLOTS]: `createSlots`,\r\n    [TO_DISPLAY_STRING]: `toDisplayString`,\r\n    [MERGE_PROPS]: `mergeProps`,\r\n    [TO_HANDLERS]: `toHandlers`,\r\n    [CAMELIZE]: `camelize`,\r\n    [CAPITALIZE]: `capitalize`,\r\n    [TO_HANDLER_KEY]: `toHandlerKey`,\r\n    [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n    [PUSH_SCOPE_ID]: `pushScopeId`,\r\n    [POP_SCOPE_ID]: `popScopeId`,\r\n    [WITH_SCOPE_ID]: `withScopeId`,\r\n    [WITH_CTX]: `withCtx`,\r\n    [UNREF]: `unref`,\r\n    [IS_REF]: `isRef`\r\n};\r\nfunction registerRuntimeHelpers(helpers) {\r\n    Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n        helperNameMap[s] = helpers[s];\r\n    });\r\n}\n\n// AST Utilities ---------------------------------------------------------------\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don't need a real location.\r\nconst locStub = {\r\n    source: '',\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createRoot(children, loc = locStub) {\r\n    return {\r\n        type: 0 /* ROOT */,\r\n        children,\r\n        helpers: [],\r\n        components: [],\r\n        directives: [],\r\n        hoists: [],\r\n        imports: [],\r\n        cached: 0,\r\n        temps: 0,\r\n        codegenNode: undefined,\r\n        loc\r\n    };\r\n}\r\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {\r\n    if (context) {\r\n        if (isBlock) {\r\n            context.helper(OPEN_BLOCK);\r\n            context.helper(CREATE_BLOCK);\r\n        }\r\n        else {\r\n            context.helper(CREATE_VNODE);\r\n        }\r\n        if (directives) {\r\n            context.helper(WITH_DIRECTIVES);\r\n        }\r\n    }\r\n    return {\r\n        type: 13 /* VNODE_CALL */,\r\n        tag,\r\n        props,\r\n        children,\r\n        patchFlag,\r\n        dynamicProps,\r\n        directives,\r\n        isBlock,\r\n        disableTracking,\r\n        loc\r\n    };\r\n}\r\nfunction createArrayExpression(elements, loc = locStub) {\r\n    return {\r\n        type: 17 /* JS_ARRAY_EXPRESSION */,\r\n        loc,\r\n        elements\r\n    };\r\n}\r\nfunction createObjectExpression(properties, loc = locStub) {\r\n    return {\r\n        type: 15 /* JS_OBJECT_EXPRESSION */,\r\n        loc,\r\n        properties\r\n    };\r\n}\r\nfunction createObjectProperty(key, value) {\r\n    return {\r\n        type: 16 /* JS_PROPERTY */,\r\n        loc: locStub,\r\n        key: shared.isString(key) ? createSimpleExpression(key, true) : key,\r\n        value\r\n    };\r\n}\r\nfunction createSimpleExpression(content, isStatic, loc = locStub, constType = 0 /* NOT_CONSTANT */) {\r\n    return {\r\n        type: 4 /* SIMPLE_EXPRESSION */,\r\n        loc,\r\n        content,\r\n        isStatic,\r\n        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType\r\n    };\r\n}\r\nfunction createInterpolation(content, loc) {\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        loc,\r\n        content: shared.isString(content)\r\n            ? createSimpleExpression(content, false, loc)\r\n            : content\r\n    };\r\n}\r\nfunction createCompoundExpression(children, loc = locStub) {\r\n    return {\r\n        type: 8 /* COMPOUND_EXPRESSION */,\r\n        loc,\r\n        children\r\n    };\r\n}\r\nfunction createCallExpression(callee, args = [], loc = locStub) {\r\n    return {\r\n        type: 14 /* JS_CALL_EXPRESSION */,\r\n        loc,\r\n        callee,\r\n        arguments: args\r\n    };\r\n}\r\nfunction createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\r\n    return {\r\n        type: 18 /* JS_FUNCTION_EXPRESSION */,\r\n        params,\r\n        returns,\r\n        newline,\r\n        isSlot,\r\n        loc\r\n    };\r\n}\r\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\r\n    return {\r\n        type: 19 /* JS_CONDITIONAL_EXPRESSION */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        newline,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createCacheExpression(index, value, isVNode = false) {\r\n    return {\r\n        type: 20 /* JS_CACHE_EXPRESSION */,\r\n        index,\r\n        value,\r\n        isVNode,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createBlockStatement(body) {\r\n    return {\r\n        type: 21 /* JS_BLOCK_STATEMENT */,\r\n        body,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createTemplateLiteral(elements) {\r\n    return {\r\n        type: 22 /* JS_TEMPLATE_LITERAL */,\r\n        elements,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createIfStatement(test, consequent, alternate) {\r\n    return {\r\n        type: 23 /* JS_IF_STATEMENT */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createAssignmentExpression(left, right) {\r\n    return {\r\n        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,\r\n        left,\r\n        right,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createSequenceExpression(expressions) {\r\n    return {\r\n        type: 25 /* JS_SEQUENCE_EXPRESSION */,\r\n        expressions,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createReturnStatement(returns) {\r\n    return {\r\n        type: 26 /* JS_RETURN_STATEMENT */,\r\n        returns,\r\n        loc: locStub\r\n    };\r\n}\n\nconst isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\r\nconst isBuiltInType = (tag, expected) => tag === expected || tag === shared.hyphenate(expected);\r\nfunction isCoreComponent(tag) {\r\n    if (isBuiltInType(tag, 'Teleport')) {\r\n        return TELEPORT;\r\n    }\r\n    else if (isBuiltInType(tag, 'Suspense')) {\r\n        return SUSPENSE;\r\n    }\r\n    else if (isBuiltInType(tag, 'KeepAlive')) {\r\n        return KEEP_ALIVE;\r\n    }\r\n    else if (isBuiltInType(tag, 'BaseTransition')) {\r\n        return BASE_TRANSITION;\r\n    }\r\n}\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\r\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\r\nconst memberExpRE = /^[A-Za-z_$\\xA0-\\uFFFF][\\w$\\xA0-\\uFFFF]*(?:\\s*\\.\\s*[A-Za-z_$\\xA0-\\uFFFF][\\w$\\xA0-\\uFFFF]*|\\[[^\\]]+\\])*$/;\r\nconst isMemberExpression = (path) => {\r\n    if (!path)\r\n        return false;\r\n    return memberExpRE.test(path.trim());\r\n};\r\nfunction getInnerRange(loc, offset, length) {\r\n    const source = loc.source.substr(offset, length);\r\n    const newLoc = {\r\n        source,\r\n        start: advancePositionWithClone(loc.start, loc.source, offset),\r\n        end: loc.end\r\n    };\r\n    if (length != null) {\r\n        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\r\n    }\r\n    return newLoc;\r\n}\r\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\r\n    return advancePositionWithMutation(shared.extend({}, pos), source, numberOfCharacters);\r\n}\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\r\n    let linesCount = 0;\r\n    let lastNewLinePos = -1;\r\n    for (let i = 0; i < numberOfCharacters; i++) {\r\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n            linesCount++;\r\n            lastNewLinePos = i;\r\n        }\r\n    }\r\n    pos.offset += numberOfCharacters;\r\n    pos.line += linesCount;\r\n    pos.column =\r\n        lastNewLinePos === -1\r\n            ? pos.column + numberOfCharacters\r\n            : numberOfCharacters - lastNewLinePos;\r\n    return pos;\r\n}\r\nfunction assert(condition, msg) {\r\n    /* istanbul ignore if */\r\n    if (!condition) {\r\n        throw new Error(msg || `unexpected compiler condition`);\r\n    }\r\n}\r\nfunction findDir(node, name, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 7 /* DIRECTIVE */ &&\r\n            (allowEmpty || p.exp) &&\r\n            (shared.isString(name) ? p.name === name : name.test(p.name))) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (dynamicOnly)\r\n                continue;\r\n            if (p.name === name && (p.value || allowEmpty)) {\r\n                return p;\r\n            }\r\n        }\r\n        else if (p.name === 'bind' &&\r\n            (p.exp || allowEmpty) &&\r\n            isBindKey(p.arg, name)) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction isBindKey(arg, name) {\r\n    return !!(arg && isStaticExp(arg) && arg.content === name);\r\n}\r\nfunction hasDynamicKeyVBind(node) {\r\n    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&\r\n        p.name === 'bind' &&\r\n        (!p.arg || // v-bind=\"obj\"\r\n            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\r\n            !p.arg.isStatic) // v-bind:[foo]\r\n    );\r\n}\r\nfunction isText(node) {\r\n    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;\r\n}\r\nfunction isVSlot(p) {\r\n    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';\r\n}\r\nfunction isTemplateNode(node) {\r\n    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);\r\n}\r\nfunction isSlotOutlet(node) {\r\n    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\r\n}\r\nfunction injectProp(node, prop, context) {\r\n    let propsWithInjection;\r\n    const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];\r\n    if (props == null || shared.isString(props)) {\r\n        propsWithInjection = createObjectExpression([prop]);\r\n    }\r\n    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n        // merged props... add ours\r\n        // only inject key to object literal if it's the first argument so that\r\n        // if doesn't override user provided keys\r\n        const first = props.arguments[0];\r\n        if (!shared.isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n            first.properties.unshift(prop);\r\n        }\r\n        else {\r\n            if (props.callee === TO_HANDLERS) {\r\n                // #2366\r\n                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n                    createObjectExpression([prop]),\r\n                    props\r\n                ]);\r\n            }\r\n            else {\r\n                props.arguments.unshift(createObjectExpression([prop]));\r\n            }\r\n        }\r\n        !propsWithInjection && (propsWithInjection = props);\r\n    }\r\n    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        let alreadyExists = false;\r\n        // check existing key to avoid overriding user provided keys\r\n        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            const propKeyName = prop.key.content;\r\n            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                p.key.content === propKeyName);\r\n        }\r\n        if (!alreadyExists) {\r\n            props.properties.unshift(prop);\r\n        }\r\n        propsWithInjection = props;\r\n    }\r\n    else {\r\n        // single v-bind with expression, return a merged replacement\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n            createObjectExpression([prop]),\r\n            props\r\n        ]);\r\n    }\r\n    if (node.type === 13 /* VNODE_CALL */) {\r\n        node.props = propsWithInjection;\r\n    }\r\n    else {\r\n        node.arguments[2] = propsWithInjection;\r\n    }\r\n}\r\nfunction toValidAssetId(name, type) {\r\n    return `_${type}_${name.replace(/[^\\w]/g, '_')}`;\r\n}\r\n// Check if a node contains expressions that reference current context scope ids\r\nfunction hasScopeRef(node, ids) {\r\n    if (!node || Object.keys(ids).length === 0) {\r\n        return false;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            for (let i = 0; i < node.props.length; i++) {\r\n                const p = node.props[i];\r\n                if (p.type === 7 /* DIRECTIVE */ &&\r\n                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\r\n                    return true;\r\n                }\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 11 /* FOR */:\r\n            if (hasScopeRef(node.source, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 9 /* IF */:\r\n            return node.branches.some(b => hasScopeRef(b, ids));\r\n        case 10 /* IF_BRANCH */:\r\n            if (hasScopeRef(node.condition, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return (!node.isStatic &&\r\n                isSimpleIdentifier(node.content) &&\r\n                !!ids[node.content]);\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            return node.children.some(c => shared.isObject(c) && hasScopeRef(c, ids));\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return hasScopeRef(node.content, ids);\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return false;\r\n        default:\r\n            return false;\r\n    }\r\n}\n\n// The default decoder only provides escapes for characters reserved as part of\r\n// the template syntax, and is only used if the custom renderer did not provide\r\n// a platform-specific decoder.\r\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\r\nconst decodeMap = {\r\n    gt: '>',\r\n    lt: '<',\r\n    amp: '&',\r\n    apos: \"'\",\r\n    quot: '\"'\r\n};\r\nconst defaultParserOptions = {\r\n    delimiters: [`{{`, `}}`],\r\n    getNamespace: () => 0 /* HTML */,\r\n    getTextMode: () => 0 /* DATA */,\r\n    isVoidTag: shared.NO,\r\n    isPreTag: shared.NO,\r\n    isCustomElement: shared.NO,\r\n    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n    onError: defaultOnError,\r\n    comments: false\r\n};\r\nfunction baseParse(content, options = {}) {\r\n    const context = createParserContext(content, options);\r\n    const start = getCursor(context);\r\n    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));\r\n}\r\nfunction createParserContext(content, rawOptions) {\r\n    const options = shared.extend({}, defaultParserOptions);\r\n    for (const key in rawOptions) {\r\n        // @ts-ignore\r\n        options[key] = rawOptions[key] || defaultParserOptions[key];\r\n    }\r\n    return {\r\n        options,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        originalSource: content,\r\n        source: content,\r\n        inPre: false,\r\n        inVPre: false\r\n    };\r\n}\r\nfunction parseChildren(context, mode, ancestors) {\r\n    const parent = last(ancestors);\r\n    const ns = parent ? parent.ns : 0 /* HTML */;\r\n    const nodes = [];\r\n    while (!isEnd(context, mode, ancestors)) {\r\n        const s = context.source;\r\n        let node = undefined;\r\n        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {\r\n            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n                // '{{'\r\n                node = parseInterpolation(context, mode);\r\n            }\r\n            else if (mode === 0 /* DATA */ && s[0] === '<') {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n                if (s.length === 1) {\r\n                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);\r\n                }\r\n                else if (s[1] === '!') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n                    if (startsWith(s, '<!--')) {\r\n                        node = parseComment(context);\r\n                    }\r\n                    else if (startsWith(s, '<!DOCTYPE')) {\r\n                        // Ignore DOCTYPE by a limitation.\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                    else if (startsWith(s, '<![CDATA[')) {\r\n                        if (ns !== 0 /* HTML */) {\r\n                            node = parseCDATA(context, ancestors);\r\n                        }\r\n                        else {\r\n                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);\r\n                            node = parseBogusComment(context);\r\n                        }\r\n                    }\r\n                    else {\r\n                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (s[1] === '/') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n                    if (s.length === 2) {\r\n                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);\r\n                    }\r\n                    else if (s[2] === '>') {\r\n                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);\r\n                        advanceBy(context, 3);\r\n                        continue;\r\n                    }\r\n                    else if (/[a-z]/i.test(s[2])) {\r\n                        emitError(context, 23 /* X_INVALID_END_TAG */);\r\n                        parseTag(context, 1 /* End */, parent);\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (/[a-z]/i.test(s[1])) {\r\n                    node = parseElement(context, ancestors);\r\n                }\r\n                else if (s[1] === '?') {\r\n                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\r\n                    node = parseBogusComment(context);\r\n                }\r\n                else {\r\n                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\r\n                }\r\n            }\r\n        }\r\n        if (!node) {\r\n            node = parseText(context, mode);\r\n        }\r\n        if (shared.isArray(node)) {\r\n            for (let i = 0; i < node.length; i++) {\r\n                pushNode(nodes, node[i]);\r\n            }\r\n        }\r\n        else {\r\n            pushNode(nodes, node);\r\n        }\r\n    }\r\n    // Whitespace management for more efficient output\r\n    // (same as v2 whitespace: 'condense')\r\n    let removedWhitespace = false;\r\n    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            if (!context.inPre && node.type === 2 /* TEXT */) {\r\n                if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n                    const prev = nodes[i - 1];\r\n                    const next = nodes[i + 1];\r\n                    // If:\r\n                    // - the whitespace is the first or last node, or:\r\n                    // - the whitespace is adjacent to a comment, or:\r\n                    // - the whitespace is between two elements AND contains newline\r\n                    // Then the whitespace is ignored.\r\n                    if (!prev ||\r\n                        !next ||\r\n                        prev.type === 3 /* COMMENT */ ||\r\n                        next.type === 3 /* COMMENT */ ||\r\n                        (prev.type === 1 /* ELEMENT */ &&\r\n                            next.type === 1 /* ELEMENT */ &&\r\n                            /[\\r\\n]/.test(node.content))) {\r\n                        removedWhitespace = true;\r\n                        nodes[i] = null;\r\n                    }\r\n                    else {\r\n                        // Otherwise, condensed consecutive whitespace inside the text\r\n                        // down to a single space\r\n                        node.content = ' ';\r\n                    }\r\n                }\r\n                else {\r\n                    node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ');\r\n                }\r\n            }\r\n            // also remove comment nodes in prod by default\r\n            if (node.type === 3 /* COMMENT */ &&\r\n                !context.options.comments) {\r\n                removedWhitespace = true;\r\n                nodes[i] = null;\r\n            }\r\n        }\r\n        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n            // remove leading newline per html spec\r\n            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n            const first = nodes[0];\r\n            if (first && first.type === 2 /* TEXT */) {\r\n                first.content = first.content.replace(/^\\r?\\n/, '');\r\n            }\r\n        }\r\n    }\r\n    return removedWhitespace ? nodes.filter(Boolean) : nodes;\r\n}\r\nfunction pushNode(nodes, node) {\r\n    if (node.type === 2 /* TEXT */) {\r\n        const prev = last(nodes);\r\n        // Merge if both this and the previous node are text and those are\r\n        // consecutive. This happens for cases like \"a < b\".\r\n        if (prev &&\r\n            prev.type === 2 /* TEXT */ &&\r\n            prev.loc.end.offset === node.loc.start.offset) {\r\n            prev.content += node.content;\r\n            prev.loc.end = node.loc.end;\r\n            prev.loc.source += node.loc.source;\r\n            return;\r\n        }\r\n    }\r\n    nodes.push(node);\r\n}\r\nfunction parseCDATA(context, ancestors) {\r\n    advanceBy(context, 9);\r\n    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\r\n    if (context.source.length === 0) {\r\n        emitError(context, 6 /* EOF_IN_CDATA */);\r\n    }\r\n    else {\r\n        advanceBy(context, 3);\r\n    }\r\n    return nodes;\r\n}\r\nfunction parseComment(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    // Regular comment.\r\n    const match = /--(\\!)?>/.exec(context.source);\r\n    if (!match) {\r\n        content = context.source.slice(4);\r\n        advanceBy(context, context.source.length);\r\n        emitError(context, 7 /* EOF_IN_COMMENT */);\r\n    }\r\n    else {\r\n        if (match.index <= 3) {\r\n            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\r\n        }\r\n        if (match[1]) {\r\n            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);\r\n        }\r\n        content = context.source.slice(4, match.index);\r\n        // Advancing with reporting nested comments.\r\n        const s = context.source.slice(0, match.index);\r\n        let prevIndex = 1, nestedIndex = 0;\r\n        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\r\n            advanceBy(context, nestedIndex - prevIndex + 1);\r\n            if (nestedIndex + 4 < s.length) {\r\n                emitError(context, 16 /* NESTED_COMMENT */);\r\n            }\r\n            prevIndex = nestedIndex + 1;\r\n        }\r\n        advanceBy(context, match.index + match[0].length - prevIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseBogusComment(context) {\r\n    const start = getCursor(context);\r\n    const contentStart = context.source[1] === '?' ? 1 : 2;\r\n    let content;\r\n    const closeIndex = context.source.indexOf('>');\r\n    if (closeIndex === -1) {\r\n        content = context.source.slice(contentStart);\r\n        advanceBy(context, context.source.length);\r\n    }\r\n    else {\r\n        content = context.source.slice(contentStart, closeIndex);\r\n        advanceBy(context, closeIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseElement(context, ancestors) {\r\n    // Start tag.\r\n    const wasInPre = context.inPre;\r\n    const wasInVPre = context.inVPre;\r\n    const parent = last(ancestors);\r\n    const element = parseTag(context, 0 /* Start */, parent);\r\n    const isPreBoundary = context.inPre && !wasInPre;\r\n    const isVPreBoundary = context.inVPre && !wasInVPre;\r\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n        return element;\r\n    }\r\n    // Children.\r\n    ancestors.push(element);\r\n    const mode = context.options.getTextMode(element, parent);\r\n    const children = parseChildren(context, mode, ancestors);\r\n    ancestors.pop();\r\n    element.children = children;\r\n    // End tag.\r\n    if (startsWithEndTagOpen(context.source, element.tag)) {\r\n        parseTag(context, 1 /* End */, parent);\r\n    }\r\n    else {\r\n        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);\r\n        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\r\n            const first = children[0];\r\n            if (first && startsWith(first.loc.source, '<!--')) {\r\n                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\r\n            }\r\n        }\r\n    }\r\n    element.loc = getSelection(context, element.loc.start);\r\n    if (isPreBoundary) {\r\n        context.inPre = false;\r\n    }\r\n    if (isVPreBoundary) {\r\n        context.inVPre = false;\r\n    }\r\n    return element;\r\n}\r\nconst isSpecialTemplateDirective = /*#__PURE__*/ shared.makeMap(`if,else,else-if,for,slot`);\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(context, type, parent) {\r\n    // Tag open.\r\n    const start = getCursor(context);\r\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\r\n    const tag = match[1];\r\n    const ns = context.options.getNamespace(tag, parent);\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n    // save current state in case we need to re-parse attributes with v-pre\r\n    const cursor = getCursor(context);\r\n    const currentSource = context.source;\r\n    // Attributes.\r\n    let props = parseAttributes(context, type);\r\n    // check <pre> tag\r\n    if (context.options.isPreTag(tag)) {\r\n        context.inPre = true;\r\n    }\r\n    // check v-pre\r\n    if (!context.inVPre &&\r\n        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {\r\n        context.inVPre = true;\r\n        // reset context\r\n        shared.extend(context, cursor);\r\n        context.source = currentSource;\r\n        // re-parse attrs and filter out v-pre itself\r\n        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');\r\n    }\r\n    // Tag close.\r\n    let isSelfClosing = false;\r\n    if (context.source.length === 0) {\r\n        emitError(context, 9 /* EOF_IN_TAG */);\r\n    }\r\n    else {\r\n        isSelfClosing = startsWith(context.source, '/>');\r\n        if (type === 1 /* End */ && isSelfClosing) {\r\n            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);\r\n        }\r\n        advanceBy(context, isSelfClosing ? 2 : 1);\r\n    }\r\n    let tagType = 0 /* ELEMENT */;\r\n    const options = context.options;\r\n    if (!context.inVPre && !options.isCustomElement(tag)) {\r\n        const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'is');\r\n        if (options.isNativeTag && !hasVIs) {\r\n            if (!options.isNativeTag(tag))\r\n                tagType = 1 /* COMPONENT */;\r\n        }\r\n        else if (hasVIs ||\r\n            isCoreComponent(tag) ||\r\n            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n            /^[A-Z]/.test(tag) ||\r\n            tag === 'component') {\r\n            tagType = 1 /* COMPONENT */;\r\n        }\r\n        if (tag === 'slot') {\r\n            tagType = 2 /* SLOT */;\r\n        }\r\n        else if (tag === 'template' &&\r\n            props.some(p => {\r\n                return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));\r\n            })) {\r\n            tagType = 3 /* TEMPLATE */;\r\n        }\r\n    }\r\n    return {\r\n        type: 1 /* ELEMENT */,\r\n        ns,\r\n        tag,\r\n        tagType,\r\n        props,\r\n        isSelfClosing,\r\n        children: [],\r\n        loc: getSelection(context, start),\r\n        codegenNode: undefined // to be created during transform phase\r\n    };\r\n}\r\nfunction parseAttributes(context, type) {\r\n    const props = [];\r\n    const attributeNames = new Set();\r\n    while (context.source.length > 0 &&\r\n        !startsWith(context.source, '>') &&\r\n        !startsWith(context.source, '/>')) {\r\n        if (startsWith(context.source, '/')) {\r\n            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);\r\n            advanceBy(context, 1);\r\n            advanceSpaces(context);\r\n            continue;\r\n        }\r\n        if (type === 1 /* End */) {\r\n            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);\r\n        }\r\n        const attr = parseAttribute(context, attributeNames);\r\n        if (type === 0 /* Start */) {\r\n            props.push(attr);\r\n        }\r\n        if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\r\n        }\r\n        advanceSpaces(context);\r\n    }\r\n    return props;\r\n}\r\nfunction parseAttribute(context, nameSet) {\r\n    // Name.\r\n    const start = getCursor(context);\r\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\r\n    const name = match[0];\r\n    if (nameSet.has(name)) {\r\n        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);\r\n    }\r\n    nameSet.add(name);\r\n    if (name[0] === '=') {\r\n        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\r\n    }\r\n    {\r\n        const pattern = /[\"'<]/g;\r\n        let m;\r\n        while ((m = pattern.exec(name))) {\r\n            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\r\n        }\r\n    }\r\n    advanceBy(context, name.length);\r\n    // Value\r\n    let value = undefined;\r\n    if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n        advanceSpaces(context);\r\n        advanceBy(context, 1);\r\n        advanceSpaces(context);\r\n        value = parseAttributeValue(context);\r\n        if (!value) {\r\n            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);\r\n        }\r\n    }\r\n    const loc = getSelection(context, start);\r\n    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {\r\n        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\r\n        const dirName = match[1] ||\r\n            (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');\r\n        let arg;\r\n        if (match[2]) {\r\n            const isSlot = dirName === 'slot';\r\n            const startOffset = name.lastIndexOf(match[2]);\r\n            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));\r\n            let content = match[2];\r\n            let isStatic = true;\r\n            if (content.startsWith('[')) {\r\n                isStatic = false;\r\n                if (!content.endsWith(']')) {\r\n                    emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\r\n                }\r\n                content = content.substr(1, content.length - 2);\r\n            }\r\n            else if (isSlot) {\r\n                // #1241 special case for v-slot: vuetify relies extensively on slot\r\n                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\r\n                // supports such usage so we are keeping it consistent with 2.x.\r\n                content += match[3] || '';\r\n            }\r\n            arg = {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content,\r\n                isStatic,\r\n                constType: isStatic\r\n                    ? 3 /* CAN_STRINGIFY */\r\n                    : 0 /* NOT_CONSTANT */,\r\n                loc\r\n            };\r\n        }\r\n        if (value && value.isQuoted) {\r\n            const valueLoc = value.loc;\r\n            valueLoc.start.offset++;\r\n            valueLoc.start.column++;\r\n            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\r\n            valueLoc.source = valueLoc.source.slice(1, -1);\r\n        }\r\n        return {\r\n            type: 7 /* DIRECTIVE */,\r\n            name: dirName,\r\n            exp: value && {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content: value.content,\r\n                isStatic: false,\r\n                // Treat as non-constant by default. This can be potentially set to\r\n                // other values by `transformExpression` to make it eligible for hoisting.\r\n                constType: 0 /* NOT_CONSTANT */,\r\n                loc: value.loc\r\n            },\r\n            arg,\r\n            modifiers: match[3] ? match[3].substr(1).split('.') : [],\r\n            loc\r\n        };\r\n    }\r\n    return {\r\n        type: 6 /* ATTRIBUTE */,\r\n        name,\r\n        value: value && {\r\n            type: 2 /* TEXT */,\r\n            content: value.content,\r\n            loc: value.loc\r\n        },\r\n        loc\r\n    };\r\n}\r\nfunction parseAttributeValue(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    const quote = context.source[0];\r\n    const isQuoted = quote === `\"` || quote === `'`;\r\n    if (isQuoted) {\r\n        // Quoted value.\r\n        advanceBy(context, 1);\r\n        const endIndex = context.source.indexOf(quote);\r\n        if (endIndex === -1) {\r\n            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\r\n        }\r\n        else {\r\n            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\r\n            advanceBy(context, 1);\r\n        }\r\n    }\r\n    else {\r\n        // Unquoted\r\n        const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\r\n        if (!match) {\r\n            return undefined;\r\n        }\r\n        const unexpectedChars = /[\"'<=`]/g;\r\n        let m;\r\n        while ((m = unexpectedChars.exec(match[0]))) {\r\n            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\r\n        }\r\n        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n    return { content, isQuoted, loc: getSelection(context, start) };\r\n}\r\nfunction parseInterpolation(context, mode) {\r\n    const [open, close] = context.options.delimiters;\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n    if (closeIndex === -1) {\r\n        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);\r\n        return undefined;\r\n    }\r\n    const start = getCursor(context);\r\n    advanceBy(context, open.length);\r\n    const innerStart = getCursor(context);\r\n    const innerEnd = getCursor(context);\r\n    const rawContentLength = closeIndex - open.length;\r\n    const rawContent = context.source.slice(0, rawContentLength);\r\n    const preTrimContent = parseTextData(context, rawContentLength, mode);\r\n    const content = preTrimContent.trim();\r\n    const startOffset = preTrimContent.indexOf(content);\r\n    if (startOffset > 0) {\r\n        advancePositionWithMutation(innerStart, rawContent, startOffset);\r\n    }\r\n    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\r\n    advancePositionWithMutation(innerEnd, rawContent, endOffset);\r\n    advanceBy(context, close.length);\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        content: {\r\n            type: 4 /* SIMPLE_EXPRESSION */,\r\n            isStatic: false,\r\n            // Set `isConstant` to false by default and will decide in transformExpression\r\n            constType: 0 /* NOT_CONSTANT */,\r\n            content,\r\n            loc: getSelection(context, innerStart, innerEnd)\r\n        },\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseText(context, mode) {\r\n    const endTokens = ['<', context.options.delimiters[0]];\r\n    if (mode === 3 /* CDATA */) {\r\n        endTokens.push(']]>');\r\n    }\r\n    let endIndex = context.source.length;\r\n    for (let i = 0; i < endTokens.length; i++) {\r\n        const index = context.source.indexOf(endTokens[i], 1);\r\n        if (index !== -1 && endIndex > index) {\r\n            endIndex = index;\r\n        }\r\n    }\r\n    const start = getCursor(context);\r\n    const content = parseTextData(context, endIndex, mode);\r\n    return {\r\n        type: 2 /* TEXT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(context, length, mode) {\r\n    const rawText = context.source.slice(0, length);\r\n    advanceBy(context, length);\r\n    if (mode === 2 /* RAWTEXT */ ||\r\n        mode === 3 /* CDATA */ ||\r\n        rawText.indexOf('&') === -1) {\r\n        return rawText;\r\n    }\r\n    else {\r\n        // DATA or RCDATA containing \"&\"\". Entity decoding required.\r\n        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n}\r\nfunction getCursor(context) {\r\n    const { column, line, offset } = context;\r\n    return { column, line, offset };\r\n}\r\nfunction getSelection(context, start, end) {\r\n    end = end || getCursor(context);\r\n    return {\r\n        start,\r\n        end,\r\n        source: context.originalSource.slice(start.offset, end.offset)\r\n    };\r\n}\r\nfunction last(xs) {\r\n    return xs[xs.length - 1];\r\n}\r\nfunction startsWith(source, searchString) {\r\n    return source.startsWith(searchString);\r\n}\r\nfunction advanceBy(context, numberOfCharacters) {\r\n    const { source } = context;\r\n    advancePositionWithMutation(context, source, numberOfCharacters);\r\n    context.source = source.slice(numberOfCharacters);\r\n}\r\nfunction advanceSpaces(context) {\r\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\r\n    if (match) {\r\n        advanceBy(context, match[0].length);\r\n    }\r\n}\r\nfunction getNewPosition(context, start, numberOfCharacters) {\r\n    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\r\n}\r\nfunction emitError(context, code, offset, loc = getCursor(context)) {\r\n    if (offset) {\r\n        loc.offset += offset;\r\n        loc.column += offset;\r\n    }\r\n    context.options.onError(createCompilerError(code, {\r\n        start: loc,\r\n        end: loc,\r\n        source: ''\r\n    }));\r\n}\r\nfunction isEnd(context, mode, ancestors) {\r\n    const s = context.source;\r\n    switch (mode) {\r\n        case 0 /* DATA */:\r\n            if (startsWith(s, '</')) {\r\n                // TODO: probably bad performance\r\n                for (let i = ancestors.length - 1; i >= 0; --i) {\r\n                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case 1 /* RCDATA */:\r\n        case 2 /* RAWTEXT */: {\r\n            const parent = last(ancestors);\r\n            if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n                return true;\r\n            }\r\n            break;\r\n        }\r\n        case 3 /* CDATA */:\r\n            if (startsWith(s, ']]>')) {\r\n                return true;\r\n            }\r\n            break;\r\n    }\r\n    return !s;\r\n}\r\nfunction startsWithEndTagOpen(source, tag) {\r\n    return (startsWith(source, '</') &&\r\n        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\r\n        /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>'));\r\n}\n\nfunction hoistStatic(root, context) {\r\n    walk(root, context, \r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0]));\r\n}\r\nfunction isSingleElementRoot(root, child) {\r\n    const { children } = root;\r\n    return (children.length === 1 &&\r\n        child.type === 1 /* ELEMENT */ &&\r\n        !isSlotOutlet(child));\r\n}\r\nfunction walk(node, context, doNotHoistNode = false) {\r\n    let hasHoistedNode = false;\r\n    // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces\r\n    // static bindings with expressions. These expressions are guaranteed to be\r\n    // constant so they are still eligible for hoisting, but they are only\r\n    // available at runtime and therefore cannot be evaluated ahead of time.\r\n    // This is only a concern for pre-stringification (via transformHoist by\r\n    // @vue/compiler-dom), but doing it here allows us to perform only one full\r\n    // walk of the AST and allow `stringifyStatic` to stop walking as soon as its\r\n    // stringficiation threshold is met.\r\n    let canStringify = true;\r\n    const { children } = node;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // only plain elements & text calls are eligible for hoisting.\r\n        if (child.type === 1 /* ELEMENT */ &&\r\n            child.tagType === 0 /* ELEMENT */) {\r\n            const constantType = doNotHoistNode\r\n                ? 0 /* NOT_CONSTANT */\r\n                : getConstantType(child, context);\r\n            if (constantType > 0 /* NOT_CONSTANT */) {\r\n                if (constantType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (constantType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode.patchFlag =\r\n                        -1 /* HOISTED */ + (``);\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                // node may contain dynamic children, but its props may be eligible for\r\n                // hoisting.\r\n                const codegenNode = child.codegenNode;\r\n                if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                    const flag = getPatchFlag(codegenNode);\r\n                    if ((!flag ||\r\n                        flag === 512 /* NEED_PATCH */ ||\r\n                        flag === 1 /* TEXT */) &&\r\n                        getGeneratedPropsConstantType(child, context) >=\r\n                            2 /* CAN_HOIST */) {\r\n                        const props = getNodeProps(child);\r\n                        if (props) {\r\n                            codegenNode.props = context.hoist(props);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (child.type === 12 /* TEXT_CALL */) {\r\n            const contentType = getConstantType(child.content, context);\r\n            if (contentType > 0) {\r\n                if (contentType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (contentType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                }\r\n            }\r\n        }\r\n        // walk further\r\n        if (child.type === 1 /* ELEMENT */) {\r\n            const isComponent = child.tagType === 1 /* COMPONENT */;\r\n            if (isComponent) {\r\n                context.scopes.vSlot++;\r\n            }\r\n            walk(child, context);\r\n            if (isComponent) {\r\n                context.scopes.vSlot--;\r\n            }\r\n        }\r\n        else if (child.type === 11 /* FOR */) {\r\n            // Do not hoist v-for single child because it has to be a block\r\n            walk(child, context, child.children.length === 1);\r\n        }\r\n        else if (child.type === 9 /* IF */) {\r\n            for (let i = 0; i < child.branches.length; i++) {\r\n                // Do not hoist v-if single child because it has to be a block\r\n                walk(child.branches[i], context, child.branches[i].children.length === 1);\r\n            }\r\n        }\r\n    }\r\n    if (canStringify && hasHoistedNode && context.transformHoist) {\r\n        context.transformHoist(children, context, node);\r\n    }\r\n}\r\nfunction getConstantType(node, context) {\r\n    const { constantCache } = context;\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            if (node.tagType !== 0 /* ELEMENT */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const cached = constantCache.get(node);\r\n            if (cached !== undefined) {\r\n                return cached;\r\n            }\r\n            const codegenNode = node.codegenNode;\r\n            if (codegenNode.type !== 13 /* VNODE_CALL */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const flag = getPatchFlag(codegenNode);\r\n            if (!flag) {\r\n                let returnType = 3 /* CAN_STRINGIFY */;\r\n                // Element itself has no patch flag. However we still need to check:\r\n                // 1. Even for a node with no patch flag, it is possible for it to contain\r\n                // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n                // injected keys or cached event handlers. Therefore we need to always\r\n                // check the codegenNode's props to be sure.\r\n                const generatedPropsType = getGeneratedPropsConstantType(node, context);\r\n                if (generatedPropsType === 0 /* NOT_CONSTANT */) {\r\n                    constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                if (generatedPropsType < returnType) {\r\n                    returnType = generatedPropsType;\r\n                }\r\n                // 2. its children.\r\n                for (let i = 0; i < node.children.length; i++) {\r\n                    const childType = getConstantType(node.children[i], context);\r\n                    if (childType === 0 /* NOT_CONSTANT */) {\r\n                        constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                        return 0 /* NOT_CONSTANT */;\r\n                    }\r\n                    if (childType < returnType) {\r\n                        returnType = childType;\r\n                    }\r\n                }\r\n                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n                // type, check if any of the props can cause the type to be lowered\r\n                // we can skip can_patch because it's guaranteed by the absence of a\r\n                // patchFlag.\r\n                if (returnType > 1 /* CAN_SKIP_PATCH */) {\r\n                    for (let i = 0; i < node.props.length; i++) {\r\n                        const p = node.props[i];\r\n                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {\r\n                            const expType = getConstantType(p.exp, context);\r\n                            if (expType === 0 /* NOT_CONSTANT */) {\r\n                                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                                return 0 /* NOT_CONSTANT */;\r\n                            }\r\n                            if (expType < returnType) {\r\n                                returnType = expType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // only svg/foreignObject could be block here, however if they are\r\n                // static then they don't need to be blocks since there will be no\r\n                // nested updates.\r\n                if (codegenNode.isBlock) {\r\n                    context.removeHelper(OPEN_BLOCK);\r\n                    context.removeHelper(CREATE_BLOCK);\r\n                    codegenNode.isBlock = false;\r\n                    context.helper(CREATE_VNODE);\r\n                }\r\n                constantCache.set(node, returnType);\r\n                return returnType;\r\n            }\r\n            else {\r\n                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return 3 /* CAN_STRINGIFY */;\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n        case 10 /* IF_BRANCH */:\r\n            return 0 /* NOT_CONSTANT */;\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return getConstantType(node.content, context);\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return node.constType;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            let returnType = 3 /* CAN_STRINGIFY */;\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (shared.isString(child) || shared.isSymbol(child)) {\r\n                    continue;\r\n                }\r\n                const childType = getConstantType(child, context);\r\n                if (childType === 0 /* NOT_CONSTANT */) {\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                else if (childType < returnType) {\r\n                    returnType = childType;\r\n                }\r\n            }\r\n            return returnType;\r\n        default:\r\n            return 0 /* NOT_CONSTANT */;\r\n    }\r\n}\r\nfunction getGeneratedPropsConstantType(node, context) {\r\n    let returnType = 3 /* CAN_STRINGIFY */;\r\n    const props = getNodeProps(node);\r\n    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        const { properties } = props;\r\n        for (let i = 0; i < properties.length; i++) {\r\n            const { key, value } = properties[i];\r\n            const keyType = getConstantType(key, context);\r\n            if (keyType === 0 /* NOT_CONSTANT */) {\r\n                return keyType;\r\n            }\r\n            if (keyType < returnType) {\r\n                returnType = keyType;\r\n            }\r\n            if (value.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const valueType = getConstantType(value, context);\r\n            if (valueType === 0 /* NOT_CONSTANT */) {\r\n                return valueType;\r\n            }\r\n            if (valueType < returnType) {\r\n                returnType = valueType;\r\n            }\r\n        }\r\n    }\r\n    return returnType;\r\n}\r\nfunction getNodeProps(node) {\r\n    const codegenNode = node.codegenNode;\r\n    if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n        return codegenNode.props;\r\n    }\r\n}\r\nfunction getPatchFlag(node) {\r\n    const flag = node.patchFlag;\r\n    return flag ? parseInt(flag, 10) : undefined;\r\n}\n\nfunction createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = shared.NOOP, isCustomElement = shared.NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, ssrCssVars = ``, bindingMetadata = shared.EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError }) {\r\n    const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/);\r\n    const context = {\r\n        // options\r\n        selfName: nameMatch && shared.capitalize(shared.camelize(nameMatch[1])),\r\n        prefixIdentifiers,\r\n        hoistStatic,\r\n        cacheHandlers,\r\n        nodeTransforms,\r\n        directiveTransforms,\r\n        transformHoist,\r\n        isBuiltInComponent,\r\n        isCustomElement,\r\n        expressionPlugins,\r\n        scopeId,\r\n        slotted,\r\n        ssr,\r\n        ssrCssVars,\r\n        bindingMetadata,\r\n        inline,\r\n        isTS,\r\n        onError,\r\n        // state\r\n        root,\r\n        helpers: new Map(),\r\n        components: new Set(),\r\n        directives: new Set(),\r\n        hoists: [],\r\n        imports: [],\r\n        constantCache: new Map(),\r\n        temps: 0,\r\n        cached: 0,\r\n        identifiers: Object.create(null),\r\n        scopes: {\r\n            vFor: 0,\r\n            vSlot: 0,\r\n            vPre: 0,\r\n            vOnce: 0\r\n        },\r\n        parent: null,\r\n        currentNode: root,\r\n        childIndex: 0,\r\n        // methods\r\n        helper(name) {\r\n            const count = context.helpers.get(name) || 0;\r\n            context.helpers.set(name, count + 1);\r\n            return name;\r\n        },\r\n        removeHelper(name) {\r\n            const count = context.helpers.get(name);\r\n            if (count) {\r\n                const currentCount = count - 1;\r\n                if (!currentCount) {\r\n                    context.helpers.delete(name);\r\n                }\r\n                else {\r\n                    context.helpers.set(name, currentCount);\r\n                }\r\n            }\r\n        },\r\n        helperString(name) {\r\n            return `_${helperNameMap[context.helper(name)]}`;\r\n        },\r\n        replaceNode(node) {\r\n            context.parent.children[context.childIndex] = context.currentNode = node;\r\n        },\r\n        removeNode(node) {\r\n            const list = context.parent.children;\r\n            const removalIndex = node\r\n                ? list.indexOf(node)\r\n                : context.currentNode\r\n                    ? context.childIndex\r\n                    : -1;\r\n            if (!node || node === context.currentNode) {\r\n                // current node removed\r\n                context.currentNode = null;\r\n                context.onNodeRemoved();\r\n            }\r\n            else {\r\n                // sibling node removed\r\n                if (context.childIndex > removalIndex) {\r\n                    context.childIndex--;\r\n                    context.onNodeRemoved();\r\n                }\r\n            }\r\n            context.parent.children.splice(removalIndex, 1);\r\n        },\r\n        onNodeRemoved: () => { },\r\n        addIdentifiers(exp) {\r\n            // identifier tracking only happens in non-browser builds.\r\n            {\r\n                if (shared.isString(exp)) {\r\n                    addId(exp);\r\n                }\r\n                else if (exp.identifiers) {\r\n                    exp.identifiers.forEach(addId);\r\n                }\r\n                else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n                    addId(exp.content);\r\n                }\r\n            }\r\n        },\r\n        removeIdentifiers(exp) {\r\n            {\r\n                if (shared.isString(exp)) {\r\n                    removeId(exp);\r\n                }\r\n                else if (exp.identifiers) {\r\n                    exp.identifiers.forEach(removeId);\r\n                }\r\n                else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n                    removeId(exp.content);\r\n                }\r\n            }\r\n        },\r\n        hoist(exp) {\r\n            context.hoists.push(exp);\r\n            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);\r\n            identifier.hoisted = exp;\r\n            return identifier;\r\n        },\r\n        cache(exp, isVNode = false) {\r\n            return createCacheExpression(++context.cached, exp, isVNode);\r\n        }\r\n    };\r\n    function addId(id) {\r\n        const { identifiers } = context;\r\n        if (identifiers[id] === undefined) {\r\n            identifiers[id] = 0;\r\n        }\r\n        identifiers[id]++;\r\n    }\r\n    function removeId(id) {\r\n        context.identifiers[id]--;\r\n    }\r\n    return context;\r\n}\r\nfunction transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);\r\n    if (options.hoistStatic) {\r\n        hoistStatic(root, context);\r\n    }\r\n    if (!options.ssr) {\r\n        createRootCodegen(root, context);\r\n    }\r\n    // finalize meta information\r\n    root.helpers = [...context.helpers.keys()];\r\n    root.components = [...context.components];\r\n    root.directives = [...context.directives];\r\n    root.imports = context.imports;\r\n    root.hoists = context.hoists;\r\n    root.temps = context.temps;\r\n    root.cached = context.cached;\r\n}\r\nfunction createRootCodegen(root, context) {\r\n    const { helper, removeHelper } = context;\r\n    const { children } = root;\r\n    if (children.length === 1) {\r\n        const child = children[0];\r\n        // if the single child is an element, turn it into a block.\r\n        if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n            // single element root is never hoisted so codegenNode will never be\r\n            // SimpleExpressionNode\r\n            const codegenNode = child.codegenNode;\r\n            if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                if (!codegenNode.isBlock) {\r\n                    removeHelper(CREATE_VNODE);\r\n                    codegenNode.isBlock = true;\r\n                    helper(OPEN_BLOCK);\r\n                    helper(CREATE_BLOCK);\r\n                }\r\n            }\r\n            root.codegenNode = codegenNode;\r\n        }\r\n        else {\r\n            // - single <slot/>, IfNode, ForNode: already blocks.\r\n            // - single text node: always patched.\r\n            // root codegen falls through via genNode()\r\n            root.codegenNode = child;\r\n        }\r\n    }\r\n    else if (children.length > 1) {\r\n        // root has multiple nodes - return a fragment block.\r\n        let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n        shared.PatchFlagNames[64 /* STABLE_FRAGMENT */];\r\n        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + (``), undefined, undefined, true);\r\n    }\r\n    else ;\r\n}\r\nfunction traverseChildren(parent, context) {\r\n    let i = 0;\r\n    const nodeRemoved = () => {\r\n        i--;\r\n    };\r\n    for (; i < parent.children.length; i++) {\r\n        const child = parent.children[i];\r\n        if (shared.isString(child))\r\n            continue;\r\n        context.parent = parent;\r\n        context.childIndex = i;\r\n        context.onNodeRemoved = nodeRemoved;\r\n        traverseNode(child, context);\r\n    }\r\n}\r\nfunction traverseNode(node, context) {\r\n    context.currentNode = node;\r\n    // apply transform plugins\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n        const onExit = nodeTransforms[i](node, context);\r\n        if (onExit) {\r\n            if (shared.isArray(onExit)) {\r\n                exitFns.push(...onExit);\r\n            }\r\n            else {\r\n                exitFns.push(onExit);\r\n            }\r\n        }\r\n        if (!context.currentNode) {\r\n            // node was removed\r\n            return;\r\n        }\r\n        else {\r\n            // node may have been replaced\r\n            node = context.currentNode;\r\n        }\r\n    }\r\n    switch (node.type) {\r\n        case 3 /* COMMENT */:\r\n            if (!context.ssr) {\r\n                // inject import for the Comment symbol, which is needed for creating\r\n                // comment nodes with `createVNode`\r\n                context.helper(CREATE_COMMENT);\r\n            }\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            // no need to traverse, but we need to inject toString helper\r\n            if (!context.ssr) {\r\n                context.helper(TO_DISPLAY_STRING);\r\n            }\r\n            break;\r\n        // for container types, further traverse downwards\r\n        case 9 /* IF */:\r\n            for (let i = 0; i < node.branches.length; i++) {\r\n                traverseNode(node.branches[i], context);\r\n            }\r\n            break;\r\n        case 10 /* IF_BRANCH */:\r\n        case 11 /* FOR */:\r\n        case 1 /* ELEMENT */:\r\n        case 0 /* ROOT */:\r\n            traverseChildren(node, context);\r\n            break;\r\n    }\r\n    // exit transforms\r\n    context.currentNode = node;\r\n    let i = exitFns.length;\r\n    while (i--) {\r\n        exitFns[i]();\r\n    }\r\n}\r\nfunction createStructuralDirectiveTransform(name, fn) {\r\n    const matches = shared.isString(name)\r\n        ? (n) => n === name\r\n        : (n) => name.test(n);\r\n    return (node, context) => {\r\n        if (node.type === 1 /* ELEMENT */) {\r\n            const { props } = node;\r\n            // structural directive transforms are not concerned with slots\r\n            // as they are handled separately in vSlot.ts\r\n            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\r\n                return;\r\n            }\r\n            const exitFns = [];\r\n            for (let i = 0; i < props.length; i++) {\r\n                const prop = props[i];\r\n                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\r\n                    // structural directives are removed to avoid infinite recursion\r\n                    // also we remove them *before* applying so that it can further\r\n                    // traverse itself in case it moves the node around\r\n                    props.splice(i, 1);\r\n                    i--;\r\n                    const onExit = fn(node, prop, context);\r\n                    if (onExit)\r\n                        exitFns.push(onExit);\r\n                }\r\n            }\r\n            return exitFns;\r\n        }\r\n    };\r\n}\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\r\nconst WITH_ID = `_withId`;\r\nfunction createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap: sourceMap$1 = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {\r\n    const context = {\r\n        mode,\r\n        prefixIdentifiers,\r\n        sourceMap: sourceMap$1,\r\n        filename,\r\n        scopeId,\r\n        optimizeImports,\r\n        runtimeGlobalName,\r\n        runtimeModuleName,\r\n        ssr,\r\n        source: ast.loc.source,\r\n        code: ``,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        indentLevel: 0,\r\n        pure: false,\r\n        map: undefined,\r\n        helper(key) {\r\n            return `_${helperNameMap[key]}`;\r\n        },\r\n        push(code, node) {\r\n            context.code += code;\r\n            if (context.map) {\r\n                if (node) {\r\n                    let name;\r\n                    if (node.type === 4 /* SIMPLE_EXPRESSION */ && !node.isStatic) {\r\n                        const content = node.content.replace(/^_ctx\\./, '');\r\n                        if (content !== node.content && isSimpleIdentifier(content)) {\r\n                            name = content;\r\n                        }\r\n                    }\r\n                    addMapping(node.loc.start, name);\r\n                }\r\n                advancePositionWithMutation(context, code);\r\n                if (node && node.loc !== locStub) {\r\n                    addMapping(node.loc.end);\r\n                }\r\n            }\r\n        },\r\n        indent() {\r\n            newline(++context.indentLevel);\r\n        },\r\n        deindent(withoutNewLine = false) {\r\n            if (withoutNewLine) {\r\n                --context.indentLevel;\r\n            }\r\n            else {\r\n                newline(--context.indentLevel);\r\n            }\r\n        },\r\n        newline() {\r\n            newline(context.indentLevel);\r\n        }\r\n    };\r\n    function newline(n) {\r\n        context.push('\\n' + `  `.repeat(n));\r\n    }\r\n    function addMapping(loc, name) {\r\n        context.map.addMapping({\r\n            name,\r\n            source: context.filename,\r\n            original: {\r\n                line: loc.line,\r\n                column: loc.column - 1 // source-map column is 0 based\r\n            },\r\n            generated: {\r\n                line: context.line,\r\n                column: context.column - 1\r\n            }\r\n        });\r\n    }\r\n    if (sourceMap$1) {\r\n        // lazy require source-map implementation, only in non-browser builds\r\n        context.map = new sourceMap.SourceMapGenerator();\r\n        context.map.setSourceContent(filename, context.source);\r\n    }\r\n    return context;\r\n}\r\nfunction generate(ast, options = {}) {\r\n    const context = createCodegenContext(ast, options);\r\n    if (options.onContextCreated)\r\n        options.onContextCreated(context);\r\n    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\r\n    const hasHelpers = ast.helpers.length > 0;\r\n    const useWithBlock = !prefixIdentifiers && mode !== 'module';\r\n    const genScopeId = scopeId != null && mode === 'module';\r\n    const isSetupInlined = !!options.inline;\r\n    // preambles\r\n    // in setup() inline mode, the preamble is generated in a sub context\r\n    // and returned separately.\r\n    const preambleContext = isSetupInlined\r\n        ? createCodegenContext(ast, options)\r\n        : context;\r\n    if (mode === 'module') {\r\n        genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined);\r\n    }\r\n    else {\r\n        genFunctionPreamble(ast, preambleContext);\r\n    }\r\n    // enter render function\r\n    const functionName = ssr ? `ssrRender` : `render`;\r\n    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];\r\n    if (options.bindingMetadata && !options.inline) {\r\n        // binding optimization args\r\n        args.push('$props', '$setup', '$data', '$options');\r\n    }\r\n    const signature = options.isTS\r\n        ? args.map(arg => `${arg}: any`).join(',')\r\n        : args.join(', ');\r\n    if (genScopeId && !isSetupInlined) {\r\n        // root-level _withId wrapping is no longer necessary after 3.0.8 and is\r\n        // a noop, it's only kept so that code compiled with 3.0.8+ can run with\r\n        // runtime < 3.0.8.\r\n        // TODO: consider removing in 3.1\r\n        push(`const ${functionName} = ${PURE_ANNOTATION}${WITH_ID}(`);\r\n    }\r\n    if (isSetupInlined || genScopeId) {\r\n        push(`(${signature}) => {`);\r\n    }\r\n    else {\r\n        push(`function ${functionName}(${signature}) {`);\r\n    }\r\n    indent();\r\n    if (useWithBlock) {\r\n        push(`with (_ctx) {`);\r\n        indent();\r\n        // function mode const declarations should be inside with block\r\n        // also they should be renamed to avoid collision with user properties\r\n        if (hasHelpers) {\r\n            push(`const { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\r\n                .join(', ')} } = _Vue`);\r\n            push(`\\n`);\r\n            newline();\r\n        }\r\n    }\r\n    // generate asset resolution statements\r\n    if (ast.components.length) {\r\n        genAssets(ast.components, 'component', context);\r\n        if (ast.directives.length || ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.directives.length) {\r\n        genAssets(ast.directives, 'directive', context);\r\n        if (ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.temps > 0) {\r\n        push(`let `);\r\n        for (let i = 0; i < ast.temps; i++) {\r\n            push(`${i > 0 ? `, ` : ``}_temp${i}`);\r\n        }\r\n    }\r\n    if (ast.components.length || ast.directives.length || ast.temps) {\r\n        push(`\\n`);\r\n        newline();\r\n    }\r\n    // generate the VNode tree expression\r\n    if (!ssr) {\r\n        push(`return `);\r\n    }\r\n    if (ast.codegenNode) {\r\n        genNode(ast.codegenNode, context);\r\n    }\r\n    else {\r\n        push(`null`);\r\n    }\r\n    if (useWithBlock) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    deindent();\r\n    push(`}`);\r\n    if (genScopeId && !isSetupInlined) {\r\n        push(`)`);\r\n    }\r\n    return {\r\n        ast,\r\n        code: context.code,\r\n        preamble: isSetupInlined ? preambleContext.code : ``,\r\n        // SourceMapGenerator does have toJSON() method but it's not in the types\r\n        map: context.map ? context.map.toJSON() : undefined\r\n    };\r\n}\r\nfunction genFunctionPreamble(ast, context) {\r\n    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;\r\n    const VueBinding = ssr\r\n        ? `require(${JSON.stringify(runtimeModuleName)})`\r\n        : runtimeGlobalName;\r\n    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\r\n    // Generate const declaration for helpers\r\n    // In prefix mode, we place the const declaration at top so it's done\r\n    // only once; But if we not prefixing, we place the declaration inside the\r\n    // with block so it doesn't incur the `in` check cost for every helper access.\r\n    if (ast.helpers.length > 0) {\r\n        if (prefixIdentifiers) {\r\n            push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\\n`);\r\n        }\r\n        else {\r\n            // \"with\" mode.\r\n            // save Vue in a separate variable to avoid collision\r\n            push(`const _Vue = ${VueBinding}\\n`);\r\n            // in \"with\" mode, helpers are declared inside the with block to avoid\r\n            // has check cost, but hoists are lifted out of the function - we need\r\n            // to provide the helper here.\r\n            if (ast.hoists.length) {\r\n                const staticHelpers = [\r\n                    CREATE_VNODE,\r\n                    CREATE_COMMENT,\r\n                    CREATE_TEXT,\r\n                    CREATE_STATIC\r\n                ]\r\n                    .filter(helper => ast.helpers.includes(helper))\r\n                    .map(aliasHelper)\r\n                    .join(', ');\r\n                push(`const { ${staticHelpers} } = _Vue\\n`);\r\n            }\r\n        }\r\n    }\r\n    // generate variables for ssr helpers\r\n    if (ast.ssrHelpers && ast.ssrHelpers.length) {\r\n        // ssr guarantees prefixIdentifier: true\r\n        push(`const { ${ast.ssrHelpers\r\n            .map(aliasHelper)\r\n            .join(', ')} } = require(\"@vue/server-renderer\")\\n`);\r\n    }\r\n    genHoists(ast.hoists, context);\r\n    newline();\r\n    push(`return `);\r\n}\r\nfunction genModulePreamble(ast, context, genScopeId, inline) {\r\n    const { push, newline, optimizeImports, runtimeModuleName, scopeId, helper } = context;\r\n    if (genScopeId) {\r\n        ast.helpers.push(WITH_SCOPE_ID);\r\n        if (ast.hoists.length) {\r\n            ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID);\r\n        }\r\n    }\r\n    // generate import statements for helpers\r\n    if (ast.helpers.length) {\r\n        if (optimizeImports) {\r\n            // when bundled with webpack with code-split, calling an import binding\r\n            // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,\r\n            // incurring both payload size increase and potential perf overhead.\r\n            // therefore we assign the imports to variables (which is a constant ~50b\r\n            // cost per-component instead of scaling with template size)\r\n            push(`import { ${ast.helpers\r\n                .map(s => helperNameMap[s])\r\n                .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`);\r\n            push(`\\n// Binding optimization for webpack code-split\\nconst ${ast.helpers\r\n                .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\r\n                .join(', ')}\\n`);\r\n        }\r\n        else {\r\n            push(`import { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n                .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`);\r\n        }\r\n    }\r\n    if (ast.ssrHelpers && ast.ssrHelpers.length) {\r\n        push(`import { ${ast.ssrHelpers\r\n            .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\r\n            .join(', ')} } from \"@vue/server-renderer\"\\n`);\r\n    }\r\n    if (ast.imports.length) {\r\n        genImports(ast.imports, context);\r\n        newline();\r\n    }\r\n    // we technically don't need this anymore since `withCtx` already sets the\r\n    // correct scopeId, but this is necessary for backwards compat\r\n    // TODO: consider removing in 3.1\r\n    if (genScopeId) {\r\n        push(`const ${WITH_ID} = ${PURE_ANNOTATION}${helper(WITH_SCOPE_ID)}(\"${scopeId}\")`);\r\n        newline();\r\n    }\r\n    genHoists(ast.hoists, context);\r\n    newline();\r\n    if (!inline) {\r\n        push(`export `);\r\n    }\r\n}\r\nfunction genAssets(assets, type, { helper, push, newline }) {\r\n    const resolver = helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\r\n    for (let i = 0; i < assets.length; i++) {\r\n        let id = assets[i];\r\n        // potential component implicit self-reference inferred from SFC filename\r\n        const maybeSelfReference = id.endsWith('__self');\r\n        if (maybeSelfReference) {\r\n            id = id.slice(0, -6);\r\n        }\r\n        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})`);\r\n        if (i < assets.length - 1) {\r\n            newline();\r\n        }\r\n    }\r\n}\r\nfunction genHoists(hoists, context) {\r\n    if (!hoists.length) {\r\n        return;\r\n    }\r\n    context.pure = true;\r\n    const { push, newline, helper, scopeId, mode } = context;\r\n    const genScopeId = scopeId != null && mode !== 'function';\r\n    newline();\r\n    // push scope Id before initializing hoisted vnodes so that these vnodes\r\n    // get the proper scopeId as well.\r\n    if (genScopeId) {\r\n        push(`${helper(PUSH_SCOPE_ID)}(\"${scopeId}\")`);\r\n        newline();\r\n    }\r\n    hoists.forEach((exp, i) => {\r\n        if (exp) {\r\n            push(`const _hoisted_${i + 1} = `);\r\n            genNode(exp, context);\r\n            newline();\r\n        }\r\n    });\r\n    if (genScopeId) {\r\n        push(`${helper(POP_SCOPE_ID)}()`);\r\n        newline();\r\n    }\r\n    context.pure = false;\r\n}\r\nfunction genImports(importsOptions, context) {\r\n    if (!importsOptions.length) {\r\n        return;\r\n    }\r\n    importsOptions.forEach(imports => {\r\n        context.push(`import `);\r\n        genNode(imports.exp, context);\r\n        context.push(` from '${imports.path}'`);\r\n        context.newline();\r\n    });\r\n}\r\nfunction isText$1(n) {\r\n    return (shared.isString(n) ||\r\n        n.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n        n.type === 2 /* TEXT */ ||\r\n        n.type === 5 /* INTERPOLATION */ ||\r\n        n.type === 8 /* COMPOUND_EXPRESSION */);\r\n}\r\nfunction genNodeListAsArray(nodes, context) {\r\n    const multilines = nodes.length > 3 ||\r\n        (nodes.some(n => shared.isArray(n) || !isText$1(n)));\r\n    context.push(`[`);\r\n    multilines && context.indent();\r\n    genNodeList(nodes, context, multilines);\r\n    multilines && context.deindent();\r\n    context.push(`]`);\r\n}\r\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\r\n    const { push, newline } = context;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        if (shared.isString(node)) {\r\n            push(node);\r\n        }\r\n        else if (shared.isArray(node)) {\r\n            genNodeListAsArray(node, context);\r\n        }\r\n        else {\r\n            genNode(node, context);\r\n        }\r\n        if (i < nodes.length - 1) {\r\n            if (multilines) {\r\n                comma && push(',');\r\n                newline();\r\n            }\r\n            else {\r\n                comma && push(', ');\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction genNode(node, context) {\r\n    if (shared.isString(node)) {\r\n        context.push(node);\r\n        return;\r\n    }\r\n    if (shared.isSymbol(node)) {\r\n        context.push(context.helper(node));\r\n        return;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 2 /* TEXT */:\r\n            genText(node, context);\r\n            break;\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            genExpression(node, context);\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            genInterpolation(node, context);\r\n            break;\r\n        case 12 /* TEXT_CALL */:\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            genCompoundExpression(node, context);\r\n            break;\r\n        case 3 /* COMMENT */:\r\n            break;\r\n        case 13 /* VNODE_CALL */:\r\n            genVNodeCall(node, context);\r\n            break;\r\n        case 14 /* JS_CALL_EXPRESSION */:\r\n            genCallExpression(node, context);\r\n            break;\r\n        case 15 /* JS_OBJECT_EXPRESSION */:\r\n            genObjectExpression(node, context);\r\n            break;\r\n        case 17 /* JS_ARRAY_EXPRESSION */:\r\n            genArrayExpression(node, context);\r\n            break;\r\n        case 18 /* JS_FUNCTION_EXPRESSION */:\r\n            genFunctionExpression(node, context);\r\n            break;\r\n        case 19 /* JS_CONDITIONAL_EXPRESSION */:\r\n            genConditionalExpression(node, context);\r\n            break;\r\n        case 20 /* JS_CACHE_EXPRESSION */:\r\n            genCacheExpression(node, context);\r\n            break;\r\n        // SSR only types\r\n        case 21 /* JS_BLOCK_STATEMENT */:\r\n            genNodeList(node.body, context, true, false);\r\n            break;\r\n        case 22 /* JS_TEMPLATE_LITERAL */:\r\n            genTemplateLiteral(node, context);\r\n            break;\r\n        case 23 /* JS_IF_STATEMENT */:\r\n            genIfStatement(node, context);\r\n            break;\r\n        case 24 /* JS_ASSIGNMENT_EXPRESSION */:\r\n            genAssignmentExpression(node, context);\r\n            break;\r\n        case 25 /* JS_SEQUENCE_EXPRESSION */:\r\n            genSequenceExpression(node, context);\r\n            break;\r\n        case 26 /* JS_RETURN_STATEMENT */:\r\n            genReturnStatement(node, context);\r\n            break;\r\n    }\r\n}\r\nfunction genText(node, context) {\r\n    context.push(JSON.stringify(node.content), node);\r\n}\r\nfunction genExpression(node, context) {\r\n    const { content, isStatic } = node;\r\n    context.push(isStatic ? JSON.stringify(content) : content, node);\r\n}\r\nfunction genInterpolation(node, context) {\r\n    const { push, helper, pure } = context;\r\n    if (pure)\r\n        push(PURE_ANNOTATION);\r\n    push(`${helper(TO_DISPLAY_STRING)}(`);\r\n    genNode(node.content, context);\r\n    push(`)`);\r\n}\r\nfunction genCompoundExpression(node, context) {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (shared.isString(child)) {\r\n            context.push(child);\r\n        }\r\n        else {\r\n            genNode(child, context);\r\n        }\r\n    }\r\n}\r\nfunction genExpressionAsPropertyKey(node, context) {\r\n    const { push } = context;\r\n    if (node.type === 8 /* COMPOUND_EXPRESSION */) {\r\n        push(`[`);\r\n        genCompoundExpression(node, context);\r\n        push(`]`);\r\n    }\r\n    else if (node.isStatic) {\r\n        // only quote keys if necessary\r\n        const text = isSimpleIdentifier(node.content)\r\n            ? node.content\r\n            : JSON.stringify(node.content);\r\n        push(text, node);\r\n    }\r\n    else {\r\n        push(`[${node.content}]`, node);\r\n    }\r\n}\r\nfunction genVNodeCall(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;\r\n    if (directives) {\r\n        push(helper(WITH_DIRECTIVES) + `(`);\r\n    }\r\n    if (isBlock) {\r\n        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\r\n    }\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);\r\n    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\r\n    push(`)`);\r\n    if (isBlock) {\r\n        push(`)`);\r\n    }\r\n    if (directives) {\r\n        push(`, `);\r\n        genNode(directives, context);\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genNullableArgs(args) {\r\n    let i = args.length;\r\n    while (i--) {\r\n        if (args[i] != null)\r\n            break;\r\n    }\r\n    return args.slice(0, i + 1).map(arg => arg || `null`);\r\n}\r\n// JavaScript\r\nfunction genCallExpression(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const callee = shared.isString(node.callee) ? node.callee : helper(node.callee);\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(callee + `(`, node);\r\n    genNodeList(node.arguments, context);\r\n    push(`)`);\r\n}\r\nfunction genObjectExpression(node, context) {\r\n    const { push, indent, deindent, newline } = context;\r\n    const { properties } = node;\r\n    if (!properties.length) {\r\n        push(`{}`, node);\r\n        return;\r\n    }\r\n    const multilines = properties.length > 1 ||\r\n        (properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));\r\n    push(multilines ? `{` : `{ `);\r\n    multilines && indent();\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const { key, value } = properties[i];\r\n        // key\r\n        genExpressionAsPropertyKey(key, context);\r\n        push(`: `);\r\n        // value\r\n        genNode(value, context);\r\n        if (i < properties.length - 1) {\r\n            // will only reach this if it's multilines\r\n            push(`,`);\r\n            newline();\r\n        }\r\n    }\r\n    multilines && deindent();\r\n    push(multilines ? `}` : ` }`);\r\n}\r\nfunction genArrayExpression(node, context) {\r\n    genNodeListAsArray(node.elements, context);\r\n}\r\nfunction genFunctionExpression(node, context) {\r\n    const { push, indent, deindent, scopeId, mode } = context;\r\n    const { params, returns, body, newline, isSlot } = node;\r\n    // slot functions also need to push scopeId before rendering its content\r\n    const genScopeId = isSlot && scopeId != null && mode !== 'function';\r\n    if (isSlot) {\r\n        // wrap slot functions with owner context\r\n        push(genScopeId ? `${WITH_ID}(` : `_${helperNameMap[WITH_CTX]}(`);\r\n    }\r\n    push(`(`, node);\r\n    if (shared.isArray(params)) {\r\n        genNodeList(params, context);\r\n    }\r\n    else if (params) {\r\n        genNode(params, context);\r\n    }\r\n    push(`) => `);\r\n    if (newline || body) {\r\n        push(`{`);\r\n        indent();\r\n    }\r\n    if (returns) {\r\n        if (newline) {\r\n            push(`return `);\r\n        }\r\n        if (shared.isArray(returns)) {\r\n            genNodeListAsArray(returns, context);\r\n        }\r\n        else {\r\n            genNode(returns, context);\r\n        }\r\n    }\r\n    else if (body) {\r\n        genNode(body, context);\r\n    }\r\n    if (newline || body) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    if (isSlot) {\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genConditionalExpression(node, context) {\r\n    const { test, consequent, alternate, newline: needNewline } = node;\r\n    const { push, indent, deindent, newline } = context;\r\n    if (test.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        const needsParens = !isSimpleIdentifier(test.content);\r\n        needsParens && push(`(`);\r\n        genExpression(test, context);\r\n        needsParens && push(`)`);\r\n    }\r\n    else {\r\n        push(`(`);\r\n        genNode(test, context);\r\n        push(`)`);\r\n    }\r\n    needNewline && indent();\r\n    context.indentLevel++;\r\n    needNewline || push(` `);\r\n    push(`? `);\r\n    genNode(consequent, context);\r\n    context.indentLevel--;\r\n    needNewline && newline();\r\n    needNewline || push(` `);\r\n    push(`: `);\r\n    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;\r\n    if (!isNested) {\r\n        context.indentLevel++;\r\n    }\r\n    genNode(alternate, context);\r\n    if (!isNested) {\r\n        context.indentLevel--;\r\n    }\r\n    needNewline && deindent(true /* without newline */);\r\n}\r\nfunction genCacheExpression(node, context) {\r\n    const { push, helper, indent, deindent, newline } = context;\r\n    push(`_cache[${node.index}] || (`);\r\n    if (node.isVNode) {\r\n        indent();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\r\n        newline();\r\n    }\r\n    push(`_cache[${node.index}] = `);\r\n    genNode(node.value, context);\r\n    if (node.isVNode) {\r\n        push(`,`);\r\n        newline();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(1),`);\r\n        newline();\r\n        push(`_cache[${node.index}]`);\r\n        deindent();\r\n    }\r\n    push(`)`);\r\n}\r\nfunction genTemplateLiteral(node, context) {\r\n    const { push, indent, deindent } = context;\r\n    push('`');\r\n    const l = node.elements.length;\r\n    const multilines = l > 3;\r\n    for (let i = 0; i < l; i++) {\r\n        const e = node.elements[i];\r\n        if (shared.isString(e)) {\r\n            push(e.replace(/(`|\\$|\\\\)/g, '\\\\$1'));\r\n        }\r\n        else {\r\n            push('${');\r\n            if (multilines)\r\n                indent();\r\n            genNode(e, context);\r\n            if (multilines)\r\n                deindent();\r\n            push('}');\r\n        }\r\n    }\r\n    push('`');\r\n}\r\nfunction genIfStatement(node, context) {\r\n    const { push, indent, deindent } = context;\r\n    const { test, consequent, alternate } = node;\r\n    push(`if (`);\r\n    genNode(test, context);\r\n    push(`) {`);\r\n    indent();\r\n    genNode(consequent, context);\r\n    deindent();\r\n    push(`}`);\r\n    if (alternate) {\r\n        push(` else `);\r\n        if (alternate.type === 23 /* JS_IF_STATEMENT */) {\r\n            genIfStatement(alternate, context);\r\n        }\r\n        else {\r\n            push(`{`);\r\n            indent();\r\n            genNode(alternate, context);\r\n            deindent();\r\n            push(`}`);\r\n        }\r\n    }\r\n}\r\nfunction genAssignmentExpression(node, context) {\r\n    genNode(node.left, context);\r\n    context.push(` = `);\r\n    genNode(node.right, context);\r\n}\r\nfunction genSequenceExpression(node, context) {\r\n    context.push(`(`);\r\n    genNodeList(node.expressions, context);\r\n    context.push(`)`);\r\n}\r\nfunction genReturnStatement({ returns }, context) {\r\n    context.push(`return `);\r\n    if (shared.isArray(returns)) {\r\n        genNodeListAsArray(returns, context);\r\n    }\r\n    else {\r\n        genNode(returns, context);\r\n    }\r\n}\n\nconst isLiteralWhitelisted = /*#__PURE__*/ shared.makeMap('true,false,null,this');\r\nconst transformExpression = (node, context) => {\r\n    if (node.type === 5 /* INTERPOLATION */) {\r\n        node.content = processExpression(node.content, context);\r\n    }\r\n    else if (node.type === 1 /* ELEMENT */) {\r\n        // handle directives on element\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const dir = node.props[i];\r\n            // do not process for v-on & v-for since they are special handled\r\n            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {\r\n                const exp = dir.exp;\r\n                const arg = dir.arg;\r\n                // do not process exp if this is v-on:arg - we need special handling\r\n                // for wrapping inline statements.\r\n                if (exp &&\r\n                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                    !(dir.name === 'on' && arg)) {\r\n                    dir.exp = processExpression(exp, context, \r\n                    // slot args must be processed as function params\r\n                    dir.name === 'slot');\r\n                }\r\n                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\r\n                    dir.arg = processExpression(arg, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !false check so that it can be\r\n// tree-shaken from the browser build.\r\nfunction processExpression(node, context, \r\n// some expressions like v-slot props & v-for aliases should be parsed as\r\n// function params\r\nasParams = false, \r\n// v-on handler values may contain multiple statements\r\nasRawStatements = false) {\r\n    if (!context.prefixIdentifiers || !node.content.trim()) {\r\n        return node;\r\n    }\r\n    const { inline, bindingMetadata } = context;\r\n    const rewriteIdentifier = (raw, parent, id) => {\r\n        const type = shared.hasOwn(bindingMetadata, raw) && bindingMetadata[raw];\r\n        if (inline) {\r\n            // x = y\r\n            const isAssignmentLVal = parent && parent.type === 'AssignmentExpression' && parent.left === id;\r\n            // x++\r\n            const isUpdateArg = parent && parent.type === 'UpdateExpression' && parent.argument === id;\r\n            // ({ x } = y)\r\n            const isDestructureAssignment = parent && isInDestructureAssignment(parent, parentStack);\r\n            if (type === \"setup-const\" /* SETUP_CONST */) {\r\n                return raw;\r\n            }\r\n            else if (type === \"setup-ref\" /* SETUP_REF */) {\r\n                return `${raw}.value`;\r\n            }\r\n            else if (type === \"setup-maybe-ref\" /* SETUP_MAYBE_REF */) {\r\n                // const binding that may or may not be ref\r\n                // if it's not a ref, then assignments don't make sense -\r\n                // so we ignore the non-ref assignment case and generate code\r\n                // that assumes the value to be a ref for more efficiency\r\n                return isAssignmentLVal || isUpdateArg || isDestructureAssignment\r\n                    ? `${raw}.value`\r\n                    : `${context.helperString(UNREF)}(${raw})`;\r\n            }\r\n            else if (type === \"setup-let\" /* SETUP_LET */) {\r\n                if (isAssignmentLVal) {\r\n                    // let binding.\r\n                    // this is a bit more tricky as we need to cover the case where\r\n                    // let is a local non-ref value, and we need to replicate the\r\n                    // right hand side value.\r\n                    // x = y --> isRef(x) ? x.value = y : x = y\r\n                    const rVal = parent.right;\r\n                    const rExp = rawExp.slice(rVal.start - 1, rVal.end - 1);\r\n                    const rExpString = stringifyExpression(processExpression(createSimpleExpression(rExp, false), context));\r\n                    return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\\n` : ``} ? ${raw}.value = ${rExpString} : ${raw}`;\r\n                }\r\n                else if (isUpdateArg) {\r\n                    // make id replace parent in the code range so the raw update operator\r\n                    // is removed\r\n                    id.start = parent.start;\r\n                    id.end = parent.end;\r\n                    const { prefix: isPrefix, operator } = parent;\r\n                    const prefix = isPrefix ? operator : ``;\r\n                    const postfix = isPrefix ? `` : operator;\r\n                    // let binding.\r\n                    // x++ --> isRef(a) ? a.value++ : a++\r\n                    return `${context.helperString(IS_REF)}(${raw})${context.isTS ? ` //@ts-ignore\\n` : ``} ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`;\r\n                }\r\n                else if (isDestructureAssignment) {\r\n                    // TODO\r\n                    // let binding in a destructure assignment - it's very tricky to\r\n                    // handle both possible cases here without altering the original\r\n                    // structure of the code, so we just assume it's not a ref here\r\n                    // for now\r\n                    return raw;\r\n                }\r\n                else {\r\n                    return `${context.helperString(UNREF)}(${raw})`;\r\n                }\r\n            }\r\n            else if (type === \"props\" /* PROPS */) {\r\n                // use __props which is generated by compileScript so in ts mode\r\n                // it gets correct type\r\n                return `__props.${raw}`;\r\n            }\r\n        }\r\n        else {\r\n            if (type && type.startsWith('setup')) {\r\n                // setup bindings in non-inline mode\r\n                return `$setup.${raw}`;\r\n            }\r\n            else if (type) {\r\n                return `$${type}.${raw}`;\r\n            }\r\n        }\r\n        // fallback to ctx\r\n        return `_ctx.${raw}`;\r\n    };\r\n    // fast path if expression is a simple identifier.\r\n    const rawExp = node.content;\r\n    // bail constant on parens (function invocation) and dot (member access)\r\n    const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0;\r\n    if (isSimpleIdentifier(rawExp)) {\r\n        const isScopeVarReference = context.identifiers[rawExp];\r\n        const isAllowedGlobal = shared.isGloballyWhitelisted(rawExp);\r\n        const isLiteral = isLiteralWhitelisted(rawExp);\r\n        if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {\r\n            // const bindings exposed from setup can be skipped for patching but\r\n            // cannot be hoisted to module scope\r\n            if (bindingMetadata[node.content] === \"setup-const\" /* SETUP_CONST */) {\r\n                node.constType = 1 /* CAN_SKIP_PATCH */;\r\n            }\r\n            node.content = rewriteIdentifier(rawExp);\r\n        }\r\n        else if (!isScopeVarReference) {\r\n            if (isLiteral) {\r\n                node.constType = 3 /* CAN_STRINGIFY */;\r\n            }\r\n            else {\r\n                node.constType = 2 /* CAN_HOIST */;\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n    let ast;\r\n    // exp needs to be parsed differently:\r\n    // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\r\n    //    exp, but make sure to pad with spaces for consistent ranges\r\n    // 2. Expressions: wrap with parens (for e.g. object expressions)\r\n    // 3. Function arguments (v-for, v-slot): place in a function argument position\r\n    const source = asRawStatements\r\n        ? ` ${rawExp} `\r\n        : `(${rawExp})${asParams ? `=>{}` : ``}`;\r\n    try {\r\n        ast = parser.parse(source, {\r\n            plugins: [...context.expressionPlugins, ...shared.babelParserDefaultPlugins]\r\n        }).program;\r\n    }\r\n    catch (e) {\r\n        context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, e.message));\r\n        return node;\r\n    }\r\n    const ids = [];\r\n    const knownIds = Object.create(context.identifiers);\r\n    const isDuplicate = (node) => ids.some(id => id.start === node.start);\r\n    const parentStack = [];\r\n    estreeWalker.walk(ast, {\r\n        enter(node, parent) {\r\n            parent && parentStack.push(parent);\r\n            if (node.type === 'Identifier') {\r\n                if (!isDuplicate(node)) {\r\n                    const needPrefix = shouldPrefix(node, parent, parentStack);\r\n                    if (!knownIds[node.name] && needPrefix) {\r\n                        if (isStaticProperty(parent) && parent.shorthand) {\r\n                            // property shorthand like { foo }, we need to add the key since\r\n                            // we rewrite the value\r\n                            node.prefix = `${node.name}: `;\r\n                        }\r\n                        node.name = rewriteIdentifier(node.name, parent, node);\r\n                        ids.push(node);\r\n                    }\r\n                    else if (!isStaticPropertyKey(node, parent)) {\r\n                        // The identifier is considered constant unless it's pointing to a\r\n                        // scope variable (a v-for alias, or a v-slot prop)\r\n                        if (!(needPrefix && knownIds[node.name]) && !bailConstant) {\r\n                            node.isConstant = true;\r\n                        }\r\n                        // also generate sub-expressions for other identifiers for better\r\n                        // source map support. (except for property keys which are static)\r\n                        ids.push(node);\r\n                    }\r\n                }\r\n            }\r\n            else if (isFunction(node)) {\r\n                // walk function expressions and add its arguments to known identifiers\r\n                // so that we don't prefix them\r\n                node.params.forEach(p => estreeWalker.walk(p, {\r\n                    enter(child, parent) {\r\n                        if (child.type === 'Identifier' &&\r\n                            // do not record as scope variable if is a destructured key\r\n                            !isStaticPropertyKey(child, parent) &&\r\n                            // do not record if this is a default value\r\n                            // assignment of a destructured variable\r\n                            !(parent &&\r\n                                parent.type === 'AssignmentPattern' &&\r\n                                parent.right === child)) {\r\n                            const { name } = child;\r\n                            if (node.scopeIds && node.scopeIds.has(name)) {\r\n                                return;\r\n                            }\r\n                            if (name in knownIds) {\r\n                                knownIds[name]++;\r\n                            }\r\n                            else {\r\n                                knownIds[name] = 1;\r\n                            }\r\n                            (node.scopeIds || (node.scopeIds = new Set())).add(name);\r\n                        }\r\n                    }\r\n                }));\r\n            }\r\n        },\r\n        leave(node, parent) {\r\n            parent && parentStack.pop();\r\n            if (node !== ast.body[0].expression && node.scopeIds) {\r\n                node.scopeIds.forEach((id) => {\r\n                    knownIds[id]--;\r\n                    if (knownIds[id] === 0) {\r\n                        delete knownIds[id];\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    // We break up the compound expression into an array of strings and sub\r\n    // expressions (for identifiers that have been prefixed). In codegen, if\r\n    // an ExpressionNode has the `.children` property, it will be used instead of\r\n    // `.content`.\r\n    const children = [];\r\n    ids.sort((a, b) => a.start - b.start);\r\n    ids.forEach((id, i) => {\r\n        // range is offset by -1 due to the wrapping parens when parsed\r\n        const start = id.start - 1;\r\n        const end = id.end - 1;\r\n        const last = ids[i - 1];\r\n        const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);\r\n        if (leadingText.length || id.prefix) {\r\n            children.push(leadingText + (id.prefix || ``));\r\n        }\r\n        const source = rawExp.slice(start, end);\r\n        children.push(createSimpleExpression(id.name, false, {\r\n            source,\r\n            start: advancePositionWithClone(node.loc.start, source, start),\r\n            end: advancePositionWithClone(node.loc.start, source, end)\r\n        }, id.isConstant ? 3 /* CAN_STRINGIFY */ : 0 /* NOT_CONSTANT */));\r\n        if (i === ids.length - 1 && end < rawExp.length) {\r\n            children.push(rawExp.slice(end));\r\n        }\r\n    });\r\n    let ret;\r\n    if (children.length) {\r\n        ret = createCompoundExpression(children, node.loc);\r\n    }\r\n    else {\r\n        ret = node;\r\n        ret.constType = bailConstant\r\n            ? 0 /* NOT_CONSTANT */\r\n            : 3 /* CAN_STRINGIFY */;\r\n    }\r\n    ret.identifiers = Object.keys(knownIds);\r\n    return ret;\r\n}\r\nconst isFunction = (node) => {\r\n    return /Function(?:Expression|Declaration)$|Method$/.test(node.type);\r\n};\r\nconst isStaticProperty = (node) => node &&\r\n    (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\r\n    !node.computed;\r\nconst isStaticPropertyKey = (node, parent) => isStaticProperty(parent) && parent.key === node;\r\nfunction shouldPrefix(id, parent, parentStack) {\r\n    // declaration id\r\n    if ((parent.type === 'VariableDeclarator' ||\r\n        parent.type === 'ClassDeclaration') &&\r\n        parent.id === id) {\r\n        return false;\r\n    }\r\n    if (isFunction(parent)) {\r\n        // function decalration/expression id\r\n        if (parent.id === id) {\r\n            return false;\r\n        }\r\n        // params list\r\n        if (parent.params.includes(id)) {\r\n            return false;\r\n        }\r\n    }\r\n    // property key\r\n    // this also covers object destructure pattern\r\n    if (isStaticPropertyKey(id, parent)) {\r\n        return false;\r\n    }\r\n    // non-assignment array destructure pattern\r\n    if (parent.type === 'ArrayPattern' &&\r\n        !isInDestructureAssignment(parent, parentStack)) {\r\n        return false;\r\n    }\r\n    // member expression property\r\n    if ((parent.type === 'MemberExpression' ||\r\n        parent.type === 'OptionalMemberExpression') &&\r\n        parent.property === id &&\r\n        !parent.computed) {\r\n        return false;\r\n    }\r\n    // is a special keyword but parsed as identifier\r\n    if (id.name === 'arguments') {\r\n        return false;\r\n    }\r\n    // skip whitelisted globals\r\n    if (shared.isGloballyWhitelisted(id.name)) {\r\n        return false;\r\n    }\r\n    // special case for webpack compilation\r\n    if (id.name === 'require') {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isInDestructureAssignment(parent, parentStack) {\r\n    if (parent &&\r\n        (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')) {\r\n        let i = parentStack.length;\r\n        while (i--) {\r\n            const p = parentStack[i];\r\n            if (p.type === 'AssignmentExpression') {\r\n                return true;\r\n            }\r\n            else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction stringifyExpression(exp) {\r\n    if (shared.isString(exp)) {\r\n        return exp;\r\n    }\r\n    else if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        return exp.content;\r\n    }\r\n    else {\r\n        return exp.children\r\n            .map(stringifyExpression)\r\n            .join('');\r\n    }\r\n}\n\nconst transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n        // #1587: We need to dynamically increment the key based on the current\r\n        // node's sibling nodes, since chained v-if/else branches are\r\n        // rendered at the same depth\r\n        const siblings = context.parent.children;\r\n        let i = siblings.indexOf(ifNode);\r\n        let key = 0;\r\n        while (i-- >= 0) {\r\n            const sibling = siblings[i];\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                key += sibling.branches.length;\r\n            }\r\n        }\r\n        // Exit callback. Complete the codegenNode when all children have been\r\n        // transformed.\r\n        return () => {\r\n            if (isRoot) {\r\n                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\r\n            }\r\n            else {\r\n                // attach this branch's codegen node to the v-if root.\r\n                const parentCondition = getParentCondition(ifNode.codegenNode);\r\n                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\r\n            }\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processIf(node, dir, context, processCodegen) {\r\n    if (dir.name !== 'else' &&\r\n        (!dir.exp || !dir.exp.content.trim())) {\r\n        const loc = dir.exp ? dir.exp.loc : node.loc;\r\n        context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));\r\n        dir.exp = createSimpleExpression(`true`, false, loc);\r\n    }\r\n    if (context.prefixIdentifiers && dir.exp) {\r\n        // dir.exp can only be simple expression because vIf transform is applied\r\n        // before expression transform.\r\n        dir.exp = processExpression(dir.exp, context);\r\n    }\r\n    if (dir.name === 'if') {\r\n        const branch = createIfBranch(node, dir);\r\n        const ifNode = {\r\n            type: 9 /* IF */,\r\n            loc: node.loc,\r\n            branches: [branch]\r\n        };\r\n        context.replaceNode(ifNode);\r\n        if (processCodegen) {\r\n            return processCodegen(ifNode, branch, true);\r\n        }\r\n    }\r\n    else {\r\n        // locate the adjacent v-if\r\n        const siblings = context.parent.children;\r\n        let i = siblings.indexOf(node);\r\n        while (i-- >= -1) {\r\n            const sibling = siblings[i];\r\n            if (sibling &&\r\n                sibling.type === 2 /* TEXT */ &&\r\n                !sibling.content.trim().length) {\r\n                context.removeNode(sibling);\r\n                continue;\r\n            }\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                // move the node to the if node's branches\r\n                context.removeNode();\r\n                const branch = createIfBranch(node, dir);\r\n                // check if user is forcing same key on different branches\r\n                {\r\n                    const key = branch.userKey;\r\n                    if (key) {\r\n                        sibling.branches.forEach(({ userKey }) => {\r\n                            if (isSameKey(userKey, key)) {\r\n                                context.onError(createCompilerError(28 /* X_V_IF_SAME_KEY */, branch.userKey.loc));\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                sibling.branches.push(branch);\r\n                const onExit = processCodegen && processCodegen(sibling, branch, false);\r\n                // since the branch was removed, it will not be traversed.\r\n                // make sure to traverse here.\r\n                traverseNode(branch, context);\r\n                // call on exit\r\n                if (onExit)\r\n                    onExit();\r\n                // make sure to reset currentNode after traversal to indicate this\r\n                // node has been removed.\r\n                context.currentNode = null;\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction createIfBranch(node, dir) {\r\n    return {\r\n        type: 10 /* IF_BRANCH */,\r\n        loc: node.loc,\r\n        condition: dir.name === 'else' ? undefined : dir.exp,\r\n        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')\r\n            ? node.children\r\n            : [node],\r\n        userKey: findProp(node, `key`)\r\n    };\r\n}\r\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\r\n    if (branch.condition) {\r\n        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \r\n        // make sure to pass in asBlock: true so that the comment node call\r\n        // closes the current block.\r\n        createCallExpression(context.helper(CREATE_COMMENT), [\r\n            '\"\"',\r\n            'true'\r\n        ]));\r\n    }\r\n    else {\r\n        return createChildrenCodegenNode(branch, keyIndex, context);\r\n    }\r\n}\r\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\r\n    const { helper, removeHelper } = context;\r\n    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));\r\n    const { children } = branch;\r\n    const firstChild = children[0];\r\n    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;\r\n    if (needFragmentWrapper) {\r\n        if (children.length === 1 && firstChild.type === 11 /* FOR */) {\r\n            // optimize away nested fragments when child is a ForNode\r\n            const vnodeCall = firstChild.codegenNode;\r\n            injectProp(vnodeCall, keyProperty, context);\r\n            return vnodeCall;\r\n        }\r\n        else {\r\n            let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n            shared.PatchFlagNames[64 /* STABLE_FRAGMENT */];\r\n            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (``), undefined, undefined, true, false, branch.loc);\r\n        }\r\n    }\r\n    else {\r\n        const vnodeCall = firstChild\r\n            .codegenNode;\r\n        // Change createVNode to createBlock.\r\n        if (vnodeCall.type === 13 /* VNODE_CALL */ && !vnodeCall.isBlock) {\r\n            removeHelper(CREATE_VNODE);\r\n            vnodeCall.isBlock = true;\r\n            helper(OPEN_BLOCK);\r\n            helper(CREATE_BLOCK);\r\n        }\r\n        // inject branch key\r\n        injectProp(vnodeCall, keyProperty, context);\r\n        return vnodeCall;\r\n    }\r\n}\r\nfunction isSameKey(a, b) {\r\n    if (!a || a.type !== b.type) {\r\n        return false;\r\n    }\r\n    if (a.type === 6 /* ATTRIBUTE */) {\r\n        if (a.value.content !== b.value.content) {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        // directive\r\n        const exp = a.exp;\r\n        const branchExp = b.exp;\r\n        if (exp.type !== branchExp.type) {\r\n            return false;\r\n        }\r\n        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||\r\n            (exp.isStatic !== branchExp.isStatic ||\r\n                exp.content !== branchExp.content)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getParentCondition(node) {\r\n    while (true) {\r\n        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                node = node.alternate;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        }\r\n        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {\r\n            node = node.value;\r\n        }\r\n    }\r\n}\n\nconst transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {\r\n    const { helper, removeHelper } = context;\r\n    return processFor(node, dir, context, forNode => {\r\n        // create the loop render function expression now, and add the\r\n        // iterator on exit after all children have been traversed\r\n        const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n            forNode.source\r\n        ]);\r\n        const keyProp = findProp(node, `key`);\r\n        const keyProperty = keyProp\r\n            ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */\r\n                ? createSimpleExpression(keyProp.value.content, true)\r\n                : keyProp.exp)\r\n            : null;\r\n        if (context.prefixIdentifiers && keyProperty) {\r\n            // #2085 process :key expression needs to be processed in order for it\r\n            // to behave consistently for <template v-for> and <div v-for>.\r\n            // In the case of `<template v-for>`, the node is discarded and never\r\n            // traversed so its key expression won't be processed by the normal\r\n            // transforms.\r\n            keyProperty.value = processExpression(keyProperty.value, context);\r\n        }\r\n        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n            forNode.source.constType > 0 /* NOT_CONSTANT */;\r\n        const fragmentFlag = isStableFragment\r\n            ? 64 /* STABLE_FRAGMENT */\r\n            : keyProp\r\n                ? 128 /* KEYED_FRAGMENT */\r\n                : 256 /* UNKEYED_FRAGMENT */;\r\n        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +\r\n            (``), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);\r\n        return () => {\r\n            // finish the codegen now that all children have been traversed\r\n            let childBlock;\r\n            const isTemplate = isTemplateNode(node);\r\n            const { children } = forNode;\r\n            // check <template v-for> key placement\r\n            if (isTemplate) {\r\n                node.children.some(c => {\r\n                    if (c.type === 1 /* ELEMENT */) {\r\n                        const key = findProp(c, 'key');\r\n                        if (key) {\r\n                            context.onError(createCompilerError(32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));\r\n                            return true;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;\r\n            const slotOutlet = isSlotOutlet(node)\r\n                ? node\r\n                : isTemplate &&\r\n                    node.children.length === 1 &&\r\n                    isSlotOutlet(node.children[0])\r\n                    ? node.children[0] // api-extractor somehow fails to infer this\r\n                    : null;\r\n            if (slotOutlet) {\r\n                // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n                childBlock = slotOutlet.codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n                    // we need to inject the key to the renderSlot() call.\r\n                    // the props for renderSlot is passed as the 3rd argument.\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n            }\r\n            else if (needFragmentWrapper) {\r\n                // <template v-for=\"...\"> with text or multi-elements\r\n                // should generate a fragment block for each loop\r\n                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +\r\n                    (``), undefined, undefined, true);\r\n            }\r\n            else {\r\n                // Normal element v-for. Directly use the child's codegenNode\r\n                // but mark it as a block.\r\n                childBlock = children[0]\r\n                    .codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n                if (childBlock.isBlock !== !isStableFragment) {\r\n                    if (childBlock.isBlock) {\r\n                        // switch from block to vnode\r\n                        removeHelper(OPEN_BLOCK);\r\n                        removeHelper(CREATE_BLOCK);\r\n                    }\r\n                    else {\r\n                        // switch from vnode to block\r\n                        removeHelper(CREATE_VNODE);\r\n                    }\r\n                }\r\n                childBlock.isBlock = !isStableFragment;\r\n                if (childBlock.isBlock) {\r\n                    helper(OPEN_BLOCK);\r\n                    helper(CREATE_BLOCK);\r\n                }\r\n                else {\r\n                    helper(CREATE_VNODE);\r\n                }\r\n            }\r\n            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processFor(node, dir, context, processCodegen) {\r\n    if (!dir.exp) {\r\n        context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const parseResult = parseForExpression(\r\n    // can only be simple expression because vFor transform is applied\r\n    // before expression transform.\r\n    dir.exp, context);\r\n    if (!parseResult) {\r\n        context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const { addIdentifiers, removeIdentifiers, scopes } = context;\r\n    const { source, value, key, index } = parseResult;\r\n    const forNode = {\r\n        type: 11 /* FOR */,\r\n        loc: dir.loc,\r\n        source,\r\n        valueAlias: value,\r\n        keyAlias: key,\r\n        objectIndexAlias: index,\r\n        parseResult,\r\n        children: isTemplateNode(node) ? node.children : [node]\r\n    };\r\n    context.replaceNode(forNode);\r\n    // bookkeeping\r\n    scopes.vFor++;\r\n    if (context.prefixIdentifiers) {\r\n        // scope management\r\n        // inject identifiers to context\r\n        value && addIdentifiers(value);\r\n        key && addIdentifiers(key);\r\n        index && addIdentifiers(index);\r\n    }\r\n    const onExit = processCodegen && processCodegen(forNode);\r\n    return () => {\r\n        scopes.vFor--;\r\n        if (context.prefixIdentifiers) {\r\n            value && removeIdentifiers(value);\r\n            key && removeIdentifiers(key);\r\n            index && removeIdentifiers(index);\r\n        }\r\n        if (onExit)\r\n            onExit();\r\n    };\r\n}\r\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n// This regex doesn't cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nconst stripParensRE = /^\\(|\\)$/g;\r\nfunction parseForExpression(input, context) {\r\n    const loc = input.loc;\r\n    const exp = input.content;\r\n    const inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    const [, LHS, RHS] = inMatch;\r\n    const result = {\r\n        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n        value: undefined,\r\n        key: undefined,\r\n        index: undefined\r\n    };\r\n    if (context.prefixIdentifiers) {\r\n        result.source = processExpression(result.source, context);\r\n    }\r\n    let valueContent = LHS.trim()\r\n        .replace(stripParensRE, '')\r\n        .trim();\r\n    const trimmedOffset = LHS.indexOf(valueContent);\r\n    const iteratorMatch = valueContent.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        valueContent = valueContent.replace(forIteratorRE, '').trim();\r\n        const keyContent = iteratorMatch[1].trim();\r\n        let keyOffset;\r\n        if (keyContent) {\r\n            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\r\n            result.key = createAliasExpression(loc, keyContent, keyOffset);\r\n            if (context.prefixIdentifiers) {\r\n                result.key = processExpression(result.key, context, true);\r\n            }\r\n        }\r\n        if (iteratorMatch[2]) {\r\n            const indexContent = iteratorMatch[2].trim();\r\n            if (indexContent) {\r\n                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\r\n                    ? keyOffset + keyContent.length\r\n                    : trimmedOffset + valueContent.length));\r\n                if (context.prefixIdentifiers) {\r\n                    result.index = processExpression(result.index, context, true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (valueContent) {\r\n        result.value = createAliasExpression(loc, valueContent, trimmedOffset);\r\n        if (context.prefixIdentifiers) {\r\n            result.value = processExpression(result.value, context, true);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction createAliasExpression(range, content, offset) {\r\n    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\r\n}\r\nfunction createForLoopParams({ value, key, index }) {\r\n    const params = [];\r\n    if (value) {\r\n        params.push(value);\r\n    }\r\n    if (key) {\r\n        if (!value) {\r\n            params.push(createSimpleExpression(`_`, false));\r\n        }\r\n        params.push(key);\r\n    }\r\n    if (index) {\r\n        if (!key) {\r\n            if (!value) {\r\n                params.push(createSimpleExpression(`_`, false));\r\n            }\r\n            params.push(createSimpleExpression(`__`, false));\r\n        }\r\n        params.push(index);\r\n    }\r\n    return params;\r\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nconst trackSlotScopes = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 1 /* COMPONENT */ ||\r\n            node.tagType === 3 /* TEMPLATE */)) {\r\n        // We are only checking non-empty v-slot here\r\n        // since we only care about slots that introduce scope variables.\r\n        const vSlot = findDir(node, 'slot');\r\n        if (vSlot) {\r\n            const slotProps = vSlot.exp;\r\n            if (context.prefixIdentifiers) {\r\n                slotProps && context.addIdentifiers(slotProps);\r\n            }\r\n            context.scopes.vSlot++;\r\n            return () => {\r\n                if (context.prefixIdentifiers) {\r\n                    slotProps && context.removeIdentifiers(slotProps);\r\n                }\r\n                context.scopes.vSlot--;\r\n            };\r\n        }\r\n    }\r\n};\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nconst trackVForSlotScopes = (node, context) => {\r\n    let vFor;\r\n    if (isTemplateNode(node) &&\r\n        node.props.some(isVSlot) &&\r\n        (vFor = findDir(node, 'for'))) {\r\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\r\n        if (result) {\r\n            const { value, key, index } = result;\r\n            const { addIdentifiers, removeIdentifiers } = context;\r\n            value && addIdentifiers(value);\r\n            key && addIdentifiers(key);\r\n            index && addIdentifiers(index);\r\n            return () => {\r\n                value && removeIdentifiers(value);\r\n                key && removeIdentifiers(key);\r\n                index && removeIdentifiers(index);\r\n            };\r\n        }\r\n    }\r\n};\r\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\r\n    context.helper(WITH_CTX);\r\n    const { children, loc } = node;\r\n    const slotsProperties = [];\r\n    const dynamicSlots = [];\r\n    const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));\r\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n    // since it likely uses a scope variable.\r\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n    // with `prefixIdentifiers: true`, this can be further optimized to make\r\n    // it dynamic only when the slot actually uses the scope variables.\r\n    if (!context.ssr && context.prefixIdentifiers) {\r\n        hasDynamicSlots = hasScopeRef(node, context.identifiers);\r\n    }\r\n    // 1. Check for slot with slotProps on component itself.\r\n    //    <Comp v-slot=\"{ prop }\"/>\r\n    const onComponentSlot = findDir(node, 'slot', true);\r\n    if (onComponentSlot) {\r\n        const { arg, exp } = onComponentSlot;\r\n        if (arg && !isStaticExp(arg)) {\r\n            hasDynamicSlots = true;\r\n        }\r\n        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));\r\n    }\r\n    // 2. Iterate through children and check for template slots\r\n    //    <template v-slot:foo=\"{ prop }\">\r\n    let hasTemplateSlots = false;\r\n    let hasNamedDefaultSlot = false;\r\n    const implicitDefaultChildren = [];\r\n    const seenSlotNames = new Set();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const slotElement = children[i];\r\n        let slotDir;\r\n        if (!isTemplateNode(slotElement) ||\r\n            !(slotDir = findDir(slotElement, 'slot', true))) {\r\n            // not a <template v-slot>, skip.\r\n            if (slotElement.type !== 3 /* COMMENT */) {\r\n                implicitDefaultChildren.push(slotElement);\r\n            }\r\n            continue;\r\n        }\r\n        if (onComponentSlot) {\r\n            // already has on-component slot - this is incorrect usage.\r\n            context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\r\n            break;\r\n        }\r\n        hasTemplateSlots = true;\r\n        const { children: slotChildren, loc: slotLoc } = slotElement;\r\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n        // check if name is dynamic.\r\n        let staticSlotName;\r\n        if (isStaticExp(slotName)) {\r\n            staticSlotName = slotName ? slotName.content : `default`;\r\n        }\r\n        else {\r\n            hasDynamicSlots = true;\r\n        }\r\n        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\r\n        // check if this slot is conditional (v-if/v-for)\r\n        let vIf;\r\n        let vElse;\r\n        let vFor;\r\n        if ((vIf = findDir(slotElement, 'if'))) {\r\n            hasDynamicSlots = true;\r\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n        }\r\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n            // find adjacent v-if\r\n            let j = i;\r\n            let prev;\r\n            while (j--) {\r\n                prev = children[j];\r\n                if (prev.type !== 3 /* COMMENT */) {\r\n                    break;\r\n                }\r\n            }\r\n            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n                // remove node\r\n                children.splice(i, 1);\r\n                i--;\r\n                // attach this slot to previous conditional\r\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                    conditional = conditional.alternate;\r\n                }\r\n                conditional.alternate = vElse.exp\r\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                    : buildDynamicSlot(slotName, slotFunction);\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n            }\r\n        }\r\n        else if ((vFor = findDir(slotElement, 'for'))) {\r\n            hasDynamicSlots = true;\r\n            const parseResult = vFor.parseResult ||\r\n                parseForExpression(vFor.exp, context);\r\n            if (parseResult) {\r\n                // Render the dynamic slots as an array and add it to the createSlot()\r\n                // args. The runtime knows how to handle it appropriately.\r\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                    parseResult.source,\r\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\r\n                ]));\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n            }\r\n        }\r\n        else {\r\n            // check duplicate static names\r\n            if (staticSlotName) {\r\n                if (seenSlotNames.has(staticSlotName)) {\r\n                    context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                    continue;\r\n                }\r\n                seenSlotNames.add(staticSlotName);\r\n                if (staticSlotName === 'default') {\r\n                    hasNamedDefaultSlot = true;\r\n                }\r\n            }\r\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n        }\r\n    }\r\n    if (!onComponentSlot) {\r\n        if (!hasTemplateSlots) {\r\n            // implicit default slot (on component)\r\n            slotsProperties.push(buildDefaultSlotProperty(undefined, children));\r\n        }\r\n        else if (implicitDefaultChildren.length) {\r\n            // implicit default slot (mixed with named slots)\r\n            if (hasNamedDefaultSlot) {\r\n                context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\r\n            }\r\n            else {\r\n                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\r\n            }\r\n        }\r\n    }\r\n    const slotFlag = hasDynamicSlots\r\n        ? 2 /* DYNAMIC */\r\n        : hasForwardedSlots(node.children)\r\n            ? 3 /* FORWARDED */\r\n            : 1 /* STABLE */;\r\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \r\n    // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n    // 1 = compiled and static = can skip normalization AND diff as optimized\r\n    createSimpleExpression(slotFlag + (``), false))), loc);\r\n    if (dynamicSlots.length) {\r\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n            slots,\r\n            createArrayExpression(dynamicSlots)\r\n        ]);\r\n    }\r\n    return {\r\n        slots,\r\n        hasDynamicSlots\r\n    };\r\n}\r\nfunction buildDynamicSlot(name, fn) {\r\n    return createObjectExpression([\r\n        createObjectProperty(`name`, name),\r\n        createObjectProperty(`fn`, fn)\r\n    ]);\r\n}\r\nfunction hasForwardedSlots(children) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        switch (child.type) {\r\n            case 1 /* ELEMENT */:\r\n                if (child.tagType === 2 /* SLOT */ ||\r\n                    (child.tagType === 0 /* ELEMENT */ &&\r\n                        hasForwardedSlots(child.children))) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 9 /* IF */:\r\n                if (hasForwardedSlots(child.branches))\r\n                    return true;\r\n                break;\r\n            case 10 /* IF_BRANCH */:\r\n            case 11 /* FOR */:\r\n                if (hasForwardedSlots(child.children))\r\n                    return true;\r\n                break;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap();\r\n// generate a JavaScript AST for this element's codegen\r\nconst transformElement = (node, context) => {\r\n    // perform the work on exit, after all child expressions have been\r\n    // processed and merged.\r\n    return function postTransformElement() {\r\n        node = context.currentNode;\r\n        if (!(node.type === 1 /* ELEMENT */ &&\r\n            (node.tagType === 0 /* ELEMENT */ ||\r\n                node.tagType === 1 /* COMPONENT */))) {\r\n            return;\r\n        }\r\n        const { tag, props } = node;\r\n        const isComponent = node.tagType === 1 /* COMPONENT */;\r\n        // The goal of the transform is to create a codegenNode implementing the\r\n        // VNodeCall interface.\r\n        const vnodeTag = isComponent\r\n            ? resolveComponentType(node, context)\r\n            : `\"${tag}\"`;\r\n        const isDynamicComponent = shared.isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\r\n        let vnodeProps;\r\n        let vnodeChildren;\r\n        let vnodePatchFlag;\r\n        let patchFlag = 0;\r\n        let vnodeDynamicProps;\r\n        let dynamicPropNames;\r\n        let vnodeDirectives;\r\n        let shouldUseBlock = \r\n        // dynamic component may resolve to plain elements\r\n        isDynamicComponent ||\r\n            vnodeTag === TELEPORT ||\r\n            vnodeTag === SUSPENSE ||\r\n            (!isComponent &&\r\n                // <svg> and <foreignObject> must be forced into blocks so that block\r\n                // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n                // This is technically web-specific, but splitting the logic out of core\r\n                // leads to too much unnecessary complexity.\r\n                (tag === 'svg' ||\r\n                    tag === 'foreignObject' ||\r\n                    // #938: elements with dynamic keys should be forced into blocks\r\n                    findProp(node, 'key', true)));\r\n        // props\r\n        if (props.length > 0) {\r\n            const propsBuildResult = buildProps(node, context);\r\n            vnodeProps = propsBuildResult.props;\r\n            patchFlag = propsBuildResult.patchFlag;\r\n            dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n            const directives = propsBuildResult.directives;\r\n            vnodeDirectives =\r\n                directives && directives.length\r\n                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\r\n                    : undefined;\r\n        }\r\n        // children\r\n        if (node.children.length > 0) {\r\n            if (vnodeTag === KEEP_ALIVE) {\r\n                // Although a built-in component, we compile KeepAlive with raw children\r\n                // instead of slot functions so that it can be used inside Transition\r\n                // or other Transition-wrapping HOCs.\r\n                // To ensure correct updates with block optimizations, we need to:\r\n                // 1. Force keep-alive into a block. This avoids its children being\r\n                //    collected by a parent block.\r\n                shouldUseBlock = true;\r\n                // 2. Force keep-alive to always be updated, since it uses raw children.\r\n                patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n            }\r\n            const shouldBuildAsSlots = isComponent &&\r\n                // Teleport is not a real component and has dedicated runtime handling\r\n                vnodeTag !== TELEPORT &&\r\n                // explained above.\r\n                vnodeTag !== KEEP_ALIVE;\r\n            if (shouldBuildAsSlots) {\r\n                const { slots, hasDynamicSlots } = buildSlots(node, context);\r\n                vnodeChildren = slots;\r\n                if (hasDynamicSlots) {\r\n                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n                const child = node.children[0];\r\n                const type = child.type;\r\n                // check for dynamic text children\r\n                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\r\n                    type === 8 /* COMPOUND_EXPRESSION */;\r\n                if (hasDynamicTextChild &&\r\n                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                    patchFlag |= 1 /* TEXT */;\r\n                }\r\n                // pass directly if the only child is a text node\r\n                // (plain / interpolation / expression)\r\n                if (hasDynamicTextChild || type === 2 /* TEXT */) {\r\n                    vnodeChildren = child;\r\n                }\r\n                else {\r\n                    vnodeChildren = node.children;\r\n                }\r\n            }\r\n            else {\r\n                vnodeChildren = node.children;\r\n            }\r\n        }\r\n        // patchFlag & dynamicPropNames\r\n        if (patchFlag !== 0) {\r\n            {\r\n                vnodePatchFlag = String(patchFlag);\r\n            }\r\n            if (dynamicPropNames && dynamicPropNames.length) {\r\n                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n            }\r\n        }\r\n        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);\r\n    };\r\n};\r\nfunction resolveComponentType(node, context, ssr = false) {\r\n    const { tag } = node;\r\n    // 1. dynamic component\r\n    const isProp = isComponentTag(tag)\r\n        ? findProp(node, 'is')\r\n        : findDir(node, 'is');\r\n    if (isProp) {\r\n        const exp = isProp.type === 6 /* ATTRIBUTE */\r\n            ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n            : isProp.exp;\r\n        if (exp) {\r\n            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n                exp\r\n            ]);\r\n        }\r\n    }\r\n    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\r\n    if (builtIn) {\r\n        // built-ins are simply fallthroughs / have special handling during ssr\r\n        // so we don't need to import their runtime equivalents\r\n        if (!ssr)\r\n            context.helper(builtIn);\r\n        return builtIn;\r\n    }\r\n    // 3. user component (from setup bindings)\r\n    // this is skipped in browser build since browser builds do not perform\r\n    // binding analysis.\r\n    {\r\n        const fromSetup = resolveSetupReference(tag, context);\r\n        if (fromSetup) {\r\n            return fromSetup;\r\n        }\r\n    }\r\n    // 4. Self referencing component (inferred from filename)\r\n    if (context.selfName &&\r\n        shared.capitalize(shared.camelize(tag)) === context.selfName) {\r\n        context.helper(RESOLVE_COMPONENT);\r\n        // codegen.ts has special check for __self postfix when generating\r\n        // component imports, which will pass additional `maybeSelfReference` flag\r\n        // to `resolveComponent`.\r\n        context.components.add(tag + `__self`);\r\n        return toValidAssetId(tag, `component`);\r\n    }\r\n    // 5. user component (resolve)\r\n    context.helper(RESOLVE_COMPONENT);\r\n    context.components.add(tag);\r\n    return toValidAssetId(tag, `component`);\r\n}\r\nfunction resolveSetupReference(name, context) {\r\n    const bindings = context.bindingMetadata;\r\n    if (!bindings || bindings.__isScriptSetup === false) {\r\n        return;\r\n    }\r\n    const camelName = shared.camelize(name);\r\n    const PascalName = shared.capitalize(camelName);\r\n    const checkType = (type) => {\r\n        if (bindings[name] === type) {\r\n            return name;\r\n        }\r\n        if (bindings[camelName] === type) {\r\n            return camelName;\r\n        }\r\n        if (bindings[PascalName] === type) {\r\n            return PascalName;\r\n        }\r\n    };\r\n    const fromConst = checkType(\"setup-const\" /* SETUP_CONST */);\r\n    if (fromConst) {\r\n        return context.inline\r\n            ? // in inline mode, const setup bindings (e.g. imports) can be used as-is\r\n                fromConst\r\n            : `$setup[${JSON.stringify(fromConst)}]`;\r\n    }\r\n    const fromMaybeRef = checkType(\"setup-let\" /* SETUP_LET */) ||\r\n        checkType(\"setup-ref\" /* SETUP_REF */) ||\r\n        checkType(\"setup-maybe-ref\" /* SETUP_MAYBE_REF */);\r\n    if (fromMaybeRef) {\r\n        return context.inline\r\n            ? // setup scope bindings that may be refs need to be unrefed\r\n                `${context.helperString(UNREF)}(${fromMaybeRef})`\r\n            : `$setup[${JSON.stringify(fromMaybeRef)}]`;\r\n    }\r\n}\r\nfunction buildProps(node, context, props = node.props, ssr = false) {\r\n    const { tag, loc: elementLoc } = node;\r\n    const isComponent = node.tagType === 1 /* COMPONENT */;\r\n    let properties = [];\r\n    const mergeArgs = [];\r\n    const runtimeDirectives = [];\r\n    // patchFlag analysis\r\n    let patchFlag = 0;\r\n    let hasRef = false;\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasHydrationEventBinding = false;\r\n    let hasDynamicKeys = false;\r\n    let hasVnodeHook = false;\r\n    const dynamicPropNames = [];\r\n    const analyzePatchFlag = ({ key, value }) => {\r\n        if (isStaticExp(key)) {\r\n            const name = key.content;\r\n            const isEventHandler = shared.isOn(name);\r\n            if (!isComponent &&\r\n                isEventHandler &&\r\n                // omit the flag for click handlers because hydration gives click\r\n                // dedicated fast path.\r\n                name.toLowerCase() !== 'onclick' &&\r\n                // omit v-model handlers\r\n                name !== 'onUpdate:modelValue' &&\r\n                // omit onVnodeXXX hooks\r\n                !shared.isReservedProp(name)) {\r\n                hasHydrationEventBinding = true;\r\n            }\r\n            if (isEventHandler && shared.isReservedProp(name)) {\r\n                hasVnodeHook = true;\r\n            }\r\n            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||\r\n                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n                    value.type === 8 /* COMPOUND_EXPRESSION */) &&\r\n                    getConstantType(value, context) > 0)) {\r\n                // skip if the prop is a cached handler or has constant value\r\n                return;\r\n            }\r\n            if (name === 'ref') {\r\n                hasRef = true;\r\n            }\r\n            else if (name === 'class' && !isComponent) {\r\n                hasClassBinding = true;\r\n            }\r\n            else if (name === 'style' && !isComponent) {\r\n                hasStyleBinding = true;\r\n            }\r\n            else if (name !== 'key' && !dynamicPropNames.includes(name)) {\r\n                dynamicPropNames.push(name);\r\n            }\r\n        }\r\n        else {\r\n            hasDynamicKeys = true;\r\n        }\r\n    };\r\n    for (let i = 0; i < props.length; i++) {\r\n        // static attribute\r\n        const prop = props[i];\r\n        if (prop.type === 6 /* ATTRIBUTE */) {\r\n            const { loc, name, value } = prop;\r\n            let isStatic = true;\r\n            if (name === 'ref') {\r\n                hasRef = true;\r\n                // in inline mode there is no setupState object, so we can't use string\r\n                // keys to set the ref. Instead, we need to transform it to pass the\r\n                // acrtual ref instead.\r\n                if (context.inline) {\r\n                    isStatic = false;\r\n                }\r\n            }\r\n            // skip :is on <component>\r\n            if (name === 'is' && isComponentTag(tag)) {\r\n                continue;\r\n            }\r\n            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));\r\n        }\r\n        else {\r\n            // directives\r\n            const { name, arg, exp, loc } = prop;\r\n            const isBind = name === 'bind';\r\n            const isOn = name === 'on';\r\n            // skip v-slot - it is handled by its dedicated transform.\r\n            if (name === 'slot') {\r\n                if (!isComponent) {\r\n                    context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            // skip v-once - it is handled by its dedicated transform.\r\n            if (name === 'once') {\r\n                continue;\r\n            }\r\n            // skip v-is and :is on <component>\r\n            if (name === 'is' ||\r\n                (isBind && isComponentTag(tag) && isBindKey(arg, 'is'))) {\r\n                continue;\r\n            }\r\n            // skip v-on in SSR compilation\r\n            if (isOn && ssr) {\r\n                continue;\r\n            }\r\n            // special case for v-bind and v-on with no argument\r\n            if (!arg && (isBind || isOn)) {\r\n                hasDynamicKeys = true;\r\n                if (exp) {\r\n                    if (properties.length) {\r\n                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n                        properties = [];\r\n                    }\r\n                    if (isBind) {\r\n                        mergeArgs.push(exp);\r\n                    }\r\n                    else {\r\n                        // v-on=\"obj\" -> toHandlers(obj)\r\n                        mergeArgs.push({\r\n                            type: 14 /* JS_CALL_EXPRESSION */,\r\n                            loc,\r\n                            callee: context.helper(TO_HANDLERS),\r\n                            arguments: [exp]\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    context.onError(createCompilerError(isBind\r\n                        ? 33 /* X_V_BIND_NO_EXPRESSION */\r\n                        : 34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            const directiveTransform = context.directiveTransforms[name];\r\n            if (directiveTransform) {\r\n                // has built-in directive transform.\r\n                const { props, needRuntime } = directiveTransform(prop, node, context);\r\n                !ssr && props.forEach(analyzePatchFlag);\r\n                properties.push(...props);\r\n                if (needRuntime) {\r\n                    runtimeDirectives.push(prop);\r\n                    if (shared.isSymbol(needRuntime)) {\r\n                        directiveImportMap.set(prop, needRuntime);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // no built-in transform, this is a user custom directive.\r\n                runtimeDirectives.push(prop);\r\n            }\r\n        }\r\n    }\r\n    let propsExpression = undefined;\r\n    // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n    if (mergeArgs.length) {\r\n        if (properties.length) {\r\n            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n        }\r\n        if (mergeArgs.length > 1) {\r\n            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\r\n        }\r\n        else {\r\n            // single v-bind with nothing else - no need for a mergeProps call\r\n            propsExpression = mergeArgs[0];\r\n        }\r\n    }\r\n    else if (properties.length) {\r\n        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\r\n    }\r\n    // patchFlag analysis\r\n    if (hasDynamicKeys) {\r\n        patchFlag |= 16 /* FULL_PROPS */;\r\n    }\r\n    else {\r\n        if (hasClassBinding) {\r\n            patchFlag |= 2 /* CLASS */;\r\n        }\r\n        if (hasStyleBinding) {\r\n            patchFlag |= 4 /* STYLE */;\r\n        }\r\n        if (dynamicPropNames.length) {\r\n            patchFlag |= 8 /* PROPS */;\r\n        }\r\n        if (hasHydrationEventBinding) {\r\n            patchFlag |= 32 /* HYDRATE_EVENTS */;\r\n        }\r\n    }\r\n    if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&\r\n        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\r\n        patchFlag |= 512 /* NEED_PATCH */;\r\n    }\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames\r\n    };\r\n}\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it's possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties) {\r\n    const knownProps = new Map();\r\n    const deduped = [];\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const prop = properties[i];\r\n        // dynamic keys are always allowed\r\n        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\r\n            deduped.push(prop);\r\n            continue;\r\n        }\r\n        const name = prop.key.content;\r\n        const existing = knownProps.get(name);\r\n        if (existing) {\r\n            if (name === 'style' || name === 'class' || name.startsWith('on')) {\r\n                mergeAsArray(existing, prop);\r\n            }\r\n            // unexpected duplicate, should have emitted error during parse\r\n        }\r\n        else {\r\n            knownProps.set(name, prop);\r\n            deduped.push(prop);\r\n        }\r\n    }\r\n    return deduped;\r\n}\r\nfunction mergeAsArray(existing, incoming) {\r\n    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {\r\n        existing.value.elements.push(incoming.value);\r\n    }\r\n    else {\r\n        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\r\n    }\r\n}\r\nfunction buildDirectiveArgs(dir, context) {\r\n    const dirArgs = [];\r\n    const runtime = directiveImportMap.get(dir);\r\n    if (runtime) {\r\n        // built-in directive with runtime\r\n        dirArgs.push(context.helperString(runtime));\r\n    }\r\n    else {\r\n        // user directive.\r\n        // see if we have directives exposed via <script setup>\r\n        const fromSetup = resolveSetupReference(dir.name, context);\r\n        if (fromSetup) {\r\n            dirArgs.push(fromSetup);\r\n        }\r\n        else {\r\n            // inject statement for resolving directive\r\n            context.helper(RESOLVE_DIRECTIVE);\r\n            context.directives.add(dir.name);\r\n            dirArgs.push(toValidAssetId(dir.name, `directive`));\r\n        }\r\n    }\r\n    const { loc } = dir;\r\n    if (dir.exp)\r\n        dirArgs.push(dir.exp);\r\n    if (dir.arg) {\r\n        if (!dir.exp) {\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        dirArgs.push(dir.arg);\r\n    }\r\n    if (Object.keys(dir.modifiers).length) {\r\n        if (!dir.arg) {\r\n            if (!dir.exp) {\r\n                dirArgs.push(`void 0`);\r\n            }\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        const trueExpression = createSimpleExpression(`true`, false, loc);\r\n        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\r\n    }\r\n    return createArrayExpression(dirArgs, dir.loc);\r\n}\r\nfunction stringifyDynamicPropNames(props) {\r\n    let propsNamesString = `[`;\r\n    for (let i = 0, l = props.length; i < l; i++) {\r\n        propsNamesString += JSON.stringify(props[i]);\r\n        if (i < l - 1)\r\n            propsNamesString += ', ';\r\n    }\r\n    return propsNamesString + `]`;\r\n}\r\nfunction isComponentTag(tag) {\r\n    return tag[0].toLowerCase() + tag.slice(1) === 'component';\r\n}\n\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\n\nconst transformSlotOutlet = (node, context) => {\r\n    if (isSlotOutlet(node)) {\r\n        const { children, loc } = node;\r\n        const { slotName, slotProps } = processSlotOutlet(node, context);\r\n        const slotArgs = [\r\n            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n            slotName\r\n        ];\r\n        if (slotProps) {\r\n            slotArgs.push(slotProps);\r\n        }\r\n        if (children.length) {\r\n            if (!slotProps) {\r\n                slotArgs.push(`{}`);\r\n            }\r\n            slotArgs.push(createFunctionExpression([], children, false, false, loc));\r\n        }\r\n        if (context.scopeId && !context.slotted) {\r\n            if (!slotProps) {\r\n                slotArgs.push(`{}`);\r\n            }\r\n            if (!children.length) {\r\n                slotArgs.push(`undefined`);\r\n            }\r\n            slotArgs.push(`true`);\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\r\n    }\r\n};\r\nfunction processSlotOutlet(node, context) {\r\n    let slotName = `\"default\"`;\r\n    let slotProps = undefined;\r\n    const nonNameProps = [];\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (p.value) {\r\n                if (p.name === 'name') {\r\n                    slotName = JSON.stringify(p.value.content);\r\n                }\r\n                else {\r\n                    p.name = camelize(p.name);\r\n                    nonNameProps.push(p);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (p.name === 'bind' && isBindKey(p.arg, 'name')) {\r\n                if (p.exp)\r\n                    slotName = p.exp;\r\n            }\r\n            else {\r\n                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\r\n                    p.arg.content = camelize(p.arg.content);\r\n                }\r\n                nonNameProps.push(p);\r\n            }\r\n        }\r\n    }\r\n    if (nonNameProps.length > 0) {\r\n        const { props, directives } = buildProps(node, context, nonNameProps);\r\n        slotProps = props;\r\n        if (directives.length) {\r\n            context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\r\n        }\r\n    }\r\n    return {\r\n        slotName,\r\n        slotProps\r\n    };\r\n}\n\nconst fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^\\s*function(?:\\s+[\\w$]+)?\\s*\\(/;\r\nconst transformOn = (dir, node, context, augmentor) => {\r\n    const { loc, modifiers, arg } = dir;\r\n    if (!dir.exp && !modifiers.length) {\r\n        context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n    }\r\n    let eventName;\r\n    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        if (arg.isStatic) {\r\n            const rawName = arg.content;\r\n            // for all event listeners, auto convert it to camelCase. See issue #2249\r\n            eventName = createSimpleExpression(shared.toHandlerKey(shared.camelize(rawName)), true, arg.loc);\r\n        }\r\n        else {\r\n            // #2388\r\n            eventName = createCompoundExpression([\r\n                `${context.helperString(TO_HANDLER_KEY)}(`,\r\n                arg,\r\n                `)`\r\n            ]);\r\n        }\r\n    }\r\n    else {\r\n        // already a compound expression.\r\n        eventName = arg;\r\n        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\r\n        eventName.children.push(`)`);\r\n    }\r\n    // handler processing\r\n    let exp = dir.exp;\r\n    if (exp && !exp.content.trim()) {\r\n        exp = undefined;\r\n    }\r\n    let shouldCache = context.cacheHandlers && !exp;\r\n    if (exp) {\r\n        const isMemberExp = isMemberExpression(exp.content);\r\n        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\r\n        const hasMultipleStatements = exp.content.includes(`;`);\r\n        // process the expression since it's been skipped\r\n        if (context.prefixIdentifiers) {\r\n            isInlineStatement && context.addIdentifiers(`$event`);\r\n            exp = dir.exp = processExpression(exp, context, false, hasMultipleStatements);\r\n            isInlineStatement && context.removeIdentifiers(`$event`);\r\n            // with scope analysis, the function is hoistable if it has no reference\r\n            // to scope variables.\r\n            shouldCache =\r\n                context.cacheHandlers &&\r\n                    // runtime constants don't need to be cached\r\n                    // (this is analyzed by compileScript in SFC <script setup>)\r\n                    !(exp.type === 4 /* SIMPLE_EXPRESSION */ && exp.constType > 0) &&\r\n                    // #1541 bail if this is a member exp handler passed to a component -\r\n                    // we need to use the original function to preserve arity,\r\n                    // e.g. <transition> relies on checking cb.length to determine\r\n                    // transition end handling. Inline function is ok since its arity\r\n                    // is preserved even when cached.\r\n                    !(isMemberExp && node.tagType === 1 /* COMPONENT */) &&\r\n                    // bail if the function references closure variables (v-for, v-slot)\r\n                    // it must be passed fresh to avoid stale values.\r\n                    !hasScopeRef(exp, context.identifiers);\r\n            // If the expression is optimizable and is a member expression pointing\r\n            // to a function, turn it into invocation (and wrap in an arrow function\r\n            // below) so that it always accesses the latest value when called - thus\r\n            // avoiding the need to be patched.\r\n            if (shouldCache && isMemberExp) {\r\n                if (exp.type === 4 /* SIMPLE_EXPRESSION */) {\r\n                    exp.content = `${exp.content} && ${exp.content}(...args)`;\r\n                }\r\n                else {\r\n                    exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`];\r\n                }\r\n            }\r\n        }\r\n        if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n            // wrap inline statement in a function expression\r\n            exp = createCompoundExpression([\r\n                `${isInlineStatement\r\n                    ? context.isTS\r\n                        ? `($event: any)`\r\n                        : `$event`\r\n                    : `${context.isTS ? `\\n//@ts-ignore\\n` : ``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\r\n                exp,\r\n                hasMultipleStatements ? `}` : `)`\r\n            ]);\r\n        }\r\n    }\r\n    let ret = {\r\n        props: [\r\n            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\r\n        ]\r\n    };\r\n    // apply extended compiler augmentor\r\n    if (augmentor) {\r\n        ret = augmentor(ret);\r\n    }\r\n    if (shouldCache) {\r\n        // cache handlers so that it's always the same handler being passed down.\r\n        // this avoids unnecessary re-renders when users use inline handlers on\r\n        // components.\r\n        ret.props[0].value = context.cache(ret.props[0].value);\r\n    }\r\n    return ret;\r\n};\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nconst transformBind = (dir, node, context) => {\r\n    const { exp, modifiers, loc } = dir;\r\n    const arg = dir.arg;\r\n    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n        arg.children.unshift(`(`);\r\n        arg.children.push(`) || \"\"`);\r\n    }\r\n    else if (!arg.isStatic) {\r\n        arg.content = `${arg.content} || \"\"`;\r\n    }\r\n    // .prop is no longer necessary due to new patch behavior\r\n    // .sync is replaced by v-model:arg\r\n    if (modifiers.includes('camel')) {\r\n        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            if (arg.isStatic) {\r\n                arg.content = shared.camelize(arg.content);\r\n            }\r\n            else {\r\n                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\r\n            }\r\n        }\r\n        else {\r\n            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\r\n            arg.children.push(`)`);\r\n        }\r\n    }\r\n    if (!exp ||\r\n        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {\r\n        context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));\r\n        return {\r\n            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\r\n        };\r\n    }\r\n    return {\r\n        props: [createObjectProperty(arg, exp)]\r\n    };\r\n};\n\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nconst transformText = (node, context) => {\r\n    if (node.type === 0 /* ROOT */ ||\r\n        node.type === 1 /* ELEMENT */ ||\r\n        node.type === 11 /* FOR */ ||\r\n        node.type === 10 /* IF_BRANCH */) {\r\n        // perform the transform on node exit so that all expressions have already\r\n        // been processed.\r\n        return () => {\r\n            const children = node.children;\r\n            let currentContainer = undefined;\r\n            let hasText = false;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child)) {\r\n                    hasText = true;\r\n                    for (let j = i + 1; j < children.length; j++) {\r\n                        const next = children[j];\r\n                        if (isText(next)) {\r\n                            if (!currentContainer) {\r\n                                currentContainer = children[i] = {\r\n                                    type: 8 /* COMPOUND_EXPRESSION */,\r\n                                    loc: child.loc,\r\n                                    children: [child]\r\n                                };\r\n                            }\r\n                            // merge adjacent text node into current\r\n                            currentContainer.children.push(` + `, next);\r\n                            children.splice(j, 1);\r\n                            j--;\r\n                        }\r\n                        else {\r\n                            currentContainer = undefined;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!hasText ||\r\n                // if this is a plain element with a single text child, leave it\r\n                // as-is since the runtime has dedicated fast path for this by directly\r\n                // setting textContent of the element.\r\n                // for component root it's always normalized anyway.\r\n                (children.length === 1 &&\r\n                    (node.type === 0 /* ROOT */ ||\r\n                        (node.type === 1 /* ELEMENT */ &&\r\n                            node.tagType === 0 /* ELEMENT */)))) {\r\n                return;\r\n            }\r\n            // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n            // runtime normalization.\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {\r\n                    const callArgs = [];\r\n                    // createTextVNode defaults to single whitespace, so if it is a\r\n                    // single space the code could be an empty call to save bytes.\r\n                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {\r\n                        callArgs.push(child);\r\n                    }\r\n                    // mark dynamic text with flag so it gets patched inside a block\r\n                    if (!context.ssr &&\r\n                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                        callArgs.push(1 /* TEXT */ +\r\n                            (``));\r\n                    }\r\n                    children[i] = {\r\n                        type: 12 /* TEXT_CALL */,\r\n                        content: child,\r\n                        loc: child.loc,\r\n                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\r\n                    };\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\n\nconst seen = new WeakSet();\r\nconst transformOnce = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {\r\n        if (seen.has(node)) {\r\n            return;\r\n        }\r\n        seen.add(node);\r\n        context.helper(SET_BLOCK_TRACKING);\r\n        return () => {\r\n            const cur = context.currentNode;\r\n            if (cur.codegenNode) {\r\n                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\r\n            }\r\n        };\r\n    }\r\n};\n\nconst transformModel = (dir, node, context) => {\r\n    const { exp, arg } = dir;\r\n    if (!exp) {\r\n        context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));\r\n        return createTransformProps();\r\n    }\r\n    const rawExp = exp.loc.source;\r\n    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;\r\n    // im SFC <script setup> inline mode, the exp may have been transformed into\r\n    // _unref(exp)\r\n    const bindingType = context.bindingMetadata[rawExp];\r\n    const maybeRef = context.inline &&\r\n        bindingType &&\r\n        bindingType !== \"setup-const\" /* SETUP_CONST */;\r\n    if (!isMemberExpression(expString) && !maybeRef) {\r\n        context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\r\n        return createTransformProps();\r\n    }\r\n    if (context.prefixIdentifiers &&\r\n        isSimpleIdentifier(expString) &&\r\n        context.identifiers[expString]) {\r\n        context.onError(createCompilerError(42 /* X_V_MODEL_ON_SCOPE_VARIABLE */, exp.loc));\r\n        return createTransformProps();\r\n    }\r\n    const propName = arg ? arg : createSimpleExpression('modelValue', true);\r\n    const eventName = arg\r\n        ? isStaticExp(arg)\r\n            ? `onUpdate:${arg.content}`\r\n            : createCompoundExpression(['\"onUpdate:\" + ', arg])\r\n        : `onUpdate:modelValue`;\r\n    let assignmentExp;\r\n    const eventArg = context.isTS ? `($event: any)` : `$event`;\r\n    if (maybeRef) {\r\n        if (bindingType === \"setup-ref\" /* SETUP_REF */) {\r\n            // v-model used on known ref.\r\n            assignmentExp = createCompoundExpression([\r\n                `${eventArg} => (`,\r\n                createSimpleExpression(rawExp, false, exp.loc),\r\n                `.value = $event)`\r\n            ]);\r\n        }\r\n        else {\r\n            // v-model used on a potentially ref binding in <script setup> inline mode.\r\n            // the assignment needs to check whether the binding is actually a ref.\r\n            const altAssignment = bindingType === \"setup-let\" /* SETUP_LET */ ? `${rawExp} = $event` : `null`;\r\n            assignmentExp = createCompoundExpression([\r\n                `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? `,\r\n                createSimpleExpression(rawExp, false, exp.loc),\r\n                `.value = $event : ${altAssignment})`\r\n            ]);\r\n        }\r\n    }\r\n    else {\r\n        assignmentExp = createCompoundExpression([\r\n            `${eventArg} => (`,\r\n            exp,\r\n            ` = $event)`\r\n        ]);\r\n    }\r\n    const props = [\r\n        // modelValue: foo\r\n        createObjectProperty(propName, dir.exp),\r\n        // \"onUpdate:modelValue\": $event => (foo = $event)\r\n        createObjectProperty(eventName, assignmentExp)\r\n    ];\r\n    // cache v-model handler if applicable (when it doesn't refer any scope vars)\r\n    if (context.prefixIdentifiers &&\r\n        context.cacheHandlers &&\r\n        !hasScopeRef(exp, context.identifiers)) {\r\n        props[1].value = context.cache(props[1].value);\r\n    }\r\n    // modelModifiers: { foo: true, \"bar-baz\": true }\r\n    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {\r\n        const modifiers = dir.modifiers\r\n            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n            .join(`, `);\r\n        const modifiersKey = arg\r\n            ? isStaticExp(arg)\r\n                ? `${arg.content}Modifiers`\r\n                : createCompoundExpression([arg, ' + \"Modifiers\"'])\r\n            : `modelModifiers`;\r\n        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));\r\n    }\r\n    return createTransformProps(props);\r\n};\r\nfunction createTransformProps(props = []) {\r\n    return { props };\r\n}\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\r\n    return [\r\n        [\r\n            transformOnce,\r\n            transformIf,\r\n            transformFor,\r\n            ...(prefixIdentifiers\r\n                ? [\r\n                    // order is important\r\n                    trackVForSlotScopes,\r\n                    transformExpression\r\n                ]\r\n                : []),\r\n            transformSlotOutlet,\r\n            transformElement,\r\n            trackSlotScopes,\r\n            transformText\r\n        ],\r\n        {\r\n            on: transformOn,\r\n            bind: transformBind,\r\n            model: transformModel\r\n        }\r\n    ];\r\n}\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nfunction baseCompile(template, options = {}) {\r\n    const onError = options.onError || defaultOnError;\r\n    const isModuleMode = options.mode === 'module';\r\n    const prefixIdentifiers = (options.prefixIdentifiers === true || isModuleMode);\r\n    if (!prefixIdentifiers && options.cacheHandlers) {\r\n        onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));\r\n    }\r\n    if (options.scopeId && !isModuleMode) {\r\n        onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));\r\n    }\r\n    const ast = shared.isString(template) ? baseParse(template, options) : template;\r\n    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset(prefixIdentifiers);\r\n    transform(ast, shared.extend({}, options, {\r\n        prefixIdentifiers,\r\n        nodeTransforms: [\r\n            ...nodeTransforms,\r\n            ...(options.nodeTransforms || []) // user transforms\r\n        ],\r\n        directiveTransforms: shared.extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms\r\n        )\r\n    }));\r\n    return generate(ast, shared.extend({}, options, {\r\n        prefixIdentifiers\r\n    }));\r\n}\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\nexports.generateCodeFrame = shared.generateCodeFrame;\nexports.BASE_TRANSITION = BASE_TRANSITION;\nexports.CAMELIZE = CAMELIZE;\nexports.CAPITALIZE = CAPITALIZE;\nexports.CREATE_BLOCK = CREATE_BLOCK;\nexports.CREATE_COMMENT = CREATE_COMMENT;\nexports.CREATE_SLOTS = CREATE_SLOTS;\nexports.CREATE_STATIC = CREATE_STATIC;\nexports.CREATE_TEXT = CREATE_TEXT;\nexports.CREATE_VNODE = CREATE_VNODE;\nexports.FRAGMENT = FRAGMENT;\nexports.IS_REF = IS_REF;\nexports.KEEP_ALIVE = KEEP_ALIVE;\nexports.MERGE_PROPS = MERGE_PROPS;\nexports.OPEN_BLOCK = OPEN_BLOCK;\nexports.POP_SCOPE_ID = POP_SCOPE_ID;\nexports.PUSH_SCOPE_ID = PUSH_SCOPE_ID;\nexports.RENDER_LIST = RENDER_LIST;\nexports.RENDER_SLOT = RENDER_SLOT;\nexports.RESOLVE_COMPONENT = RESOLVE_COMPONENT;\nexports.RESOLVE_DIRECTIVE = RESOLVE_DIRECTIVE;\nexports.RESOLVE_DYNAMIC_COMPONENT = RESOLVE_DYNAMIC_COMPONENT;\nexports.SET_BLOCK_TRACKING = SET_BLOCK_TRACKING;\nexports.SUSPENSE = SUSPENSE;\nexports.TELEPORT = TELEPORT;\nexports.TO_DISPLAY_STRING = TO_DISPLAY_STRING;\nexports.TO_HANDLERS = TO_HANDLERS;\nexports.TO_HANDLER_KEY = TO_HANDLER_KEY;\nexports.UNREF = UNREF;\nexports.WITH_CTX = WITH_CTX;\nexports.WITH_DIRECTIVES = WITH_DIRECTIVES;\nexports.WITH_SCOPE_ID = WITH_SCOPE_ID;\nexports.advancePositionWithClone = advancePositionWithClone;\nexports.advancePositionWithMutation = advancePositionWithMutation;\nexports.assert = assert;\nexports.baseCompile = baseCompile;\nexports.baseParse = baseParse;\nexports.buildProps = buildProps;\nexports.buildSlots = buildSlots;\nexports.createArrayExpression = createArrayExpression;\nexports.createAssignmentExpression = createAssignmentExpression;\nexports.createBlockStatement = createBlockStatement;\nexports.createCacheExpression = createCacheExpression;\nexports.createCallExpression = createCallExpression;\nexports.createCompilerError = createCompilerError;\nexports.createCompoundExpression = createCompoundExpression;\nexports.createConditionalExpression = createConditionalExpression;\nexports.createForLoopParams = createForLoopParams;\nexports.createFunctionExpression = createFunctionExpression;\nexports.createIfStatement = createIfStatement;\nexports.createInterpolation = createInterpolation;\nexports.createObjectExpression = createObjectExpression;\nexports.createObjectProperty = createObjectProperty;\nexports.createReturnStatement = createReturnStatement;\nexports.createRoot = createRoot;\nexports.createSequenceExpression = createSequenceExpression;\nexports.createSimpleExpression = createSimpleExpression;\nexports.createStructuralDirectiveTransform = createStructuralDirectiveTransform;\nexports.createTemplateLiteral = createTemplateLiteral;\nexports.createTransformContext = createTransformContext;\nexports.createVNodeCall = createVNodeCall;\nexports.findDir = findDir;\nexports.findProp = findProp;\nexports.generate = generate;\nexports.getBaseTransformPreset = getBaseTransformPreset;\nexports.getInnerRange = getInnerRange;\nexports.hasDynamicKeyVBind = hasDynamicKeyVBind;\nexports.hasScopeRef = hasScopeRef;\nexports.helperNameMap = helperNameMap;\nexports.injectProp = injectProp;\nexports.isBindKey = isBindKey;\nexports.isBuiltInType = isBuiltInType;\nexports.isCoreComponent = isCoreComponent;\nexports.isMemberExpression = isMemberExpression;\nexports.isSimpleIdentifier = isSimpleIdentifier;\nexports.isSlotOutlet = isSlotOutlet;\nexports.isStaticExp = isStaticExp;\nexports.isTemplateNode = isTemplateNode;\nexports.isText = isText;\nexports.isVSlot = isVSlot;\nexports.locStub = locStub;\nexports.noopDirectiveTransform = noopDirectiveTransform;\nexports.processExpression = processExpression;\nexports.processFor = processFor;\nexports.processIf = processIf;\nexports.processSlotOutlet = processSlotOutlet;\nexports.registerRuntimeHelpers = registerRuntimeHelpers;\nexports.resolveComponentType = resolveComponentType;\nexports.toValidAssetId = toValidAssetId;\nexports.trackSlotScopes = trackSlotScopes;\nexports.trackVForSlotScopes = trackVForSlotScopes;\nexports.transform = transform;\nexports.transformBind = transformBind;\nexports.transformElement = transformElement;\nexports.transformExpression = transformExpression;\nexports.transformModel = transformModel;\nexports.transformOn = transformOn;\nexports.traverseNode = traverseNode;\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/shared.cjs.prod.js')\n} else {\n  module.exports = require('./dist/shared.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            const normalized = normalizeClass(value[i]);\r\n            if (normalized) {\r\n                res += normalized + ' ';\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = {};\r\nconst EMPTY_ARR = [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nexports.EMPTY_ARR = EMPTY_ARR;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO = NO;\nexports.NOOP = NOOP;\nexports.PatchFlagNames = PatchFlagNames;\nexports.babelParserDefaultPlugins = babelParserDefaultPlugins;\nexports.camelize = camelize;\nexports.capitalize = capitalize;\nexports.def = def;\nexports.escapeHtml = escapeHtml;\nexports.escapeHtmlComment = escapeHtmlComment;\nexports.extend = extend;\nexports.generateCodeFrame = generateCodeFrame;\nexports.getGlobalThis = getGlobalThis;\nexports.hasChanged = hasChanged;\nexports.hasOwn = hasOwn;\nexports.hyphenate = hyphenate;\nexports.invokeArrayFns = invokeArrayFns;\nexports.isArray = isArray;\nexports.isBooleanAttr = isBooleanAttr;\nexports.isDate = isDate;\nexports.isFunction = isFunction;\nexports.isGloballyWhitelisted = isGloballyWhitelisted;\nexports.isHTMLTag = isHTMLTag;\nexports.isIntegerKey = isIntegerKey;\nexports.isKnownAttr = isKnownAttr;\nexports.isMap = isMap;\nexports.isModelListener = isModelListener;\nexports.isNoUnitNumericStyleProp = isNoUnitNumericStyleProp;\nexports.isObject = isObject;\nexports.isOn = isOn;\nexports.isPlainObject = isPlainObject;\nexports.isPromise = isPromise;\nexports.isReservedProp = isReservedProp;\nexports.isSSRSafeAttrName = isSSRSafeAttrName;\nexports.isSVGTag = isSVGTag;\nexports.isSet = isSet;\nexports.isSpecialBooleanAttr = isSpecialBooleanAttr;\nexports.isString = isString;\nexports.isSymbol = isSymbol;\nexports.isVoidTag = isVoidTag;\nexports.looseEqual = looseEqual;\nexports.looseIndexOf = looseIndexOf;\nexports.makeMap = makeMap;\nexports.normalizeClass = normalizeClass;\nexports.normalizeStyle = normalizeStyle;\nexports.objectToString = objectToString;\nexports.parseStringStyle = parseStringStyle;\nexports.propsToAttrMap = propsToAttrMap;\nexports.remove = remove;\nexports.slotFlagsText = slotFlagsText;\nexports.stringifyStyle = stringifyStyle;\nexports.toDisplayString = toDisplayString;\nexports.toHandlerKey = toHandlerKey;\nexports.toNumber = toNumber;\nexports.toRawType = toRawType;\nexports.toTypeString = toTypeString;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","// @flow\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n\n// The `startsExpr` property is used to determine whether an expression\n// may be the argument subexpression of a `yield` expression or\n// `yield` statement. It is set on all token types that may be at the\n// start of a subexpression.\n\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\n\ntype TokenOptions = {\n  keyword?: string,\n  beforeExpr?: boolean,\n  startsExpr?: boolean,\n  rightAssociative?: boolean,\n  isLoop?: boolean,\n  isAssign?: boolean,\n  prefix?: boolean,\n  postfix?: boolean,\n  binop?: ?number,\n};\n\nexport class TokenType {\n  label: string;\n  keyword: ?string;\n  beforeExpr: boolean;\n  startsExpr: boolean;\n  rightAssociative: boolean;\n  isLoop: boolean;\n  isAssign: boolean;\n  prefix: boolean;\n  postfix: boolean;\n  binop: ?number;\n  updateContext: ?(prevType: TokenType) => void;\n\n  constructor(label: string, conf: TokenOptions = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n}\n\nexport const keywords = new Map<string, TokenType>();\n\nfunction createKeyword(name: string, options: TokenOptions = {}): TokenType {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name: string, binop: number) {\n  return new TokenType(name, { beforeExpr, binop });\n}\n\nexport const types: { [name: string]: TokenType } = {\n  num: new TokenType(\"num\", { startsExpr }),\n  bigint: new TokenType(\"bigint\", { startsExpr }),\n  decimal: new TokenType(\"decimal\", { startsExpr }),\n  regexp: new TokenType(\"regexp\", { startsExpr }),\n  string: new TokenType(\"string\", { startsExpr }),\n  name: new TokenType(\"name\", { startsExpr }),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", { beforeExpr, startsExpr }),\n  bracketHashL: new TokenType(\"#[\", { beforeExpr, startsExpr }),\n  bracketBarL: new TokenType(\"[|\", { beforeExpr, startsExpr }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", { beforeExpr, startsExpr }),\n  braceBarL: new TokenType(\"{|\", { beforeExpr, startsExpr }),\n  braceHashL: new TokenType(\"#{\", { beforeExpr, startsExpr }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", { beforeExpr, startsExpr }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", { beforeExpr }),\n  semi: new TokenType(\";\", { beforeExpr }),\n  colon: new TokenType(\":\", { beforeExpr }),\n  doubleColon: new TokenType(\"::\", { beforeExpr }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", { beforeExpr }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", { beforeExpr }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", { beforeExpr }),\n  backQuote: new TokenType(\"`\", { startsExpr }),\n  dollarBraceL: new TokenType(\"${\", { beforeExpr, startsExpr }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", { startsExpr }),\n\n  // Special hashbang token.\n  interpreterDirective: new TokenType(\"#!...\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", { beforeExpr, isAssign }),\n  assign: new TokenType(\"_=\", { beforeExpr, isAssign }),\n  incDec: new TokenType(\"++/--\", { prefix, postfix, startsExpr }),\n  bang: new TokenType(\"!\", { beforeExpr, prefix, startsExpr }),\n  tilde: new TokenType(\"~\", { beforeExpr, prefix, startsExpr }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", { beforeExpr, binop: 9, prefix, startsExpr }),\n  // startsExpr: required by v8intrinsic plugin\n  modulo: new TokenType(\"%\", { beforeExpr, binop: 10, startsExpr }),\n  // unset `beforeExpr` as it can be `function *`\n  star: new TokenType(\"*\", { binop: 10 }),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true,\n  }),\n\n  // Keywords\n  // Don't forget to update packages/babel-helper-validator-identifier/src/keyword.js\n  // when new keywords are added\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", { beforeExpr }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", { beforeExpr }),\n  _do: createKeyword(\"do\", { isLoop, beforeExpr }),\n  _else: createKeyword(\"else\", { beforeExpr }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", { isLoop }),\n  _function: createKeyword(\"function\", { startsExpr }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", { beforeExpr }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", { beforeExpr, prefix, startsExpr }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", { isLoop }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", { beforeExpr, startsExpr }),\n  _this: createKeyword(\"this\", { startsExpr }),\n  _super: createKeyword(\"super\", { startsExpr }),\n  _class: createKeyword(\"class\", { startsExpr }),\n  _extends: createKeyword(\"extends\", { beforeExpr }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", { startsExpr }),\n  _null: createKeyword(\"null\", { startsExpr }),\n  _true: createKeyword(\"true\", { startsExpr }),\n  _false: createKeyword(\"false\", { startsExpr }),\n  _in: createKeyword(\"in\", { beforeExpr, binop: 7 }),\n  _instanceof: createKeyword(\"instanceof\", { beforeExpr, binop: 7 }),\n  _typeof: createKeyword(\"typeof\", { beforeExpr, prefix, startsExpr }),\n  _void: createKeyword(\"void\", { beforeExpr, prefix, startsExpr }),\n  _delete: createKeyword(\"delete\", { beforeExpr, prefix, startsExpr }),\n};\n","// @flow\n\nimport * as charCodes from \"charcodes\";\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nexport const lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nexport const lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n// https://tc39.github.io/ecma262/#sec-line-terminators\nexport function isNewLine(code: number): boolean {\n  switch (code) {\n    case charCodes.lineFeed:\n    case charCodes.carriageReturn:\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport const skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport function isWhitespace(code: number): boolean {\n  switch (code) {\n    case 0x0009: // CHARACTER TABULATION\n    case 0x000b: // LINE TABULATION\n    case 0x000c: // FORM FEED\n    case charCodes.space:\n    case charCodes.nonBreakingSpace:\n    case charCodes.oghamSpaceMark:\n    case 0x2000: // EN QUAD\n    case 0x2001: // EM QUAD\n    case 0x2002: // EN SPACE\n    case 0x2003: // EM SPACE\n    case 0x2004: // THREE-PER-EM SPACE\n    case 0x2005: // FOUR-PER-EM SPACE\n    case 0x2006: // SIX-PER-EM SPACE\n    case 0x2007: // FIGURE SPACE\n    case 0x2008: // PUNCTUATION SPACE\n    case 0x2009: // THIN SPACE\n    case 0x200a: // HAIR SPACE\n    case 0x202f: // NARROW NO-BREAK SPACE\n    case 0x205f: // MEDIUM MATHEMATICAL SPACE\n    case 0x3000: // IDEOGRAPHIC SPACE\n    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE\n      return true;\n\n    default:\n      return false;\n  }\n}\n","// @flow\n\nimport { lineBreakG } from \"./whitespace\";\n\nexport type Pos = {\n  start: number,\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nexport class Position {\n  line: number;\n  column: number;\n\n  constructor(line: number, col: number) {\n    this.line = line;\n    this.column = col;\n  }\n}\n\nexport class SourceLocation {\n  start: Position;\n  end: Position;\n  filename: string;\n  identifierName: ?string;\n\n  constructor(start: Position, end?: Position) {\n    this.start = start;\n    // $FlowIgnore (may start as null, but initialized later)\n    this.end = end;\n  }\n}\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nexport function getLineInfo(input: string, offset: number): Position {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n","// @flow\n\nimport type { Options } from \"../options\";\nimport type State from \"../tokenizer/state\";\nimport type { PluginsMap } from \"./index\";\nimport type ScopeHandler from \"../util/scope\";\nimport type ExpressionScopeHandler from \"../util/expression-scope\";\nimport type ClassScopeHandler from \"../util/class-scope\";\nimport type ProductionParameterHandler from \"../util/production-parameter\";\n\nexport default class BaseParser {\n  // Properties set by constructor in index.js\n  declare options: Options;\n  declare inModule: boolean;\n  declare scope: ScopeHandler<*>;\n  declare classScope: ClassScopeHandler;\n  declare prodParam: ProductionParameterHandler;\n  declare expressionScope: ExpressionScopeHandler;\n  declare plugins: PluginsMap;\n  declare filename: ?string;\n  sawUnambiguousESM: boolean = false;\n  ambiguousScriptDifferentAst: boolean = false;\n\n  // Initialized by Tokenizer\n  declare state: State;\n  // input and length are not in state as they are constant and we do\n  // not want to ever copy them, which happens if state gets cloned\n  declare input: string;\n  declare length: number;\n\n  hasPlugin(name: string): boolean {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin: string, name: string) {\n    // $FlowIssue\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n}\n","// @flow\n\n/**\n * Based on the comment attachment algorithm used in espree and estraverse.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright\n *   notice, this list of conditions and the following disclaimer.\n * * Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport BaseParser from \"./base\";\nimport type { Comment, Node } from \"../types\";\n\nfunction last<T>(stack: $ReadOnlyArray<T>): T {\n  return stack[stack.length - 1];\n}\n\nexport default class CommentsParser extends BaseParser {\n  addComment(comment: Comment): void {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(\n    node: Node,\n    elements: (Node | null)[],\n    // When the current node is followed by a token which hasn't a respective AST node, we\n    // need to take all the trailing comments to prevent them from being attached to an\n    // unrelated node. e.g. in\n    //     var { x } /* cmt */ = { y }\n    // we don't want /* cmt */ to be attached to { y }.\n    // On the other hand, in\n    //     fn(x) [new line] /* cmt */ [new line] y\n    // /* cmt */ is both a trailing comment of fn(x) and a leading comment of y\n    takeAllComments?: boolean,\n  ) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (\n        this.state.leadingComments[j].end < this.state.commentPreviousNode.end\n      ) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        // Perf: we don't need to splice if we are going to reset the array anyway\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n        node.trailingComments.push(leadingComment);\n      }\n    }\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node: Node): void {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n\n    const stack = this.state.commentStack;\n\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      // If the first comment in trailingComments comes after the\n      // current node, then we're good - all comments in the array will\n      // come after the node and so it's safe to add them as official\n      // trailingComments.\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        // Otherwise, if the first comment doesn't come after the\n        // current node, that means we have a mix of leading and trailing\n        // comments in the array and that leadingComments contains the\n        // same items as trailingComments. Reset trailingComments to\n        // zero items and we'll handle this by evaluating leadingComments\n        // later.\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n      if (\n        lastInStack.trailingComments &&\n        lastInStack.trailingComments[0].start >= node.end\n      ) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    // Eating the stack.\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    // Adjust comments that follow a trailing comma on the last element in a\n    // comma separated list of nodes to be the trailing comments on the last\n    // element\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (\n      this.state.commentPreviousNode &&\n      ((this.state.commentPreviousNode.type === \"ImportSpecifier\" &&\n        node.type !== \"ImportSpecifier\") ||\n        (this.state.commentPreviousNode.type === \"ExportSpecifier\" &&\n          node.type !== \"ExportSpecifier\"))\n    ) {\n      this.adjustCommentsAfterTrailingComma(node, [\n        this.state.commentPreviousNode,\n      ]);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (\n          lastChild !== node &&\n          lastChild.leadingComments.length > 0 &&\n          last(lastChild.leadingComments).end <= node.start\n        ) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          // A leading comment for an anonymous class had been stolen by its first ClassMethod,\n          // so this takes back the leading comment.\n          // See also: https://github.com/eslint/espree/issues/158\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (\n              this.state.leadingComments[j].end <\n              this.state.commentPreviousNode.end\n            ) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        // https://github.com/eslint/espree/issues/2\n        //\n        // In special cases, such as return (without a value) and\n        // debugger, all comments will end up as leadingComments and\n        // will otherwise be eliminated. This step runs when the\n        // commentStack is empty and there are comments left\n        // in leadingComments.\n        //\n        // This loop figures out the stopping point between the actual\n        // leading and trailing comments by finding the location of the\n        // first comment that comes after the given node.\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        // Split the array based on the location of the first comment\n        // that comes after the node. Keep in mind that this could\n        // result in an empty array, and if so, the array must be\n        // deleted.\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        // Similarly, trailing comments are attached later. The variable\n        // must be reset to null if there are no trailing comments.\n        trailingComments = this.state.leadingComments.slice(i);\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (\n        trailingComments.length &&\n        trailingComments[0].start >= node.start &&\n        last(trailingComments).end <= node.end\n      ) {\n        node.innerComments = trailingComments;\n      } else {\n        // TrailingComments maybe contain innerComments\n        const firstTrailingCommentIndex = trailingComments.findIndex(\n          comment => comment.end >= node.end,\n        );\n\n        if (firstTrailingCommentIndex > 0) {\n          node.innerComments = trailingComments.slice(\n            0,\n            firstTrailingCommentIndex,\n          );\n          node.trailingComments = trailingComments.slice(\n            firstTrailingCommentIndex,\n          );\n        } else {\n          node.trailingComments = trailingComments;\n        }\n      }\n    }\n\n    stack.push(node);\n  }\n}\n","// @flow\n/* eslint sort-keys: \"error\" */\n\n/**\n * @module parser/error-message\n */\n\n// The Errors key follows https://cs.chromium.org/chromium/src/v8/src/common/message-template.h unless it does not exist\nexport const ErrorMessages = Object.freeze({\n  AccessorIsGenerator: \"A %0ter cannot be a generator\",\n  ArgumentsInClass:\n    \"'arguments' is only allowed in functions and class methods\",\n  AsyncFunctionInSingleStatementContext:\n    \"Async functions can only be declared at the top level or inside a block\",\n  AwaitBindingIdentifier:\n    \"Can not use 'await' as identifier inside an async function\",\n  AwaitBindingIdentifierInStaticBlock:\n    \"Can not use 'await' as identifier inside a static block\",\n  AwaitExpressionFormalParameter:\n    \"await is not allowed in async function parameters\",\n  AwaitNotInAsyncContext:\n    \"'await' is only allowed within async functions and at the top levels of modules\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions\",\n  BadGetterArity: \"getter must not have any formal parameters\",\n  BadSetterArity: \"setter must have exactly one formal parameter\",\n  BadSetterRestParameter:\n    \"setter function argument must not be a rest parameter\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n  ConstructorClassPrivateField:\n    \"Classes may not have a private field named '#constructor'\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n  ConstructorIsAsync: \"Constructor can't be an async function\",\n  ConstructorIsGenerator: \"Constructor can't be a generator\",\n  DeclarationMissingInitializer: \"%0 require an initialization value\",\n  DecoratorBeforeExport:\n    \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n  DecoratorConstructor:\n    \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass:\n    \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block\",\n  DeletePrivateField: \"Deleting a private field is not allowed\",\n  DestructureNamedImport:\n    \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport:\n    \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n  ElementAfterRest: \"Rest element must be last element\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n  ExportBindingIsString:\n    \"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",\n  ExportDefaultFromAsIdentifier:\n    \"'from' is not allowed as an identifier after 'export default'\",\n  ForInOfLoopInitializer:\n    \"%0 loop variable declaration may not have an initializer\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext:\n    \"Generators can only be declared at the top level or inside a block\",\n  IllegalBreakContinue: \"Unsyntactic %0\",\n  IllegalLanguageModeDirective:\n    \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"'return' outside of function\",\n  ImportBindingIsString:\n    'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',\n  ImportCallArgumentTrailingComma:\n    \"Trailing comma is disallowed inside import(...) arguments\",\n  ImportCallArity: \"import() requires exactly %0\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n  ImportCallSpreadArgument: \"... is not allowed in import()\",\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral\",\n  InvalidCodePoint: \"Code point out of bounds\",\n  InvalidDecimal: \"Invalid decimal\",\n  InvalidDigit: \"Expected number in radix %0\",\n  InvalidEscapeSequence: \"Bad character escape sequence\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n  InvalidIdentifier: \"Invalid identifier %0\",\n  InvalidLhs: \"Invalid left-hand side in %0\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n  InvalidNumber: \"Invalid number\",\n  InvalidOrMissingExponent:\n    \"Floating-point numbers require a valid exponent after the 'e'\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n  InvalidPropertyBindingPattern: \"Binding member expression\",\n  InvalidRecordProperty:\n    \"Only properties and spread elements are allowed in record definitions\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n  LabelRedeclaration: \"Label '%0' is already declared\",\n  LetInLexicalBinding:\n    \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'\",\n  MalformedRegExpFlags: \"Invalid regular expression flag\",\n  MissingClassName: \"A class name is required\",\n  MissingEqInAssignment:\n    \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n  MixingCoalesceWithLogical:\n    \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n  ModuleAttributeDifferentFromType:\n    \"The only accepted module attribute is `type`\",\n  ModuleAttributeInvalidValue:\n    \"Only string literals are allowed as module attribute values\",\n  ModuleAttributesWithDuplicateKeys:\n    'Duplicate key \"%0\" is not allowed in module attributes',\n  ModuleExportNameHasLoneSurrogate:\n    \"An export name cannot include a lone surrogate, found '\\\\u%0'\",\n  ModuleExportUndefined: \"Export '%0' is not defined\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoCatchOrFinally: \"Missing catch or finally clause\",\n  NumberIdentifier: \"Identifier directly after number\",\n  NumericSeparatorInEscapeSequence:\n    \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n  ObsoleteAwaitStar:\n    \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew:\n    \"constructors in/after an Optional Chain are not allowed\",\n  OptionalChainingNoTemplate:\n    \"Tagged Template Literals are not allowed in optionalChain\",\n  ParamDupe: \"Argument name clash\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n  PatternHasMethod: \"Object pattern can't contain methods\",\n  PipelineBodyNoArrow:\n    'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n  PipelineBodySequenceExpression:\n    \"Pipeline body may not be a comma-separated sequence expression\",\n  PipelineHeadSequenceExpression:\n    \"Pipeline head should not be a comma-separated sequence expression\",\n  PipelineTopicUnused:\n    \"Pipeline is in topic style but does not use topic reference\",\n  PrimaryTopicNotAllowed:\n    \"Topic reference was used in a lexical context without topic binding\",\n  PrimaryTopicRequiresSmartPipeline:\n    \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n  PrivateInExpectedIn:\n    \"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0\",\n  RecordExpressionBarIncorrectEndSyntaxType:\n    \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionBarIncorrectStartSyntaxType:\n    \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionHashIncorrectStartSyntaxType:\n    \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element\",\n  SloppyFunction:\n    \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictDelete: \"Deleting local variable in strict mode\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n  StrictFunction:\n    \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n  StrictWith: \"'with' in strict mode\",\n  SuperNotAllowed:\n    \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super\",\n  TrailingDecorator: \"Decorators must be attached to a class element\",\n  TupleExpressionBarIncorrectEndSyntaxType:\n    \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionBarIncorrectStartSyntaxType:\n    \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionHashIncorrectStartSyntaxType:\n    \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n  UnexpectedAwaitAfterPipelineBody:\n    'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n  UnexpectedImportExport:\n    \"'import' and 'export' may only appear at the top level\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'\",\n  UnexpectedLeadingDecorator:\n    \"Leading decorators must be attached to a class declaration\",\n  UnexpectedLexicalDeclaration:\n    \"Lexical declaration cannot appear in a single-statement context\",\n  UnexpectedNewTarget: \"new.target can only be used in functions\",\n  UnexpectedNumericSeparator:\n    \"A numeric separator is only allowed between two digits\",\n  UnexpectedPrivateField:\n    \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n  UnexpectedSuper: \"super is only allowed in object methods and classes\",\n  UnexpectedToken: \"Unexpected token '%0'\",\n  UnexpectedTokenUnaryExponentiation:\n    \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport:\n    \"A decorated export must export a class declaration\",\n  UnsupportedDefaultExport:\n    \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"import can only be used in import() or import.meta\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n  UnsupportedParameterDecorator:\n    \"Decorators cannot be used to decorate parameters\",\n  UnsupportedPropertyDecorator:\n    \"Decorators cannot be used to decorate object literal properties\",\n  UnsupportedSuper:\n    \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n  UnterminatedComment: \"Unterminated comment\",\n  UnterminatedRegExp: \"Unterminated regular expression\",\n  UnterminatedString: \"Unterminated string constant\",\n  UnterminatedTemplate: \"Unterminated template\",\n  VarRedeclaration: \"Identifier '%0' has already been declared\",\n  YieldBindingIdentifier:\n    \"Can not use 'yield' as identifier inside a generator\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters\",\n  ZeroDigitNumericSeparator:\n    \"Numeric separator can not be used after leading 0\",\n});\n","// @flow\n/* eslint sort-keys: \"error\" */\nimport { getLineInfo, type Position } from \"../util/location\";\nimport CommentsParser from \"./comments\";\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\ntype ErrorContext = {\n  pos: number,\n  loc: Position,\n  missingPlugin?: Array<string>,\n  code?: string,\n};\n\nexport type ParsingError = SyntaxError & ErrorContext;\n\nexport { ErrorMessages as Errors } from \"./error-message\";\n\nexport default class ParserError extends CommentsParser {\n  // Forward-declaration: defined in tokenizer/index.js\n  /*::\n  +isLookahead: boolean;\n  */\n\n  getLocationForPosition(pos: number): Position {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;\n    else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;\n    else if (pos === this.state.end) loc = this.state.endLoc;\n    else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;\n    else loc = getLineInfo(this.input, pos);\n\n    return loc;\n  }\n\n  raise(pos: number, errorTemplate: string, ...params: any): Error | empty {\n    return this.raiseWithData(pos, undefined, errorTemplate, ...params);\n  }\n\n  /**\n   * Raise a parsing error on given position pos. If errorRecovery is true,\n   * it will first search current errors and overwrite the error thrown on the exact\n   * position before with the new error message. If errorRecovery is false, it\n   * fallbacks to `raise`.\n   *\n   * @param {number} pos\n   * @param {string} errorTemplate\n   * @param {...any} params\n   * @returns {(Error | empty)}\n   * @memberof ParserError\n   */\n  raiseOverwrite(\n    pos: number,\n    errorTemplate: string,\n    ...params: any\n  ): Error | empty {\n    const loc = this.getLocationForPosition(pos);\n    const message =\n      errorTemplate.replace(/%(\\d+)/g, (_, i: number) => params[i]) +\n      ` (${loc.line}:${loc.column})`;\n    if (this.options.errorRecovery) {\n      const errors = this.state.errors;\n      for (let i = errors.length - 1; i >= 0; i--) {\n        const error = errors[i];\n        if (error.pos === pos) {\n          return Object.assign(error, { message });\n        } else if (error.pos < pos) {\n          break;\n        }\n      }\n    }\n    return this._raise({ loc, pos }, message);\n  }\n\n  raiseWithData(\n    pos: number,\n    data?: {\n      missingPlugin?: Array<string>,\n      code?: string,\n    },\n    errorTemplate: string,\n    ...params: any\n  ): Error | empty {\n    const loc = this.getLocationForPosition(pos);\n    const message =\n      errorTemplate.replace(/%(\\d+)/g, (_, i: number) => params[i]) +\n      ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign(({ loc, pos }: Object), data), message);\n  }\n\n  _raise(errorContext: ErrorContext, message: string): Error | empty {\n    // $FlowIgnore\n    const err: SyntaxError & ErrorContext = new SyntaxError(message);\n    Object.assign(err, errorContext);\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n}\n","// @flow\n\nimport { types as tt, TokenType } from \"../tokenizer/types\";\nimport type Parser from \"../parser\";\nimport type { ExpressionErrors } from \"../parser/util\";\nimport * as N from \"../types\";\nimport type { Position } from \"../util/location\";\nimport { Errors } from \"../parser/error\";\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    estreeParseRegExpLiteral({ pattern, flags }: N.RegExpLiteral): N.Node {\n      let regex = null;\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (e) {\n        // In environments that don't support these flags value will\n        // be null as the regex can't be represented natively.\n      }\n      const node = this.estreeParseLiteral(regex);\n      node.regex = { pattern, flags };\n\n      return node;\n    }\n\n    estreeParseBigIntLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n      let bigInt;\n      try {\n        // $FlowIgnore\n        bigInt = BigInt(value);\n      } catch {\n        bigInt = null;\n      }\n      const node = this.estreeParseLiteral(bigInt);\n      node.bigint = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseDecimalLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/experimental/decimal.md\n      // todo: use BigDecimal when node supports it.\n      const decimal = null;\n      const node = this.estreeParseLiteral(decimal);\n      node.decimal = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseLiteral(value: any): N.Node {\n      return this.parseLiteral(value, \"Literal\");\n    }\n\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\n      const directiveLiteral = directive.value;\n\n      const stmt = this.startNodeAt(directive.start, directive.loc.start);\n      const expression = this.startNodeAt(\n        directiveLiteral.start,\n        directiveLiteral.loc.start,\n      );\n\n      expression.value = directiveLiteral.extra.expressionValue;\n      expression.raw = directiveLiteral.extra.raw;\n\n      stmt.expression = this.finishNodeAt(\n        expression,\n        \"Literal\",\n        directiveLiteral.end,\n        directiveLiteral.loc.end,\n      );\n      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n\n      return this.finishNodeAt(\n        stmt,\n        \"ExpressionStatement\",\n        directive.end,\n        directive.loc.end,\n      );\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    initFunction(\n      node: N.BodilessFunctionOrMethodBase,\n      isAsync: ?boolean,\n    ): void {\n      super.initFunction(node, isAsync);\n      node.expression = false;\n    }\n\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n      if (node != null && this.isObjectProperty(node)) {\n        this.checkDeclaration(((node: any): N.EstreeProperty).value);\n      } else {\n        super.checkDeclaration(node);\n      }\n    }\n\n    getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n      return ((method: any): N.EstreeProperty | N.EstreeMethodDefinition).value\n        .params;\n    }\n\n    isValidDirective(stmt: N.Statement): boolean {\n      return (\n        stmt.type === \"ExpressionStatement\" &&\n        stmt.expression.type === \"Literal\" &&\n        typeof stmt.expression.value === \"string\" &&\n        !stmt.expression.extra?.parenthesized\n      );\n    }\n\n    stmtToDirective(stmt: N.Statement): N.Directive {\n      const directive = super.stmtToDirective(stmt);\n      const value = stmt.expression.value;\n\n      // Record the expression value as in estree mode we want\n      // the stmt to have the real value e.g. (\"use strict\") and\n      // not the raw value e.g. (\"use\\\\x20strict\")\n      this.addExtra(directive.value, \"expressionValue\", value);\n\n      return directive;\n    }\n\n    parseBlockBody(\n      node: N.BlockStatementLike,\n      ...args: [?boolean, boolean, TokenType, void | (boolean => void)]\n    ): void {\n      super.parseBlockBody(node, ...args);\n\n      const directiveStatements = node.directives.map(d =>\n        this.directiveToStmt(d),\n      );\n      node.body = directiveStatements.concat(node.body);\n      // $FlowIgnore - directives isn't optional in the type definition\n      delete node.directives;\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      );\n      if (method.typeParameters) {\n        // $FlowIgnore\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(method);\n    }\n\n    parseExprAtom(refExpressionErrors?: ?ExpressionErrors): N.Expression {\n      switch (this.state.type) {\n        case tt.num:\n        case tt.string:\n          return this.estreeParseLiteral(this.state.value);\n\n        case tt.regexp:\n          return this.estreeParseRegExpLiteral(this.state.value);\n\n        case tt.bigint:\n          return this.estreeParseBigIntLiteral(this.state.value);\n\n        case tt.decimal:\n          return this.estreeParseDecimalLiteral(this.state.value);\n\n        case tt._null:\n          return this.estreeParseLiteral(null);\n\n        case tt._true:\n          return this.estreeParseLiteral(true);\n\n        case tt._false:\n          return this.estreeParseLiteral(false);\n\n        default:\n          return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    parseMaybePrivateName(...args: [boolean]): any {\n      const node = super.parseMaybePrivateName(...args);\n      if (\n        node.type === \"PrivateName\" &&\n        this.getPluginOption(\"estree\", \"classFeatures\")\n      ) {\n        return this.convertPrivateNameToPrivateIdentifier(node);\n      }\n      return node;\n    }\n\n    convertPrivateNameToPrivateIdentifier(\n      node: N.PrivateName,\n    ): N.EstreePrivateIdentifier {\n      const name = super.getPrivateNameSV(node);\n      node = (node: any);\n      delete node.id;\n      node.name = name;\n      node.type = \"PrivateIdentifier\";\n      return node;\n    }\n\n    isPrivateName(node: N.Node): boolean {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n      return node.type === \"PrivateIdentifier\";\n    }\n\n    getPrivateNameSV(node: N.Node): string {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n      return node.name;\n    }\n\n    parseLiteral<T: N.Literal>(\n      value: any,\n      type: /*T[\"kind\"]*/ string,\n      startPos?: number,\n      startLoc?: Position,\n    ): T {\n      const node = super.parseLiteral(value, type, startPos, startLoc);\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    }\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpression: ?boolean,\n      isMethod?: boolean = false,\n    ): void {\n      super.parseFunctionBody(node, allowExpression, isMethod);\n      node.expression = node.body.type !== \"BlockStatement\";\n    }\n\n    parseMethod<T: N.MethodLike>(\n      node: T,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: string,\n      inClassScope: boolean = false,\n    ): T {\n      let funcNode = this.startNode();\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n      funcNode = super.parseMethod(\n        funcNode,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      funcNode.type = \"FunctionExpression\";\n      delete funcNode.kind;\n      // $FlowIgnore\n      node.value = funcNode;\n      if (type === \"ClassPrivateMethod\") {\n        // $FlowIgnore\n        node.computed = false;\n      }\n      type = \"MethodDefinition\";\n      return this.finishNode(node, type);\n    }\n\n    parseClassProperty(...args: [N.ClassProperty]): any {\n      const propertyNode = (super.parseClassProperty(...args): any);\n      if (this.getPluginOption(\"estree\", \"classFeatures\")) {\n        propertyNode.type = \"PropertyDefinition\";\n      }\n      return (propertyNode: N.EstreePropertyDefinition);\n    }\n\n    parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {\n      const propertyNode = (super.parseClassPrivateProperty(...args): any);\n      if (this.getPluginOption(\"estree\", \"classFeatures\")) {\n        propertyNode.type = \"PropertyDefinition\";\n        propertyNode.computed = false;\n      }\n      return (propertyNode: N.EstreePropertyDefinition);\n    }\n\n    parseObjectMethod(\n      prop: N.ObjectMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n    ): ?N.ObjectMethod {\n      const node: N.EstreeProperty = (super.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ): any);\n\n      if (node) {\n        node.type = \"Property\";\n        if (((node: any): N.ClassMethod).kind === \"method\") node.kind = \"init\";\n        node.shorthand = false;\n      }\n\n      return (node: any);\n    }\n\n    parseObjectProperty(\n      prop: N.ObjectProperty,\n      startPos: ?number,\n      startLoc: ?Position,\n      isPattern: boolean,\n      refExpressionErrors: ?ExpressionErrors,\n    ): ?N.ObjectProperty {\n      const node: N.EstreeProperty = (super.parseObjectProperty(\n        prop,\n        startPos,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      ): any);\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return (node: any);\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): N.Node {\n      if (node != null && this.isObjectProperty(node)) {\n        this.toAssignable(node.value, isLHS);\n\n        return node;\n      }\n\n      return super.toAssignable(node, isLHS);\n    }\n\n    toAssignableObjectExpressionProp(prop: N.Node, ...args) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        this.raise(prop.key.start, Errors.PatternHasAccessor);\n      } else if (prop.method) {\n        this.raise(prop.key.start, Errors.PatternHasMethod);\n      } else {\n        super.toAssignableObjectExpressionProp(prop, ...args);\n      }\n    }\n\n    finishCallExpression<T: N.CallExpression | N.OptionalCallExpression>(\n      node: T,\n      optional: boolean,\n    ): N.Expression {\n      super.finishCallExpression(node, optional);\n\n      if (node.callee.type === \"Import\") {\n        ((node: N.Node): N.EstreeImportExpression).type = \"ImportExpression\";\n        ((node: N.Node): N.EstreeImportExpression).source = node.arguments[0];\n        // $FlowIgnore - arguments isn't optional in the type definition\n        delete node.arguments;\n        // $FlowIgnore - callee isn't optional in the type definition\n        delete node.callee;\n      }\n\n      return node;\n    }\n\n    toReferencedArguments(\n      node:\n        | N.CallExpression\n        | N.OptionalCallExpression\n        | N.EstreeImportExpression,\n      /* isParenthesizedExpr?: boolean, */\n    ) {\n      // ImportExpressions do not have an arguments array.\n      if (node.type === \"ImportExpression\") {\n        return;\n      }\n\n      super.toReferencedArguments(node);\n    }\n\n    parseExport(node: N.Node) {\n      super.parseExport(node);\n\n      switch (node.type) {\n        case \"ExportAllDeclaration\":\n          node.exported = null;\n          break;\n\n        case \"ExportNamedDeclaration\":\n          if (\n            node.specifiers.length === 1 &&\n            node.specifiers[0].type === \"ExportNamespaceSpecifier\"\n          ) {\n            node.type = \"ExportAllDeclaration\";\n            node.exported = node.specifiers[0].exported;\n            delete node.specifiers;\n          }\n\n          break;\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: ?boolean,\n      state: N.ParseSubscriptState,\n    ) {\n      const node = super.parseSubscript(\n        base,\n        startPos,\n        startLoc,\n        noCalls,\n        state,\n      );\n\n      if (state.optionalChainMember) {\n        // https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n        if (\n          node.type === \"OptionalMemberExpression\" ||\n          node.type === \"OptionalCallExpression\"\n        ) {\n          node.type = node.type.substring(8); // strip Optional prefix\n        }\n        if (state.stop) {\n          const chain = this.startNodeAtNode(node);\n          chain.expression = node;\n          return this.finishNode(chain, \"ChainExpression\");\n        }\n      } else if (\n        node.type === \"MemberExpression\" ||\n        node.type === \"CallExpression\"\n      ) {\n        node.optional = false;\n      }\n\n      return node;\n    }\n\n    hasPropertyAsPrivateName(node: N.Node): boolean {\n      if (node.type === \"ChainExpression\") {\n        node = node.expression;\n      }\n      return super.hasPropertyAsPrivateName(node);\n    }\n\n    isOptionalChain(node: N.Node): boolean {\n      return node.type === \"ChainExpression\";\n    }\n\n    isObjectProperty(node: N.Node): boolean {\n      return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n    }\n\n    isObjectMethod(node: N.Node): boolean {\n      return node.method || node.kind === \"get\" || node.kind === \"set\";\n    }\n  };\n","// @flow\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nimport { types as tt } from \"./types\";\n\nexport class TokContext {\n  constructor(\n    token: string,\n    isExpr?: boolean,\n    preserveSpace?: boolean,\n    override?: ?Function, // Takes a Tokenizer as a this-parameter, and returns void.\n  ) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n  token: string;\n  isExpr: boolean;\n  preserveSpace: boolean;\n  override: ?Function;\n}\n\nexport const types: {\n  [key: string]: TokContext,\n} = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  recordExpression: new TokContext(\"#{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false),\n};\n\n// Token-specific context update code\n// Note that we should avoid accessing `this.prodParam` in context update,\n// because it is executed immediately when last token is consumed, which may be\n// before `this.prodParam` is updated. e.g.\n// ```\n// function *g() { () => yield / 2 }\n// ```\n// When `=>` is eaten, the context update of `yield` is executed, however,\n// `this.prodParam` still has `[Yield]` production because it is not yet updated\n\ntt.parenR.updateContext = tt.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n  if (out === types.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntt.name.updateContext = function (prevType) {\n  let allowed = false;\n  if (prevType !== tt.dot) {\n    if (\n      this.state.value === \"of\" &&\n      !this.state.exprAllowed &&\n      prevType !== tt._function &&\n      prevType !== tt._class\n    ) {\n      allowed = true;\n    }\n  }\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntt.braceL.updateContext = function (prevType) {\n  this.state.context.push(\n    this.braceIsBlock(prevType) ? types.braceStatement : types.braceExpression,\n  );\n  this.state.exprAllowed = true;\n};\n\ntt.dollarBraceL.updateContext = function () {\n  this.state.context.push(types.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntt.parenL.updateContext = function (prevType) {\n  const statementParens =\n    prevType === tt._if ||\n    prevType === tt._for ||\n    prevType === tt._with ||\n    prevType === tt._while;\n  this.state.context.push(\n    statementParens ? types.parenStatement : types.parenExpression,\n  );\n  this.state.exprAllowed = true;\n};\n\ntt.incDec.updateContext = function () {\n  // tokExprAllowed stays unchanged\n};\n\ntt._function.updateContext = tt._class.updateContext = function (prevType) {\n  if (\n    prevType.beforeExpr &&\n    prevType !== tt.semi &&\n    prevType !== tt._else &&\n    !(prevType === tt._return && this.hasPrecedingLineBreak()) &&\n    !(\n      (prevType === tt.colon || prevType === tt.braceL) &&\n      this.curContext() === types.b_stat\n    )\n  ) {\n    this.state.context.push(types.functionExpression);\n  } else {\n    this.state.context.push(types.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntt.backQuote.updateContext = function () {\n  if (this.curContext() === types.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types.template);\n  }\n  this.state.exprAllowed = false;\n};\n\n// we don't need to update context for tt.braceBarL because we do not pop context for tt.braceBarR\ntt.braceHashL.updateContext = function () {\n  this.state.context.push(types.recordExpression);\n  this.state.exprAllowed = true; /* tt.braceHashL.beforeExpr */\n};\n","import * as charCodes from \"charcodes\";\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point between 0x80 and 0xffff.\n// Generated by `scripts/generate-identifier-regex.js`.\n\n/* prettier-ignore */\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n/* prettier-ignore */\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nconst nonASCIIidentifierStart = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\n);\nconst nonASCIIidentifier = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\n);\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset-encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `scripts/generate-identifier-regex.js`.\n/* prettier-ignore */\n/* prettier-ignore */\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,107,20,28,22,13,52,76,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8952,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42717,35,4148,12,221,3,5761,15,7472,3104,541,1507,4938];\n/* prettier-ignore */\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code: number, set: readonly number[]): boolean {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\n// Test whether a given character code starts an identifier.\n\nexport function isIdentifierStart(code: number): boolean {\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return (\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    );\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nexport function isIdentifierChar(code: number): boolean {\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\n  if (code < charCodes.colon) return true;\n  if (code < charCodes.uppercaseA) return false;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return (\n    isInAstralSet(code, astralIdentifierStartCodes) ||\n    isInAstralSet(code, astralIdentifierCodes)\n  );\n}\n\n// Test whether a given string is a valid identifier name\n\nexport function isIdentifierName(name: string): boolean {\n  let isFirst = true;\n  for (const char of Array.from(name)) {\n    const cp = char.codePointAt(0);\n    if (isFirst) {\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n      isFirst = false;\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n","const reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\",\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\",\n  ],\n  strictBind: [\"eval\", \"arguments\"],\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\n/**\n * Checks if word is a reserved word in non-strict mode\n */\nexport function isReservedWord(word: string, inModule: boolean): boolean {\n  return (inModule && word === \"await\") || word === \"enum\";\n}\n\n/**\n * Checks if word is a reserved word in non-binding strict mode\n *\n * Includes non-strict reserved words\n */\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode, but it is allowed as\n * a normal identifier.\n */\nexport function isStrictBindOnlyReservedWord(word: string): boolean {\n  return reservedWordsStrictBindSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode\n *\n * Includes non-strict reserved words and non-binding strict reserved words\n */\nexport function isStrictBindReservedWord(\n  word: string,\n  inModule: boolean,\n): boolean {\n  return (\n    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)\n  );\n}\n\nexport function isKeyword(word: string): boolean {\n  return keywords.has(word);\n}\n","/* eslint max-len: 0 */\n\n// @flow\n\nimport * as charCodes from \"charcodes\";\n\nexport {\n  isIdentifierStart,\n  isIdentifierChar,\n  isReservedWord,\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nexport const keywordRelationalOperator = /^in(stanceof)?$/;\n\n// Test whether a current state character code and next character code is @\n\nexport function isIteratorStart(current: number, next: number): boolean {\n  return current === charCodes.atSign && next === charCodes.atSign;\n}\n","// @flow\n\n// Each scope gets a bitset that may contain these flags\n// prettier-ignore\nexport const SCOPE_OTHER        = 0b000000000,\n             SCOPE_PROGRAM      = 0b000000001,\n             SCOPE_FUNCTION     = 0b000000010,\n             SCOPE_ARROW        = 0b000000100,\n             SCOPE_SIMPLE_CATCH = 0b000001000,\n             SCOPE_SUPER        = 0b000010000,\n             SCOPE_DIRECT_SUPER = 0b000100000,\n             SCOPE_CLASS        = 0b001000000,\n             SCOPE_STATIC_BLOCK = 0b010000000,\n             SCOPE_TS_MODULE    = 0b100000000,\n             SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\n\nexport type ScopeFlags =\n  | typeof SCOPE_OTHER\n  | typeof SCOPE_PROGRAM\n  | typeof SCOPE_FUNCTION\n  | typeof SCOPE_VAR\n  | typeof SCOPE_ARROW\n  | typeof SCOPE_SIMPLE_CATCH\n  | typeof SCOPE_SUPER\n  | typeof SCOPE_DIRECT_SUPER\n  | typeof SCOPE_CLASS\n  | typeof SCOPE_STATIC_BLOCK;\n\n// These flags are meant to be _only_ used inside the Scope class (or subclasses).\n// prettier-ignore\nexport const BIND_KIND_VALUE            = 0b000000_0000_01,\n             BIND_KIND_TYPE             = 0b000000_0000_10,\n             // Used in checkLVal and declareName to determine the type of a binding\n             BIND_SCOPE_VAR             = 0b000000_0001_00, // Var-style binding\n             BIND_SCOPE_LEXICAL         = 0b000000_0010_00, // Let- or const-style binding\n             BIND_SCOPE_FUNCTION        = 0b000000_0100_00, // Function declaration\n             BIND_SCOPE_OUTSIDE         = 0b000000_1000_00, // Special case for function names as\n                                                   // bound inside the function\n             // Misc flags\n             BIND_FLAGS_NONE            = 0b000001_0000_00,\n             BIND_FLAGS_CLASS           = 0b000010_0000_00,\n             BIND_FLAGS_TS_ENUM         = 0b000100_0000_00,\n             BIND_FLAGS_TS_CONST_ENUM   = 0b001000_0000_00,\n             BIND_FLAGS_TS_EXPORT_ONLY  = 0b010000_0000_00,\n             BIND_FLAGS_FLOW_DECLARE_FN = 0b100000_0000_00;\n\n// These flags are meant to be _only_ used by Scope consumers\n// prettier-ignore\n/*                              =    is value?    |    is type?    |      scope          |    misc flags    */\nexport const BIND_CLASS         = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_CLASS  ,\n             BIND_LEXICAL       = BIND_KIND_VALUE | 0              | BIND_SCOPE_LEXICAL  | 0                 ,\n             BIND_VAR           = BIND_KIND_VALUE | 0              | BIND_SCOPE_VAR      | 0                 ,\n             BIND_FUNCTION      = BIND_KIND_VALUE | 0              | BIND_SCOPE_FUNCTION | 0                 ,\n             BIND_TS_INTERFACE  = 0               | BIND_KIND_TYPE | 0                   | BIND_FLAGS_CLASS  ,\n             BIND_TS_TYPE       = 0               | BIND_KIND_TYPE | 0                   | 0                 ,\n             BIND_TS_ENUM       = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_TS_ENUM,\n             BIND_TS_AMBIENT    = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,\n             // These bindings don't introduce anything in the scope. They are used for assignments and\n             // function expressions IDs.\n             BIND_NONE          = 0               | 0              | 0                   | BIND_FLAGS_NONE   ,\n             BIND_OUTSIDE       = BIND_KIND_VALUE | 0              | 0                   | BIND_FLAGS_NONE   ,\n\n             BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n             BIND_TS_NAMESPACE  = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,\n\n             BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\n\nexport type BindingTypes =\n  | typeof BIND_NONE\n  | typeof BIND_OUTSIDE\n  | typeof BIND_VAR\n  | typeof BIND_LEXICAL\n  | typeof BIND_CLASS\n  | typeof BIND_FUNCTION\n  | typeof BIND_TS_INTERFACE\n  | typeof BIND_TS_TYPE\n  | typeof BIND_TS_ENUM\n  | typeof BIND_TS_AMBIENT\n  | typeof BIND_TS_NAMESPACE;\n\n// prettier-ignore\nexport const CLASS_ELEMENT_FLAG_STATIC = 0b1_00,\n             CLASS_ELEMENT_KIND_GETTER = 0b0_10,\n             CLASS_ELEMENT_KIND_SETTER = 0b0_01,\n             CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\n\n// prettier-ignore\nexport const CLASS_ELEMENT_STATIC_GETTER   = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n             CLASS_ELEMENT_STATIC_SETTER   = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n             CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n             CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n             CLASS_ELEMENT_OTHER           = 0;\n\nexport type ClassElementTypes =\n  | typeof CLASS_ELEMENT_STATIC_GETTER\n  | typeof CLASS_ELEMENT_STATIC_SETTER\n  | typeof CLASS_ELEMENT_INSTANCE_GETTER\n  | typeof CLASS_ELEMENT_INSTANCE_SETTER\n  | typeof CLASS_ELEMENT_OTHER;\n","// @flow\nimport {\n  SCOPE_ARROW,\n  SCOPE_DIRECT_SUPER,\n  SCOPE_FUNCTION,\n  SCOPE_SIMPLE_CATCH,\n  SCOPE_SUPER,\n  SCOPE_PROGRAM,\n  SCOPE_VAR,\n  SCOPE_CLASS,\n  SCOPE_STATIC_BLOCK,\n  BIND_SCOPE_FUNCTION,\n  BIND_SCOPE_VAR,\n  BIND_SCOPE_LEXICAL,\n  BIND_KIND_VALUE,\n  type ScopeFlags,\n  type BindingTypes,\n} from \"./scopeflags\";\nimport * as N from \"../types\";\nimport { Errors } from \"../parser/error\";\n\n// Start an AST node, attaching a start offset.\nexport class Scope {\n  flags: ScopeFlags;\n  // A list of var-declared names in the current lexical scope\n  var: string[] = [];\n  // A list of lexically-declared names in the current lexical scope\n  lexical: string[] = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  functions: string[] = [];\n\n  constructor(flags: ScopeFlags) {\n    this.flags = flags;\n  }\n}\n\ntype raiseFunction = (number, string, ...any) => void;\n\n// The functions in this module keep track of declared variables in the\n// current scope in order to detect duplicate variable names.\nexport default class ScopeHandler<IScope: Scope = Scope> {\n  scopeStack: Array<IScope> = [];\n  declare raise: raiseFunction;\n  declare inModule: boolean;\n  undefinedExports: Map<string, number> = new Map();\n  undefinedPrivateNames: Map<string, number> = new Map();\n\n  constructor(raise: raiseFunction, inModule: boolean) {\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n  get inStaticBlock() {\n    return (this.currentThisScope().flags & SCOPE_STATIC_BLOCK) > 0;\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags: ScopeFlags): Scope {\n    return new Scope(flags);\n  }\n  // This method will be overwritten by subclasses\n  /*:: +createScope: (flags: ScopeFlags) => IScope; */\n\n  enter(flags: ScopeFlags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\n    return !!(\n      scope.flags & SCOPE_FUNCTION ||\n      (!this.inModule && scope.flags & SCOPE_PROGRAM)\n    );\n  }\n\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\n    let scope = this.currentScope();\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope: IScope, name: string) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n    pos: number,\n  ) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, Errors.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return (\n        scope.lexical.indexOf(name) > -1 ||\n        scope.functions.indexOf(name) > -1 ||\n        scope.var.indexOf(name) > -1\n      );\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return (\n        scope.lexical.indexOf(name) > -1 ||\n        (!this.treatFunctionsAsVarInScope(scope) &&\n          scope.var.indexOf(name) > -1)\n      );\n    }\n\n    return (\n      (scope.lexical.indexOf(name) > -1 &&\n        !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name)) ||\n      (!this.treatFunctionsAsVarInScope(scope) &&\n        scope.functions.indexOf(name) > -1)\n    );\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    if (\n      this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1 &&\n      // In strict mode, scope.functions will always be empty.\n      // Modules are strict by default, but the `scriptMode` option\n      // can overwrite this behavior.\n      this.scopeStack[0].functions.indexOf(id.name) === -1\n    ) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope(): IScope {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  // $FlowIgnore\n  currentVarScope(): IScope {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  // Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  // $FlowIgnore\n  currentThisScope(): IScope {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const scope = this.scopeStack[i];\n      if (\n        (scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) &&\n        !(scope.flags & SCOPE_ARROW)\n      ) {\n        return scope;\n      }\n    }\n  }\n}\n","// @flow\n\nimport ScopeHandler, { Scope } from \"../../util/scope\";\nimport {\n  BIND_FLAGS_FLOW_DECLARE_FN,\n  type ScopeFlags,\n  type BindingTypes,\n} from \"../../util/scopeflags\";\nimport * as N from \"../../types\";\n\n// Reference implementation: https://github.com/facebook/flow/blob/23aeb2a2ef6eb4241ce178fde5d8f17c5f747fb5/src/typing/env.ml#L536-L584\nclass FlowScope extends Scope {\n  // declare function foo(): type;\n  declareFunctions: string[] = [];\n}\n\nexport default class FlowScopeHandler extends ScopeHandler<FlowScope> {\n  createScope(flags: ScopeFlags): FlowScope {\n    return new FlowScope(flags);\n  }\n\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n  }\n\n  isRedeclaredInScope(\n    scope: FlowScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (super.isRedeclaredInScope(...arguments)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return (\n        !scope.declareFunctions.includes(name) &&\n        (scope.lexical.includes(name) || scope.functions.includes(name))\n      );\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    if (this.scopeStack[0].declareFunctions.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n","// @flow\n\n/*:: declare var invariant; */\n\n// Error messages are colocated with the plugin.\n/* eslint-disable @babel/development-internal/dry-error-messages */\n\nimport type Parser from \"../../parser\";\nimport { types as tt, type TokenType } from \"../../tokenizer/types\";\nimport * as N from \"../../types\";\nimport type { Pos, Position } from \"../../util/location\";\nimport type State from \"../../tokenizer/state\";\nimport { types as tc } from \"../../tokenizer/context\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart, isKeyword } from \"../../util/identifier\";\nimport FlowScopeHandler from \"./scope\";\nimport {\n  type BindingTypes,\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  BIND_FLOW_DECLARE_FN,\n  SCOPE_ARROW,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n} from \"../../util/scopeflags\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { Errors } from \"../../parser/error\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = Object.freeze({\n  AmbiguousConditionalArrow:\n    \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind:\n    \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n  AssignReservedType: \"Cannot overwrite reserved type %0\",\n  DeclareClassElement:\n    \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer:\n    \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n  EnumBooleanMemberNotInitialized:\n    \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName:\n    \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues:\n    \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType:\n    \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied:\n    \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType:\n    \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType:\n    \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType:\n    \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName:\n    \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized:\n    \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized:\n    \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportTypeShorthandOnlyInPureImport:\n    \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n  InexactInsideExact:\n    \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n  InexactInsideNonObject:\n    \"Explicit inexact syntax cannot appear in class or interface definitions\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance\",\n  InvalidNonTypeImportInDeclareModule:\n    \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n  MissingTypeParamDefault:\n    \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule:\n    \"`declare module` cannot be used inside another `declare module`\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n  OptionalBindingPattern:\n    \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance\",\n  ThisParamAnnotationRequired:\n    \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor:\n    \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst:\n    \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  TypeCastInPattern:\n    \"The type cast expression is expected to be wrapped with parenthesis\",\n  UnexpectedExplicitInexactInObject:\n    \"Explicit inexact syntax must appear at the end of an inexact object\",\n  UnexpectedReservedType: \"Unexpected reserved type %0\",\n  UnexpectedReservedUnderscore:\n    \"`_` is only allowed as a type argument to call or new\",\n  UnexpectedSpaceBetweenModuloChecks:\n    \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType:\n    \"Spread operator cannot appear in class or interface definitions\",\n  UnexpectedSubtractionOperand:\n    'Unexpected token, expected \"number\" or \"bigint\"',\n  UnexpectedTokenAfterTypeParameter:\n    \"Expected an arrow function after this type parameter declaration\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction:\n    \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n  UnsupportedDeclareExportKind:\n    \"`declare export %0` is not supported. Use `%1` instead\",\n  UnsupportedStatementInDeclareModule:\n    \"Only declares and type imports are allowed inside declare module\",\n  UnterminatedFlowComment: \"Unterminated flow-comment\",\n});\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(node: N.Node): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state: State): boolean {\n  return (\n    (state.type === tt.name || !!state.type.keyword) && state.value !== \"from\"\n  );\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (T, number, T[]) => ?boolean,\n): [T[], T[]] {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\ntype EnumContext = {|\n  enumName: string,\n  explicitType: EnumExplicitType,\n  memberName: string,\n|};\ntype EnumMemberInit =\n  | {| type: \"number\", pos: number, value: N.Node |}\n  | {| type: \"string\", pos: number, value: N.Node |}\n  | {| type: \"boolean\", pos: number, value: N.Node |}\n  | {| type: \"invalid\", pos: number |}\n  | {| type: \"none\", pos: number |};\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): Class<FlowScopeHandler> {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums(): boolean {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      return super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      return super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowType {\n      const node = this.startNode();\n      const moduloLoc = this.state.startLoc;\n      const moduloPos = this.state.start;\n      this.expect(tt.modulo);\n      const checksLoc = this.state.startLoc;\n      this.expectContextual(\"checks\");\n      // Force '%' and 'checks' to be adjacent\n      if (\n        moduloLoc.line !== checksLoc.line ||\n        moduloLoc.column !== checksLoc.column - 1\n      ) {\n        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = this.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [?N.FlowType, ?N.FlowPredicate] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(node: N.FlowDeclareClass): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: N.FlowDeclareFunction,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode();\n\n      if (this.isRelational(\"<\")) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [\n        // $FlowFixMe (destructuring not supported yet)\n        typeNode.returnType,\n        // $FlowFixMe (destructuring not supported yet)\n        node.predicate,\n      ] = this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: N.FlowDeclare,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(\"module\")) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(\"type\")) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(\"opaque\")) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(\"interface\")) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: N.FlowDeclareVariable,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(node: N.FlowDeclareModule): N.FlowDeclareModule {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode());\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(\"type\") && !this.match(tt._typeof)) {\n            this.raise(\n              this.state.lastTokStart,\n              FlowErrors.InvalidNonTypeImportInDeclareModule,\n            );\n          }\n          this.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            \"declare\",\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(\n              bodyElement.start,\n              FlowErrors.AmbiguousDeclareModuleKind,\n            );\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(\n              bodyElement.start,\n              FlowErrors.DuplicateDeclareModuleExports,\n            );\n          }\n          if (kind === \"ES\") {\n            this.raise(\n              bodyElement.start,\n              FlowErrors.AmbiguousDeclareModuleKind,\n            );\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: N.FlowDeclareExportDeclaration,\n      insideModule: ?boolean,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(\"type\") || this.isContextual(\"interface\")) &&\n            !insideModule)\n        ) {\n          const label = this.state.value;\n          const suggestion = exportSuggestions[label];\n\n          throw this.raise(\n            this.state.start,\n            FlowErrors.UnsupportedDeclareExportKind,\n            label,\n            suggestion,\n          );\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(\"opaque\") // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(\"interface\") || // declare export interface ...\n          this.isContextual(\"type\") || // declare export type ...\n          this.isContextual(\"opaque\") // declare export opaque type ...\n        ) {\n          node = this.parseExport(node);\n          if (node.type === \"ExportNamedDeclaration\") {\n            // flow does not support the ExportNamedDeclaration\n            // $FlowIgnore\n            node.type = \"ExportDeclaration\";\n            // $FlowFixMe\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          // $FlowIgnore\n          node.type = \"Declare\" + node.type;\n\n          return node;\n        }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: N.FlowDeclareModuleExports,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(\"exports\");\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: N.FlowDeclareTypeAlias,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      this.flowParseTypeAlias(node);\n      // Don't do finishNode as we don't want to process comments twice\n      node.type = \"DeclareTypeAlias\";\n      return node;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: N.FlowDeclareOpaqueType,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      this.flowParseOpaqueType(node, true);\n      // Don't do finishNode as we don't want to process comments twice\n      node.type = \"DeclareOpaqueType\";\n      return node;\n    }\n\n    flowParseDeclareInterface(\n      node: N.FlowDeclareInterface,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(\n      node: N.FlowDeclare,\n      isClass?: boolean = false,\n    ): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BIND_FUNCTION : BIND_LEXICAL,\n        node.id.start,\n      );\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.implements = [];\n      node.mixins = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (this.isContextual(\"mixins\")) {\n        this.next();\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: N.FlowInterface): N.FlowInterface {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n      }\n    }\n\n    checkReservedType(word: string, startLoc: number, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        startLoc,\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        word,\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(this.state.value, this.state.start, declaration);\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: N.FlowTypeAlias): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: N.FlowOpaqueType,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(\"type\");\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault?: boolean = false): N.TypeParameter {\n      const nodeStart = this.state.start;\n\n      const node = this.startNode();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      node.variance = variance;\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.isRelational(\"<\") || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.isRelational(\">\")) {\n          this.expect(tt.comma);\n        }\n      } while (!this.isRelational(\">\"));\n      this.expectRelational(\">\");\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expectRelational(\"<\");\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseType());\n        if (!this.isRelational(\">\")) {\n          this.expect(tt.comma);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expectRelational(\">\");\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expectRelational(\"<\");\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.isRelational(\">\")) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expectRelational(\">\");\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode();\n      this.expectContextual(\"interface\");\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? this.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: N.FlowObjectTypeIndexer,\n      isStatic: boolean,\n      variance: ?N.FlowVariance,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: N.FlowObjectTypeInternalSlot,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.isRelational(\"<\") || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.start, node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: N.FlowFunctionTypeAnnotation,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: N.FlowObjectTypeCallProperty,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean,\n      allowExact: boolean,\n      allowSpread: boolean,\n      allowProto: boolean,\n      allowInexact: boolean,\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStart: ?number = null;\n        let inexactStart: ?number = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(\"proto\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStart = this.state.start;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(\"static\")) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.isRelational(\"<\")) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n            const lookahead = this.lookahead();\n            if (\n              lookahead.type === tt.name ||\n              lookahead.type === tt.string ||\n              lookahead.type === tt.num\n            ) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStart,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStart = this.state.lastTokStart;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStart &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(\n            inexactStart,\n            FlowErrors.UnexpectedExplicitInexactInObject,\n          );\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,\n      isStatic: boolean,\n      protoStart: ?number,\n      variance: ?N.FlowVariance,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): (N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty) | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(\n              this.state.lastTokStart,\n              FlowErrors.InexactInsideNonObject,\n            );\n          } else if (!allowInexact) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n          }\n          if (variance) {\n            this.raise(variance.start, FlowErrors.InexactVariance);\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n        }\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n        if (variance) {\n          this.raise(variance.start, FlowErrors.SpreadVariance);\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStart != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.isRelational(\"<\") || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.start, node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(\n              node.value.this.start,\n              FlowErrors.ThisParamBannedInConstructor,\n            );\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const start = property.start;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.value.this.start,\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n        );\n      }\n\n      if (length !== paramCount) {\n        if (property.kind === \"get\") {\n          this.raise(start, Errors.BadGetterArity);\n        } else {\n          this.raise(start, Errors.BadSetterArity);\n        }\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(start, Errors.BadSetterRestParameter);\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startPos?: number,\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      let node = id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt(startPos, startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startPos: number,\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt(startPos, startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(node.start, FlowErrors.ThisParamMustBeFirst);\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(\n      params: N.FlowFunctionTypeParam[] = [],\n    ): {\n      params: N.FlowFunctionTypeParam[],\n      rest: ?N.FlowFunctionTypeParam,\n      _this: ?N.FlowFunctionTypeParam,\n    } {\n      let rest: ?N.FlowFunctionTypeParam = null;\n      let _this: ?N.FlowFunctionTypeParam = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startPos: number,\n      startLoc: Position,\n      node: N.FlowTypeAnnotation,\n      id: N.Identifier,\n    ): N.FlowTypeAnnotation {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.name:\n          if (this.isContextual(\"interface\")) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(\n            startPos,\n            startLoc,\n            node,\n            this.parseIdentifier(),\n          );\n\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.relational:\n          if (this.state.value === \"<\") {\n            node.typeParameters = this.flowParseTypeParameterDeclaration();\n            this.expect(tt.parenL);\n            tmp = this.flowParseFunctionTypeParams();\n            node.params = tmp.params;\n            node.rest = tmp.rest;\n            node.this = tmp._this;\n            this.expect(tt.parenR);\n\n            this.expect(tt.arrow);\n\n            node.returnType = this.flowParseType();\n\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\n          }\n          break;\n\n        case tt.parenL:\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (this.match(tt.name) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.string:\n          return this.parseLiteral(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteral(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node.start,\n                node.loc.start,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteral(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node.start,\n                node.loc.start,\n              );\n            }\n\n            throw this.raise(\n              this.state.start,\n              FlowErrors.UnexpectedSubtractionOperand,\n            );\n          }\n\n          throw this.unexpected();\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        default:\n          if (this.state.type.keyword === \"typeof\") {\n            return this.flowParseTypeofType();\n          } else if (this.state.type.keyword) {\n            const label = this.state.type.label;\n            this.next();\n            return super.createIdentifier(node, label);\n          }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowTypeAnnotation {\n      const startPos = this.state.start,\n        startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      while (this.match(tt.bracketL) && !this.canInsertSemicolon()) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.elementType = type;\n        this.expect(tt.bracketL);\n        this.expect(tt.bracketR);\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      // Ensure that a brace after a function generic type annotation is a\n      // statement, except in arrow functions (noAnonFunctionType)\n      this.state.exprAllowed =\n        this.state.exprAllowed || this.state.noAnonFunctionType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startPos, startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.Node): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(\n        node.expression,\n        node.typeAnnotation.end,\n        node.typeAnnotation.loc.end,\n      );\n\n      return node.expression;\n    }\n\n    flowParseVariance(): ?N.FlowVariance {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody: ?boolean,\n      isMethod?: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n      }\n\n      return super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish(\n      node: N.BodilessFunctionOrMethodBase,\n      type: string,\n      isMethod?: boolean = false,\n    ): void {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode();\n\n        [\n          // $FlowFixMe (destructuring not supported yet)\n          typeNode.typeAnnotation,\n          // $FlowFixMe (destructuring not supported yet)\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatement(context: ?string, topLevel?: boolean): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (\n        this.state.strict &&\n        this.match(tt.name) &&\n        this.state.value === \"interface\"\n      ) {\n        const lookahead = this.lookahead();\n        if (lookahead.type === tt.name || isKeyword(lookahead.value)) {\n          const node = this.startNode();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatement(context, topLevel);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            this.match(tt.name) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(tt.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      return (\n        this.isContextual(\"type\") ||\n        this.isContextual(\"interface\") ||\n        this.isContextual(\"opaque\") ||\n        (this.shouldParseEnums() && this.isContextual(\"enum\")) ||\n        super.shouldParseExportDeclaration()\n      );\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (\n        this.match(tt.name) &&\n        (this.state.value === \"type\" ||\n          this.state.value === \"interface\" ||\n          this.state.value === \"opaque\" ||\n          (this.shouldParseEnums() && this.state.value === \"enum\"))\n      ) {\n        return false;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      refNeedsArrowPos?: ?Pos,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      // only use the expensive \"tryParse\" method if there is a question mark\n      // and if we come from inside parens\n      if (refNeedsArrowPos) {\n        const result = this.tryParse(() =>\n          super.parseConditional(expr, startPos, startLoc),\n        );\n\n        if (!result.node) {\n          // $FlowIgnore\n          refNeedsArrowPos.start = result.error.pos || this.state.start;\n          return expr;\n        }\n\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startPos, startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression,\n      failed: boolean,\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            this.finishArrowValidation(node);\n          } else {\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        ((node.params: any): N.Expression[]),\n        node.extra?.trailingComma,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(node: N.Node, parse: () => T): T {\n      let result: T;\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(\n      node: N.Expression,\n      startPos: number,\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startPos, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(node: N.Node): N.AnyExport {\n      const decl = super.parseExport(node);\n      if (\n        decl.type === \"ExportNamedDeclaration\" ||\n        decl.type === \"ExportAllDeclaration\"\n      ) {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n      return decl;\n    }\n\n    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node: N.Node): boolean {\n      if (super.eatExportStar(...arguments)) return true;\n\n      if (this.isContextual(\"type\") && this.lookahead().type === tt.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n      const pos = this.state.start;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(pos);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(node: N.Class, isStatement: boolean, optionalId: ?boolean) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const pos = this.state.start;\n      if (this.isContextual(\"declare\")) {\n        if (this.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(pos, FlowErrors.DeclareClassElement);\n        } else if (member.value) {\n          this.raise(\n            member.value.start,\n            FlowErrors.DeclareClassFieldInitializer,\n          );\n        }\n      }\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        return this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        return this.finishOp(tt.relational, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        // allow double nullable types in Flow: ??string\n        return this.finishOp(tt.question, 1);\n      } else if (isIteratorStart(code, next)) {\n        this.state.isIterator = true;\n        return super.readWord();\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          return true;\n\n        case \"ObjectExpression\": {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return (\n              prop.type !== \"ObjectMethod\" &&\n              (i === last || prop.type === \"SpreadElement\") &&\n              this.isAssignable(prop)\n            );\n          });\n        }\n\n        case \"ObjectProperty\":\n          return this.isAssignable(node.value);\n\n        case \"SpreadElement\":\n          return this.isAssignable(node.argument);\n\n        case \"ArrayExpression\":\n          return node.elements.every(element => this.isAssignable(element));\n\n        case \"AssignmentExpression\":\n          return node.operator === \"=\";\n\n        case \"ParenthesizedExpression\":\n        case \"TypeCastExpression\":\n          return this.isAssignable(node.expression);\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return !isBinding;\n\n        default:\n          return false;\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): N.Node {\n      if (node.type === \"TypeCastExpression\") {\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n      } else {\n        return super.toAssignable(node, isLHS);\n      }\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaPos?: ?number,\n      isLHS: boolean,\n    ): $ReadOnlyArray<N.Pattern> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      return super.toAssignableList(exprList, trailingCommaPos, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList: $ReadOnlyArray<?N.Expression>,\n      isParenthesizedExpr?: boolean,\n    ): $ReadOnlyArray<?N.Expression> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors: ?ExpressionErrors,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    checkLVal(\n      expr: N.Expression,\n      ...args:\n        | [string, BindingTypes | void]\n        | [\n            string,\n            BindingTypes | void,\n            ?Set<string>,\n            boolean | void,\n            boolean | void,\n          ]\n    ): void {\n      if (expr.type !== \"TypeCastExpression\") {\n        return super.checkLVal(expr, ...args);\n      }\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.isRelational(\"<\") || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // determine whether a parameter is a this param\n    isThisParam(param) {\n      return param.type === \"Identifier\" && param.name === \"this\";\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method: $FlowFixMe).variance) {\n        this.unexpected((method: $FlowFixMe).variance.start);\n      }\n      delete (method: $FlowFixMe).variance;\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);\n        }\n        // estree support\n      } else if (\n        // $FlowFixMe flow does not know about the face that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        method.value.params\n      ) {\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method: $FlowFixMe).variance) {\n        this.unexpected((method: $FlowFixMe).variance.start);\n      }\n      delete (method: $FlowFixMe).variance;\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.isRelational(\"<\")) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);\n        } else if (this.isThisParam(param)) {\n          this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);\n        }\n      }\n    }\n\n    parsePropertyName(\n      node: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,\n      isPrivateNameAllowed: boolean,\n    ): N.Identifier {\n      const variance = this.flowParseVariance();\n      const key = super.parsePropertyName(node, isPrivateNameAllowed);\n      // $FlowIgnore (\"variance\" not defined on TsNamedTypeElementBase)\n      node.variance = variance;\n      return key;\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue(\n      prop: N.ObjectMember,\n      startPos: ?number,\n      startLoc: ?Position,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors: ?ExpressionErrors,\n    ): void {\n      if ((prop: $FlowFixMe).variance) {\n        this.unexpected((prop: $FlowFixMe).variance.start);\n      }\n      delete (prop: $FlowFixMe).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.isRelational(\"<\") && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      super.parseObjPropValue(\n        prop,\n        startPos,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    }\n\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(param.start, FlowErrors.OptionalBindingPattern);\n        }\n        if (this.isThisParam(param)) {\n          this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);\n        }\n\n        ((param: any): N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(param.start, FlowErrors.ThisParamNoDefault);\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startPos?: ?number,\n      startLoc?: ?Position,\n      left?: ?N.Pattern,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state);\n    }\n\n    parseImportSpecifierLocal(\n      node: N.ImportDeclaration,\n      specifier: N.Node,\n      type: string,\n      contextDescription: string,\n    ): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, type));\n    }\n\n    // parse typeof and type imports\n    maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\n      node.importKind = \"value\";\n\n      let kind = null;\n      if (this.match(tt._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n      if (kind) {\n        const lh = this.lookahead();\n\n        // import type * is not allowed\n        if (kind === \"type\" && lh.type === tt.star) {\n          this.unexpected(lh.start);\n        }\n\n        if (\n          isMaybeDefaultImport(lh) ||\n          lh.type === tt.braceL ||\n          lh.type === tt.star\n        ) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(node: N.ImportDeclaration): void {\n      const specifier = this.startNode();\n      const firstIdentLoc = this.state.start;\n      const firstIdent = this.parseModuleExportName();\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !this.match(tt.name) &&\n          !this.state.type.keyword\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (\n        specifierTypeKind !== null &&\n        (this.match(tt.name) || this.state.type.keyword)\n      ) {\n        // `import {type foo`\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        if (firstIdent.type === \"StringLiteral\") {\n          throw this.raise(\n            specifier.start,\n            Errors.ImportBindingIsString,\n            firstIdent.value,\n          );\n        }\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      const nodeIsTypeImport = hasTypeImportKind(node);\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (nodeIsTypeImport && specifierIsTypeImport) {\n        this.raise(\n          firstIdentLoc,\n          FlowErrors.ImportTypeShorthandOnlyInPureImport,\n        );\n      }\n\n      if (nodeIsTypeImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.start,\n          true,\n          true,\n        );\n      }\n\n      this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n      // $FlowFixMe\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ?ExpressionErrors,\n      afterLeftParse?: Function,\n      refNeedsArrowPos?: ?Pos,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.isRelational(\"<\"))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () =>\n            super.parseMaybeAssign(\n              refExpressionErrors,\n              afterLeftParse,\n              refNeedsArrowPos,\n            ),\n          state,\n        );\n        /*:: invariant(!jsx.aborted) */\n\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        if (context[context.length - 1] === tc.j_oTag) {\n          context.length -= 2;\n        } else if (context[context.length - 1] === tc.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (jsx?.error || this.isRelational(\"<\")) {\n        state = state || this.state.clone();\n\n        let typeParameters;\n\n        const arrow = this.tryParse(abort => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n                refNeedsArrowPos,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {}: any);\n          if (\n            arrowExpression.type !== \"ArrowFunctionExpression\" &&\n            arrowExpression.extra?.parenthesized\n          ) {\n            abort();\n          }\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression: ?(\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n        ) = null;\n\n        if (\n          arrow.node &&\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                typeParameters.start,\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n              );\n            }\n\n            return arrow.node;\n          }\n\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(\n          typeParameters.start,\n          FlowErrors.UnexpectedTokenAfterTypeParameter,\n        );\n      }\n\n      return super.parseMaybeAssign(\n        refExpressionErrors,\n        afterLeftParse,\n        refNeedsArrowPos,\n      );\n    }\n\n    // handle return types for arrow functions\n    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode();\n\n          [\n            // $FlowFixMe (destructuring not supported yet)\n            typeNode.typeAnnotation,\n            // $FlowFixMe (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow();\n    }\n\n    setArrowFunctionParameters(\n      node: N.ArrowFunctionExpression,\n      params: N.Expression[],\n    ): void {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction: ?boolean,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);\n        }\n      }\n\n      return super.checkParams(...arguments);\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls?: ?boolean,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.indexOf(startPos) !== -1\n      ) {\n        this.next();\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.isRelational(\"<\")\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort =>\n            this.parseAsyncArrowWithTypeParameters(startPos, startLoc) ||\n            abort(),\n          state,\n        );\n\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startPos, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: ?boolean,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node: N.OptionalCallExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(tt.parenL);\n        // $FlowFixMe\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (\n        !noCalls &&\n        this.shouldParseTypes() &&\n        this.isRelational(\"<\")\n      ) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n          if (subscriptState.optionalChainMember) node.optional = false;\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n        startPos,\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewArguments(node: N.NewExpression): void {\n      let targs = null;\n      if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n\n      super.parseNewArguments(node);\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startPos: number,\n      startLoc: Position,\n    ): ?N.ArrowFunctionExpression {\n      const node = this.startNodeAt(startPos, startLoc);\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return this.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): void {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          this.unexpected(null, FlowErrors.NestedFlowComment);\n        }\n        this.hasFlowCommentCompletion();\n        this.state.pos += this.skipFlowComment();\n        this.state.hasFlowComment = true;\n        return;\n      }\n\n      if (this.state.hasFlowComment) {\n        const end = this.input.indexOf(\"*-/\", (this.state.pos += 2));\n        if (end === -1) {\n          throw this.raise(this.state.pos - 2, Errors.UnterminatedComment);\n        }\n        this.state.pos = end + 3;\n        return;\n      }\n\n      super.skipBlockComment();\n    }\n\n    skipFlowComment(): number | boolean {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(this.state.pos, Errors.UnterminatedComment);\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      this.raise(\n        pos,\n        FlowErrors.EnumBooleanMemberNotInitialized,\n        memberName,\n        enumName,\n      );\n    }\n\n    flowEnumErrorInvalidMemberName(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n      this.raise(\n        pos,\n        FlowErrors.EnumInvalidMemberName,\n        memberName,\n        suggestion,\n        enumName,\n      );\n    }\n\n    flowEnumErrorDuplicateMemberName(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n    }\n\n    flowEnumErrorInconsistentMemberValues(\n      pos: number,\n      { enumName }: { enumName: string },\n    ): void {\n      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n    }\n\n    flowEnumErrorInvalidExplicitType(\n      pos: number,\n      {\n        enumName,\n        suppliedType,\n      }: { enumName: string, suppliedType: null | string },\n    ) {\n      return this.raise(\n        pos,\n        suppliedType === null\n          ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied\n          : FlowErrors.EnumInvalidExplicitType,\n        enumName,\n        suppliedType,\n      );\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      pos: number,\n      { enumName, explicitType, memberName }: EnumContext,\n    ) {\n      let message = null;\n      switch (explicitType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n          break;\n        case \"symbol\":\n          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n          break;\n        default:\n          // null\n          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n      }\n      return this.raise(pos, message, enumName, memberName, explicitType);\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      this.raise(\n        pos,\n        FlowErrors.EnumNumberMemberNotInitialized,\n        enumName,\n        memberName,\n      );\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(\n      pos: number,\n      { enumName }: { enumName: string },\n    ): void {\n      this.raise(\n        pos,\n        FlowErrors.EnumStringMemberInconsistentlyInitailized,\n        enumName,\n      );\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startPos = this.state.start;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n          if (endOfInit()) {\n            return { type: \"number\", pos: literal.start, value: literal };\n          }\n          return { type: \"invalid\", pos: startPos };\n        }\n        case tt.string: {\n          const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n          if (endOfInit()) {\n            return { type: \"string\", pos: literal.start, value: literal };\n          }\n          return { type: \"invalid\", pos: startPos };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral();\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              pos: literal.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", pos: startPos };\n        }\n        default:\n          return { type: \"invalid\", pos: startPos };\n      }\n    }\n\n    flowEnumMemberRaw(): { id: N.Node, init: EnumMemberInit } {\n      const pos = this.state.start;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\", pos };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      pos: number,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(pos, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string,\n      explicitType: EnumExplicitType,\n    }): {|\n      members: {|\n        booleanMembers: Array<N.Node>,\n        numberMembers: Array<N.Node>,\n        stringMembers: Array<N.Node>,\n        defaultedMembers: Array<N.Node>,\n      |},\n      hasUnknownMembers: boolean,\n    |} {\n      const seenNames = new Set();\n      const members = {\n        booleanMembers: [],\n        numberMembers: [],\n        stringMembers: [],\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.flowEnumErrorInvalidMemberName(id.start, {\n            enumName,\n            memberName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.flowEnumErrorDuplicateMemberName(id.start, {\n            enumName,\n            memberName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.pos,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.pos,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      { enumName }: { enumName: string },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(\n            member.start,\n            { enumName },\n          );\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(\n            member.start,\n            { enumName },\n          );\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string,\n    }): EnumExplicitType {\n      if (this.eatContextual(\"of\")) {\n        if (!this.match(tt.name)) {\n          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: null,\n          });\n        }\n\n        const { value } = this.state;\n        this.next();\n\n        if (\n          value !== \"boolean\" &&\n          value !== \"number\" &&\n          value !== \"string\" &&\n          value !== \"symbol\"\n        ) {\n          this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: value,\n          });\n        }\n\n        return value;\n      }\n      return null;\n    }\n\n    flowEnumBody(node: N.Node, { enumName, nameLoc }): N.Node {\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.flowEnumErrorInconsistentMemberValues(nameLoc, { enumName });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(node: N.Node): N.Node {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), {\n        enumName: id.name,\n        nameLoc: id.start,\n      });\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    updateContext(prevType: TokenType): void {\n      if (\n        this.match(tt.name) &&\n        this.state.value === \"of\" &&\n        prevType === tt.name &&\n        this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ===\n          \"interface\"\n      ) {\n        this.state.exprAllowed = false;\n      } else {\n        super.updateContext(prevType);\n      }\n    }\n\n    // check if the next token is a tt.relation(\"<\")\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n","// @flow\n\nconst entities: { [name: string]: string } = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n};\nexport default entities;\n","// @flow\n\n// Error messages are colocated with the plugin.\n/* eslint-disable @babel/development-internal/dry-error-messages */\n\nimport * as charCodes from \"charcodes\";\n\nimport XHTMLEntities from \"./xhtml\";\nimport type Parser from \"../../parser\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { TokenType, types as tt } from \"../../tokenizer/types\";\nimport { TokContext, types as tc } from \"../../tokenizer/context\";\nimport * as N from \"../../types\";\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier\";\nimport type { Position } from \"../../util/location\";\nimport { isNewLine } from \"../../util/whitespace\";\nimport { Errors } from \"../../parser/error\";\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\n\n/* eslint sort-keys: \"error\" */\nconst JsxErrors = Object.freeze({\n  AttributeIsEmpty:\n    \"JSX attributes must only be assigned a non-empty expression\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n  UnexpectedSequenceExpression:\n    \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnsupportedJsxValue:\n    \"JSX value should be either an expression or a quoted JSX text\",\n  UnterminatedJsxContent: \"Unterminated JSX contents\",\n  UnwrappedAdjacentJSXElements:\n    \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\",\n});\n/* eslint-disable sort-keys */\n\n// Be aware that this file is always executed and not only when the plugin is enabled.\n// Therefore this contexts and tokens do always exist.\ntc.j_oTag = new TokContext(\"<tag\", false);\ntc.j_cTag = new TokContext(\"</tag\", false);\ntc.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\n\ntt.jsxName = new TokenType(\"jsxName\");\ntt.jsxText = new TokenType(\"jsxText\", { beforeExpr: true });\ntt.jsxTagStart = new TokenType(\"jsxTagStart\", { startsExpr: true });\ntt.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntt.jsxTagStart.updateContext = function () {\n  this.state.context.push(tc.j_expr); // treat as beginning of JSX expression\n  this.state.context.push(tc.j_oTag); // start opening tag context\n  this.state.exprAllowed = false;\n};\n\ntt.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n  if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === tc.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object: ?N.JSXElement): boolean {\n  return object\n    ? object.type === \"JSXOpeningFragment\" ||\n        object.type === \"JSXClosingFragment\"\n    : false;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\n): string {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return (\n      getQualifiedJSXName(object.object) +\n      \".\" +\n      getQualifiedJSXName(object.property)\n    );\n  }\n\n  // istanbul ignore next\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    // Reads inline JSX contents token.\n\n    jsxReadToken(): void {\n      let out = \"\";\n      let chunkStart = this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case charCodes.lessThan:\n          case charCodes.leftCurlyBrace:\n            if (this.state.pos === this.state.start) {\n              if (ch === charCodes.lessThan && this.state.exprAllowed) {\n                ++this.state.pos;\n                return this.finishToken(tt.jsxTagStart);\n              }\n              return super.getTokenFromCode(ch);\n            }\n            out += this.input.slice(chunkStart, this.state.pos);\n            return this.finishToken(tt.jsxText, out);\n\n          case charCodes.ampersand:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          case charCodes.greaterThan:\n          case charCodes.rightCurlyBrace:\n            if (process.env.BABEL_8_BREAKING) {\n              const htmlEntity =\n                ch === charCodes.rightCurlyBrace ? \"&rbrace;\" : \"&gt;\";\n              const char = this.input[this.state.pos];\n              this.raise(\n                this.state.pos,\n                `Unexpected token \\`${char}\\`. Did you mean \\`${htmlEntity}\\` or \\`{'${char}'}\\`?`,\n              );\n            }\n          /* falls through */\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n        }\n      }\n    }\n\n    jsxReadNewLine(normalizeCRLF: boolean): string {\n      const ch = this.input.charCodeAt(this.state.pos);\n      let out;\n      ++this.state.pos;\n      if (\n        ch === charCodes.carriageReturn &&\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\n      ) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n\n      return out;\n    }\n\n    jsxReadString(quote: number): void {\n      let out = \"\";\n      let chunkStart = ++this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(this.state.start, Errors.UnterminatedString);\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n        if (ch === charCodes.ampersand) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.state.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsxReadEntity(): string {\n      let str = \"\";\n      let count = 0;\n      let entity;\n      let ch = this.input[this.state.pos];\n\n      const startPos = ++this.state.pos;\n      while (this.state.pos < this.length && count++ < 10) {\n        ch = this.input[this.state.pos++];\n        if (ch === \";\") {\n          if (str[0] === \"#\") {\n            if (str[1] === \"x\") {\n              str = str.substr(2);\n              if (HEX_NUMBER.test(str)) {\n                entity = String.fromCodePoint(parseInt(str, 16));\n              }\n            } else {\n              str = str.substr(1);\n              if (DECIMAL_NUMBER.test(str)) {\n                entity = String.fromCodePoint(parseInt(str, 10));\n              }\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.state.pos = startPos;\n        return \"&\";\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can\"t contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsxReadWord(): void {\n      let ch;\n      const start = this.state.pos;\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\n      return this.finishToken(\n        tt.jsxName,\n        this.input.slice(start, this.state.pos),\n      );\n    }\n\n    // Parse next token as JSX identifier\n\n    jsxParseIdentifier(): N.JSXIdentifier {\n      const node = this.startNode();\n      if (this.match(tt.jsxName)) {\n        node.name = this.state.value;\n      } else if (this.state.type.keyword) {\n        node.name = this.state.type.keyword;\n      } else {\n        this.unexpected();\n      }\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n\n    // Parse namespaced identifier.\n\n    jsxParseNamespacedName(): N.JSXNamespacedName {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const name = this.jsxParseIdentifier();\n      if (!this.eat(tt.colon)) return name;\n\n      const node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsxParseElementName():\n      | N.JSXIdentifier\n      | N.JSXNamespacedName\n      | N.JSXMemberExpression {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let node = this.jsxParseNamespacedName();\n      if (node.type === \"JSXNamespacedName\") {\n        return node;\n      }\n      while (this.eat(tt.dot)) {\n        const newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsxParseAttributeValue(): N.Expression {\n      let node;\n      switch (this.state.type) {\n        case tt.braceL:\n          node = this.startNode();\n          this.next();\n          node = this.jsxParseExpressionContainer(node);\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            this.raise(node.start, JsxErrors.AttributeIsEmpty);\n          }\n          return node;\n\n        case tt.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\n      const node = this.startNodeAt(\n        this.state.lastTokEnd,\n        this.state.lastTokEndLoc,\n      );\n      return this.finishNodeAt(\n        node,\n        \"JSXEmptyExpression\",\n        this.state.start,\n        this.state.startLoc,\n      );\n    }\n\n    // Parse JSX spread child\n\n    jsxParseSpreadChild(node: N.JSXSpreadChild): N.JSXSpreadChild {\n      this.next(); // ellipsis\n      node.expression = this.parseExpression();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXSpreadChild\");\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsxParseExpressionContainer(\n      node: N.JSXExpressionContainer,\n    ): N.JSXExpressionContainer {\n      if (this.match(tt.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        const expression = this.parseExpression();\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            expression.type === \"SequenceExpression\" &&\n            !expression.extra?.parenthesized\n          ) {\n            this.raise(\n              expression.expressions[1].start,\n              JsxErrors.UnexpectedSequenceExpression,\n            );\n          }\n        }\n\n        node.expression = expression;\n      }\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsxParseAttribute(): N.JSXAttribute {\n      const node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssignAllowIn();\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n\n    // Parses JSX opening tag starting after \"<\".\n\n    jsxParseOpeningElementAt(\n      startPos: number,\n      startLoc: Position,\n    ): N.JSXOpeningElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      if (this.match(tt.jsxTagEnd)) {\n        this.expect(tt.jsxTagEnd);\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      return this.jsxParseOpeningElementAfterName(node);\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      const attributes: N.JSXAttribute[] = [];\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\n        attributes.push(this.jsxParseAttribute());\n      }\n      node.attributes = attributes;\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    }\n\n    // Parses JSX closing tag starting after \"</\".\n\n    jsxParseClosingElementAt(\n      startPos: number,\n      startLoc: Position,\n    ): N.JSXClosingElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      if (this.match(tt.jsxTagEnd)) {\n        this.expect(tt.jsxTagEnd);\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    }\n\n    // Parses entire JSX element, including it\"s opening tag\n    // (starting after \"<\"), attributes, contents and closing tag.\n\n    jsxParseElementAt(startPos: number, startLoc: Position): N.JSXElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      const children = [];\n      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case tt.jsxTagStart:\n              startPos = this.state.start;\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsxParseClosingElementAt(\n                  startPos,\n                  startLoc,\n                );\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startPos, startLoc));\n              break;\n\n            case tt.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL: {\n              const node = this.startNode();\n              this.next();\n              if (this.match(tt.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n            // istanbul ignore next - should never happen\n            default:\n              throw this.unexpected();\n          }\n        }\n\n        if (isFragment(openingElement) && !isFragment(closingElement)) {\n          this.raise(\n            // $FlowIgnore\n            closingElement.start,\n            JsxErrors.MissingClosingTagFragment,\n          );\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(\n            // $FlowIgnore\n            closingElement.start,\n            JsxErrors.MissingClosingTagElement,\n            getQualifiedJSXName(openingElement.name),\n          );\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (\n            // $FlowIgnore\n            getQualifiedJSXName(closingElement.name) !==\n            getQualifiedJSXName(openingElement.name)\n          ) {\n            this.raise(\n              // $FlowIgnore\n              closingElement.start,\n              JsxErrors.MissingClosingTagElement,\n              getQualifiedJSXName(openingElement.name),\n            );\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n      node.children = children;\n      if (this.isRelational(\"<\")) {\n        throw this.raise(\n          this.state.start,\n          JsxErrors.UnwrappedAdjacentJSXElements,\n        );\n      }\n\n      return isFragment(openingElement)\n        ? this.finishNode(node, \"JSXFragment\")\n        : this.finishNode(node, \"JSXElement\");\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsxParseElement(): N.JSXElement {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startPos, startLoc);\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseExprAtom(refExpressionErrors: ?ExpressionErrors): N.Expression {\n      if (this.match(tt.jsxText)) {\n        return this.parseLiteral(this.state.value, \"JSXText\");\n      } else if (this.match(tt.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else if (\n        this.isRelational(\"<\") &&\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\n      ) {\n        // In case we encounter an lt token here it will always be the start of\n        // jsx as the lt sign is not allowed in places that expect an expression\n        this.finishToken(tt.jsxTagStart);\n        return this.jsxParseElement();\n      } else {\n        return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    getTokenFromCode(code: number): void {\n      if (this.state.inPropertyName) return super.getTokenFromCode(code);\n\n      const context = this.curContext();\n\n      if (context === tc.j_expr) {\n        return this.jsxReadToken();\n      }\n\n      if (context === tc.j_oTag || context === tc.j_cTag) {\n        if (isIdentifierStart(code)) {\n          return this.jsxReadWord();\n        }\n\n        if (code === charCodes.greaterThan) {\n          ++this.state.pos;\n          return this.finishToken(tt.jsxTagEnd);\n        }\n\n        if (\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\n          context === tc.j_oTag\n        ) {\n          return this.jsxReadString(code);\n        }\n      }\n\n      if (\n        code === charCodes.lessThan &&\n        this.state.exprAllowed &&\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\n      ) {\n        ++this.state.pos;\n        return this.finishToken(tt.jsxTagStart);\n      }\n\n      return super.getTokenFromCode(code);\n    }\n\n    updateContext(prevType: TokenType): void {\n      if (this.match(tt.braceL)) {\n        const curContext = this.curContext();\n        if (curContext === tc.j_oTag) {\n          this.state.context.push(tc.braceExpression);\n        } else if (curContext === tc.j_expr) {\n          this.state.context.push(tc.templateQuasi);\n        } else {\n          super.updateContext(prevType);\n        }\n        this.state.exprAllowed = true;\n      } else if (this.match(tt.slash) && prevType === tt.jsxTagStart) {\n        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\n        this.state.context.push(tc.j_cTag); // reconsider as closing tag context\n        this.state.exprAllowed = false;\n      } else {\n        return super.updateContext(prevType);\n      }\n    }\n  };\n","// @flow\n\nimport ScopeHandler, { Scope } from \"../../util/scope\";\nimport {\n  BIND_KIND_TYPE,\n  BIND_FLAGS_TS_ENUM,\n  BIND_FLAGS_TS_CONST_ENUM,\n  BIND_FLAGS_TS_EXPORT_ONLY,\n  BIND_KIND_VALUE,\n  BIND_FLAGS_CLASS,\n  type ScopeFlags,\n  type BindingTypes,\n} from \"../../util/scopeflags\";\nimport * as N from \"../../types\";\n\nclass TypeScriptScope extends Scope {\n  types: string[] = [];\n\n  // enums (which are also in .types)\n  enums: string[] = [];\n\n  // const enums (which are also in .enums and .types)\n  constEnums: string[] = [];\n\n  // classes (which are also in .lexical) and interface (which are also in .types)\n  classes: string[] = [];\n\n  // namespaces and ambient functions (or classes) are too difficult to track,\n  // especially without type analysis.\n  // We need to track them anyway, to avoid \"X is not defined\" errors\n  // when exporting them.\n  exportOnlyBindings: string[] = [];\n}\n\n// See https://github.com/babel/babel/pull/9766#discussion_r268920730 for an\n// explanation of how typescript handles scope.\n\nexport default class TypeScriptScopeHandler extends ScopeHandler<TypeScriptScope> {\n  createScope(flags: ScopeFlags): TypeScriptScope {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        // \"Value\" bindings have already been registered by the superclass.\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n      scope.types.push(name);\n    }\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(\n    scope: TypeScriptScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        // Enums can be merged with other enums if they are both\n        //  const or both non-const.\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        // Classes can be merged with interfaces\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        // Interface can be merged with other classes or interfaces\n        return false;\n      }\n    }\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    if (\n      this.scopeStack[0].types.indexOf(id.name) === -1 &&\n      this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1\n    ) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n","// @flow\nexport const PARAM = 0b0000, // Initial Parameter flags\n  PARAM_YIELD = 0b0001, // track [Yield] production parameter\n  PARAM_AWAIT = 0b0010, // track [Await] production parameter\n  PARAM_RETURN = 0b0100, // track [Return] production parameter\n  PARAM_IN = 0b1000; // track [In] production parameter\n\n// ProductionParameterHandler is a stack fashioned production parameter tracker\n// https://tc39.es/ecma262/#sec-grammar-notation\n// The tracked parameters are defined above.\n//\n// Whenever [+Await]/[+Yield] appears in the right-hand sides of a production,\n// we must enter a new tracking stack. For example when parsing\n//\n// AsyncFunctionDeclaration [Yield, Await]:\n//   async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await]\n//     ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }\n//\n// we must follow such process:\n//\n// 1. parse async keyword\n// 2. parse function keyword\n// 3. parse bindingIdentifier <= inherit current parameters: [?Await]\n// 4. enter new stack with (PARAM_AWAIT)\n// 5. parse formal parameters <= must have [Await] parameter [+Await]\n// 6. parse function body\n// 7. exit current stack\n\nexport type ParamKind =\n  | typeof PARAM\n  | typeof PARAM_AWAIT\n  | typeof PARAM_IN\n  | typeof PARAM_RETURN\n  | typeof PARAM_YIELD;\n\nexport default class ProductionParameterHandler {\n  stacks: Array<ParamKind> = [];\n  enter(flags: ParamKind) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags(): ParamKind {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait(): boolean {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield(): boolean {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn(): boolean {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn(): boolean {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n}\n\nexport function functionFlags(\n  isAsync: boolean,\n  isGenerator: boolean,\n): ParamKind {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n","// @flow\n\n/*:: declare var invariant; */\n\n// Error messages are colocated with the plugin.\n/* eslint-disable @babel/development-internal/dry-error-messages */\n\nimport type { TokenType } from \"../../tokenizer/types\";\nimport type State from \"../../tokenizer/state\";\nimport { types as tt } from \"../../tokenizer/types\";\nimport { types as ct } from \"../../tokenizer/context\";\nimport * as N from \"../../types\";\nimport type { Pos, Position } from \"../../util/location\";\nimport type Parser from \"../../parser\";\nimport {\n  type BindingTypes,\n  SCOPE_TS_MODULE,\n  SCOPE_OTHER,\n  BIND_TS_ENUM,\n  BIND_TS_CONST_ENUM,\n  BIND_TS_TYPE,\n  BIND_TS_INTERFACE,\n  BIND_TS_AMBIENT,\n  BIND_TS_NAMESPACE,\n  BIND_CLASS,\n  BIND_LEXICAL,\n} from \"../../util/scopeflags\";\nimport TypeScriptScopeHandler from \"./scope\";\nimport * as charCodes from \"charcodes\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { PARAM } from \"../../util/production-parameter\";\nimport { Errors } from \"../../parser/error\";\n\ntype TsModifier =\n  | \"readonly\"\n  | \"abstract\"\n  | \"declare\"\n  | \"static\"\n  | N.Accessibility;\n\nfunction nonNull<T>(x: ?T): T {\n  if (x == null) {\n    // $FlowIgnore\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\n\nfunction assert(x: boolean): void {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\ntype ParsingContext =\n  | \"EnumMembers\"\n  | \"HeritageClauseElement\"\n  | \"TupleElementTypes\"\n  | \"TypeMembers\"\n  | \"TypeParametersOrArguments\";\n\n/* eslint sort-keys: \"error\" */\nconst TSErrors = Object.freeze({\n  AbstractMethodHasImplementation:\n    \"Method '%0' cannot have an implementation because it is marked abstract.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n  ConstructorHasTypeParameters:\n    \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareClassFieldHasInitializer:\n    \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation:\n    \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: \"Accessibility modifier already seen.\",\n  DuplicateModifier: \"Duplicate modifier: '%0'\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare:\n    \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'\",\n  IndexSignatureHasAbstract:\n    \"Index signatures cannot have the 'abstract' modifier\",\n  IndexSignatureHasAccessibility:\n    \"Index signatures cannot have an accessibility modifier ('%0')\",\n  IndexSignatureHasDeclare:\n    \"Index signatures cannot have the 'declare' modifier\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n  InvalidModifierOnTypeMember: \"'%0' modifier cannot appear on a type member.\",\n  InvalidTupleMemberLabel:\n    \"Tuple members must be labeled with a simple identifier.\",\n  MixedLabeledAndUnlabeledElements:\n    \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod:\n    \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer:\n    \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired:\n    \"A required element cannot follow an optional element.\",\n  PatternIsOptional:\n    \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract:\n    \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility:\n    \"Private elements cannot have an accessibility modifier ('%0')\",\n  ReadonlyForMethodSignature:\n    \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  TypeAnnotationAfterAssign:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  UnexpectedParameterModifier:\n    \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly:\n    \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument:\n    \"Argument in a type import must be a string literal\",\n  UnsupportedParameterPropertyKind:\n    \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind:\n    \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\",\n});\n/* eslint-disable sort-keys */\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\n// It also doesn't handle \"intrinsic\", since usually it's not a keyword.\nfunction keywordTypeFromName(\n  value: string,\n): N.TsKeywordTypeType | typeof undefined {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier: string): boolean %checks {\n  return (\n    modifier === \"private\" || modifier === \"public\" || modifier === \"protected\"\n  );\n}\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    getScopeHandler(): Class<TypeScriptScopeHandler> {\n      return TypeScriptScopeHandler;\n    }\n\n    tsIsIdentifier(): boolean {\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n      // See https://github.com/Microsoft/TypeScript/issues/15008\n      return this.match(tt.name);\n    }\n\n    tsNextTokenCanFollowModifier() {\n      // Note: TypeScript's implementation is much more complicated because\n      // more things are considered modifiers there.\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\n      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n      this.next();\n      return (\n        (this.match(tt.bracketL) ||\n          this.match(tt.braceL) ||\n          this.match(tt.star) ||\n          this.match(tt.ellipsis) ||\n          this.match(tt.hash) ||\n          this.isLiteralPropertyName()) &&\n        !this.hasPrecedingLineBreak()\n      );\n    }\n\n    /** Parses a modifier matching one the given modifier names. */\n    tsParseModifier<T: TsModifier>(allowedModifiers: T[]): ?T {\n      if (!this.match(tt.name)) {\n        return undefined;\n      }\n\n      const modifier = this.state.value;\n      if (\n        allowedModifiers.indexOf(modifier) !== -1 &&\n        this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))\n      ) {\n        return modifier;\n      }\n      return undefined;\n    }\n\n    /** Parses a list of modifiers, in any order.\n     *  If you need a specific order, you must call this function multiple times:\n     *    this.tsParseModifiers(node, [\"public\"]);\n     *    this.tsParseModifiers(node, [\"abstract\", \"readonly\"]);\n     */\n    tsParseModifiers(\n      modified: {\n        [key: TsModifier]: ?true,\n        accessibility?: N.Accessibility,\n      },\n      allowedModifiers: TsModifier[],\n      disallowedModifiers?: TsModifier[],\n      errorTemplate?: string,\n    ): void {\n      for (;;) {\n        const startPos = this.state.start;\n        const modifier: ?TsModifier = this.tsParseModifier(\n          allowedModifiers.concat(disallowedModifiers ?? []),\n        );\n\n        if (!modifier) break;\n\n        if (tsIsAccessModifier(modifier)) {\n          if (modified.accessibility) {\n            this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);\n          } else {\n            modified.accessibility = modifier;\n          }\n        } else {\n          if (Object.hasOwnProperty.call(modified, modifier)) {\n            this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n          }\n          modified[modifier] = true;\n        }\n\n        if (disallowedModifiers?.includes(modifier)) {\n          this.raise(\n            startPos,\n            // $FlowIgnore\n            errorTemplate,\n            modifier,\n          );\n        }\n      }\n    }\n\n    tsIsListTerminator(kind: ParsingContext): boolean {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(tt.braceR);\n        case \"HeritageClauseElement\":\n          return this.match(tt.braceL);\n        case \"TupleElementTypes\":\n          return this.match(tt.bracketR);\n        case \"TypeParametersOrArguments\":\n          return this.isRelational(\">\");\n      }\n\n      throw new Error(\"Unreachable\");\n    }\n\n    tsParseList<T: N.Node>(kind: ParsingContext, parseElement: () => T): T[] {\n      const result: T[] = [];\n      while (!this.tsIsListTerminator(kind)) {\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n        result.push(parseElement());\n      }\n      return result;\n    }\n\n    tsParseDelimitedList<T: N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n    ): T[] {\n      return nonNull(\n        this.tsParseDelimitedListWorker(\n          kind,\n          parseElement,\n          /* expectSuccess */ true,\n        ),\n      );\n    }\n\n    /**\n     * If !expectSuccess, returns undefined instead of failing to parse.\n     * If expectSuccess, parseElement should always return a defined value.\n     */\n    tsParseDelimitedListWorker<T: N.Node>(\n      kind: ParsingContext,\n      parseElement: () => ?T,\n      expectSuccess: boolean,\n    ): ?(T[]) {\n      const result = [];\n\n      for (;;) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        const element = parseElement();\n        if (element == null) {\n          return undefined;\n        }\n        result.push(element);\n\n        if (this.eat(tt.comma)) {\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          // This will fail with an error about a missing comma\n          this.expect(tt.comma);\n        }\n        return undefined;\n      }\n\n      return result;\n    }\n\n    tsParseBracketedList<T: N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      bracket: boolean,\n      skipFirstToken: boolean,\n    ): T[] {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(tt.bracketL);\n        } else {\n          this.expectRelational(\"<\");\n        }\n      }\n\n      const result = this.tsParseDelimitedList(kind, parseElement);\n\n      if (bracket) {\n        this.expect(tt.bracketR);\n      } else {\n        this.expectRelational(\">\");\n      }\n\n      return result;\n    }\n\n    tsParseImportType(): N.TsImportType {\n      const node: N.TsImportType = this.startNode();\n      this.expect(tt._import);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n      }\n\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.argument = this.parseExprAtom();\n      this.expect(tt.parenR);\n\n      if (this.eat(tt.dot)) {\n        node.qualifier = this.tsParseEntityName(/* allowReservedWords */ true);\n      }\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSImportType\");\n    }\n\n    tsParseEntityName(allowReservedWords: boolean): N.TsEntityName {\n      let entity: N.TsEntityName = this.parseIdentifier();\n      while (this.eat(tt.dot)) {\n        const node: N.TsQualifiedName = this.startNodeAtNode(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(allowReservedWords);\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n      return entity;\n    }\n\n    tsParseTypeReference(): N.TsTypeReference {\n      const node: N.TsTypeReference = this.startNode();\n      node.typeName = this.tsParseEntityName(/* allowReservedWords */ false);\n      if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeReference\");\n    }\n\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\n      this.next();\n      const node: N.TsTypePredicate = this.startNodeAtNode(lhs);\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\n      node.asserts = false;\n      return this.finishNode(node, \"TSTypePredicate\");\n    }\n\n    tsParseThisTypeNode(): N.TsThisType {\n      const node: N.TsThisType = this.startNode();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    }\n\n    tsParseTypeQuery(): N.TsTypeQuery {\n      const node: N.TsTypeQuery = this.startNode();\n      this.expect(tt._typeof);\n      if (this.match(tt._import)) {\n        node.exprName = this.tsParseImportType();\n      } else {\n        node.exprName = this.tsParseEntityName(/* allowReservedWords */ true);\n      }\n      return this.finishNode(node, \"TSTypeQuery\");\n    }\n\n    tsParseTypeParameter(): N.TsTypeParameter {\n      const node: N.TsTypeParameter = this.startNode();\n      node.name = this.parseIdentifierName(node.start);\n      node.constraint = this.tsEatThenParseType(tt._extends);\n      node.default = this.tsEatThenParseType(tt.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsTryParseTypeParameters(): ?N.TsTypeParameterDeclaration {\n      if (this.isRelational(\"<\")) {\n        return this.tsParseTypeParameters();\n      }\n    }\n\n    tsParseTypeParameters() {\n      const node: N.TsTypeParameterDeclaration = this.startNode();\n\n      if (this.isRelational(\"<\") || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      node.params = this.tsParseBracketedList(\n        \"TypeParametersOrArguments\",\n        this.tsParseTypeParameter.bind(this),\n        /* bracket */ false,\n        /* skipFirstToken */ true,\n      );\n      if (node.params.length === 0) {\n        this.raise(node.start, TSErrors.EmptyTypeParameters);\n      }\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    }\n\n    tsTryNextParseConstantContext(): ?N.TsTypeReference {\n      if (this.lookahead().type === tt._const) {\n        this.next();\n        return this.tsParseTypeReference();\n      }\n      return null;\n    }\n\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n    // but here it's always false, because this is only used for types.\n    tsFillSignature(\n      returnToken: TokenType,\n      signature: N.TsSignatureDeclaration,\n    ): void {\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n      const returnTokenRequired = returnToken === tt.arrow;\n      signature.typeParameters = this.tsTryParseTypeParameters();\n      this.expect(tt.parenL);\n      signature.parameters = this.tsParseBindingListForSignature();\n      if (returnTokenRequired) {\n        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(\n          returnToken,\n        );\n      } else if (this.match(returnToken)) {\n        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(\n          returnToken,\n        );\n      }\n    }\n\n    tsParseBindingListForSignature(): $ReadOnlyArray<\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern,\n    > {\n      return this.parseBindingList(tt.parenR, charCodes.rightParenthesis).map(\n        pattern => {\n          if (\n            pattern.type !== \"Identifier\" &&\n            pattern.type !== \"RestElement\" &&\n            pattern.type !== \"ObjectPattern\" &&\n            pattern.type !== \"ArrayPattern\"\n          ) {\n            this.raise(\n              pattern.start,\n              TSErrors.UnsupportedSignatureParameterKind,\n              pattern.type,\n            );\n          }\n          return (pattern: any);\n        },\n      );\n    }\n\n    tsParseTypeMemberSemicolon(): void {\n      if (!this.eat(tt.comma)) {\n        this.semicolon();\n      }\n    }\n\n    tsParseSignatureMember(\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\n      node: N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration,\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\n      this.tsFillSignature(tt.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    }\n\n    tsIsUnambiguouslyIndexSignature() {\n      this.next(); // Skip '{'\n      return this.eat(tt.name) && this.match(tt.colon);\n    }\n\n    tsTryParseIndexSignature(node: N.Node): ?N.TsIndexSignature {\n      if (\n        !(\n          this.match(tt.bracketL) &&\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\n        )\n      ) {\n        return undefined;\n      }\n\n      this.expect(tt.bracketL);\n      const id = this.parseIdentifier();\n      id.typeAnnotation = this.tsParseTypeAnnotation();\n      this.resetEndLocation(id); // set end position to end of type\n\n      this.expect(tt.bracketR);\n      node.parameters = [id];\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    }\n\n    tsParsePropertyOrMethodSignature(\n      node: N.TsPropertySignature | N.TsMethodSignature,\n      readonly: boolean,\n    ): N.TsPropertySignature | N.TsMethodSignature {\n      if (this.eat(tt.question)) node.optional = true;\n      const nodeAny: any = node;\n\n      if (this.match(tt.parenL) || this.isRelational(\"<\")) {\n        if (readonly) {\n          this.raise(node.start, TSErrors.ReadonlyForMethodSignature);\n        }\n        const method: N.TsMethodSignature = nodeAny;\n        this.tsFillSignature(tt.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        const property: N.TsPropertySignature = nodeAny;\n        if (readonly) property.readonly = true;\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    }\n\n    tsParseTypeMember(): N.TsTypeElement {\n      const node: any = this.startNode();\n\n      if (this.match(tt.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n      }\n\n      if (this.match(tt._new)) {\n        const id: N.Identifier = this.startNode();\n        this.next();\n        if (this.match(tt.parenL) || this.isRelational(\"<\")) {\n          return this.tsParseSignatureMember(\n            \"TSConstructSignatureDeclaration\",\n            node,\n          );\n        } else {\n          node.key = this.createIdentifier(id, \"new\");\n          return this.tsParsePropertyOrMethodSignature(node, false);\n        }\n      }\n\n      this.tsParseModifiers(\n        node,\n        [\"readonly\"],\n        [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\"],\n        TSErrors.InvalidModifierOnTypeMember,\n      );\n\n      const idx = this.tsTryParseIndexSignature(node);\n      if (idx) {\n        return idx;\n      }\n\n      this.parsePropertyName(node, /* isPrivateNameAllowed */ false);\n      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n    }\n\n    tsParseTypeLiteral(): N.TsTypeLiteral {\n      const node: N.TsTypeLiteral = this.startNode();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    }\n\n    tsParseObjectTypeMembers(): $ReadOnlyArray<N.TsTypeElement> {\n      this.expect(tt.braceL);\n      const members = this.tsParseList(\n        \"TypeMembers\",\n        this.tsParseTypeMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return members;\n    }\n\n    tsIsStartOfMappedType(): boolean {\n      this.next();\n      if (this.eat(tt.plusMin)) {\n        return this.isContextual(\"readonly\");\n      }\n      if (this.isContextual(\"readonly\")) {\n        this.next();\n      }\n      if (!this.match(tt.bracketL)) {\n        return false;\n      }\n      this.next();\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n      this.next();\n      return this.match(tt._in);\n    }\n\n    tsParseMappedTypeParameter(): N.TsTypeParameter {\n      const node: N.TsTypeParameter = this.startNode();\n      node.name = this.parseIdentifierName(node.start);\n      node.constraint = this.tsExpectThenParseType(tt._in);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsParseMappedType(): N.TsMappedType {\n      const node: N.TsMappedType = this.startNode();\n\n      this.expect(tt.braceL);\n\n      if (this.match(tt.plusMin)) {\n        node.readonly = this.state.value;\n        this.next();\n        this.expectContextual(\"readonly\");\n      } else if (this.eatContextual(\"readonly\")) {\n        node.readonly = true;\n      }\n\n      this.expect(tt.bracketL);\n      node.typeParameter = this.tsParseMappedTypeParameter();\n      node.nameType = this.eatContextual(\"as\") ? this.tsParseType() : null;\n\n      this.expect(tt.bracketR);\n\n      if (this.match(tt.plusMin)) {\n        node.optional = this.state.value;\n        this.next();\n        this.expect(tt.question);\n      } else if (this.eat(tt.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"TSMappedType\");\n    }\n\n    tsParseTupleType(): N.TsTupleType {\n      const node: N.TsTupleType = this.startNode();\n      node.elementTypes = this.tsParseBracketedList(\n        \"TupleElementTypes\",\n        this.tsParseTupleElementType.bind(this),\n        /* bracket */ true,\n        /* skipFirstToken */ false,\n      );\n\n      // Validate the elementTypes to ensure that no mandatory elements\n      // follow optional elements\n      let seenOptionalElement = false;\n      let labeledElements = null;\n      node.elementTypes.forEach(elementNode => {\n        let { type } = elementNode;\n\n        if (\n          seenOptionalElement &&\n          type !== \"TSRestType\" &&\n          type !== \"TSOptionalType\" &&\n          !(type === \"TSNamedTupleMember\" && elementNode.optional)\n        ) {\n          this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n        }\n\n        // Flow doesn't support ||=\n        seenOptionalElement =\n          seenOptionalElement ||\n          (type === \"TSNamedTupleMember\" && elementNode.optional) ||\n          type === \"TSOptionalType\";\n\n        // When checking labels, check the argument of the spread operator\n        if (type === \"TSRestType\") {\n          elementNode = elementNode.typeAnnotation;\n          type = elementNode.type;\n        }\n\n        const isLabeled = type === \"TSNamedTupleMember\";\n        // Flow doesn't support ??=\n        labeledElements = labeledElements ?? isLabeled;\n        if (labeledElements !== isLabeled) {\n          this.raise(\n            elementNode.start,\n            TSErrors.MixedLabeledAndUnlabeledElements,\n          );\n        }\n      });\n\n      return this.finishNode(node, \"TSTupleType\");\n    }\n\n    tsParseTupleElementType(): N.TsType | N.TsNamedTupleMember {\n      // parses `...TsType[]`\n\n      const { start: startPos, startLoc } = this.state;\n\n      const rest = this.eat(tt.ellipsis);\n      let type = this.tsParseType();\n      const optional = this.eat(tt.question);\n      const labeled = this.eat(tt.colon);\n\n      if (labeled) {\n        const labeledNode: N.TsNamedTupleMember = this.startNodeAtNode(type);\n        labeledNode.optional = optional;\n\n        if (\n          type.type === \"TSTypeReference\" &&\n          !type.typeParameters &&\n          type.typeName.type === \"Identifier\"\n        ) {\n          labeledNode.label = (type.typeName: N.Identifier);\n        } else {\n          this.raise(type.start, TSErrors.InvalidTupleMemberLabel);\n          // This produces an invalid AST, but at least we don't drop\n          // nodes representing the invalid source.\n          // $FlowIgnore\n          labeledNode.label = type;\n        }\n\n        labeledNode.elementType = this.tsParseType();\n        type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n      } else if (optional) {\n        const optionalTypeNode: N.TsOptionalType = this.startNodeAtNode(type);\n        optionalTypeNode.typeAnnotation = type;\n        type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n      }\n\n      if (rest) {\n        const restNode: N.TsRestType = this.startNodeAt(startPos, startLoc);\n        restNode.typeAnnotation = type;\n        type = this.finishNode(restNode, \"TSRestType\");\n      }\n\n      return type;\n    }\n\n    tsParseParenthesizedType(): N.TsParenthesizedType {\n      const node = this.startNode();\n      this.expect(tt.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    }\n\n    tsParseFunctionOrConstructorType(\n      type: \"TSFunctionType\" | \"TSConstructorType\",\n      abstract?: boolean,\n    ): N.TsFunctionOrConstructorType {\n      const node: N.TsFunctionOrConstructorType = this.startNode();\n      if (type === \"TSConstructorType\") {\n        // $FlowIgnore\n        node.abstract = !!abstract;\n        if (abstract) this.next();\n        this.next(); // eat `new`\n      }\n      this.tsFillSignature(tt.arrow, node);\n      return this.finishNode(node, type);\n    }\n\n    tsParseLiteralTypeNode(): N.TsLiteralType {\n      const node: N.TsLiteralType = this.startNode();\n      node.literal = (() => {\n        switch (this.state.type) {\n          case tt.num:\n          case tt.bigint:\n          case tt.string:\n          case tt._true:\n          case tt._false:\n            // For compatibility to estree we cannot call parseLiteral directly here\n            return this.parseExprAtom();\n          default:\n            throw this.unexpected();\n        }\n      })();\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    tsParseTemplateLiteralType(): N.TsType {\n      const node: N.TsLiteralType = this.startNode();\n      node.literal = this.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    parseTemplateSubstitution(): N.TsType {\n      if (this.state.inType) return this.tsParseType();\n      return super.parseTemplateSubstitution();\n    }\n\n    tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {\n      const thisKeyword = this.tsParseThisTypeNode();\n      if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n        return this.tsParseThisTypePredicate(thisKeyword);\n      } else {\n        return thisKeyword;\n      }\n    }\n\n    tsParseNonArrayType(): N.TsType {\n      switch (this.state.type) {\n        case tt.name:\n        case tt._void:\n        case tt._null: {\n          const type = this.match(tt._void)\n            ? \"TSVoidKeyword\"\n            : this.match(tt._null)\n            ? \"TSNullKeyword\"\n            : keywordTypeFromName(this.state.value);\n          if (\n            type !== undefined &&\n            this.lookaheadCharCode() !== charCodes.dot\n          ) {\n            const node: N.TsKeywordType = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n          return this.tsParseTypeReference();\n        }\n        case tt.string:\n        case tt.num:\n        case tt.bigint:\n        case tt._true:\n        case tt._false:\n          return this.tsParseLiteralTypeNode();\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            const node: N.TsLiteralType = this.startNode();\n            const nextToken = this.lookahead();\n            if (nextToken.type !== tt.num && nextToken.type !== tt.bigint) {\n              throw this.unexpected();\n            }\n            node.literal = this.parseMaybeUnary();\n            return this.finishNode(node, \"TSLiteralType\");\n          }\n          break;\n        case tt._this:\n          return this.tsParseThisTypeOrThisTypePredicate();\n        case tt._typeof:\n          return this.tsParseTypeQuery();\n        case tt._import:\n          return this.tsParseImportType();\n        case tt.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\n            ? this.tsParseMappedType()\n            : this.tsParseTypeLiteral();\n        case tt.bracketL:\n          return this.tsParseTupleType();\n        case tt.parenL:\n          if (process.env.BABEL_8_BREAKING) {\n            if (!this.options.createParenthesizedExpressions) {\n              const startPos = this.state.start;\n              this.next();\n              const type = this.tsParseType();\n              this.expect(tt.parenR);\n              this.addExtra(type, \"parenthesized\", true);\n              this.addExtra(type, \"parenStart\", startPos);\n              return type;\n            }\n          }\n\n          return this.tsParseParenthesizedType();\n        case tt.backQuote:\n          return this.tsParseTemplateLiteralType();\n      }\n\n      throw this.unexpected();\n    }\n\n    tsParseArrayTypeOrHigher(): N.TsType {\n      let type = this.tsParseNonArrayType();\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n        if (this.match(tt.bracketR)) {\n          const node: N.TsArrayType = this.startNodeAtNode(type);\n          node.elementType = type;\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          const node: N.TsIndexedAccessType = this.startNodeAtNode(type);\n          node.objectType = type;\n          node.indexType = this.tsParseType();\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSIndexedAccessType\");\n        }\n      }\n      return type;\n    }\n\n    tsParseTypeOperator(\n      operator: \"keyof\" | \"unique\" | \"readonly\",\n    ): N.TsTypeOperator {\n      const node: N.TsTypeOperator = this.startNode();\n      this.expectContextual(operator);\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n      if (operator === \"readonly\") {\n        this.tsCheckTypeAnnotationForReadOnly(node);\n      }\n\n      return this.finishNode(node, \"TSTypeOperator\");\n    }\n\n    tsCheckTypeAnnotationForReadOnly(node: N.Node) {\n      switch (node.typeAnnotation.type) {\n        case \"TSTupleType\":\n        case \"TSArrayType\":\n          return;\n        default:\n          this.raise(node.start, TSErrors.UnexpectedReadonly);\n      }\n    }\n\n    tsParseInferType(): N.TsInferType {\n      const node = this.startNode();\n      this.expectContextual(\"infer\");\n      const typeParameter = this.startNode();\n      typeParameter.name = this.parseIdentifierName(typeParameter.start);\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    }\n\n    tsParseTypeOperatorOrHigher(): N.TsType {\n      const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw =>\n        this.isContextual(kw),\n      );\n      return operator\n        ? this.tsParseTypeOperator(operator)\n        : this.isContextual(\"infer\")\n        ? this.tsParseInferType()\n        : this.tsParseArrayTypeOrHigher();\n    }\n\n    tsParseUnionOrIntersectionType(\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\n      parseConstituentType: () => N.TsType,\n      operator: TokenType,\n    ): N.TsType {\n      const node: N.TsUnionType | N.TsIntersectionType = this.startNode();\n      const hasLeadingOperator = this.eat(operator);\n      const types = [];\n      do {\n        types.push(parseConstituentType());\n      } while (this.eat(operator));\n      if (types.length === 1 && !hasLeadingOperator) {\n        return types[0];\n      }\n      node.types = types;\n      return this.finishNode(node, kind);\n    }\n\n    tsParseIntersectionTypeOrHigher(): N.TsType {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSIntersectionType\",\n        this.tsParseTypeOperatorOrHigher.bind(this),\n        tt.bitwiseAND,\n      );\n    }\n\n    tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSUnionType\",\n        this.tsParseIntersectionTypeOrHigher.bind(this),\n        tt.bitwiseOR,\n      );\n    }\n\n    tsIsStartOfFunctionType() {\n      if (this.isRelational(\"<\")) {\n        return true;\n      }\n      return (\n        this.match(tt.parenL) &&\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\n      );\n    }\n\n    tsSkipParameterStart(): boolean {\n      if (this.match(tt.name) || this.match(tt._this)) {\n        this.next();\n        return true;\n      }\n\n      if (this.match(tt.braceL)) {\n        let braceStackCounter = 1;\n        this.next();\n\n        while (braceStackCounter > 0) {\n          if (this.match(tt.braceL)) {\n            ++braceStackCounter;\n          } else if (this.match(tt.braceR)) {\n            --braceStackCounter;\n          }\n          this.next();\n        }\n        return true;\n      }\n\n      if (this.match(tt.bracketL)) {\n        let braceStackCounter = 1;\n        this.next();\n\n        while (braceStackCounter > 0) {\n          if (this.match(tt.bracketL)) {\n            ++braceStackCounter;\n          } else if (this.match(tt.bracketR)) {\n            --braceStackCounter;\n          }\n          this.next();\n        }\n        return true;\n      }\n\n      return false;\n    }\n\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\n      this.next();\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n        // ( )\n        // ( ...\n        return true;\n      }\n      if (this.tsSkipParameterStart()) {\n        if (\n          this.match(tt.colon) ||\n          this.match(tt.comma) ||\n          this.match(tt.question) ||\n          this.match(tt.eq)\n        ) {\n          // ( xxx :\n          // ( xxx ,\n          // ( xxx ?\n          // ( xxx =\n          return true;\n        }\n        if (this.match(tt.parenR)) {\n          this.next();\n          if (this.match(tt.arrow)) {\n            // ( xxx ) =>\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    tsParseTypeOrTypePredicateAnnotation(\n      returnToken: TokenType,\n    ): N.TsTypeAnnotation {\n      return this.tsInType(() => {\n        const t: N.TsTypeAnnotation = this.startNode();\n        this.expect(returnToken);\n\n        const node = this.startNode<N.TsTypePredicate>();\n\n        const asserts = !!this.tsTryParse(\n          this.tsParseTypePredicateAsserts.bind(this),\n        );\n\n        if (asserts && this.match(tt._this)) {\n          // When asserts is false, thisKeyword is handled by tsParseNonArrayType\n          // : asserts this is type\n          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n          // if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`\n          // : asserts this\n          if (thisTypePredicate.type === \"TSThisType\") {\n            node.parameterName = (thisTypePredicate: N.TsThisType);\n            node.asserts = true;\n            thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n          } else {\n            this.resetStartLocationFromNode(thisTypePredicate, node);\n            (thisTypePredicate: N.TsTypePredicate).asserts = true;\n          }\n          t.typeAnnotation = thisTypePredicate;\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        const typePredicateVariable =\n          this.tsIsIdentifier() &&\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          if (!asserts) {\n            // : type\n            return this.tsParseTypeAnnotation(/* eatColon */ false, t);\n          }\n\n          // : asserts foo\n          node.parameterName = this.parseIdentifier();\n          node.asserts = asserts;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        // : asserts foo is type\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      });\n    }\n\n    tsTryParseTypeOrTypePredicateAnnotation(): ?N.TsTypeAnnotation {\n      return this.match(tt.colon)\n        ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon)\n        : undefined;\n    }\n\n    tsTryParseTypeAnnotation(): ?N.TsTypeAnnotation {\n      return this.match(tt.colon) ? this.tsParseTypeAnnotation() : undefined;\n    }\n\n    tsTryParseType(): ?N.TsType {\n      return this.tsEatThenParseType(tt.colon);\n    }\n\n    tsParseTypePredicatePrefix(): ?N.Identifier {\n      const id = this.parseIdentifier();\n      if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    }\n\n    tsParseTypePredicateAsserts(): boolean {\n      if (\n        !this.match(tt.name) ||\n        this.state.value !== \"asserts\" ||\n        this.hasPrecedingLineBreak()\n      ) {\n        return false;\n      }\n      const containsEsc = this.state.containsEsc;\n      this.next();\n      if (!this.match(tt.name) && !this.match(tt._this)) {\n        return false;\n      }\n\n      if (containsEsc) {\n        this.raise(\n          this.state.lastTokStart,\n          Errors.InvalidEscapedReservedWord,\n          \"asserts\",\n        );\n      }\n\n      return true;\n    }\n\n    tsParseTypeAnnotation(\n      eatColon = true,\n      t: N.TsTypeAnnotation = this.startNode(),\n    ): N.TsTypeAnnotation {\n      this.tsInType(() => {\n        if (eatColon) this.expect(tt.colon);\n        t.typeAnnotation = this.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    }\n\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\n    tsParseType(): N.TsType {\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\n      assert(this.state.inType);\n      const type = this.tsParseNonConditionalType();\n      if (this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {\n        return type;\n      }\n      const node: N.TsConditionalType = this.startNodeAtNode(type);\n      node.checkType = type;\n      node.extendsType = this.tsParseNonConditionalType();\n      this.expect(tt.question);\n      node.trueType = this.tsParseType();\n      this.expect(tt.colon);\n      node.falseType = this.tsParseType();\n      return this.finishNode(node, \"TSConditionalType\");\n    }\n\n    isAbstractConstructorSignature(): boolean {\n      return this.isContextual(\"abstract\") && this.lookahead().type === tt._new;\n    }\n\n    tsParseNonConditionalType(): N.TsType {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n      if (this.match(tt._new)) {\n        // As in `new () => Date`\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      } else if (this.isAbstractConstructorSignature()) {\n        // As in `abstract new () => Date`\n        return this.tsParseFunctionOrConstructorType(\n          \"TSConstructorType\",\n          /* abstract */ true,\n        );\n      }\n      return this.tsParseUnionTypeOrHigher();\n    }\n\n    tsParseTypeAssertion(): N.TsTypeAssertion {\n      const node: N.TsTypeAssertion = this.startNode();\n      const _const = this.tsTryNextParseConstantContext();\n      node.typeAnnotation = _const || this.tsNextThenParseType();\n      this.expectRelational(\">\");\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    }\n\n    tsParseHeritageClause(\n      descriptor: string,\n    ): $ReadOnlyArray<N.TsExpressionWithTypeArguments> {\n      const originalStart = this.state.start;\n\n      const delimitedList = this.tsParseDelimitedList(\n        \"HeritageClauseElement\",\n        this.tsParseExpressionWithTypeArguments.bind(this),\n      );\n\n      if (!delimitedList.length) {\n        this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n      }\n\n      return delimitedList;\n    }\n\n    tsParseExpressionWithTypeArguments(): N.TsExpressionWithTypeArguments {\n      const node: N.TsExpressionWithTypeArguments = this.startNode();\n      // Note: TS uses parseLeftHandSideExpressionOrHigher,\n      // then has grammar errors later if it's not an EntityName.\n      node.expression = this.tsParseEntityName(/* allowReservedWords */ false);\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    }\n\n    tsParseInterfaceDeclaration(\n      node: N.TsInterfaceDeclaration,\n    ): N.TsInterfaceDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkLVal(\n        node.id,\n        \"typescript interface declaration\",\n        BIND_TS_INTERFACE,\n      );\n      node.typeParameters = this.tsTryParseTypeParameters();\n      if (this.eat(tt._extends)) {\n        node.extends = this.tsParseHeritageClause(\"extends\");\n      }\n      const body: N.TSInterfaceBody = this.startNode();\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    }\n\n    tsParseTypeAliasDeclaration(\n      node: N.TsTypeAliasDeclaration,\n    ): N.TsTypeAliasDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkLVal(node.id, \"typescript type alias\", BIND_TS_TYPE);\n\n      node.typeParameters = this.tsTryParseTypeParameters();\n      node.typeAnnotation = this.tsInType(() => {\n        this.expect(tt.eq);\n\n        if (\n          this.isContextual(\"intrinsic\") &&\n          this.lookahead().type !== tt.dot\n        ) {\n          const node: N.TsKeywordType = this.startNode();\n          this.next();\n          return this.finishNode(node, \"TSIntrinsicKeyword\");\n        }\n\n        return this.tsParseType();\n      });\n\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    }\n\n    tsInNoContext<T>(cb: () => T): T {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    }\n\n    /**\n     * Runs `cb` in a type context.\n     * This should be called one token *before* the first type token,\n     * so that the call to `next()` is run in type context.\n     */\n    tsInType<T>(cb: () => T): T {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    }\n\n    tsEatThenParseType(token: TokenType): N.TsType | typeof undefined {\n      return !this.match(token) ? undefined : this.tsNextThenParseType();\n    }\n\n    tsExpectThenParseType(token: TokenType): N.TsType {\n      return this.tsDoThenParseType(() => this.expect(token));\n    }\n\n    tsNextThenParseType(): N.TsType {\n      return this.tsDoThenParseType(() => this.next());\n    }\n\n    tsDoThenParseType(cb: () => void): N.TsType {\n      return this.tsInType(() => {\n        cb();\n        return this.tsParseType();\n      });\n    }\n\n    tsParseEnumMember(): N.TsEnumMember {\n      const node: N.TsEnumMember = this.startNode();\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n      node.id = this.match(tt.string)\n        ? this.parseExprAtom()\n        : this.parseIdentifier(/* liberal */ true);\n      if (this.eat(tt.eq)) {\n        node.initializer = this.parseMaybeAssignAllowIn();\n      }\n      return this.finishNode(node, \"TSEnumMember\");\n    }\n\n    tsParseEnumDeclaration(\n      node: N.TsEnumDeclaration,\n      isConst: boolean,\n    ): N.TsEnumDeclaration {\n      if (isConst) node.const = true;\n      node.id = this.parseIdentifier();\n      this.checkLVal(\n        node.id,\n        \"typescript enum declaration\",\n        isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM,\n      );\n\n      this.expect(tt.braceL);\n      node.members = this.tsParseDelimitedList(\n        \"EnumMembers\",\n        this.tsParseEnumMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    }\n\n    tsParseModuleBlock(): N.TsModuleBlock {\n      const node: N.TsModuleBlock = this.startNode();\n      this.scope.enter(SCOPE_OTHER);\n\n      this.expect(tt.braceL);\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n      this.parseBlockOrModuleBlockBody(\n        (node.body = []),\n        /* directives */ undefined,\n        /* topLevel */ true,\n        /* end */ tt.braceR,\n      );\n      this.scope.exit();\n      return this.finishNode(node, \"TSModuleBlock\");\n    }\n\n    tsParseModuleOrNamespaceDeclaration(\n      node: N.TsModuleDeclaration,\n      nested?: boolean = false,\n    ): N.TsModuleDeclaration {\n      node.id = this.parseIdentifier();\n\n      if (!nested) {\n        this.checkLVal(\n          node.id,\n          \"module or namespace declaration\",\n          BIND_TS_NAMESPACE,\n        );\n      }\n\n      if (this.eat(tt.dot)) {\n        const inner = this.startNode();\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\n        node.body = inner;\n      } else {\n        this.scope.enter(SCOPE_TS_MODULE);\n        this.prodParam.enter(PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      }\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseAmbientExternalModuleDeclaration(\n      node: N.TsModuleDeclaration,\n    ): N.TsModuleDeclaration {\n      if (this.isContextual(\"global\")) {\n        node.global = true;\n        node.id = this.parseIdentifier();\n      } else if (this.match(tt.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        this.unexpected();\n      }\n      if (this.match(tt.braceL)) {\n        this.scope.enter(SCOPE_TS_MODULE);\n        this.prodParam.enter(PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseImportEqualsDeclaration(\n      node: N.TsImportEqualsDeclaration,\n      isExport?: boolean,\n    ): N.TsImportEqualsDeclaration {\n      node.isExport = isExport || false;\n      node.id = this.parseIdentifier();\n      this.checkLVal(node.id, \"import equals declaration\", BIND_LEXICAL);\n      this.expect(tt.eq);\n      const moduleReference = this.tsParseModuleReference();\n      if (\n        node.importKind === \"type\" &&\n        moduleReference.type !== \"TSExternalModuleReference\"\n      ) {\n        this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);\n      }\n      node.moduleReference = moduleReference;\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    }\n\n    tsIsExternalModuleReference(): boolean {\n      return (\n        this.isContextual(\"require\") &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      );\n    }\n\n    tsParseModuleReference(): N.TsModuleReference {\n      return this.tsIsExternalModuleReference()\n        ? this.tsParseExternalModuleReference()\n        : this.tsParseEntityName(/* allowReservedWords */ false);\n    }\n\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\n      const node: N.TsExternalModuleReference = this.startNode();\n      this.expectContextual(\"require\");\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        throw this.unexpected();\n      }\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.expression = this.parseExprAtom();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    }\n\n    // Utilities\n\n    tsLookAhead<T>(f: () => T): T {\n      const state = this.state.clone();\n      const res = f();\n      this.state = state;\n      return res;\n    }\n\n    tsTryParseAndCatch<T: ?N.NodeBase>(f: () => T): ?T {\n      const result = this.tryParse(abort => f() || abort());\n\n      if (result.aborted || !result.node) return undefined;\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    tsTryParse<T>(f: () => ?T): ?T {\n      const state = this.state.clone();\n      const result = f();\n      if (result !== undefined && result !== false) {\n        return result;\n      } else {\n        this.state = state;\n        return undefined;\n      }\n    }\n\n    tsTryParseDeclare(nany: any): ?N.Declaration {\n      if (this.isLineTerminator()) {\n        return;\n      }\n      let starttype = this.state.type;\n      let kind;\n\n      if (this.isContextual(\"let\")) {\n        starttype = tt._var;\n        kind = \"let\";\n      }\n\n      return this.tsInDeclareContext(() => {\n        switch (starttype) {\n          case tt._function:\n            nany.declare = true;\n            return this.parseFunctionStatement(\n              nany,\n              /* async */ false,\n              /* declarationPosition */ true,\n            );\n          case tt._class:\n            // While this is also set by tsParseExpressionStatement, we need to set it\n            // before parsing the class declaration to now how to register it in the scope.\n            nany.declare = true;\n            return this.parseClass(\n              nany,\n              /* isStatement */ true,\n              /* optionalId */ false,\n            );\n          case tt._const:\n            if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n              // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n              this.expect(tt._const);\n              this.expectContextual(\"enum\");\n              return this.tsParseEnumDeclaration(nany, /* isConst */ true);\n            }\n          // falls through\n          case tt._var:\n            kind = kind || this.state.value;\n            return this.parseVarStatement(nany, kind);\n          case tt.name: {\n            const value = this.state.value;\n            if (value === \"global\") {\n              return this.tsParseAmbientExternalModuleDeclaration(nany);\n            } else {\n              return this.tsParseDeclaration(nany, value, /* next */ true);\n            }\n          }\n        }\n      });\n    }\n\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n    tsTryParseExportDeclaration(): ?N.Declaration {\n      return this.tsParseDeclaration(\n        this.startNode(),\n        this.state.value,\n        /* next */ true,\n      );\n    }\n\n    tsParseExpressionStatement(node: any, expr: N.Identifier): ?N.Declaration {\n      switch (expr.name) {\n        case \"declare\": {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n          break;\n        }\n        case \"global\":\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n          if (this.match(tt.braceL)) {\n            this.scope.enter(SCOPE_TS_MODULE);\n            this.prodParam.enter(PARAM);\n            const mod: N.TsModuleDeclaration = node;\n            mod.global = true;\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            this.scope.exit();\n            this.prodParam.exit();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n          break;\n\n        default:\n          return this.tsParseDeclaration(node, expr.name, /* next */ false);\n      }\n    }\n\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n    tsParseDeclaration(\n      node: any,\n      value: string,\n      next: boolean,\n    ): ?N.Declaration {\n      // no declaration apart from enum can be followed by a line break.\n      switch (value) {\n        case \"abstract\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            (this.match(tt._class) || this.match(tt.name))\n          ) {\n            return this.tsParseAbstractDeclaration(node);\n          }\n          break;\n\n        case \"enum\":\n          if (next || this.match(tt.name)) {\n            if (next) this.next();\n            return this.tsParseEnumDeclaration(node, /* isConst */ false);\n          }\n          break;\n\n        case \"interface\":\n          if (this.tsCheckLineTerminator(next) && this.match(tt.name)) {\n            return this.tsParseInterfaceDeclaration(node);\n          }\n          break;\n\n        case \"module\":\n          if (this.tsCheckLineTerminator(next)) {\n            if (this.match(tt.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (this.match(tt.name)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n          }\n          break;\n\n        case \"namespace\":\n          if (this.tsCheckLineTerminator(next) && this.match(tt.name)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n          break;\n\n        case \"type\":\n          if (this.tsCheckLineTerminator(next) && this.match(tt.name)) {\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n          break;\n      }\n    }\n\n    tsCheckLineTerminator(next: boolean) {\n      if (next) {\n        if (this.hasFollowingLineBreak()) return false;\n        this.next();\n        return true;\n      }\n      return !this.isLineTerminator();\n    }\n\n    tsTryParseGenericAsyncArrowFunction(\n      startPos: number,\n      startLoc: Position,\n    ): ?N.ArrowFunctionExpression {\n      if (!this.isRelational(\"<\")) {\n        return undefined;\n      }\n\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      this.state.maybeInArrowParameters = true;\n\n      const res: ?N.ArrowFunctionExpression = this.tsTryParseAndCatch(() => {\n        const node: N.ArrowFunctionExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        node.typeParameters = this.tsParseTypeParameters();\n        // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n        super.parseFunctionParams(node);\n        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n        this.expect(tt.arrow);\n        return node;\n      });\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n      if (!res) {\n        return undefined;\n      }\n\n      return this.parseArrowExpression(\n        res,\n        /* params are already set */ null,\n        /* async */ true,\n      );\n    }\n\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\n      const node = this.startNode();\n      node.params = this.tsInType(() =>\n        // Temporarily remove a JSX parsing context, which makes us scan different tokens.\n        this.tsInNoContext(() => {\n          this.expectRelational(\"<\");\n          return this.tsParseDelimitedList(\n            \"TypeParametersOrArguments\",\n            this.tsParseType.bind(this),\n          );\n        }),\n      );\n      if (node.params.length === 0) {\n        this.raise(node.start, TSErrors.EmptyTypeArguments);\n      }\n      // This reads the next token after the `>` too, so do this in the enclosing context.\n      // But be sure not to parse a regex in the jsx expression `<C<number> />`, so set exprAllowed = false\n      this.state.exprAllowed = false;\n      this.expectRelational(\">\");\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    }\n\n    tsIsDeclarationStart(): boolean {\n      if (this.match(tt.name)) {\n        switch (this.state.value) {\n          case \"abstract\":\n          case \"declare\":\n          case \"enum\":\n          case \"interface\":\n          case \"module\":\n          case \"namespace\":\n          case \"type\":\n            return true;\n        }\n      }\n\n      return false;\n    }\n\n    // ======================================================\n    // OVERRIDES\n    // ======================================================\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.tsIsDeclarationStart()) return false;\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseAssignableListItem(\n      allowModifiers: ?boolean,\n      decorators: N.Decorator[],\n    ): N.Pattern | N.TSParameterProperty {\n      // Store original location/position to include modifiers in range\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n\n      let accessibility: ?N.Accessibility;\n      let readonly = false;\n      if (allowModifiers !== undefined) {\n        accessibility = this.parseAccessModifier();\n        readonly = !!this.tsParseModifier([\"readonly\"]);\n        if (allowModifiers === false && (accessibility || readonly)) {\n          this.raise(startPos, TSErrors.UnexpectedParameterModifier);\n        }\n      }\n\n      const left = this.parseMaybeDefault();\n      this.parseAssignableListItemTypes(left);\n      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n      if (accessibility || readonly) {\n        const pp: N.TSParameterProperty = this.startNodeAt(startPos, startLoc);\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n        }\n        pp.parameter = ((elt: any): N.Identifier | N.AssignmentPattern);\n        return this.finishNode(pp, \"TSParameterProperty\");\n      }\n\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n\n      return elt;\n    }\n\n    parseFunctionBodyAndFinish(\n      node: N.BodilessFunctionOrMethodBase,\n      type: string,\n      isMethod?: boolean = false,\n    ): void {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n\n      const bodilessType =\n        type === \"FunctionDeclaration\"\n          ? \"TSDeclareFunction\"\n          : type === \"ClassMethod\"\n          ? \"TSDeclareMethod\"\n          : undefined;\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n        this.finishNode(node, bodilessType);\n        return;\n      }\n      if (bodilessType === \"TSDeclareFunction\" && this.state.isDeclareContext) {\n        this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);\n        if (\n          // $FlowIgnore\n          node.declare\n        ) {\n          super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n          return;\n        }\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    registerFunctionStatementId(node: N.Function): void {\n      if (!node.body && node.id) {\n        // Function ids are validated after parsing their body.\n        // For bodyless function, we need to do it here.\n        this.checkLVal(node.id, \"function name\", BIND_TS_AMBIENT);\n      } else {\n        super.registerFunctionStatementId(...arguments);\n      }\n    }\n\n    tsCheckForInvalidTypeCasts(items: $ReadOnlyArray<?N.Expression>) {\n      items.forEach(node => {\n        if (node?.type === \"TSTypeCastExpression\") {\n          this.raise(\n            node.typeAnnotation.start,\n            TSErrors.UnexpectedTypeAnnotation,\n          );\n        }\n      });\n    }\n\n    toReferencedList(\n      exprList: $ReadOnlyArray<?N.Expression>,\n      isInParens?: boolean, // eslint-disable-line no-unused-vars\n    ): $ReadOnlyArray<?N.Expression> {\n      // Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.\n      //\n      // Note that `f<T>(a:b)` goes through a different path and is handled\n      // in `parseSubscript` directly.\n      this.tsCheckForInvalidTypeCasts(exprList);\n      return exprList;\n    }\n\n    parseArrayLike(...args): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(...args);\n\n      if (node.type === \"ArrayExpression\") {\n        this.tsCheckForInvalidTypeCasts(node.elements);\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: ?boolean,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\n        this.state.exprAllowed = false;\n        this.next();\n\n        const nonNullExpression: N.TsNonNullExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      if (this.isRelational(\"<\")) {\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\n        // tagged template expressions. If any of them fail, walk it back and continue.\n        const result = this.tsTryParseAndCatch(() => {\n          if (!noCalls && this.atPossibleAsyncArrow(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(\n              startPos,\n              startLoc,\n            );\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          const node: N.CallExpression = this.startNodeAt(startPos, startLoc);\n          node.callee = base;\n\n          const typeArguments = this.tsParseTypeArguments();\n\n          if (typeArguments) {\n            if (!noCalls && this.eat(tt.parenL)) {\n              // possibleAsync always false here, because we would have handled it above.\n              // $FlowIgnore (won't be any undefined arguments)\n              node.arguments = this.parseCallExpressionArguments(\n                tt.parenR,\n                /* possibleAsync */ false,\n              );\n\n              // Handles invalid case: `f<T>(a:b)`\n              this.tsCheckForInvalidTypeCasts(node.arguments);\n\n              node.typeParameters = typeArguments;\n              if (state.optionalChainMember) {\n                // $FlowIgnore\n                node.optional = false;\n              }\n              return this.finishCallExpression(node, state.optionalChainMember);\n            } else if (this.match(tt.backQuote)) {\n              const result = this.parseTaggedTemplateExpression(\n                base,\n                startPos,\n                startLoc,\n                state,\n              );\n              result.typeParameters = typeArguments;\n              return result;\n            }\n          }\n\n          this.unexpected();\n        });\n\n        if (result) return result;\n      }\n\n      return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n    }\n\n    parseNewArguments(node: N.NewExpression): void {\n      if (this.isRelational(\"<\")) {\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.\n        const typeParameters = this.tsTryParseAndCatch(() => {\n          const args = this.tsParseTypeArguments();\n          if (!this.match(tt.parenL)) this.unexpected();\n          return args;\n        });\n        if (typeParameters) {\n          node.typeParameters = typeParameters;\n        }\n      }\n\n      super.parseNewArguments(node);\n    }\n\n    parseExprOp(\n      left: N.Expression,\n      leftStartPos: number,\n      leftStartLoc: Position,\n      minPrec: number,\n    ) {\n      if (\n        nonNull(tt._in.binop) > minPrec &&\n        !this.hasPrecedingLineBreak() &&\n        this.isContextual(\"as\")\n      ) {\n        const node: N.TsAsExpression = this.startNodeAt(\n          leftStartPos,\n          leftStartLoc,\n        );\n        node.expression = left;\n        const _const = this.tsTryNextParseConstantContext();\n        if (_const) {\n          node.typeAnnotation = _const;\n        } else {\n          node.typeAnnotation = this.tsNextThenParseType();\n        }\n        this.finishNode(node, \"TSAsExpression\");\n        // rescan `<`, `>` because they were scanned when this.state.inType was true\n        this.reScan_lt_gt();\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n\n      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    checkReservedWord(\n      word: string, // eslint-disable-line no-unused-vars\n      startLoc: number, // eslint-disable-line no-unused-vars\n      checkKeywords: boolean, // eslint-disable-line no-unused-vars\n      // eslint-disable-next-line no-unused-vars\n      isBinding: boolean,\n    ): void {\n      // Don't bother checking for TypeScript code.\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n    }\n\n    /*\n    Don't bother doing this check in TypeScript code because:\n    1. We may have a nested export statement with the same name:\n      export const x = 0;\n      export namespace N {\n        export const x = 1;\n      }\n    2. We have a type checker to warn us about this sort of thing.\n    */\n    checkDuplicateExports() {}\n\n    parseImport(node: N.Node): N.AnyImport {\n      node.importKind = \"value\";\n      if (this.match(tt.name) || this.match(tt.star) || this.match(tt.braceL)) {\n        let ahead = this.lookahead();\n\n        if (\n          this.isContextual(\"type\") &&\n          // import type, { a } from \"b\";\n          ahead.type !== tt.comma &&\n          // import type from \"a\";\n          !(ahead.type === tt.name && ahead.value === \"from\") &&\n          // import type = require(\"a\");\n          ahead.type !== tt.eq\n        ) {\n          node.importKind = \"type\";\n          this.next();\n          ahead = this.lookahead();\n        }\n\n        if (this.match(tt.name) && ahead.type === tt.eq) {\n          return this.tsParseImportEqualsDeclaration(node);\n        }\n      }\n\n      const importNode = super.parseImport(node);\n      /*:: invariant(importNode.type !== \"TSImportEqualsDeclaration\") */\n\n      // `import type` can only be used on imports with named imports or with a\n      // default import - but not both\n      if (\n        importNode.importKind === \"type\" &&\n        importNode.specifiers.length > 1 &&\n        importNode.specifiers[0].type === \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(\n          importNode.start,\n          \"A type-only import can specify a default import or named bindings, but not both.\",\n        );\n      }\n\n      return importNode;\n    }\n\n    parseExport(node: N.Node): N.AnyExport {\n      if (this.match(tt._import)) {\n        // `export import A = B;`\n        this.next(); // eat `tt._import`\n        if (\n          this.isContextual(\"type\") &&\n          this.lookaheadCharCode() !== charCodes.equalsTo\n        ) {\n          node.importKind = \"type\";\n          this.next(); // eat \"type\"\n        } else {\n          node.importKind = \"value\";\n        }\n        return this.tsParseImportEqualsDeclaration(node, /* isExport */ true);\n      } else if (this.eat(tt.eq)) {\n        // `export = x;`\n        const assign: N.TsExportAssignment = node;\n        assign.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(\"as\")) {\n        // `export as namespace A;`\n        const decl: N.TsNamespaceExportDeclaration = node;\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n        this.expectContextual(\"namespace\");\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        if (this.isContextual(\"type\") && this.lookahead().type === tt.braceL) {\n          this.next();\n          node.exportKind = \"type\";\n        } else {\n          node.exportKind = \"value\";\n        }\n\n        return super.parseExport(node);\n      }\n    }\n\n    isAbstractClass(): boolean {\n      return (\n        this.isContextual(\"abstract\") && this.lookahead().type === tt._class\n      );\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.isAbstractClass()) {\n        const cls = this.startNode();\n        this.next(); // Skip \"abstract\"\n        cls.abstract = true;\n        this.parseClass(cls, true, true);\n        return cls;\n      }\n\n      // export default interface allowed in:\n      // https://github.com/Microsoft/TypeScript/pull/16040\n      if (this.state.value === \"interface\") {\n        const result = this.tsParseDeclaration(\n          this.startNode(),\n          this.state.value,\n          true,\n        );\n\n        if (result) return result;\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseStatementContent(context: ?string, topLevel: ?boolean): N.Statement {\n      if (this.state.type === tt._const) {\n        const ahead = this.lookahead();\n        if (ahead.type === tt.name && ahead.value === \"enum\") {\n          const node: N.TsEnumDeclaration = this.startNode();\n          this.expect(tt._const);\n          this.expectContextual(\"enum\");\n          return this.tsParseEnumDeclaration(node, /* isConst */ true);\n        }\n      }\n      return super.parseStatementContent(context, topLevel);\n    }\n\n    parseAccessModifier(): ?N.Accessibility {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      this.tsParseModifiers(member, [\n        \"declare\",\n        \"private\",\n        \"public\",\n        \"protected\",\n      ]);\n\n      const callParseClassMember = () => {\n        super.parseClassMember(classBody, member, state);\n      };\n      if (member.declare) {\n        this.tsInDeclareContext(callParseClassMember);\n      } else {\n        callParseClassMember();\n      }\n    }\n\n    parseClassMemberWithIsStatic(\n      classBody: N.ClassBody,\n      member: N.ClassMember | N.TsIndexSignature,\n      state: N.ParseClassMemberState,\n      isStatic: boolean,\n    ): void {\n      this.tsParseModifiers(member, [\"abstract\", \"readonly\", \"declare\"]);\n\n      const idx = this.tsTryParseIndexSignature(member);\n      if (idx) {\n        classBody.body.push(idx);\n\n        if ((member: any).abstract) {\n          this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n        }\n        if (isStatic) {\n          this.raise(member.start, TSErrors.IndexSignatureHasStatic);\n        }\n        if ((member: any).accessibility) {\n          this.raise(\n            member.start,\n            TSErrors.IndexSignatureHasAccessibility,\n            (member: any).accessibility,\n          );\n        }\n        if ((member: any).declare) {\n          this.raise(member.start, TSErrors.IndexSignatureHasDeclare);\n        }\n\n        return;\n      }\n\n      if (!this.state.inAbstractClass && (member: any).abstract) {\n        this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);\n      }\n\n      /*:: invariant(member.type !== \"TSIndexSignature\") */\n\n      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n    }\n\n    parsePostMemberNameModifiers(\n      methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      const optional = this.eat(tt.question);\n      if (optional) methodOrProp.optional = true;\n\n      if ((methodOrProp: any).readonly && this.match(tt.parenL)) {\n        this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n      }\n\n      if ((methodOrProp: any).declare && this.match(tt.parenL)) {\n        this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n      }\n    }\n\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\n    // by parsing the rest.\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n    ): N.Statement {\n      const decl =\n        expr.type === \"Identifier\"\n          ? this.tsParseExpressionStatement(node, expr)\n          : undefined;\n      return decl || super.parseExpressionStatement(node, expr);\n    }\n\n    // export type\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n    shouldParseExportDeclaration(): boolean {\n      if (this.tsIsDeclarationStart()) return true;\n      return super.shouldParseExportDeclaration();\n    }\n\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\n    parseConditional(\n      expr: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      refNeedsArrowPos?: ?Pos,\n    ): N.Expression {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (!refNeedsArrowPos || !this.match(tt.question)) {\n        return super.parseConditional(\n          expr,\n          startPos,\n          startLoc,\n          refNeedsArrowPos,\n        );\n      }\n\n      const result = this.tryParse(() =>\n        super.parseConditional(expr, startPos, startLoc),\n      );\n\n      if (!result.node) {\n        // $FlowIgnore\n        refNeedsArrowPos.start = result.error.pos || this.state.start;\n        return expr;\n      }\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    // Note: These \"type casts\" are *not* valid TS expressions.\n    // But we parse them here and change them when completing the arrow function.\n    parseParenItem(\n      node: N.Expression,\n      startPos: number,\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startPos, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode: N.TsTypeCastExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\n      // Store original location/position\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n\n      // \"export declare\" is equivalent to just \"export\".\n      const isDeclare = this.eatContextual(\"declare\");\n\n      if (\n        isDeclare &&\n        (this.isContextual(\"declare\") || !this.shouldParseExportDeclaration())\n      ) {\n        throw this.raise(\n          this.state.start,\n          TSErrors.ExpectedAmbientAfterExportDeclare,\n        );\n      }\n\n      let declaration: ?N.Declaration;\n\n      if (this.match(tt.name)) {\n        declaration = this.tsTryParseExportDeclaration();\n      }\n      if (!declaration) {\n        declaration = super.parseExportDeclaration(node);\n      }\n      if (\n        declaration &&\n        (declaration.type === \"TSInterfaceDeclaration\" ||\n          declaration.type === \"TSTypeAliasDeclaration\" ||\n          isDeclare)\n      ) {\n        node.exportKind = \"type\";\n      }\n\n      if (declaration && isDeclare) {\n        // Reset location to include `declare` in range\n        this.resetStartLocation(declaration, startPos, startLoc);\n\n        declaration.declare = true;\n      }\n\n      return declaration;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId: ?boolean,\n    ): void {\n      if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n        return;\n      }\n\n      super.parseClassId(\n        node,\n        isStatement,\n        optionalId,\n        (node: any).declare ? BIND_TS_AMBIENT : BIND_CLASS,\n      );\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n    }\n\n    parseClassPropertyAnnotation(\n      node: N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      if (!node.optional && this.eat(tt.bang)) {\n        node.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n    }\n\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      this.parseClassPropertyAnnotation(node);\n\n      if (this.state.isDeclareContext && this.match(tt.eq)) {\n        this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      // $FlowIgnore\n      if (node.abstract) {\n        this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n      }\n\n      // $FlowIgnore\n      if (node.accessibility) {\n        this.raise(\n          node.start,\n          TSErrors.PrivateElementHasAccessibility,\n          node.accessibility,\n        );\n      }\n\n      this.parseClassPropertyAnnotation(node);\n      return super.parseClassPrivateProperty(node);\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters && isConstructor) {\n        this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);\n      }\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.tsParseTypeArguments();\n      }\n      if (this.eatContextual(\"implements\")) {\n        node.implements = this.tsParseHeritageClause(\"implements\");\n      }\n    }\n\n    parseObjPropValue(prop: N.ObjectMember, ...args): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) prop.typeParameters = typeParameters;\n\n      super.parseObjPropValue(prop, ...args);\n    }\n\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    // `let x: number;`\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (decl.id.type === \"Identifier\" && this.eat(tt.bang)) {\n        decl.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    parseMaybeAssign(...args): N.Expression {\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n\n      let state: ?State;\n      let jsx;\n      let typeCast;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.isRelational(\"<\"))\n      ) {\n        // Prefer to parse JSX if possible. But may be an arrow fn.\n        state = this.state.clone();\n\n        jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n        /*:: invariant(!jsx.aborted) */\n\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        if (context[context.length - 1] === ct.j_oTag) {\n          context.length -= 2;\n        } else if (context[context.length - 1] === ct.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (!jsx?.error && !this.isRelational(\"<\")) {\n        return super.parseMaybeAssign(...args);\n      }\n\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n      let typeParameters: N.TsTypeParameterDeclaration;\n      state = state || this.state.clone();\n\n      const arrow = this.tryParse(abort => {\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n        typeParameters = this.tsParseTypeParameters();\n        const expr = super.parseMaybeAssign(...args);\n\n        if (\n          expr.type !== \"ArrowFunctionExpression\" ||\n          expr.extra?.parenthesized\n        ) {\n          abort();\n        }\n\n        // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n        if (typeParameters?.params.length !== 0) {\n          this.resetStartLocationFromNode(expr, typeParameters);\n        }\n        expr.typeParameters = typeParameters;\n        return expr;\n      }, state);\n\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n\n      if (!jsx) {\n        // Try parsing a type cast instead of an arrow function.\n        // This will never happen outside of JSX.\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n        assert(!this.hasPlugin(\"jsx\"));\n\n        // This will start with a type assertion (via parseMaybeUnary).\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n        /*:: invariant(!typeCast.aborted) */\n        if (!typeCast.error) return typeCast.node;\n      }\n\n      if (jsx?.node) {\n        /*:: invariant(jsx.failState) */\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrow.node) {\n        /*:: invariant(arrow.failState) */\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (typeCast?.node) {\n        /*:: invariant(typeCast.failState) */\n        this.state = typeCast.failState;\n        return typeCast.node;\n      }\n\n      if (jsx?.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      if (typeCast?.thrown) throw typeCast.error;\n\n      throw jsx?.error || arrow.error || typeCast?.error;\n    }\n\n    // Handle type assertions\n    parseMaybeUnary(refExpressionErrors?: ?ExpressionErrors): N.Expression {\n      if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n        return this.tsParseTypeAssertion();\n      } else {\n        return super.parseMaybeUnary(refExpressionErrors);\n      }\n    }\n\n    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        // This is different from how the TS parser does it.\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\n\n        const result = this.tryParse(abort => {\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\n            tt.colon,\n          );\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n          return returnType;\n        });\n\n        if (result.aborted) return;\n\n        if (!result.thrown) {\n          if (result.error) this.state = result.failState;\n          node.returnType = result.node;\n        }\n      }\n\n      return super.parseArrow(node);\n    }\n\n    // Allow type annotations inside of a parameter list.\n    parseAssignableListItemTypes(param: N.Pattern) {\n      if (this.eat(tt.question)) {\n        if (\n          param.type !== \"Identifier\" &&\n          !this.state.isDeclareContext &&\n          !this.state.inType\n        ) {\n          this.raise(param.start, TSErrors.PatternIsOptional);\n        }\n\n        ((param: any): N.Identifier).optional = true;\n      }\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      this.resetEndLocation(param);\n\n      return param;\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): N.Node {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return super.toAssignable(this.typeCastToParameter(node), isLHS);\n        case \"TSParameterProperty\":\n          return super.toAssignable(node, isLHS);\n        case \"ParenthesizedExpression\":\n          return this.toAssignableParenthesizedExpression(node, isLHS);\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n          node.expression = this.toAssignable(node.expression, isLHS);\n          return node;\n        default:\n          return super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableParenthesizedExpression(node: N.Node, isLHS: boolean) {\n      switch (node.expression.type) {\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n        case \"ParenthesizedExpression\":\n          node.expression = this.toAssignable(node.expression, isLHS);\n          return node;\n        default:\n          return super.toAssignable(node, isLHS);\n      }\n    }\n\n    checkLVal(\n      expr: N.Expression,\n      contextDescription: string,\n      ...args:\n        | [BindingTypes | void]\n        | [BindingTypes | void, ?Set<string>, boolean | void, boolean | void]\n    ): void {\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          // Allow \"typecasts\" to appear on the left of assignment expressions,\n          // because it may be in an arrow function.\n          // e.g. `const f = (foo: number = 0) => foo;`\n          return;\n        case \"TSParameterProperty\":\n          this.checkLVal(expr.parameter, \"parameter property\", ...args);\n          return;\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (\n            /*bindingType*/ !args[0] &&\n            contextDescription !== \"parenthesized expression\" &&\n            !expr.extra?.parenthesized\n          ) {\n            this.raise(expr.start, Errors.InvalidLhs, contextDescription);\n            break;\n          }\n          this.checkLVal(expr.expression, \"parenthesized expression\", ...args);\n          return;\n        case \"TSNonNullExpression\":\n          this.checkLVal(expr.expression, contextDescription, ...args);\n          return;\n        default:\n          super.checkLVal(expr, contextDescription, ...args);\n          return;\n      }\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n      if (this.isRelational(\"<\")) {\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (this.match(tt.parenL)) {\n          const call = super.parseMaybeDecoratorArguments(expr);\n          call.typeParameters = typeArguments;\n          return call;\n        }\n\n        this.unexpected(this.state.start, tt.parenL);\n      }\n\n      return super.parseMaybeDecoratorArguments(expr);\n    }\n\n    checkCommaAfterRest(close) {\n      if (\n        this.state.isDeclareContext &&\n        this.match(tt.comma) &&\n        this.lookaheadCharCode() === close\n      ) {\n        this.next();\n      } else {\n        super.checkCommaAfterRest(close);\n      }\n    }\n\n    // === === === === === === === === === === === === === === === ===\n    // Note: All below methods are duplicates of something in flow.js.\n    // Not sure what the best way to combine these is.\n    // === === === === === === === === === === === === === === === ===\n\n    isClassMethod(): boolean {\n      return this.isRelational(\"<\") || super.isClassMethod();\n    }\n\n    isClassProperty(): boolean {\n      return (\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\n      );\n    }\n\n    parseMaybeDefault(...args): N.Pattern {\n      const node = super.parseMaybeDefault(...args);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(\n          node.typeAnnotation.start,\n          TSErrors.TypeAnnotationAfterAssign,\n        );\n      }\n\n      return node;\n    }\n\n    // ensure that inside types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        return this.finishOp(tt.relational, 1);\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      if (this.match(tt.relational)) {\n        const code = this.input.charCodeAt(this.state.start);\n        if (code === charCodes.lessThan || code === charCodes.greaterThan) {\n          this.state.pos -= 1;\n          this.readToken_lt_gt(code);\n        }\n      }\n    }\n\n    toAssignableList(exprList: N.Expression[]): $ReadOnlyArray<N.Pattern> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (!expr) continue;\n        switch (expr.type) {\n          case \"TSTypeCastExpression\":\n            exprList[i] = this.typeCastToParameter(expr);\n            break;\n          case \"TSAsExpression\":\n          case \"TSTypeAssertion\":\n            if (!this.state.maybeInArrowParameters) {\n              exprList[i] = this.typeCastToParameter(expr);\n            } else {\n              this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n            }\n            break;\n        }\n      }\n      return super.toAssignableList(...arguments);\n    }\n\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(\n        node.expression,\n        node.typeAnnotation.end,\n        node.typeAnnotation.loc.end,\n      );\n\n      return node.expression;\n    }\n\n    shouldParseArrow() {\n      return this.match(tt.colon) || super.shouldParseArrow();\n    }\n\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    canHaveLeadingDecorator() {\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      if (this.isRelational(\"<\")) {\n        const typeArguments = this.tsTryParseAndCatch(() =>\n          this.tsParseTypeArguments(),\n        );\n        if (typeArguments) node.typeParameters = typeArguments;\n      }\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    getGetterSetterExpectedParamCount(\n      method: N.ObjectMethod | N.ClassMethod,\n    ): number {\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      const firstParam = params[0];\n      const hasContextParam =\n        firstParam &&\n        firstParam.type === \"Identifier\" &&\n        firstParam.name === \"this\";\n\n      return hasContextParam ? baseCount + 1 : baseCount;\n    }\n\n    parseCatchClauseParam(): N.Pattern {\n      const param = super.parseCatchClauseParam();\n      const type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        param.typeAnnotation = type;\n        this.resetEndLocation(param);\n      }\n\n      return param;\n    }\n\n    tsInDeclareContext<T>(cb: () => T): T {\n      const oldIsDeclareContext = this.state.isDeclareContext;\n      this.state.isDeclareContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.isDeclareContext = oldIsDeclareContext;\n      }\n    }\n\n    parseClass<T: N.Class>(node: T, ...args: any[]): T {\n      const oldInAbstractClass = this.state.inAbstractClass;\n      this.state.inAbstractClass = !!(node: any).abstract;\n      try {\n        return super.parseClass(node, ...args);\n      } finally {\n        this.state.inAbstractClass = oldInAbstractClass;\n      }\n    }\n\n    tsParseAbstractDeclaration(\n      node: any,\n    ): N.ClassDeclaration | N.TsInterfaceDeclaration | typeof undefined {\n      if (this.match(tt._class)) {\n        node.abstract = true;\n        return this.parseClass<N.ClassDeclaration>(\n          (node: N.ClassDeclaration),\n          /* isStatement */ true,\n          /* optionalId */ false,\n        );\n      } else if (this.isContextual(\"interface\")) {\n        // for invalid abstract interface\n\n        // To avoid\n        //   abstract interface\n        //   Foo {}\n        if (!this.hasFollowingLineBreak()) {\n          node.abstract = true;\n          this.raise(\n            node.start,\n            TSErrors.NonClassMethodPropertyHasAbstractModifer,\n          );\n          this.next();\n          return this.tsParseInterfaceDeclaration(\n            (node: N.TsInterfaceDeclaration),\n          );\n        }\n      } else {\n        this.unexpected(null, tt._class);\n      }\n    }\n\n    parseMethod(...args: any[]) {\n      const method = super.parseMethod(...args);\n      if (method.abstract) {\n        const hasBody = this.hasPlugin(\"estree\")\n          ? !!method.value.body\n          : !!method.body;\n        if (hasBody) {\n          const { key } = method;\n          this.raise(\n            method.start,\n            TSErrors.AbstractMethodHasImplementation,\n            key.type === \"Identifier\"\n              ? key.name\n              : `[${this.input.slice(key.start, key.end)}]`,\n          );\n        }\n      }\n      return method;\n    }\n  };\n","// @flow\n\nimport * as charCodes from \"charcodes\";\n\nimport { types as tt, TokenType } from \"../tokenizer/types\";\nimport type Parser from \"../parser\";\nimport * as N from \"../types\";\n\ntt.placeholder = new TokenType(\"%%\", { startsExpr: true });\n\nexport type PlaceholderTypes =\n  | \"Identifier\"\n  | \"StringLiteral\"\n  | \"Expression\"\n  | \"Statement\"\n  | \"Declaration\"\n  | \"BlockStatement\"\n  | \"ClassBody\"\n  | \"Pattern\";\n\n// $PropertyType doesn't support enums. Use a fake \"switch\" (GetPlaceholderNode)\n//type MaybePlaceholder<T: PlaceholderTypes> = $PropertyType<N, T> | N.Placeholder<T>;\n\ntype _Switch<Value, Cases, Index> = $Call<\n  (\n    $ElementType<$ElementType<Cases, Index>, 0>,\n  ) => $ElementType<$ElementType<Cases, Index>, 1>,\n  Value,\n>;\ntype $Switch<Value, Cases> = _Switch<Value, Cases, *>;\n\ntype NodeOf<T: PlaceholderTypes> = $Switch<\n  T,\n  [\n    [\"Identifier\", N.Identifier],\n    [\"StringLiteral\", N.StringLiteral],\n    [\"Expression\", N.Expression],\n    [\"Statement\", N.Statement],\n    [\"Declaration\", N.Declaration],\n    [\"BlockStatement\", N.BlockStatement],\n    [\"ClassBody\", N.ClassBody],\n    [\"Pattern\", N.Pattern],\n  ],\n>;\n\n// Placeholder<T> breaks everything, because its type is incompatible with\n// the substituted nodes.\ntype MaybePlaceholder<T: PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    parsePlaceholder<T: PlaceholderTypes>(\n      expectedNode: T,\n    ): /*?N.Placeholder<T>*/ ?MaybePlaceholder<T> {\n      if (this.match(tt.placeholder)) {\n        const node = this.startNode();\n        this.next();\n        this.assertNoSpace(\"Unexpected space in placeholder.\");\n\n        // We can't use this.parseIdentifier because\n        // we don't want nested placeholders.\n        node.name = super.parseIdentifier(/* liberal */ true);\n\n        this.assertNoSpace(\"Unexpected space in placeholder.\");\n        this.expect(tt.placeholder);\n        return this.finishPlaceholder(node, expectedNode);\n      }\n    }\n\n    finishPlaceholder<T: PlaceholderTypes>(\n      node: N.Node,\n      expectedNode: T,\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\n      const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n      node.expectedNode = expectedNode;\n\n      return isFinished ? node : this.finishNode(node, \"Placeholder\");\n    }\n\n    /* ============================================================ *\n     * tokenizer/index.js                                           *\n     * ============================================================ */\n\n    getTokenFromCode(code: number) {\n      if (\n        code === charCodes.percentSign &&\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\n      ) {\n        return this.finishOp(tt.placeholder, 2);\n      }\n\n      return super.getTokenFromCode(...arguments);\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(): MaybePlaceholder<\"Expression\"> {\n      return (\n        this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments)\n      );\n    }\n\n    parseIdentifier(): MaybePlaceholder<\"Identifier\"> {\n      // NOTE: This function only handles identifiers outside of\n      // expressions and binding patterns, since they are already\n      // handled by the parseExprAtom and parseBindingAtom functions.\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\n      return (\n        this.parsePlaceholder(\"Identifier\") ||\n        super.parseIdentifier(...arguments)\n      );\n    }\n\n    checkReservedWord(word: string): void {\n      // Sometimes we call #checkReservedWord(node.name), expecting\n      // that node is an Identifier. If it is a Placeholder, name\n      // will be undefined.\n      if (word !== undefined) super.checkReservedWord(...arguments);\n    }\n\n    /* ============================================================ *\n     * parser/lval.js                                               *\n     * ============================================================ */\n\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\n      return (\n        this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments)\n      );\n    }\n\n    checkLVal(expr: N.Expression): void {\n      if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n    }\n\n    toAssignable(node: N.Node): N.Node {\n      if (\n        node &&\n        node.type === \"Placeholder\" &&\n        node.expectedNode === \"Expression\"\n      ) {\n        node.expectedNode = \"Pattern\";\n        return node;\n      }\n      return super.toAssignable(...arguments);\n    }\n\n    /* ============================================================ *\n     * parser/statement.js                                          *\n     * ============================================================ */\n\n    isLet(context: ?string): boolean {\n      if (super.isLet(context)) {\n        return true;\n      }\n\n      // Replicate the original checks that lead to looking ahead for an\n      // identifier.\n      if (!this.isContextual(\"let\")) {\n        return false;\n      }\n      if (context) return false;\n\n      // Accept \"let %%\" as the start of \"let %%placeholder%%\", as though the\n      // placeholder were an identifier.\n      const nextToken = this.lookahead();\n      if (nextToken.type === tt.placeholder) {\n        return true;\n      }\n\n      return false;\n    }\n\n    verifyBreakContinue(node: N.BreakStatement | N.ContinueStatement) {\n      if (node.label && node.label.type === \"Placeholder\") return;\n      super.verifyBreakContinue(...arguments);\n    }\n\n    parseExpressionStatement(\n      node: MaybePlaceholder<\"Statement\">,\n      expr: N.Expression,\n    ): MaybePlaceholder<\"Statement\"> {\n      if (\n        expr.type !== \"Placeholder\" ||\n        (expr.extra && expr.extra.parenthesized)\n      ) {\n        return super.parseExpressionStatement(...arguments);\n      }\n\n      if (this.match(tt.colon)) {\n        const stmt: N.LabeledStatement = node;\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n        this.next();\n        stmt.body = this.parseStatement(\"label\");\n        return this.finishNode(stmt, \"LabeledStatement\");\n      }\n\n      this.semicolon();\n\n      node.name = expr.name;\n      return this.finishPlaceholder(node, \"Statement\");\n    }\n\n    parseBlock(): MaybePlaceholder<\"BlockStatement\"> {\n      return (\n        this.parsePlaceholder(\"BlockStatement\") ||\n        super.parseBlock(...arguments)\n      );\n    }\n\n    parseFunctionId(): ?MaybePlaceholder<\"Identifier\"> {\n      return (\n        this.parsePlaceholder(\"Identifier\") ||\n        super.parseFunctionId(...arguments)\n      );\n    }\n\n    parseClass<T: N.Class>(\n      node: T,\n      isStatement: /* T === ClassDeclaration */ boolean,\n      optionalId?: boolean,\n    ): T {\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n\n      this.next();\n      this.takeDecorators(node);\n      const oldStrict = this.state.strict;\n\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (placeholder) {\n        if (\n          this.match(tt._extends) ||\n          this.match(tt.placeholder) ||\n          this.match(tt.braceL)\n        ) {\n          node.id = placeholder;\n        } else if (optionalId || !isStatement) {\n          node.id = null;\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n          return this.finishNode(node, type);\n        } else {\n          this.unexpected(null, \"A class name is required\");\n        }\n      } else {\n        this.parseClassId(node, isStatement, optionalId);\n      }\n\n      this.parseClassSuper(node);\n      node.body =\n        this.parsePlaceholder(\"ClassBody\") ||\n        this.parseClassBody(!!node.superClass, oldStrict);\n      return this.finishNode(node, type);\n    }\n\n    parseExport(node: N.Node): N.Node {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseExport(...arguments);\n\n      if (!this.isContextual(\"from\") && !this.match(tt.comma)) {\n        // export %%DECL%%;\n        node.specifiers = [];\n        node.source = null;\n        node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n\n      // export %%NAME%% from \"foo\";\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = placeholder;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n\n      return super.parseExport(node);\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.match(tt._default)) {\n        const next = this.nextTokenStart();\n        if (this.isUnparsedContextual(next, \"from\")) {\n          if (\n            this.input.startsWith(\n              tt.placeholder.label,\n              this.nextTokenStartSince(next + 4),\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n      return super.isExportDefaultSpecifier();\n    }\n\n    maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n      if (node.specifiers && node.specifiers.length > 0) {\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\n        return true;\n      }\n      return super.maybeParseExportDefaultSpecifier(...arguments);\n    }\n\n    checkExport(node: N.ExportNamedDeclaration): void {\n      const { specifiers } = node;\n      if (specifiers?.length) {\n        node.specifiers = specifiers.filter(\n          node => node.exported.type === \"Placeholder\",\n        );\n      }\n      super.checkExport(node);\n      node.specifiers = specifiers;\n    }\n\n    parseImport(\n      node: N.Node,\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseImport(...arguments);\n\n      node.specifiers = [];\n\n      if (!this.isContextual(\"from\") && !this.match(tt.comma)) {\n        // import %%STRING%%;\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n\n      // import %%DEFAULT%% ...\n      const specifier = this.startNodeAtNode(placeholder);\n      specifier.local = placeholder;\n      this.finishNode(specifier, \"ImportDefaultSpecifier\");\n      node.specifiers.push(specifier);\n\n      if (this.eat(tt.comma)) {\n        // import %%DEFAULT%%, * as ...\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n        // import %%DEFAULT%%, { ...\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n      }\n\n      this.expectContextual(\"from\");\n      node.source = this.parseImportSource();\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\n      // import ... from %%STRING%%;\n\n      return (\n        this.parsePlaceholder(\"StringLiteral\") ||\n        super.parseImportSource(...arguments)\n      );\n    }\n  };\n","import type Parser from \"../parser\";\nimport { types as tt } from \"../tokenizer/types\";\nimport * as N from \"../types\";\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    parseV8Intrinsic(): N.Expression {\n      if (this.match(tt.modulo)) {\n        const v8IntrinsicStart = this.state.start;\n        // let the `loc` of Identifier starts from `%`\n        const node = this.startNode();\n        this.eat(tt.modulo);\n        if (this.match(tt.name)) {\n          const name = this.parseIdentifierName(this.state.start);\n          const identifier = this.createIdentifier(node, name);\n          identifier.type = \"V8IntrinsicIdentifier\";\n          if (this.match(tt.parenL)) {\n            return identifier;\n          }\n        }\n        this.unexpected(v8IntrinsicStart);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(): N.Expression {\n      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n    }\n  };\n","// @flow\n\nimport type Parser from \"./parser\";\n\nexport type Plugin = string | [string, Object];\n\nexport type PluginList = $ReadOnlyArray<Plugin>;\n\nexport type MixinPlugin = (superClass: Class<Parser>) => Class<Parser>;\n\nexport function hasPlugin(plugins: PluginList, name: string): boolean {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\n\nexport function getPluginOption(\n  plugins: PluginList,\n  name: string,\n  option: string,\n) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\n\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n\nexport function validatePlugins(plugins: PluginList) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\n        \"Cannot use the decorators and decorators-legacy plugin together\",\n      );\n    }\n\n    const decoratorsBeforeExport = getPluginOption(\n      plugins,\n      \"decorators\",\n      \"decoratorsBeforeExport\",\n    );\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\n        \"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" +\n          \" whose value must be a boolean. If you are migrating from\" +\n          \" Babylon/Babel 6 or want to use the old decorators proposal, you\" +\n          \" should use the 'decorators-legacy' plugin instead of 'decorators'.\",\n      );\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (\n    hasPlugin(plugins, \"pipelineOperator\") &&\n    !PIPELINE_PROPOSALS.includes(\n      getPluginOption(plugins, \"pipelineOperator\", \"proposal\"),\n    )\n  ) {\n    throw new Error(\n      \"'pipelineOperator' requires 'proposal' option whose value should be one of: \" +\n        PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"),\n    );\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (hasPlugin(plugins, \"importAssertions\")) {\n      throw new Error(\n        \"Cannot combine importAssertions and moduleAttributes plugins.\",\n      );\n    }\n    const moduleAttributesVerionPluginOption = getPluginOption(\n      plugins,\n      \"moduleAttributes\",\n      \"version\",\n    );\n    if (moduleAttributesVerionPluginOption !== \"may-2020\") {\n      throw new Error(\n        \"The 'moduleAttributes' plugin requires a 'version' option,\" +\n          \" representing the last proposal update. Currently, the\" +\n          \" only supported value is 'may-2020'.\",\n      );\n    }\n  }\n\n  if (\n    hasPlugin(plugins, \"recordAndTuple\") &&\n    !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(\n      getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"),\n    )\n  ) {\n    throw new Error(\n      \"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" +\n        RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"),\n    );\n  }\n}\n\n// These plugins are defined using a mixin which extends the parser class.\n\nimport estree from \"./plugins/estree\";\nimport flow from \"./plugins/flow\";\nimport jsx from \"./plugins/jsx\";\nimport typescript from \"./plugins/typescript\";\nimport placeholders from \"./plugins/placeholders\";\nimport v8intrinsic from \"./plugins/v8intrinsic\";\n\n// NOTE: order is important. estree must come first; placeholders must come last.\nexport const mixinPlugins: { [name: string]: MixinPlugin } = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders,\n};\n\nexport const mixinPluginNames: $ReadOnlyArray<string> = Object.keys(\n  mixinPlugins,\n);\n","// @flow\n\nimport type { PluginList } from \"./plugin-utils\";\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nexport type SourceType = \"script\" | \"module\" | \"unambiguous\";\n\nexport type Options = {\n  sourceType: SourceType,\n  sourceFilename?: string,\n  startLine: number,\n  allowAwaitOutsideFunction: boolean,\n  allowReturnOutsideFunction: boolean,\n  allowImportExportEverywhere: boolean,\n  allowSuperOutsideMethod: boolean,\n  allowUndeclaredExports: boolean,\n  plugins: PluginList,\n  strictMode: ?boolean,\n  ranges: boolean,\n  tokens: boolean,\n  createParenthesizedExpressions: boolean,\n  errorRecovery: boolean,\n};\n\nexport const defaultOptions: Options = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Line from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, await at the top level is not considered an\n  // error.\n  allowAwaitOutsideFunction: false,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // When enabled, export statements can reference undeclared variables.\n  allowUndeclaredExports: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // Adds all parsed tokens to a `tokens` property on the `File` node\n  tokens: false,\n  // Whether to create ParenthesizedExpression AST nodes (if false\n  // the parser sets extra.parenthesized on the expression nodes instead).\n  createParenthesizedExpressions: false,\n  // When enabled, errors are attached to the AST instead of being directly thrown.\n  // Some errors will still throw, because @babel/parser can't always recover.\n  errorRecovery: false,\n};\n\n// Interpret and default an options object\n\nexport function getOptions(opts: ?Options): Options {\n  const options: any = {};\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n  return options;\n}\n","// @flow\n\nimport type { Options } from \"../options\";\nimport * as N from \"../types\";\nimport { Position } from \"../util/location\";\n\nimport { types as ct, type TokContext } from \"./context\";\nimport { types as tt, type TokenType } from \"./types\";\nimport type { ParsingError } from \"../parser/error\";\n\ntype TopicContextState = {\n  // When a topic binding has been currently established,\n  // then this is 1. Otherwise, it is 0. This is forwards compatible\n  // with a future plugin for multiple lexical topics.\n  maxNumOfResolvableTopics: number,\n\n  // When a topic binding has been currently established, and if that binding\n  // has been used as a topic reference `#`, then this is 0. Otherwise, it is\n  // `null`. This is forwards compatible with a future plugin for multiple\n  // lexical topics.\n  maxTopicIndex: null | 0,\n};\n\nexport default class State {\n  strict: boolean;\n  curLine: number;\n\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  startLoc: Position;\n  endLoc: Position;\n\n  init(options: Options): void {\n    this.strict =\n      options.strictMode === false ? false : options.sourceType === \"module\";\n\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  errors: ParsingError[] = [];\n\n  // Used to signify the start of a potential arrow function\n  potentialArrowAt: number = -1;\n\n  // Used to signify the start of an expression which looks like a\n  // typed arrow function, but it isn't\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowAt: number[] = [];\n\n  // Used to signify the start of an expression whose params, if it looks like\n  // an arrow function, shouldn't be converted to assignable nodes.\n  // This is used to defer the validation of typed arrow functions inside\n  // conditional expressions.\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowParamsConversionAt: number[] = [];\n\n  // Flags to track\n  maybeInArrowParameters: boolean = false;\n  inPipeline: boolean = false;\n  inType: boolean = false;\n  noAnonFunctionType: boolean = false;\n  inPropertyName: boolean = false;\n  hasFlowComment: boolean = false;\n  isIterator: boolean = false;\n  isDeclareContext: boolean = false;\n  inAbstractClass: boolean = false;\n\n  // For the smartPipelines plugin:\n  topicContext: TopicContextState = {\n    maxNumOfResolvableTopics: 0,\n    maxTopicIndex: null,\n  };\n\n  // For the F# plugin\n  soloAwait: boolean = false;\n  inFSharpPipelineDirectBody: boolean = false;\n\n  // Labels in scope.\n  labels: Array<{\n    kind: ?(\"loop\" | \"switch\"),\n    name?: ?string,\n    statementStart?: number,\n  }> = [];\n\n  // Leading decorators. Last element of the stack represents the decorators in current context.\n  // Supports nesting of decorators, e.g. @foo(@bar class inner {}) class outer {}\n  // where @foo belongs to the outer class and @bar to the inner\n  decoratorStack: Array<Array<N.Decorator>> = [[]];\n\n  // Comment store.\n  comments: Array<N.Comment> = [];\n\n  // Comment attachment store\n  trailingComments: Array<N.Comment> = [];\n  leadingComments: Array<N.Comment> = [];\n  commentStack: Array<{\n    start: number,\n    leadingComments: ?Array<N.Comment>,\n    trailingComments: ?Array<N.Comment>,\n    type: string,\n  }> = [];\n  // $FlowIgnore this is initialized when the parser starts.\n  commentPreviousNode: N.Node = null;\n\n  // The current position of the tokenizer in the input.\n  pos: number = 0;\n  lineStart: number = 0;\n\n  // Properties of the current token:\n  // Its type\n  type: TokenType = tt.eof;\n\n  // For tokens that include more information than their type, the value\n  value: any = null;\n\n  // Its start and end offset\n  start: number = 0;\n  end: number = 0;\n\n  // Position information for the previous token\n  // $FlowIgnore this is initialized when generating the second token.\n  lastTokEndLoc: Position = null;\n  // $FlowIgnore this is initialized when generating the second token.\n  lastTokStartLoc: Position = null;\n  lastTokStart: number = 0;\n  lastTokEnd: number = 0;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  context: Array<TokContext> = [ct.braceStatement];\n  exprAllowed: boolean = true;\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  containsEsc: boolean = false;\n\n  // This property is used to track the following errors\n  // - StrictNumericEscape\n  // - StrictOctalLiteral\n  //\n  // in a literal that occurs prior to/immediately after a \"use strict\" directive.\n\n  // todo(JLHwung): set strictErrors to null and avoid recording string errors\n  // after a non-directive is parsed\n  strictErrors: Map<number, string> = new Map();\n\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n  exportedIdentifiers: Array<string> = [];\n\n  // Tokens length in token store\n  tokensLength: number = 0;\n\n  curPosition(): Position {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays?: boolean): State {\n    const state = new State();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // $FlowIgnore\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      // $FlowIgnore\n      state[key] = val;\n    }\n\n    return state;\n  }\n}\n","// @flow\n\n/*:: declare var invariant; */\n\nimport type { Options } from \"../options\";\nimport * as N from \"../types\";\nimport type { Position } from \"../util/location\";\nimport * as charCodes from \"charcodes\";\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier\";\nimport { types as tt, keywords as keywordTypes, type TokenType } from \"./types\";\nimport { type TokContext, types as ct } from \"./context\";\nimport ParserErrors, { Errors } from \"../parser/error\";\nimport { SourceLocation } from \"../util/location\";\nimport {\n  lineBreak,\n  lineBreakG,\n  isNewLine,\n  isWhitespace,\n  skipWhiteSpace,\n} from \"../util/whitespace\";\nimport State from \"./state\";\n\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\n\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ],\n  hex: [\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ],\n};\n\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [\n  // 0 - 1\n  charCodes.digit0,\n  charCodes.digit1,\n];\nallowedNumericSeparatorSiblings.oct = [\n  // 0 - 7\n  ...allowedNumericSeparatorSiblings.bin,\n\n  charCodes.digit2,\n  charCodes.digit3,\n  charCodes.digit4,\n  charCodes.digit5,\n  charCodes.digit6,\n  charCodes.digit7,\n];\nallowedNumericSeparatorSiblings.dec = [\n  // 0 - 9\n  ...allowedNumericSeparatorSiblings.oct,\n\n  charCodes.digit8,\n  charCodes.digit9,\n];\n\nallowedNumericSeparatorSiblings.hex = [\n  // 0 - 9, A - F, a - f,\n  ...allowedNumericSeparatorSiblings.dec,\n\n  charCodes.uppercaseA,\n  charCodes.uppercaseB,\n  charCodes.uppercaseC,\n  charCodes.uppercaseD,\n  charCodes.uppercaseE,\n  charCodes.uppercaseF,\n\n  charCodes.lowercaseA,\n  charCodes.lowercaseB,\n  charCodes.lowercaseC,\n  charCodes.lowercaseD,\n  charCodes.lowercaseE,\n  charCodes.lowercaseF,\n];\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nexport class Token {\n  constructor(state: State) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n  declare type: TokenType;\n  declare value: any;\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n}\n\n// ## Tokenizer\n\nexport default class Tokenizer extends ParserErrors {\n  // Forward-declarations\n  // parser/util.js\n  /*::\n  +hasPrecedingLineBreak: () => boolean;\n  +unexpected: (pos?: ?number, messageOrType?: string | TokenType) => empty;\n  +expectPlugin: (name: string, pos?: ?number) => true;\n  */\n\n  isLookahead: boolean;\n\n  // Token store.\n  tokens: Array<Token | N.Comment> = [];\n\n  constructor(options: Options, input: string) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token: Token | N.Comment) {\n    // Pop out invalid tokens trapped by try-catch parsing.\n    // Those parsing branches are mainly created by typescript and flow plugins.\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  // Move to the next token\n\n  next(): void {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n      if (this.options.tokens) {\n        this.pushToken(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  // TODO\n\n  eat(type: TokenType): boolean {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // TODO\n\n  match(type: TokenType): boolean {\n    return this.state.type === type;\n  }\n\n  // TODO\n\n  lookahead(): State {\n    const old = this.state;\n    this.state = old.clone(true);\n\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart(): number {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos: number): number {\n    skipWhiteSpace.lastIndex = pos;\n    const skip = skipWhiteSpace.exec(this.input);\n    // $FlowIgnore: The skipWhiteSpace ensures to match any string\n    return pos + skip[0].length;\n  }\n\n  lookaheadCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  setStrict(strict: boolean): void {\n    this.state.strict = strict;\n    if (strict) {\n      // Throw an error for any string decimal escape found before/immediately\n      // after a \"use strict\" directive. Strict mode will be set at parse\n      // time for any literals that occur after the next node of the strict\n      // directive.\n      this.state.strictErrors.forEach((message, pos) =>\n        /* eslint-disable @babel/development-internal/dry-error-messages */\n        this.raise(pos, message),\n      );\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext(): TokContext {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  nextToken(): void {\n    const curContext = this.curContext();\n    if (!curContext?.preserveSpace) this.skipSpace();\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(tt.eof);\n      return;\n    }\n\n    const override = curContext?.override;\n    if (override) {\n      override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(\n    block: boolean,\n    text: string,\n    start: number,\n    end: number,\n    startLoc: Position,\n    endLoc: Position,\n  ): void {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc),\n    };\n\n    if (this.options.tokens) this.pushToken(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment(): void {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, Errors.UnterminatedComment);\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n    while (\n      (match = lineBreakG.exec(this.input)) &&\n      match.index < this.state.pos\n    ) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n\n    this.pushComment(\n      true,\n      this.input.slice(start + 2, end),\n      start,\n      this.state.pos,\n      startLoc,\n      this.state.curPosition(),\n    );\n  }\n\n  skipLineComment(startSkip: number): void {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n\n    this.pushComment(\n      false,\n      this.input.slice(start + startSkip, this.state.pos),\n      start,\n      this.state.pos,\n      startLoc,\n      this.state.curPosition(),\n    );\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  skipSpace(): void {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case charCodes.space:\n        case charCodes.nonBreakingSpace:\n        case charCodes.tab:\n          ++this.state.pos;\n          break;\n        case charCodes.carriageReturn:\n          if (\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\n          ) {\n            ++this.state.pos;\n          }\n        // fall through\n        case charCodes.lineFeed:\n        case charCodes.lineSeparator:\n        case charCodes.paragraphSeparator:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case charCodes.slash:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case charCodes.asterisk:\n              this.skipBlockComment();\n              break;\n\n            case charCodes.slash:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n      }\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  finishToken(type: TokenType, val: any): void {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n\n  // number sign is \"#\"\n  readToken_numberSign(): void {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      throw this.raise(this.state.pos, Errors.UnexpectedDigitAfterHash);\n    }\n\n    if (\n      next === charCodes.leftCurlyBrace ||\n      (next === charCodes.leftSquareBracket && this.hasPlugin(\"recordAndTuple\"))\n    ) {\n      // When we see `#{`, it is likely to be a hash record.\n      // However we don't yell at `#[` since users may intend to use \"computed private fields\",\n      // which is not allowed in the spec. Throwing expecting recordAndTuple is\n      // misleading\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(\n          this.state.pos,\n          next === charCodes.leftCurlyBrace\n            ? Errors.RecordExpressionHashIncorrectStartSyntaxType\n            : Errors.TupleExpressionHashIncorrectStartSyntaxType,\n        );\n      }\n\n      if (next === charCodes.leftCurlyBrace) {\n        // #{\n        this.finishToken(tt.braceHashL);\n      } else {\n        // #[\n        this.finishToken(tt.bracketHashL);\n      }\n      this.state.pos += 2;\n    } else {\n      this.finishOp(tt.hash, 1);\n    }\n  }\n\n  readToken_dot(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (\n      next === charCodes.dot &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dot\n    ) {\n      this.state.pos += 3;\n      this.finishToken(tt.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.dot);\n    }\n  }\n\n  readToken_slash(): void {\n    // '/'\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.slash, 1);\n    }\n  }\n\n  readToken_interpreter(): boolean {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== charCodes.exclamationMark) return false;\n\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n\n    this.finishToken(tt.interpreterDirective, value);\n\n    return true;\n  }\n\n  readToken_mult_modulo(code: number): void {\n    // '%*'\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    // Exponentiation operator **\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = tt.exponent;\n    }\n\n    if (next === charCodes.equalsTo && !exprAllowed) {\n      width++;\n      type = tt.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code: number): void {\n    // '||' '&&' '||=' '&&='\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n      } else {\n        this.finishOp(\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\n          2,\n        );\n      }\n      return;\n    }\n\n    if (code === charCodes.verticalBar) {\n      // '|>'\n      if (next === charCodes.greaterThan) {\n        this.finishOp(tt.pipeline, 2);\n        return;\n      }\n      // '|}'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(\n            this.state.pos,\n            Errors.RecordExpressionBarIncorrectEndSyntaxType,\n          );\n        }\n\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      // '|]'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightSquareBracket\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(\n            this.state.pos,\n            Errors.TupleExpressionBarIncorrectEndSyntaxType,\n          );\n        }\n\n        this.finishOp(tt.bracketBarR, 2);\n        return;\n      }\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n      return;\n    }\n\n    this.finishOp(\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\n      1,\n    );\n  }\n\n  readToken_caret(): void {\n    // '^'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code: number): void {\n    // '+-'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (\n        next === charCodes.dash &&\n        !this.inModule &&\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.greaterThan &&\n        (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())\n      ) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n      this.finishOp(tt.incDec, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code: number): void {\n    // '<>'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size =\n        code === charCodes.greaterThan &&\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.greaterThan\n          ? 3\n          : 2;\n      if (this.input.charCodeAt(this.state.pos + size) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, size + 1);\n        return;\n      }\n      this.finishOp(tt.bitShift, size);\n      return;\n    }\n\n    if (\n      next === charCodes.exclamationMark &&\n      code === charCodes.lessThan &&\n      !this.inModule &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dash &&\n      this.input.charCodeAt(this.state.pos + 3) === charCodes.dash\n    ) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <= | >=\n      size = 2;\n    }\n\n    this.finishOp(tt.relational, size);\n  }\n\n  readToken_eq_excl(code: number): void {\n    // '=!'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(\n        tt.equality,\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\n          ? 3\n          : 2,\n      );\n      return;\n    }\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(tt.arrow);\n      return;\n    }\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n  }\n\n  readToken_question(): void {\n    // '?'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === charCodes.questionMark) {\n      if (next2 === charCodes.equalsTo) {\n        // '??='\n        this.finishOp(tt.assign, 3);\n      } else {\n        // '??'\n        this.finishOp(tt.nullishCoalescing, 2);\n      }\n    } else if (\n      next === charCodes.dot &&\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\n    ) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(tt.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.question);\n    }\n  }\n\n  getTokenFromCode(code: number): void {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case charCodes.dot:\n        this.readToken_dot();\n        return;\n\n      // Punctuation tokens.\n      case charCodes.leftParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenL);\n        return;\n      case charCodes.rightParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenR);\n        return;\n      case charCodes.semicolon:\n        ++this.state.pos;\n        this.finishToken(tt.semi);\n        return;\n      case charCodes.comma:\n        ++this.state.pos;\n        this.finishToken(tt.comma);\n        return;\n      case charCodes.leftSquareBracket:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              this.state.pos,\n              Errors.TupleExpressionBarIncorrectStartSyntaxType,\n            );\n          }\n\n          // [|\n          this.finishToken(tt.bracketBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.bracketL);\n        }\n        return;\n      case charCodes.rightSquareBracket:\n        ++this.state.pos;\n        this.finishToken(tt.bracketR);\n        return;\n      case charCodes.leftCurlyBrace:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              this.state.pos,\n              Errors.RecordExpressionBarIncorrectStartSyntaxType,\n            );\n          }\n\n          // {|\n          this.finishToken(tt.braceBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.braceL);\n        }\n        return;\n      case charCodes.rightCurlyBrace:\n        ++this.state.pos;\n        this.finishToken(tt.braceR);\n        return;\n\n      case charCodes.colon:\n        if (\n          this.hasPlugin(\"functionBind\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.colon);\n        }\n        return;\n\n      case charCodes.questionMark:\n        this.readToken_question();\n        return;\n\n      case charCodes.graveAccent:\n        ++this.state.pos;\n        this.finishToken(tt.backQuote);\n        return;\n\n      case charCodes.digit0: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        // '0x', '0X' - hex number\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\n          this.readRadixNumber(16);\n          return;\n        }\n        // '0o', '0O' - octal number\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\n          this.readRadixNumber(8);\n          return;\n        }\n        // '0b', '0B' - binary number\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float. (fall through)\n      case charCodes.digit1:\n      case charCodes.digit2:\n      case charCodes.digit3:\n      case charCodes.digit4:\n      case charCodes.digit5:\n      case charCodes.digit6:\n      case charCodes.digit7:\n      case charCodes.digit8:\n      case charCodes.digit9:\n        this.readNumber(false);\n        return;\n\n      // Quotes produce strings.\n      case charCodes.quotationMark:\n      case charCodes.apostrophe:\n        this.readString(code);\n        return;\n\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case charCodes.slash:\n        this.readToken_slash();\n        return;\n\n      case charCodes.percentSign:\n      case charCodes.asterisk:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case charCodes.verticalBar:\n      case charCodes.ampersand:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case charCodes.caret:\n        this.readToken_caret();\n        return;\n\n      case charCodes.plusSign:\n      case charCodes.dash:\n        this.readToken_plus_min(code);\n        return;\n\n      case charCodes.lessThan:\n      case charCodes.greaterThan:\n        this.readToken_lt_gt(code);\n        return;\n\n      case charCodes.equalsTo:\n      case charCodes.exclamationMark:\n        this.readToken_eq_excl(code);\n        return;\n\n      case charCodes.tilde:\n        this.finishOp(tt.tilde, 1);\n        return;\n\n      case charCodes.atSign:\n        ++this.state.pos;\n        this.finishToken(tt.at);\n        return;\n\n      case charCodes.numberSign:\n        this.readToken_numberSign();\n        return;\n\n      case charCodes.backslash:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n    }\n\n    throw this.raise(\n      this.state.pos,\n      Errors.InvalidOrUnexpectedToken,\n      String.fromCodePoint(code),\n    );\n  }\n\n  finishOp(type: TokenType, size: number): void {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp(): void {\n    const start = this.state.pos;\n    let escaped, inClass;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n      const ch = this.input.charAt(this.state.pos);\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n        escaped = ch === \"\\\\\";\n      }\n      ++this.state.pos;\n    }\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, Errors.DuplicateRegExpFlags);\n        }\n      } else if (\n        isIdentifierChar(charCode) ||\n        charCode === charCodes.backslash\n      ) {\n        this.raise(this.state.pos + 1, Errors.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n    });\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n  // When `forceLen` is `true`, it means that we already know that in case\n  // of a malformed number we have to skip `len` characters anyway, instead\n  // of bailing out early. For example, in \"\\u{123Z}\" we want to read up to }\n  // anyway, while in \"\\u00Z\" we will stop at Z instead of consuming four\n  // characters (and thus the closing quote).\n\n  readInt(\n    radix: number,\n    len?: number,\n    forceLen?: boolean,\n    allowNumSeparator: boolean = true,\n  ): number | null {\n    const start = this.state.pos;\n    const forbiddenSiblings =\n      radix === 16\n        ? forbiddenNumericSeparatorSiblings.hex\n        : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings =\n      radix === 16\n        ? allowedNumericSeparatorSiblings.hex\n        : radix === 10\n        ? allowedNumericSeparatorSiblings.dec\n        : radix === 8\n        ? allowedNumericSeparatorSiblings.oct\n        : allowedNumericSeparatorSiblings.bin;\n\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === charCodes.underscore) {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        if (allowedSiblings.indexOf(next) === -1) {\n          this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n        } else if (\n          forbiddenSiblings.indexOf(prev) > -1 ||\n          forbiddenSiblings.indexOf(next) > -1 ||\n          Number.isNaN(next)\n        ) {\n          this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n        }\n\n        if (!allowNumSeparator) {\n          this.raise(this.state.pos, Errors.NumericSeparatorInEscapeSequence);\n        }\n\n        // Ignore this _ character\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= charCodes.lowercaseA) {\n        val = code - charCodes.lowercaseA + charCodes.lineFeed;\n      } else if (code >= charCodes.uppercaseA) {\n        val = code - charCodes.uppercaseA + charCodes.lineFeed;\n      } else if (charCodes.isDigit(code)) {\n        val = code - charCodes.digit0; // 0-9\n      } else {\n        val = Infinity;\n      }\n      if (val >= radix) {\n        // If we are in \"errorRecovery\" mode and we found a digit which is too big,\n        // don't break the loop.\n\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, Errors.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n    if (\n      this.state.pos === start ||\n      (len != null && this.state.pos - start !== len) ||\n      invalid\n    ) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix: number): void {\n    const start = this.state.pos;\n    let isBigInt = false;\n\n    this.state.pos += 2; // 0x\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(this.state.start + 2, Errors.InvalidDigit, radix);\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === charCodes.lowercaseN) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === charCodes.lowercaseM) {\n      throw this.raise(start, Errors.InvalidDecimal);\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    this.finishToken(tt.num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  readNumber(startsWithDot: boolean): void {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, Errors.InvalidNumber);\n    }\n    const hasLeadingZero =\n      this.state.pos - start >= 2 &&\n      this.input.charCodeAt(start) === charCodes.digit0;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(start, Errors.StrictOctalLiteral);\n      if (!this.state.strict) {\n        // disallow numeric separators in non octal decimals and legacy octal likes\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(underscorePos + start, Errors.ZeroDigitNumericSeparator);\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === charCodes.dot && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\n      !isOctal\n    ) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === charCodes.plusSign || next === charCodes.dash) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(start, Errors.InvalidOrMissingExponent);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === charCodes.lowercaseN) {\n      // disallow floats, legacy octal syntax and non octal decimals\n      // new style octal (\"0o\") is handled in this.readRadixNumber\n      if (isFloat || hasLeadingZero) {\n        this.raise(start, Errors.InvalidBigIntLiteral);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === charCodes.lowercaseM) {\n      this.expectPlugin(\"decimal\", this.state.pos);\n      if (hasExponent || hasLeadingZero) {\n        this.raise(start, Errors.InvalidDecimal);\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    // remove \"_\" for numeric literal separator, and trailing `m` or `n`\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(tt.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(tt.num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  readCodePoint(throwOnInvalid: boolean): number | null {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === charCodes.leftCurlyBrace) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(\n        this.input.indexOf(\"}\", this.state.pos) - this.state.pos,\n        true,\n        throwOnInvalid,\n      );\n      ++this.state.pos;\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, Errors.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n    return code;\n  }\n\n  readString(quote: number): void {\n    let out = \"\",\n      chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === charCodes.backslash) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        // $FlowFixMe\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (\n        ch === charCodes.lineSeparator ||\n        ch === charCodes.paragraphSeparator\n      ) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(tt.string, out);\n  }\n\n  // Reads template string tokens.\n\n  readTmplToken(): void {\n    let out = \"\",\n      chunkStart = this.state.pos,\n      containsInvalid = false;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedTemplate);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (\n        ch === charCodes.graveAccent ||\n        (ch === charCodes.dollarSign &&\n          this.input.charCodeAt(this.state.pos + 1) ===\n            charCodes.leftCurlyBrace)\n      ) {\n        if (this.state.pos === this.state.start && this.match(tt.template)) {\n          if (ch === charCodes.dollarSign) {\n            this.state.pos += 2;\n            this.finishToken(tt.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(tt.backQuote);\n            return;\n          }\n        }\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(tt.template, containsInvalid ? null : out);\n        return;\n      }\n      if (ch === charCodes.backslash) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n        switch (ch) {\n          case charCodes.carriageReturn:\n            if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {\n              ++this.state.pos;\n            }\n          // fall through\n          case charCodes.lineFeed:\n            out += \"\\n\";\n            break;\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(pos: number, message: string) {\n    if (this.state.strict && !this.state.strictErrors.has(pos)) {\n      this.raise(pos, message);\n    } else {\n      this.state.strictErrors.set(pos, message);\n    }\n  }\n\n  // Used to read escaped characters\n  readEscapedChar(inTemplate: boolean): string | null {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n    switch (ch) {\n      case charCodes.lowercaseN:\n        return \"\\n\";\n      case charCodes.lowercaseR:\n        return \"\\r\";\n      case charCodes.lowercaseX: {\n        const code = this.readHexChar(2, false, throwOnInvalid);\n        return code === null ? null : String.fromCharCode(code);\n      }\n      case charCodes.lowercaseU: {\n        const code = this.readCodePoint(throwOnInvalid);\n        return code === null ? null : String.fromCodePoint(code);\n      }\n      case charCodes.lowercaseT:\n        return \"\\t\";\n      case charCodes.lowercaseB:\n        return \"\\b\";\n      case charCodes.lowercaseV:\n        return \"\\u000b\";\n      case charCodes.lowercaseF:\n        return \"\\f\";\n      case charCodes.carriageReturn:\n        if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {\n          ++this.state.pos;\n        }\n      // fall through\n      case charCodes.lineFeed:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n      // fall through\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        return \"\";\n      case charCodes.digit8:\n      case charCodes.digit9:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(\n            this.state.pos - 1,\n            Errors.StrictNumericEscape,\n          );\n        }\n      // fall through\n      default:\n        if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n          const codePos = this.state.pos - 1;\n          const match = this.input\n            .substr(this.state.pos - 1, 3)\n            .match(/^[0-7]+/);\n\n          // This is never null, because of the if condition above.\n          /*:: invariant(match !== null) */\n          let octalStr = match[0];\n\n          let octal = parseInt(octalStr, 8);\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n          if (\n            octalStr !== \"0\" ||\n            next === charCodes.digit8 ||\n            next === charCodes.digit9\n          ) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(codePos, Errors.StrictNumericEscape);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u').\n\n  readHexChar(\n    len: number,\n    forceLen: boolean,\n    throwOnInvalid: boolean,\n  ): number | null {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, Errors.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n    return n;\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  readWord1(): string {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === charCodes.atSign) {\n        ++this.state.pos;\n      } else if (ch === charCodes.backslash) {\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck =\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\n          this.raise(this.state.pos, Errors.MissingUnicodeEscape);\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, Errors.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word: string): boolean {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  readWord(): void {\n    const word = this.readWord1();\n    const type = keywordTypes.get(word) || tt.name;\n\n    // Allow @@iterator and @@asyncIterator as a identifier only inside type\n    if (\n      this.state.isIterator &&\n      (!this.isIterator(word) || !this.state.inType)\n    ) {\n      this.raise(this.state.pos, Errors.InvalidIdentifier, word);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes(): void {\n    const kw = this.state.type.keyword;\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, Errors.InvalidEscapedReservedWord, kw);\n    }\n  }\n\n  braceIsBlock(prevType: TokenType): boolean {\n    const parent = this.curContext();\n    if (parent === ct.functionExpression || parent === ct.functionStatement) {\n      return true;\n    }\n    if (\n      prevType === tt.colon &&\n      (parent === ct.braceStatement || parent === ct.braceExpression)\n    ) {\n      return !parent.isExpr;\n    }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (\n      prevType === tt._return ||\n      (prevType === tt.name && this.state.exprAllowed)\n    ) {\n      return this.hasPrecedingLineBreak();\n    }\n\n    if (\n      prevType === tt._else ||\n      prevType === tt.semi ||\n      prevType === tt.eof ||\n      prevType === tt.parenR ||\n      prevType === tt.arrow\n    ) {\n      return true;\n    }\n\n    if (prevType === tt.braceL) {\n      return parent === ct.braceStatement;\n    }\n\n    if (\n      prevType === tt._var ||\n      prevType === tt._const ||\n      prevType === tt.name\n    ) {\n      return false;\n    }\n\n    if (prevType === tt.relational) {\n      // `class C<T> { ... }`\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType: TokenType): void {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === tt.dot || prevType === tt.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if ((update = type.updateContext)) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n}\n","// @flow\n\nimport {\n  CLASS_ELEMENT_KIND_ACCESSOR,\n  CLASS_ELEMENT_FLAG_STATIC,\n  type ClassElementTypes,\n} from \"./scopeflags\";\nimport { Errors } from \"../parser/error\";\n\nexport class ClassScope {\n  // A list of private named declared in the current class\n  privateNames: Set<string> = new Set();\n\n  // A list of private getters of setters without their counterpart\n  loneAccessors: Map<string, ClassElementTypes> = new Map();\n\n  // A list of private names used before being defined, mapping to\n  // their position.\n  undefinedPrivateNames: Map<string, number> = new Map();\n}\n\ntype raiseFunction = (number, string, ...any) => void;\n\nexport default class ClassScopeHandler {\n  stack: Array<ClassScope> = [];\n  declare raise: raiseFunction;\n  undefinedPrivateNames: Map<string, number> = new Map();\n\n  constructor(raise: raiseFunction) {\n    this.raise = raise;\n  }\n\n  current(): ClassScope {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n\n    // Migrate the usage of not yet defined private names to the outer\n    // class scope, or raise an error if we reached the top-level scope.\n\n    const current = this.current();\n\n    // Array.from is needed because this is compiled to an array-like for loop\n    for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(\n    name: string,\n    elementType: ClassElementTypes,\n    pos: number,\n  ) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n\n        // The private name can be duplicated only if it is used by\n        // two accessors with different kind (get and set), and if\n        // they have the same placement (static or not).\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, Errors.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name: string, pos: number) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      // top-level\n      this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n    }\n  }\n}\n","// @flow\n\n/*:: declare var invariant; */\n/**\n * @module util/expression-scope\n\nExpressionScope is used to track declaration errors in these ambiguous patterns:\n\n- CoverParenthesizedExpressionAndArrowParameterList\n  e.g. we don't know if `({ x })` is an parenthesized expression or an\n  arrow function parameters until we see an `=>` after `)`.\n\n- CoverCallExpressionAndAsyncArrowHead\n   e.g. we don't know if `async({ x })` is a call expression or an async arrow\n   function parameters until we see an `=>` after `)`\n\nThe following declaration errors (@see parser/error-message) will be recorded in\nsome expression scopes and thrown later when we know what the ambigous pattern is\n\n- AwaitBindingIdentifier\n- AwaitExpressionFormalParameter\n- YieldInParameter\n- InvalidParenthesizedAssignment when parenthesized is an identifier\n\nThere are four different expression scope\n- Expression\n  A general scope that represents program / function body / static block. No errors\n  will be recorded nor thrown in this scope.\n\n- MaybeArrowParameterDeclaration\n  A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded\n  alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`\n  is called.\n\n- MaybeAsyncArrowParameterDeclaration\n  A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will\n  be recorded alongside parent scopes and thrown when\n  `ExpressionScopeHandler#validateAsPattern` is called.\n\n- ParameterDeclaration\n  A scope that represents unambiguous function parameters `function(x)`. Errors\n  recorded in this scope will be thrown immediately. No errors will be recorded in\n  this scope.\n\n// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}\n */\n\nconst kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3;\n\ntype ExpressionScopeType = 0 | 1 | 2 | 3;\n\ntype raiseFunction = (number, string, ...any) => void;\n\nclass ExpressionScope {\n  type: ExpressionScopeType;\n\n  constructor(type: ExpressionScopeType = kExpression) {\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return (\n      this.type === kMaybeAsyncArrowParameterDeclaration ||\n      this.type === kMaybeArrowParameterDeclaration\n    );\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  errors: Map</* pos */ number, /* message */ string> = new Map();\n  constructor(type: 1 | 2) {\n    super(type);\n  }\n  recordDeclarationError(pos: number, message: string) {\n    this.errors.set(pos, message);\n  }\n  clearDeclarationError(pos: number) {\n    this.errors.delete(pos);\n  }\n  iterateErrors(iterator: (message: string, pos: number) => void) {\n    this.errors.forEach(iterator);\n  }\n}\n\nexport default class ExpressionScopeHandler {\n  stack: Array<ExpressionScope> = [new ExpressionScope()];\n  declare raise: raiseFunction;\n  constructor(raise: raiseFunction) {\n    this.raise = raise;\n  }\n  enter(scope: ExpressionScope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  /**\n   * Record likely parameter initializer errors\n   *\n   * When current scope is a ParameterDeclaration, the error will be thrown immediately,\n   * otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and\n   * MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.\n   * @param {number} pos Error position\n   * @param {string} message Error message\n   * @memberof ExpressionScopeHandler\n   */\n  recordParameterInitializerError(pos: number, message: string): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n        scope.recordDeclarationError(pos, message);\n      } else {\n        /*:: invariant(scope.type == kExpression) */\n        // Type-Expression is the boundary where initializer error can populate to\n        return;\n      }\n      scope = stack[--i];\n    }\n    /* eslint-disable @babel/development-internal/dry-error-messages */\n    this.raise(pos, message);\n  }\n\n  /**\n   * Record parenthesized identifier errors\n   *\n   * A parenthesized identifier in LHS can be ambiguous because the assignment\n   * can be transformed to an assignable later, but not vice versa:\n   * For example, in `([(a) = []] = []) => {}`, we think `(a) = []` is an LHS in `[(a) = []]`,\n   * an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,\n   * and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the\n   * location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration\n   * and MaybeAsyncArrowParameterDeclaration\n   *\n   * Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we\n   * validate arrow head parsing scope before exit, and then the LHS will be unambiguous:\n   * For example, in `( x = ( [(a) = []] = [] ) ) => {}`, we should not record `(a)` in `( x = ... ) =>`\n   * arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment\n   * expression and can not be cast to pattern\n   * @param {number} pos\n   * @param {string} message\n   * @returns {void}\n   * @memberof ExpressionScopeHandler\n   */\n  recordParenthesizedIdentifierError(pos: number, message: string): void {\n    const { stack } = this;\n    const scope: ExpressionScope = stack[stack.length - 1];\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.raise(pos, message);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n      scope.recordDeclarationError(pos, message);\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Record likely async arrow parameter errors\n   *\n   * Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration\n   * scope until an Expression scope is seen.\n   * @param {number} pos\n   * @param {string} message\n   * @memberof ExpressionScopeHandler\n   */\n  recordAsyncArrowParametersError(pos: number, message: string): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n        scope.recordDeclarationError(pos, message);\n      }\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern(): void {\n    const { stack } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    /*:: invariant(currentScope instanceof ArrowHeadParsingScope) */\n    currentScope.iterateErrors((message, pos) => {\n      /* eslint-disable @babel/development-internal/dry-error-messages */\n      this.raise(pos, message);\n      // iterate from parent scope\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n        scope.clearDeclarationError(pos);\n        scope = stack[--i];\n      }\n    });\n  }\n}\n\nexport function newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\n\nexport function newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\n\nexport function newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\n\nexport function newExpressionScope() {\n  return new ExpressionScope();\n}\n","// @flow\n\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\nimport Tokenizer from \"../tokenizer\";\nimport State from \"../tokenizer/state\";\nimport type { Node } from \"../types\";\nimport { lineBreak } from \"../util/whitespace\";\nimport { isIdentifierChar } from \"../util/identifier\";\nimport ClassScopeHandler from \"../util/class-scope\";\nimport ExpressionScopeHandler from \"../util/expression-scope\";\nimport { SCOPE_PROGRAM } from \"../util/scopeflags\";\nimport ProductionParameterHandler, {\n  PARAM_AWAIT,\n  PARAM,\n} from \"../util/production-parameter\";\nimport { Errors } from \"./error\";\n/*::\nimport type ScopeHandler from \"../util/scope\";\n*/\n\ntype TryParse<Node, Error, Thrown, Aborted, FailState> = {\n  node: Node,\n  error: Error,\n  thrown: Thrown,\n  aborted: Aborted,\n  failState: FailState,\n};\n\n// ## Parser utilities\n\nexport default class UtilParser extends Tokenizer {\n  // Forward-declaration: defined in parser/index.js\n  /*::\n  +getScopeHandler: () => Class<ScopeHandler<*>>;\n  */\n\n  // TODO\n\n  addExtra(node: Node, key: string, val: any): void {\n    if (!node) return;\n\n    const extra = (node.extra = node.extra || {});\n    extra[key] = val;\n  }\n\n  // TODO\n\n  isRelational(op: \"<\" | \">\"): boolean {\n    return this.match(tt.relational) && this.state.value === op;\n  }\n\n  // TODO\n\n  expectRelational(op: \"<\" | \">\"): void {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, tt.relational);\n    }\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  isContextual(name: string): boolean {\n    return (\n      this.match(tt.name) &&\n      this.state.value === name &&\n      !this.state.containsEsc\n    );\n  }\n\n  isUnparsedContextual(nameStart: number, name: string): boolean {\n    const nameEnd = nameStart + name.length;\n    return (\n      this.input.slice(nameStart, nameEnd) === name &&\n      (nameEnd === this.input.length ||\n        !isIdentifierChar(this.input.charCodeAt(nameEnd)))\n    );\n  }\n\n  isLookaheadContextual(name: string): boolean {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  // Consumes contextual keyword if possible.\n\n  eatContextual(name: string): boolean {\n    return this.isContextual(name) && this.eat(tt.name);\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  expectContextual(name: string, message?: string): void {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  canInsertSemicolon(): boolean {\n    return (\n      this.match(tt.eof) ||\n      this.match(tt.braceR) ||\n      this.hasPrecedingLineBreak()\n    );\n  }\n\n  hasPrecedingLineBreak(): boolean {\n    return lineBreak.test(\n      this.input.slice(this.state.lastTokEnd, this.state.start),\n    );\n  }\n\n  hasFollowingLineBreak(): boolean {\n    return lineBreak.test(\n      this.input.slice(this.state.end, this.nextTokenStart()),\n    );\n  }\n\n  // TODO\n\n  isLineTerminator(): boolean {\n    return this.eat(tt.semi) || this.canInsertSemicolon();\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  semicolon(allowAsi: boolean = true): void {\n    if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;\n    this.raise(this.state.lastTokEnd, Errors.MissingSemicolon);\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n  expect(type: TokenType, pos?: ?number): void {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  // Throws if the current token and the prev one are separated by a space.\n  assertNoSpace(message: string = \"Unexpected space.\"): void {\n    if (this.state.start > this.state.lastTokEnd) {\n      /* eslint-disable @babel/development-internal/dry-error-messages */\n      this.raise(this.state.lastTokEnd, message);\n      /* eslint-enable @babel/development-internal/dry-error-messages */\n    }\n  }\n\n  // Raise an unexpected token error. Can take the expected token type\n  // instead of a message string.\n\n  unexpected(\n    pos: ?number,\n    messageOrType: string | TokenType = \"Unexpected token\",\n  ): empty {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n    /* eslint-disable @babel/development-internal/dry-error-messages */\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n    /* eslint-enable @babel/development-internal/dry-error-messages */\n  }\n\n  expectPlugin(name: string, pos?: ?number): true {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(\n        pos != null ? pos : this.state.start,\n        { missingPlugin: [name] },\n        `This experimental syntax requires enabling the parser plugin: '${name}'`,\n      );\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names: Array<string>, pos?: ?number): void {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(\n        pos != null ? pos : this.state.start,\n        { missingPlugin: names },\n        `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\n          \", \",\n        )}'`,\n      );\n    }\n  }\n\n  // tryParse will clone parser state.\n  // It is expensive and should be used with cautions\n  tryParse<T: Node | $ReadOnlyArray<Node>>(\n    fn: (abort: (node?: T) => empty) => T,\n    oldState: State = this.state.clone(),\n  ):\n    | TryParse<T, null, false, false, null>\n    | TryParse<T | null, SyntaxError, boolean, false, State>\n    | TryParse<T | null, null, false, true, State> {\n    const abortSignal: { node: T | null } = { node: null };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: (failState.errors[oldState.errors.length]: SyntaxError),\n          thrown: false,\n          aborted: false,\n          failState,\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null,\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return { node: null, error, thrown: true, aborted: false, failState };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState,\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(\n    refExpressionErrors: ?ExpressionErrors,\n    andThrow: boolean,\n  ) {\n    if (!refExpressionErrors) return false;\n    const { shorthandAssign, doubleProto } = refExpressionErrors;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, Errors.DuplicateProto);\n    }\n  }\n\n  /**\n   * Test if current token is a literal property name\n   * https://tc39.es/ecma262/#prod-LiteralPropertyName\n   * LiteralPropertyName:\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   *   BigIntLiteral\n   */\n  isLiteralPropertyName(): boolean {\n    return (\n      this.match(tt.name) ||\n      !!this.state.type.keyword ||\n      this.match(tt.string) ||\n      this.match(tt.num) ||\n      this.match(tt.bigint) ||\n      this.match(tt.decimal)\n    );\n  }\n\n  /*\n   * Test if given node is a PrivateName\n   * will be overridden in ESTree plugin\n   */\n  isPrivateName(node: Node): boolean {\n    return node.type === \"PrivateName\";\n  }\n\n  /*\n   * Return the string value of a given private name\n   * WITHOUT `#`\n   * @see {@link https://tc39.es/proposal-class-fields/#sec-private-names-static-semantics-stringvalue}\n   */\n  getPrivateNameSV(node: Node): string {\n    return node.id.name;\n  }\n\n  /*\n   * Return whether the given node is a member/optional chain that\n   * contains a private name as its property\n   * It is overridden in ESTree plugin\n   */\n  hasPropertyAsPrivateName(node: Node): boolean {\n    return (\n      (node.type === \"MemberExpression\" ||\n        node.type === \"OptionalMemberExpression\") &&\n      this.isPrivateName(node.property)\n    );\n  }\n\n  isOptionalChain(node: Node): boolean {\n    return (\n      node.type === \"OptionalMemberExpression\" ||\n      node.type === \"OptionalCallExpression\"\n    );\n  }\n\n  isObjectProperty(node: Node): boolean {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node: Node): boolean {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(\n    inModule: boolean = this.options.sourceType === \"module\",\n  ): () => void {\n    // Initialize state\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    const oldExportedIdentifiers = this.state.exportedIdentifiers;\n    this.state.exportedIdentifiers = [];\n\n    // initialize scopes\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));\n\n    return () => {\n      // Revert state\n      this.state.labels = oldLabels;\n      this.state.exportedIdentifiers = oldExportedIdentifiers;\n\n      // Revert scopes\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n}\n\n/**\n * The ExpressionErrors is a context struct used to track\n * - **shorthandAssign**: track initializer `=` position when parsing ambiguous\n *   patterns. When we are sure the parsed pattern is a RHS, which means it is\n *   not a pattern, we will throw on this position on invalid assign syntax,\n *   otherwise it will be reset to -1\n * - **doubleProto**: track the duplicate `__proto__` key position when parsing\n *   ambiguous object patterns. When we are sure the parsed pattern is a RHS,\n *   which means it is an object literal, we will throw on this position for\n *   __proto__ redefinition, otherwise it will be reset to -1\n */\nexport class ExpressionErrors {\n  shorthandAssign = -1;\n  doubleProto = -1;\n}\n","// @flow\n\nimport type Parser from \"./index\";\nimport UtilParser from \"./util\";\nimport { SourceLocation, type Position } from \"../util/location\";\nimport type { Comment, Node as NodeType, NodeBase } from \"../types\";\n\n// Start an AST node, attaching a start offset.\n\nclass Node implements NodeBase {\n  constructor(parser: Parser, pos: number, loc: Position) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser?.options.ranges) this.range = [pos, 0];\n    if (parser?.filename) this.loc.filename = parser.filename;\n  }\n\n  type: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  range: [number, number];\n  leadingComments: Array<Comment>;\n  trailingComments: Array<Comment>;\n  innerComments: Array<Comment>;\n  extra: { [key: string]: any };\n\n  __clone(): this {\n    // $FlowIgnore\n    const newNode: any = new Node();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // Do not clone comments that are already attached to the node\n      if (\n        key !== \"leadingComments\" &&\n        key !== \"trailingComments\" &&\n        key !== \"innerComments\"\n      ) {\n        // $FlowIgnore\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n}\n\nexport class NodeUtils extends UtilParser {\n  startNode<T: NodeType>(): T {\n    // $FlowIgnore\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt<T: NodeType>(pos: number, loc: Position): T {\n    // $FlowIgnore\n    return new Node(this, pos, loc);\n  }\n\n  /** Start a new node with a previous node's location. */\n  startNodeAtNode<T: NodeType>(type: NodeType): T {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  finishNode<T: NodeType>(node: T, type: string): T {\n    return this.finishNodeAt(\n      node,\n      type,\n      this.state.lastTokEnd,\n      this.state.lastTokEndLoc,\n    );\n  }\n\n  // Finish node at given position\n\n  finishNodeAt<T: NodeType>(\n    node: T,\n    type: string,\n    pos: number,\n    loc: Position,\n  ): T {\n    if (process.env.NODE_ENV !== \"production\" && node.end > 0) {\n      throw new Error(\n        \"Do not call finishNode*() twice on the same node.\" +\n          \" Instead use resetEndLocation() or change type directly.\",\n      );\n    }\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node: NodeBase, start: number, startLoc: Position): void {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(\n    node: NodeBase,\n    end?: number = this.state.lastTokEnd,\n    endLoc?: Position = this.state.lastTokEndLoc,\n  ): void {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  /**\n   * Reset the start location of node to the start location of locationNode\n   */\n  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n}\n","// @flow\n\n/*:: declare var invariant; */\nimport * as charCodes from \"charcodes\";\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\nimport type {\n  TSParameterProperty,\n  Decorator,\n  Expression,\n  Node,\n  Pattern,\n  RestElement,\n  SpreadElement,\n  /*:: Identifier, */\n  /*:: ObjectExpression, */\n  /*:: ObjectPattern, */\n} from \"../types\";\nimport type { Pos, Position } from \"../util/location\";\nimport {\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n} from \"../util/identifier\";\nimport { NodeUtils } from \"./node\";\nimport { type BindingTypes, BIND_NONE } from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { Errors } from \"./error\";\n\nconst unwrapParenthesizedExpression = (node: Node): Node => {\n  return node.type === \"ParenthesizedExpression\"\n    ? unwrapParenthesizedExpression(node.expression)\n    : node;\n};\n\nexport default class LValParser extends NodeUtils {\n  // Forward-declaration: defined in expression.js\n  /*::\n  +parseIdentifier: (liberal?: boolean) => Identifier;\n  +parseMaybeAssignAllowIn: (\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: ?Pos,\n  ) => Expression;\n  +parseObjectLike: <T: ObjectPattern | ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: ?boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ) => T;\n  */\n  // Forward-declaration: defined in statement.js\n  /*::\n  +parseDecorator: () => Decorator;\n  */\n\n  /**\n   * Convert existing expression atom to assignable pattern\n   * if possible. Also checks invalid destructuring targets:\n\n   - Parenthesized Destructuring patterns\n   - RestElement is not the last element\n   - Missing `=` in assignment pattern\n\n   NOTE: There is a corresponding \"isAssignable\" method in flow.js.\n   When this one is updated, please check if also that one needs to be updated.\n\n   * @param {Node} node The expression atom\n   * @param {boolean} [isLHS=false] Whether we are parsing a LeftHandSideExpression. If isLHS is `true`, the following cases are allowed:\n                                    `[(a)] = [0]`, `[(a.b)] = [0]`\n\n   * @returns {Node} The converted assignable pattern\n   * @memberof LValParser\n   */\n  toAssignable(node: Node, isLHS: boolean = false): Node {\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || node.extra?.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        // an LHS can be reinterpreted to a binding pattern but not vice versa.\n        // therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression\n        // i.e. `([(a) = []] = []) => {}`\n        // see also `recordParenthesizedIdentifierError` signature in packages/babel-parser/src/util/expression-scope.js\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordParenthesizedIdentifierError(\n            node.start,\n            Errors.InvalidParenthesizedAssignment,\n          );\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          // A parenthesized member expression can be in LHS but not in pattern.\n          // If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding\n          // i.e. `([(a.b) = []] = []) => {}`\n          this.raise(node.start, Errors.InvalidParenthesizedAssignment);\n        }\n      } else {\n        this.raise(node.start, Errors.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (\n          let i = 0, length = node.properties.length, last = length - 1;\n          i < length;\n          i++\n        ) {\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (\n            isLast &&\n            prop.type === \"RestElement\" &&\n            node.extra?.trailingComma\n          ) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isLHS);\n        break;\n\n      case \"SpreadElement\": {\n        this.checkToRestConversion(node);\n\n        node.type = \"RestElement\";\n        const arg = node.argument;\n        this.toAssignable(arg, isLHS);\n        break;\n      }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, node.extra?.trailingComma, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, Errors.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        /*::invariant (parenthesized !== undefined) */\n        this.toAssignable(parenthesized, isLHS);\n        break;\n\n      default:\n      // We don't know how to deal with this node. It will\n      // be reported by a later call to checkLVal\n    }\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(\n    prop: Node,\n    isLast: boolean,\n    isLHS: boolean,\n  ) {\n    if (prop.type === \"ObjectMethod\") {\n      const error =\n        prop.kind === \"get\" || prop.kind === \"set\"\n          ? Errors.PatternHasAccessor\n          : Errors.PatternHasMethod;\n\n      /* eslint-disable @babel/development-internal/dry-error-messages */\n      this.raise(prop.key.start, error);\n      /* eslint-enable @babel/development-internal/dry-error-messages */\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  toAssignableList(\n    exprList: Expression[],\n    trailingCommaPos?: ?number,\n    isLHS: boolean,\n  ): $ReadOnlyArray<Pattern> {\n    let end = exprList.length;\n    if (end) {\n      const last = exprList[end - 1];\n      if (last?.type === \"RestElement\") {\n        --end;\n      } else if (last?.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        let arg = last.argument;\n        this.toAssignable(arg, isLHS);\n        arg = unwrapParenthesizedExpression(arg);\n        if (\n          arg.type !== \"Identifier\" &&\n          arg.type !== \"MemberExpression\" &&\n          arg.type !== \"ArrayPattern\" &&\n          arg.type !== \"ObjectPattern\"\n        ) {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n      if (elt) {\n        this.toAssignable(elt, isLHS);\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n    return exprList;\n  }\n\n  // Convert list of expression atoms to a list of\n\n  toReferencedList(\n    exprList: $ReadOnlyArray<?Expression>,\n    isParenthesizedExpr?: boolean, // eslint-disable-line no-unused-vars\n  ): $ReadOnlyArray<?Expression> {\n    return exprList;\n  }\n\n  toReferencedListDeep(\n    exprList: $ReadOnlyArray<?Expression>,\n    isParenthesizedExpr?: boolean,\n  ): void {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if (expr?.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  // Parses spread element.\n\n  parseSpread(\n    refExpressionErrors: ?ExpressionErrors,\n    refNeedsArrowPos?: ?Pos,\n  ): SpreadElement {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(\n      refExpressionErrors,\n      undefined,\n      refNeedsArrowPos,\n    );\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  // https://tc39.es/ecma262/#prod-BindingRestElement\n  parseRestBinding(): RestElement {\n    const node = this.startNode();\n    this.next(); // eat `...`\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  // Parses lvalue (assignable) atom.\n  parseBindingAtom(): Pattern {\n    // https://tc39.es/ecma262/#prod-BindingPattern\n    switch (this.state.type) {\n      case tt.bracketL: {\n        const node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(\n          tt.bracketR,\n          charCodes.rightSquareBracket,\n          true,\n        );\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n\n      case tt.braceL:\n        return this.parseObjectLike(tt.braceR, true);\n    }\n\n    // https://tc39.es/ecma262/#prod-BindingIdentifier\n    return this.parseIdentifier();\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElementList\n  parseBindingList(\n    close: TokenType,\n    closeCharCode: $Values<typeof charCodes>,\n    allowEmpty?: boolean,\n    allowModifiers?: boolean,\n  ): $ReadOnlyArray<Pattern | TSParameterProperty> {\n    const elts: Array<Pattern | TSParameterProperty> = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n      }\n      if (allowEmpty && this.match(tt.comma)) {\n        // $FlowFixMe This method returns `$ReadOnlyArray<?Pattern>` if `allowEmpty` is set.\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(tt.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n        if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, Errors.UnsupportedParameterDecorator);\n        }\n        // invariant: hasPlugin(\"decorators-legacy\")\n        while (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n    return elts;\n  }\n\n  parseAssignableListItem(\n    allowModifiers: ?boolean,\n    decorators: Decorator[],\n  ): Pattern | TSParameterProperty {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  // Used by flow/typescript plugin to add type annotations to binding elements\n  parseAssignableListItemTypes(param: Pattern): Pattern {\n    return param;\n  }\n\n  // Parses assignment pattern around given atom if possible.\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseMaybeDefault(\n    startPos?: ?number,\n    startLoc?: ?Position,\n    left?: ?Pattern,\n  ): Pattern {\n    startLoc = startLoc ?? this.state.startLoc;\n    startPos = startPos ?? this.state.start;\n    // $FlowIgnore\n    left = left ?? this.parseBindingAtom();\n    if (!this.eat(tt.eq)) return left;\n\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  /**\n   * Verify that if a node is an lval - something that can be assigned to.\n   *\n   * @param {Expression} expr The given node\n   * @param {string} contextDescription The auxiliary context information printed when error is thrown\n   * @param {BindingTypes} [bindingType=BIND_NONE] The desired binding type. If the given node is an identifier and `bindingType` is not\n                                                   BIND_NONE, `checkLVal` will register binding to the parser scope\n                                                   See also src/util/scopeflags.js\n   * @param {?Set<string>} checkClashes An optional string set to check if an identifier name is included. `checkLVal` will add checked\n                                        identifier name to `checkClashes` It is used in tracking duplicates in function parameter lists. If\n                                        it is nullish, `checkLVal` will skip duplicate checks\n   * @param {boolean} [disallowLetBinding] Whether an identifier named \"let\" should be disallowed\n   * @param {boolean} [strictModeChanged=false] Whether an identifier has been parsed in a sloppy context but should be reinterpreted as\n                                                strict-mode. e.g. `(arguments) => { \"use strict \"}`\n   * @memberof LValParser\n   */\n  checkLVal(\n    expr: Expression,\n    contextDescription: string,\n    bindingType: BindingTypes = BIND_NONE,\n    checkClashes: ?Set<string>,\n    disallowLetBinding?: boolean,\n    strictModeChanged?: boolean = false,\n  ): void {\n    switch (expr.type) {\n      case \"Identifier\": {\n        const { name } = expr;\n        if (\n          this.state.strict &&\n          // \"Global\" reserved words have already been checked by parseIdentifier,\n          // unless they have been found in the id or parameters of a strict-mode\n          // function in a sloppy context.\n          (strictModeChanged\n            ? isStrictBindReservedWord(name, this.inModule)\n            : isStrictBindOnlyReservedWord(name))\n        ) {\n          this.raise(\n            expr.start,\n            bindingType === BIND_NONE\n              ? Errors.StrictEvalArguments\n              : Errors.StrictEvalArgumentsBinding,\n            name,\n          );\n        }\n\n        if (checkClashes) {\n          if (checkClashes.has(name)) {\n            this.raise(expr.start, Errors.ParamDupe);\n          } else {\n            checkClashes.add(name);\n          }\n        }\n        if (disallowLetBinding && name === \"let\") {\n          this.raise(expr.start, Errors.LetInLexicalBinding);\n        }\n        if (!(bindingType & BIND_NONE)) {\n          this.scope.declareName(name, bindingType, expr.start);\n        }\n        break;\n      }\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, Errors.InvalidPropertyBindingPattern);\n        }\n        break;\n\n      case \"ObjectPattern\":\n        for (let prop of expr.properties) {\n          if (this.isObjectProperty(prop)) prop = prop.value;\n          // If we find here an ObjectMethod, it's because this was originally\n          // an ObjectExpression which has then been converted.\n          // toAssignable already reported this error with a nicer message.\n          else if (this.isObjectMethod(prop)) continue;\n\n          this.checkLVal(\n            prop,\n            \"object destructuring pattern\",\n            bindingType,\n            checkClashes,\n            disallowLetBinding,\n          );\n        }\n        break;\n\n      case \"ArrayPattern\":\n        for (const elem of expr.elements) {\n          if (elem) {\n            this.checkLVal(\n              elem,\n              \"array destructuring pattern\",\n              bindingType,\n              checkClashes,\n              disallowLetBinding,\n            );\n          }\n        }\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(\n          expr.left,\n          \"assignment pattern\",\n          bindingType,\n          checkClashes,\n        );\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(\n          expr.argument,\n          \"rest element\",\n          bindingType,\n          checkClashes,\n        );\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(\n          expr.expression,\n          \"parenthesized expression\",\n          bindingType,\n          checkClashes,\n        );\n        break;\n\n      default: {\n        this.raise(\n          expr.start,\n          bindingType === BIND_NONE\n            ? Errors.InvalidLhs\n            : Errors.InvalidLhsBinding,\n          contextDescription,\n        );\n      }\n    }\n  }\n\n  checkToRestConversion(node: SpreadElement): void {\n    if (\n      node.argument.type !== \"Identifier\" &&\n      node.argument.type !== \"MemberExpression\"\n    ) {\n      this.raise(node.argument.start, Errors.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close: $Values<typeof charCodes>): void {\n    if (this.match(tt.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos: number) {\n    throw this.raise(pos, Errors.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos: number) {\n    this.raise(pos, Errors.RestTrailingComma);\n  }\n}\n","// @flow\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\nimport { types as ct } from \"../tokenizer/context\";\nimport * as N from \"../types\";\nimport LValParser from \"./lval\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n} from \"../util/identifier\";\nimport type { Pos, Position } from \"../util/location\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_OUTSIDE,\n  BIND_VAR,\n  SCOPE_ARROW,\n  SCOPE_CLASS,\n  SCOPE_DIRECT_SUPER,\n  SCOPE_FUNCTION,\n  SCOPE_SUPER,\n  SCOPE_PROGRAM,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport {\n  PARAM_AWAIT,\n  PARAM_IN,\n  PARAM_RETURN,\n  PARAM,\n  functionFlags,\n} from \"../util/production-parameter\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope\";\nimport { Errors } from \"./error\";\n\n/*::\nimport type { SourceType } from \"../options\";\n*/\n\nexport default class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  /*::\n  +parseBlock: (\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ) => N.BlockStatement;\n  +parseClass: (\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ) => N.Class;\n  +parseDecorators: (allowExport?: boolean) => void;\n  +parseFunction: <T: N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ) => T;\n  +parseFunctionParams: (node: N.Function, allowModifiers?: boolean) => void;\n  +takeDecorators: (node: N.HasDecorators) => void;\n  +parseBlockOrModuleBlockBody: (\n    body: N.Statement[],\n    directives: ?(N.Directive[]),\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void\n  ) => void\n  +parseProgram: (\n    program: N.Program, end: TokenType, sourceType?: SourceType\n  ) => N.Program\n  */\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: boolean,\n    protoRef: { used: boolean },\n    refExpressionErrors: ?ExpressionErrors,\n  ): void {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      // $FlowIgnore\n      prop.shorthand\n    ) {\n      return;\n    }\n\n    const key = prop.key;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(key.start, Errors.RecordNoProto);\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, Errors.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {\n    return (\n      expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(): N.Expression & N.ParserOutput {\n    let paramFlags = PARAM;\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(refExpressionErrors?: ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: ?Pos,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(\n        refExpressionErrors,\n        afterLeftParse,\n        refNeedsArrowPos,\n      ),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: ?Pos,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(\n        refExpressionErrors,\n        afterLeftParse,\n        refNeedsArrowPos,\n      ),\n    );\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: ?Pos,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(\"yield\")) {\n      if (this.prodParam.hasYield) {\n        // If we have [Yield] production, `yield` will start a YieldExpression thus\n        // regex is allowed following. Otherwise `yield` is an identifier and regex\n        // is disallowed in tt.name.updateContext\n        this.state.exprAllowed = true;\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    if (this.match(tt.parenL) || this.match(tt.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(\n      refExpressionErrors,\n      refNeedsArrowPos,\n    );\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        node.left = this.toAssignable(left, /* isLHS */ true);\n        refExpressionErrors.doubleProto = -1; // reset because double __proto__ is valid in assignment expression\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n      }\n\n      this.checkLVal(left, \"assignment expression\");\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(\n    refExpressionErrors: ExpressionErrors,\n    refNeedsArrowPos?: ?Pos,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(\n    expr: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    // FIXME: Disabling this for now since can't seem to get it to play nicely\n    // eslint-disable-next-line no-unused-vars\n    refNeedsArrowPos?: ?Pos,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(refExpressionErrors: ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    left: N.Expression,\n    leftStartPos: number,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    let prec = this.state.type.binop;\n    if (prec != null && (this.prodParam.hasIn || !this.match(tt._in))) {\n      if (prec > minPrec) {\n        const op = this.state.type;\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        }\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = ((tt.logicalAND: any): { binop: number }).binop;\n        }\n\n        this.next();\n\n        if (\n          op === tt.pipeline &&\n          this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\"\n        ) {\n          if (\n            this.match(tt.name) &&\n            this.state.value === \"await\" &&\n            this.prodParam.hasAwait\n          ) {\n            throw this.raise(\n              this.state.start,\n              Errors.UnexpectedAwaitAfterPipelineBody,\n            );\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(this.state.start, Errors.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(op: TokenType, prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(\n                this.parseExprOpBaseRightExpr(op, prec),\n                startPos,\n                startLoc,\n              );\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n      // falls through\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(op: TokenType, prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnary(),\n      startPos,\n      startLoc,\n      op.rightAssociative ? prec - 1 : prec,\n    );\n  }\n\n  checkExponentialAfterUnary(node: N.AwaitExpression | N.UnaryExpression) {\n    if (this.match(tt.exponent)) {\n      this.raise(\n        node.argument.start,\n        Errors.UnexpectedTokenUnaryExponentiation,\n      );\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    refExpressionErrors: ?ExpressionErrors,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(\"await\");\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startPos, startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    if (\n      this.isContextual(\"module\") &&\n      this.lookaheadCharCode() === charCodes.leftCurlyBrace &&\n      !this.hasFollowingLineBreak()\n    ) {\n      return this.parseModuleExpression();\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode();\n    if (this.state.type.prefix) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, Errors.StrictDelete);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(node.start, Errors.DeletePrivateField);\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) this.checkExponentialAfterUnary(node);\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? this.state.type.startsExpr\n        : this.state.type.startsExpr && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(\n          startPos,\n          this.hasPlugin(\"topLevelAwait\")\n            ? Errors.AwaitNotInAsyncContext\n            : Errors.AwaitNotInAsyncFunction,\n        );\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors: ?ExpressionErrors,\n  ): N.Expression {\n    if (update) {\n      this.checkLVal(node.argument, \"prefix operation\");\n      return this.finishNode(node, \"UpdateExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(refExpressionErrors: ?ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls?: ?boolean,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls: ?boolean,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    if (!noCalls && this.eat(tt.doubleColon)) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (this.match(tt.backQuote)) {\n      return this.parseTaggedTemplateExpression(\n        base,\n        startPos,\n        startLoc,\n        state,\n      );\n    }\n\n    let optional = false;\n    if (this.match(tt.questionDot)) {\n      if (noCalls && this.lookaheadCharCode() === charCodes.leftParenthesis) {\n        // stop at `?.` when parsing `new a?.()`\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startPos,\n        startLoc,\n        state,\n        optional,\n      );\n    } else if (optional || this.match(tt.bracketL) || this.eat(tt.dot)) {\n      return this.parseMember(base, startPos, startLoc, state, optional);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt(startPos, startLoc);\n    const computed = this.eat(tt.bracketL);\n    node.object = base;\n    node.computed = computed;\n    const property = computed\n      ? this.parseExpression()\n      : this.parseMaybePrivateName(true);\n\n    if (this.isPrivateName(property)) {\n      if (node.object.type === \"Super\") {\n        this.raise(startPos, Errors.SuperPrivateField);\n      }\n      this.classScope.usePrivateName(\n        this.getPrivateNameSV(property),\n        property.start,\n      );\n    }\n    node.property = property;\n\n    if (computed) {\n      this.expect(tt.bracketR);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls: ?boolean,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startPos,\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n\n    this.next(); // eat `(`\n\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n    if (state.maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        state.maybeAsyncArrow,\n        base.type === \"Import\",\n        base.type !== \"Super\",\n        node,\n      );\n    }\n    this.finishCallExpression(node, state.optionalChainMember);\n\n    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt(startPos, startLoc),\n        node,\n      );\n    } else {\n      if (state.maybeAsyncArrow) {\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return node;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node: N.TaggedTemplateExpression = this.startNodeAt(\n      startPos,\n      startLoc,\n    );\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(startPos, Errors.OptionalChainingNoTemplate);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEnd === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      base.start === this.state.potentialArrowAt\n    );\n  }\n\n  finishCallExpression<T: N.CallExpression | N.OptionalCallExpression>(\n    node: T,\n    optional: boolean,\n  ): N.Expression {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        // todo(Babel 8): remove the if condition,\n        // moduleAttributes is renamed to importAssertions\n        if (!this.hasPlugin(\"moduleAttributes\")) {\n          this.expectPlugin(\"importAssertions\");\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(\n          node.start,\n          Errors.ImportCallArity,\n          this.hasPlugin(\"importAssertions\") ||\n            this.hasPlugin(\"moduleAttributes\")\n            ? \"one or two arguments\"\n            : \"one argument\",\n        );\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(arg.start, Errors.ImportCallSpreadArgument);\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    close: TokenType,\n    possibleAsyncArrow: boolean,\n    dynamicImport?: boolean,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: ?N.Node,\n  ): $ReadOnlyArray<?N.Expression> {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (\n            dynamicImport &&\n            !this.hasPlugin(\"importAssertions\") &&\n            !this.hasPlugin(\"moduleAttributes\")\n          ) {\n            this.raise(\n              this.state.lastTokStart,\n              Errors.ImportCallArgumentTrailingComma,\n            );\n          }\n          if (nodeForExtra) {\n            this.addExtra(\n              nodeForExtra,\n              \"trailingComma\",\n              this.state.lastTokStart,\n            );\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(\n          false,\n          possibleAsyncArrow ? new ExpressionErrors() : undefined,\n          possibleAsyncArrow ? { start: 0 } : undefined,\n          allowPlaceholder,\n        ),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    node: N.ArrowFunctionExpression,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingComma,\n    );\n    return node;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(refExpressionErrors?: ?ExpressionErrors): N.Expression {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.state.type === tt.slash) this.readRegexp();\n\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(tt.parenL)) {\n          this.raise(this.state.lastTokStart, Errors.UnsupportedImport);\n        }\n        return this.finishNode(node, \"Import\");\n      case tt._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt.name: {\n        const containsEsc = this.state.containsEsc;\n        const id = this.parseIdentifier();\n\n        if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n          if (this.match(tt._function)) {\n            const last = this.state.context.length - 1;\n            if (this.state.context[last] !== ct.functionStatement) {\n              // Since \"async\" is an identifier and normally identifiers\n              // can't be followed by expression, the tokenizer assumes\n              // that \"function\" starts a statement.\n              // Fixing it in the tokenizer would mean tracking not only the\n              // previous token (\"async\"), but also the one before to know\n              // its beforeExpr value.\n              // It's easier and more efficient to adjust the context here.\n              throw new Error(\"Internal error\");\n            }\n            this.state.context[last] = ct.functionExpression;\n\n            this.next();\n            return this.parseFunction(\n              this.startNodeAtNode(id),\n              undefined,\n              true,\n            );\n          } else if (this.match(tt.name)) {\n            return this.parseAsyncArrowUnaryFunction(id);\n          }\n        }\n\n        if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {\n          this.next();\n          return this.parseArrowExpression(\n            this.startNodeAtNode(id),\n            [id],\n            false,\n          );\n        }\n\n        return id;\n      }\n\n      case tt._do: {\n        return this.parseDo();\n      }\n\n      case tt.regexp: {\n        const value = this.state.value;\n        node = this.parseLiteral(value.value, \"RegExpLiteral\");\n        node.pattern = value.pattern;\n        node.flags = value.flags;\n        return node;\n      }\n\n      case tt.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case tt.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case tt.decimal:\n        return this.parseLiteral(this.state.value, \"DecimalLiteral\");\n\n      case tt.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case tt._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case tt._true:\n      case tt._false:\n        return this.parseBooleanLiteral();\n\n      case tt.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n          refExpressionErrors,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        this.parseDecorators();\n      // fall through\n      case tt._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.backQuote:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(callee.start, Errors.UnsupportedBind);\n        }\n      }\n\n      case tt.hash: {\n        if (this.state.inPipeline) {\n          node = this.startNode();\n\n          if (\n            this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\"\n          ) {\n            this.raise(node.start, Errors.PrimaryTopicRequiresSmartPipeline);\n          }\n\n          this.next();\n\n          if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n            this.raise(node.start, Errors.PrimaryTopicNotAllowed);\n          }\n\n          this.registerTopicReference();\n          return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n        }\n\n        // https://tc39.es/proposal-private-fields-in-in\n        // RelationalExpression [In, Yield, Await]\n        //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n        const nextCh = this.input.codePointAt(this.state.end);\n        if (isIdentifierStart(nextCh) || nextCh === charCodes.backslash) {\n          const start = this.state.start;\n          // $FlowIgnore It'll either parse a PrivateName or throw.\n          node = (this.parseMaybePrivateName(true): N.PrivateName);\n          if (this.match(tt._in)) {\n            this.expectPlugin(\"privateIn\");\n            this.classScope.usePrivateName(\n              this.getPrivateNameSV(node),\n              node.start,\n            );\n          } else if (this.hasPlugin(\"privateIn\")) {\n            this.raise(\n              this.state.start,\n              Errors.PrivateInExpectedIn,\n              this.getPrivateNameSV(node),\n            );\n          } else {\n            throw this.unexpected(start);\n          }\n          return node;\n        }\n      }\n      // fall through\n      case tt.relational: {\n        if (this.state.value === \"<\") {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (\n            isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n            lookaheadCh === charCodes.greaterThan // Fragment <>\n          ) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          }\n        }\n      }\n      // fall through\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(id: N.Expression): N.ArrowFunctionExpression {\n    const node = this.startNodeAtNode(id);\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.pos, Errors.LineTerminatorBeforeArrow);\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  parseDo(): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    const node = this.startNode();\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    node.body = this.parseBlock();\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(node.start, Errors.SuperNotAllowed);\n    } else if (\n      !this.scope.allowSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(node.start, Errors.UnexpectedSuper);\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(node.start, Errors.UnsupportedSuper);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parseBooleanLiteral(): N.BooleanLiteral {\n    const node = this.startNode();\n    node.value = this.match(tt._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName(\n    isPrivateNameAllowed: boolean,\n  ): N.PrivateName | N.Identifier {\n    const isPrivate = this.match(tt.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.pos, Errors.UnexpectedPrivateField);\n      }\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionOrFunctionSent(): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(\n    node: N.MetaProperty,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(\n        node.property.start,\n        Errors.UnsupportedMetaProperty,\n        meta.name,\n        propertyName,\n      );\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(node: N.MetaProperty): N.MetaProperty {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next(); // eat `.`\n\n    if (this.isContextual(\"meta\")) {\n      if (!this.inModule) {\n        this.raiseWithData(\n          id.start,\n          { code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\" },\n          Errors.ImportMetaOutsideModule,\n        );\n      }\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral<T: N.Literal>(\n    value: any,\n    type: /*T[\"kind\"]*/ string,\n    startPos?: number,\n    startLoc?: Position,\n  ): T {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    const refNeedsArrowPos = { start: 0 };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma, refNeedsArrowPos.start || null);\n        if (this.match(tt.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(\n          this.parseParenItem(\n            this.parseRestBinding(),\n            spreadNodeStartPos,\n            spreadNodeStartLoc,\n          ),\n        );\n\n        this.checkCommaAfterRest(charCodes.rightParenthesis);\n\n        break;\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n            refNeedsArrowPos,\n          ),\n        );\n      }\n    }\n\n    const innerEndPos = this.state.lastTokEnd;\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n    if (\n      canBeArrow &&\n      this.shouldParseArrow() &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow(): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(\n    node: N.Expression,\n    startPos: number, // eslint-disable-line no-unused-vars\n    startLoc: Position, // eslint-disable-line no-unused-vars\n  ): N.Expression {\n    return node;\n  }\n\n  parseNewOrNewTarget(): N.NewExpression | N.MetaProperty {\n    const node = this.startNode();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        let error = Errors.UnexpectedNewTarget;\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        /* eslint-disable @babel/development-internal/dry-error-messages */\n        this.raise(metaProp.start, error);\n        /* eslint-enable @babel/development-internal/dry-error-messages */\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call  at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(node: N.Expression): N.NewExpression {\n    node.callee = this.parseNoCallExpr();\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, Errors.ImportCallNotNewExpression);\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(this.state.lastTokEnd, Errors.OptionalChainingNoNew);\n    } else if (this.eat(tt.questionDot)) {\n      this.raise(this.state.start, Errors.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node: N.NewExpression): void {\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // $FlowFixMe (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const elem = this.startNode();\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, Errors.InvalidEscapeSequenceTemplate);\n      }\n    }\n    elem.value = {\n      raw: this.input\n        .slice(this.state.start, this.state.end)\n        .replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value,\n    };\n    this.next();\n    elem.tail = this.match(tt.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      this.expect(tt.dollarBraceL);\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.expect(tt.braceR);\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(): N.Expression {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike<T: N.ObjectPattern | N.ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: ?boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash: any = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          break;\n        }\n      }\n\n      const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);\n      if (!isPattern) {\n        // $FlowIgnore RestElement will never be returned if !isPattern\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(prop.start, Errors.InvalidRecordProperty);\n      }\n\n      // $FlowIgnore\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    // The tokenizer uses `braceIsBlock` to detect whether `{` starts a block statement.\n    // If `{` is a block statement, `exprAllowed` will be `true`.\n    // However the tokenizer can not handle edge cases like `0 ? a : { a : 1 } / 2`, here\n    // we update `exprAllowed` when an object-like is parsed.\n    this.state.exprAllowed = false;\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(prop: N.ObjectProperty): boolean {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    isPattern: boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ): N.ObjectMember | N.SpreadElement | N.RestElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, Errors.UnsupportedPropertyDecorator);\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      if (isPattern) {\n        this.next();\n        // Don't use parseRestBinding() as we only allow Identifier here.\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(charCodes.rightCurlyBrace);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(tt.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, /* isPrivateNameAllowed */ false);\n\n    if (\n      !isPattern &&\n      !isGenerator &&\n      !containsEsc &&\n      this.maybeAsyncOrAccessorProp(prop)\n    ) {\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop, /* isPrivateNameAllowed */ false);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(this.state.pos, Errors.AccessorIsGenerator, keyName);\n          this.next();\n        }\n        this.parsePropertyName(prop, /* isPrivateNameAllowed */ false);\n      }\n    }\n\n    this.parseObjPropValue(\n      prop,\n      startPos,\n      startLoc,\n      isGenerator,\n      isAsync,\n      isPattern,\n      isAccessor,\n      refExpressionErrors,\n    );\n\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    const start = method.start;\n\n    if (params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    prop: N.ObjectMethod,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): ?N.ObjectMethod {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    prop: N.ObjectProperty,\n    startPos: ?number,\n    startLoc: ?Position,\n    isPattern: boolean,\n    refExpressionErrors: ?ExpressionErrors,\n  ): ?N.ObjectProperty {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoveredInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startPos,\n          startLoc,\n          prop.key.__clone(),\n        );\n      } else if (this.match(tt.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n        prop.value = this.parseMaybeDefault(\n          startPos,\n          startLoc,\n          prop.key.__clone(),\n        );\n      } else {\n        prop.value = prop.key.__clone();\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(\n    prop: any,\n    startPos: ?number,\n    startLoc: ?Position,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ): void {\n    const node =\n      this.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) ||\n      this.parseObjectProperty(\n        prop,\n        startPos,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      );\n\n    if (!node) this.unexpected();\n\n    // $FlowFixMe\n    return node;\n  }\n\n  parsePropertyName(\n    prop: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,\n    isPrivateNameAllowed: boolean,\n  ): N.Expression | N.Identifier {\n    if (this.eat(tt.bracketL)) {\n      (prop: $FlowSubtype<N.ObjectOrClassMember>).computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(tt.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      // We check if it's valid for it to be a private name when we push it.\n      (prop: $FlowFixMe).key =\n        this.match(tt.num) ||\n        this.match(tt.string) ||\n        this.match(tt.bigint) ||\n        this.match(tt.decimal)\n          ? this.parseExprAtom()\n          : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (!this.isPrivateName(prop.key)) {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  // Initialize empty function node.\n\n  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: ?boolean): void {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  // Parse object or class method.\n\n  parseMethod<T: N.MethodLike>(\n    node: T,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowDirectSuper: boolean,\n    type: string,\n    inClassScope: boolean = false,\n  ): T {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor; // For TypeScript parameter properties\n    this.scope.enter(\n      SCOPE_FUNCTION |\n        SCOPE_SUPER |\n        (inClassScope ? SCOPE_CLASS : 0) |\n        (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),\n    );\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams((node: any), allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n\n    return node;\n  }\n\n  // parse an array literal or tuple literal\n  // https://tc39.es/ecma262/#prod-ArrayLiteral\n  // https://tc39.es/proposal-record-tuple/#prod-TupleLiteral\n  parseArrayLike(\n    close: TokenType,\n    canBePattern: boolean,\n    isTuple: boolean,\n    refExpressionErrors: ?ExpressionErrors,\n  ): N.ArrayExpression | N.TupleExpression {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(\n      close,\n      /* allowEmpty */ !isTuple,\n      refExpressionErrors,\n      node,\n    );\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(\n      node,\n      isTuple ? \"TupleExpression\" : \"ArrayExpression\",\n    );\n  }\n\n  // Parse arrow function expression.\n  // If the parameters are provided, they will be converted to an\n  // assignable list.\n  parseArrowExpression(\n    node: N.ArrowFunctionExpression,\n    params: ?(N.Expression[]),\n    isAsync: boolean,\n    trailingCommaPos: ?number,\n  ): N.ArrowFunctionExpression {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n    // ConciseBody and AsyncConciseBody inherit [In]\n    if (!this.match(tt.bracketL) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(\n    node: N.ArrowFunctionExpression,\n    params: N.Expression[],\n    trailingCommaPos: ?number,\n  ): void {\n    node.params = this.toAssignableList(params, trailingCommaPos, false);\n  }\n\n  parseFunctionBodyAndFinish(\n    node: N.BodilessFunctionOrMethodBase,\n    type: string,\n    isMethod?: boolean = false,\n  ): void {\n    // $FlowIgnore (node is not bodiless if we get here)\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  // Parse function body and check parameters.\n  parseFunctionBody(\n    node: N.Function,\n    allowExpression: ?boolean,\n    isMethod?: boolean = false,\n  ): void {\n    const isExpression = allowExpression && !this.match(tt.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      // https://tc39.es/ecma262/#prod-ExpressionBody\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      // Start a new scope with regard to labels\n      // flag (restore them to their old value afterwards).\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      // FunctionBody[Yield, Await]:\n      //   StatementList[?Yield, ?Await, +Return] opt\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(\n        true,\n        false,\n        // Strict mode function checks after we parse the statements in the function body.\n        (hasStrictModeDirective: boolean) => {\n          const nonSimple = !this.isSimpleParamList(node.params);\n\n          if (hasStrictModeDirective && nonSimple) {\n            // This logic is here to align the error location with the ESTree plugin.\n            const errorPos =\n              // $FlowIgnore\n              (node.kind === \"method\" || node.kind === \"constructor\") &&\n              // $FlowIgnore\n              !!node.key\n                ? node.key.end\n                : node.start;\n            this.raise(errorPos, Errors.IllegalLanguageModeDirective);\n          }\n\n          const strictModeChanged = !oldStrict && this.state.strict;\n\n          // Add the params to varDeclaredNames to ensure that an error is thrown\n          // if a let/const declaration in the function clashes with one of the params.\n          this.checkParams(\n            node,\n            !this.state.strict && !allowExpression && !isMethod && !nonSimple,\n            allowExpression,\n            strictModeChanged,\n          );\n\n          // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n          if (this.state.strict && node.id) {\n            this.checkLVal(\n              node.id,\n              \"function name\",\n              BIND_OUTSIDE,\n              undefined,\n              undefined,\n              strictModeChanged,\n            );\n          }\n        },\n      );\n      this.prodParam.exit();\n      this.expressionScope.exit();\n      this.state.labels = oldLabels;\n    }\n  }\n\n  isSimpleParamList(\n    params: $ReadOnlyArray<N.Pattern | N.TSParameterProperty>,\n  ): boolean {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n    return true;\n  }\n\n  checkParams(\n    node: N.Function,\n    allowDuplicates: boolean,\n    // eslint-disable-next-line no-unused-vars\n    isArrowFunction: ?boolean,\n    strictModeChanged?: boolean = true,\n  ): void {\n    const checkClashes = new Set();\n    for (const param of node.params) {\n      this.checkLVal(\n        param,\n        \"function parameter list\",\n        BIND_VAR,\n        allowDuplicates ? null : checkClashes,\n        undefined,\n        strictModeChanged,\n      );\n    }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  parseExprList(\n    close: TokenType,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n    nodeForExtra?: ?N.Node,\n  ): $ReadOnlyArray<?N.Expression> {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(\n              nodeForExtra,\n              \"trailingComma\",\n              this.state.lastTokStart,\n            );\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n\n  parseExprListItem(\n    allowEmpty: ?boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n    refNeedsArrowPos: ?Pos,\n    allowPlaceholder: ?boolean,\n  ): ?N.Expression {\n    let elt;\n    if (this.match(tt.comma)) {\n      if (!allowEmpty) {\n        this.raise(this.state.pos, Errors.UnexpectedToken, \",\");\n      }\n      elt = null;\n    } else if (this.match(tt.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(\n        this.parseSpread(refExpressionErrors, refNeedsArrowPos),\n        spreadNodeStartPos,\n        spreadNodeStartLoc,\n      );\n    } else if (this.match(tt.question)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, Errors.UnexpectedArgumentPlaceholder);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(\n        refExpressionErrors,\n        this.parseParenItem,\n        refNeedsArrowPos,\n      );\n    }\n    return elt;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n  // This shouldn't be used to parse the keywords of meta properties, since they\n  // are not identifiers and cannot contain escape sequences.\n\n  parseIdentifier(liberal?: boolean): N.Identifier {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node: N.Identifier, name: string): N.Identifier {\n    node.name = name;\n    node.loc.identifierName = name;\n\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos: number, liberal?: boolean): string {\n    let name: string;\n\n    const { start, type } = this.state;\n\n    if (type === tt.name) {\n      name = this.state.value;\n    } else if (type.keyword) {\n      name = type.keyword;\n\n      // `class` and `function` keywords push function-type token context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed\n      // as an identifier such as a property name.\n      const curContext = this.curContext();\n      if (\n        (type === tt._class || type === tt._function) &&\n        (curContext === ct.functionStatement ||\n          curContext === ct.functionExpression)\n      ) {\n        this.state.context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      // If the current token is not used as a keyword, set its type to \"tt.name\".\n      // This will prevent this.next() from throwing about unexpected escapes.\n      this.state.type = tt.name;\n    } else {\n      this.checkReservedWord(name, start, !!type.keyword, false);\n    }\n\n    this.next();\n\n    return name;\n  }\n\n  checkReservedWord(\n    word: string,\n    startLoc: number,\n    checkKeywords: boolean,\n    isBinding: boolean,\n  ): void {\n    if (this.prodParam.hasYield && word === \"yield\") {\n      this.raise(startLoc, Errors.YieldBindingIdentifier);\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, Errors.AwaitBindingIdentifier);\n        return;\n      } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {\n        this.raise(startLoc, Errors.AwaitBindingIdentifierInStaticBlock);\n        return;\n      } else {\n        this.expressionScope.recordAsyncArrowParametersError(\n          startLoc,\n          Errors.AwaitBindingIdentifier,\n        );\n      }\n    }\n\n    if (\n      this.scope.inClass &&\n      !this.scope.inNonArrowFunction &&\n      word === \"arguments\"\n    ) {\n      this.raise(startLoc, Errors.ArgumentsInClass);\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, Errors.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict\n      ? isReservedWord\n      : isBinding\n      ? isStrictBindReservedWord\n      : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(startLoc, Errors.UnexpectedReservedWord, word);\n    }\n  }\n\n  isAwaitAllowed(): boolean {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n\n  // Parses await expression inside async function.\n\n  parseAwait(startPos: number, startLoc: Position): N.AwaitExpression {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    this.expressionScope.recordParameterInitializerError(\n      node.start,\n      Errors.AwaitExpressionFormalParameter,\n    );\n\n    if (this.eat(tt.star)) {\n      this.raise(node.start, Errors.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait(): boolean {\n    return (\n      this.hasPrecedingLineBreak() ||\n      // All the following expressions are ambiguous:\n      //   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``\n      this.match(tt.plusMin) ||\n      this.match(tt.parenL) ||\n      this.match(tt.bracketL) ||\n      this.match(tt.backQuote) ||\n      // Sometimes the tokenizer generates tt.slash for regexps, and this is\n      // handler by parseExprAtom\n      this.match(tt.regexp) ||\n      this.match(tt.slash) ||\n      // This code could be parsed both as a modulo operator or as an intrinsic:\n      //   await %x(0)\n      (this.hasPlugin(\"v8intrinsic\") && this.match(tt.modulo))\n    );\n  }\n\n  // Parses yield expression inside generator.\n\n  parseYield(): N.YieldExpression {\n    const node = this.startNode();\n\n    this.expressionScope.recordParameterInitializerError(\n      node.start,\n      Errors.YieldInParameter,\n    );\n\n    this.next();\n    if (\n      this.match(tt.semi) ||\n      (!this.match(tt.star) && !this.state.type.startsExpr) ||\n      this.hasPrecedingLineBreak()\n    ) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(tt.star);\n      node.argument = this.parseMaybeAssign();\n    }\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\n  // of the infix operator `|>`.\n\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartPos: number) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        // Ensure that the pipeline head is not a comma-delimited\n        // sequence expression.\n        this.raise(leftStartPos, Errors.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(\n    childExpression: N.Expression,\n    startPos: number,\n    startLoc: Position,\n  ): N.PipelineBody {\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);\n\n    return this.parseSmartPipelineBodyInStyle(\n      childExpression,\n      startPos,\n      startLoc,\n    );\n  }\n\n  checkSmartPipelineBodyEarlyErrors(\n    childExpression: N.Expression,\n    startPos: number,\n  ): void {\n    if (this.match(tt.arrow)) {\n      // If the following token is invalidly `=>`, then throw a human-friendly error\n      // instead of something like 'Unexpected token, expected \";\"'.\n      throw this.raise(this.state.start, Errors.PipelineBodyNoArrow);\n    } else if (childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, Errors.PipelineBodySequenceExpression);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(\n    childExpression: N.Expression,\n    startPos: number,\n    startLoc: Position,\n  ): N.PipelineBody {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n    const isSimpleReference = this.isSimpleReference(childExpression);\n    if (isSimpleReference) {\n      bodyNode.callee = childExpression;\n    } else {\n      if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n        this.raise(startPos, Errors.PipelineTopicUnused);\n      }\n      bodyNode.expression = childExpression;\n    }\n    return this.finishNode(\n      bodyNode,\n      isSimpleReference ? \"PipelineBareFunction\" : \"PipelineTopicExpression\",\n    );\n  }\n\n  isSimpleReference(expression: N.Expression): boolean {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return (\n          !expression.computed && this.isSimpleReference(expression.object)\n        );\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Enable topic references from outer contexts within smart pipeline bodies.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withTopicPermittingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Enable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 1,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  // Disable topic references from outer contexts within syntax constructs\n  // such as the bodies of iteration statements.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withTopicForbiddingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Disable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 0,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext<T>(callback: () => T): T {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  disallowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  // Register the use of a primary topic reference (`#`) within the current\n  // topic context.\n  registerTopicReference(): void {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext(): boolean {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext(): boolean {\n    return (\n      this.state.topicContext.maxTopicIndex != null &&\n      this.state.topicContext.maxTopicIndex >= 0\n    );\n  }\n\n  parseFSharpPipelineBody(prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n\n    const ret = this.parseExprOp(\n      this.parseMaybeUnary(),\n      startPos,\n      startLoc,\n      prec,\n    );\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return ret;\n  }\n\n  // https://github.com/tc39/proposal-js-module-blocks\n  parseModuleExpression(): N.ModuleExpression {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode<N.ModuleExpression>();\n    this.next(); // eat \"module\"\n    this.eat(tt.braceL);\n\n    const revertScopes = this.initializeScopes(/** inModule */ true);\n    this.enterInitialScopes();\n\n    const program = this.startNode<N.Program>();\n    try {\n      node.body = this.parseProgram(program, tt.braceR, \"module\");\n    } finally {\n      revertScopes();\n    }\n    this.eat(tt.braceR);\n    return this.finishNode<N.ModuleExpression>(node, \"ModuleExpression\");\n  }\n}\n","// @flow\n\nimport * as N from \"../types\";\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\nimport ExpressionParser from \"./expression\";\nimport { Errors } from \"./error\";\nimport {\n  isIdentifierChar,\n  isIdentifierStart,\n  keywordRelationalOperator,\n} from \"../util/identifier\";\nimport { lineBreak } from \"../util/whitespace\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_CLASS,\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  SCOPE_CLASS,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n  SCOPE_SIMPLE_CATCH,\n  SCOPE_STATIC_BLOCK,\n  SCOPE_SUPER,\n  CLASS_ELEMENT_OTHER,\n  CLASS_ELEMENT_INSTANCE_GETTER,\n  CLASS_ELEMENT_INSTANCE_SETTER,\n  CLASS_ELEMENT_STATIC_GETTER,\n  CLASS_ELEMENT_STATIC_SETTER,\n  type BindingTypes,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { PARAM, functionFlags } from \"../util/production-parameter\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope\";\nimport type { SourceType } from \"../options\";\n\nconst loopLabel = { kind: \"loop\" },\n  switchLabel = { kind: \"switch\" };\n\nconst FUNC_NO_FLAGS = 0b000,\n  FUNC_STATEMENT = 0b001,\n  FUNC_HANGING_STATEMENT = 0b010,\n  FUNC_NULLABLE_ID = 0b100;\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nexport default class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(file: N.File, program: N.Program): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) file.tokens = this.tokens;\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    program: N.Program,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (\n      this.inModule &&\n      !this.options.allowUndeclaredExports &&\n      this.scope.undefinedExports.size > 0\n    ) {\n      for (const [name] of Array.from(this.scope.undefinedExports)) {\n        const pos = this.scope.undefinedExports.get(name);\n        // $FlowIssue\n        this.raise(pos, Errors.ModuleExportUndefined, name);\n      }\n    }\n    return this.finishNode<N.Program>(program, \"Program\");\n  }\n\n  // TODO\n\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const expr = stmt.expression;\n\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n\n    directive.value = this.finishNodeAt(\n      directiveLiteral,\n      \"DirectiveLiteral\",\n      expr.end,\n      expr.loc.end,\n    );\n\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context: ?string): boolean {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n    return this.isLetKeyword(context);\n  }\n\n  /**\n   * Assuming we have seen a contextual `let`, check if it starts a variable declaration\n   so that `left` should be interpreted as a `let` keyword.\n   *\n   * @param {?string} context When `context` is non nullish, it will return early and _skip_ checking\n                              if the next token after `let` is `{` or a keyword relational operator\n   * @returns {boolean}\n   * @memberof StatementParser\n   */\n  isLetKeyword(context: ?string): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === charCodes.leftSquareBracket) return true;\n    if (context) return false;\n\n    if (nextCh === charCodes.leftCurlyBrace) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n    return false;\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatement(context: ?string, topLevel?: boolean): N.Statement {\n    if (this.match(tt.at)) {\n      this.parseDecorators(true);\n    }\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context: ?string, topLevel: ?boolean): N.Statement {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = tt._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case tt._break:\n      case tt._continue:\n        // $FlowFixMe\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node);\n      case tt._do:\n        return this.parseDoStatement(node);\n      case tt._for:\n        return this.parseForStatement(node);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, Errors.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, Errors.SloppyFunction);\n          }\n        }\n        return this.parseFunctionStatement(node, false, !context);\n\n      case tt._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case tt._if:\n        return this.parseIfStatement(node);\n      case tt._return:\n        return this.parseReturnStatement(node);\n      case tt._switch:\n        return this.parseSwitchStatement(node);\n      case tt._throw:\n        return this.parseThrowStatement(node);\n      case tt._try:\n        return this.parseTryStatement(node);\n\n      case tt._const:\n      case tt._var:\n        kind = kind || this.state.value;\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, Errors.UnexpectedLexicalDeclaration);\n        }\n        return this.parseVarStatement(node, kind);\n\n      case tt._while:\n        return this.parseWhileStatement(node);\n      case tt._with:\n        return this.parseWithStatement(node);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(this.state.start, Errors.UnexpectedImportExport);\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (starttype === tt._import) {\n          result = this.parseImport(node);\n\n          if (\n            result.type === \"ImportDeclaration\" &&\n            (!result.importKind || result.importKind === \"value\")\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(node);\n\n          if (\n            (result.type === \"ExportNamedDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            (result.type === \"ExportAllDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            result.type === \"ExportDefaultDeclaration\"\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        }\n\n        this.assertModuleNodeAllowed(node);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (context) {\n            this.raise(\n              this.state.start,\n              Errors.AsyncFunctionInSingleStatementContext,\n            );\n          }\n          this.next();\n          return this.parseFunctionStatement(node, true, !context);\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      starttype === tt.name &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raiseWithData(\n        node.start,\n        {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\",\n        },\n        Errors.ImportOutsideModule,\n      );\n    }\n  }\n\n  takeDecorators(node: N.HasDecorators): void {\n    const decorators = this.state.decoratorStack[\n      this.state.decoratorStack.length - 1\n    ];\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(allowExport?: boolean): void {\n    const currentContextDecorators = this.state.decoratorStack[\n      this.state.decoratorStack.length - 1\n    ];\n    while (this.match(tt.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (\n        this.hasPlugin(\"decorators\") &&\n        !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\n      ) {\n        this.raise(this.state.start, Errors.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, Errors.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator(): N.Decorator {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      // Every time a decorator class expression is evaluated, a new empty array is pushed onto the stack\n      // So that the decorators of any nested class expressions will be dealt with separately\n      this.state.decoratorStack.push([]);\n\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.eat(tt.parenL)) {\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: N.BreakStatement | N.ContinueStatement,\n    keyword: string,\n  ): N.BreakStatement | N.ContinueStatement {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: N.BreakStatement | N.ContinueStatement,\n    keyword: string,\n  ) {\n    const isBreak = keyword === \"break\";\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      this.raise(node.start, Errors.IllegalBreakContinue, keyword);\n    }\n  }\n\n  parseDebuggerStatement(node: N.DebuggerStatement): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  parseDoStatement(node: N.DoWhileStatement): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(\"do\"),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(node: N.Node): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = -1;\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n\n    const startsWithLet = this.isContextual(\"let\");\n    const isLet = startsWithLet && this.isLetKeyword();\n    if (this.match(tt._var) || this.match(tt._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if (\n        (this.match(tt._in) || this.isContextual(\"of\")) &&\n        init.declarations.length === 1\n      ) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, init);\n    }\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(\"of\");\n    if (isForOf || this.match(tt._in)) {\n      if (isForOf && startsWithLet) {\n        this.raise(init.start, Errors.ForOfLet);\n      }\n      this.toAssignable(init, /* isLHS */ true);\n      const description = isForOf ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(\n    node: N.FunctionDeclaration,\n    isAsync?: boolean,\n    declarationPosition?: boolean,\n  ): N.FunctionDeclaration {\n    this.next();\n    return this.parseFunction(\n      node,\n      FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT),\n      isAsync,\n    );\n  }\n\n  parseIfStatement(node: N.IfStatement): N.IfStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(tt._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node: N.ReturnStatement): N.ReturnStatement {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, Errors.IllegalReturn);\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node: N.SwitchStatement): N.SwitchStatement {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push((cur = this.startNode()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(\n              this.state.lastTokStart,\n              Errors.MultipleDefaultsInSwitch,\n            );\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node: N.ThrowStatement): N.ThrowStatement {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.lastTokEnd, Errors.NewlineAfterThrow);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, \"catch clause\", BIND_LEXICAL);\n\n    return param;\n  }\n\n  parseTryStatement(node: N.TryStatement): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n      this.scope.exit();\n\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, Errors.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(\n    node: N.VariableDeclaration,\n    kind: \"var\" | \"let\" | \"const\",\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node: N.WhileStatement): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(\"while\"),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node: N.WithStatement): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(this.state.start, Errors.StrictWith);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(\"with\"),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: N.EmptyStatement): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(\n    node: N.LabeledStatement,\n    maybeName: string,\n    expr: N.Identifier,\n    context: ?string,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(expr.start, Errors.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = this.state.type.isLoop\n      ? \"loop\"\n      : this.match(tt._switch)\n      ? \"switch\"\n      : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start,\n    });\n    node.body = this.parseStatement(\n      context\n        ? context.indexOf(\"label\") === -1\n          ? context + \"label\"\n          : context\n        : \"label\",\n    );\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: N.ExpressionStatement,\n    expr: N.Expression,\n  ): N.Statement {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    allowDirectives?: boolean = false,\n    createNewLexicalScope?: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    node: N.BlockStatementLike,\n    allowDirectives: ?boolean,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body = (node.body = []);\n    const directives = (node.directives = []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: ?(N.Directive[]),\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    node: N.ForStatement,\n    init: ?(N.VariableDeclaration | N.Expression),\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(\"for\"),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    node: N.ForInOf,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt: number,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(\n        init.start,\n        Errors.ForInOfLoopInitializer,\n        isForIn ? \"for-in\" : \"for-of\",\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, Errors.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(\"for\"),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    node: N.VariableDeclaration,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\",\n  ): N.VariableDeclaration {\n    const declarations = (node.declarations = []);\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(tt.eq)) {\n        decl.init = isFor\n          ? this.parseMaybeAssignDisallowIn()\n          : this.parseMaybeAssignAllowIn();\n      } else {\n        if (\n          kind === \"const\" &&\n          !(this.match(tt._in) || this.isContextual(\"of\"))\n        ) {\n          // `const` with no initializer is allowed in TypeScript.\n          // It could be a declaration like `const x: number;`.\n          if (!isTypescript) {\n            this.raise(\n              this.state.lastTokEnd,\n              Errors.DeclarationMissingInitializer,\n              \"Const declarations\",\n            );\n          }\n        } else if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(\"of\")))\n        ) {\n          this.raise(\n            this.state.lastTokEnd,\n            Errors.DeclarationMissingInitializer,\n            \"Complex binding patterns\",\n          );\n        }\n        decl.init = null;\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(decl: N.VariableDeclarator, kind: \"var\" | \"let\" | \"const\"): void {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(\n      decl.id,\n      \"variable declaration\",\n      kind === \"var\" ? BIND_VAR : BIND_LEXICAL,\n      undefined,\n      kind !== \"var\",\n    );\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseFunction<T: N.NormalFunction>(\n    node: T,\n    statement?: number = FUNC_NO_FLAGS,\n    isAsync?: boolean = false,\n  ): T {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star) && isHangingStatement) {\n      this.raise(this.state.start, Errors.GeneratorInSingleStatementContext);\n    }\n    node.generator = this.eat(tt.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* allowModifiers */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId?: boolean): ?N.Identifier {\n    return requireId || this.match(tt.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      /* allowEmpty */ false,\n      allowModifiers,\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BIND_VAR\n          : BIND_LEXICAL\n        : BIND_FUNCTION,\n      node.id.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T: N.Class>(\n    node: T,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next();\n    this.takeDecorators(node);\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed &&\n      !method.static &&\n      (method.key.name === \"constructor\" || // Identifier\n        method.key.value === \"constructor\") // String literal\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(\n    constructorAllowsSuper: boolean,\n    oldStrict: boolean,\n  ): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      constructorAllowsSuper,\n      hadConstructor: false,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody: N.ClassBody = this.startNode();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withTopicForbiddingContext(() => {\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, Errors.DecoratorSemicolon);\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          member.kind === \"constructor\" &&\n          member.decorators &&\n          member.decorators.length > 0\n        ) {\n          this.raise(member.start, Errors.DecoratorConstructor);\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, Errors.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    classBody: N.ClassBody,\n    member: N.ClassMember,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = (member: any);\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = (member: any);\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    return false;\n  }\n\n  parseClassMember(\n    classBody: N.ClassBody,\n    member: N.ClassMember,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(\"static\");\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, ((member: any): N.StaticBlock));\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    classBody: N.ClassBody,\n    member: N.ClassMember,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod: $FlowSubtype<N.ClassMethod> = member;\n    const privateMethod: $FlowSubtype<N.ClassPrivateMethod> = member;\n    const publicProp: $FlowSubtype<N.ClassMethod> = member;\n    const privateProp: $FlowSubtype<N.ClassPrivateMethod> = member;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      this.parseClassElementName(method);\n\n      if (this.isPrivateName(method.key)) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, Errors.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassElementName(member);\n    const isPrivate = this.isPrivateName(key);\n    // Check the key is not a computed expression or string literal.\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, Errors.DuplicateConstructor);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (\n      isSimple &&\n      key.name === \"async\" &&\n      !containsEsc &&\n      !this.isLineTerminator()\n    ) {\n      // an async method\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (this.isPrivateName(method.key)) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      isSimple &&\n      (key.name === \"get\" || key.name === \"set\") &&\n      !containsEsc &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      method.kind = key.name;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      this.parseClassElementName(publicMethod);\n\n      if (this.isPrivateName(method.key)) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAccessor);\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/proposal-class-fields/#prod-ClassElementName\n  parseClassElementName(member: N.ClassMember): N.Expression | N.Identifier {\n    const key = this.parsePropertyName(member, /* isPrivateNameAllowed */ true);\n\n    if (\n      !member.computed &&\n      member.static &&\n      ((key: $FlowSubtype<N.Identifier>).name === \"prototype\" ||\n        (key: $FlowSubtype<N.StringLiteral>).value === \"prototype\")\n    ) {\n      this.raise(key.start, Errors.StaticPrototype);\n    }\n\n    if (\n      this.isPrivateName(key) &&\n      this.getPrivateNameSV(key) === \"constructor\"\n    ) {\n      this.raise(key.start, Errors.ConstructorClassPrivateField);\n    }\n\n    return key;\n  }\n\n  parseClassStaticBlock(\n    classBody: N.ClassBody,\n    member: N.StaticBlock & { decorators?: Array<N.Decorator> },\n  ) {\n    this.expectPlugin(\"classStaticBlock\", member.start);\n    // Start a new lexical scope\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(PARAM);\n    const body = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(member.start, Errors.DecoratorStaticBlock);\n    }\n  }\n\n  pushClassProperty(classBody: N.ClassBody, prop: N.ClassProperty) {\n    if (\n      !prop.computed &&\n      (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")\n    ) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(prop.key.start, Errors.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    classBody: N.ClassBody,\n    prop: N.ClassPrivateProperty,\n  ) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      CLASS_ELEMENT_OTHER,\n      node.key.start,\n    );\n  }\n\n  pushClassMethod(\n    classBody: N.ClassBody,\n    method: N.ClassMethod,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    classBody: N.ClassBody,\n    method: N.ClassPrivateMethod,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_GETTER\n          : CLASS_ELEMENT_INSTANCE_GETTER\n        : node.kind === \"set\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_SETTER\n          : CLASS_ELEMENT_INSTANCE_SETTER\n        : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      kind,\n      node.key.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line no-unused-vars\n    methodOrProp: N.ClassMethod | N.ClassProperty,\n  ): void {}\n\n  // https://tc39.es/proposal-class-fields/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    node: N.ClassPrivateProperty,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/proposal-class-fields/#prod-FieldDefinition\n  parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n    if (!node.typeAnnotation || this.match(tt.eq)) {\n      this.expectPlugin(\"classProperties\");\n    }\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  // https://tc39.es/proposal-class-fields/#prod-Initializer\n  parseInitializer(node: N.ClassProperty | N.ClassPrivateProperty): void {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId: ?boolean,\n    bindingType: BindingTypes = BIND_CLASS,\n  ): void {\n    if (this.match(tt.name)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.checkLVal(node.id, \"class name\", bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, Errors.MissingClassName);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(node: N.Class): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(node: N.Node): N.AnyExport {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace =\n      hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (\n      (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||\n      (hasNamespace && parseAfterNamespace && !hasSpecifiers)\n    ) {\n      throw this.unexpected(null, tt.braceL);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      // export default ...\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, tt.braceL);\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  eatExportStar(node: N.Node): boolean {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n    if (this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n\n      const specifier = this.startNodeAt(\n        this.state.lastTokStart,\n        this.state.lastTokStartLoc,\n      );\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\n    if (this.match(tt.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n\n      node.source = null;\n      node.declaration = null;\n\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(node: N.Node): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return (\n      !lineBreak.test(this.input.slice(this.state.pos, next)) &&\n      this.isUnparsedContextual(next, \"function\")\n    );\n  }\n\n  parseExportDefaultExpression(): N.Expression | N.Declaration {\n    const expr = this.startNode();\n\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(tt._function) || isAsync) {\n      this.next();\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(\n        expr,\n        FUNC_STATEMENT | FUNC_NULLABLE_ID,\n        isAsync,\n      );\n    } else if (this.match(tt._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\n      ) {\n        this.raise(this.state.start, Errors.DecoratorBeforeExport);\n      }\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(this.state.start, Errors.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssignAllowIn();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    if (this.match(tt.name)) {\n      const value = this.state.value;\n      if ((value === \"async\" && !this.state.containsEsc) || value === \"let\") {\n        return false;\n      }\n      if (\n        (value === \"type\" || value === \"interface\") &&\n        !this.state.containsEsc\n      ) {\n        const l = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (l.type === tt.name && l.value !== \"from\") ||\n          l.type === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (this.match(tt.name) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(node: N.ExportNamedDeclaration, expect?: boolean): void {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    if (this.match(tt.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, Errors.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return (\n      this.state.type.keyword === \"var\" ||\n      this.state.type.keyword === \"const\" ||\n      this.state.type.keyword === \"function\" ||\n      this.state.type.keyword === \"class\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: N.ExportNamedDeclaration,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = ((node: any): N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(declaration.start, Errors.ExportDefaultFromAsIdentifier);\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        // Named exports\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportedName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportedName);\n          // $FlowIgnore\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type === \"StringLiteral\") {\n              this.raise(\n                specifier.start,\n                Errors.ExportBindingIsString,\n                local.value,\n                exportedName,\n              );\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (\n          node.declaration.type === \"FunctionDeclaration\" ||\n          node.declaration.type === \"ClassDeclaration\"\n        ) {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[\n      this.state.decoratorStack.length - 1\n    ];\n    // If node.declaration is a class, it will take all decorators in the current context.\n    // Thus we should throw if we see non-empty decorators here.\n    if (currentContextDecorators.length) {\n      throw this.raise(node.start, Errors.UnsupportedDecoratorExport);\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node:\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier,\n    name: string,\n  ): void {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(\n        node.start,\n        name === \"default\"\n          ? Errors.DuplicateDefaultExport\n          : Errors.DuplicateExport,\n        name,\n      );\n    }\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      node.exported = this.eatContextual(\"as\")\n        ? this.parseModuleExportName()\n        : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      this.expectPlugin(\"moduleStringNames\");\n      const result = this.parseLiteral<N.StringLiteral>(\n        this.state.value,\n        \"StringLiteral\",\n      );\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(\n          result.start,\n          Errors.ModuleExportNameHasLoneSurrogate,\n          surrogate[0].charCodeAt(0).toString(16),\n        );\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(node: N.Node): N.AnyImport {\n    // import '...'\n    node.specifiers = [];\n    if (!this.match(tt.string)) {\n      // check if we have a default import like\n      // import React from \"react\";\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      /* we are checking if we do not have a default import, then it is obvious that we need named imports\n       * import { get } from \"axios\";\n       * but if we do have a default import\n       * we need to check if we have a comma after that and\n       * that is where this `|| this.eat` condition comes into play\n       */\n      const parseNext = !hasDefault || this.eat(tt.comma);\n      // if we do have to parse the next set of specifiers, we first check for star imports\n      // import React, * from \"react\";\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      // now we check if we need to parse the next imports\n      // but only if they are not importing * (everything)\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n    node.source = this.parseImportSource();\n    // https://github.com/tc39/proposal-import-assertions\n    // parse module import assertions if the next token is `assert` or ignore\n    // and finish the ImportDeclaration node.\n    const assertions = this.maybeParseImportAssertions();\n    if (assertions) {\n      node.assertions = assertions;\n    }\n    // todo(Babel 8): remove module attributes support\n    else {\n      const attributes = this.maybeParseModuleAttributes();\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\n    return this.match(tt.name);\n  }\n\n  parseImportSpecifierLocal(\n    node: N.ImportDeclaration,\n    specifier: N.Node,\n    type: string,\n    contextDescription: string,\n  ): void {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-assertions/#prod-AssertEntries |AssertEntries}\n   * @returns {N.ImportAttribute[]}\n   * @memberof StatementParser\n   */\n  parseAssertEntries(): N.ImportAttribute[] {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      if (this.match(tt.string)) {\n        node.key = this.parseLiteral<N.StringLiteral>(keyName, \"StringLiteral\");\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      // for now we are only allowing `type` as the only allowed module attribute\n      if (keyName !== \"type\") {\n        this.raise(\n          node.key.start,\n          Errors.ModuleAttributeDifferentFromType,\n          keyName,\n        );\n      }\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(\n          node.key.start,\n          Errors.ModuleAttributesWithDuplicateKeys,\n          keyName,\n        );\n      }\n      attrNames.add(keyName);\n\n      if (!this.match(tt.string)) {\n        throw this.unexpected(\n          this.state.start,\n          Errors.ModuleAttributeInvalidValue,\n        );\n      }\n      node.value = this.parseLiteral<N.StringLiteral>(\n        this.state.value,\n        \"StringLiteral\",\n      );\n      this.finishNode<N.ImportAttribute>(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   * @returns\n   * @memberof StatementParser\n   */\n  maybeParseModuleAttributes() {\n    if (this.match(tt._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(\n          node.key.start,\n          Errors.ModuleAttributeDifferentFromType,\n          node.key.name,\n        );\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(\n          node.key.start,\n          Errors.ModuleAttributesWithDuplicateKeys,\n          node.key.name,\n        );\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.unexpected(\n          this.state.start,\n          Errors.ModuleAttributeInvalidValue,\n        );\n      }\n      node.value = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    // [no LineTerminator here] AssertClause\n    if (this.isContextual(\"assert\") && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next(); // eat `assert`\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n    // https://tc39.es/proposal-import-assertions/#prod-AssertClause\n    this.eat(tt.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(tt.braceR);\n\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\n    if (this.shouldParseDefaultImport(node)) {\n      // import defaultObj, { x, y as z } from '...'\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode(),\n        \"ImportDefaultSpecifier\",\n        \"default import specifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: N.ImportDeclaration): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n        \"import namespace specifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: N.ImportDeclaration) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(this.state.start, Errors.DestructureNamedImport);\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(node: N.ImportDeclaration): void {\n    const specifier = this.startNode();\n    specifier.imported = this.parseModuleExportName();\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (imported.type === \"StringLiteral\") {\n        throw this.raise(\n          specifier.start,\n          Errors.ImportBindingIsString,\n          imported.value,\n        );\n      }\n      this.checkReservedWord(imported.name, specifier.start, true, true);\n      specifier.local = imported.__clone();\n    }\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n}\n","// @flow\n\nimport type { Options } from \"../options\";\nimport type { File /*::, JSXOpeningElement */ } from \"../types\";\nimport type { PluginList } from \"../plugin-utils\";\nimport { getOptions } from \"../options\";\nimport StatementParser from \"./statement\";\nimport ScopeHandler from \"../util/scope\";\n\nexport type PluginsMap = Map<string, { [string]: any }>;\n\nexport default class Parser extends StatementParser {\n  // Forward-declaration so typescript plugin can override jsx plugin\n  /*::\n  +jsxParseOpeningElementAfterName: (\n    node: JSXOpeningElement,\n  ) => JSXOpeningElement;\n  */\n\n  constructor(options: ?Options, input: string) {\n    options = getOptions(options);\n    super(options, input);\n\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  // This can be overwritten, for example, by the TypeScript plugin.\n  getScopeHandler(): Class<ScopeHandler<*>> {\n    return ScopeHandler;\n  }\n\n  parse(): File {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n}\n\nfunction pluginsMap(plugins: PluginList): PluginsMap {\n  const pluginMap: PluginsMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\n","// @flow\n\nimport { type Options } from \"./options\";\nimport {\n  hasPlugin,\n  validatePlugins,\n  mixinPluginNames,\n  mixinPlugins,\n  type PluginList,\n} from \"./plugin-utils\";\nimport Parser from \"./parser\";\n\nimport { types as tokTypes } from \"./tokenizer/types\";\nimport \"./tokenizer/context\";\n\nimport type { Expression, File } from \"./types\";\n\nexport function parse(input: string, options?: Options): File {\n  if (options?.sourceType === \"unambiguous\") {\n    options = {\n      ...options,\n    };\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        // Top level await introduces code which can be both a valid script and\n        // a valid module, but which produces different ASTs:\n        //    await\n        //    0\n        // can be parsed either as an AwaitExpression, or as two ExpressionStatements.\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch {}\n      } else {\n        // This is both a valid module and a valid script, but\n        // we parse it as a script by default\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\n\nexport function parseExpression(input: string, options?: Options): Expression {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\n\nexport { tokTypes };\n\nfunction getParser(options: ?Options, input: string): Parser {\n  let cls = Parser;\n  if (options?.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache: { [key: string]: Class<Parser> } = {};\n\n/** Get a Parser class with plugins applied. */\nfunction getParserClass(pluginsFromOptions: PluginList): Class<Parser> {\n  const pluginList = mixinPluginNames.filter(name =>\n    hasPlugin(pluginsFromOptions, name),\n  );\n\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = global || self, factory(global.estreeWalker = {}));\n}(this, (function (exports) { 'use strict';\n\n\t// @ts-check\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\n\t/** @typedef {{\n\t\tskip: () => void;\n\t\tremove: () => void;\n\t\treplace: (node: BaseNode) => void;\n\t}} WalkerContext */\n\n\tclass WalkerBase {\n\t\tconstructor() {\n\t\t\t/** @type {boolean} */\n\t\t\tthis.should_skip = false;\n\n\t\t\t/** @type {boolean} */\n\t\t\tthis.should_remove = false;\n\n\t\t\t/** @type {BaseNode | null} */\n\t\t\tthis.replacement = null;\n\n\t\t\t/** @type {WalkerContext} */\n\t\t\tthis.context = {\n\t\t\t\tskip: () => (this.should_skip = true),\n\t\t\t\tremove: () => (this.should_remove = true),\n\t\t\t\treplace: (node) => (this.replacement = node)\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {any} parent\n\t\t * @param {string} prop\n\t\t * @param {number} index\n\t\t * @param {BaseNode} node\n\t\t */\n\t\treplace(parent, prop, index, node) {\n\t\t\tif (parent) {\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tparent[prop][index] = node;\n\t\t\t\t} else {\n\t\t\t\t\tparent[prop] = node;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {any} parent\n\t\t * @param {string} prop\n\t\t * @param {number} index\n\t\t */\n\t\tremove(parent, prop, index) {\n\t\t\tif (parent) {\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t\t} else {\n\t\t\t\t\tdelete parent[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./walker.js').WalkerContext} WalkerContext */\n\n\t/** @typedef {(\n\t *    this: WalkerContext,\n\t *    node: BaseNode,\n\t *    parent: BaseNode,\n\t *    key: string,\n\t *    index: number\n\t * ) => void} SyncHandler */\n\n\tclass SyncWalker extends WalkerBase {\n\t\t/**\n\t\t *\n\t\t * @param {SyncHandler} enter\n\t\t * @param {SyncHandler} leave\n\t\t */\n\t\tconstructor(enter, leave) {\n\t\t\tsuper();\n\n\t\t\t/** @type {SyncHandler} */\n\t\t\tthis.enter = enter;\n\n\t\t\t/** @type {SyncHandler} */\n\t\t\tthis.leave = leave;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {BaseNode} node\n\t\t * @param {BaseNode} parent\n\t\t * @param {string} [prop]\n\t\t * @param {number} [index]\n\t\t * @returns {BaseNode}\n\t\t */\n\t\tvisit(node, parent, prop, index) {\n\t\t\tif (node) {\n\t\t\t\tif (this.enter) {\n\t\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tthis.should_skip = false;\n\t\t\t\t\tthis.should_remove = false;\n\t\t\t\t\tthis.replacement = null;\n\n\t\t\t\t\tthis.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\t\tif (skipped) return node;\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\n\t\t\t\tfor (const key in node) {\n\t\t\t\t\tconst value = node[key];\n\n\t\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\t\tif (!this.visit(value[i], node, key, i)) {\n\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\t\tthis.visit(value, node, key, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.leave) {\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tthis.replacement = null;\n\t\t\t\t\tthis.should_remove = false;\n\n\t\t\t\t\tthis.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.replacement = _replacement;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./walker').WalkerContext} WalkerContext */\n\n\t/** @typedef {(\n\t *    this: WalkerContext,\n\t *    node: BaseNode,\n\t *    parent: BaseNode,\n\t *    key: string,\n\t *    index: number\n\t * ) => Promise<void>} AsyncHandler */\n\n\tclass AsyncWalker extends WalkerBase {\n\t\t/**\n\t\t *\n\t\t * @param {AsyncHandler} enter\n\t\t * @param {AsyncHandler} leave\n\t\t */\n\t\tconstructor(enter, leave) {\n\t\t\tsuper();\n\n\t\t\t/** @type {AsyncHandler} */\n\t\t\tthis.enter = enter;\n\n\t\t\t/** @type {AsyncHandler} */\n\t\t\tthis.leave = leave;\n\t\t}\n\n\t\t/**\n\t\t *\n\t\t * @param {BaseNode} node\n\t\t * @param {BaseNode} parent\n\t\t * @param {string} [prop]\n\t\t * @param {number} [index]\n\t\t * @returns {Promise<BaseNode>}\n\t\t */\n\t\tasync visit(node, parent, prop, index) {\n\t\t\tif (node) {\n\t\t\t\tif (this.enter) {\n\t\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tthis.should_skip = false;\n\t\t\t\t\tthis.should_remove = false;\n\t\t\t\t\tthis.replacement = null;\n\n\t\t\t\t\tawait this.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\t\tif (skipped) return node;\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\n\t\t\t\tfor (const key in node) {\n\t\t\t\t\tconst value = node[key];\n\n\t\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\t\tif (!(await this.visit(value[i], node, key, i))) {\n\t\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\t\tawait this.visit(value, node, key, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.leave) {\n\t\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\t\tthis.replacement = null;\n\t\t\t\t\tthis.should_remove = false;\n\n\t\t\t\t\tawait this.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\t\tif (this.replacement) {\n\t\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.should_remove) {\n\t\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\t\tthis.replacement = _replacement;\n\t\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\t\tif (removed) return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t// @ts-check\n\n\t/** @typedef { import('estree').BaseNode} BaseNode */\n\t/** @typedef { import('./sync.js').SyncHandler} SyncHandler */\n\t/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */\n\n\t/**\n\t *\n\t * @param {BaseNode} ast\n\t * @param {{\n\t *   enter?: SyncHandler\n\t *   leave?: SyncHandler\n\t * }} walker\n\t * @returns {BaseNode}\n\t */\n\tfunction walk(ast, { enter, leave }) {\n\t\tconst instance = new SyncWalker(enter, leave);\n\t\treturn instance.visit(ast, null);\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} ast\n\t * @param {{\n\t *   enter?: AsyncHandler\n\t *   leave?: AsyncHandler\n\t * }} walker\n\t * @returns {Promise<BaseNode>}\n\t */\n\tasync function asyncWalk(ast, { enter, leave }) {\n\t\tconst instance = new AsyncWalker(enter, leave);\n\t\treturn await instance.visit(ast, null);\n\t}\n\n\texports.asyncWalk = asyncWalk;\n\texports.walk = walk;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/runtime-dom.cjs.prod.js')\n} else {\n  module.exports = require('./dist/runtime-dom.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar runtimeCore = require('@vue/runtime-core');\nvar shared = require('@vue/shared');\n\nconst svgNS = 'http://www.w3.org/2000/svg';\r\nconst doc = (typeof document !== 'undefined' ? document : null);\r\nlet tempContainer;\r\nlet tempSVGContainer;\r\nconst nodeOps = {\r\n    insert: (child, parent, anchor) => {\r\n        parent.insertBefore(child, anchor || null);\r\n    },\r\n    remove: child => {\r\n        const parent = child.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(child);\r\n        }\r\n    },\r\n    createElement: (tag, isSVG, is, props) => {\r\n        const el = isSVG\r\n            ? doc.createElementNS(svgNS, tag)\r\n            : doc.createElement(tag, is ? { is } : undefined);\r\n        if (tag === 'select' && props && props.multiple != null) {\r\n            el.setAttribute('multiple', props.multiple);\r\n        }\r\n        return el;\r\n    },\r\n    createText: text => doc.createTextNode(text),\r\n    createComment: text => doc.createComment(text),\r\n    setText: (node, text) => {\r\n        node.nodeValue = text;\r\n    },\r\n    setElementText: (el, text) => {\r\n        el.textContent = text;\r\n    },\r\n    parentNode: node => node.parentNode,\r\n    nextSibling: node => node.nextSibling,\r\n    querySelector: selector => doc.querySelector(selector),\r\n    setScopeId(el, id) {\r\n        el.setAttribute(id, '');\r\n    },\r\n    cloneNode(el) {\r\n        const cloned = el.cloneNode(true);\r\n        // #3072\r\n        // - in `patchDOMProp`, we store the actual value in the `el._value` property.\r\n        // - normally, elements using `:value` bindings will not be hoisted, but if\r\n        //   the bound value is a constant, e.g. `:value=\"true\"` - they do get\r\n        //   hoisted.\r\n        // - in production, hoisted nodes are cloned when subsequent inserts, but\r\n        //   cloneNode() does not copy the custom property we attached.\r\n        // - This may need to account for other custom DOM properties we attach to\r\n        //   elements in addition to `_value` in the future.\r\n        if (`_value` in el) {\r\n            cloned._value = el._value;\r\n        }\r\n        return cloned;\r\n    },\r\n    // __UNSAFE__\r\n    // Reason: innerHTML.\r\n    // Static content here can only come from compiled templates.\r\n    // As long as the user only uses trusted templates, this is safe.\r\n    insertStaticContent(content, parent, anchor, isSVG) {\r\n        const temp = isSVG\r\n            ? tempSVGContainer ||\r\n                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))\r\n            : tempContainer || (tempContainer = doc.createElement('div'));\r\n        temp.innerHTML = content;\r\n        const first = temp.firstChild;\r\n        let node = first;\r\n        let last = node;\r\n        while (node) {\r\n            last = node;\r\n            nodeOps.insert(node, parent, anchor);\r\n            node = temp.firstChild;\r\n        }\r\n        return [first, last];\r\n    }\r\n};\n\n// compiler should normalize class + :class bindings on the same element\r\n// into a single binding ['staticClass', dynamic]\r\nfunction patchClass(el, value, isSVG) {\r\n    if (value == null) {\r\n        value = '';\r\n    }\r\n    if (isSVG) {\r\n        el.setAttribute('class', value);\r\n    }\r\n    else {\r\n        // directly setting className should be faster than setAttribute in theory\r\n        // if this is an element during a transition, take the temporary transition\r\n        // classes into account.\r\n        const transitionClasses = el._vtc;\r\n        if (transitionClasses) {\r\n            value = (value\r\n                ? [value, ...transitionClasses]\r\n                : [...transitionClasses]).join(' ');\r\n        }\r\n        el.className = value;\r\n    }\r\n}\n\nfunction patchStyle(el, prev, next) {\r\n    const style = el.style;\r\n    if (!next) {\r\n        el.removeAttribute('style');\r\n    }\r\n    else if (shared.isString(next)) {\r\n        if (prev !== next) {\r\n            const current = style.display;\r\n            style.cssText = next;\r\n            // indicates that the `display` of the element is controlled by `v-show`,\r\n            // so we always keep the current `display` value regardless of the `style` value,\r\n            // thus handing over control to `v-show`.\r\n            if ('_vod' in el) {\r\n                style.display = current;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (const key in next) {\r\n            setStyle(style, key, next[key]);\r\n        }\r\n        if (prev && !shared.isString(prev)) {\r\n            for (const key in prev) {\r\n                if (next[key] == null) {\r\n                    setStyle(style, key, '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst importantRE = /\\s*!important$/;\r\nfunction setStyle(style, name, val) {\r\n    if (shared.isArray(val)) {\r\n        val.forEach(v => setStyle(style, name, v));\r\n    }\r\n    else {\r\n        if (name.startsWith('--')) {\r\n            // custom property definition\r\n            style.setProperty(name, val);\r\n        }\r\n        else {\r\n            const prefixed = autoPrefix(style, name);\r\n            if (importantRE.test(val)) {\r\n                // !important\r\n                style.setProperty(shared.hyphenate(prefixed), val.replace(importantRE, ''), 'important');\r\n            }\r\n            else {\r\n                style[prefixed] = val;\r\n            }\r\n        }\r\n    }\r\n}\r\nconst prefixes = ['Webkit', 'Moz', 'ms'];\r\nconst prefixCache = {};\r\nfunction autoPrefix(style, rawName) {\r\n    const cached = prefixCache[rawName];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    let name = runtimeCore.camelize(rawName);\r\n    if (name !== 'filter' && name in style) {\r\n        return (prefixCache[rawName] = name);\r\n    }\r\n    name = shared.capitalize(name);\r\n    for (let i = 0; i < prefixes.length; i++) {\r\n        const prefixed = prefixes[i] + name;\r\n        if (prefixed in style) {\r\n            return (prefixCache[rawName] = prefixed);\r\n        }\r\n    }\r\n    return rawName;\r\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\r\nfunction patchAttr(el, key, value, isSVG) {\r\n    if (isSVG && key.startsWith('xlink:')) {\r\n        if (value == null) {\r\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        // note we are only checking boolean attributes that don't have a\r\n        // corresponding dom prop of the same name here.\r\n        const isBoolean = shared.isSpecialBooleanAttr(key);\r\n        if (value == null || (isBoolean && value === false)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, isBoolean ? '' : value);\r\n        }\r\n    }\r\n}\n\n// __UNSAFE__\r\n// functions. The user is responsible for using them with only trusted content.\r\nfunction patchDOMProp(el, key, value, \r\n// the following args are passed only due to potential innerHTML/textContent\r\n// overriding existing VNodes, in which case the old tree must be properly\r\n// unmounted.\r\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\r\n    if (key === 'innerHTML' || key === 'textContent') {\r\n        if (prevChildren) {\r\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\r\n        }\r\n        el[key] = value == null ? '' : value;\r\n        return;\r\n    }\r\n    if (key === 'value' && el.tagName !== 'PROGRESS') {\r\n        // store value as _value as well since\r\n        // non-string values will be stringified.\r\n        el._value = value;\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n        return;\r\n    }\r\n    if (value === '' || value == null) {\r\n        const type = typeof el[key];\r\n        if (value === '' && type === 'boolean') {\r\n            // e.g. <select multiple> compiles to { multiple: '' }\r\n            el[key] = true;\r\n            return;\r\n        }\r\n        else if (value == null && type === 'string') {\r\n            // e.g. <div :id=\"null\">\r\n            el[key] = '';\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n        else if (type === 'number') {\r\n            // e.g. <img :width=\"null\">\r\n            el[key] = 0;\r\n            el.removeAttribute(key);\r\n            return;\r\n        }\r\n    }\r\n    // some properties perform value validation and throw\r\n    try {\r\n        el[key] = value;\r\n    }\r\n    catch (e) {\r\n    }\r\n}\n\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nlet _getNow = Date.now;\r\nlet skipTimestampCheck = false;\r\nif (typeof window !== 'undefined') {\r\n    // Determine what event timestamp the browser is using. Annoyingly, the\r\n    // timestamp can either be hi-res (relative to page load) or low-res\r\n    // (relative to UNIX epoch), so in order to compare time we have to use the\r\n    // same timestamp type when saving the flush timestamp.\r\n    if (_getNow() > document.createEvent('Event').timeStamp) {\r\n        // if the low-res timestamp which is bigger than the event timestamp\r\n        // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\r\n        // and we need to use the hi-res version for event listeners as well.\r\n        _getNow = () => performance.now();\r\n    }\r\n    // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation\r\n    // and does not fire microtasks in between event propagation, so safe to exclude.\r\n    const ffMatch = navigator.userAgent.match(/firefox\\/(\\d+)/i);\r\n    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);\r\n}\r\n// To avoid the overhead of repeatedly calling performance.now(), we cache\r\n// and use the same timestamp for all event listeners attached in the same tick.\r\nlet cachedNow = 0;\r\nconst p = Promise.resolve();\r\nconst reset = () => {\r\n    cachedNow = 0;\r\n};\r\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));\r\nfunction addEventListener(el, event, handler, options) {\r\n    el.addEventListener(event, handler, options);\r\n}\r\nfunction removeEventListener(el, event, handler, options) {\r\n    el.removeEventListener(event, handler, options);\r\n}\r\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\r\n    // vei = vue event invokers\r\n    const invokers = el._vei || (el._vei = {});\r\n    const existingInvoker = invokers[rawName];\r\n    if (nextValue && existingInvoker) {\r\n        // patch\r\n        existingInvoker.value = nextValue;\r\n    }\r\n    else {\r\n        const [name, options] = parseName(rawName);\r\n        if (nextValue) {\r\n            // add\r\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\r\n            addEventListener(el, name, invoker, options);\r\n        }\r\n        else if (existingInvoker) {\r\n            // remove\r\n            removeEventListener(el, name, existingInvoker, options);\r\n            invokers[rawName] = undefined;\r\n        }\r\n    }\r\n}\r\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\r\nfunction parseName(name) {\r\n    let options;\r\n    if (optionsModifierRE.test(name)) {\r\n        options = {};\r\n        let m;\r\n        while ((m = name.match(optionsModifierRE))) {\r\n            name = name.slice(0, name.length - m[0].length);\r\n            options[m[0].toLowerCase()] = true;\r\n        }\r\n    }\r\n    return [shared.hyphenate(name.slice(2)), options];\r\n}\r\nfunction createInvoker(initialValue, instance) {\r\n    const invoker = (e) => {\r\n        // async edge case #6566: inner click event triggers patch, event handler\r\n        // attached to outer element during patch, and triggered again. This\r\n        // happens because browsers fire microtask ticks between event propagation.\r\n        // the solution is simple: we save the timestamp when a handler is attached,\r\n        // and the handler would only fire if the event passed to it was fired\r\n        // AFTER it was attached.\r\n        const timeStamp = e.timeStamp || _getNow();\r\n        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {\r\n            runtimeCore.callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);\r\n        }\r\n    };\r\n    invoker.value = initialValue;\r\n    invoker.attached = getNow();\r\n    return invoker;\r\n}\r\nfunction patchStopImmediatePropagation(e, value) {\r\n    if (shared.isArray(value)) {\r\n        const originalStop = e.stopImmediatePropagation;\r\n        e.stopImmediatePropagation = () => {\r\n            originalStop.call(e);\r\n            e._stopped = true;\r\n        };\r\n        return value.map(fn => (e) => !e._stopped && fn(e));\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\n\nconst nativeOnRE = /^on[a-z]/;\r\nconst forcePatchProp = (_, key) => key === 'value';\r\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\r\n    switch (key) {\r\n        // special\r\n        case 'class':\r\n            patchClass(el, nextValue, isSVG);\r\n            break;\r\n        case 'style':\r\n            patchStyle(el, prevValue, nextValue);\r\n            break;\r\n        default:\r\n            if (shared.isOn(key)) {\r\n                // ignore v-model listeners\r\n                if (!shared.isModelListener(key)) {\r\n                    patchEvent(el, key, prevValue, nextValue, parentComponent);\r\n                }\r\n            }\r\n            else if (shouldSetAsProp(el, key, nextValue, isSVG)) {\r\n                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\r\n            }\r\n            else {\r\n                // special case for <input v-model type=\"checkbox\"> with\r\n                // :true-value & :false-value\r\n                // store value as dom properties since non-string values will be\r\n                // stringified.\r\n                if (key === 'true-value') {\r\n                    el._trueValue = nextValue;\r\n                }\r\n                else if (key === 'false-value') {\r\n                    el._falseValue = nextValue;\r\n                }\r\n                patchAttr(el, key, nextValue, isSVG);\r\n            }\r\n            break;\r\n    }\r\n};\r\nfunction shouldSetAsProp(el, key, value, isSVG) {\r\n    if (isSVG) {\r\n        // most keys must be set as attribute on svg elements to work\r\n        // ...except innerHTML\r\n        if (key === 'innerHTML') {\r\n            return true;\r\n        }\r\n        // or native onclick with function values\r\n        if (key in el && nativeOnRE.test(key) && shared.isFunction(value)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // spellcheck and draggable are numerated attrs, however their\r\n    // corresponding DOM properties are actually booleans - this leads to\r\n    // setting it with a string \"false\" value leading it to be coerced to\r\n    // `true`, so we need to always treat them as attributes.\r\n    // Note that `contentEditable` doesn't have this problem: its DOM\r\n    // property is also enumerated string values.\r\n    if (key === 'spellcheck' || key === 'draggable') {\r\n        return false;\r\n    }\r\n    // #1787, #2840 form property on form elements is readonly and must be set as\r\n    // attribute.\r\n    if (key === 'form') {\r\n        return false;\r\n    }\r\n    // #1526 <input list> must be set as attribute\r\n    if (key === 'list' && el.tagName === 'INPUT') {\r\n        return false;\r\n    }\r\n    // #2766 <textarea type> must be set as attribute\r\n    if (key === 'type' && el.tagName === 'TEXTAREA') {\r\n        return false;\r\n    }\r\n    // native onclick with string value, must be set as attribute\r\n    if (nativeOnRE.test(key) && shared.isString(value)) {\r\n        return false;\r\n    }\r\n    return key in el;\r\n}\n\nfunction useCssModule(name = '$style') {\r\n    /* istanbul ignore else */\r\n    {\r\n        const instance = runtimeCore.getCurrentInstance();\r\n        if (!instance) {\r\n            return shared.EMPTY_OBJ;\r\n        }\r\n        const modules = instance.type.__cssModules;\r\n        if (!modules) {\r\n            return shared.EMPTY_OBJ;\r\n        }\r\n        const mod = modules[name];\r\n        if (!mod) {\r\n            return shared.EMPTY_OBJ;\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    return;\r\n}\n\nconst TRANSITION = 'transition';\r\nconst ANIMATION = 'animation';\r\n// DOM Transition is a higher-order-component based on the platform-agnostic\r\n// base Transition component, with DOM-specific logic.\r\nconst Transition = (props, { slots }) => runtimeCore.h(runtimeCore.BaseTransition, resolveTransitionProps(props), slots);\r\nTransition.displayName = 'Transition';\r\nconst DOMTransitionPropsValidators = {\r\n    name: String,\r\n    type: String,\r\n    css: {\r\n        type: Boolean,\r\n        default: true\r\n    },\r\n    duration: [String, Number, Object],\r\n    enterFromClass: String,\r\n    enterActiveClass: String,\r\n    enterToClass: String,\r\n    appearFromClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    leaveFromClass: String,\r\n    leaveActiveClass: String,\r\n    leaveToClass: String\r\n};\r\nconst TransitionPropsValidators = (Transition.props = /*#__PURE__*/ shared.extend({}, runtimeCore.BaseTransition.props, DOMTransitionPropsValidators));\r\nfunction resolveTransitionProps(rawProps) {\r\n    let { name = 'v', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\r\n    const baseProps = {};\r\n    for (const key in rawProps) {\r\n        if (!(key in DOMTransitionPropsValidators)) {\r\n            baseProps[key] = rawProps[key];\r\n        }\r\n    }\r\n    if (!css) {\r\n        return baseProps;\r\n    }\r\n    const durations = normalizeDuration(duration);\r\n    const enterDuration = durations && durations[0];\r\n    const leaveDuration = durations && durations[1];\r\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\r\n    const finishEnter = (el, isAppear, done) => {\r\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\r\n        done && done();\r\n    };\r\n    const finishLeave = (el, done) => {\r\n        removeTransitionClass(el, leaveToClass);\r\n        removeTransitionClass(el, leaveActiveClass);\r\n        done && done();\r\n    };\r\n    const makeEnterHook = (isAppear) => {\r\n        return (el, done) => {\r\n            const hook = isAppear ? onAppear : onEnter;\r\n            const resolve = () => finishEnter(el, isAppear, done);\r\n            hook && hook(el, resolve);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\r\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\r\n                if (!(hook && hook.length > 1)) {\r\n                    whenTransitionEnds(el, type, enterDuration, resolve);\r\n                }\r\n            });\r\n        };\r\n    };\r\n    return shared.extend(baseProps, {\r\n        onBeforeEnter(el) {\r\n            onBeforeEnter && onBeforeEnter(el);\r\n            addTransitionClass(el, enterFromClass);\r\n            addTransitionClass(el, enterActiveClass);\r\n        },\r\n        onBeforeAppear(el) {\r\n            onBeforeAppear && onBeforeAppear(el);\r\n            addTransitionClass(el, appearFromClass);\r\n            addTransitionClass(el, appearActiveClass);\r\n        },\r\n        onEnter: makeEnterHook(false),\r\n        onAppear: makeEnterHook(true),\r\n        onLeave(el, done) {\r\n            const resolve = () => finishLeave(el, done);\r\n            addTransitionClass(el, leaveFromClass);\r\n            // force reflow so *-leave-from classes immediately take effect (#2593)\r\n            forceReflow();\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(() => {\r\n                removeTransitionClass(el, leaveFromClass);\r\n                addTransitionClass(el, leaveToClass);\r\n                if (!(onLeave && onLeave.length > 1)) {\r\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\r\n                }\r\n            });\r\n            onLeave && onLeave(el, resolve);\r\n        },\r\n        onEnterCancelled(el) {\r\n            finishEnter(el, false);\r\n            onEnterCancelled && onEnterCancelled(el);\r\n        },\r\n        onAppearCancelled(el) {\r\n            finishEnter(el, true);\r\n            onAppearCancelled && onAppearCancelled(el);\r\n        },\r\n        onLeaveCancelled(el) {\r\n            finishLeave(el);\r\n            onLeaveCancelled && onLeaveCancelled(el);\r\n        }\r\n    });\r\n}\r\nfunction normalizeDuration(duration) {\r\n    if (duration == null) {\r\n        return null;\r\n    }\r\n    else if (shared.isObject(duration)) {\r\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\r\n    }\r\n    else {\r\n        const n = NumberOf(duration);\r\n        return [n, n];\r\n    }\r\n}\r\nfunction NumberOf(val) {\r\n    const res = shared.toNumber(val);\r\n    return res;\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\r\n    (el._vtc ||\r\n        (el._vtc = new Set())).add(cls);\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\r\n    const { _vtc } = el;\r\n    if (_vtc) {\r\n        _vtc.delete(cls);\r\n        if (!_vtc.size) {\r\n            el._vtc = undefined;\r\n        }\r\n    }\r\n}\r\nfunction nextFrame(cb) {\r\n    requestAnimationFrame(() => {\r\n        requestAnimationFrame(cb);\r\n    });\r\n}\r\nlet endId = 0;\r\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\r\n    const id = (el._endId = ++endId);\r\n    const resolveIfNotStale = () => {\r\n        if (id === el._endId) {\r\n            resolve();\r\n        }\r\n    };\r\n    if (explicitTimeout) {\r\n        return setTimeout(resolveIfNotStale, explicitTimeout);\r\n    }\r\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\r\n    if (!type) {\r\n        return resolve();\r\n    }\r\n    const endEvent = type + 'end';\r\n    let ended = 0;\r\n    const end = () => {\r\n        el.removeEventListener(endEvent, onEnd);\r\n        resolveIfNotStale();\r\n    };\r\n    const onEnd = (e) => {\r\n        if (e.target === el && ++ended >= propCount) {\r\n            end();\r\n        }\r\n    };\r\n    setTimeout(() => {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(endEvent, onEnd);\r\n}\r\nfunction getTransitionInfo(el, expectedType) {\r\n    const styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    const getStyleProperties = (key) => (styles[key] || '').split(', ');\r\n    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');\r\n    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');\r\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    const animationDelays = getStyleProperties(ANIMATION + 'Delay');\r\n    const animationDurations = getStyleProperties(ANIMATION + 'Duration');\r\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    let type = null;\r\n    let timeout = 0;\r\n    let propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    const hasTransform = type === TRANSITION &&\r\n        /\\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);\r\n    return {\r\n        type,\r\n        timeout,\r\n        propCount,\r\n        hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\r\n// numbers in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down\r\n// (i.e. acting as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\r\n// synchronously force layout to put elements into a certain state\r\nfunction forceReflow() {\r\n    return document.body.offsetHeight;\r\n}\n\nconst positionMap = new WeakMap();\r\nconst newPositionMap = new WeakMap();\r\nconst TransitionGroupImpl = {\r\n    name: 'TransitionGroup',\r\n    props: /*#__PURE__*/ shared.extend({}, TransitionPropsValidators, {\r\n        tag: String,\r\n        moveClass: String\r\n    }),\r\n    setup(props, { slots }) {\r\n        const instance = runtimeCore.getCurrentInstance();\r\n        const state = runtimeCore.useTransitionState();\r\n        let prevChildren;\r\n        let children;\r\n        runtimeCore.onUpdated(() => {\r\n            // children is guaranteed to exist after initial render\r\n            if (!prevChildren.length) {\r\n                return;\r\n            }\r\n            const moveClass = props.moveClass || `${props.name || 'v'}-move`;\r\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\r\n                return;\r\n            }\r\n            // we divide the work into three loops to avoid mixing DOM reads and writes\r\n            // in each iteration - which helps prevent layout thrashing.\r\n            prevChildren.forEach(callPendingCbs);\r\n            prevChildren.forEach(recordPosition);\r\n            const movedChildren = prevChildren.filter(applyTranslation);\r\n            // force reflow to put everything in position\r\n            forceReflow();\r\n            movedChildren.forEach(c => {\r\n                const el = c.el;\r\n                const style = el.style;\r\n                addTransitionClass(el, moveClass);\r\n                style.transform = style.webkitTransform = style.transitionDuration = '';\r\n                const cb = (el._moveCb = (e) => {\r\n                    if (e && e.target !== el) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el.removeEventListener('transitionend', cb);\r\n                        el._moveCb = null;\r\n                        removeTransitionClass(el, moveClass);\r\n                    }\r\n                });\r\n                el.addEventListener('transitionend', cb);\r\n            });\r\n        });\r\n        return () => {\r\n            const rawProps = runtimeCore.toRaw(props);\r\n            const cssTransitionProps = resolveTransitionProps(rawProps);\r\n            const tag = rawProps.tag || runtimeCore.Fragment;\r\n            prevChildren = children;\r\n            children = slots.default ? runtimeCore.getTransitionRawChildren(slots.default()) : [];\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (child.key != null) {\r\n                    runtimeCore.setTransitionHooks(child, runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                }\r\n            }\r\n            if (prevChildren) {\r\n                for (let i = 0; i < prevChildren.length; i++) {\r\n                    const child = prevChildren[i];\r\n                    runtimeCore.setTransitionHooks(child, runtimeCore.resolveTransitionHooks(child, cssTransitionProps, state, instance));\r\n                    positionMap.set(child, child.el.getBoundingClientRect());\r\n                }\r\n            }\r\n            return runtimeCore.createVNode(tag, null, children);\r\n        };\r\n    }\r\n};\r\nconst TransitionGroup = TransitionGroupImpl;\r\nfunction callPendingCbs(c) {\r\n    const el = c.el;\r\n    if (el._moveCb) {\r\n        el._moveCb();\r\n    }\r\n    if (el._enterCb) {\r\n        el._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    newPositionMap.set(c, c.el.getBoundingClientRect());\r\n}\r\nfunction applyTranslation(c) {\r\n    const oldPos = positionMap.get(c);\r\n    const newPos = newPositionMap.get(c);\r\n    const dx = oldPos.left - newPos.left;\r\n    const dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        const s = c.el.style;\r\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\r\n        s.transitionDuration = '0s';\r\n        return c;\r\n    }\r\n}\r\nfunction hasCSSTransform(el, root, moveClass) {\r\n    // Detect whether an element with the move class applied has\r\n    // CSS transitions. Since the element may be inside an entering\r\n    // transition at this very moment, we make a clone of it and remove\r\n    // all other transition classes applied to ensure only the move class\r\n    // is applied.\r\n    const clone = el.cloneNode();\r\n    if (el._vtc) {\r\n        el._vtc.forEach(cls => {\r\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\r\n        });\r\n    }\r\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\r\n    clone.style.display = 'none';\r\n    const container = (root.nodeType === 1\r\n        ? root\r\n        : root.parentNode);\r\n    container.appendChild(clone);\r\n    const { hasTransform } = getTransitionInfo(clone);\r\n    container.removeChild(clone);\r\n    return hasTransform;\r\n}\n\nconst getModelAssigner = (vnode) => {\r\n    const fn = vnode.props['onUpdate:modelValue'];\r\n    return shared.isArray(fn) ? value => shared.invokeArrayFns(fn, value) : fn;\r\n};\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    const target = e.target;\r\n    if (target.composing) {\r\n        target.composing = false;\r\n        trigger(target, 'input');\r\n    }\r\n}\r\nfunction trigger(el, type) {\r\n    const e = document.createEvent('HTMLEvents');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\r\n// We are exporting the v-model runtime directly as vnode hooks so that it can\r\n// be tree-shaken in case v-model is never used.\r\nconst vModelText = {\r\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        const castToNumber = number || el.type === 'number';\r\n        addEventListener(el, lazy ? 'change' : 'input', e => {\r\n            if (e.target.composing)\r\n                return;\r\n            let domValue = el.value;\r\n            if (trim) {\r\n                domValue = domValue.trim();\r\n            }\r\n            else if (castToNumber) {\r\n                domValue = shared.toNumber(domValue);\r\n            }\r\n            el._assign(domValue);\r\n        });\r\n        if (trim) {\r\n            addEventListener(el, 'change', () => {\r\n                el.value = el.value.trim();\r\n            });\r\n        }\r\n        if (!lazy) {\r\n            addEventListener(el, 'compositionstart', onCompositionStart);\r\n            addEventListener(el, 'compositionend', onCompositionEnd);\r\n            // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n            // switching focus before confirming composition choice\r\n            // this also fixes the issue where some browsers e.g. iOS Chrome\r\n            // fires \"change\" instead of \"input\" on autocomplete.\r\n            addEventListener(el, 'change', onCompositionEnd);\r\n        }\r\n    },\r\n    // set value on mounted so it's after min/max for type=\"range\"\r\n    mounted(el, { value }) {\r\n        el.value = value == null ? '' : value;\r\n    },\r\n    beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        // avoid clearing unresolved text. #2302\r\n        if (el.composing)\r\n            return;\r\n        if (document.activeElement === el) {\r\n            if (trim && el.value.trim() === value) {\r\n                return;\r\n            }\r\n            if ((number || el.type === 'number') && shared.toNumber(el.value) === value) {\r\n                return;\r\n            }\r\n        }\r\n        const newValue = value == null ? '' : value;\r\n        if (el.value !== newValue) {\r\n            el.value = newValue;\r\n        }\r\n    }\r\n};\r\nconst vModelCheckbox = {\r\n    created(el, _, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, 'change', () => {\r\n            const modelValue = el._modelValue;\r\n            const elementValue = getValue(el);\r\n            const checked = el.checked;\r\n            const assign = el._assign;\r\n            if (shared.isArray(modelValue)) {\r\n                const index = shared.looseIndexOf(modelValue, elementValue);\r\n                const found = index !== -1;\r\n                if (checked && !found) {\r\n                    assign(modelValue.concat(elementValue));\r\n                }\r\n                else if (!checked && found) {\r\n                    const filtered = [...modelValue];\r\n                    filtered.splice(index, 1);\r\n                    assign(filtered);\r\n                }\r\n            }\r\n            else if (shared.isSet(modelValue)) {\r\n                const cloned = new Set(modelValue);\r\n                if (checked) {\r\n                    cloned.add(elementValue);\r\n                }\r\n                else {\r\n                    cloned.delete(elementValue);\r\n                }\r\n                assign(cloned);\r\n            }\r\n            else {\r\n                assign(getCheckboxValue(el, checked));\r\n            }\r\n        });\r\n    },\r\n    // set initial checked on mount to wait for true-value/false-value\r\n    mounted: setChecked,\r\n    beforeUpdate(el, binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        setChecked(el, binding, vnode);\r\n    }\r\n};\r\nfunction setChecked(el, { value, oldValue }, vnode) {\r\n    el._modelValue = value;\r\n    if (shared.isArray(value)) {\r\n        el.checked = shared.looseIndexOf(value, vnode.props.value) > -1;\r\n    }\r\n    else if (shared.isSet(value)) {\r\n        el.checked = value.has(vnode.props.value);\r\n    }\r\n    else if (value !== oldValue) {\r\n        el.checked = shared.looseEqual(value, getCheckboxValue(el, true));\r\n    }\r\n}\r\nconst vModelRadio = {\r\n    created(el, { value }, vnode) {\r\n        el.checked = shared.looseEqual(value, vnode.props.value);\r\n        el._assign = getModelAssigner(vnode);\r\n        addEventListener(el, 'change', () => {\r\n            el._assign(getValue(el));\r\n        });\r\n    },\r\n    beforeUpdate(el, { value, oldValue }, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n        if (value !== oldValue) {\r\n            el.checked = shared.looseEqual(value, vnode.props.value);\r\n        }\r\n    }\r\n};\r\nconst vModelSelect = {\r\n    created(el, { value, modifiers: { number } }, vnode) {\r\n        const isSetModel = shared.isSet(value);\r\n        addEventListener(el, 'change', () => {\r\n            const selectedVal = Array.prototype.filter\r\n                .call(el.options, (o) => o.selected)\r\n                .map((o) => number ? shared.toNumber(getValue(o)) : getValue(o));\r\n            el._assign(el.multiple\r\n                ? isSetModel\r\n                    ? new Set(selectedVal)\r\n                    : selectedVal\r\n                : selectedVal[0]);\r\n        });\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    // set value in mounted & updated because <select> relies on its children\r\n    // <option>s.\r\n    mounted(el, { value }) {\r\n        setSelected(el, value);\r\n    },\r\n    beforeUpdate(el, _binding, vnode) {\r\n        el._assign = getModelAssigner(vnode);\r\n    },\r\n    updated(el, { value }) {\r\n        setSelected(el, value);\r\n    }\r\n};\r\nfunction setSelected(el, value) {\r\n    const isMultiple = el.multiple;\r\n    if (isMultiple && !shared.isArray(value) && !shared.isSet(value)) {\r\n        return;\r\n    }\r\n    for (let i = 0, l = el.options.length; i < l; i++) {\r\n        const option = el.options[i];\r\n        const optionValue = getValue(option);\r\n        if (isMultiple) {\r\n            if (shared.isArray(value)) {\r\n                option.selected = shared.looseIndexOf(value, optionValue) > -1;\r\n            }\r\n            else {\r\n                option.selected = value.has(optionValue);\r\n            }\r\n        }\r\n        else {\r\n            if (shared.looseEqual(getValue(option), value)) {\r\n                el.selectedIndex = i;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\n// retrieve raw value set via :value bindings\r\nfunction getValue(el) {\r\n    return '_value' in el ? el._value : el.value;\r\n}\r\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\r\nfunction getCheckboxValue(el, checked) {\r\n    const key = checked ? '_trueValue' : '_falseValue';\r\n    return key in el ? el[key] : checked;\r\n}\r\nconst vModelDynamic = {\r\n    created(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, 'created');\r\n    },\r\n    mounted(el, binding, vnode) {\r\n        callModelHook(el, binding, vnode, null, 'mounted');\r\n    },\r\n    beforeUpdate(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\r\n    },\r\n    updated(el, binding, vnode, prevVNode) {\r\n        callModelHook(el, binding, vnode, prevVNode, 'updated');\r\n    }\r\n};\r\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\r\n    let modelToUse;\r\n    switch (el.tagName) {\r\n        case 'SELECT':\r\n            modelToUse = vModelSelect;\r\n            break;\r\n        case 'TEXTAREA':\r\n            modelToUse = vModelText;\r\n            break;\r\n        default:\r\n            switch (vnode.props && vnode.props.type) {\r\n                case 'checkbox':\r\n                    modelToUse = vModelCheckbox;\r\n                    break;\r\n                case 'radio':\r\n                    modelToUse = vModelRadio;\r\n                    break;\r\n                default:\r\n                    modelToUse = vModelText;\r\n            }\r\n    }\r\n    const fn = modelToUse[hook];\r\n    fn && fn(el, binding, vnode, prevVNode);\r\n}\r\n// SSR vnode transforms\r\n{\r\n    vModelText.getSSRProps = ({ value }) => ({ value });\r\n    vModelRadio.getSSRProps = ({ value }, vnode) => {\r\n        if (vnode.props && shared.looseEqual(vnode.props.value, value)) {\r\n            return { checked: true };\r\n        }\r\n    };\r\n    vModelCheckbox.getSSRProps = ({ value }, vnode) => {\r\n        if (shared.isArray(value)) {\r\n            if (vnode.props && shared.looseIndexOf(value, vnode.props.value) > -1) {\r\n                return { checked: true };\r\n            }\r\n        }\r\n        else if (shared.isSet(value)) {\r\n            if (vnode.props && value.has(vnode.props.value)) {\r\n                return { checked: true };\r\n            }\r\n        }\r\n        else if (value) {\r\n            return { checked: true };\r\n        }\r\n    };\r\n}\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\r\nconst modifierGuards = {\r\n    stop: e => e.stopPropagation(),\r\n    prevent: e => e.preventDefault(),\r\n    self: e => e.target !== e.currentTarget,\r\n    ctrl: e => !e.ctrlKey,\r\n    shift: e => !e.shiftKey,\r\n    alt: e => !e.altKey,\r\n    meta: e => !e.metaKey,\r\n    left: e => 'button' in e && e.button !== 0,\r\n    middle: e => 'button' in e && e.button !== 1,\r\n    right: e => 'button' in e && e.button !== 2,\r\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withModifiers = (fn, modifiers) => {\r\n    return (event, ...args) => {\r\n        for (let i = 0; i < modifiers.length; i++) {\r\n            const guard = modifierGuards[modifiers[i]];\r\n            if (guard && guard(event, modifiers))\r\n                return;\r\n        }\r\n        return fn(event, ...args);\r\n    };\r\n};\r\n// Kept for 2.x compat.\r\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\r\nconst keyNames = {\r\n    esc: 'escape',\r\n    space: ' ',\r\n    up: 'arrow-up',\r\n    left: 'arrow-left',\r\n    right: 'arrow-right',\r\n    down: 'arrow-down',\r\n    delete: 'backspace'\r\n};\r\n/**\r\n * @private\r\n */\r\nconst withKeys = (fn, modifiers) => {\r\n    return (event) => {\r\n        if (!('key' in event))\r\n            return;\r\n        const eventKey = shared.hyphenate(event.key);\r\n        if (\r\n        // None of the provided key modifiers match the current event key\r\n        !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\r\n            return;\r\n        }\r\n        return fn(event);\r\n    };\r\n};\n\nconst vShow = {\r\n    beforeMount(el, { value }, { transition }) {\r\n        el._vod = el.style.display === 'none' ? '' : el.style.display;\r\n        if (transition && value) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    mounted(el, { value }, { transition }) {\r\n        if (transition && value) {\r\n            transition.enter(el);\r\n        }\r\n    },\r\n    updated(el, { value, oldValue }, { transition }) {\r\n        if (!value === !oldValue)\r\n            return;\r\n        if (transition) {\r\n            if (value) {\r\n                transition.beforeEnter(el);\r\n                setDisplay(el, true);\r\n                transition.enter(el);\r\n            }\r\n            else {\r\n                transition.leave(el, () => {\r\n                    setDisplay(el, false);\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            setDisplay(el, value);\r\n        }\r\n    },\r\n    beforeUnmount(el, { value }) {\r\n        setDisplay(el, value);\r\n    }\r\n};\r\n{\r\n    vShow.getSSRProps = ({ value }) => {\r\n        if (!value) {\r\n            return { style: { display: 'none' } };\r\n        }\r\n    };\r\n}\r\nfunction setDisplay(el, value) {\r\n    el.style.display = value ? el._vod : 'none';\r\n}\n\nconst rendererOptions = shared.extend({ patchProp, forcePatchProp }, nodeOps);\r\n// lazy create the renderer - this makes core renderer logic tree-shakable\r\n// in case the user only imports reactivity utilities from Vue.\r\nlet renderer;\r\nlet enabledHydration = false;\r\nfunction ensureRenderer() {\r\n    return renderer || (renderer = runtimeCore.createRenderer(rendererOptions));\r\n}\r\nfunction ensureHydrationRenderer() {\r\n    renderer = enabledHydration\r\n        ? renderer\r\n        : runtimeCore.createHydrationRenderer(rendererOptions);\r\n    enabledHydration = true;\r\n    return renderer;\r\n}\r\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\r\nconst render = ((...args) => {\r\n    ensureRenderer().render(...args);\r\n});\r\nconst hydrate = ((...args) => {\r\n    ensureHydrationRenderer().hydrate(...args);\r\n});\r\nconst createApp = ((...args) => {\r\n    const app = ensureRenderer().createApp(...args);\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (!container)\r\n            return;\r\n        const component = app._component;\r\n        if (!shared.isFunction(component) && !component.render && !component.template) {\r\n            component.template = container.innerHTML;\r\n        }\r\n        // clear content before mounting\r\n        container.innerHTML = '';\r\n        const proxy = mount(container, false, container instanceof SVGElement);\r\n        if (container instanceof Element) {\r\n            container.removeAttribute('v-cloak');\r\n            container.setAttribute('data-v-app', '');\r\n        }\r\n        return proxy;\r\n    };\r\n    return app;\r\n});\r\nconst createSSRApp = ((...args) => {\r\n    const app = ensureHydrationRenderer().createApp(...args);\r\n    const { mount } = app;\r\n    app.mount = (containerOrSelector) => {\r\n        const container = normalizeContainer(containerOrSelector);\r\n        if (container) {\r\n            return mount(container, true, container instanceof SVGElement);\r\n        }\r\n    };\r\n    return app;\r\n});\r\nfunction normalizeContainer(container) {\r\n    if (shared.isString(container)) {\r\n        const res = document.querySelector(container);\r\n        return res;\r\n    }\r\n    return container;\r\n}\n\nObject.keys(runtimeCore).forEach(function (k) {\n  if (k !== 'default') exports[k] = runtimeCore[k];\n});\nexports.Transition = Transition;\nexports.TransitionGroup = TransitionGroup;\nexports.createApp = createApp;\nexports.createSSRApp = createSSRApp;\nexports.hydrate = hydrate;\nexports.render = render;\nexports.useCssModule = useCssModule;\nexports.useCssVars = useCssVars;\nexports.vModelCheckbox = vModelCheckbox;\nexports.vModelDynamic = vModelDynamic;\nexports.vModelRadio = vModelRadio;\nexports.vModelSelect = vModelSelect;\nexports.vModelText = vModelText;\nexports.vShow = vShow;\nexports.withKeys = withKeys;\nexports.withModifiers = withModifiers;\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/runtime-core.cjs.prod.js')\n} else {\n  module.exports = require('./dist/runtime-core.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar reactivity = require('@vue/reactivity');\nvar shared = require('@vue/shared');\n\nconst stack = [];\r\nfunction warn(msg, ...args) {\r\n    // avoid props formatting or warn handler tracking deps that might be mutated\r\n    // during patch, leading to infinite recursion.\r\n    reactivity.pauseTracking();\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n    reactivity.resetTracking();\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (shared.isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (reactivity.isRef(value)) {\r\n        value = formatProp(key, reactivity.toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (shared.isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = reactivity.toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\r\n    if (shared.isFunction(fn)) {\r\n        const res = callWithErrorHandling(fn, instance, type, args);\r\n        if (res && shared.isPromise(res)) {\r\n            res.catch(err => {\r\n                handleError(err, instance, type);\r\n            });\r\n        }\r\n        return res;\r\n    }\r\n    const values = [];\r\n    for (let i = 0; i < fn.length; i++) {\r\n        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\r\n    }\r\n    return values;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = type;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    {\r\n        // recover in prod to reduce the impact on end-user\r\n        console.error(err);\r\n    }\r\n}\n\nlet isFlushing = false;\r\nlet isFlushPending = false;\r\nconst queue = [];\r\nlet flushIndex = 0;\r\nconst pendingPreFlushCbs = [];\r\nlet activePreFlushCbs = null;\r\nlet preFlushIndex = 0;\r\nconst pendingPostFlushCbs = [];\r\nlet activePostFlushCbs = null;\r\nlet postFlushIndex = 0;\r\nconst resolvedPromise = Promise.resolve();\r\nlet currentFlushPromise = null;\r\nlet currentPreFlushParentJob = null;\r\nconst RECURSION_LIMIT = 100;\r\nfunction nextTick(fn) {\r\n    const p = currentFlushPromise || resolvedPromise;\r\n    return fn ? p.then(this ? fn.bind(this) : fn) : p;\r\n}\r\n// #2768\r\n// Use binary-search to find a suitable position in the queue,\r\n// so that the queue maintains the increasing order of job's id,\r\n// which can prevent the job from being skipped and also can avoid repeated patching.\r\nfunction findInsertionIndex(job) {\r\n    // the start index should be `flushIndex + 1`\r\n    let start = flushIndex + 1;\r\n    let end = queue.length;\r\n    const jobId = getId(job);\r\n    while (start < end) {\r\n        const middle = (start + end) >>> 1;\r\n        const middleJobId = getId(queue[middle]);\r\n        middleJobId < jobId ? (start = middle + 1) : (end = middle);\r\n    }\r\n    return start;\r\n}\r\nfunction queueJob(job) {\r\n    // the dedupe search uses the startIndex argument of Array.includes()\r\n    // by default the search index includes the current job that is being run\r\n    // so it cannot recursively trigger itself again.\r\n    // if the job is a watch() callback, the search will start with a +1 index to\r\n    // allow it recursively trigger itself - it is the user's responsibility to\r\n    // ensure it doesn't end up in an infinite loop.\r\n    if ((!queue.length ||\r\n        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&\r\n        job !== currentPreFlushParentJob) {\r\n        const pos = findInsertionIndex(job);\r\n        if (pos > -1) {\r\n            queue.splice(pos, 0, job);\r\n        }\r\n        else {\r\n            queue.push(job);\r\n        }\r\n        queueFlush();\r\n    }\r\n}\r\nfunction queueFlush() {\r\n    if (!isFlushing && !isFlushPending) {\r\n        isFlushPending = true;\r\n        currentFlushPromise = resolvedPromise.then(flushJobs);\r\n    }\r\n}\r\nfunction invalidateJob(job) {\r\n    const i = queue.indexOf(job);\r\n    if (i > flushIndex) {\r\n        queue.splice(i, 1);\r\n    }\r\n}\r\nfunction queueCb(cb, activeQueue, pendingQueue, index) {\r\n    if (!shared.isArray(cb)) {\r\n        if (!activeQueue ||\r\n            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {\r\n            pendingQueue.push(cb);\r\n        }\r\n    }\r\n    else {\r\n        // if cb is an array, it is a component lifecycle hook which can only be\r\n        // triggered by a job, which is already deduped in the main queue, so\r\n        // we can skip duplicate check here to improve perf\r\n        pendingQueue.push(...cb);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queuePreFlushCb(cb) {\r\n    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);\r\n}\r\nfunction queuePostFlushCb(cb) {\r\n    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);\r\n}\r\nfunction flushPreFlushCbs(seen, parentJob = null) {\r\n    if (pendingPreFlushCbs.length) {\r\n        currentPreFlushParentJob = parentJob;\r\n        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];\r\n        pendingPreFlushCbs.length = 0;\r\n        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {\r\n            activePreFlushCbs[preFlushIndex]();\r\n        }\r\n        activePreFlushCbs = null;\r\n        preFlushIndex = 0;\r\n        currentPreFlushParentJob = null;\r\n        // recursively flush until it drains\r\n        flushPreFlushCbs(seen, parentJob);\r\n    }\r\n}\r\nfunction flushPostFlushCbs(seen) {\r\n    if (pendingPostFlushCbs.length) {\r\n        const deduped = [...new Set(pendingPostFlushCbs)];\r\n        pendingPostFlushCbs.length = 0;\r\n        // #1947 already has active queue, nested flushPostFlushCbs call\r\n        if (activePostFlushCbs) {\r\n            activePostFlushCbs.push(...deduped);\r\n            return;\r\n        }\r\n        activePostFlushCbs = deduped;\r\n        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));\r\n        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\r\n            activePostFlushCbs[postFlushIndex]();\r\n        }\r\n        activePostFlushCbs = null;\r\n        postFlushIndex = 0;\r\n    }\r\n}\r\nconst getId = (job) => job.id == null ? Infinity : job.id;\r\nfunction flushJobs(seen) {\r\n    isFlushPending = false;\r\n    isFlushing = true;\r\n    flushPreFlushCbs(seen);\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child so its render effect will have smaller\r\n    //    priority number)\r\n    // 2. If a component is unmounted during a parent component's update,\r\n    //    its update can be skipped.\r\n    queue.sort((a, b) => getId(a) - getId(b));\r\n    try {\r\n        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\r\n            const job = queue[flushIndex];\r\n            if (job) {\r\n                if (false) ;\r\n                callWithErrorHandling(job, null, 14 /* SCHEDULER */);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        flushIndex = 0;\r\n        queue.length = 0;\r\n        flushPostFlushCbs();\r\n        isFlushing = false;\r\n        currentFlushPromise = null;\r\n        // some postFlushCb queued jobs!\r\n        // keep flushing until it drains.\r\n        if (queue.length || pendingPostFlushCbs.length) {\r\n            flushJobs(seen);\r\n        }\r\n    }\r\n}\r\nfunction checkRecursiveUpdates(seen, fn) {\r\n    if (!seen.has(fn)) {\r\n        seen.set(fn, 1);\r\n    }\r\n    else {\r\n        const count = seen.get(fn);\r\n        if (count > RECURSION_LIMIT) {\r\n            throw new Error(`Maximum recursive updates exceeded. ` +\r\n                `This means you have a reactive effect that is mutating its own ` +\r\n                `dependencies and thus recursively triggering itself. Possible sources ` +\r\n                `include component template, render function, updated hook or ` +\r\n                `watcher source function.`);\r\n        }\r\n        else {\r\n            seen.set(fn, count + 1);\r\n        }\r\n    }\r\n}\n\nfunction setDevtoolsHook(hook) {\r\n    exports.devtools = hook;\r\n}\n\nfunction emit(instance, event, ...rawArgs) {\r\n    const props = instance.vnode.props || shared.EMPTY_OBJ;\r\n    let args = rawArgs;\r\n    const isModelListener = event.startsWith('update:');\r\n    // for v-model update:xxx events, apply modifiers on args\r\n    const modelArg = isModelListener && event.slice(7);\r\n    if (modelArg && modelArg in props) {\r\n        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;\r\n        const { number, trim } = props[modifiersKey] || shared.EMPTY_OBJ;\r\n        if (trim) {\r\n            args = rawArgs.map(a => a.trim());\r\n        }\r\n        else if (number) {\r\n            args = rawArgs.map(shared.toNumber);\r\n        }\r\n    }\r\n    let handlerName;\r\n    let handler = props[(handlerName = shared.toHandlerKey(event))] ||\r\n        // also try camelCase event handler (#2249)\r\n        props[(handlerName = shared.toHandlerKey(shared.camelize(event)))];\r\n    // for v-model update:xxx events, also trigger kebab-case equivalent\r\n    // for props passed via kebab-case\r\n    if (!handler && isModelListener) {\r\n        handler = props[(handlerName = shared.toHandlerKey(shared.hyphenate(event)))];\r\n    }\r\n    if (handler) {\r\n        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n    const onceHandler = props[handlerName + `Once`];\r\n    if (onceHandler) {\r\n        if (!instance.emitted) {\r\n            (instance.emitted = {})[handlerName] = true;\r\n        }\r\n        else if (instance.emitted[handlerName]) {\r\n            return;\r\n        }\r\n        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);\r\n    }\r\n}\r\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__emits !== undefined) {\r\n        return comp.__emits;\r\n    }\r\n    const raw = comp.emits;\r\n    let normalized = {};\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (!shared.isFunction(comp)) {\r\n        const extendEmits = (raw) => {\r\n            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);\r\n            if (normalizedFromExtend) {\r\n                hasExtends = true;\r\n                shared.extend(normalized, normalizedFromExtend);\r\n            }\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendEmits);\r\n        }\r\n        if (comp.extends) {\r\n            extendEmits(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendEmits);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__emits = null);\r\n    }\r\n    if (shared.isArray(raw)) {\r\n        raw.forEach(key => (normalized[key] = null));\r\n    }\r\n    else {\r\n        shared.extend(normalized, raw);\r\n    }\r\n    return (comp.__emits = normalized);\r\n}\r\n// Check if an incoming prop key is a declared emit event listener.\r\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\r\n// both considered matched listeners.\r\nfunction isEmitListener(options, key) {\r\n    if (!options || !shared.isOn(key)) {\r\n        return false;\r\n    }\r\n    key = key.slice(2).replace(/Once$/, '');\r\n    return (shared.hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\r\n        shared.hasOwn(options, shared.hyphenate(key)) ||\r\n        shared.hasOwn(options, key));\r\n}\n\nlet isRenderingCompiledSlot = 0;\r\nconst setCompiledSlotRendering = (n) => (isRenderingCompiledSlot += n);\r\n/**\r\n * Compiler runtime helper for rendering `<slot/>`\r\n * @private\r\n */\r\nfunction renderSlot(slots, name, props = {}, \r\n// this is not a user-facing function, so the fallback is always generated by\r\n// the compiler and guaranteed to be a function returning an array\r\nfallback, noSlotted) {\r\n    let slot = slots[name];\r\n    // a compiled slot disables block tracking by default to avoid manual\r\n    // invocation interfering with template-based block tracking, but in\r\n    // `renderSlot` we can be sure that it's template-based so we can force\r\n    // enable it.\r\n    isRenderingCompiledSlot++;\r\n    openBlock();\r\n    const validSlotContent = slot && ensureValidVNode(slot(props));\r\n    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */\r\n        ? 64 /* STABLE_FRAGMENT */\r\n        : -2 /* BAIL */);\r\n    if (!noSlotted && rendered.scopeId) {\r\n        rendered.slotScopeIds = [rendered.scopeId + '-s'];\r\n    }\r\n    isRenderingCompiledSlot--;\r\n    return rendered;\r\n}\r\nfunction ensureValidVNode(vnodes) {\r\n    return vnodes.some(child => {\r\n        if (!isVNode(child))\r\n            return true;\r\n        if (child.type === Comment)\r\n            return false;\r\n        if (child.type === Fragment &&\r\n            !ensureValidVNode(child.children))\r\n            return false;\r\n        return true;\r\n    })\r\n        ? vnodes\r\n        : null;\r\n}\n\n/**\r\n * mark the current rendering instance for asset resolution (e.g.\r\n * resolveComponent, resolveDirective) during render\r\n */\r\nlet currentRenderingInstance = null;\r\nlet currentScopeId = null;\r\n/**\r\n * Note: rendering calls maybe nested. The function returns the parent rendering\r\n * instance if present, which should be restored after the render is done:\r\n *\r\n * ```js\r\n * const prev = setCurrentRenderingInstance(i)\r\n * // ...render\r\n * setCurrentRenderingInstance(prev)\r\n * ```\r\n */\r\nfunction setCurrentRenderingInstance(instance) {\r\n    const prev = currentRenderingInstance;\r\n    currentRenderingInstance = instance;\r\n    currentScopeId = (instance && instance.type.__scopeId) || null;\r\n    return prev;\r\n}\r\n/**\r\n * Set scope id when creating hoisted vnodes.\r\n * @private compiler helper\r\n */\r\nfunction pushScopeId(id) {\r\n    currentScopeId = id;\r\n}\r\n/**\r\n * Technically we no longer need this after 3.0.8 but we need to keep the same\r\n * API for backwards compat w/ code generated by compilers.\r\n * @private\r\n */\r\nfunction popScopeId() {\r\n    currentScopeId = null;\r\n}\r\n/**\r\n * Only for backwards compat\r\n * @private\r\n */\r\nconst withScopeId = (_id) => withCtx;\r\n/**\r\n * Wrap a slot function to memoize current rendering instance\r\n * @private compiler helper\r\n */\r\nfunction withCtx(fn, ctx = currentRenderingInstance) {\r\n    if (!ctx)\r\n        return fn;\r\n    const renderFnWithContext = (...args) => {\r\n        // If a user calls a compiled slot inside a template expression (#1745), it\r\n        // can mess up block tracking, so by default we need to push a null block to\r\n        // avoid that. This isn't necessary if rendering a compiled `<slot>`.\r\n        if (!isRenderingCompiledSlot) {\r\n            openBlock(true /* null block that disables tracking */);\r\n        }\r\n        const prevInstance = setCurrentRenderingInstance(ctx);\r\n        const res = fn(...args);\r\n        setCurrentRenderingInstance(prevInstance);\r\n        if (!isRenderingCompiledSlot) {\r\n            closeBlock();\r\n        }\r\n        return res;\r\n    };\r\n    // mark this as a compiled slot function.\r\n    // this is used in vnode.ts -> normalizeChildren() to set the slot\r\n    // rendering flag.\r\n    renderFnWithContext._c = true;\r\n    return renderFnWithContext;\r\n}\n\n/**\r\n * dev only flag to track whether $attrs was used during render.\r\n * If $attrs was used during render then the warning for failed attrs\r\n * fallthrough can be suppressed.\r\n */\r\nlet accessedAttrs = false;\r\nfunction markAttrsAccessed() {\r\n    accessedAttrs = true;\r\n}\r\nfunction renderComponentRoot(instance) {\r\n    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx } = instance;\r\n    let result;\r\n    const prev = setCurrentRenderingInstance(instance);\r\n    try {\r\n        let fallthroughAttrs;\r\n        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n            // withProxy is a proxy with a different `has` trap only for\r\n            // runtime-compiled render functions using `with` block.\r\n            const proxyToUse = withProxy || proxy;\r\n            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));\r\n            fallthroughAttrs = attrs;\r\n        }\r\n        else {\r\n            // functional\r\n            const render = Component;\r\n            // in dev, mark attrs accessed if optional props (attrs === props)\r\n            if (false && attrs === props) ;\r\n            result = normalizeVNode(render.length > 1\r\n                ? render(props, false\r\n                    ? {\r\n                        get attrs() {\r\n                            markAttrsAccessed();\r\n                            return attrs;\r\n                        },\r\n                        slots,\r\n                        emit\r\n                    }\r\n                    : { attrs, slots, emit })\r\n                : render(props, null /* we know it doesn't need it */));\r\n            fallthroughAttrs = Component.props\r\n                ? attrs\r\n                : getFunctionalFallthrough(attrs);\r\n        }\r\n        // attr merging\r\n        // in dev mode, comments are preserved, and it's possible for a template\r\n        // to have comments along side the root element which makes it a fragment\r\n        let root = result;\r\n        let setRoot = undefined;\r\n        if (false &&\r\n            result.patchFlag > 0 &&\r\n            result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) ;\r\n        if (Component.inheritAttrs !== false && fallthroughAttrs) {\r\n            const keys = Object.keys(fallthroughAttrs);\r\n            const { shapeFlag } = root;\r\n            if (keys.length) {\r\n                if (shapeFlag & 1 /* ELEMENT */ ||\r\n                    shapeFlag & 6 /* COMPONENT */) {\r\n                    if (propsOptions && keys.some(shared.isModelListener)) {\r\n                        // If a v-model listener (onUpdate:xxx) has a corresponding declared\r\n                        // prop, it indicates this component expects to handle v-model and\r\n                        // it should not fallthrough.\r\n                        // related: #1543, #1643, #1989\r\n                        fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);\r\n                    }\r\n                    root = cloneVNode(root, fallthroughAttrs);\r\n                }\r\n                else if (false && !accessedAttrs && root.type !== Comment) ;\r\n            }\r\n        }\r\n        // inherit directives\r\n        if (vnode.dirs) {\r\n            if (false && !isElementRoot(root)) ;\r\n            root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\r\n        }\r\n        // inherit transition data\r\n        if (vnode.transition) {\r\n            if (false && !isElementRoot(root)) ;\r\n            root.transition = vnode.transition;\r\n        }\r\n        if (false && setRoot) ;\r\n        else {\r\n            result = root;\r\n        }\r\n    }\r\n    catch (err) {\r\n        blockStack.length = 0;\r\n        handleError(err, instance, 1 /* RENDER_FUNCTION */);\r\n        result = createVNode(Comment);\r\n    }\r\n    setCurrentRenderingInstance(prev);\r\n    return result;\r\n}\r\n/**\r\n * dev only\r\n * In dev mode, template root level comments are rendered, which turns the\r\n * template into a fragment root, but we need to locate the single element\r\n * root for attrs and scope id processing.\r\n */\r\nconst getChildRoot = (vnode) => {\r\n    const rawChildren = vnode.children;\r\n    const dynamicChildren = vnode.dynamicChildren;\r\n    const childRoot = filterSingleRoot(rawChildren);\r\n    if (!childRoot) {\r\n        return [vnode, undefined];\r\n    }\r\n    const index = rawChildren.indexOf(childRoot);\r\n    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\r\n    const setRoot = (updatedRoot) => {\r\n        rawChildren[index] = updatedRoot;\r\n        if (dynamicChildren) {\r\n            if (dynamicIndex > -1) {\r\n                dynamicChildren[dynamicIndex] = updatedRoot;\r\n            }\r\n            else if (updatedRoot.patchFlag > 0) {\r\n                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\r\n            }\r\n        }\r\n    };\r\n    return [normalizeVNode(childRoot), setRoot];\r\n};\r\nfunction filterSingleRoot(children) {\r\n    let singleRoot;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (isVNode(child)) {\r\n            // ignore user comment\r\n            if (child.type !== Comment || child.children === 'v-if') {\r\n                if (singleRoot) {\r\n                    // has more than 1 non-comment child, return now\r\n                    return;\r\n                }\r\n                else {\r\n                    singleRoot = child;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    return singleRoot;\r\n}\r\nconst getFunctionalFallthrough = (attrs) => {\r\n    let res;\r\n    for (const key in attrs) {\r\n        if (key === 'class' || key === 'style' || shared.isOn(key)) {\r\n            (res || (res = {}))[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst filterModelListeners = (attrs, props) => {\r\n    const res = {};\r\n    for (const key in attrs) {\r\n        if (!shared.isModelListener(key) || !(key.slice(9) in props)) {\r\n            res[key] = attrs[key];\r\n        }\r\n    }\r\n    return res;\r\n};\r\nconst isElementRoot = (vnode) => {\r\n    return (vnode.shapeFlag & 6 /* COMPONENT */ ||\r\n        vnode.shapeFlag & 1 /* ELEMENT */ ||\r\n        vnode.type === Comment // potential v-if branch switch\r\n    );\r\n};\r\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\r\n    const { props: prevProps, children: prevChildren, component } = prevVNode;\r\n    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\r\n    const emits = component.emitsOptions;\r\n    // force child update for runtime directive or transition on component vnode.\r\n    if (nextVNode.dirs || nextVNode.transition) {\r\n        return true;\r\n    }\r\n    if (optimized && patchFlag >= 0) {\r\n        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n            // slot content that references values that might have changed,\r\n            // e.g. in a v-for\r\n            return true;\r\n        }\r\n        if (patchFlag & 16 /* FULL_PROPS */) {\r\n            if (!prevProps) {\r\n                return !!nextProps;\r\n            }\r\n            // presence of this flag indicates props are always non-null\r\n            return hasPropsChanged(prevProps, nextProps, emits);\r\n        }\r\n        else if (patchFlag & 8 /* PROPS */) {\r\n            const dynamicProps = nextVNode.dynamicProps;\r\n            for (let i = 0; i < dynamicProps.length; i++) {\r\n                const key = dynamicProps[i];\r\n                if (nextProps[key] !== prevProps[key] &&\r\n                    !isEmitListener(emits, key)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // this path is only taken by manually written render functions\r\n        // so presence of any children leads to a forced update\r\n        if (prevChildren || nextChildren) {\r\n            if (!nextChildren || !nextChildren.$stable) {\r\n                return true;\r\n            }\r\n        }\r\n        if (prevProps === nextProps) {\r\n            return false;\r\n        }\r\n        if (!prevProps) {\r\n            return !!nextProps;\r\n        }\r\n        if (!nextProps) {\r\n            return true;\r\n        }\r\n        return hasPropsChanged(prevProps, nextProps, emits);\r\n    }\r\n    return false;\r\n}\r\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\r\n    const nextKeys = Object.keys(nextProps);\r\n    if (nextKeys.length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (let i = 0; i < nextKeys.length; i++) {\r\n        const key = nextKeys[i];\r\n        if (nextProps[key] !== prevProps[key] &&\r\n            !isEmitListener(emitsOptions, key)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction updateHOCHostEl({ vnode, parent }, el // HostNode\r\n) {\r\n    while (parent && parent.subTree === vnode) {\r\n        (vnode = parent.vnode).el = el;\r\n        parent = parent.parent;\r\n    }\r\n}\n\nconst isSuspense = (type) => type.__isSuspense;\r\n// Suspense exposes a component-like API, and is treated like a component\r\n// in the compiler, but internally it's a special built-in type that hooks\r\n// directly into the renderer.\r\nconst SuspenseImpl = {\r\n    name: 'Suspense',\r\n    // In order to make Suspense tree-shakable, we need to avoid importing it\r\n    // directly in the renderer. The renderer checks for the __isSuspense flag\r\n    // on a vnode's type and calls the `process` method, passing in renderer\r\n    // internals.\r\n    __isSuspense: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, \r\n    // platform-specific impl passed from renderer\r\n    rendererInternals) {\r\n        if (n1 == null) {\r\n            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);\r\n        }\r\n        else {\r\n            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);\r\n        }\r\n    },\r\n    hydrate: hydrateSuspense,\r\n    create: createSuspenseBoundary\r\n};\r\n// Force-casted public typing for h and TSX props inference\r\nconst Suspense = (SuspenseImpl\r\n    );\r\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {\r\n    const { p: patch, o: { createElement } } = rendererInternals;\r\n    const hiddenContainer = createElement('div');\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));\r\n    // start mounting the content subtree in an off-dom container\r\n    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);\r\n    // now check if we have encountered any async deps\r\n    if (suspense.deps > 0) {\r\n        // has async\r\n        // mount the fallback tree\r\n        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n        isSVG, slotScopeIds);\r\n        setActiveBranch(suspense, vnode.ssFallback);\r\n    }\r\n    else {\r\n        // Suspense has no async deps. Just resolve.\r\n        suspense.resolve();\r\n    }\r\n}\r\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\r\n    const suspense = (n2.suspense = n1.suspense);\r\n    suspense.vnode = n2;\r\n    n2.el = n1.el;\r\n    const newBranch = n2.ssContent;\r\n    const newFallback = n2.ssFallback;\r\n    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\r\n    if (pendingBranch) {\r\n        suspense.pendingBranch = newBranch;\r\n        if (isSameVNodeType(newBranch, pendingBranch)) {\r\n            // same root type but content may have changed.\r\n            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            if (suspense.deps <= 0) {\r\n                suspense.resolve();\r\n            }\r\n            else if (isInFallback) {\r\n                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, slotScopeIds, optimized);\r\n                setActiveBranch(suspense, newFallback);\r\n            }\r\n        }\r\n        else {\r\n            // toggled before pending tree is resolved\r\n            suspense.pendingId++;\r\n            if (isHydrating) {\r\n                // if toggled before hydration is finished, the current DOM tree is\r\n                // no longer valid. set it as the active branch so it will be unmounted\r\n                // when resolved\r\n                suspense.isHydrating = false;\r\n                suspense.activeBranch = pendingBranch;\r\n            }\r\n            else {\r\n                unmount(pendingBranch, parentComponent, suspense);\r\n            }\r\n            // increment pending ID. this is used to invalidate async callbacks\r\n            // reset suspense state\r\n            suspense.deps = 0;\r\n            // discard effects from pending branch\r\n            suspense.effects.length = 0;\r\n            // discard previous container\r\n            suspense.hiddenContainer = createElement('div');\r\n            if (isInFallback) {\r\n                // already in fallback state\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n                else {\r\n                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                    isSVG, slotScopeIds, optimized);\r\n                    setActiveBranch(suspense, newFallback);\r\n                }\r\n            }\r\n            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n                // toggled \"back\" to current active branch\r\n                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                // force resolve\r\n                suspense.resolve(true);\r\n            }\r\n            else {\r\n                // switched to a 3rd branch\r\n                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n                if (suspense.deps <= 0) {\r\n                    suspense.resolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\r\n            // root did not change, just normal patch\r\n            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            setActiveBranch(suspense, newBranch);\r\n        }\r\n        else {\r\n            // root node toggled\r\n            // invoke @pending event\r\n            const onPending = n2.props && n2.props.onPending;\r\n            if (shared.isFunction(onPending)) {\r\n                onPending();\r\n            }\r\n            // mount pending branch in off-dom container\r\n            suspense.pendingBranch = newBranch;\r\n            suspense.pendingId++;\r\n            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);\r\n            if (suspense.deps <= 0) {\r\n                // incoming branch has no async deps, resolve now.\r\n                suspense.resolve();\r\n            }\r\n            else {\r\n                const { timeout, pendingId } = suspense;\r\n                if (timeout > 0) {\r\n                    setTimeout(() => {\r\n                        if (suspense.pendingId === pendingId) {\r\n                            suspense.fallback(newFallback);\r\n                        }\r\n                    }, timeout);\r\n                }\r\n                else if (timeout === 0) {\r\n                    suspense.fallback(newFallback);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\r\n    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;\r\n    const timeout = shared.toNumber(vnode.props && vnode.props.timeout);\r\n    const suspense = {\r\n        vnode,\r\n        parent,\r\n        parentComponent,\r\n        isSVG,\r\n        container,\r\n        hiddenContainer,\r\n        anchor,\r\n        deps: 0,\r\n        pendingId: 0,\r\n        timeout: typeof timeout === 'number' ? timeout : -1,\r\n        activeBranch: null,\r\n        pendingBranch: null,\r\n        isInFallback: true,\r\n        isHydrating,\r\n        isUnmounted: false,\r\n        effects: [],\r\n        resolve(resume = false) {\r\n            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;\r\n            if (suspense.isHydrating) {\r\n                suspense.isHydrating = false;\r\n            }\r\n            else if (!resume) {\r\n                const delayEnter = activeBranch &&\r\n                    pendingBranch.transition &&\r\n                    pendingBranch.transition.mode === 'out-in';\r\n                if (delayEnter) {\r\n                    activeBranch.transition.afterLeave = () => {\r\n                        if (pendingId === suspense.pendingId) {\r\n                            move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                        }\r\n                    };\r\n                }\r\n                // this is initial anchor on mount\r\n                let { anchor } = suspense;\r\n                // unmount current active tree\r\n                if (activeBranch) {\r\n                    // if the fallback tree was mounted, it may have been moved\r\n                    // as part of a parent suspense. get the latest anchor for insertion\r\n                    anchor = next(activeBranch);\r\n                    unmount(activeBranch, parentComponent, suspense, true);\r\n                }\r\n                if (!delayEnter) {\r\n                    // move content from off-dom container to actual container\r\n                    move(pendingBranch, container, anchor, 0 /* ENTER */);\r\n                }\r\n            }\r\n            setActiveBranch(suspense, pendingBranch);\r\n            suspense.pendingBranch = null;\r\n            suspense.isInFallback = false;\r\n            // flush buffered effects\r\n            // check if there is a pending parent suspense\r\n            let parent = suspense.parent;\r\n            let hasUnresolvedAncestor = false;\r\n            while (parent) {\r\n                if (parent.pendingBranch) {\r\n                    // found a pending parent suspense, merge buffered post jobs\r\n                    // into that parent\r\n                    parent.effects.push(...effects);\r\n                    hasUnresolvedAncestor = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            // no pending parent suspense, flush all jobs\r\n            if (!hasUnresolvedAncestor) {\r\n                queuePostFlushCb(effects);\r\n            }\r\n            suspense.effects = [];\r\n            // invoke @resolve event\r\n            const onResolve = vnode.props && vnode.props.onResolve;\r\n            if (shared.isFunction(onResolve)) {\r\n                onResolve();\r\n            }\r\n        },\r\n        fallback(fallbackVNode) {\r\n            if (!suspense.pendingBranch) {\r\n                return;\r\n            }\r\n            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;\r\n            // invoke @fallback event\r\n            const onFallback = vnode.props && vnode.props.onFallback;\r\n            if (shared.isFunction(onFallback)) {\r\n                onFallback();\r\n            }\r\n            const anchor = next(activeBranch);\r\n            const mountFallback = () => {\r\n                if (!suspense.isInFallback) {\r\n                    return;\r\n                }\r\n                // mount the fallback tree\r\n                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context\r\n                isSVG, slotScopeIds, optimized);\r\n                setActiveBranch(suspense, fallbackVNode);\r\n            };\r\n            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';\r\n            if (delayEnter) {\r\n                activeBranch.transition.afterLeave = mountFallback;\r\n            }\r\n            // unmount current active branch\r\n            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now\r\n            true // shouldRemove\r\n            );\r\n            suspense.isInFallback = true;\r\n            if (!delayEnter) {\r\n                mountFallback();\r\n            }\r\n        },\r\n        move(container, anchor, type) {\r\n            suspense.activeBranch &&\r\n                move(suspense.activeBranch, container, anchor, type);\r\n            suspense.container = container;\r\n        },\r\n        next() {\r\n            return suspense.activeBranch && next(suspense.activeBranch);\r\n        },\r\n        registerDep(instance, setupRenderEffect) {\r\n            const isInPendingSuspense = !!suspense.pendingBranch;\r\n            if (isInPendingSuspense) {\r\n                suspense.deps++;\r\n            }\r\n            const hydratedEl = instance.vnode.el;\r\n            instance\r\n                .asyncDep.catch(err => {\r\n                handleError(err, instance, 0 /* SETUP_FUNCTION */);\r\n            })\r\n                .then(asyncSetupResult => {\r\n                // retry when the setup() promise resolves.\r\n                // component may have been unmounted before resolve.\r\n                if (instance.isUnmounted ||\r\n                    suspense.isUnmounted ||\r\n                    suspense.pendingId !== instance.suspenseId) {\r\n                    return;\r\n                }\r\n                // retry from this component\r\n                instance.asyncResolved = true;\r\n                const { vnode } = instance;\r\n                handleSetupResult(instance, asyncSetupResult, false);\r\n                if (hydratedEl) {\r\n                    // vnode may have been replaced if an update happened before the\r\n                    // async dep is resolved.\r\n                    vnode.el = hydratedEl;\r\n                }\r\n                const placeholder = !hydratedEl && instance.subTree.el;\r\n                setupRenderEffect(instance, vnode, \r\n                // component may have been moved before resolve.\r\n                // if this is not a hydration, instance.subTree will be the comment\r\n                // placeholder.\r\n                parentNode(hydratedEl || instance.subTree.el), \r\n                // anchor will not be used if this is hydration, so only need to\r\n                // consider the comment placeholder case.\r\n                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);\r\n                if (placeholder) {\r\n                    remove(placeholder);\r\n                }\r\n                updateHOCHostEl(instance, vnode.el);\r\n                // only decrease deps count if suspense is not already resolved\r\n                if (isInPendingSuspense && --suspense.deps === 0) {\r\n                    suspense.resolve();\r\n                }\r\n            });\r\n        },\r\n        unmount(parentSuspense, doRemove) {\r\n            suspense.isUnmounted = true;\r\n            if (suspense.activeBranch) {\r\n                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n            if (suspense.pendingBranch) {\r\n                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);\r\n            }\r\n        }\r\n    };\r\n    return suspense;\r\n}\r\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {\r\n    /* eslint-disable no-restricted-globals */\r\n    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));\r\n    // there are two possible scenarios for server-rendered suspense:\r\n    // - success: ssr content should be fully resolved\r\n    // - failure: ssr content should be the fallback branch.\r\n    // however, on the client we don't really know if it has failed or not\r\n    // attempt to hydrate the DOM assuming it has succeeded, but we still\r\n    // need to construct a suspense boundary first\r\n    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);\r\n    if (suspense.deps === 0) {\r\n        suspense.resolve();\r\n    }\r\n    return result;\r\n    /* eslint-enable no-restricted-globals */\r\n}\r\nfunction normalizeSuspenseChildren(vnode) {\r\n    const { shapeFlag, children } = vnode;\r\n    let content;\r\n    let fallback;\r\n    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        content = normalizeSuspenseSlot(children.default);\r\n        fallback = normalizeSuspenseSlot(children.fallback);\r\n    }\r\n    else {\r\n        content = normalizeSuspenseSlot(children);\r\n        fallback = normalizeVNode(null);\r\n    }\r\n    return {\r\n        content,\r\n        fallback\r\n    };\r\n}\r\nfunction normalizeSuspenseSlot(s) {\r\n    if (shared.isFunction(s)) {\r\n        s = s();\r\n    }\r\n    if (shared.isArray(s)) {\r\n        const singleChild = filterSingleRoot(s);\r\n        s = singleChild;\r\n    }\r\n    return normalizeVNode(s);\r\n}\r\nfunction queueEffectWithSuspense(fn, suspense) {\r\n    if (suspense && suspense.pendingBranch) {\r\n        if (shared.isArray(fn)) {\r\n            suspense.effects.push(...fn);\r\n        }\r\n        else {\r\n            suspense.effects.push(fn);\r\n        }\r\n    }\r\n    else {\r\n        queuePostFlushCb(fn);\r\n    }\r\n}\r\nfunction setActiveBranch(suspense, branch) {\r\n    suspense.activeBranch = branch;\r\n    const { vnode, parentComponent } = suspense;\r\n    const el = (vnode.el = branch.el);\r\n    // in case suspense is the root node of a component,\r\n    // recursively update the HOC el\r\n    if (parentComponent && parentComponent.subTree === vnode) {\r\n        parentComponent.vnode.el = el;\r\n        updateHOCHostEl(parentComponent, el);\r\n    }\r\n}\n\nfunction initProps(instance, rawProps, isStateful, // result of bitwise flag comparison\r\nisSSR = false) {\r\n    const props = {};\r\n    const attrs = {};\r\n    shared.def(attrs, InternalObjectKey, 1);\r\n    instance.propsDefaults = Object.create(null);\r\n    setFullProps(instance, rawProps, props, attrs);\r\n    if (isStateful) {\r\n        // stateful\r\n        instance.props = isSSR ? props : reactivity.shallowReactive(props);\r\n    }\r\n    else {\r\n        if (!instance.type.props) {\r\n            // functional w/ optional props, props === attrs\r\n            instance.props = attrs;\r\n        }\r\n        else {\r\n            // functional w/ declared props\r\n            instance.props = props;\r\n        }\r\n    }\r\n    instance.attrs = attrs;\r\n}\r\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\r\n    const { props, attrs, vnode: { patchFlag } } = instance;\r\n    const rawCurrentProps = reactivity.toRaw(props);\r\n    const [options] = instance.propsOptions;\r\n    if (\r\n    // always force full diff in dev\r\n    // - #1942 if hmr is enabled with sfc component\r\n    // - vite#872 non-sfc component used by sfc component\r\n    (optimized || patchFlag > 0) &&\r\n        !(patchFlag & 16 /* FULL_PROPS */)) {\r\n        if (patchFlag & 8 /* PROPS */) {\r\n            // Compiler-generated props & no keys change, just set the updated\r\n            // the props.\r\n            const propsToUpdate = instance.vnode.dynamicProps;\r\n            for (let i = 0; i < propsToUpdate.length; i++) {\r\n                const key = propsToUpdate[i];\r\n                // PROPS flag guarantees rawProps to be non-null\r\n                const value = rawProps[key];\r\n                if (options) {\r\n                    // attr / props separation was done on init and will be consistent\r\n                    // in this code path, so just check if attrs have it.\r\n                    if (shared.hasOwn(attrs, key)) {\r\n                        attrs[key] = value;\r\n                    }\r\n                    else {\r\n                        const camelizedKey = shared.camelize(key);\r\n                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    attrs[key] = value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // full props update.\r\n        setFullProps(instance, rawProps, props, attrs);\r\n        // in case of dynamic props, check if we need to delete keys from\r\n        // the props object\r\n        let kebabKey;\r\n        for (const key in rawCurrentProps) {\r\n            if (!rawProps ||\r\n                // for camelCase\r\n                (!shared.hasOwn(rawProps, key) &&\r\n                    // it's possible the original props was passed in as kebab-case\r\n                    // and converted to camelCase (#955)\r\n                    ((kebabKey = shared.hyphenate(key)) === key || !shared.hasOwn(rawProps, kebabKey)))) {\r\n                if (options) {\r\n                    if (rawPrevProps &&\r\n                        // for camelCase\r\n                        (rawPrevProps[key] !== undefined ||\r\n                            // for kebab-case\r\n                            rawPrevProps[kebabKey] !== undefined)) {\r\n                        props[key] = resolvePropValue(options, rawProps || shared.EMPTY_OBJ, key, undefined, instance);\r\n                    }\r\n                }\r\n                else {\r\n                    delete props[key];\r\n                }\r\n            }\r\n        }\r\n        // in the case of functional component w/o props declaration, props and\r\n        // attrs point to the same object so it should already have been updated.\r\n        if (attrs !== rawCurrentProps) {\r\n            for (const key in attrs) {\r\n                if (!rawProps || !shared.hasOwn(rawProps, key)) {\r\n                    delete attrs[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // trigger updates for $attrs in case it's used in component slots\r\n    reactivity.trigger(instance, \"set\" /* SET */, '$attrs');\r\n}\r\nfunction setFullProps(instance, rawProps, props, attrs) {\r\n    const [options, needCastKeys] = instance.propsOptions;\r\n    if (rawProps) {\r\n        for (const key in rawProps) {\r\n            const value = rawProps[key];\r\n            // key, ref are reserved and never passed down\r\n            if (shared.isReservedProp(key)) {\r\n                continue;\r\n            }\r\n            // prop option names are camelized during normalization, so to support\r\n            // kebab -> camel conversion here we need to camelize the key.\r\n            let camelKey;\r\n            if (options && shared.hasOwn(options, (camelKey = shared.camelize(key)))) {\r\n                props[camelKey] = value;\r\n            }\r\n            else if (!isEmitListener(instance.emitsOptions, key)) {\r\n                // Any non-declared (either as a prop or an emitted event) props are put\r\n                // into a separate `attrs` object for spreading. Make sure to preserve\r\n                // original key casing\r\n                attrs[key] = value;\r\n            }\r\n        }\r\n    }\r\n    if (needCastKeys) {\r\n        const rawCurrentProps = reactivity.toRaw(props);\r\n        for (let i = 0; i < needCastKeys.length; i++) {\r\n            const key = needCastKeys[i];\r\n            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key], instance);\r\n        }\r\n    }\r\n}\r\nfunction resolvePropValue(options, props, key, value, instance) {\r\n    const opt = options[key];\r\n    if (opt != null) {\r\n        const hasDefault = shared.hasOwn(opt, 'default');\r\n        // default values\r\n        if (hasDefault && value === undefined) {\r\n            const defaultValue = opt.default;\r\n            if (opt.type !== Function && shared.isFunction(defaultValue)) {\r\n                const { propsDefaults } = instance;\r\n                if (key in propsDefaults) {\r\n                    value = propsDefaults[key];\r\n                }\r\n                else {\r\n                    setCurrentInstance(instance);\r\n                    value = propsDefaults[key] = defaultValue(props);\r\n                    setCurrentInstance(null);\r\n                }\r\n            }\r\n            else {\r\n                value = defaultValue;\r\n            }\r\n        }\r\n        // boolean casting\r\n        if (opt[0 /* shouldCast */]) {\r\n            if (!shared.hasOwn(props, key) && !hasDefault) {\r\n                value = false;\r\n            }\r\n            else if (opt[1 /* shouldCastTrue */] &&\r\n                (value === '' || value === shared.hyphenate(key))) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\r\n    if (!appContext.deopt && comp.__props) {\r\n        return comp.__props;\r\n    }\r\n    const raw = comp.props;\r\n    const normalized = {};\r\n    const needCastKeys = [];\r\n    // apply mixin/extends props\r\n    let hasExtends = false;\r\n    if (!shared.isFunction(comp)) {\r\n        const extendProps = (raw) => {\r\n            hasExtends = true;\r\n            const [props, keys] = normalizePropsOptions(raw, appContext, true);\r\n            shared.extend(normalized, props);\r\n            if (keys)\r\n                needCastKeys.push(...keys);\r\n        };\r\n        if (!asMixin && appContext.mixins.length) {\r\n            appContext.mixins.forEach(extendProps);\r\n        }\r\n        if (comp.extends) {\r\n            extendProps(comp.extends);\r\n        }\r\n        if (comp.mixins) {\r\n            comp.mixins.forEach(extendProps);\r\n        }\r\n    }\r\n    if (!raw && !hasExtends) {\r\n        return (comp.__props = shared.EMPTY_ARR);\r\n    }\r\n    if (shared.isArray(raw)) {\r\n        for (let i = 0; i < raw.length; i++) {\r\n            const normalizedKey = shared.camelize(raw[i]);\r\n            if (validatePropName(normalizedKey)) {\r\n                normalized[normalizedKey] = shared.EMPTY_OBJ;\r\n            }\r\n        }\r\n    }\r\n    else if (raw) {\r\n        for (const key in raw) {\r\n            const normalizedKey = shared.camelize(key);\r\n            if (validatePropName(normalizedKey)) {\r\n                const opt = raw[key];\r\n                const prop = (normalized[normalizedKey] =\r\n                    shared.isArray(opt) || shared.isFunction(opt) ? { type: opt } : opt);\r\n                if (prop) {\r\n                    const booleanIndex = getTypeIndex(Boolean, prop.type);\r\n                    const stringIndex = getTypeIndex(String, prop.type);\r\n                    prop[0 /* shouldCast */] = booleanIndex > -1;\r\n                    prop[1 /* shouldCastTrue */] =\r\n                        stringIndex < 0 || booleanIndex < stringIndex;\r\n                    // if the prop needs boolean casting or default value\r\n                    if (booleanIndex > -1 || shared.hasOwn(prop, 'default')) {\r\n                        needCastKeys.push(normalizedKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (comp.__props = [normalized, needCastKeys]);\r\n}\r\nfunction validatePropName(key) {\r\n    if (key[0] !== '$') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n// use function string name to check type constructors\r\n// so that it works across vms / iframes.\r\nfunction getType(ctor) {\r\n    const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (shared.isArray(expectedTypes)) {\r\n        return expectedTypes.findIndex(t => isSameType(t, type));\r\n    }\r\n    else if (shared.isFunction(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    return -1;\r\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\r\n    if (target) {\r\n        const hooks = target[type] || (target[type] = []);\r\n        // cache the error handling wrapper for injected hooks so the same hook\r\n        // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\r\n        // handling\".\r\n        const wrappedHook = hook.__weh ||\r\n            (hook.__weh = (...args) => {\r\n                if (target.isUnmounted) {\r\n                    return;\r\n                }\r\n                // disable tracking inside all lifecycle hooks\r\n                // since they can potentially be called inside effects.\r\n                reactivity.pauseTracking();\r\n                // Set currentInstance during hook invocation.\r\n                // This assumes the hook does not synchronously trigger other hooks, which\r\n                // can only be false when the user does something really funky.\r\n                setCurrentInstance(target);\r\n                const res = callWithAsyncErrorHandling(hook, target, type, args);\r\n                setCurrentInstance(null);\r\n                reactivity.resetTracking();\r\n                return res;\r\n            });\r\n        if (prepend) {\r\n            hooks.unshift(wrappedHook);\r\n        }\r\n        else {\r\n            hooks.push(wrappedHook);\r\n        }\r\n        return wrappedHook;\r\n    }\r\n}\r\nconst createHook = (lifecycle) => (hook, target = currentInstance) => \r\n// post-create lifecycle registrations are noops during SSR\r\n!isInSSRComponentSetup && injectHook(lifecycle, hook, target);\r\nconst onBeforeMount = createHook(\"bm\" /* BEFORE_MOUNT */);\r\nconst onMounted = createHook(\"m\" /* MOUNTED */);\r\nconst onBeforeUpdate = createHook(\"bu\" /* BEFORE_UPDATE */);\r\nconst onUpdated = createHook(\"u\" /* UPDATED */);\r\nconst onBeforeUnmount = createHook(\"bum\" /* BEFORE_UNMOUNT */);\r\nconst onUnmounted = createHook(\"um\" /* UNMOUNTED */);\r\nconst onRenderTriggered = createHook(\"rtg\" /* RENDER_TRIGGERED */);\r\nconst onRenderTracked = createHook(\"rtc\" /* RENDER_TRACKED */);\r\nconst onErrorCaptured = (hook, target = currentInstance) => {\r\n    injectHook(\"ec\" /* ERROR_CAPTURED */, hook, target);\r\n};\n\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nconst INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = shared.EMPTY_OBJ, instance = currentInstance) {\r\n    let getter;\r\n    let forceTrigger = false;\r\n    if (reactivity.isRef(source)) {\r\n        getter = () => source.value;\r\n        forceTrigger = !!source._shallow;\r\n    }\r\n    else if (reactivity.isReactive(source)) {\r\n        getter = () => source;\r\n        deep = true;\r\n    }\r\n    else if (shared.isArray(source)) {\r\n        getter = () => source.map(s => {\r\n            if (reactivity.isRef(s)) {\r\n                return s.value;\r\n            }\r\n            else if (reactivity.isReactive(s)) {\r\n                return traverse(s);\r\n            }\r\n            else if (shared.isFunction(s)) {\r\n                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */, [\r\n                    instance && instance.proxy\r\n                ]);\r\n            }\r\n            else ;\r\n        });\r\n    }\r\n    else if (shared.isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */, [\r\n                instance && instance.proxy\r\n            ]);\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = () => {\r\n                if (instance && instance.isUnmounted) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = shared.NOOP;\r\n    }\r\n    if (cb && deep) {\r\n        const baseGetter = getter;\r\n        getter = () => traverse(baseGetter());\r\n    }\r\n    let cleanup;\r\n    let onInvalidate = (fn) => {\r\n        cleanup = runner.options.onStop = () => {\r\n            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isInSSRComponentSetup) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onInvalidate = shared.NOOP;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                getter(),\r\n                undefined,\r\n                onInvalidate\r\n            ]);\r\n        }\r\n        return shared.NOOP;\r\n    }\r\n    let oldValue = shared.isArray(source) ? [] : INITIAL_WATCHER_VALUE;\r\n    const job = () => {\r\n        if (!runner.active) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            const newValue = runner();\r\n            if (deep || forceTrigger || shared.hasChanged(newValue, oldValue)) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onInvalidate\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            runner();\r\n        }\r\n    };\r\n    // important: mark the job as a watcher callback so that scheduler knows\r\n    // it is allowed to self-trigger (#1727)\r\n    job.allowRecurse = !!cb;\r\n    let scheduler;\r\n    if (flush === 'sync') {\r\n        scheduler = job;\r\n    }\r\n    else if (flush === 'post') {\r\n        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\r\n    }\r\n    else {\r\n        // default: 'pre'\r\n        scheduler = () => {\r\n            if (!instance || instance.isMounted) {\r\n                queuePreFlushCb(job);\r\n            }\r\n            else {\r\n                // with 'pre' option, the first call must happen before\r\n                // the component is mounted so it is called synchronously.\r\n                job();\r\n            }\r\n        };\r\n    }\r\n    const runner = reactivity.effect(getter, {\r\n        lazy: true,\r\n        onTrack,\r\n        onTrigger,\r\n        scheduler\r\n    });\r\n    recordInstanceBoundEffect(runner, instance);\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            job();\r\n        }\r\n        else {\r\n            oldValue = runner();\r\n        }\r\n    }\r\n    else if (flush === 'post') {\r\n        queuePostRenderEffect(runner, instance && instance.suspense);\r\n    }\r\n    else {\r\n        runner();\r\n    }\r\n    return () => {\r\n        reactivity.stop(runner);\r\n        if (instance) {\r\n            shared.remove(instance.effects, runner);\r\n        }\r\n    };\r\n}\r\n// this.$watch\r\nfunction instanceWatch(source, cb, options) {\r\n    const publicThis = this.proxy;\r\n    const getter = shared.isString(source)\r\n        ? () => publicThis[source]\r\n        : source.bind(publicThis);\r\n    return doWatch(getter, cb.bind(publicThis), options, this);\r\n}\r\nfunction traverse(value, seen = new Set()) {\r\n    if (!shared.isObject(value) || seen.has(value)) {\r\n        return value;\r\n    }\r\n    seen.add(value);\r\n    if (reactivity.isRef(value)) {\r\n        traverse(value.value, seen);\r\n    }\r\n    else if (shared.isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            traverse(value[i], seen);\r\n        }\r\n    }\r\n    else if (shared.isSet(value) || shared.isMap(value)) {\r\n        value.forEach((v) => {\r\n            traverse(v, seen);\r\n        });\r\n    }\r\n    else {\r\n        for (const key in value) {\r\n            traverse(value[key], seen);\r\n        }\r\n    }\r\n    return value;\r\n}\n\nfunction useTransitionState() {\r\n    const state = {\r\n        isMounted: false,\r\n        isLeaving: false,\r\n        isUnmounting: false,\r\n        leavingVNodes: new Map()\r\n    };\r\n    onMounted(() => {\r\n        state.isMounted = true;\r\n    });\r\n    onBeforeUnmount(() => {\r\n        state.isUnmounting = true;\r\n    });\r\n    return state;\r\n}\r\nconst TransitionHookValidator = [Function, Array];\r\nconst BaseTransitionImpl = {\r\n    name: `BaseTransition`,\r\n    props: {\r\n        mode: String,\r\n        appear: Boolean,\r\n        persisted: Boolean,\r\n        // enter\r\n        onBeforeEnter: TransitionHookValidator,\r\n        onEnter: TransitionHookValidator,\r\n        onAfterEnter: TransitionHookValidator,\r\n        onEnterCancelled: TransitionHookValidator,\r\n        // leave\r\n        onBeforeLeave: TransitionHookValidator,\r\n        onLeave: TransitionHookValidator,\r\n        onAfterLeave: TransitionHookValidator,\r\n        onLeaveCancelled: TransitionHookValidator,\r\n        // appear\r\n        onBeforeAppear: TransitionHookValidator,\r\n        onAppear: TransitionHookValidator,\r\n        onAfterAppear: TransitionHookValidator,\r\n        onAppearCancelled: TransitionHookValidator\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        const state = useTransitionState();\r\n        let prevTransitionKey;\r\n        return () => {\r\n            const children = slots.default && getTransitionRawChildren(slots.default(), true);\r\n            if (!children || !children.length) {\r\n                return;\r\n            }\r\n            // there's no need to track reactivity for these props so use the raw\r\n            // props for a bit better perf\r\n            const rawProps = reactivity.toRaw(props);\r\n            const { mode } = rawProps;\r\n            // at this point children has a guaranteed length of 1.\r\n            const child = children[0];\r\n            if (state.isLeaving) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            // in the case of <transition><keep-alive/></transition>, we need to\r\n            // compare the type of the kept-alive children.\r\n            const innerChild = getKeepAliveChild(child);\r\n            if (!innerChild) {\r\n                return emptyPlaceholder(child);\r\n            }\r\n            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);\r\n            setTransitionHooks(innerChild, enterHooks);\r\n            const oldChild = instance.subTree;\r\n            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\r\n            let transitionKeyChanged = false;\r\n            const { getTransitionKey } = innerChild.type;\r\n            if (getTransitionKey) {\r\n                const key = getTransitionKey();\r\n                if (prevTransitionKey === undefined) {\r\n                    prevTransitionKey = key;\r\n                }\r\n                else if (key !== prevTransitionKey) {\r\n                    prevTransitionKey = key;\r\n                    transitionKeyChanged = true;\r\n                }\r\n            }\r\n            // handle mode\r\n            if (oldInnerChild &&\r\n                oldInnerChild.type !== Comment &&\r\n                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {\r\n                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);\r\n                // update old tree's hooks in case of dynamic transition\r\n                setTransitionHooks(oldInnerChild, leavingHooks);\r\n                // switching between different views\r\n                if (mode === 'out-in') {\r\n                    state.isLeaving = true;\r\n                    // return placeholder node and queue update when leave finishes\r\n                    leavingHooks.afterLeave = () => {\r\n                        state.isLeaving = false;\r\n                        instance.update();\r\n                    };\r\n                    return emptyPlaceholder(child);\r\n                }\r\n                else if (mode === 'in-out' && innerChild.type !== Comment) {\r\n                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\r\n                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);\r\n                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\r\n                        // early removal callback\r\n                        el._leaveCb = () => {\r\n                            earlyRemove();\r\n                            el._leaveCb = undefined;\r\n                            delete enterHooks.delayedLeave;\r\n                        };\r\n                        enterHooks.delayedLeave = delayedLeave;\r\n                    };\r\n                }\r\n            }\r\n            return child;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst BaseTransition = BaseTransitionImpl;\r\nfunction getLeavingNodesForType(state, vnode) {\r\n    const { leavingVNodes } = state;\r\n    let leavingVNodesCache = leavingVNodes.get(vnode.type);\r\n    if (!leavingVNodesCache) {\r\n        leavingVNodesCache = Object.create(null);\r\n        leavingVNodes.set(vnode.type, leavingVNodesCache);\r\n    }\r\n    return leavingVNodesCache;\r\n}\r\n// The transition hooks are attached to the vnode as vnode.transition\r\n// and will be called at appropriate timing in the renderer.\r\nfunction resolveTransitionHooks(vnode, props, state, instance) {\r\n    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;\r\n    const key = String(vnode.key);\r\n    const leavingVNodesCache = getLeavingNodesForType(state, vnode);\r\n    const callHook = (hook, args) => {\r\n        hook &&\r\n            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);\r\n    };\r\n    const hooks = {\r\n        mode,\r\n        persisted,\r\n        beforeEnter(el) {\r\n            let hook = onBeforeEnter;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onBeforeAppear || onBeforeEnter;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            // for same element (v-show)\r\n            if (el._leaveCb) {\r\n                el._leaveCb(true /* cancelled */);\r\n            }\r\n            // for toggled element with same key (v-if)\r\n            const leavingVNode = leavingVNodesCache[key];\r\n            if (leavingVNode &&\r\n                isSameVNodeType(vnode, leavingVNode) &&\r\n                leavingVNode.el._leaveCb) {\r\n                // force early removal (not cancelled)\r\n                leavingVNode.el._leaveCb();\r\n            }\r\n            callHook(hook, [el]);\r\n        },\r\n        enter(el) {\r\n            let hook = onEnter;\r\n            let afterHook = onAfterEnter;\r\n            let cancelHook = onEnterCancelled;\r\n            if (!state.isMounted) {\r\n                if (appear) {\r\n                    hook = onAppear || onEnter;\r\n                    afterHook = onAfterAppear || onAfterEnter;\r\n                    cancelHook = onAppearCancelled || onEnterCancelled;\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            let called = false;\r\n            const done = (el._enterCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                if (cancelled) {\r\n                    callHook(cancelHook, [el]);\r\n                }\r\n                else {\r\n                    callHook(afterHook, [el]);\r\n                }\r\n                if (hooks.delayedLeave) {\r\n                    hooks.delayedLeave();\r\n                }\r\n                el._enterCb = undefined;\r\n            });\r\n            if (hook) {\r\n                hook(el, done);\r\n                if (hook.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        leave(el, remove) {\r\n            const key = String(vnode.key);\r\n            if (el._enterCb) {\r\n                el._enterCb(true /* cancelled */);\r\n            }\r\n            if (state.isUnmounting) {\r\n                return remove();\r\n            }\r\n            callHook(onBeforeLeave, [el]);\r\n            let called = false;\r\n            const done = (el._leaveCb = (cancelled) => {\r\n                if (called)\r\n                    return;\r\n                called = true;\r\n                remove();\r\n                if (cancelled) {\r\n                    callHook(onLeaveCancelled, [el]);\r\n                }\r\n                else {\r\n                    callHook(onAfterLeave, [el]);\r\n                }\r\n                el._leaveCb = undefined;\r\n                if (leavingVNodesCache[key] === vnode) {\r\n                    delete leavingVNodesCache[key];\r\n                }\r\n            });\r\n            leavingVNodesCache[key] = vnode;\r\n            if (onLeave) {\r\n                onLeave(el, done);\r\n                if (onLeave.length <= 1) {\r\n                    done();\r\n                }\r\n            }\r\n            else {\r\n                done();\r\n            }\r\n        },\r\n        clone(vnode) {\r\n            return resolveTransitionHooks(vnode, props, state, instance);\r\n        }\r\n    };\r\n    return hooks;\r\n}\r\n// the placeholder really only handles one special case: KeepAlive\r\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\r\n// placeholder with empty content to avoid the KeepAlive instance from being\r\n// unmounted.\r\nfunction emptyPlaceholder(vnode) {\r\n    if (isKeepAlive(vnode)) {\r\n        vnode = cloneVNode(vnode);\r\n        vnode.children = null;\r\n        return vnode;\r\n    }\r\n}\r\nfunction getKeepAliveChild(vnode) {\r\n    return isKeepAlive(vnode)\r\n        ? vnode.children\r\n            ? vnode.children[0]\r\n            : undefined\r\n        : vnode;\r\n}\r\nfunction setTransitionHooks(vnode, hooks) {\r\n    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {\r\n        setTransitionHooks(vnode.component.subTree, hooks);\r\n    }\r\n    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n        vnode.ssContent.transition = hooks.clone(vnode.ssContent);\r\n        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\r\n    }\r\n    else {\r\n        vnode.transition = hooks;\r\n    }\r\n}\r\nfunction getTransitionRawChildren(children, keepComment = false) {\r\n    let ret = [];\r\n    let keyedFragmentCount = 0;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // handle fragment children case, e.g. v-for\r\n        if (child.type === Fragment) {\r\n            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)\r\n                keyedFragmentCount++;\r\n            ret = ret.concat(getTransitionRawChildren(child.children, keepComment));\r\n        }\r\n        // comment placeholders should be skipped, e.g. v-if\r\n        else if (keepComment || child.type !== Comment) {\r\n            ret.push(child);\r\n        }\r\n    }\r\n    // #1126 if a transition children list contains multiple sub fragments, these\r\n    // fragments will be merged into a flat children array. Since each v-for\r\n    // fragment may contain different static bindings inside, we need to de-op\r\n    // these children to force full diffs to ensure correct behavior.\r\n    if (keyedFragmentCount > 1) {\r\n        for (let i = 0; i < ret.length; i++) {\r\n            ret[i].patchFlag = -2 /* BAIL */;\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\r\nconst KeepAliveImpl = {\r\n    name: `KeepAlive`,\r\n    // Marker for special handling inside the renderer. We are not using a ===\r\n    // check directly on KeepAlive in the renderer, because importing it directly\r\n    // would prevent it from being tree-shaken.\r\n    __isKeepAlive: true,\r\n    props: {\r\n        include: [String, RegExp, Array],\r\n        exclude: [String, RegExp, Array],\r\n        max: [String, Number]\r\n    },\r\n    setup(props, { slots }) {\r\n        const instance = getCurrentInstance();\r\n        // KeepAlive communicates with the instantiated renderer via the\r\n        // ctx where the renderer passes in its internals,\r\n        // and the KeepAlive instance exposes activate/deactivate implementations.\r\n        // The whole point of this is to avoid importing KeepAlive directly in the\r\n        // renderer to facilitate tree-shaking.\r\n        const sharedContext = instance.ctx;\r\n        // if the internal renderer is not registered, it indicates that this is server-side rendering,\r\n        // for KeepAlive, we just need to render its children\r\n        if (!sharedContext.renderer) {\r\n            return slots.default;\r\n        }\r\n        const cache = new Map();\r\n        const keys = new Set();\r\n        let current = null;\r\n        const parentSuspense = instance.suspense;\r\n        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;\r\n        const storageContainer = createElement('div');\r\n        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\r\n            const instance = vnode.component;\r\n            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);\r\n            // in case props have changed\r\n            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);\r\n            queuePostRenderEffect(() => {\r\n                instance.isDeactivated = false;\r\n                if (instance.a) {\r\n                    shared.invokeArrayFns(instance.a);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n            }, parentSuspense);\r\n        };\r\n        sharedContext.deactivate = (vnode) => {\r\n            const instance = vnode.component;\r\n            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);\r\n            queuePostRenderEffect(() => {\r\n                if (instance.da) {\r\n                    shared.invokeArrayFns(instance.da);\r\n                }\r\n                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\r\n                if (vnodeHook) {\r\n                    invokeVNodeHook(vnodeHook, instance.parent, vnode);\r\n                }\r\n                instance.isDeactivated = true;\r\n            }, parentSuspense);\r\n        };\r\n        function unmount(vnode) {\r\n            // reset the shapeFlag so it can be properly unmounted\r\n            resetShapeFlag(vnode);\r\n            _unmount(vnode, instance, parentSuspense);\r\n        }\r\n        function pruneCache(filter) {\r\n            cache.forEach((vnode, key) => {\r\n                const name = getComponentName(vnode.type);\r\n                if (name && (!filter || !filter(name))) {\r\n                    pruneCacheEntry(key);\r\n                }\r\n            });\r\n        }\r\n        function pruneCacheEntry(key) {\r\n            const cached = cache.get(key);\r\n            if (!current || cached.type !== current.type) {\r\n                unmount(cached);\r\n            }\r\n            else if (current) {\r\n                // current active instance should no longer be kept-alive.\r\n                // we can't unmount it now but it might be later, so reset its flag now.\r\n                resetShapeFlag(current);\r\n            }\r\n            cache.delete(key);\r\n            keys.delete(key);\r\n        }\r\n        // prune cache on include/exclude prop change\r\n        watch(() => [props.include, props.exclude], ([include, exclude]) => {\r\n            include && pruneCache(name => matches(include, name));\r\n            exclude && pruneCache(name => !matches(exclude, name));\r\n        }, \r\n        // prune post-render after `current` has been updated\r\n        { flush: 'post', deep: true });\r\n        // cache sub tree after render\r\n        let pendingCacheKey = null;\r\n        const cacheSubtree = () => {\r\n            // fix #1621, the pendingCacheKey could be 0\r\n            if (pendingCacheKey != null) {\r\n                cache.set(pendingCacheKey, getInnerChild(instance.subTree));\r\n            }\r\n        };\r\n        onMounted(cacheSubtree);\r\n        onUpdated(cacheSubtree);\r\n        onBeforeUnmount(() => {\r\n            cache.forEach(cached => {\r\n                const { subTree, suspense } = instance;\r\n                const vnode = getInnerChild(subTree);\r\n                if (cached.type === vnode.type) {\r\n                    // current instance will be unmounted as part of keep-alive's unmount\r\n                    resetShapeFlag(vnode);\r\n                    // but invoke its deactivated hook here\r\n                    const da = vnode.component.da;\r\n                    da && queuePostRenderEffect(da, suspense);\r\n                    return;\r\n                }\r\n                unmount(cached);\r\n            });\r\n        });\r\n        return () => {\r\n            pendingCacheKey = null;\r\n            if (!slots.default) {\r\n                return null;\r\n            }\r\n            const children = slots.default();\r\n            const rawVNode = children[0];\r\n            if (children.length > 1) {\r\n                current = null;\r\n                return children;\r\n            }\r\n            else if (!isVNode(rawVNode) ||\r\n                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&\r\n                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {\r\n                current = null;\r\n                return rawVNode;\r\n            }\r\n            let vnode = getInnerChild(rawVNode);\r\n            const comp = vnode.type;\r\n            const name = getComponentName(comp);\r\n            const { include, exclude, max } = props;\r\n            if ((include && (!name || !matches(include, name))) ||\r\n                (exclude && name && matches(exclude, name))) {\r\n                current = vnode;\r\n                return rawVNode;\r\n            }\r\n            const key = vnode.key == null ? comp : vnode.key;\r\n            const cachedVNode = cache.get(key);\r\n            // clone vnode if it's reused because we are going to mutate it\r\n            if (vnode.el) {\r\n                vnode = cloneVNode(vnode);\r\n                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {\r\n                    rawVNode.ssContent = vnode;\r\n                }\r\n            }\r\n            // #1513 it's possible for the returned vnode to be cloned due to attr\r\n            // fallthrough or scopeId, so the vnode here may not be the final vnode\r\n            // that is mounted. Instead of caching it directly, we store the pending\r\n            // key and cache `instance.subTree` (the normalized vnode) in\r\n            // beforeMount/beforeUpdate hooks.\r\n            pendingCacheKey = key;\r\n            if (cachedVNode) {\r\n                // copy over mounted state\r\n                vnode.el = cachedVNode.el;\r\n                vnode.component = cachedVNode.component;\r\n                if (vnode.transition) {\r\n                    // recursively update transition hooks on subTree\r\n                    setTransitionHooks(vnode, vnode.transition);\r\n                }\r\n                // avoid vnode being mounted as fresh\r\n                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;\r\n                // make this key the freshest\r\n                keys.delete(key);\r\n                keys.add(key);\r\n            }\r\n            else {\r\n                keys.add(key);\r\n                // prune oldest entry\r\n                if (max && keys.size > parseInt(max, 10)) {\r\n                    pruneCacheEntry(keys.values().next().value);\r\n                }\r\n            }\r\n            // avoid vnode being unmounted\r\n            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n            current = vnode;\r\n            return rawVNode;\r\n        };\r\n    }\r\n};\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\nconst KeepAlive = KeepAliveImpl;\r\nfunction matches(pattern, name) {\r\n    if (shared.isArray(pattern)) {\r\n        return pattern.some((p) => matches(p, name));\r\n    }\r\n    else if (shared.isString(pattern)) {\r\n        return pattern.split(',').indexOf(name) > -1;\r\n    }\r\n    else if (pattern.test) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction onActivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"a\" /* ACTIVATED */, target);\r\n}\r\nfunction onDeactivated(hook, target) {\r\n    registerKeepAliveHook(hook, \"da\" /* DEACTIVATED */, target);\r\n}\r\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\r\n    // cache the deactivate branch check wrapper for injected hooks so the same\r\n    // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\r\n    // deactivation check\".\r\n    const wrappedHook = hook.__wdc ||\r\n        (hook.__wdc = () => {\r\n            // only fire the hook if the target instance is NOT in a deactivated branch.\r\n            let current = target;\r\n            while (current) {\r\n                if (current.isDeactivated) {\r\n                    return;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            hook();\r\n        });\r\n    injectHook(type, wrappedHook, target);\r\n    // In addition to registering it on the target instance, we walk up the parent\r\n    // chain and register it on all ancestor instances that are keep-alive roots.\r\n    // This avoids the need to walk the entire component tree when invoking these\r\n    // hooks, and more importantly, avoids the need to track child components in\r\n    // arrays.\r\n    if (target) {\r\n        let current = target.parent;\r\n        while (current && current.parent) {\r\n            if (isKeepAlive(current.parent.vnode)) {\r\n                injectToKeepAliveRoot(wrappedHook, type, target, current);\r\n            }\r\n            current = current.parent;\r\n        }\r\n    }\r\n}\r\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\r\n    // injectHook wraps the original for error handling, so make sure to remove\r\n    // the wrapped version.\r\n    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);\r\n    onUnmounted(() => {\r\n        shared.remove(keepAliveRoot[type], injected);\r\n    }, target);\r\n}\r\nfunction resetShapeFlag(vnode) {\r\n    let shapeFlag = vnode.shapeFlag;\r\n    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;\r\n    }\r\n    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;\r\n    }\r\n    vnode.shapeFlag = shapeFlag;\r\n}\r\nfunction getInnerChild(vnode) {\r\n    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;\r\n}\n\nconst isInternalKey = (key) => key[0] === '_' || key === '$stable';\r\nconst normalizeSlotValue = (value) => shared.isArray(value)\r\n    ? value.map(normalizeVNode)\r\n    : [normalizeVNode(value)];\r\nconst normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {\r\n    return normalizeSlotValue(rawSlot(props));\r\n}, ctx);\r\nconst normalizeObjectSlots = (rawSlots, slots) => {\r\n    const ctx = rawSlots._ctx;\r\n    for (const key in rawSlots) {\r\n        if (isInternalKey(key))\r\n            continue;\r\n        const value = rawSlots[key];\r\n        if (shared.isFunction(value)) {\r\n            slots[key] = normalizeSlot(key, value, ctx);\r\n        }\r\n        else if (value != null) {\r\n            const normalized = normalizeSlotValue(value);\r\n            slots[key] = () => normalized;\r\n        }\r\n    }\r\n};\r\nconst normalizeVNodeSlots = (instance, children) => {\r\n    const normalized = normalizeSlotValue(children);\r\n    instance.slots.default = () => normalized;\r\n};\r\nconst initSlots = (instance, children) => {\r\n    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            instance.slots = children;\r\n            // make compiler marker non-enumerable\r\n            shared.def(children, '_', type);\r\n        }\r\n        else {\r\n            normalizeObjectSlots(children, (instance.slots = {}));\r\n        }\r\n    }\r\n    else {\r\n        instance.slots = {};\r\n        if (children) {\r\n            normalizeVNodeSlots(instance, children);\r\n        }\r\n    }\r\n    shared.def(instance.slots, InternalObjectKey, 1);\r\n};\r\nconst updateSlots = (instance, children, optimized) => {\r\n    const { vnode, slots } = instance;\r\n    let needDeletionCheck = true;\r\n    let deletionComparisonTarget = shared.EMPTY_OBJ;\r\n    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {\r\n        const type = children._;\r\n        if (type) {\r\n            // compiled slots.\r\n            if (optimized && type === 1 /* STABLE */) {\r\n                // compiled AND stable.\r\n                // no need to update, and skip stale slots removal.\r\n                needDeletionCheck = false;\r\n            }\r\n            else {\r\n                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\r\n                // normalization.\r\n                shared.extend(slots, children);\r\n                // #2893\r\n                // when rendering the optimized slots by manually written render function,\r\n                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\r\n                // i.e. let the `renderSlot` create the bailed Fragment\r\n                if (!optimized && type === 1 /* STABLE */) {\r\n                    delete slots._;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            needDeletionCheck = !children.$stable;\r\n            normalizeObjectSlots(children, slots);\r\n        }\r\n        deletionComparisonTarget = children;\r\n    }\r\n    else if (children) {\r\n        // non slot object children (direct value) passed to a component\r\n        normalizeVNodeSlots(instance, children);\r\n        deletionComparisonTarget = { default: 1 };\r\n    }\r\n    // delete stale slots\r\n    if (needDeletionCheck) {\r\n        for (const key in slots) {\r\n            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\r\n                delete slots[key];\r\n            }\r\n        }\r\n    }\r\n};\n\n/**\r\nRuntime helper for applying directives to a vnode. Example usage:\r\n\nconst comp = resolveComponent('comp')\r\nconst foo = resolveDirective('foo')\r\nconst bar = resolveDirective('bar')\r\n\nreturn withDirectives(h(comp), [\r\n  [foo, this.x],\r\n  [bar, this.y]\r\n])\r\n*/\r\n/**\r\n * Adds directives to a VNode.\r\n */\r\nfunction withDirectives(vnode, directives) {\r\n    const internalInstance = currentRenderingInstance;\r\n    if (internalInstance === null) {\r\n        return vnode;\r\n    }\r\n    const instance = internalInstance.proxy;\r\n    const bindings = vnode.dirs || (vnode.dirs = []);\r\n    for (let i = 0; i < directives.length; i++) {\r\n        let [dir, value, arg, modifiers = shared.EMPTY_OBJ] = directives[i];\r\n        if (shared.isFunction(dir)) {\r\n            dir = {\r\n                mounted: dir,\r\n                updated: dir\r\n            };\r\n        }\r\n        bindings.push({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: void 0,\r\n            arg,\r\n            modifiers\r\n        });\r\n    }\r\n    return vnode;\r\n}\r\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\r\n    const bindings = vnode.dirs;\r\n    const oldBindings = prevVNode && prevVNode.dirs;\r\n    for (let i = 0; i < bindings.length; i++) {\r\n        const binding = bindings[i];\r\n        if (oldBindings) {\r\n            binding.oldValue = oldBindings[i].value;\r\n        }\r\n        const hook = binding.dir[name];\r\n        if (hook) {\r\n            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [\r\n                vnode.el,\r\n                binding,\r\n                vnode,\r\n                prevVNode\r\n            ]);\r\n        }\r\n    }\r\n}\n\nfunction createAppContext() {\r\n    return {\r\n        app: null,\r\n        config: {\r\n            isNativeTag: shared.NO,\r\n            performance: false,\r\n            globalProperties: {},\r\n            optionMergeStrategies: {},\r\n            isCustomElement: shared.NO,\r\n            errorHandler: undefined,\r\n            warnHandler: undefined\r\n        },\r\n        mixins: [],\r\n        components: {},\r\n        directives: {},\r\n        provides: Object.create(null)\r\n    };\r\n}\r\nlet uid = 0;\r\nfunction createAppAPI(render, hydrate) {\r\n    return function createApp(rootComponent, rootProps = null) {\r\n        if (rootProps != null && !shared.isObject(rootProps)) {\r\n            rootProps = null;\r\n        }\r\n        const context = createAppContext();\r\n        const installedPlugins = new Set();\r\n        let isMounted = false;\r\n        const app = (context.app = {\r\n            _uid: uid++,\r\n            _component: rootComponent,\r\n            _props: rootProps,\r\n            _container: null,\r\n            _context: context,\r\n            version,\r\n            get config() {\r\n                return context.config;\r\n            },\r\n            set config(v) {\r\n            },\r\n            use(plugin, ...options) {\r\n                if (installedPlugins.has(plugin)) ;\r\n                else if (plugin && shared.isFunction(plugin.install)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin.install(app, ...options);\r\n                }\r\n                else if (shared.isFunction(plugin)) {\r\n                    installedPlugins.add(plugin);\r\n                    plugin(app, ...options);\r\n                }\r\n                else ;\r\n                return app;\r\n            },\r\n            mixin(mixin) {\r\n                {\r\n                    if (!context.mixins.includes(mixin)) {\r\n                        context.mixins.push(mixin);\r\n                        // global mixin with props/emits de-optimizes props/emits\r\n                        // normalization caching.\r\n                        if (mixin.props || mixin.emits) {\r\n                            context.deopt = true;\r\n                        }\r\n                    }\r\n                }\r\n                return app;\r\n            },\r\n            component(name, component) {\r\n                if (!component) {\r\n                    return context.components[name];\r\n                }\r\n                context.components[name] = component;\r\n                return app;\r\n            },\r\n            directive(name, directive) {\r\n                if (!directive) {\r\n                    return context.directives[name];\r\n                }\r\n                context.directives[name] = directive;\r\n                return app;\r\n            },\r\n            mount(rootContainer, isHydrate, isSVG) {\r\n                if (!isMounted) {\r\n                    const vnode = createVNode(rootComponent, rootProps);\r\n                    // store app context on the root VNode.\r\n                    // this will be set on the root instance on initial mount.\r\n                    vnode.appContext = context;\r\n                    if (isHydrate && hydrate) {\r\n                        hydrate(vnode, rootContainer);\r\n                    }\r\n                    else {\r\n                        render(vnode, rootContainer, isSVG);\r\n                    }\r\n                    isMounted = true;\r\n                    app._container = rootContainer;\r\n                    rootContainer.__vue_app__ = app;\r\n                    return vnode.component.proxy;\r\n                }\r\n            },\r\n            unmount() {\r\n                if (isMounted) {\r\n                    render(null, app._container);\r\n                    delete app._container.__vue_app__;\r\n                }\r\n            },\r\n            provide(key, value) {\r\n                // TypeScript doesn't allow symbols as index type\r\n                // https://github.com/Microsoft/TypeScript/issues/24587\r\n                context.provides[key] = value;\r\n                return app;\r\n            }\r\n        });\r\n        return app;\r\n    };\r\n}\n\nlet hasMismatch = false;\r\nconst isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';\r\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\r\n// Note: hydration is DOM-specific\r\n// But we have to place it in core due to tight coupling with core - splitting\r\n// it out creates a ton of unnecessary complexity.\r\n// Hydration also depends on some renderer internal logic which needs to be\r\n// passed in via arguments.\r\nfunction createHydrationFunctions(rendererInternals) {\r\n    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;\r\n    const hydrate = (vnode, container) => {\r\n        hasMismatch = false;\r\n        hydrateNode(container.firstChild, vnode, null, null, null);\r\n        flushPostFlushCbs();\r\n        if (hasMismatch && !false) {\r\n            // this error should show up in production\r\n            console.error(`Hydration completed but contains mismatches.`);\r\n        }\r\n    };\r\n    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\r\n        const isFragmentStart = isComment(node) && node.data === '[';\r\n        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);\r\n        const { type, ref, shapeFlag } = vnode;\r\n        const domType = node.nodeType;\r\n        vnode.el = node;\r\n        let nextNode = null;\r\n        switch (type) {\r\n            case Text:\r\n                if (domType !== 3 /* TEXT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    if (node.data !== vnode.children) {\r\n                        hasMismatch = true;\r\n                        node.data = vnode.children;\r\n                    }\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Comment:\r\n                if (domType !== 8 /* COMMENT */ || isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = nextSibling(node);\r\n                }\r\n                break;\r\n            case Static:\r\n                if (domType !== 1 /* ELEMENT */) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    // determine anchor, adopt content\r\n                    nextNode = node;\r\n                    // if the static vnode has its content stripped during build,\r\n                    // adopt it from the server-rendered HTML.\r\n                    const needToAdoptContent = !vnode.children.length;\r\n                    for (let i = 0; i < vnode.staticCount; i++) {\r\n                        if (needToAdoptContent)\r\n                            vnode.children += nextNode.outerHTML;\r\n                        if (i === vnode.staticCount - 1) {\r\n                            vnode.anchor = nextNode;\r\n                        }\r\n                        nextNode = nextSibling(nextNode);\r\n                    }\r\n                    return nextNode;\r\n                }\r\n                break;\r\n            case Fragment:\r\n                if (!isFragmentStart) {\r\n                    nextNode = onMismatch();\r\n                }\r\n                else {\r\n                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                }\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    if (domType !== 1 /* ELEMENT */ ||\r\n                        vnode.type.toLowerCase() !==\r\n                            node.tagName.toLowerCase()) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    // when setting up the render effect, if the initial vnode already\r\n                    // has .el set, the component will perform hydration instead of mount\r\n                    // on its sub-tree.\r\n                    vnode.slotScopeIds = slotScopeIds;\r\n                    const container = parentNode(node);\r\n                    const hydrateComponent = () => {\r\n                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);\r\n                    };\r\n                    // async component\r\n                    const loadAsync = vnode.type.__asyncLoader;\r\n                    if (loadAsync) {\r\n                        loadAsync().then(hydrateComponent);\r\n                    }\r\n                    else {\r\n                        hydrateComponent();\r\n                    }\r\n                    // component may be async, so in the case of fragments we cannot rely\r\n                    // on component's rendered output to determine the end of the fragment\r\n                    // instead, we do a lookahead to find the end anchor node.\r\n                    nextNode = isFragmentStart\r\n                        ? locateClosingAsyncAnchor(node)\r\n                        : nextSibling(node);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    if (domType !== 8 /* COMMENT */) {\r\n                        nextNode = onMismatch();\r\n                    }\r\n                    else {\r\n                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);\r\n                    }\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);\r\n                }\r\n                else ;\r\n        }\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, vnode);\r\n        }\r\n        return nextNode;\r\n    };\r\n    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        optimized = optimized || !!vnode.dynamicChildren;\r\n        const { props, patchFlag, shapeFlag, dirs } = vnode;\r\n        // skip props & children if this is hoisted static nodes\r\n        if (patchFlag !== -1 /* HOISTED */) {\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                if (!optimized ||\r\n                    (patchFlag & 16 /* FULL_PROPS */ ||\r\n                        patchFlag & 32 /* HYDRATE_EVENTS */)) {\r\n                    for (const key in props) {\r\n                        if (!shared.isReservedProp(key) && shared.isOn(key)) {\r\n                            patchProp(el, key, null, props[key]);\r\n                        }\r\n                    }\r\n                }\r\n                else if (props.onClick) {\r\n                    // Fast path for click listeners (which is most often) to avoid\r\n                    // iterating through props.\r\n                    patchProp(el, 'onClick', null, props.onClick);\r\n                }\r\n            }\r\n            // vnode / directive hooks\r\n            let vnodeHooks;\r\n            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\r\n                invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n            }\r\n            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\r\n                queueEffectWithSuspense(() => {\r\n                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\r\n                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n                }, parentSuspense);\r\n            }\r\n            // children\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&\r\n                // skip if element has innerHTML / textContent\r\n                !(props && (props.innerHTML || props.textContent))) {\r\n                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                while (next) {\r\n                    hasMismatch = true;\r\n                    // The SSRed DOM contains more nodes than it should. Remove them.\r\n                    const cur = next;\r\n                    next = next.nextSibling;\r\n                    remove(cur);\r\n                }\r\n            }\r\n            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                if (el.textContent !== vnode.children) {\r\n                    hasMismatch = true;\r\n                    el.textContent = vnode.children;\r\n                }\r\n            }\r\n        }\r\n        return el.nextSibling;\r\n    };\r\n    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        optimized = optimized || !!parentVNode.dynamicChildren;\r\n        const children = parentVNode.children;\r\n        const l = children.length;\r\n        for (let i = 0; i < l; i++) {\r\n            const vnode = optimized\r\n                ? children[i]\r\n                : (children[i] = normalizeVNode(children[i]));\r\n            if (node) {\r\n                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n            }\r\n            else if (vnode.type === Text && !vnode.children) {\r\n                continue;\r\n            }\r\n            else {\r\n                hasMismatch = true;\r\n                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\r\n                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\r\n        const { slotScopeIds: fragmentSlotScopeIds } = vnode;\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        const container = parentNode(node);\r\n        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n        if (next && isComment(next) && next.data === ']') {\r\n            return nextSibling((vnode.anchor = next));\r\n        }\r\n        else {\r\n            // fragment didn't hydrate successfully, since we didn't get a end anchor\r\n            // back. This should have led to node/children mismatch warnings.\r\n            hasMismatch = true;\r\n            // since the anchor is missing, we need to create one and insert it\r\n            insert((vnode.anchor = createComment(`]`)), container, next);\r\n            return next;\r\n        }\r\n    };\r\n    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\r\n        hasMismatch = true;\r\n        vnode.el = null;\r\n        if (isFragment) {\r\n            // remove excessive fragment nodes\r\n            const end = locateClosingAsyncAnchor(node);\r\n            while (true) {\r\n                const next = nextSibling(node);\r\n                if (next && next !== end) {\r\n                    remove(next);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const next = nextSibling(node);\r\n        const container = parentNode(node);\r\n        remove(node);\r\n        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);\r\n        return next;\r\n    };\r\n    const locateClosingAsyncAnchor = (node) => {\r\n        let match = 0;\r\n        while (node) {\r\n            node = nextSibling(node);\r\n            if (node && isComment(node)) {\r\n                if (node.data === '[')\r\n                    match++;\r\n                if (node.data === ']') {\r\n                    if (match === 0) {\r\n                        return nextSibling(node);\r\n                    }\r\n                    else {\r\n                        match--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    return [hydrate, hydrateNode];\r\n}\n\n// implementation, close to no-op\r\nfunction defineComponent(options) {\r\n    return shared.isFunction(options) ? { setup: options, name: options.name } : options;\r\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\r\nfunction defineAsyncComponent(source) {\r\n    if (shared.isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out\r\n    suspensible = true, onError: userOnError } = source;\r\n    let pendingRequest = null;\r\n    let resolvedComp;\r\n    let retries = 0;\r\n    const retry = () => {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    const load = () => {\r\n        let thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest = loader()\r\n                .catch(err => {\r\n                err = err instanceof Error ? err : new Error(String(err));\r\n                if (userOnError) {\r\n                    return new Promise((resolve, reject) => {\r\n                        const userRetry = () => resolve(retry());\r\n                        const userFail = () => reject(err);\r\n                        userOnError(err, userRetry, userFail, retries + 1);\r\n                    });\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            })\r\n                .then((comp) => {\r\n                if (thisRequest !== pendingRequest && pendingRequest) {\r\n                    return pendingRequest;\r\n                }\r\n                // interop module default\r\n                if (comp &&\r\n                    (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                    comp = comp.default;\r\n                }\r\n                resolvedComp = comp;\r\n                return comp;\r\n            })));\r\n    };\r\n    return defineComponent({\r\n        __asyncLoader: load,\r\n        name: 'AsyncComponentWrapper',\r\n        setup() {\r\n            const instance = currentInstance;\r\n            // already resolved\r\n            if (resolvedComp) {\r\n                return () => createInnerComp(resolvedComp, instance);\r\n            }\r\n            const onError = (err) => {\r\n                pendingRequest = null;\r\n                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);\r\n            };\r\n            // suspense-controlled or SSR.\r\n            if ((suspensible && instance.suspense) ||\r\n                (isInSSRComponentSetup)) {\r\n                return load()\r\n                    .then(comp => {\r\n                    return () => createInnerComp(comp, instance);\r\n                })\r\n                    .catch(err => {\r\n                    onError(err);\r\n                    return () => errorComponent\r\n                        ? createVNode(errorComponent, {\r\n                            error: err\r\n                        })\r\n                        : null;\r\n                });\r\n            }\r\n            const loaded = reactivity.ref(false);\r\n            const error = reactivity.ref();\r\n            const delayed = reactivity.ref(!!delay);\r\n            if (delay) {\r\n                setTimeout(() => {\r\n                    delayed.value = false;\r\n                }, delay);\r\n            }\r\n            if (timeout != null) {\r\n                setTimeout(() => {\r\n                    if (!loaded.value && !error.value) {\r\n                        const err = new Error(`Async component timed out after ${timeout}ms.`);\r\n                        onError(err);\r\n                        error.value = err;\r\n                    }\r\n                }, timeout);\r\n            }\r\n            load()\r\n                .then(() => {\r\n                loaded.value = true;\r\n            })\r\n                .catch(err => {\r\n                onError(err);\r\n                error.value = err;\r\n            });\r\n            return () => {\r\n                if (loaded.value && resolvedComp) {\r\n                    return createInnerComp(resolvedComp, instance);\r\n                }\r\n                else if (error.value && errorComponent) {\r\n                    return createVNode(errorComponent, {\r\n                        error: error.value\r\n                    });\r\n                }\r\n                else if (loadingComponent && !delayed.value) {\r\n                    return createVNode(loadingComponent);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\nfunction createInnerComp(comp, { vnode: { ref, props, children } }) {\r\n    const vnode = createVNode(comp, props, children);\r\n    // ensure inner component inherits the async wrapper's ref owner\r\n    vnode.ref = ref;\r\n    return vnode;\r\n}\n\nconst prodEffectOptions = {\r\n    scheduler: queueJob,\r\n    // #1801, #2043 component render effects should allow recursive updates\r\n    allowRecurse: true\r\n};\r\nconst queuePostRenderEffect = queueEffectWithSuspense\r\n    ;\r\nconst setRef = (rawRef, oldRawRef, parentSuspense, vnode) => {\r\n    if (shared.isArray(rawRef)) {\r\n        rawRef.forEach((r, i) => setRef(r, oldRawRef && (shared.isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode));\r\n        return;\r\n    }\r\n    let value;\r\n    if (!vnode) {\r\n        // means unmount\r\n        value = null;\r\n    }\r\n    else if (isAsyncWrapper(vnode)) {\r\n        // when mounting async components, nothing needs to be done,\r\n        // because the template ref is forwarded to inner component\r\n        return;\r\n    }\r\n    else if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {\r\n        value = vnode.component.exposed || vnode.component.proxy;\r\n    }\r\n    else {\r\n        value = vnode.el;\r\n    }\r\n    const { i: owner, r: ref } = rawRef;\r\n    const oldRef = oldRawRef && oldRawRef.r;\r\n    const refs = owner.refs === shared.EMPTY_OBJ ? (owner.refs = {}) : owner.refs;\r\n    const setupState = owner.setupState;\r\n    // unset old ref\r\n    if (oldRef != null && oldRef !== ref) {\r\n        if (shared.isString(oldRef)) {\r\n            refs[oldRef] = null;\r\n            if (shared.hasOwn(setupState, oldRef)) {\r\n                setupState[oldRef] = null;\r\n            }\r\n        }\r\n        else if (reactivity.isRef(oldRef)) {\r\n            oldRef.value = null;\r\n        }\r\n    }\r\n    if (shared.isString(ref)) {\r\n        const doSet = () => {\r\n            refs[ref] = value;\r\n            if (shared.hasOwn(setupState, ref)) {\r\n                setupState[ref] = value;\r\n            }\r\n        };\r\n        // #1789: for non-null values, set them after render\r\n        // null values means this is unmount and it should not overwrite another\r\n        // ref with the same key\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (reactivity.isRef(ref)) {\r\n        const doSet = () => {\r\n            ref.value = value;\r\n        };\r\n        if (value) {\r\n            doSet.id = -1;\r\n            queuePostRenderEffect(doSet, parentSuspense);\r\n        }\r\n        else {\r\n            doSet();\r\n        }\r\n    }\r\n    else if (shared.isFunction(ref)) {\r\n        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);\r\n    }\r\n    else ;\r\n};\r\n/**\r\n * The createRenderer function accepts two generic arguments:\r\n * HostNode and HostElement, corresponding to Node and Element types in the\r\n * host environment. For example, for runtime-dom, HostNode would be the DOM\r\n * `Node` interface and HostElement would be the DOM `Element` interface.\r\n *\r\n * Custom renderers can pass in the platform specific types like this:\r\n *\r\n * ``` js\r\n * const { render, createApp } = createRenderer<Node, Element>({\r\n *   patchProp,\r\n *   ...nodeOps\r\n * })\r\n * ```\r\n */\r\nfunction createRenderer(options) {\r\n    return baseCreateRenderer(options);\r\n}\r\n// Separate API for creating hydration-enabled renderer.\r\n// Hydration logic is only used when calling this function, making it\r\n// tree-shakable.\r\nfunction createHydrationRenderer(options) {\r\n    return baseCreateRenderer(options, createHydrationFunctions);\r\n}\r\n// implementation\r\nfunction baseCreateRenderer(options, createHydrationFns) {\r\n    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = shared.NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;\r\n    // Note: functions inside this closure should use `const xxx = () => {}`\r\n    // style in order to prevent being inlined by minifiers.\r\n    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = false) => {\r\n        // patching & not same type, unmount old tree\r\n        if (n1 && !isSameVNodeType(n1, n2)) {\r\n            anchor = getNextHostNode(n1);\r\n            unmount(n1, parentComponent, parentSuspense, true);\r\n            n1 = null;\r\n        }\r\n        if (n2.patchFlag === -2 /* BAIL */) {\r\n            optimized = false;\r\n            n2.dynamicChildren = null;\r\n        }\r\n        const { type, ref, shapeFlag } = n2;\r\n        switch (type) {\r\n            case Text:\r\n                processText(n1, n2, container, anchor);\r\n                break;\r\n            case Comment:\r\n                processCommentNode(n1, n2, container, anchor);\r\n                break;\r\n            case Static:\r\n                if (n1 == null) {\r\n                    mountStaticNode(n2, container, anchor, isSVG);\r\n                }\r\n                break;\r\n            case Fragment:\r\n                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ELEMENT */) {\r\n                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 6 /* COMPONENT */) {\r\n                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (shapeFlag & 64 /* TELEPORT */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);\r\n                }\r\n                else ;\r\n        }\r\n        // set ref\r\n        if (ref != null && parentComponent) {\r\n            setRef(ref, n1 && n1.ref, parentSuspense, n2);\r\n        }\r\n    };\r\n    const processText = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);\r\n        }\r\n        else {\r\n            const el = (n2.el = n1.el);\r\n            if (n2.children !== n1.children) {\r\n                hostSetText(el, n2.children);\r\n            }\r\n        }\r\n    };\r\n    const processCommentNode = (n1, n2, container, anchor) => {\r\n        if (n1 == null) {\r\n            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);\r\n        }\r\n        else {\r\n            // there's no support for dynamic comments\r\n            n2.el = n1.el;\r\n        }\r\n    };\r\n    const mountStaticNode = (n2, container, anchor, isSVG) => {\r\n        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);\r\n    };\r\n    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostInsert(el, container, nextSibling);\r\n            el = next;\r\n        }\r\n        hostInsert(anchor, container, nextSibling);\r\n    };\r\n    const removeStaticNode = ({ el, anchor }) => {\r\n        let next;\r\n        while (el && el !== anchor) {\r\n            next = hostNextSibling(el);\r\n            hostRemove(el);\r\n            el = next;\r\n        }\r\n        hostRemove(anchor);\r\n    };\r\n    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        isSVG = isSVG || n2.type === 'svg';\r\n        if (n1 == null) {\r\n            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n    };\r\n    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let el;\r\n        let vnodeHook;\r\n        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;\r\n        if (vnode.el &&\r\n            hostCloneNode !== undefined &&\r\n            patchFlag === -1 /* HOISTED */) {\r\n            // If a vnode has non-null el, it means it's being reused.\r\n            // Only static vnodes can be reused, so its mounted DOM nodes should be\r\n            // exactly the same, and we can simply do a clone here.\r\n            // only do this in production since cloned trees cannot be HMR updated.\r\n            el = vnode.el = hostCloneNode(vnode.el);\r\n        }\r\n        else {\r\n            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);\r\n            // mount children first, since some props may rely on child content\r\n            // being already rendered, e.g. `<select value>`\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                hostSetElementText(el, vnode.children);\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized || !!vnode.dynamicChildren);\r\n            }\r\n            if (dirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'created');\r\n            }\r\n            // props\r\n            if (props) {\r\n                for (const key in props) {\r\n                    if (!shared.isReservedProp(key)) {\r\n                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n                if ((vnodeHook = props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                }\r\n            }\r\n            // scopeId\r\n            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');\r\n        }\r\n        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\r\n        // #1689 For inside suspense + suspense resolved case, just call it\r\n        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\r\n            transition &&\r\n            !transition.persisted;\r\n        if (needCallTransitionHooks) {\r\n            transition.beforeEnter(el);\r\n        }\r\n        hostInsert(el, container, anchor);\r\n        if ((vnodeHook = props && props.onVnodeMounted) ||\r\n            needCallTransitionHooks ||\r\n            dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                needCallTransitionHooks && transition.enter(el);\r\n                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\r\n        if (scopeId) {\r\n            hostSetScopeId(el, scopeId);\r\n        }\r\n        if (slotScopeIds) {\r\n            for (let i = 0; i < slotScopeIds.length; i++) {\r\n                hostSetScopeId(el, slotScopeIds[i]);\r\n            }\r\n        }\r\n        if (parentComponent) {\r\n            let subTree = parentComponent.subTree;\r\n            if (vnode === subTree) {\r\n                const parentVNode = parentComponent.vnode;\r\n                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);\r\n            }\r\n        }\r\n    };\r\n    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, slotScopeIds, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            const child = (children[i] = optimized\r\n                ? cloneIfMounted(children[i])\r\n                : normalizeVNode(children[i]));\r\n            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized, slotScopeIds);\r\n        }\r\n    };\r\n    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const el = (n2.el = n1.el);\r\n        let { patchFlag, dynamicChildren, dirs } = n2;\r\n        // #1426 take the old vnode's patch flag into account since user may clone a\r\n        // compiler-generated vnode, which de-opts to FULL_PROPS\r\n        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;\r\n        const oldProps = n1.props || shared.EMPTY_OBJ;\r\n        const newProps = n2.props || shared.EMPTY_OBJ;\r\n        let vnodeHook;\r\n        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n        }\r\n        if (dirs) {\r\n            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');\r\n        }\r\n        if (patchFlag > 0) {\r\n            // the presence of a patchFlag means this element's render code was\r\n            // generated by the compiler and can take the fast path.\r\n            // in this path old node and new node are guaranteed to have the same shape\r\n            // (i.e. at the exact same position in the source template)\r\n            if (patchFlag & 16 /* FULL_PROPS */) {\r\n                // element props contain dynamic keys, full diff needed\r\n                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n            }\r\n            else {\r\n                // class\r\n                // this flag is matched when the element has dynamic class bindings.\r\n                if (patchFlag & 2 /* CLASS */) {\r\n                    if (oldProps.class !== newProps.class) {\r\n                        hostPatchProp(el, 'class', null, newProps.class, isSVG);\r\n                    }\r\n                }\r\n                // style\r\n                // this flag is matched when the element has dynamic style bindings\r\n                if (patchFlag & 4 /* STYLE */) {\r\n                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);\r\n                }\r\n                // props\r\n                // This flag is matched when the element has dynamic prop/attr bindings\r\n                // other than class and style. The keys of dynamic prop/attrs are saved for\r\n                // faster iteration.\r\n                // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\r\n                // bail out and go through a full diff because we need to unset the old key\r\n                if (patchFlag & 8 /* PROPS */) {\r\n                    // if the flag is present then dynamicProps must be non-null\r\n                    const propsToUpdate = n2.dynamicProps;\r\n                    for (let i = 0; i < propsToUpdate.length; i++) {\r\n                        const key = propsToUpdate[i];\r\n                        const prev = oldProps[key];\r\n                        const next = newProps[key];\r\n                        if (next !== prev ||\r\n                            (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // text\r\n            // This flag is matched when the element has only dynamic text children.\r\n            if (patchFlag & 1 /* TEXT */) {\r\n                if (n1.children !== n2.children) {\r\n                    hostSetElementText(el, n2.children);\r\n                }\r\n            }\r\n        }\r\n        else if (!optimized && dynamicChildren == null) {\r\n            // unoptimized, full diff\r\n            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);\r\n        }\r\n        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';\r\n        if (dynamicChildren) {\r\n            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);\r\n        }\r\n        else if (!optimized) {\r\n            // full diff\r\n            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);\r\n        }\r\n        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\r\n                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    // The fast path for blocks.\r\n    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {\r\n        for (let i = 0; i < newChildren.length; i++) {\r\n            const oldVNode = oldChildren[i];\r\n            const newVNode = newChildren[i];\r\n            // Determine the container (parent element) for the patch.\r\n            const container = \r\n            // - In the case of a Fragment, we need to provide the actual parent\r\n            // of the Fragment itself so it can move its children.\r\n            oldVNode.type === Fragment ||\r\n                // - In the case of different nodes, there is going to be a replacement\r\n                // which also requires the correct parent container\r\n                !isSameVNodeType(oldVNode, newVNode) ||\r\n                // - In the case of a component, it could contain anything.\r\n                oldVNode.shapeFlag & 6 /* COMPONENT */ ||\r\n                oldVNode.shapeFlag & 64 /* TELEPORT */\r\n                ? hostParentNode(oldVNode.el)\r\n                : // In other cases, the parent container is not actually used so we\r\n                    // just pass the block element here to avoid a DOM parentNode call.\r\n                    fallbackContainer;\r\n            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);\r\n        }\r\n    };\r\n    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                // empty string is not valid prop\r\n                if (shared.isReservedProp(key))\r\n                    continue;\r\n                const next = newProps[key];\r\n                const prev = oldProps[key];\r\n                if (next !== prev ||\r\n                    (hostForcePatchProp && hostForcePatchProp(el, key))) {\r\n                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                }\r\n            }\r\n            if (oldProps !== shared.EMPTY_OBJ) {\r\n                for (const key in oldProps) {\r\n                    if (!shared.isReservedProp(key) && !(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));\r\n        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));\r\n        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\r\n        if (patchFlag > 0) {\r\n            optimized = true;\r\n        }\r\n        // check if this is a slot fragment with :slotted scope ids\r\n        if (fragmentSlotScopeIds) {\r\n            slotScopeIds = slotScopeIds\r\n                ? slotScopeIds.concat(fragmentSlotScopeIds)\r\n                : fragmentSlotScopeIds;\r\n        }\r\n        if (n1 == null) {\r\n            hostInsert(fragmentStartAnchor, container, anchor);\r\n            hostInsert(fragmentEndAnchor, container, anchor);\r\n            // a fragment can only have array children\r\n            // since they are either generated by the compiler, or implicitly created\r\n            // from arrays.\r\n            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        else {\r\n            if (patchFlag > 0 &&\r\n                patchFlag & 64 /* STABLE_FRAGMENT */ &&\r\n                dynamicChildren &&\r\n                // #2715 the previous fragment could've been a BAILed one as a result\r\n                // of renderSlot() with no valid children\r\n                n1.dynamicChildren) {\r\n                // a stable fragment (template root or <template v-for>) doesn't need to\r\n                // patch children order, but it may contain dynamicChildren.\r\n                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                if (\r\n                // #2080 if the stable fragment has a key, it's a <template v-for> that may\r\n                //  get moved around. Make sure all root level vnodes inherit el.\r\n                // #2134 or if it's a component root, it may also get moved around\r\n                // as the component is being moved.\r\n                n2.key != null ||\r\n                    (parentComponent && n2 === parentComponent.subTree)) {\r\n                    traverseStaticChildren(n1, n2, true /* shallow */);\r\n                }\r\n            }\r\n            else {\r\n                // keyed / unkeyed, or manual fragments.\r\n                // for keyed & unkeyed, since they are compiler generated from v-for,\r\n                // each child is guaranteed to be a block so the fragment will never\r\n                // have dynamicChildren.\r\n                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n        }\r\n    };\r\n    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        n2.slotScopeIds = slotScopeIds;\r\n        if (n1 == null) {\r\n            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {\r\n                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);\r\n            }\r\n            else {\r\n                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);\r\n            }\r\n        }\r\n        else {\r\n            updateComponent(n1, n2, optimized);\r\n        }\r\n    };\r\n    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));\r\n        // inject renderer internals for keepAlive\r\n        if (isKeepAlive(initialVNode)) {\r\n            instance.ctx.renderer = internals;\r\n        }\r\n        setupComponent(instance);\r\n        // setup() is async. This component relies on async logic to be resolved\r\n        // before proceeding\r\n        if (instance.asyncDep) {\r\n            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\r\n            // Give it a placeholder if this is not hydration\r\n            // TODO handle self-defined fallback\r\n            if (!initialVNode.el) {\r\n                const placeholder = (instance.subTree = createVNode(Comment));\r\n                processCommentNode(null, placeholder, container, anchor);\r\n            }\r\n            return;\r\n        }\r\n        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);\r\n    };\r\n    const updateComponent = (n1, n2, optimized) => {\r\n        const instance = (n2.component = n1.component);\r\n        if (shouldUpdateComponent(n1, n2, optimized)) {\r\n            if (instance.asyncDep &&\r\n                !instance.asyncResolved) {\r\n                updateComponentPreRender(instance, n2, optimized);\r\n                return;\r\n            }\r\n            else {\r\n                // normal update\r\n                instance.next = n2;\r\n                // in case the child component is also queued, remove it to avoid\r\n                // double updating the same child component in the same flush.\r\n                invalidateJob(instance.update);\r\n                // instance.update is the reactive effect runner.\r\n                instance.update();\r\n            }\r\n        }\r\n        else {\r\n            // no update needed. just copy over properties\r\n            n2.component = n1.component;\r\n            n2.el = n1.el;\r\n            instance.vnode = n2;\r\n        }\r\n    };\r\n    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\r\n        // create reactive effect for rendering\r\n        instance.update = reactivity.effect(function componentEffect() {\r\n            if (!instance.isMounted) {\r\n                let vnodeHook;\r\n                const { el, props } = initialVNode;\r\n                const { bm, m, parent } = instance;\r\n                // beforeMount hook\r\n                if (bm) {\r\n                    shared.invokeArrayFns(bm);\r\n                }\r\n                // onVnodeBeforeMount\r\n                if ((vnodeHook = props && props.onVnodeBeforeMount)) {\r\n                    invokeVNodeHook(vnodeHook, parent, initialVNode);\r\n                }\r\n                const subTree = (instance.subTree = renderComponentRoot(instance));\r\n                if (el && hydrateNode) {\r\n                    // vnode has adopted host node - perform hydration instead of mount.\r\n                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense, null);\r\n                }\r\n                else {\r\n                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);\r\n                    initialVNode.el = subTree.el;\r\n                }\r\n                // mounted hook\r\n                if (m) {\r\n                    queuePostRenderEffect(m, parentSuspense);\r\n                }\r\n                // onVnodeMounted\r\n                if ((vnodeHook = props && props.onVnodeMounted)) {\r\n                    const scopedInitialVNode = initialVNode;\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, scopedInitialVNode);\r\n                    }, parentSuspense);\r\n                }\r\n                // activated hook for keep-alive roots.\r\n                // #1742 activated hook must be accessed after first render\r\n                // since the hook may be injected by a child keep-alive\r\n                const { a } = instance;\r\n                if (a &&\r\n                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n                    queuePostRenderEffect(a, parentSuspense);\r\n                }\r\n                instance.isMounted = true;\r\n                // #2458: deference mount-only object parameters to prevent memleaks\r\n                initialVNode = container = anchor = null;\r\n            }\r\n            else {\r\n                // updateComponent\r\n                // This is triggered by mutation of component's own state (next: null)\r\n                // OR parent calling processComponent (next: VNode)\r\n                let { next, bu, u, parent, vnode } = instance;\r\n                let originNext = next;\r\n                let vnodeHook;\r\n                if (next) {\r\n                    next.el = vnode.el;\r\n                    updateComponentPreRender(instance, next, optimized);\r\n                }\r\n                else {\r\n                    next = vnode;\r\n                }\r\n                // beforeUpdate hook\r\n                if (bu) {\r\n                    shared.invokeArrayFns(bu);\r\n                }\r\n                // onVnodeBeforeUpdate\r\n                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\r\n                    invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                }\r\n                const nextTree = renderComponentRoot(instance);\r\n                const prevTree = instance.subTree;\r\n                instance.subTree = nextTree;\r\n                patch(prevTree, nextTree, \r\n                // parent may have changed if it's in a teleport\r\n                hostParentNode(prevTree.el), \r\n                // anchor may have changed if it's in a fragment\r\n                getNextHostNode(prevTree), instance, parentSuspense, isSVG);\r\n                next.el = nextTree.el;\r\n                if (originNext === null) {\r\n                    // self-triggered update. In case of HOC, update parent component\r\n                    // vnode el. HOC is indicated by parent instance's subTree pointing\r\n                    // to child component's vnode\r\n                    updateHOCHostEl(instance, nextTree.el);\r\n                }\r\n                // updated hook\r\n                if (u) {\r\n                    queuePostRenderEffect(u, parentSuspense);\r\n                }\r\n                // onVnodeUpdated\r\n                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\r\n                    queuePostRenderEffect(() => {\r\n                        invokeVNodeHook(vnodeHook, parent, next, vnode);\r\n                    }, parentSuspense);\r\n                }\r\n            }\r\n        }, prodEffectOptions);\r\n    };\r\n    const updateComponentPreRender = (instance, nextVNode, optimized) => {\r\n        nextVNode.component = instance;\r\n        const prevProps = instance.vnode.props;\r\n        instance.vnode = nextVNode;\r\n        instance.next = null;\r\n        updateProps(instance, nextVNode.props, prevProps, optimized);\r\n        updateSlots(instance, nextVNode.children, optimized);\r\n        reactivity.pauseTracking();\r\n        // props update may have triggered pre-flush watchers.\r\n        // flush them before the render update.\r\n        flushPreFlushCbs(undefined, instance.update);\r\n        reactivity.resetTracking();\r\n    };\r\n    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {\r\n        const c1 = n1 && n1.children;\r\n        const prevShapeFlag = n1 ? n1.shapeFlag : 0;\r\n        const c2 = n2.children;\r\n        const { patchFlag, shapeFlag } = n2;\r\n        // fast path\r\n        if (patchFlag > 0) {\r\n            if (patchFlag & 128 /* KEYED_FRAGMENT */) {\r\n                // this could be either fully-keyed or mixed (some keyed some not)\r\n                // presence of patchFlag means children are guaranteed to be arrays\r\n                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {\r\n                // unkeyed\r\n                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                return;\r\n            }\r\n        }\r\n        // children has 3 possibilities: text, array or no children.\r\n        if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n            // text children fast path\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                unmountChildren(c1, parentComponent, parentSuspense);\r\n            }\r\n            if (c2 !== c1) {\r\n                hostSetElementText(container, c2);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                // prev children was array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    // two arrays, cannot assume anything, do full diff\r\n                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else {\r\n                    // no new children, just unmount old\r\n                    unmountChildren(c1, parentComponent, parentSuspense, true);\r\n                }\r\n            }\r\n            else {\r\n                // prev children was text OR null\r\n                // new children is array OR null\r\n                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                    hostSetElementText(container, '');\r\n                }\r\n                // mount new if array\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        c1 = c1 || shared.EMPTY_ARR;\r\n        c2 = c2 || shared.EMPTY_ARR;\r\n        const oldLength = c1.length;\r\n        const newLength = c2.length;\r\n        const commonLength = Math.min(oldLength, newLength);\r\n        let i;\r\n        for (i = 0; i < commonLength; i++) {\r\n            const nextChild = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n        }\r\n        if (oldLength > newLength) {\r\n            // remove old\r\n            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);\r\n        }\r\n        else {\r\n            // mount new\r\n            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);\r\n        }\r\n    };\r\n    // can be all-keyed or mixed\r\n    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\r\n        let i = 0;\r\n        const l2 = c2.length;\r\n        let e1 = c1.length - 1; // prev ending index\r\n        let e2 = l2 - 1; // next ending index\r\n        // 1. sync from start\r\n        // (a b) c\r\n        // (a b) d e\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[i];\r\n            const n2 = (c2[i] = optimized\r\n                ? cloneIfMounted(c2[i])\r\n                : normalizeVNode(c2[i]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 2. sync from end\r\n        // a (b c)\r\n        // d e (b c)\r\n        while (i <= e1 && i <= e2) {\r\n            const n1 = c1[e1];\r\n            const n2 = (c2[e2] = optimized\r\n                ? cloneIfMounted(c2[e2])\r\n                : normalizeVNode(c2[e2]));\r\n            if (isSameVNodeType(n1, n2)) {\r\n                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        // 3. common sequence + mount\r\n        // (a b)\r\n        // (a b) c\r\n        // i = 2, e1 = 1, e2 = 2\r\n        // (a b)\r\n        // c (a b)\r\n        // i = 0, e1 = -1, e2 = 0\r\n        if (i > e1) {\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\r\n                while (i <= e2) {\r\n                    patch(null, (c2[i] = optimized\r\n                        ? cloneIfMounted(c2[i])\r\n                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        // 4. common sequence + unmount\r\n        // (a b) c\r\n        // (a b)\r\n        // i = 2, e1 = 2, e2 = 1\r\n        // a (b c)\r\n        // (b c)\r\n        // i = 0, e1 = 0, e2 = -1\r\n        else if (i > e2) {\r\n            while (i <= e1) {\r\n                unmount(c1[i], parentComponent, parentSuspense, true);\r\n                i++;\r\n            }\r\n        }\r\n        // 5. unknown sequence\r\n        // [i ... e1 + 1]: a b [c d e] f g\r\n        // [i ... e2 + 1]: a b [e d c h] f g\r\n        // i = 2, e1 = 4, e2 = 5\r\n        else {\r\n            const s1 = i; // prev starting index\r\n            const s2 = i; // next starting index\r\n            // 5.1 build key:index map for newChildren\r\n            const keyToNewIndexMap = new Map();\r\n            for (i = s2; i <= e2; i++) {\r\n                const nextChild = (c2[i] = optimized\r\n                    ? cloneIfMounted(c2[i])\r\n                    : normalizeVNode(c2[i]));\r\n                if (nextChild.key != null) {\r\n                    keyToNewIndexMap.set(nextChild.key, i);\r\n                }\r\n            }\r\n            // 5.2 loop through old children left to be patched and try to patch\r\n            // matching nodes & remove nodes that are no longer present\r\n            let j;\r\n            let patched = 0;\r\n            const toBePatched = e2 - s2 + 1;\r\n            let moved = false;\r\n            // used to track whether any node has moved\r\n            let maxNewIndexSoFar = 0;\r\n            // works as Map<newIndex, oldIndex>\r\n            // Note that oldIndex is offset by +1\r\n            // and oldIndex = 0 is a special value indicating the new node has\r\n            // no corresponding old node.\r\n            // used for determining longest stable subsequence\r\n            const newIndexToOldIndexMap = new Array(toBePatched);\r\n            for (i = 0; i < toBePatched; i++)\r\n                newIndexToOldIndexMap[i] = 0;\r\n            for (i = s1; i <= e1; i++) {\r\n                const prevChild = c1[i];\r\n                if (patched >= toBePatched) {\r\n                    // all new children have been patched so this can only be a removal\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key != null) {\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    // key-less node, try to locate a key-less node of the same type\r\n                    for (j = s2; j <= e2; j++) {\r\n                        if (newIndexToOldIndexMap[j - s2] === 0 &&\r\n                            isSameVNodeType(prevChild, c2[j])) {\r\n                            newIndex = j;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex === undefined) {\r\n                    unmount(prevChild, parentComponent, parentSuspense, true);\r\n                }\r\n                else {\r\n                    newIndexToOldIndexMap[newIndex - s2] = i + 1;\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                    patched++;\r\n                }\r\n            }\r\n            // 5.3 move and mount\r\n            // generate longest stable subsequence only when nodes have moved\r\n            const increasingNewIndexSequence = moved\r\n                ? getSequence(newIndexToOldIndexMap)\r\n                : shared.EMPTY_ARR;\r\n            j = increasingNewIndexSequence.length - 1;\r\n            // looping backwards so that we can use last patched node as anchor\r\n            for (i = toBePatched - 1; i >= 0; i--) {\r\n                const nextIndex = s2 + i;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\r\n                if (newIndexToOldIndexMap[i] === 0) {\r\n                    // mount new\r\n                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n                else if (moved) {\r\n                    // move if:\r\n                    // There is no stable subsequence (e.g. a reverse)\r\n                    // OR current node is not among the stable sequence\r\n                    if (j < 0 || i !== increasingNewIndexSequence[j]) {\r\n                        move(nextChild, container, anchor, 2 /* REORDER */);\r\n                    }\r\n                    else {\r\n                        j--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\r\n        const { el, type, transition, children, shapeFlag } = vnode;\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            move(vnode.component.subTree, container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 128 /* SUSPENSE */) {\r\n            vnode.suspense.move(container, anchor, moveType);\r\n            return;\r\n        }\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type.move(vnode, container, anchor, internals);\r\n            return;\r\n        }\r\n        if (type === Fragment) {\r\n            hostInsert(el, container, anchor);\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, anchor, moveType);\r\n            }\r\n            hostInsert(vnode.anchor, container, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            moveStaticNode(vnode, container, anchor);\r\n            return;\r\n        }\r\n        // single nodes\r\n        const needTransition = moveType !== 2 /* REORDER */ &&\r\n            shapeFlag & 1 /* ELEMENT */ &&\r\n            transition;\r\n        if (needTransition) {\r\n            if (moveType === 0 /* ENTER */) {\r\n                transition.beforeEnter(el);\r\n                hostInsert(el, container, anchor);\r\n                queuePostRenderEffect(() => transition.enter(el), parentSuspense);\r\n            }\r\n            else {\r\n                const { leave, delayLeave, afterLeave } = transition;\r\n                const remove = () => hostInsert(el, container, anchor);\r\n                const performLeave = () => {\r\n                    leave(el, () => {\r\n                        remove();\r\n                        afterLeave && afterLeave();\r\n                    });\r\n                };\r\n                if (delayLeave) {\r\n                    delayLeave(el, remove, performLeave);\r\n                }\r\n                else {\r\n                    performLeave();\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            hostInsert(el, container, anchor);\r\n        }\r\n    };\r\n    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\r\n        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;\r\n        // unset ref\r\n        if (ref != null) {\r\n            setRef(ref, null, parentSuspense, null);\r\n        }\r\n        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {\r\n            parentComponent.ctx.deactivate(vnode);\r\n            return;\r\n        }\r\n        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;\r\n        let vnodeHook;\r\n        if ((vnodeHook = props && props.onVnodeBeforeUnmount)) {\r\n            invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n        }\r\n        if (shapeFlag & 6 /* COMPONENT */) {\r\n            unmountComponent(vnode.component, parentSuspense, doRemove);\r\n        }\r\n        else {\r\n            if (shapeFlag & 128 /* SUSPENSE */) {\r\n                vnode.suspense.unmount(parentSuspense, doRemove);\r\n                return;\r\n            }\r\n            if (shouldInvokeDirs) {\r\n                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');\r\n            }\r\n            if (shapeFlag & 64 /* TELEPORT */) {\r\n                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);\r\n            }\r\n            else if (dynamicChildren &&\r\n                // #1153: fast path should not be taken for non-stable (v-for) fragments\r\n                (type !== Fragment ||\r\n                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {\r\n                // fast path for block nodes: only need to unmount dynamic children.\r\n                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);\r\n            }\r\n            else if ((type === Fragment &&\r\n                (patchFlag & 128 /* KEYED_FRAGMENT */ ||\r\n                    patchFlag & 256 /* UNKEYED_FRAGMENT */)) ||\r\n                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {\r\n                unmountChildren(children, parentComponent, parentSuspense);\r\n            }\r\n            if (doRemove) {\r\n                remove(vnode);\r\n            }\r\n        }\r\n        if ((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\r\n            queuePostRenderEffect(() => {\r\n                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\r\n                shouldInvokeDirs &&\r\n                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');\r\n            }, parentSuspense);\r\n        }\r\n    };\r\n    const remove = vnode => {\r\n        const { type, el, anchor, transition } = vnode;\r\n        if (type === Fragment) {\r\n            removeFragment(el, anchor);\r\n            return;\r\n        }\r\n        if (type === Static) {\r\n            removeStaticNode(vnode);\r\n            return;\r\n        }\r\n        const performRemove = () => {\r\n            hostRemove(el);\r\n            if (transition && !transition.persisted && transition.afterLeave) {\r\n                transition.afterLeave();\r\n            }\r\n        };\r\n        if (vnode.shapeFlag & 1 /* ELEMENT */ &&\r\n            transition &&\r\n            !transition.persisted) {\r\n            const { leave, delayLeave } = transition;\r\n            const performLeave = () => leave(el, performRemove);\r\n            if (delayLeave) {\r\n                delayLeave(vnode.el, performRemove, performLeave);\r\n            }\r\n            else {\r\n                performLeave();\r\n            }\r\n        }\r\n        else {\r\n            performRemove();\r\n        }\r\n    };\r\n    const removeFragment = (cur, end) => {\r\n        // For fragments, directly remove all contained DOM nodes.\r\n        // (fragment child nodes cannot have transition)\r\n        let next;\r\n        while (cur !== end) {\r\n            next = hostNextSibling(cur);\r\n            hostRemove(cur);\r\n            cur = next;\r\n        }\r\n        hostRemove(end);\r\n    };\r\n    const unmountComponent = (instance, parentSuspense, doRemove) => {\r\n        const { bum, effects, update, subTree, um } = instance;\r\n        // beforeUnmount hook\r\n        if (bum) {\r\n            shared.invokeArrayFns(bum);\r\n        }\r\n        if (effects) {\r\n            for (let i = 0; i < effects.length; i++) {\r\n                reactivity.stop(effects[i]);\r\n            }\r\n        }\r\n        // update may be null if a component is unmounted before its async\r\n        // setup has resolved.\r\n        if (update) {\r\n            reactivity.stop(update);\r\n            unmount(subTree, instance, parentSuspense, doRemove);\r\n        }\r\n        // unmounted hook\r\n        if (um) {\r\n            queuePostRenderEffect(um, parentSuspense);\r\n        }\r\n        queuePostRenderEffect(() => {\r\n            instance.isUnmounted = true;\r\n        }, parentSuspense);\r\n        // A component with async dep inside a pending suspense is unmounted before\r\n        // its async dep resolves. This should remove the dep from the suspense, and\r\n        // cause the suspense to resolve immediately if that was the last dep.\r\n        if (parentSuspense &&\r\n            parentSuspense.pendingBranch &&\r\n            !parentSuspense.isUnmounted &&\r\n            instance.asyncDep &&\r\n            !instance.asyncResolved &&\r\n            instance.suspenseId === parentSuspense.pendingId) {\r\n            parentSuspense.deps--;\r\n            if (parentSuspense.deps === 0) {\r\n                parentSuspense.resolve();\r\n            }\r\n        }\r\n    };\r\n    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\r\n        for (let i = start; i < children.length; i++) {\r\n            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\r\n        }\r\n    };\r\n    const getNextHostNode = vnode => {\r\n        if (vnode.shapeFlag & 6 /* COMPONENT */) {\r\n            return getNextHostNode(vnode.component.subTree);\r\n        }\r\n        if (vnode.shapeFlag & 128 /* SUSPENSE */) {\r\n            return vnode.suspense.next();\r\n        }\r\n        return hostNextSibling((vnode.anchor || vnode.el));\r\n    };\r\n    const render = (vnode, container, isSVG) => {\r\n        if (vnode == null) {\r\n            if (container._vnode) {\r\n                unmount(container._vnode, null, null, true);\r\n            }\r\n        }\r\n        else {\r\n            patch(container._vnode || null, vnode, container, null, null, null, isSVG);\r\n        }\r\n        flushPostFlushCbs();\r\n        container._vnode = vnode;\r\n    };\r\n    const internals = {\r\n        p: patch,\r\n        um: unmount,\r\n        m: move,\r\n        r: remove,\r\n        mt: mountComponent,\r\n        mc: mountChildren,\r\n        pc: patchChildren,\r\n        pbc: patchBlockChildren,\r\n        n: getNextHostNode,\r\n        o: options\r\n    };\r\n    let hydrate;\r\n    let hydrateNode;\r\n    if (createHydrationFns) {\r\n        [hydrate, hydrateNode] = createHydrationFns(internals);\r\n    }\r\n    return {\r\n        render,\r\n        hydrate,\r\n        createApp: createAppAPI(render, hydrate)\r\n    };\r\n}\r\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\r\n    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [\r\n        vnode,\r\n        prevVNode\r\n    ]);\r\n}\r\n/**\r\n * #1156\r\n * When a component is HMR-enabled, we need to make sure that all static nodes\r\n * inside a block also inherit the DOM element from the previous tree so that\r\n * HMR updates (which are full updates) can retrieve the element for patching.\r\n *\r\n * #2080\r\n * Inside keyed `template` fragment static children, if a fragment is moved,\r\n * the children will always moved so that need inherit el form previous nodes\r\n * to ensure correct moved position.\r\n */\r\nfunction traverseStaticChildren(n1, n2, shallow = false) {\r\n    const ch1 = n1.children;\r\n    const ch2 = n2.children;\r\n    if (shared.isArray(ch1) && shared.isArray(ch2)) {\r\n        for (let i = 0; i < ch1.length; i++) {\r\n            // this is only called in the optimized path so array children are\r\n            // guaranteed to be vnodes\r\n            const c1 = ch1[i];\r\n            let c2 = ch2[i];\r\n            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {\r\n                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {\r\n                    c2 = ch2[i] = cloneIfMounted(ch2[i]);\r\n                    c2.el = c1.el;\r\n                }\r\n                if (!shallow)\r\n                    traverseStaticChildren(c1, c2);\r\n            }\r\n        }\r\n    }\r\n}\r\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction getSequence(arr) {\r\n    const p = arr.slice();\r\n    const result = [0];\r\n    let i, j, u, v, c;\r\n    const len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        const arrI = arr[i];\r\n        if (arrI !== 0) {\r\n            j = result[result.length - 1];\r\n            if (arr[j] < arrI) {\r\n                p[i] = j;\r\n                result.push(i);\r\n                continue;\r\n            }\r\n            u = 0;\r\n            v = result.length - 1;\r\n            while (u < v) {\r\n                c = ((u + v) / 2) | 0;\r\n                if (arr[result[c]] < arrI) {\r\n                    u = c + 1;\r\n                }\r\n                else {\r\n                    v = c;\r\n                }\r\n            }\r\n            if (arrI < arr[result[u]]) {\r\n                if (u > 0) {\r\n                    p[i] = result[u - 1];\r\n                }\r\n                result[u] = i;\r\n            }\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\n\nconst isTeleport = (type) => type.__isTeleport;\r\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');\r\nconst isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;\r\nconst resolveTarget = (props, select) => {\r\n    const targetSelector = props && props.to;\r\n    if (shared.isString(targetSelector)) {\r\n        if (!select) {\r\n            return null;\r\n        }\r\n        else {\r\n            const target = select(targetSelector);\r\n            return target;\r\n        }\r\n    }\r\n    else {\r\n        return targetSelector;\r\n    }\r\n};\r\nconst TeleportImpl = {\r\n    __isTeleport: true,\r\n    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\r\n        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;\r\n        const disabled = isTeleportDisabled(n2.props);\r\n        const { shapeFlag, children } = n2;\r\n        if (n1 == null) {\r\n            // insert anchors in the main view\r\n            const placeholder = (n2.el = createText(''));\r\n            const mainAnchor = (n2.anchor = createText(''));\r\n            insert(placeholder, container, anchor);\r\n            insert(mainAnchor, container, anchor);\r\n            const target = (n2.target = resolveTarget(n2.props, querySelector));\r\n            const targetAnchor = (n2.targetAnchor = createText(''));\r\n            if (target) {\r\n                insert(targetAnchor, target);\r\n                // #2652 we could be teleporting from a non-SVG tree into an SVG tree\r\n                isSVG = isSVG || isTargetSVG(target);\r\n            }\r\n            const mount = (container, anchor) => {\r\n                // Teleport *always* has Array children. This is enforced in both the\r\n                // compiler and vnode children normalization.\r\n                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);\r\n                }\r\n            };\r\n            if (disabled) {\r\n                mount(container, mainAnchor);\r\n            }\r\n            else if (target) {\r\n                mount(target, targetAnchor);\r\n            }\r\n        }\r\n        else {\r\n            // update content\r\n            n2.el = n1.el;\r\n            const mainAnchor = (n2.anchor = n1.anchor);\r\n            const target = (n2.target = n1.target);\r\n            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);\r\n            const wasDisabled = isTeleportDisabled(n1.props);\r\n            const currentContainer = wasDisabled ? container : target;\r\n            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\r\n            isSVG = isSVG || isTargetSVG(target);\r\n            if (n2.dynamicChildren) {\r\n                // fast path when the teleport happens to be a block root\r\n                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);\r\n                // even in block tree mode we need to make sure all root-level nodes\r\n                // in the teleport inherit previous DOM references so that they can\r\n                // be moved in future patches.\r\n                traverseStaticChildren(n1, n2, true);\r\n            }\r\n            else if (!optimized) {\r\n                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);\r\n            }\r\n            if (disabled) {\r\n                if (!wasDisabled) {\r\n                    // enabled -> disabled\r\n                    // move into main container\r\n                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n            else {\r\n                // target changed\r\n                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\r\n                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));\r\n                    if (nextTarget) {\r\n                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);\r\n                    }\r\n                }\r\n                else if (wasDisabled) {\r\n                    // disabled -> enabled\r\n                    // move into teleport target\r\n                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\r\n        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\r\n        if (target) {\r\n            hostRemove(targetAnchor);\r\n        }\r\n        // an unmounted teleport should always remove its children if not disabled\r\n        if (doRemove || !isTeleportDisabled(props)) {\r\n            hostRemove(anchor);\r\n            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                for (let i = 0; i < children.length; i++) {\r\n                    unmount(children[i], parentComponent, parentSuspense, true, optimized);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    move: moveTeleport,\r\n    hydrate: hydrateTeleport\r\n};\r\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {\r\n    // move target anchor if this is a target change.\r\n    if (moveType === 0 /* TARGET_CHANGE */) {\r\n        insert(vnode.targetAnchor, container, parentAnchor);\r\n    }\r\n    const { el, anchor, shapeFlag, children, props } = vnode;\r\n    const isReorder = moveType === 2 /* REORDER */;\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(el, container, parentAnchor);\r\n    }\r\n    // if this is a re-order and teleport is enabled (content is in target)\r\n    // do not move children. So the opposite is: only move children if this\r\n    // is not a reorder, or the teleport is disabled\r\n    if (!isReorder || isTeleportDisabled(props)) {\r\n        // Teleport has either Array children or no children.\r\n        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            for (let i = 0; i < children.length; i++) {\r\n                move(children[i], container, parentAnchor, 2 /* REORDER */);\r\n            }\r\n        }\r\n    }\r\n    // move main view anchor if this is a re-order.\r\n    if (isReorder) {\r\n        insert(anchor, container, parentAnchor);\r\n    }\r\n}\r\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {\r\n    const target = (vnode.target = resolveTarget(vnode.props, querySelector));\r\n    if (target) {\r\n        // if multiple teleports rendered to the same target element, we need to\r\n        // pick up from where the last teleport finished instead of the first node\r\n        const targetNode = target._lpa || target.firstChild;\r\n        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n            if (isTeleportDisabled(vnode.props)) {\r\n                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);\r\n                vnode.targetAnchor = targetNode;\r\n            }\r\n            else {\r\n                vnode.anchor = nextSibling(node);\r\n                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);\r\n            }\r\n            target._lpa =\r\n                vnode.targetAnchor && nextSibling(vnode.targetAnchor);\r\n        }\r\n    }\r\n    return vnode.anchor && nextSibling(vnode.anchor);\r\n}\r\n// Force-casted public typing for h and TSX props inference\r\nconst Teleport = TeleportImpl;\n\nconst COMPONENTS = 'components';\r\nconst DIRECTIVES = 'directives';\r\n/**\r\n * @private\r\n */\r\nfunction resolveComponent(name, maybeSelfReference) {\r\n    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\r\n}\r\nconst NULL_DYNAMIC_COMPONENT = Symbol();\r\n/**\r\n * @private\r\n */\r\nfunction resolveDynamicComponent(component) {\r\n    if (shared.isString(component)) {\r\n        return resolveAsset(COMPONENTS, component, false) || component;\r\n    }\r\n    else {\r\n        // invalid types will fallthrough to createVNode and raise warning\r\n        return (component || NULL_DYNAMIC_COMPONENT);\r\n    }\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction resolveDirective(name) {\r\n    return resolveAsset(DIRECTIVES, name);\r\n}\r\n// implementation\r\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\r\n    const instance = currentRenderingInstance || currentInstance;\r\n    if (instance) {\r\n        const Component = instance.type;\r\n        // explicit self name has highest priority\r\n        if (type === COMPONENTS) {\r\n            const selfName = getComponentName(Component);\r\n            if (selfName &&\r\n                (selfName === name ||\r\n                    selfName === shared.camelize(name) ||\r\n                    selfName === shared.capitalize(shared.camelize(name)))) {\r\n                return Component;\r\n            }\r\n        }\r\n        const res = \r\n        // local registration\r\n        // check instance[type] first for components with mixin or extends.\r\n        resolve(instance[type] || Component[type], name) ||\r\n            // global registration\r\n            resolve(instance.appContext[type], name);\r\n        if (!res && maybeSelfReference) {\r\n            // fallback to implicit self-reference\r\n            return Component;\r\n        }\r\n        return res;\r\n    }\r\n}\r\nfunction resolve(registry, name) {\r\n    return (registry &&\r\n        (registry[name] ||\r\n            registry[shared.camelize(name)] ||\r\n            registry[shared.capitalize(shared.camelize(name))]));\r\n}\n\nconst Fragment = Symbol(undefined);\r\nconst Text = Symbol(undefined);\r\nconst Comment = Symbol(undefined);\r\nconst Static = Symbol(undefined);\r\n// Since v-if and v-for are the two possible ways node structure can dynamically\r\n// change, once we consider v-if branches and each v-for fragment a block, we\r\n// can divide a template into nested blocks, and within each block the node\r\n// structure would be stable. This allows us to skip most children diffing\r\n// and only worry about the dynamic nodes (indicated by patch flags).\r\nconst blockStack = [];\r\nlet currentBlock = null;\r\n/**\r\n * Open a block.\r\n * This must be called before `createBlock`. It cannot be part of `createBlock`\r\n * because the children of the block are evaluated before `createBlock` itself\r\n * is called. The generated code typically looks like this:\r\n *\r\n * ```js\r\n * function render() {\r\n *   return (openBlock(),createBlock('div', null, [...]))\r\n * }\r\n * ```\r\n * disableTracking is true when creating a v-for fragment block, since a v-for\r\n * fragment always diffs its children.\r\n *\r\n * @private\r\n */\r\nfunction openBlock(disableTracking = false) {\r\n    blockStack.push((currentBlock = disableTracking ? null : []));\r\n}\r\nfunction closeBlock() {\r\n    blockStack.pop();\r\n    currentBlock = blockStack[blockStack.length - 1] || null;\r\n}\r\n// Whether we should be tracking dynamic child nodes inside a block.\r\n// Only tracks when this value is > 0\r\n// We are not using a simple boolean because this value may need to be\r\n// incremented/decremented by nested usage of v-once (see below)\r\nlet shouldTrack = 1;\r\n/**\r\n * Block tracking sometimes needs to be disabled, for example during the\r\n * creation of a tree that needs to be cached by v-once. The compiler generates\r\n * code like this:\r\n *\r\n * ``` js\r\n * _cache[1] || (\r\n *   setBlockTracking(-1),\r\n *   _cache[1] = createVNode(...),\r\n *   setBlockTracking(1),\r\n *   _cache[1]\r\n * )\r\n * ```\r\n *\r\n * @private\r\n */\r\nfunction setBlockTracking(value) {\r\n    shouldTrack += value;\r\n}\r\n/**\r\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\r\n * A block root keeps track of dynamic nodes within the block in the\r\n * `dynamicChildren` array.\r\n *\r\n * @private\r\n */\r\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\r\n    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);\r\n    // save current block children on the block vnode\r\n    vnode.dynamicChildren = currentBlock || shared.EMPTY_ARR;\r\n    // close block\r\n    closeBlock();\r\n    // a block is always going to be patched, so track it as a child of its\r\n    // parent block\r\n    if (shouldTrack > 0 && currentBlock) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction isVNode(value) {\r\n    return value ? value.__v_isVNode === true : false;\r\n}\r\nfunction isSameVNodeType(n1, n2) {\r\n    return n1.type === n2.type && n1.key === n2.key;\r\n}\r\n/**\r\n * Internal API for registering an arguments transform for createVNode\r\n * used for creating stubs in the test-utils\r\n * It is *internal* but needs to be exposed for test-utils to pick up proper\r\n * typings\r\n */\r\nfunction transformVNodeArgs(transformer) {\r\n}\r\nconst InternalObjectKey = `__vInternal`;\r\nconst normalizeKey = ({ key }) => key != null ? key : null;\r\nconst normalizeRef = ({ ref }) => {\r\n    return (ref != null\r\n        ? shared.isString(ref) || reactivity.isRef(ref) || shared.isFunction(ref)\r\n            ? { i: currentRenderingInstance, r: ref }\r\n            : ref\r\n        : null);\r\n};\r\nconst createVNode = (_createVNode);\r\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\r\n    if (!type || type === NULL_DYNAMIC_COMPONENT) {\r\n        type = Comment;\r\n    }\r\n    if (isVNode(type)) {\r\n        // createVNode receiving an existing vnode. This happens in cases like\r\n        // <component :is=\"vnode\"/>\r\n        // #2078 make sure to merge refs during the clone instead of overwriting it\r\n        const cloned = cloneVNode(type, props, true /* mergeRef: true */);\r\n        if (children) {\r\n            normalizeChildren(cloned, children);\r\n        }\r\n        return cloned;\r\n    }\r\n    // class component normalization.\r\n    if (isClassComponent(type)) {\r\n        type = type.__vccOpts;\r\n    }\r\n    // class & style normalization.\r\n    if (props) {\r\n        // for reactive or proxy objects, we need to clone it to enable mutation.\r\n        if (reactivity.isProxy(props) || InternalObjectKey in props) {\r\n            props = shared.extend({}, props);\r\n        }\r\n        let { class: klass, style } = props;\r\n        if (klass && !shared.isString(klass)) {\r\n            props.class = shared.normalizeClass(klass);\r\n        }\r\n        if (shared.isObject(style)) {\r\n            // reactive state objects need to be cloned since they are likely to be\r\n            // mutated\r\n            if (reactivity.isProxy(style) && !shared.isArray(style)) {\r\n                style = shared.extend({}, style);\r\n            }\r\n            props.style = shared.normalizeStyle(style);\r\n        }\r\n    }\r\n    // encode the vnode type information into a bitmap\r\n    const shapeFlag = shared.isString(type)\r\n        ? 1 /* ELEMENT */\r\n        : isSuspense(type)\r\n            ? 128 /* SUSPENSE */\r\n            : isTeleport(type)\r\n                ? 64 /* TELEPORT */\r\n                : shared.isObject(type)\r\n                    ? 4 /* STATEFUL_COMPONENT */\r\n                    : shared.isFunction(type)\r\n                        ? 2 /* FUNCTIONAL_COMPONENT */\r\n                        : 0;\r\n    const vnode = {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type,\r\n        props,\r\n        key: props && normalizeKey(props),\r\n        ref: props && normalizeRef(props),\r\n        scopeId: currentScopeId,\r\n        slotScopeIds: null,\r\n        children: null,\r\n        component: null,\r\n        suspense: null,\r\n        ssContent: null,\r\n        ssFallback: null,\r\n        dirs: null,\r\n        transition: null,\r\n        el: null,\r\n        anchor: null,\r\n        target: null,\r\n        targetAnchor: null,\r\n        staticCount: 0,\r\n        shapeFlag,\r\n        patchFlag,\r\n        dynamicProps,\r\n        dynamicChildren: null,\r\n        appContext: null\r\n    };\r\n    normalizeChildren(vnode, children);\r\n    // normalize suspense children\r\n    if (shapeFlag & 128 /* SUSPENSE */) {\r\n        const { content, fallback } = normalizeSuspenseChildren(vnode);\r\n        vnode.ssContent = content;\r\n        vnode.ssFallback = fallback;\r\n    }\r\n    if (shouldTrack > 0 &&\r\n        // avoid a block node from tracking itself\r\n        !isBlockNode &&\r\n        // has current parent block\r\n        currentBlock &&\r\n        // presence of a patch flag indicates this node needs patching on updates.\r\n        // component nodes also should always be patched, because even if the\r\n        // component doesn't need to update, it needs to persist the instance on to\r\n        // the next vnode so that it can be properly unmounted later.\r\n        (patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&\r\n        // the EVENTS flag is only for hydration and if it is the only flag, the\r\n        // vnode should not be considered dynamic due to handler caching.\r\n        patchFlag !== 32 /* HYDRATE_EVENTS */) {\r\n        currentBlock.push(vnode);\r\n    }\r\n    return vnode;\r\n}\r\nfunction cloneVNode(vnode, extraProps, mergeRef = false) {\r\n    // This is intentionally NOT using spread or extend to avoid the runtime\r\n    // key enumeration cost.\r\n    const { props, ref, patchFlag, children } = vnode;\r\n    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\r\n    return {\r\n        __v_isVNode: true,\r\n        [\"__v_skip\" /* SKIP */]: true,\r\n        type: vnode.type,\r\n        props: mergedProps,\r\n        key: mergedProps && normalizeKey(mergedProps),\r\n        ref: extraProps && extraProps.ref\r\n            ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\r\n                // if the vnode itself already has a ref, cloneVNode will need to merge\r\n                // the refs so the single vnode can be set on multiple refs\r\n                mergeRef && ref\r\n                    ? shared.isArray(ref)\r\n                        ? ref.concat(normalizeRef(extraProps))\r\n                        : [ref, normalizeRef(extraProps)]\r\n                    : normalizeRef(extraProps)\r\n            : ref,\r\n        scopeId: vnode.scopeId,\r\n        slotScopeIds: vnode.slotScopeIds,\r\n        children: children,\r\n        target: vnode.target,\r\n        targetAnchor: vnode.targetAnchor,\r\n        staticCount: vnode.staticCount,\r\n        shapeFlag: vnode.shapeFlag,\r\n        // if the vnode is cloned with extra props, we can no longer assume its\r\n        // existing patch flag to be reliable and need to add the FULL_PROPS flag.\r\n        // note: perserve flag for fragments since they use the flag for children\r\n        // fast paths only.\r\n        patchFlag: extraProps && vnode.type !== Fragment\r\n            ? patchFlag === -1 // hoisted node\r\n                ? 16 /* FULL_PROPS */\r\n                : patchFlag | 16 /* FULL_PROPS */\r\n            : patchFlag,\r\n        dynamicProps: vnode.dynamicProps,\r\n        dynamicChildren: vnode.dynamicChildren,\r\n        appContext: vnode.appContext,\r\n        dirs: vnode.dirs,\r\n        transition: vnode.transition,\r\n        // These should technically only be non-null on mounted VNodes. However,\r\n        // they *should* be copied for kept-alive vnodes. So we just always copy\r\n        // them since them being non-null during a mount doesn't affect the logic as\r\n        // they will simply be overwritten.\r\n        component: vnode.component,\r\n        suspense: vnode.suspense,\r\n        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\r\n        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\r\n        el: vnode.el,\r\n        anchor: vnode.anchor\r\n    };\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createTextVNode(text = ' ', flag = 0) {\r\n    return createVNode(Text, null, text, flag);\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createStaticVNode(content, numberOfNodes) {\r\n    // A static vnode can contain multiple stringified elements, and the number\r\n    // of elements is necessary for hydration.\r\n    const vnode = createVNode(Static, null, content);\r\n    vnode.staticCount = numberOfNodes;\r\n    return vnode;\r\n}\r\n/**\r\n * @private\r\n */\r\nfunction createCommentVNode(text = '', \r\n// when used as the v-else branch, the comment node must be created as a\r\n// block to ensure correct updates.\r\nasBlock = false) {\r\n    return asBlock\r\n        ? (openBlock(), createBlock(Comment, null, text))\r\n        : createVNode(Comment, null, text);\r\n}\r\nfunction normalizeVNode(child) {\r\n    if (child == null || typeof child === 'boolean') {\r\n        // empty placeholder\r\n        return createVNode(Comment);\r\n    }\r\n    else if (shared.isArray(child)) {\r\n        // fragment\r\n        return createVNode(Fragment, null, child);\r\n    }\r\n    else if (typeof child === 'object') {\r\n        // already vnode, this should be the most common since compiled templates\r\n        // always produce all-vnode children arrays\r\n        return child.el === null ? child : cloneVNode(child);\r\n    }\r\n    else {\r\n        // strings and numbers\r\n        return createVNode(Text, null, String(child));\r\n    }\r\n}\r\n// optimized normalization for template-compiled render fns\r\nfunction cloneIfMounted(child) {\r\n    return child.el === null ? child : cloneVNode(child);\r\n}\r\nfunction normalizeChildren(vnode, children) {\r\n    let type = 0;\r\n    const { shapeFlag } = vnode;\r\n    if (children == null) {\r\n        children = null;\r\n    }\r\n    else if (shared.isArray(children)) {\r\n        type = 16 /* ARRAY_CHILDREN */;\r\n    }\r\n    else if (typeof children === 'object') {\r\n        if (shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) {\r\n            // Normalize slot to plain children for plain element and Teleport\r\n            const slot = children.default;\r\n            if (slot) {\r\n                // _c marker is added by withCtx() indicating this is a compiled slot\r\n                slot._c && setCompiledSlotRendering(1);\r\n                normalizeChildren(vnode, slot());\r\n                slot._c && setCompiledSlotRendering(-1);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            type = 32 /* SLOTS_CHILDREN */;\r\n            const slotFlag = children._;\r\n            if (!slotFlag && !(InternalObjectKey in children)) {\r\n                children._ctx = currentRenderingInstance;\r\n            }\r\n            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {\r\n                // a child component receives forwarded slots from the parent.\r\n                // its slot type is determined by its parent's slot type.\r\n                if (currentRenderingInstance.vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) {\r\n                    children._ = 2 /* DYNAMIC */;\r\n                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n                else {\r\n                    children._ = 1 /* STABLE */;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (shared.isFunction(children)) {\r\n        children = { default: children, _ctx: currentRenderingInstance };\r\n        type = 32 /* SLOTS_CHILDREN */;\r\n    }\r\n    else {\r\n        children = String(children);\r\n        // force teleport children to array so it can be moved around\r\n        if (shapeFlag & 64 /* TELEPORT */) {\r\n            type = 16 /* ARRAY_CHILDREN */;\r\n            children = [createTextVNode(children)];\r\n        }\r\n        else {\r\n            type = 8 /* TEXT_CHILDREN */;\r\n        }\r\n    }\r\n    vnode.children = children;\r\n    vnode.shapeFlag |= type;\r\n}\r\nfunction mergeProps(...args) {\r\n    const ret = shared.extend({}, args[0]);\r\n    for (let i = 1; i < args.length; i++) {\r\n        const toMerge = args[i];\r\n        for (const key in toMerge) {\r\n            if (key === 'class') {\r\n                if (ret.class !== toMerge.class) {\r\n                    ret.class = shared.normalizeClass([ret.class, toMerge.class]);\r\n                }\r\n            }\r\n            else if (key === 'style') {\r\n                ret.style = shared.normalizeStyle([ret.style, toMerge.style]);\r\n            }\r\n            else if (shared.isOn(key)) {\r\n                const existing = ret[key];\r\n                const incoming = toMerge[key];\r\n                if (existing !== incoming) {\r\n                    ret[key] = existing\r\n                        ? [].concat(existing, toMerge[key])\r\n                        : incoming;\r\n                }\r\n            }\r\n            else if (key !== '') {\r\n                ret[key] = toMerge[key];\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) ;\r\n    else {\r\n        let provides = currentInstance.provides;\r\n        // by default an instance inherits its parent's provides object\r\n        // but when it needs to provide values of its own, it creates its\r\n        // own provides object using parent provides object as prototype.\r\n        // this way in `inject` we can simply look up injections from direct\r\n        // parent and let the prototype chain do the work.\r\n        const parentProvides = currentInstance.parent && currentInstance.parent.provides;\r\n        if (parentProvides === provides) {\r\n            provides = currentInstance.provides = Object.create(parentProvides);\r\n        }\r\n        // TS doesn't allow symbol as index type\r\n        provides[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    const instance = currentInstance || currentRenderingInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the intance is at root\r\n        const provides = instance.parent == null\r\n            ? instance.vnode.appContext && instance.vnode.appContext.provides\r\n            : instance.parent.provides;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && shared.isFunction(defaultValue)\r\n                ? defaultValue()\r\n                : defaultValue;\r\n        }\r\n        else ;\r\n    }\r\n}\n\nlet shouldCacheAccess = true;\r\nfunction applyOptions(instance, options, deferredData = [], deferredWatch = [], deferredProvide = [], asMixin = false) {\r\n    const { \r\n    // composition\r\n    mixins, extends: extendsOptions, \r\n    // state\r\n    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, \r\n    // assets\r\n    components, directives, \r\n    // lifecycle\r\n    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, \r\n    // public API\r\n    expose } = options;\r\n    const publicThis = instance.proxy;\r\n    const ctx = instance.ctx;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (asMixin && render && instance.render === shared.NOOP) {\r\n        instance.render = render;\r\n    }\r\n    // applyOptions is called non-as-mixin once per instance\r\n    if (!asMixin) {\r\n        shouldCacheAccess = false;\r\n        callSyncHook('beforeCreate', \"bc\" /* BEFORE_CREATE */, options, instance, globalMixins);\r\n        shouldCacheAccess = true;\r\n        // global mixins are applied first\r\n        applyMixins(instance, globalMixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    // extending a base component...\r\n    if (extendsOptions) {\r\n        applyOptions(instance, extendsOptions, deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n    // local mixins\r\n    if (mixins) {\r\n        applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide);\r\n    }\r\n    // options initialization order (to be consistent with Vue 2):\r\n    // - props (already done outside of this function)\r\n    // - inject\r\n    // - methods\r\n    // - data (deferred since it relies on `this` access)\r\n    // - computed\r\n    // - watch (deferred since it relies on `this` access)\r\n    if (injectOptions) {\r\n        if (shared.isArray(injectOptions)) {\r\n            for (let i = 0; i < injectOptions.length; i++) {\r\n                const key = injectOptions[i];\r\n                ctx[key] = inject(key);\r\n            }\r\n        }\r\n        else {\r\n            for (const key in injectOptions) {\r\n                const opt = injectOptions[key];\r\n                if (shared.isObject(opt)) {\r\n                    ctx[key] = inject(opt.from || key, opt.default, true /* treat default function as factory */);\r\n                }\r\n                else {\r\n                    ctx[key] = inject(opt);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (methods) {\r\n        for (const key in methods) {\r\n            const methodHandler = methods[key];\r\n            if (shared.isFunction(methodHandler)) {\r\n                // In dev mode, we use the `createRenderContext` function to define methods to the proxy target,\r\n                // and those are read-only but reconfigurable, so it needs to be redefined here\r\n                {\r\n                    ctx[key] = methodHandler.bind(publicThis);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!asMixin) {\r\n        if (deferredData.length) {\r\n            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));\r\n        }\r\n        if (dataOptions) {\r\n            // @ts-ignore dataOptions is not fully type safe\r\n            resolveData(instance, dataOptions, publicThis);\r\n        }\r\n    }\r\n    else if (dataOptions) {\r\n        deferredData.push(dataOptions);\r\n    }\r\n    if (computedOptions) {\r\n        for (const key in computedOptions) {\r\n            const opt = computedOptions[key];\r\n            const get = shared.isFunction(opt)\r\n                ? opt.bind(publicThis, publicThis)\r\n                : shared.isFunction(opt.get)\r\n                    ? opt.get.bind(publicThis, publicThis)\r\n                    : shared.NOOP;\r\n            const set = !shared.isFunction(opt) && shared.isFunction(opt.set)\r\n                ? opt.set.bind(publicThis)\r\n                : shared.NOOP;\r\n            const c = computed({\r\n                get,\r\n                set\r\n            });\r\n            Object.defineProperty(ctx, key, {\r\n                enumerable: true,\r\n                configurable: true,\r\n                get: () => c.value,\r\n                set: v => (c.value = v)\r\n            });\r\n        }\r\n    }\r\n    if (watchOptions) {\r\n        deferredWatch.push(watchOptions);\r\n    }\r\n    if (!asMixin && deferredWatch.length) {\r\n        deferredWatch.forEach(watchOptions => {\r\n            for (const key in watchOptions) {\r\n                createWatcher(watchOptions[key], ctx, publicThis, key);\r\n            }\r\n        });\r\n    }\r\n    if (provideOptions) {\r\n        deferredProvide.push(provideOptions);\r\n    }\r\n    if (!asMixin && deferredProvide.length) {\r\n        deferredProvide.forEach(provideOptions => {\r\n            const provides = shared.isFunction(provideOptions)\r\n                ? provideOptions.call(publicThis)\r\n                : provideOptions;\r\n            Reflect.ownKeys(provides).forEach(key => {\r\n                provide(key, provides[key]);\r\n            });\r\n        });\r\n    }\r\n    // asset options.\r\n    // To reduce memory usage, only components with mixins or extends will have\r\n    // resolved asset registry attached to instance.\r\n    if (asMixin) {\r\n        if (components) {\r\n            shared.extend(instance.components ||\r\n                (instance.components = shared.extend({}, instance.type.components)), components);\r\n        }\r\n        if (directives) {\r\n            shared.extend(instance.directives ||\r\n                (instance.directives = shared.extend({}, instance.type.directives)), directives);\r\n        }\r\n    }\r\n    // lifecycle options\r\n    if (!asMixin) {\r\n        callSyncHook('created', \"c\" /* CREATED */, options, instance, globalMixins);\r\n    }\r\n    if (beforeMount) {\r\n        onBeforeMount(beforeMount.bind(publicThis));\r\n    }\r\n    if (mounted) {\r\n        onMounted(mounted.bind(publicThis));\r\n    }\r\n    if (beforeUpdate) {\r\n        onBeforeUpdate(beforeUpdate.bind(publicThis));\r\n    }\r\n    if (updated) {\r\n        onUpdated(updated.bind(publicThis));\r\n    }\r\n    if (activated) {\r\n        onActivated(activated.bind(publicThis));\r\n    }\r\n    if (deactivated) {\r\n        onDeactivated(deactivated.bind(publicThis));\r\n    }\r\n    if (errorCaptured) {\r\n        onErrorCaptured(errorCaptured.bind(publicThis));\r\n    }\r\n    if (renderTracked) {\r\n        onRenderTracked(renderTracked.bind(publicThis));\r\n    }\r\n    if (renderTriggered) {\r\n        onRenderTriggered(renderTriggered.bind(publicThis));\r\n    }\r\n    if (beforeUnmount) {\r\n        onBeforeUnmount(beforeUnmount.bind(publicThis));\r\n    }\r\n    if (unmounted) {\r\n        onUnmounted(unmounted.bind(publicThis));\r\n    }\r\n    if (shared.isArray(expose)) {\r\n        if (!asMixin) {\r\n            if (expose.length) {\r\n                const exposed = instance.exposed || (instance.exposed = reactivity.proxyRefs({}));\r\n                expose.forEach(key => {\r\n                    exposed[key] = reactivity.toRef(publicThis, key);\r\n                });\r\n            }\r\n            else if (!instance.exposed) {\r\n                instance.exposed = shared.EMPTY_OBJ;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction callSyncHook(name, type, options, instance, globalMixins) {\r\n    for (let i = 0; i < globalMixins.length; i++) {\r\n        callHookWithMixinAndExtends(name, type, globalMixins[i], instance);\r\n    }\r\n    callHookWithMixinAndExtends(name, type, options, instance);\r\n}\r\nfunction callHookWithMixinAndExtends(name, type, options, instance) {\r\n    const { extends: base, mixins } = options;\r\n    const selfHook = options[name];\r\n    if (base) {\r\n        callHookWithMixinAndExtends(name, type, base, instance);\r\n    }\r\n    if (mixins) {\r\n        for (let i = 0; i < mixins.length; i++) {\r\n            callHookWithMixinAndExtends(name, type, mixins[i], instance);\r\n        }\r\n    }\r\n    if (selfHook) {\r\n        callWithAsyncErrorHandling(selfHook.bind(instance.proxy), instance, type);\r\n    }\r\n}\r\nfunction applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide) {\r\n    for (let i = 0; i < mixins.length; i++) {\r\n        applyOptions(instance, mixins[i], deferredData, deferredWatch, deferredProvide, true);\r\n    }\r\n}\r\nfunction resolveData(instance, dataFn, publicThis) {\r\n    shouldCacheAccess = false;\r\n    const data = dataFn.call(publicThis, publicThis);\r\n    shouldCacheAccess = true;\r\n    if (!shared.isObject(data)) ;\r\n    else if (instance.data === shared.EMPTY_OBJ) {\r\n        instance.data = reactivity.reactive(data);\r\n    }\r\n    else {\r\n        // existing data: this is a mixin or extends.\r\n        shared.extend(instance.data, data);\r\n    }\r\n}\r\nfunction createWatcher(raw, ctx, publicThis, key) {\r\n    const getter = key.includes('.')\r\n        ? createPathGetter(publicThis, key)\r\n        : () => publicThis[key];\r\n    if (shared.isString(raw)) {\r\n        const handler = ctx[raw];\r\n        if (shared.isFunction(handler)) {\r\n            watch(getter, handler);\r\n        }\r\n    }\r\n    else if (shared.isFunction(raw)) {\r\n        watch(getter, raw.bind(publicThis));\r\n    }\r\n    else if (shared.isObject(raw)) {\r\n        if (shared.isArray(raw)) {\r\n            raw.forEach(r => createWatcher(r, ctx, publicThis, key));\r\n        }\r\n        else {\r\n            const handler = shared.isFunction(raw.handler)\r\n                ? raw.handler.bind(publicThis)\r\n                : ctx[raw.handler];\r\n            if (shared.isFunction(handler)) {\r\n                watch(getter, handler, raw);\r\n            }\r\n        }\r\n    }\r\n    else ;\r\n}\r\nfunction createPathGetter(ctx, path) {\r\n    const segments = path.split('.');\r\n    return () => {\r\n        let cur = ctx;\r\n        for (let i = 0; i < segments.length && cur; i++) {\r\n            cur = cur[segments[i]];\r\n        }\r\n        return cur;\r\n    };\r\n}\r\nfunction resolveMergedOptions(instance) {\r\n    const raw = instance.type;\r\n    const { __merged, mixins, extends: extendsOptions } = raw;\r\n    if (__merged)\r\n        return __merged;\r\n    const globalMixins = instance.appContext.mixins;\r\n    if (!globalMixins.length && !mixins && !extendsOptions)\r\n        return raw;\r\n    const options = {};\r\n    globalMixins.forEach(m => mergeOptions(options, m, instance));\r\n    mergeOptions(options, raw, instance);\r\n    return (raw.__merged = options);\r\n}\r\nfunction mergeOptions(to, from, instance) {\r\n    const strats = instance.appContext.config.optionMergeStrategies;\r\n    const { mixins, extends: extendsOptions } = from;\r\n    extendsOptions && mergeOptions(to, extendsOptions, instance);\r\n    mixins &&\r\n        mixins.forEach((m) => mergeOptions(to, m, instance));\r\n    for (const key in from) {\r\n        if (strats && shared.hasOwn(strats, key)) {\r\n            to[key] = strats[key](to[key], from[key], instance.proxy, key);\r\n        }\r\n        else {\r\n            to[key] = from[key];\r\n        }\r\n    }\r\n}\n\n/**\r\n * #2437 In Vue 3, functional components do not have a public instance proxy but\r\n * they exist in the internal parent chain. For code that relies on traversing\r\n * public $parent chains, skip functional ones and go to the parent instead.\r\n */\r\nconst getPublicInstance = (i) => {\r\n    if (!i)\r\n        return null;\r\n    if (isStatefulComponent(i))\r\n        return i.exposed ? i.exposed : i.proxy;\r\n    return getPublicInstance(i.parent);\r\n};\r\nconst publicPropertiesMap = shared.extend(Object.create(null), {\r\n    $: i => i,\r\n    $el: i => i.vnode.el,\r\n    $data: i => i.data,\r\n    $props: i => (i.props),\r\n    $attrs: i => (i.attrs),\r\n    $slots: i => (i.slots),\r\n    $refs: i => (i.refs),\r\n    $parent: i => getPublicInstance(i.parent),\r\n    $root: i => getPublicInstance(i.root),\r\n    $emit: i => i.emit,\r\n    $options: i => (resolveMergedOptions(i) ),\r\n    $forceUpdate: i => () => queueJob(i.update),\r\n    $nextTick: i => nextTick.bind(i.proxy),\r\n    $watch: i => (instanceWatch.bind(i) )\r\n});\r\nconst PublicInstanceProxyHandlers = {\r\n    get({ _: instance }, key) {\r\n        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\r\n        // let @vue/reactivity know it should never observe Vue public instances.\r\n        if (key === \"__v_skip\" /* SKIP */) {\r\n            return true;\r\n        }\r\n        // data / props / ctx\r\n        // This getter gets called for every property access on the render context\r\n        // during render and is a major hotspot. The most expensive part of this\r\n        // is the multiple hasOwn() calls. It's much faster to do a simple property\r\n        // access on a plain object, so we use an accessCache object (with null\r\n        // prototype) to memoize what access type a key corresponds to.\r\n        let normalizedProps;\r\n        if (key[0] !== '$') {\r\n            const n = accessCache[key];\r\n            if (n !== undefined) {\r\n                switch (n) {\r\n                    case 0 /* SETUP */:\r\n                        return setupState[key];\r\n                    case 1 /* DATA */:\r\n                        return data[key];\r\n                    case 3 /* CONTEXT */:\r\n                        return ctx[key];\r\n                    case 2 /* PROPS */:\r\n                        return props[key];\r\n                    // default: just fallthrough\r\n                }\r\n            }\r\n            else if (setupState !== shared.EMPTY_OBJ && shared.hasOwn(setupState, key)) {\r\n                accessCache[key] = 0 /* SETUP */;\r\n                return setupState[key];\r\n            }\r\n            else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {\r\n                accessCache[key] = 1 /* DATA */;\r\n                return data[key];\r\n            }\r\n            else if (\r\n            // only cache other properties when instance has declared (thus stable)\r\n            // props\r\n            (normalizedProps = instance.propsOptions[0]) &&\r\n                shared.hasOwn(normalizedProps, key)) {\r\n                accessCache[key] = 2 /* PROPS */;\r\n                return props[key];\r\n            }\r\n            else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {\r\n                accessCache[key] = 3 /* CONTEXT */;\r\n                return ctx[key];\r\n            }\r\n            else if (shouldCacheAccess) {\r\n                accessCache[key] = 4 /* OTHER */;\r\n            }\r\n        }\r\n        const publicGetter = publicPropertiesMap[key];\r\n        let cssModule, globalProperties;\r\n        // public $xxx properties\r\n        if (publicGetter) {\r\n            if (key === '$attrs') {\r\n                reactivity.track(instance, \"get\" /* GET */, key);\r\n            }\r\n            return publicGetter(instance);\r\n        }\r\n        else if (\r\n        // css module (injected by vue-loader)\r\n        (cssModule = type.__cssModules) &&\r\n            (cssModule = cssModule[key])) {\r\n            return cssModule;\r\n        }\r\n        else if (ctx !== shared.EMPTY_OBJ && shared.hasOwn(ctx, key)) {\r\n            // user may set custom properties to `this` that start with `$`\r\n            accessCache[key] = 3 /* CONTEXT */;\r\n            return ctx[key];\r\n        }\r\n        else if (\r\n        // global properties\r\n        ((globalProperties = appContext.config.globalProperties),\r\n            shared.hasOwn(globalProperties, key))) {\r\n            return globalProperties[key];\r\n        }\r\n        else ;\r\n    },\r\n    set({ _: instance }, key, value) {\r\n        const { data, setupState, ctx } = instance;\r\n        if (setupState !== shared.EMPTY_OBJ && shared.hasOwn(setupState, key)) {\r\n            setupState[key] = value;\r\n        }\r\n        else if (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) {\r\n            data[key] = value;\r\n        }\r\n        else if (shared.hasOwn(instance.props, key)) {\r\n            return false;\r\n        }\r\n        if (key[0] === '$' && key.slice(1) in instance) {\r\n            return false;\r\n        }\r\n        else {\r\n            {\r\n                ctx[key] = value;\r\n            }\r\n        }\r\n        return true;\r\n    },\r\n    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {\r\n        let normalizedProps;\r\n        return (accessCache[key] !== undefined ||\r\n            (data !== shared.EMPTY_OBJ && shared.hasOwn(data, key)) ||\r\n            (setupState !== shared.EMPTY_OBJ && shared.hasOwn(setupState, key)) ||\r\n            ((normalizedProps = propsOptions[0]) && shared.hasOwn(normalizedProps, key)) ||\r\n            shared.hasOwn(ctx, key) ||\r\n            shared.hasOwn(publicPropertiesMap, key) ||\r\n            shared.hasOwn(appContext.config.globalProperties, key));\r\n    }\r\n};\r\nconst RuntimeCompiledPublicInstanceProxyHandlers = shared.extend({}, PublicInstanceProxyHandlers, {\r\n    get(target, key) {\r\n        // fast path for unscopables when using `with` block\r\n        if (key === Symbol.unscopables) {\r\n            return;\r\n        }\r\n        return PublicInstanceProxyHandlers.get(target, key, target);\r\n    },\r\n    has(_, key) {\r\n        const has = key[0] !== '_' && !shared.isGloballyWhitelisted(key);\r\n        return has;\r\n    }\r\n});\n\nconst emptyAppContext = createAppContext();\r\nlet uid$1 = 0;\r\nfunction createComponentInstance(vnode, parent, suspense) {\r\n    const type = vnode.type;\r\n    // inherit parent app context - or - if root, adopt from root vnode\r\n    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\r\n    const instance = {\r\n        uid: uid$1++,\r\n        vnode,\r\n        type,\r\n        parent,\r\n        appContext,\r\n        root: null,\r\n        next: null,\r\n        subTree: null,\r\n        update: null,\r\n        render: null,\r\n        proxy: null,\r\n        exposed: null,\r\n        withProxy: null,\r\n        effects: null,\r\n        provides: parent ? parent.provides : Object.create(appContext.provides),\r\n        accessCache: null,\r\n        renderCache: [],\r\n        // local resovled assets\r\n        components: null,\r\n        directives: null,\r\n        // resolved props and emits options\r\n        propsOptions: normalizePropsOptions(type, appContext),\r\n        emitsOptions: normalizeEmitsOptions(type, appContext),\r\n        // emit\r\n        emit: null,\r\n        emitted: null,\r\n        // props default value\r\n        propsDefaults: shared.EMPTY_OBJ,\r\n        // state\r\n        ctx: shared.EMPTY_OBJ,\r\n        data: shared.EMPTY_OBJ,\r\n        props: shared.EMPTY_OBJ,\r\n        attrs: shared.EMPTY_OBJ,\r\n        slots: shared.EMPTY_OBJ,\r\n        refs: shared.EMPTY_OBJ,\r\n        setupState: shared.EMPTY_OBJ,\r\n        setupContext: null,\r\n        // suspense related\r\n        suspense,\r\n        suspenseId: suspense ? suspense.pendingId : 0,\r\n        asyncDep: null,\r\n        asyncResolved: false,\r\n        // lifecycle hooks\r\n        // not using enums here because it results in computed properties\r\n        isMounted: false,\r\n        isUnmounted: false,\r\n        isDeactivated: false,\r\n        bc: null,\r\n        c: null,\r\n        bm: null,\r\n        m: null,\r\n        bu: null,\r\n        u: null,\r\n        um: null,\r\n        bum: null,\r\n        da: null,\r\n        a: null,\r\n        rtg: null,\r\n        rtc: null,\r\n        ec: null\r\n    };\r\n    {\r\n        instance.ctx = { _: instance };\r\n    }\r\n    instance.root = parent ? parent.root : instance;\r\n    instance.emit = emit.bind(null, instance);\r\n    return instance;\r\n}\r\nlet currentInstance = null;\r\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\r\nconst setCurrentInstance = (instance) => {\r\n    currentInstance = instance;\r\n};\r\nfunction isStatefulComponent(instance) {\r\n    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;\r\n}\r\nlet isInSSRComponentSetup = false;\r\nfunction setupComponent(instance, isSSR = false) {\r\n    isInSSRComponentSetup = isSSR;\r\n    const { props, children } = instance.vnode;\r\n    const isStateful = isStatefulComponent(instance);\r\n    initProps(instance, props, isStateful, isSSR);\r\n    initSlots(instance, children);\r\n    const setupResult = isStateful\r\n        ? setupStatefulComponent(instance, isSSR)\r\n        : undefined;\r\n    isInSSRComponentSetup = false;\r\n    return setupResult;\r\n}\r\nfunction setupStatefulComponent(instance, isSSR) {\r\n    const Component = instance.type;\r\n    // 0. create render proxy property access cache\r\n    instance.accessCache = Object.create(null);\r\n    // 1. create public instance / render proxy\r\n    // also mark it raw so it's never observed\r\n    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\r\n    // 2. call setup()\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        const setupContext = (instance.setupContext =\r\n            setup.length > 1 ? createSetupContext(instance) : null);\r\n        currentInstance = instance;\r\n        reactivity.pauseTracking();\r\n        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [instance.props, setupContext]);\r\n        reactivity.resetTracking();\r\n        currentInstance = null;\r\n        if (shared.isPromise(setupResult)) {\r\n            if (isSSR) {\r\n                // return the promise so server-renderer can wait on it\r\n                return setupResult\r\n                    .then((resolvedResult) => {\r\n                    handleSetupResult(instance, resolvedResult, isSSR);\r\n                })\r\n                    .catch(e => {\r\n                    handleError(e, instance, 0 /* SETUP_FUNCTION */);\r\n                });\r\n            }\r\n            else {\r\n                // async setup returned Promise.\r\n                // bail here and wait for re-entry.\r\n                instance.asyncDep = setupResult;\r\n            }\r\n        }\r\n        else {\r\n            handleSetupResult(instance, setupResult, isSSR);\r\n        }\r\n    }\r\n    else {\r\n        finishComponentSetup(instance, isSSR);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult, isSSR) {\r\n    if (shared.isFunction(setupResult)) {\r\n        // setup returned an inline render function\r\n        if (instance.type.__ssrInlineRender) {\r\n            // when the function's name is `ssrRender` (compiled by SFC inline mode),\r\n            // set it as ssrRender instead.\r\n            instance.ssrRender = setupResult;\r\n        }\r\n        else {\r\n            instance.render = setupResult;\r\n        }\r\n    }\r\n    else if (shared.isObject(setupResult)) {\r\n        instance.setupState = reactivity.proxyRefs(setupResult);\r\n    }\r\n    else ;\r\n    finishComponentSetup(instance, isSSR);\r\n}\r\nlet compile;\r\n// dev only\r\nconst isRuntimeOnly = () => !compile;\r\n/**\r\n * For runtime-dom to register the compiler.\r\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\r\n */\r\nfunction registerRuntimeCompiler(_compile) {\r\n    compile = _compile;\r\n}\r\nfunction finishComponentSetup(instance, isSSR) {\r\n    const Component = instance.type;\r\n    // template / render function normalization\r\n    if (isSSR) {\r\n        // 1. the render function may already exist, returned by `setup`\r\n        // 2. otherwise try to use the `Component.render`\r\n        // 3. if the component doesn't have a render function,\r\n        //    set `instance.render` to NOOP so that it can inherit the render\r\n        //    function from mixins/extend\r\n        instance.render = (instance.render ||\r\n            Component.render ||\r\n            shared.NOOP);\r\n    }\r\n    else if (!instance.render) {\r\n        // could be set from setup()\r\n        if (compile && Component.template && !Component.render) {\r\n            Component.render = compile(Component.template, {\r\n                isCustomElement: instance.appContext.config.isCustomElement,\r\n                delimiters: Component.delimiters\r\n            });\r\n        }\r\n        instance.render = (Component.render || shared.NOOP);\r\n        // for runtime-compiled render functions using `with` blocks, the render\r\n        // proxy used needs a different `has` handler which is more performant and\r\n        // also only allows a whitelist of globals to fallthrough.\r\n        if (instance.render._rc) {\r\n            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\r\n        }\r\n    }\r\n    // support for 2.x options\r\n    {\r\n        currentInstance = instance;\r\n        reactivity.pauseTracking();\r\n        applyOptions(instance, Component);\r\n        reactivity.resetTracking();\r\n        currentInstance = null;\r\n    }\r\n}\r\nfunction createSetupContext(instance) {\r\n    const expose = exposed => {\r\n        instance.exposed = reactivity.proxyRefs(exposed);\r\n    };\r\n    {\r\n        return {\r\n            attrs: instance.attrs,\r\n            slots: instance.slots,\r\n            emit: instance.emit,\r\n            expose\r\n        };\r\n    }\r\n}\r\n// record effects created during a component's setup() so that they can be\r\n// stopped when the component unmounts\r\nfunction recordInstanceBoundEffect(effect, instance = currentInstance) {\r\n    if (instance) {\r\n        (instance.effects || (instance.effects = [])).push(effect);\r\n    }\r\n}\r\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\nfunction getComponentName(Component) {\r\n    return shared.isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\r\nfunction isClassComponent(value) {\r\n    return shared.isFunction(value) && '__vccOpts' in value;\r\n}\n\nfunction computed(getterOrOptions) {\r\n    const c = reactivity.computed(getterOrOptions);\r\n    recordInstanceBoundEffect(c.effect);\r\n    return c;\r\n}\n\n// implementation\r\nfunction defineProps() {\r\n    return null;\r\n}\r\n// implementation\r\nfunction defineEmit() {\r\n    return null;\r\n}\r\nfunction useContext() {\r\n    const i = getCurrentInstance();\r\n    return i.setupContext || (i.setupContext = createSetupContext(i));\r\n}\n\n// Actual implementation\r\nfunction h(type, propsOrChildren, children) {\r\n    const l = arguments.length;\r\n    if (l === 2) {\r\n        if (shared.isObject(propsOrChildren) && !shared.isArray(propsOrChildren)) {\r\n            // single vnode without props\r\n            if (isVNode(propsOrChildren)) {\r\n                return createVNode(type, null, [propsOrChildren]);\r\n            }\r\n            // props without children\r\n            return createVNode(type, propsOrChildren);\r\n        }\r\n        else {\r\n            // omit props\r\n            return createVNode(type, null, propsOrChildren);\r\n        }\r\n    }\r\n    else {\r\n        if (l > 3) {\r\n            children = Array.prototype.slice.call(arguments, 2);\r\n        }\r\n        else if (l === 3 && isVNode(children)) {\r\n            children = [children];\r\n        }\r\n        return createVNode(type, propsOrChildren, children);\r\n    }\r\n}\n\nconst ssrContextKey = Symbol(``);\r\nconst useSSRContext = () => {\r\n    {\r\n        const ctx = inject(ssrContextKey);\r\n        if (!ctx) {\r\n            warn(`Server rendering context not provided. Make sure to only call ` +\r\n                `useSSRContext() conditionally in the server build.`);\r\n        }\r\n        return ctx;\r\n    }\r\n};\n\nfunction initCustomFormatter() {\r\n    /* eslint-disable no-restricted-globals */\r\n    {\r\n        return;\r\n    }\r\n}\n\n/**\r\n * Actual implementation\r\n */\r\nfunction renderList(source, renderItem) {\r\n    let ret;\r\n    if (shared.isArray(source) || shared.isString(source)) {\r\n        ret = new Array(source.length);\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            ret[i] = renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        ret = new Array(source);\r\n        for (let i = 0; i < source; i++) {\r\n            ret[i] = renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (shared.isObject(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            ret = Array.from(source, renderItem);\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            ret = new Array(keys.length);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                ret[i] = renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * For prefixing keys in v-on=\"obj\" with \"on\"\r\n * @private\r\n */\r\nfunction toHandlers(obj) {\r\n    const ret = {};\r\n    for (const key in obj) {\r\n        ret[shared.toHandlerKey(key)] = obj[key];\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Compiler runtime helper for creating dynamic slots object\r\n * @private\r\n */\r\nfunction createSlots(slots, dynamicSlots) {\r\n    for (let i = 0; i < dynamicSlots.length; i++) {\r\n        const slot = dynamicSlots[i];\r\n        // array of dynamic slot generated by <template v-for=\"...\" #[...]>\r\n        if (shared.isArray(slot)) {\r\n            for (let j = 0; j < slot.length; j++) {\r\n                slots[slot[j].name] = slot[j].fn;\r\n            }\r\n        }\r\n        else if (slot) {\r\n            // conditional single slot generated by <template v-if=\"...\" #foo>\r\n            slots[slot.name] = slot.fn;\r\n        }\r\n    }\r\n    return slots;\r\n}\n\n// Core API ------------------------------------------------------------------\r\nconst version = \"3.0.11\";\r\nconst _ssrUtils = {\r\n    createComponentInstance,\r\n    setupComponent,\r\n    renderComponentRoot,\r\n    setCurrentRenderingInstance,\r\n    isVNode,\r\n    normalizeVNode\r\n};\r\n/**\r\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\r\n * @internal\r\n */\r\nconst ssrUtils = (_ssrUtils );\n\nexports.customRef = reactivity.customRef;\nexports.isProxy = reactivity.isProxy;\nexports.isReactive = reactivity.isReactive;\nexports.isReadonly = reactivity.isReadonly;\nexports.isRef = reactivity.isRef;\nexports.markRaw = reactivity.markRaw;\nexports.proxyRefs = reactivity.proxyRefs;\nexports.reactive = reactivity.reactive;\nexports.readonly = reactivity.readonly;\nexports.ref = reactivity.ref;\nexports.shallowReactive = reactivity.shallowReactive;\nexports.shallowReadonly = reactivity.shallowReadonly;\nexports.shallowRef = reactivity.shallowRef;\nexports.toRaw = reactivity.toRaw;\nexports.toRef = reactivity.toRef;\nexports.toRefs = reactivity.toRefs;\nexports.triggerRef = reactivity.triggerRef;\nexports.unref = reactivity.unref;\nexports.camelize = shared.camelize;\nexports.capitalize = shared.capitalize;\nexports.toDisplayString = shared.toDisplayString;\nexports.toHandlerKey = shared.toHandlerKey;\nexports.BaseTransition = BaseTransition;\nexports.Comment = Comment;\nexports.Fragment = Fragment;\nexports.KeepAlive = KeepAlive;\nexports.Static = Static;\nexports.Suspense = Suspense;\nexports.Teleport = Teleport;\nexports.Text = Text;\nexports.callWithAsyncErrorHandling = callWithAsyncErrorHandling;\nexports.callWithErrorHandling = callWithErrorHandling;\nexports.cloneVNode = cloneVNode;\nexports.computed = computed;\nexports.createBlock = createBlock;\nexports.createCommentVNode = createCommentVNode;\nexports.createHydrationRenderer = createHydrationRenderer;\nexports.createRenderer = createRenderer;\nexports.createSlots = createSlots;\nexports.createStaticVNode = createStaticVNode;\nexports.createTextVNode = createTextVNode;\nexports.createVNode = createVNode;\nexports.defineAsyncComponent = defineAsyncComponent;\nexports.defineComponent = defineComponent;\nexports.defineEmit = defineEmit;\nexports.defineProps = defineProps;\nexports.getCurrentInstance = getCurrentInstance;\nexports.getTransitionRawChildren = getTransitionRawChildren;\nexports.h = h;\nexports.handleError = handleError;\nexports.initCustomFormatter = initCustomFormatter;\nexports.inject = inject;\nexports.isRuntimeOnly = isRuntimeOnly;\nexports.isVNode = isVNode;\nexports.mergeProps = mergeProps;\nexports.nextTick = nextTick;\nexports.onActivated = onActivated;\nexports.onBeforeMount = onBeforeMount;\nexports.onBeforeUnmount = onBeforeUnmount;\nexports.onBeforeUpdate = onBeforeUpdate;\nexports.onDeactivated = onDeactivated;\nexports.onErrorCaptured = onErrorCaptured;\nexports.onMounted = onMounted;\nexports.onRenderTracked = onRenderTracked;\nexports.onRenderTriggered = onRenderTriggered;\nexports.onUnmounted = onUnmounted;\nexports.onUpdated = onUpdated;\nexports.openBlock = openBlock;\nexports.popScopeId = popScopeId;\nexports.provide = provide;\nexports.pushScopeId = pushScopeId;\nexports.queuePostFlushCb = queuePostFlushCb;\nexports.registerRuntimeCompiler = registerRuntimeCompiler;\nexports.renderList = renderList;\nexports.renderSlot = renderSlot;\nexports.resolveComponent = resolveComponent;\nexports.resolveDirective = resolveDirective;\nexports.resolveDynamicComponent = resolveDynamicComponent;\nexports.resolveTransitionHooks = resolveTransitionHooks;\nexports.setBlockTracking = setBlockTracking;\nexports.setDevtoolsHook = setDevtoolsHook;\nexports.setTransitionHooks = setTransitionHooks;\nexports.ssrContextKey = ssrContextKey;\nexports.ssrUtils = ssrUtils;\nexports.toHandlers = toHandlers;\nexports.transformVNodeArgs = transformVNodeArgs;\nexports.useContext = useContext;\nexports.useSSRContext = useSSRContext;\nexports.useTransitionState = useTransitionState;\nexports.version = version;\nexports.warn = warn;\nexports.watch = watch;\nexports.watchEffect = watchEffect;\nexports.withCtx = withCtx;\nexports.withDirectives = withDirectives;\nexports.withScopeId = withScopeId;\n","'use strict'\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/reactivity.cjs.prod.js')\n} else {\n  module.exports = require('./dist/reactivity.cjs.js')\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar shared = require('@vue/shared');\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol('');\r\nconst MAP_KEY_ITERATE_KEY = Symbol('');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = shared.EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && shared.isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!shared.isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (shared.isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (shared.isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!shared.isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (shared.isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (shared.isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ shared.makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(shared.isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = shared.isArray(target);\r\n        if (!isReadonly && targetIsArray && shared.hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (shared.isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !shared.isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (shared.isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            oldValue = toRaw(oldValue);\r\n            if (!shared.isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = shared.isArray(target) && shared.isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : shared.hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (shared.hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = shared.hasOwn(target, key);\r\n    target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!shared.isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, shared.isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = shared.extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = shared.extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => shared.isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => shared.isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (shared.hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = shared.isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst shallowReadonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, true)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(shared.hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, true)\r\n};\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(shared.toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!shared.isObject(target)) {\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    shared.def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => shared.isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (shared.hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    const ret = shared.isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        if (self._dirty) {\r\n            self._value = this.effect();\r\n            self._dirty = false;\r\n        }\r\n        track(self, \"get\" /* GET */, 'value');\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (shared.isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = shared.NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, shared.isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nexports.ITERATE_KEY = ITERATE_KEY;\nexports.computed = computed;\nexports.customRef = customRef;\nexports.effect = effect;\nexports.enableTracking = enableTracking;\nexports.isProxy = isProxy;\nexports.isReactive = isReactive;\nexports.isReadonly = isReadonly;\nexports.isRef = isRef;\nexports.markRaw = markRaw;\nexports.pauseTracking = pauseTracking;\nexports.proxyRefs = proxyRefs;\nexports.reactive = reactive;\nexports.readonly = readonly;\nexports.ref = ref;\nexports.resetTracking = resetTracking;\nexports.shallowReactive = shallowReactive;\nexports.shallowReadonly = shallowReadonly;\nexports.shallowRef = shallowRef;\nexports.stop = stop;\nexports.toRaw = toRaw;\nexports.toRef = toRef;\nexports.toRefs = toRefs;\nexports.track = track;\nexports.trigger = trigger;\nexports.triggerRef = triggerRef;\nexports.unref = unref;\n","<template>\r\n    <div class=\"flex justify-sdstt\">\r\n        <div class=\"text-gray-800\">\r\n            <canvas\r\n                v-show=\"mode == 'src'\"\r\n                class=\"max-w-7xl\"\r\n                ref=\"srcCanvasRef\"\r\n                width=\"600\"\r\n                height=\"600\"\r\n                v-on:mousedown=\"srcMousedown\"\r\n                v-on:mousemove=\"srcMousemove\"\r\n                v-on:mouseup=\"srcMouseup\"\r\n                v-on:mouseover=\"srcMouseup\"\r\n            ></canvas>\r\n            <canvas\r\n                v-show=\"mode == 'dst'\"\r\n                class=\"max-w-7xl\"\r\n                ref=\"dstCanvasRef\"\r\n                width=\"600\"\r\n                height=\"600\"\r\n                v-on:mousedown=\"dstMousedown\"\r\n                v-on:mousemove=\"dstMousemove\"\r\n                v-on:mouseup=\"dstMouseup\"\r\n                v-on:mouseover=\"dstMouseup\"\r\n            ></canvas>\r\n            <button\r\n                v-bind:class=\"{\r\n                    'bg-green-300': srcImg != undefined && mode != 'src',\r\n                    'bg-blue-300': srcImg == undefined && mode != 'src',\r\n                    'bg-yellow-300': mode == 'src',\r\n                }\"\r\n                class=\"py-1 px-5 rounded-b-lg\"\r\n                v-on:click=\";(mode = 'src'), renderCanvas()\"\r\n            >\r\n                src\r\n            </button>\r\n            <button\r\n                v-bind:class=\"{\r\n                    'bg-green-300': dstImg != undefined && mode != 'dst',\r\n                    'bg-blue-300': dstImg == undefined && mode != 'dst',\r\n                    'bg-yellow-300': mode == 'dst',\r\n                }\"\r\n                class=\"py-1 px-5 rounded-b-lg\"\r\n                v-on:click=\";(mode = 'dst'), renderCanvas()\"\r\n            >\r\n                dst\r\n            </button>\r\n            <button class=\"bg-pink-500 text-white py-1 px-5 rounded-b-lg\" v-on:click=\"loadImg()\">\r\n                load img\r\n            </button>\r\n\r\n            <button\r\n                class=\"bg-red-600 text-white py-1 px-5 rounded-b-lg\"\r\n                v-show=\"\r\n                    lines.length != 0 &&\r\n                    lines.reduce((prev, line) => prev && line.dst != undefined, true) &&\r\n                    srcImg != undefined &&\r\n                    dstImg != undefined\r\n                \"\r\n                v-on:click=\"openView\"\r\n            >\r\n                open view\r\n            </button>\r\n        </div>\r\n        <div class=\"text-gray-800 w-36 m-2\">\r\n            <div class=\"h-10\">\r\n                <div v-if=\"lines[lookLineIdx] && lines[lookLineIdx][mode]\">\r\n                    from: ({{ Math.round(lines[lookLineIdx][mode].from.x * 100) / 100 }},\r\n                    {{ Math.round(lines[lookLineIdx][mode].from.y * 100) / 100 }})\r\n                    <br />\r\n                    to: ({{ Math.round(lines[lookLineIdx][mode].to.x * 100) / 100 }},\r\n                    {{ Math.round(lines[lookLineIdx][mode].to.y * 100) / 100 }})\r\n                </div>\r\n            </div>\r\n            <ul>\r\n                <li v-for=\"(value, name) in lines\" :key=\"name\" class=\"flex justify-sdstt my-2\">\r\n                    <div\r\n                        v-on:click=\";(lookLineIdx = name), renderCanvas()\"\r\n                        v-bind:class=\"{\r\n                            'bg-blue-300': value.dst == undefined && name != lookLineIdx,\r\n                            'bg-green-300': value.dst != undefined && name != lookLineIdx,\r\n                            'bg-yellow-300': name == lookLineIdx,\r\n                        }\"\r\n                        class=\"py-1 px-3 w-full rounded-l-lg\"\r\n                    >\r\n                        line {{ name }}\r\n                    </div>\r\n                    <div\r\n                        v-on:click=\"removeLine(name)\"\r\n                        class=\"bg-pink-600 p-1 w-10 rounded-r-lg text-center\"\r\n                    >\r\n                        <img :src=\"close_icon\" alt=\"remove\" />\r\n                    </div>\r\n                </li>\r\n            </ul>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport { defineComponent, ref, onMounted, Ref } from \"vue\"\r\n// @ts-ignore\r\nimport close_icon from \"url:../icon/highlight_off_black_24dp.svg\"\r\ninterface Point {\r\n    x: number\r\n    y: number\r\n}\r\ninterface Line {\r\n    from: Point\r\n    to: Point\r\n}\r\n\r\nconst imgSize = 600\r\n\r\nconst drawLine = (ctx: CanvasRenderingContext2D, line: Line, color: string = `#ffcc33`) => {\r\n    ctx.beginPath()\r\n    ctx.strokeStyle = color\r\n    ctx.moveTo((line.from.x + 1) * (imgSize / 2), (-line.from.y + 1) * (imgSize / 2))\r\n    ctx.lineTo((line.to.x + 1) * (imgSize / 2), (-line.to.y + 1) * (imgSize / 2))\r\n    ctx.stroke()\r\n\r\n    ctx.lineWidth = 3\r\n    ctx.beginPath()\r\n    ctx.strokeStyle = `#ff5522`\r\n    ctx.fillStyle = `#ff5522`\r\n    ctx.arc(\r\n        (line.from.x + 1) * (imgSize / 2),\r\n        (-line.from.y + 1) * (imgSize / 2),\r\n        5,\r\n        0,\r\n        Math.PI * 2,\r\n        true\r\n    )\r\n    ctx.fill()\r\n    ctx.stroke()\r\n\r\n    ctx.beginPath()\r\n    ctx.strokeStyle = `#22ffff`\r\n    ctx.fillStyle = `#22ffff`\r\n    ctx.arc(\r\n        (line.to.x + 1) * (imgSize / 2),\r\n        (-line.to.y + 1) * (imgSize / 2),\r\n        5,\r\n        0,\r\n        Math.PI * 2,\r\n        true\r\n    )\r\n    ctx.fill()\r\n    ctx.stroke()\r\n}\r\nconst color = {\r\n    other: `#93c5fd`,\r\n    success: `rgba(110, 231, 183)`,\r\n    primary: `#ffcc33`,\r\n}\r\n\r\nexport default defineComponent({\r\n    setup() {\r\n        const srcCanvasRef: Ref<HTMLCanvasElement> = ref()\r\n\r\n        const srcMousedown = ref((e: MouseEvent) => {})\r\n        const srcMousemove = ref((e: MouseEvent) => {})\r\n        const srcMouseup = ref((e: MouseEvent) => {})\r\n\r\n        const dstCanvasRef: Ref<HTMLCanvasElement> = ref()\r\n\r\n        const dstMousedown = ref((e: MouseEvent) => {})\r\n        const dstMousemove = ref((e: MouseEvent) => {})\r\n        const dstMouseup = ref((e: MouseEvent) => {})\r\n\r\n        const lines: Ref<{ src: Line; dst: Line }[]> = ref([])\r\n\r\n        const lookLineIdx = ref(-1)\r\n\r\n        const mode = ref(\"src\")\r\n\r\n        const removeLine = ref((idx: number) => {\r\n            lines.value = lines.value.reduce((lineArr, currLine, currIdx) => {\r\n                if (currIdx != idx) {\r\n                    lineArr.push(currLine)\r\n                }\r\n                return lineArr\r\n            }, [])\r\n\r\n            if (lookLineIdx.value != -1) {\r\n                if (lookLineIdx.value == idx) {\r\n                    lookLineIdx.value = -1\r\n                } else if (lookLineIdx.value > idx) {\r\n                    lookLineIdx.value -= 1\r\n                }\r\n            }\r\n\r\n            renderCanvas.value()\r\n        })\r\n\r\n        const renderCanvas = ref(() => {})\r\n\r\n        let srcCtx: CanvasRenderingContext2D\r\n        let dstCtx: CanvasRenderingContext2D\r\n\r\n        onMounted(() => {\r\n            const srcCanvas = srcCanvasRef.value\r\n            srcCtx = srcCanvas.getContext(\"2d\")\r\n            const dstCanvas = dstCanvasRef.value\r\n            dstCtx = dstCanvas.getContext(\"2d\")\r\n\r\n            let down = false\r\n            let move = false\r\n            let tempLine: Line = { from: { x: 0, y: 0 }, to: { x: 0, y: 0 } }\r\n\r\n            srcMousedown.value = (e) => {\r\n                down = true\r\n                tempLine = {\r\n                    from: {\r\n                        x: (e.pageX - srcCanvas.offsetLeft) / (imgSize / 2) - 1,\r\n                        y: -((e.pageY - srcCanvas.offsetTop) / (imgSize / 2) - 1),\r\n                    },\r\n                    to: {\r\n                        x: (e.pageX - srcCanvas.offsetLeft) / (imgSize / 2) - 1,\r\n                        y: -((e.pageY - srcCanvas.offsetTop) / (imgSize / 2) - 1),\r\n                    },\r\n                }\r\n                drawLine(srcCtx, tempLine, color.primary)\r\n            }\r\n            srcMousemove.value = (e: MouseEvent) => {\r\n                if (down) {\r\n                    tempLine.to = {\r\n                        x: (e.pageX - srcCanvas.offsetLeft) / (imgSize / 2) - 1,\r\n                        y: -((e.pageY - srcCanvas.offsetTop) / (imgSize / 2) - 1),\r\n                    }\r\n                    if (!move) {\r\n                        move = true\r\n                        lines.value.push({ src: Object.assign({}, tempLine), dst: undefined })\r\n                        lookLineIdx.value = lines.value.length - 1\r\n                    } else {\r\n                        lines.value[lookLineIdx.value] = {\r\n                            src: Object.assign({}, tempLine),\r\n                            dst: undefined,\r\n                        }\r\n                    }\r\n                    renderCanvas.value()\r\n                }\r\n            }\r\n            srcMouseup.value = (e) => {\r\n                if (down && move) {\r\n                    if (\r\n                        lines.value[lookLineIdx.value].src.from.x ==\r\n                            lines.value[lookLineIdx.value].src.to.x &&\r\n                        lines.value[lookLineIdx.value].src.from.y ==\r\n                            lines.value[lookLineIdx.value].src.to.y\r\n                    ) {\r\n                        lines.value.pop()\r\n                    }\r\n                }\r\n                down = false\r\n                move = false\r\n                renderCanvas.value()\r\n            }\r\n\r\n            dstMousedown.value = (e) => {\r\n                if (lookLineIdx.value != -1) {\r\n                    down = true\r\n                    tempLine = {\r\n                        from: {\r\n                            x: (e.pageX - dstCanvas.offsetLeft) / (imgSize / 2) - 1,\r\n                            y: -((e.pageY - dstCanvas.offsetTop) / (imgSize / 2) - 1),\r\n                        },\r\n                        to: {\r\n                            x: (e.pageX - dstCanvas.offsetLeft) / (imgSize / 2) - 1,\r\n                            y: -((e.pageY - dstCanvas.offsetTop) / (imgSize / 2) - 1),\r\n                        },\r\n                    }\r\n                    drawLine(dstCtx, tempLine, color.primary)\r\n                }\r\n            }\r\n            dstMousemove.value = (e: MouseEvent) => {\r\n                if (down) {\r\n                    tempLine.to = {\r\n                        x: (e.pageX - dstCanvas.offsetLeft) / (imgSize / 2) - 1,\r\n                        y: -((e.pageY - dstCanvas.offsetTop) / (imgSize / 2) - 1),\r\n                    }\r\n                    lines.value[lookLineIdx.value].dst = Object.assign({}, tempLine)\r\n                    renderCanvas.value()\r\n                }\r\n            }\r\n            dstMouseup.value = (e: MouseEvent) => {\r\n                if (down) {\r\n                    down = false\r\n                    if (\r\n                        lines.value[lookLineIdx.value].dst.from.x ==\r\n                            lines.value[lookLineIdx.value].dst.to.x &&\r\n                        lines.value[lookLineIdx.value].dst.from.y ==\r\n                            lines.value[lookLineIdx.value].dst.to.y\r\n                    ) {\r\n                        lines.value[lookLineIdx.value].dst = undefined\r\n                    }\r\n                    if (lines.value.length - 1 > lookLineIdx.value) {\r\n                        lookLineIdx.value += 1\r\n                    }\r\n                    renderCanvas.value()\r\n                }\r\n            }\r\n\r\n            renderCanvas.value = () => {\r\n                const ctx = mode.value == \"src\" ? srcCtx : dstCtx\r\n                ctx.clearRect(0, 0, 800, imgSize)\r\n                const img = mode.value == \"src\" ? srcImg.value : dstImg.value\r\n                if (img != undefined) ctx.drawImage(img, 0, 0, imgSize, imgSize)\r\n                lines.value.forEach((line, i) => {\r\n                    if (line[mode.value]) {\r\n                        if (i != lookLineIdx.value && line.dst) {\r\n                            drawLine(ctx, line[mode.value], color.success)\r\n                        } else if (i != lookLineIdx.value) {\r\n                            drawLine(ctx, line[mode.value], color.other)\r\n                        } else {\r\n                            drawLine(ctx, line[mode.value], color.primary)\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n        })\r\n\r\n        const channel = new BroadcastChannel(\"channel\")\r\n        interface Msg {\r\n            msgType: \"opened\" | \"lines\" | \"srcImgLink\" | \"dstImgLink\"\r\n            lines?: { src: Line; dst: Line }[]\r\n            link?: string\r\n        }\r\n        channel.onmessage = (event: MessageEvent<Msg>) => {\r\n            const msg = event.data\r\n            switch (msg.msgType) {\r\n                case \"opened\": {\r\n                    channel.postMessage(<Msg>{\r\n                        msgType: \"lines\",\r\n                        lines: JSON.parse(JSON.stringify(lines.value)),\r\n                    })\r\n                    channel.postMessage(<Msg>{\r\n                        msgType: \"srcImgLink\",\r\n                        link: srcImg.value.src,\r\n                    })\r\n                    channel.postMessage(<Msg>{\r\n                        msgType: \"dstImgLink\",\r\n                        link: dstImg.value.src,\r\n                    })\r\n                    break\r\n                }\r\n            }\r\n        }\r\n        const openView = () => {\r\n            window.open(\"./index.html\", \"image morphing view\")\r\n        }\r\n\r\n        let srcImg: Ref<HTMLImageElement> = ref()\r\n        let dstImg: Ref<HTMLImageElement> = ref()\r\n        const loadImg = () => {\r\n            const inp = document.createElement(\"input\")\r\n            inp.type = \"file\"\r\n            inp.accept = \"image/*\"\r\n            inp.onchange = () => {\r\n                const files = inp.files\r\n                const reader = new FileReader()\r\n                reader.addEventListener(\"loadend\", async () => {\r\n                    let img = new Image()\r\n                    img.onload = () => {\r\n                        if (mode.value == \"src\") srcImg.value = img\r\n                        else if (mode.value == \"dst\") dstImg.value = img\r\n                        renderCanvas.value()\r\n                    }\r\n                    img.src = <string>reader.result\r\n                })\r\n                reader.readAsDataURL(files[0])\r\n            }\r\n            inp.click()\r\n        }\r\n\r\n        return {\r\n            srcCanvasRef,\r\n            srcMousedown,\r\n            srcMousemove,\r\n            srcMouseup,\r\n\r\n            dstCanvasRef,\r\n            dstMousedown,\r\n            dstMousemove,\r\n            dstMouseup,\r\n\r\n            lines,\r\n            close_icon,\r\n            lookLineIdx,\r\n            removeLine,\r\n            mode,\r\n            renderCanvas,\r\n\r\n            openView,\r\n\r\n            loadImg,\r\n\r\n            srcImg,\r\n            dstImg,\r\n        }\r\n    },\r\n})\r\n</script>\r\n\r\n<style scoped>\r\nmin-w-0 {\r\n    min-width: 0px;\r\n}\r\n</style>\r\n","\"use strict\";\n\n/* globals document:readonly */\nvar bundleURL = null;\n\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp):\\/\\/[^)\\n]+/g);\n\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\n\n\nfunction getOrigin(url) {\n  let matches = ('' + url).match(/(https?|file|ftp):\\/\\/[^/]+/);\n\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n\n  return matches[0];\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","\"use strict\";\n\nvar resolve = require('./bundle-manifest').resolve;\n\nmodule.exports = function (fromId, toId) {\n  return relative(dirname(resolve(fromId)), resolve(toId));\n};\n\nfunction dirname(_filePath) {\n  if (_filePath === '') {\n    return '.';\n  }\n\n  var filePath = _filePath[_filePath.length - 1] === '/' ? _filePath.slice(0, _filePath.length - 1) : _filePath;\n  var slashIndex = filePath.lastIndexOf('/');\n  return slashIndex === -1 ? '.' : filePath.slice(0, slashIndex);\n}\n\nfunction relative(from, to) {\n  if (from === to) {\n    return '';\n  }\n\n  var fromParts = from.split('/');\n\n  if (fromParts[0] === '.') {\n    fromParts.shift();\n  }\n\n  var toParts = to.split('/');\n\n  if (toParts[0] === '.') {\n    toParts.shift();\n  } // Find where path segments diverge.\n\n\n  var i;\n  var divergeIndex;\n\n  for (i = 0; (i < toParts.length || i < fromParts.length) && divergeIndex == null; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      divergeIndex = i;\n    }\n  } // If there are segments from \"from\" beyond the point of divergence,\n  // return back up the path to that point using \"..\".\n\n\n  var parts = [];\n\n  for (i = 0; i < fromParts.length - divergeIndex; i++) {\n    parts.push('..');\n  } // If there are segments from \"to\" beyond the point of divergence,\n  // continue using the remaining segments.\n\n\n  if (toParts.length > divergeIndex) {\n    parts.push.apply(parts, toParts.slice(divergeIndex));\n  }\n\n  return parts.join('/');\n}\n\nmodule.exports._dirname = dirname;\nmodule.exports._relative = relative;","\"use strict\";\n\nexports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {\n    default: a\n  };\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {\n    value: true\n  });\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    } // Skip duplicate re-exports when they have the same value.\n\n\n    if (key in dest && dest[key] === source[key]) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get\n  });\n};","<template>\r\n    <div>\r\n        <canvas\r\n            ref=\"canvasRef\"\r\n            v-bind:style=\"`width:${width}px;height:${height}px;`\"\r\n            width=\"500\"\r\n            height=\"500\"\r\n        ></canvas>\r\n        <button\r\n            v-bind:class=\"{\r\n                'bg-blue-300': mode != 'morphing',\r\n                'bg-yellow-300': mode == 'morphing',\r\n            }\"\r\n            class=\"py-1 px-5 rounded-b-lg\"\r\n            v-on:click=\";(mode = 'morphing'), run(time)\"\r\n        >\r\n            image morphing\r\n        </button>\r\n        <button\r\n            v-bind:class=\"{\r\n                'bg-blue-300': mode != 'src',\r\n                'bg-yellow-300': mode == 'src',\r\n            }\"\r\n            class=\"py-1 px-5 rounded-b-lg\"\r\n            v-on:click=\";(mode = 'src'), run(time)\"\r\n        >\r\n            src\r\n        </button>\r\n        <button\r\n            v-bind:class=\"{\r\n                'bg-blue-300': mode != 'dst',\r\n                'bg-yellow-300': mode == 'dst',\r\n            }\"\r\n            class=\"py-1 px-5 rounded-b-lg\"\r\n            v-on:click=\";(mode = 'dst'), run(time)\"\r\n        >\r\n            dst\r\n        </button>\r\n        <div>\r\n            <input\r\n                type=\"range\"\r\n                min=\"0\"\r\n                max=\"1\"\r\n                step=\"0.001\"\r\n                v-model=\"time\"\r\n                v-on:input=\"run(time)\"\r\n            />{{ time }}\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script lang=\"ts\">\r\nimport { defineComponent, ref, onMounted, Ref } from \"vue\"\r\nimport { calcWeight, genShaderProgram, genBufferData, render, genVAO } from \"./imgMorph\"\r\nimport { Line as PoseLine, Transform } from \"./pose\"\r\nimport * as glm from \"gl-matrix\"\r\ninterface Point {\r\n    x: number\r\n    y: number\r\n}\r\ninterface Line {\r\n    from: Point\r\n    to: Point\r\n}\r\n\r\nexport default defineComponent({\r\n    setup() {\r\n        const run = ref((t: number) => {})\r\n        const time = ref(0)\r\n        const mode = ref(\"morphing\")\r\n\r\n        const canvasRef: Ref<HTMLCanvasElement> = ref()\r\n\r\n        let srcImg: HTMLImageElement = new Image()\r\n        let dstImg: HTMLImageElement = new Image()\r\n        let width = ref(500),\r\n            height = ref(500)\r\n\r\n        onMounted(() => {\r\n            const gl = createGl(canvasRef.value)\r\n\r\n            let bg_program: WebGLProgram\r\n            let fg_program: WebGLProgram\r\n\r\n            let transforms: { src: Transform; dst: Transform }[]\r\n\r\n            let pos_arr: number[], uv_arr: number[], idx_arr: number[]\r\n\r\n            let fg_vao: WebGLVertexArrayObject\r\n            let bg_vao: WebGLVertexArrayObject\r\n\r\n            let fg_texture: WebGLTexture\r\n            let bg_texture: WebGLTexture\r\n\r\n            run.value = (t: number) => {\r\n                switch (mode.value) {\r\n                    case \"morphing\": {\r\n                        let w = srcImg.width * (1 - t) + dstImg.width * t\r\n                        let h = srcImg.height * (1 - t) + dstImg.height * t\r\n                        ;({ w, h } = calcWH(w, h))\r\n                        width.value = w\r\n                        height.value = h\r\n\r\n                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\r\n                        render(\r\n                            t,\r\n                            gl,\r\n                            bg_program,\r\n                            bg_vao,\r\n                            bg_texture,\r\n                            transforms.map(({ dst }) => dst.withTime(1 - t)),\r\n                            idx_arr.length\r\n                        )\r\n                        render(\r\n                            t,\r\n                            gl,\r\n                            fg_program,\r\n                            fg_vao,\r\n                            fg_texture,\r\n                            transforms.map(({ src }) => src.withTime(t)),\r\n                            idx_arr.length\r\n                        )\r\n                        break\r\n                    }\r\n                    case \"src\": {\r\n                        let w = srcImg.width\r\n                        let h = srcImg.height\r\n                        ;({ w, h } = calcWH(w, h))\r\n                        width.value = w\r\n                        height.value = h\r\n\r\n                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\r\n                        render(\r\n                            t,\r\n                            gl,\r\n                            bg_program,\r\n                            fg_vao,\r\n                            fg_texture,\r\n                            transforms.map(({ src }) => src.withTime(t)),\r\n                            idx_arr.length\r\n                        )\r\n                        render(\r\n                            t,\r\n                            gl,\r\n                            fg_program,\r\n                            fg_vao,\r\n                            fg_texture,\r\n                            transforms.map(({ src }) => src.withTime(t)),\r\n                            idx_arr.length\r\n                        )\r\n                        break\r\n                    }\r\n                    case \"dst\": {\r\n                        let w = srcImg.width\r\n                        let h = srcImg.height\r\n                        ;({ w, h } = calcWH(w, h))\r\n                        width.value = w\r\n                        height.value = h\r\n\r\n                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\r\n                        render(\r\n                            t,\r\n                            gl,\r\n                            bg_program,\r\n                            bg_vao,\r\n                            bg_texture,\r\n                            transforms.map(({ dst }) => dst.withTime(1 - t)),\r\n                            idx_arr.length\r\n                        )\r\n                        render(\r\n                            t,\r\n                            gl,\r\n                            fg_program,\r\n                            bg_vao,\r\n                            bg_texture,\r\n                            transforms.map(({ dst }) => dst.withTime(1 - t)),\r\n                            idx_arr.length\r\n                        )\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n\r\n            const channel = new BroadcastChannel(\"channel\")\r\n            interface Msg {\r\n                msgType: \"opened\" | \"lines\" | \"srcImgLink\" | \"dstImgLink\"\r\n                lines?: { src: Line; dst: Line }[]\r\n                link?: string\r\n            }\r\n            channel.onmessage = (event: MessageEvent<Msg>) => {\r\n                const msg = event.data\r\n                switch (msg.msgType) {\r\n                    case \"lines\": {\r\n                        const lines = msg.lines\r\n                        ;({ pos_arr, uv_arr, idx_arr } = genBufferData(25, 25))\r\n\r\n                        let srcWeights = new Array(Math.ceil(lines.length / 4))\r\n                            .fill(0)\r\n                            .map(() => []) //lines.map(() => [])\r\n                        for (let i = 0; i < pos_arr.length; i += 2) {\r\n                            let ws = new Array(Math.ceil(lines.length / 4) * 4).fill(0)\r\n                            lines.forEach((line, lineIdx) => {\r\n                                ws[lineIdx] = calcWeight(\r\n                                    { x: pos_arr[i], y: pos_arr[i + 1] },\r\n                                    line.src,\r\n                                    0.001,\r\n                                    2,\r\n                                    0.5\r\n                                )\r\n                            })\r\n                            let w_acc = ws.reduce((acc, w) => acc + w, 0)\r\n                            ws.forEach((w, lineIdx) =>\r\n                                srcWeights[Math.floor(lineIdx / 4)].push(w / w_acc)\r\n                            )\r\n                        }\r\n                        gl.deleteVertexArray(fg_vao)\r\n                        fg_vao = genVAO(gl, pos_arr, uv_arr, idx_arr, srcWeights)\r\n\r\n                        let dstWeights = new Array(Math.ceil(lines.length / 4))\r\n                            .fill(0)\r\n                            .map(() => []) //lines.map(() => [])\r\n                        for (let i = 0; i < pos_arr.length; i += 2) {\r\n                            let ws = new Array(Math.ceil(lines.length / 4) * 4).fill(0)\r\n                            lines.forEach((line, lineIdx) => {\r\n                                ws[lineIdx] = calcWeight(\r\n                                    { x: pos_arr[i], y: pos_arr[i + 1] },\r\n                                    line.dst,\r\n                                    0.001,\r\n                                    2,\r\n                                    0.5\r\n                                )\r\n                            })\r\n                            let w_acc = ws.reduce((acc, w) => acc + w, 0)\r\n                            ws.forEach((w, lineIdx) =>\r\n                                dstWeights[Math.floor(lineIdx / 4)].push(w / w_acc)\r\n                            )\r\n                        }\r\n                        gl.deleteVertexArray(bg_vao)\r\n                        bg_vao = genVAO(gl, pos_arr, uv_arr, idx_arr, dstWeights)\r\n\r\n                        bg_program = genShaderProgram(gl, lines.length, true)\r\n                        fg_program = genShaderProgram(gl, lines.length, false)\r\n\r\n                        transforms = lines.map(({ src, dst }) => {\r\n                            let line1 = PoseLine.create(\r\n                                glm.vec2.fromValues(src.from.x, src.from.y),\r\n                                glm.vec2.fromValues(src.to.x, src.to.y)\r\n                            )\r\n                            let line2 = PoseLine.create(\r\n                                glm.vec2.fromValues(dst.from.x, dst.from.y),\r\n                                glm.vec2.fromValues(dst.to.x, dst.to.y)\r\n                            )\r\n                            return {\r\n                                src: new Transform(line1, line2),\r\n                                dst: new Transform(line2, line1),\r\n                            }\r\n                        })\r\n                    }\r\n                    case \"srcImgLink\": {\r\n                        srcImg.src = msg.link\r\n\r\n                        srcImg.onload = () => {\r\n                            gl.deleteTexture(fg_texture)\r\n                            fg_texture = gl.createTexture()\r\n                            gl.bindTexture(gl.TEXTURE_2D, fg_texture)\r\n\r\n                            gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGB8, srcImg.width, srcImg.height)\r\n                            gl.texSubImage2D(\r\n                                gl.TEXTURE_2D,\r\n                                0,\r\n                                0,\r\n                                0,\r\n                                gl.RGB,\r\n                                gl.UNSIGNED_BYTE,\r\n                                srcImg\r\n                            )\r\n                            gl.generateMipmap(gl.TEXTURE_2D)\r\n                        }\r\n                        break\r\n                    }\r\n                    case \"dstImgLink\": {\r\n                        dstImg.src = msg.link\r\n\r\n                        dstImg.onload = () => {\r\n                            gl.deleteTexture(bg_texture)\r\n                            bg_texture = gl.createTexture()\r\n                            gl.bindTexture(gl.TEXTURE_2D, bg_texture)\r\n\r\n                            gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGB8, dstImg.width, dstImg.height)\r\n                            gl.texSubImage2D(\r\n                                gl.TEXTURE_2D,\r\n                                0,\r\n                                0,\r\n                                0,\r\n                                gl.RGB,\r\n                                gl.UNSIGNED_BYTE,\r\n                                dstImg\r\n                            )\r\n                            gl.generateMipmap(gl.TEXTURE_2D)\r\n                            run.value(0)\r\n                        }\r\n\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n            channel.postMessage(<Msg>{ msgType: \"opened\" })\r\n        })\r\n\r\n        return {\r\n            run,\r\n            time,\r\n            mode,\r\n            canvasRef,\r\n            width,\r\n            height,\r\n        }\r\n    },\r\n})\r\n\r\nconst createGl = (canvas: HTMLCanvasElement) => {\r\n    let gl = canvas.getContext(\"webgl2\", {\r\n        preserveDrawingBuffer: true,\r\n        premultipliedAlpha: false,\r\n    })\r\n    gl.clearColor(0, 0, 0, 1)\r\n    gl.clearDepth(1)\r\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\r\n    gl.enable(gl.CULL_FACE)\r\n    gl.enable(gl.DEPTH_TEST)\r\n    gl.depthMask(true)\r\n    gl.depthFunc(gl.LEQUAL)\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)\r\n    gl.enable(gl.BLEND)\r\n    gl.blendFunc(gl.SRC_ALPHA, gl.DST_ALPHA)\r\n\r\n    return gl\r\n}\r\n\r\nconst calcWH = (w: number, h: number) => {\r\n    if (w > h) {\r\n        return {\r\n            w: 500,\r\n            h: (500 * h) / w,\r\n        }\r\n    } else {\r\n        return {\r\n            w: (500 * w) / h,\r\n            h: 500,\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style scoped>\r\nmin-w-0 {\r\n    min-width: 0px;\r\n}\r\n</style>\r\n","import * as shader from \"./shader\"\r\nimport * as glm from \"gl-matrix\"\r\n\r\ninterface Point {\r\n    x: number\r\n    y: number\r\n}\r\ninterface Line {\r\n    from: Point\r\n    to: Point\r\n}\r\nconst calcVecLen = (vec: Point) => {\r\n    return (vec.x ** 2 + vec.y ** 2) ** 0.5\r\n}\r\nconst calcLineLen = (line: Line) => {\r\n    let vec = { x: line.to.x - line.from.x, y: line.to.y - line.from.y }\r\n    return calcVecLen(vec)\r\n}\r\nconst calcDist = (point: Point, line: Line) => {\r\n    let vec1 = { x: point.x - line.from.x, y: point.y - line.from.y }\r\n    let vec2 = { x: line.to.x - line.from.x, y: line.to.y - line.from.y }\r\n    let vec2Len = calcVecLen(vec2)\r\n    let len = (vec1.x * vec2.x + vec1.y * vec2.y) / vec2Len\r\n    if (len < 0) {\r\n        return (vec1.x ** 2 + vec1.y ** 2) ** 0.5\r\n    } else if (len > vec2Len) {\r\n        let vec3 = { x: point.x - line.to.x, y: point.y - line.to.y }\r\n        return calcVecLen(vec3)\r\n    } else {\r\n        return (calcVecLen(vec1) ** 2 - len ** 2) ** 0.5\r\n    }\r\n}\r\n\r\nexport const calcWeight = (point: Point, line: Line, a: number, b: number, p: number) => {\r\n    let dist = calcDist(point, line)\r\n    let lineLen = calcLineLen(line)\r\n    return (lineLen ** p / (a + dist)) ** b\r\n}\r\n\r\nexport const genShaderProgram = (gl: WebGL2RenderingContext, lineNum: number, isBg = true) => {\r\n    let vs_source =\r\n        `#version 300 es\\n` +\r\n        `precision mediump float;\\n` +\r\n        `layout (location = 0) in vec2 a_position;\\n` +\r\n        `layout (location = 1) in vec2 a_texcoord;\\n` +\r\n        new Array(lineNum).fill(0).reduce((prev, _, idx) => {\r\n            if (idx % 4 == 0) {\r\n                return prev + `layout (location = ${idx / 4 + 2}) in vec4 a_w${idx / 4};\\n`\r\n            } else {\r\n                return prev\r\n            }\r\n        }, ``) +\r\n        new Array(lineNum).fill(0).reduce((prev, _, idx) => {\r\n            return prev + `uniform mat3 u_m${idx};\\n`\r\n        }, ``) +\r\n        `uniform float u_time;\\n` +\r\n        `out vec2 v_texcoord;\\n` +\r\n        `void main(void) {\\n` +\r\n        `   mat3 m;\\n` +\r\n        new Array(lineNum).fill(0).reduce((prev, _, idx) => {\r\n            return prev + `   m += u_m${idx} * a_w${Math.floor(idx / 4)}[${idx % 4}];\\n`\r\n        }, ``) +\r\n        `   vec3 pos = m * vec3(a_position, 1.0);\\n` +\r\n        // `   gl_Position = vec4(u_time * a_position + (1. - u_time) * pos.xy, 0.0, 1.0);\\n` +\r\n        `   gl_Position = vec4(pos.xy, 0.0, 1.0);\\n` +\r\n        `   v_texcoord = a_texcoord;\\n` +\r\n        `}\\n`\r\n\r\n    let fs_source =\r\n        `#version 300 es\\n` +\r\n        `precision mediump float;\\n` +\r\n        `in vec2 v_texcoord;\\n` +\r\n        `uniform sampler2D u_texture;\\n` +\r\n        `uniform float u_time;\\n` +\r\n        `out vec4 f_color;\\n` +\r\n        `void main(void) {\\n` +\r\n        `   f_color = texture(u_texture, v_texcoord);\\n` +\r\n        `   f_color = vec4(f_color.rgb, ${isBg ? \"u_time\" : \"1. - u_time\"});\\n` +\r\n        // `   f_color = vec4(v_texcoord, 0.5, 1.0);\\n` +\r\n        `}\\n`\r\n\r\n    let program = shader.createProgram(gl, vs_source, fs_source)\r\n    return program\r\n}\r\nexport const genBufferData = (x: number, y: number) => {\r\n    let pos_arr: number[] = []\r\n    let uv_arr: number[] = []\r\n    let idx_arr: number[] = []\r\n    for (let j = 0; j <= y; j++) {\r\n        for (let i = 0; i <= x; i++) {\r\n            pos_arr = pos_arr.concat([i / (x / 2) - 1, j / (y / 2) - 1])\r\n            uv_arr = uv_arr.concat([i / x, 1 - j / y])\r\n            if (j != y && i != x) {\r\n                const n = j * (x + 1) + i\r\n                idx_arr = idx_arr.concat([n, n + 1, n + (x + 2)])\r\n                idx_arr = idx_arr.concat([n, n + (x + 2), n + (x + 1)])\r\n            }\r\n        }\r\n    }\r\n\r\n    return { pos_arr, uv_arr, idx_arr }\r\n}\r\n\r\nexport const render = (\r\n    time: number,\r\n    gl: WebGL2RenderingContext,\r\n    program: WebGLProgram,\r\n    vao: WebGLVertexArrayObject,\r\n    texture: WebGLTexture,\r\n    transformMat3s: glm.mat3[],\r\n    count\r\n) => {\r\n    gl.useProgram(program)\r\n    gl.bindVertexArray(vao)\r\n\r\n    let u_textureLocation = gl.getUniformLocation(program, \"u_texture\")\r\n    gl.uniform1i(u_textureLocation, 0)\r\n    gl.activeTexture(gl.TEXTURE0)\r\n    gl.bindTexture(gl.TEXTURE_2D, texture)\r\n\r\n    let u_timeLocation = gl.getUniformLocation(program, \"u_time\")\r\n    gl.uniform1f(u_timeLocation, time)\r\n\r\n    transformMat3s.forEach((m, lineIdx) => {\r\n        let u_mLocation = gl.getUniformLocation(program, `u_m${lineIdx}`)\r\n        gl.uniformMatrix3fv(u_mLocation, false, m)\r\n    })\r\n\r\n    gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_INT, 0)\r\n    gl.bindVertexArray(null)\r\n}\r\n\r\nexport const genVAO = (\r\n    gl: WebGL2RenderingContext,\r\n    pos_arr: number[],\r\n    uv_arr: number[],\r\n    idx_arr: number[],\r\n    weights: number[][]\r\n) => {\r\n    let vao = gl.createVertexArray()\r\n    gl.bindVertexArray(vao)\r\n    gl.enableVertexAttribArray(0)\r\n    const positionBuffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos_arr), gl.STATIC_DRAW)\r\n    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0)\r\n\r\n    gl.enableVertexAttribArray(1)\r\n    const texcoordBuffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uv_arr), gl.STATIC_DRAW)\r\n    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0)\r\n\r\n    weights.forEach((weight, lineIdx) => {\r\n        gl.enableVertexAttribArray(2 + lineIdx)\r\n        const weightBuffer = gl.createBuffer()\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, weightBuffer)\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(weight), gl.STATIC_DRAW)\r\n        gl.vertexAttribPointer(2 + lineIdx, 4, gl.FLOAT, false, 0, 0)\r\n    })\r\n\r\n    const ebo = gl.createBuffer()\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo)\r\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(idx_arr), gl.STATIC_DRAW)\r\n    gl.bindVertexArray(null)\r\n\r\n    return vao\r\n}\r\n","export const createProgram = (gl: WebGL2RenderingContext, vsSource: string, fsSource: string) => {\r\n    const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource)\r\n    const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fsSource)\r\n\r\n    // Create the shader program\r\n\r\n    const shaderProgram = gl.createProgram()\r\n    gl.attachShader(shaderProgram, vertexShader)\r\n    gl.attachShader(shaderProgram, fragmentShader)\r\n    gl.linkProgram(shaderProgram)\r\n\r\n    // If creating the shader program failed, alert\r\n\r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n        console.log(\r\n            \"Unable to initialize the shader program: \" + gl.getProgramInfoLog(shaderProgram)\r\n        )\r\n        return null\r\n    }\r\n\r\n    return shaderProgram\r\n}\r\n\r\n//\r\n// creates a shader of the given type, uploads the source and\r\n// compiles it.\r\n//\r\nexport const compileShader = (gl: WebGL2RenderingContext, type: number, source: string) => {\r\n    const shader = gl.createShader(type)\r\n\r\n    // Send the source to the shader object\r\n\r\n    gl.shaderSource(shader, source)\r\n\r\n    // Compile the shader program\r\n\r\n    gl.compileShader(shader)\r\n\r\n    // See if it compiled successfully\r\n\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        console.log(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader))\r\n        gl.deleteShader(shader)\r\n        return null\r\n    }\r\n\r\n    return shader\r\n}\r\n","import * as glm from \"gl-matrix\"\r\n\r\nconst r90 = (v: glm.vec2) => {\r\n    return glm.vec2.rotate(glm.vec2.create(), v, [0, 0], Math.PI * 0.5)\r\n}\r\nclass Mat3 {\r\n    constructor(mat3: glm.mat3) {\r\n        this.mat3 = mat3\r\n    }\r\n    mat3: glm.mat3\r\n    mul(b: glm.mat3) {\r\n        return new Mat3(glm.mat3.mul(glm.mat3.create(), this.mat3, b))\r\n    }\r\n}\r\nexport class Line {\r\n    constructor(p1: glm.vec2, p2: glm.vec2) {\r\n        this.p = glm.vec2.clone(p1)\r\n        this.v = glm.vec2.sub(glm.vec2.create(), p2, p1)\r\n    }\r\n    static create(p1: glm.vec2, p2: glm.vec2) {\r\n        return new Line(p1, p2)\r\n    }\r\n    p: glm.vec2\r\n    v: glm.vec2\r\n\r\n    static angle(line1: Line, line2: Line) {\r\n        return line1.angle(line2)\r\n    }\r\n    angle(line2: Line) {\r\n        let angle = glm.vec2.angle(this.v, line2.v)\r\n        if (glm.vec2.dot(this.v, r90(line2.v)) >= 0) {\r\n            // angle = Math.PI * 2 - angle\r\n            angle = -angle\r\n        }\r\n        return angle\r\n    }\r\n    scale(line2: Line) {\r\n        return glm.vec2.len(line2.v) / glm.vec2.len(this.v)\r\n    }\r\n    displacement(line2: Line) {\r\n        return glm.vec2.sub(glm.vec2.create(), line2.p, this.p)\r\n    }\r\n\r\n    transformMat3(line2: Line) {\r\n        let x_axis = Line.create([0, 0], [1, 0])\r\n\r\n        let t1 = glm.mat3.fromTranslation(\r\n            glm.mat3.create(),\r\n            glm.vec2.negate(glm.vec2.create(), this.p)\r\n        )\r\n\r\n        let x_angle = this.angle(x_axis)\r\n\r\n        let r1 = glm.mat3.fromRotation(glm.mat3.create(), x_angle)\r\n\r\n        let scale = this.scale(line2)\r\n\r\n        let s = glm.mat3.fromScaling(glm.mat3.create(), [scale, 1])\r\n\r\n        let neg_r1 = glm.mat3.fromRotation(glm.mat3.create(), -x_angle)\r\n\r\n        let angle = this.angle(line2)\r\n\r\n        let r2 = glm.mat3.fromRotation(glm.mat3.create(), angle)\r\n\r\n        let t = glm.mat3.fromTranslation(glm.mat3.create(), line2.p)\r\n        return new Mat3(t).mul(r2).mul(neg_r1).mul(s).mul(r1).mul(t1).mat3\r\n    }\r\n}\r\n\r\nexport class Transform {\r\n    constructor(line1: Line, line2: Line) {\r\n        this.org = line1.p\r\n        this.x_angle = line1.angle(Line.create([0, 0], [1, 0]))\r\n\r\n        this.angle = line1.angle(line2)\r\n        this.scale = line1.scale(line2)\r\n        this.displacement = line1.displacement(line2)\r\n    }\r\n\r\n    org: glm.vec2\r\n    x_angle: number\r\n\r\n    angle: number\r\n    scale: number\r\n    displacement: glm.vec2\r\n    withTime(t) {\r\n        let angle = t * this.angle\r\n        let scale = 1 - t + t * this.scale\r\n        let displacement = glm.vec2.mul(glm.vec2.create(), this.displacement, [t, t])\r\n\r\n        let tran2org = glm.mat3.fromTranslation(\r\n            glm.mat3.create(),\r\n            glm.vec2.negate(glm.vec2.create(), this.org)\r\n        )\r\n\r\n        let rotate2x = glm.mat3.fromRotation(glm.mat3.create(), this.x_angle)\r\n\r\n        let scaling = glm.mat3.fromScaling(glm.mat3.create(), [scale, 1])\r\n\r\n        let derotate2x = glm.mat3.fromRotation(glm.mat3.create(), -this.x_angle)\r\n\r\n        let rotate2target = glm.mat3.fromRotation(glm.mat3.create(), angle)\r\n\r\n        let detran2org = glm.mat3.fromTranslation(glm.mat3.create(), this.org)\r\n        let tran2target = glm.mat3.fromTranslation(glm.mat3.create(), displacement)\r\n\r\n        return new Mat3(tran2target)\r\n            .mul(detran2org)\r\n            .mul(rotate2target)\r\n            .mul(derotate2x)\r\n            .mul(scaling)\r\n            .mul(rotate2x)\r\n            .mul(tran2org).mat3\r\n    }\r\n}\r\n// let l1 = Line.create([1, 0], [2, 0])\r\n// let l2 = Line.create([-1, 0], [0, -1])\r\n// // let l1 = Line.create([0, 0], [2, 0])\r\n// // let l2 = Line.create([0, 0], [3, 3])\r\n// let m = l1.transformMat3(l2)\r\n// // m = new Transform(l1, l2).withTime(1)\r\n// let v = glm.vec2.transformMat3(glm.vec2.create(), [0, 0], m)\r\n// console.log(`v: ${v}`)\r\n\r\n// test\r\n{\r\n    // t'->r'->s->r\"->r->t\"->t\r\n}\r\n","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nexports.glMatrix = glMatrix;\n\nvar mat2 = _interopRequireWildcard(require(\"./mat2.js\"));\n\nexports.mat2 = mat2;\n\nvar mat2d = _interopRequireWildcard(require(\"./mat2d.js\"));\n\nexports.mat2d = mat2d;\n\nvar mat3 = _interopRequireWildcard(require(\"./mat3.js\"));\n\nexports.mat3 = mat3;\n\nvar mat4 = _interopRequireWildcard(require(\"./mat4.js\"));\n\nexports.mat4 = mat4;\n\nvar quat = _interopRequireWildcard(require(\"./quat.js\"));\n\nexports.quat = quat;\n\nvar quat2 = _interopRequireWildcard(require(\"./quat2.js\"));\n\nexports.quat2 = quat2;\n\nvar vec2 = _interopRequireWildcard(require(\"./vec2.js\"));\n\nexports.vec2 = vec2;\n\nvar vec3 = _interopRequireWildcard(require(\"./vec3.js\"));\n\nexports.vec3 = vec3;\n\nvar vec4 = _interopRequireWildcard(require(\"./vec4.js\"));\n\nexports.vec4 = vec4;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setMatrixArrayType = setMatrixArrayType;\nexports.toRadian = toRadian;\nexports.equals = equals;\nexports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;\n\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\n// Configuration Constants\nvar EPSILON = 0.000001;\nexports.EPSILON = EPSILON;\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexports.ARRAY_TYPE = ARRAY_TYPE;\nvar RANDOM = Math.random;\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\r\n */\n\nexports.RANDOM = RANDOM;\n\nfunction setMatrixArrayType(type) {\n  exports.ARRAY_TYPE = ARRAY_TYPE = type;\n}\n\nvar degree = Math.PI / 180;\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\n\nfunction toRadian(a) {\n  return a * degree;\n}\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.identity = identity;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.str = str;\nexports.frob = frob;\nexports.LDU = LDU;\nexports.add = add;\nexports.subtract = subtract;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.sub = exports.mul = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 2x2 Matrix\r\n * @module mat2\r\n */\n\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @returns {mat2} a new 2x2 matrix\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat2} a matrix to clone\r\n * @returns {mat2} a new 2x2 matrix\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Create a new mat2 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out A new 2x2 matrix\r\n */\n\n\nfunction fromValues(m00, m01, m10, m11) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Set the components of a mat2 to the given values\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out\r\n */\n\n\nfunction set(out, m00, m01, m10, m11) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m10;\n  out[3] = m11;\n  return out;\n}\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache\n  // some values\n  if (out === a) {\n    var a1 = a[1];\n    out[1] = a[2];\n    out[2] = a1;\n  } else {\n    out[0] = a[0];\n    out[1] = a[2];\n    out[2] = a[1];\n    out[3] = a[3];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3]; // Calculate the determinant\n\n  var det = a0 * a3 - a2 * a1;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = a3 * det;\n  out[1] = -a1 * det;\n  out[2] = -a2 * det;\n  out[3] = a0 * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {mat2} out\r\n */\n\n\nfunction adjoint(out, a) {\n  // Caching this value is nessecary if out == a\n  var a0 = a[0];\n  out[0] = a[3];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a0;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @param {ReadonlyMat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\n\nfunction determinant(a) {\n  return a[0] * a[3] - a[2] * a[1];\n}\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  return out;\n}\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\n\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  return out;\n}\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the matrix to rotate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\n\n\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\n\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.scale(dest, dest, vec);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {ReadonlyVec2} v Scaling vector\r\n * @returns {mat2} out\r\n */\n\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2\r\n *\r\n * @param {ReadonlyMat2} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\n\nfunction str(a) {\n  return \"mat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3]);\n}\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n * @param {ReadonlyMat2} L the lower triangular matrix\r\n * @param {ReadonlyMat2} D the diagonal matrix\r\n * @param {ReadonlyMat2} U the upper triangular matrix\r\n * @param {ReadonlyMat2} a the input matrix to factorize\r\n */\n\n\nfunction LDU(L, D, U, a) {\n  L[2] = a[2] / a[0];\n  U[0] = a[0];\n  U[1] = a[1];\n  U[3] = a[3] - L[2] * U[1];\n  return [L, D, U];\n}\n/**\r\n * Adds two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @returns {mat2} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat2} a The first matrix.\r\n * @param {ReadonlyMat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat2} a The first matrix.\r\n * @param {ReadonlyMat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {ReadonlyMat2} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2} out\r\n */\n\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2} out the receiving vector\r\n * @param {ReadonlyMat2} a the first operand\r\n * @param {ReadonlyMat2} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2} out\r\n */\n\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Alias for {@link mat2.multiply}\r\n * @function\r\n */\n\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat2.subtract}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar sub = subtract;\nexports.sub = sub;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.identity = identity;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.invert = invert;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.translate = translate;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.fromTranslation = fromTranslation;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.sub = exports.mul = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 2x3 Matrix\r\n * @module mat2d\r\n * @description\r\n * A mat2d contains six elements defined as:\r\n * <pre>\r\n * [a, b,\r\n *  c, d,\r\n *  tx, ty]\r\n * </pre>\r\n * This is a short form for the 3x3 matrix:\r\n * <pre>\r\n * [a, b, 0,\r\n *  c, d, 0,\r\n *  tx, ty, 1]\r\n * </pre>\r\n * The last column is ignored so the array is shorter and operations are faster.\r\n */\n\n/**\r\n * Creates a new identity mat2d\r\n *\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(6);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[4] = 0;\n    out[5] = 0;\n  }\n\n  out[0] = 1;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat2d initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat2d} a matrix to clone\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Copy the values from one mat2d to another\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  return out;\n}\n/**\r\n * Set a mat2d to the identity matrix\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @returns {mat2d} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Create a new mat2d with the given values\r\n *\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} A new mat2d\r\n */\n\n\nfunction fromValues(a, b, c, d, tx, ty) {\n  var out = new glMatrix.ARRAY_TYPE(6);\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Set the components of a mat2d to the given values\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} out\r\n */\n\n\nfunction set(out, a, b, c, d, tx, ty) {\n  out[0] = a;\n  out[1] = b;\n  out[2] = c;\n  out[3] = d;\n  out[4] = tx;\n  out[5] = ty;\n  return out;\n}\n/**\r\n * Inverts a mat2d\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0],\n      ab = a[1],\n      ac = a[2],\n      ad = a[3];\n  var atx = a[4],\n      aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat2d\r\n *\r\n * @param {ReadonlyMat2d} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\n\nfunction determinant(a) {\n  return a[0] * a[3] - a[1] * a[2];\n}\n/**\r\n * Multiplies two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  out[0] = a0 * b0 + a2 * b1;\n  out[1] = a1 * b0 + a3 * b1;\n  out[2] = a0 * b2 + a2 * b3;\n  out[3] = a1 * b2 + a3 * b3;\n  out[4] = a0 * b4 + a2 * b5 + a4;\n  out[5] = a1 * b4 + a3 * b5 + a5;\n  return out;\n}\n/**\r\n * Rotates a mat2d by the given angle\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\n\nfunction rotate(out, a, rad) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  out[0] = a0 * c + a2 * s;\n  out[1] = a1 * c + a3 * s;\n  out[2] = a0 * -s + a2 * c;\n  out[3] = a1 * -s + a3 * c;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Scales the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to translate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat2d} out\r\n **/\n\n\nfunction scale(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0 * v0;\n  out[1] = a1 * v0;\n  out[2] = a2 * v1;\n  out[3] = a3 * v1;\n  out[4] = a4;\n  out[5] = a5;\n  return out;\n}\n/**\r\n * Translates the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to translate\r\n * @param {ReadonlyVec2} v the vec2 to translate the matrix by\r\n * @returns {mat2d} out\r\n **/\n\n\nfunction translate(out, a, v) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var v0 = v[0],\n      v1 = v[1];\n  out[0] = a0;\n  out[1] = a1;\n  out[2] = a2;\n  out[3] = a3;\n  out[4] = a0 * v0 + a2 * v1 + a4;\n  out[5] = a1 * v0 + a3 * v1 + a5;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\n\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = -s;\n  out[3] = c;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.scale(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {ReadonlyVec2} v Scaling vector\r\n * @returns {mat2d} out\r\n */\n\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = v[1];\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.translate(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {ReadonlyVec2} v Translation vector\r\n * @returns {mat2d} out\r\n */\n\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = v[0];\n  out[5] = v[1];\n  return out;\n}\n/**\r\n * Returns a string representation of a mat2d\r\n *\r\n * @param {ReadonlyMat2d} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\n\nfunction str(a) {\n  return \"mat2d(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat2d\r\n *\r\n * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);\n}\n/**\r\n * Adds two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2d} out\r\n */\n\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  return out;\n}\n/**\r\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2d} out the receiving vector\r\n * @param {ReadonlyMat2d} a the first operand\r\n * @param {ReadonlyMat2d} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2d} out\r\n */\n\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat2d} a The first matrix.\r\n * @param {ReadonlyMat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat2d} a The first matrix.\r\n * @param {ReadonlyMat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\n}\n/**\r\n * Alias for {@link mat2d.multiply}\r\n * @function\r\n */\n\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat2d.subtract}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar sub = subtract;\nexports.sub = sub;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.fromMat4 = fromMat4;\nexports.clone = clone;\nexports.copy = copy;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.identity = identity;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.fromTranslation = fromTranslation;\nexports.fromRotation = fromRotation;\nexports.fromScaling = fromScaling;\nexports.fromMat2d = fromMat2d;\nexports.fromQuat = fromQuat;\nexports.normalFromMat4 = normalFromMat4;\nexports.projection = projection;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.sub = exports.mul = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\n\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the upper-left 3x3 values into the given mat3.\r\n *\r\n * @param {mat3} out the receiving 3x3 matrix\r\n * @param {ReadonlyMat4} a   the source 4x4 matrix\r\n * @returns {mat3} out\r\n */\n\n\nfunction fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n/**\r\n * Creates a new mat3 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat3} a matrix to clone\r\n * @returns {mat3} a new 3x3 matrix\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Copy the values from one mat3 to another\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Create a new mat3 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} A new mat3\r\n */\n\n\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set the components of a mat3 to the given values\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} out\r\n */\n\n\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n/**\r\n * Set a mat3 to the identity matrix\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @returns {mat3} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant\n\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {mat3} out\r\n */\n\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {ReadonlyMat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to translate\r\n * @param {ReadonlyVec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\n\n\nfunction translate(out, a, v) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      x = v[0],\n      y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\n\nfunction rotate(out, a, rad) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a10 = a[3],\n      a11 = a[4],\n      a12 = a[5],\n      a20 = a[6],\n      a21 = a[7],\n      a22 = a[8],\n      s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to rotate\r\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\n\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.translate(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyVec2} v Translation vector\r\n * @returns {mat3} out\r\n */\n\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.rotate(dest, dest, rad);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\n\n\nfunction fromRotation(out, rad) {\n  var s = Math.sin(rad),\n      c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.scale(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyVec2} v Scaling vector\r\n * @returns {mat3} out\r\n */\n\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Copies the values from a mat2d into a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat2d} a the matrix to copy\r\n * @returns {mat3} out\r\n **/\n\n\nfunction fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Calculates a 3x3 matrix from the given quaternion\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat3} out\r\n */\n\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n/**\r\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\r\n *\r\n * @returns {mat3} out\r\n */\n\n\nfunction normalFromMat4(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n/**\r\n * Generates a 2D projection matrix with the given bounds\r\n *\r\n * @param {mat3} out mat3 frustum matrix will be written into\r\n * @param {number} width Width of your gl context\r\n * @param {number} height Height of gl context\r\n * @returns {mat3} out\r\n */\n\n\nfunction projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat3\r\n *\r\n * @param {ReadonlyMat3} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\n\nfunction str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat3\r\n *\r\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);\n}\n/**\r\n * Adds two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @returns {mat3} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {ReadonlyMat3} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat3} out\r\n */\n\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n/**\r\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat3} out the receiving vector\r\n * @param {ReadonlyMat3} a the first operand\r\n * @param {ReadonlyMat3} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat3} out\r\n */\n\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat3} a The first matrix.\r\n * @param {ReadonlyMat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat3} a The first matrix.\r\n * @param {ReadonlyMat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7],\n      a8 = a[8];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7],\n      b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n/**\r\n * Alias for {@link mat3.multiply}\r\n * @function\r\n */\n\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat3.subtract}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar sub = subtract;\nexports.sub = sub;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.fromValues = fromValues;\nexports.set = set;\nexports.identity = identity;\nexports.transpose = transpose;\nexports.invert = invert;\nexports.adjoint = adjoint;\nexports.determinant = determinant;\nexports.multiply = multiply;\nexports.translate = translate;\nexports.scale = scale;\nexports.rotate = rotate;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.fromTranslation = fromTranslation;\nexports.fromScaling = fromScaling;\nexports.fromRotation = fromRotation;\nexports.fromXRotation = fromXRotation;\nexports.fromYRotation = fromYRotation;\nexports.fromZRotation = fromZRotation;\nexports.fromRotationTranslation = fromRotationTranslation;\nexports.fromQuat2 = fromQuat2;\nexports.getTranslation = getTranslation;\nexports.getScaling = getScaling;\nexports.getRotation = getRotation;\nexports.fromRotationTranslationScale = fromRotationTranslationScale;\nexports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;\nexports.fromQuat = fromQuat;\nexports.frustum = frustum;\nexports.perspective = perspective;\nexports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;\nexports.ortho = ortho;\nexports.lookAt = lookAt;\nexports.targetTo = targetTo;\nexports.str = str;\nexports.frob = frob;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiplyScalar = multiplyScalar;\nexports.multiplyScalarAndAdd = multiplyScalarAndAdd;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.sub = exports.mul = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\n\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(16);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n  }\n\n  out[0] = 1;\n  out[5] = 1;\n  out[10] = 1;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {ReadonlyMat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  out[9] = a[9];\n  out[10] = a[10];\n  out[11] = a[11];\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\n\n\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  var out = new glMatrix.ARRAY_TYPE(16);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\n\n\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m03;\n  out[4] = m10;\n  out[5] = m11;\n  out[6] = m12;\n  out[7] = m13;\n  out[8] = m20;\n  out[9] = m21;\n  out[10] = m22;\n  out[11] = m23;\n  out[12] = m30;\n  out[13] = m31;\n  out[14] = m32;\n  out[15] = m33;\n  return out;\n}\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\n\nfunction transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    var a12 = a[6],\n        a13 = a[7];\n    var a23 = a[11];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a01;\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a02;\n    out[9] = a12;\n    out[11] = a[14];\n    out[12] = a03;\n    out[13] = a13;\n    out[14] = a23;\n  } else {\n    out[0] = a[0];\n    out[1] = a[4];\n    out[2] = a[8];\n    out[3] = a[12];\n    out[4] = a[1];\n    out[5] = a[5];\n    out[6] = a[9];\n    out[7] = a[13];\n    out[8] = a[2];\n    out[9] = a[6];\n    out[10] = a[10];\n    out[11] = a[14];\n    out[12] = a[3];\n    out[13] = a[7];\n    out[14] = a[11];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\n\nfunction invert(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n  return out;\n}\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {mat4} out\r\n */\n\n\nfunction adjoint(out, a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\n  return out;\n}\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\n\n\nfunction determinant(a) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2],\n      a03 = a[3];\n  var a10 = a[4],\n      a11 = a[5],\n      a12 = a[6],\n      a13 = a[7];\n  var a20 = a[8],\n      a21 = a[9],\n      a22 = a[10],\n      a23 = a[11];\n  var a30 = a[12],\n      a31 = a[13],\n      a32 = a[14],\n      a33 = a[15]; // Cache only the current line of the second matrix\n\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[4];\n  b1 = b[5];\n  b2 = b[6];\n  b3 = b[7];\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[8];\n  b1 = b[9];\n  b2 = b[10];\n  b3 = b[11];\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  b0 = b[12];\n  b1 = b[13];\n  b2 = b[14];\n  b3 = b[15];\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n  return out;\n}\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\n\n\nfunction translate(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n\n  if (a === out) {\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n  } else {\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a03;\n    out[4] = a10;\n    out[5] = a11;\n    out[6] = a12;\n    out[7] = a13;\n    out[8] = a20;\n    out[9] = a21;\n    out[10] = a22;\n    out[11] = a23;\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\n  }\n\n  return out;\n}\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {ReadonlyVec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\n\n\nfunction scale(out, a, v) {\n  var x = v[0],\n      y = v[1],\n      z = v[2];\n  out[0] = a[0] * x;\n  out[1] = a[1] * x;\n  out[2] = a[2] * x;\n  out[3] = a[3] * x;\n  out[4] = a[4] * y;\n  out[5] = a[5] * y;\n  out[6] = a[6] * y;\n  out[7] = a[7] * y;\n  out[8] = a[8] * z;\n  out[9] = a[9] * z;\n  out[10] = a[10] * z;\n  out[11] = a[11] * z;\n  out[12] = a[12];\n  out[13] = a[13];\n  out[14] = a[14];\n  out[15] = a[15];\n  return out;\n}\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\n\nfunction rotate(out, a, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n  var a00, a01, a02, a03;\n  var a10, a11, a12, a13;\n  var a20, a21, a22, a23;\n  var b00, b01, b02;\n  var b10, b11, b12;\n  var b20, b21, b22;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c;\n  a00 = a[0];\n  a01 = a[1];\n  a02 = a[2];\n  a03 = a[3];\n  a10 = a[4];\n  a11 = a[5];\n  a12 = a[6];\n  a13 = a[7];\n  a20 = a[8];\n  a21 = a[9];\n  a22 = a[10];\n  a23 = a[11]; // Construct the elements of the rotation matrix\n\n  b00 = x * x * t + c;\n  b01 = y * x * t + z * s;\n  b02 = z * x * t - y * s;\n  b10 = x * y * t - z * s;\n  b11 = y * y * t + c;\n  b12 = z * y * t + x * s;\n  b20 = x * z * t + y * s;\n  b21 = y * z * t - x * s;\n  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  }\n\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\n\nfunction rotateX(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[4] = a10 * c + a20 * s;\n  out[5] = a11 * c + a21 * s;\n  out[6] = a12 * c + a22 * s;\n  out[7] = a13 * c + a23 * s;\n  out[8] = a20 * c - a10 * s;\n  out[9] = a21 * c - a11 * s;\n  out[10] = a22 * c - a12 * s;\n  out[11] = a23 * c - a13 * s;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\n\nfunction rotateY(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a20 = a[8];\n  var a21 = a[9];\n  var a22 = a[10];\n  var a23 = a[11];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged rows\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c - a20 * s;\n  out[1] = a01 * c - a21 * s;\n  out[2] = a02 * c - a22 * s;\n  out[3] = a03 * c - a23 * s;\n  out[8] = a00 * s + a20 * c;\n  out[9] = a01 * s + a21 * c;\n  out[10] = a02 * s + a22 * c;\n  out[11] = a03 * s + a23 * c;\n  return out;\n}\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\n\nfunction rotateZ(out, a, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad);\n  var a00 = a[0];\n  var a01 = a[1];\n  var a02 = a[2];\n  var a03 = a[3];\n  var a10 = a[4];\n  var a11 = a[5];\n  var a12 = a[6];\n  var a13 = a[7];\n\n  if (a !== out) {\n    // If the source and destination differ, copy the unchanged last row\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n  } // Perform axis-specific matrix multiplication\n\n\n  out[0] = a00 * c + a10 * s;\n  out[1] = a01 * c + a11 * s;\n  out[2] = a02 * c + a12 * s;\n  out[3] = a03 * c + a13 * s;\n  out[4] = a10 * c - a00 * s;\n  out[5] = a11 * c - a01 * s;\n  out[6] = a12 * c - a02 * s;\n  out[7] = a13 * c - a03 * s;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyVec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = v[1];\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = v[2];\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromRotation(out, rad, axis) {\n  var x = axis[0],\n      y = axis[1],\n      z = axis[2];\n  var len = Math.hypot(x, y, z);\n  var s, c, t;\n\n  if (len < glMatrix.EPSILON) {\n    return null;\n  }\n\n  len = 1 / len;\n  x *= len;\n  y *= len;\n  z *= len;\n  s = Math.sin(rad);\n  c = Math.cos(rad);\n  t = 1 - c; // Perform rotation-specific matrix multiplication\n\n  out[0] = x * x * t + c;\n  out[1] = y * x * t + z * s;\n  out[2] = z * x * t - y * s;\n  out[3] = 0;\n  out[4] = x * y * t - z * s;\n  out[5] = y * y * t + c;\n  out[6] = z * y * t + x * s;\n  out[7] = 0;\n  out[8] = x * z * t + y * s;\n  out[9] = y * z * t - x * s;\n  out[10] = z * z * t + c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromXRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = c;\n  out[6] = s;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = -s;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromYRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = 0;\n  out[2] = -s;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = 1;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = s;\n  out[9] = 0;\n  out[10] = c;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromZRotation(out, rad) {\n  var s = Math.sin(rad);\n  var c = Math.cos(rad); // Perform axis-specific matrix multiplication\n\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -s;\n  out[5] = c;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 1;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromRotationTranslation(out, q, v) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - (yy + zz);\n  out[1] = xy + wz;\n  out[2] = xz - wy;\n  out[3] = 0;\n  out[4] = xy - wz;\n  out[5] = 1 - (xx + zz);\n  out[6] = yz + wx;\n  out[7] = 0;\n  out[8] = xz + wy;\n  out[9] = yz - wx;\n  out[10] = 1 - (xx + yy);\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {ReadonlyQuat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\n\n\nfunction fromQuat2(out, a) {\n  var translation = new glMatrix.ARRAY_TYPE(3);\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense\n\n  if (magnitude > 0) {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\n  } else {\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  }\n\n  fromRotationTranslation(out, a, translation);\n  return out;\n}\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\n\nfunction getTranslation(out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n  return out;\n}\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\n\n\nfunction getScaling(out, mat) {\n  var m11 = mat[0];\n  var m12 = mat[1];\n  var m13 = mat[2];\n  var m21 = mat[4];\n  var m22 = mat[5];\n  var m23 = mat[6];\n  var m31 = mat[8];\n  var m32 = mat[9];\n  var m33 = mat[10];\n  out[0] = Math.hypot(m11, m12, m13);\n  out[1] = Math.hypot(m21, m22, m23);\n  out[2] = Math.hypot(m31, m32, m33);\n  return out;\n}\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {ReadonlyMat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\n\n\nfunction getRotation(out, mat) {\n  var scaling = new glMatrix.ARRAY_TYPE(3);\n  getScaling(scaling, mat);\n  var is1 = 1 / scaling[0];\n  var is2 = 1 / scaling[1];\n  var is3 = 1 / scaling[2];\n  var sm11 = mat[0] * is1;\n  var sm12 = mat[1] * is2;\n  var sm13 = mat[2] * is3;\n  var sm21 = mat[4] * is1;\n  var sm22 = mat[5] * is2;\n  var sm23 = mat[6] * is3;\n  var sm31 = mat[8] * is1;\n  var sm32 = mat[9] * is2;\n  var sm33 = mat[10] * is3;\n  var trace = sm11 + sm22 + sm33;\n  var S = 0;\n\n  if (trace > 0) {\n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (sm23 - sm32) / S;\n    out[1] = (sm31 - sm13) / S;\n    out[2] = (sm12 - sm21) / S;\n  } else if (sm11 > sm22 && sm11 > sm33) {\n    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n    out[3] = (sm23 - sm32) / S;\n    out[0] = 0.25 * S;\n    out[1] = (sm12 + sm21) / S;\n    out[2] = (sm31 + sm13) / S;\n  } else if (sm22 > sm33) {\n    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n    out[3] = (sm31 - sm13) / S;\n    out[0] = (sm12 + sm21) / S;\n    out[1] = 0.25 * S;\n    out[2] = (sm23 + sm32) / S;\n  } else {\n    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n    out[3] = (sm12 - sm21) / S;\n    out[0] = (sm31 + sm13) / S;\n    out[1] = (sm23 + sm32) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromRotationTranslationScale(out, q, v, s) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0];\n  out[13] = v[1];\n  out[14] = v[2];\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {ReadonlyVec3} v Translation vector\r\n * @param {ReadonlyVec3} s Scaling vector\r\n * @param {ReadonlyVec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var xy = x * y2;\n  var xz = x * z2;\n  var yy = y * y2;\n  var yz = y * z2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  var sx = s[0];\n  var sy = s[1];\n  var sz = s[2];\n  var ox = o[0];\n  var oy = o[1];\n  var oz = o[2];\n  var out0 = (1 - (yy + zz)) * sx;\n  var out1 = (xy + wz) * sx;\n  var out2 = (xz - wy) * sx;\n  var out4 = (xy - wz) * sy;\n  var out5 = (1 - (xx + zz)) * sy;\n  var out6 = (yz + wx) * sy;\n  var out8 = (xz + wy) * sz;\n  var out9 = (yz - wx) * sz;\n  var out10 = (1 - (xx + yy)) * sz;\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = 0;\n  out[4] = out4;\n  out[5] = out5;\n  out[6] = out6;\n  out[7] = 0;\n  out[8] = out8;\n  out[9] = out9;\n  out[10] = out10;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {ReadonlyQuat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\n\n\nfunction fromQuat(out, q) {\n  var x = q[0],\n      y = q[1],\n      z = q[2],\n      w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[1] = yx + wz;\n  out[2] = zx - wy;\n  out[3] = 0;\n  out[4] = yx - wz;\n  out[5] = 1 - xx - zz;\n  out[6] = zy + wx;\n  out[7] = 0;\n  out[8] = zx + wy;\n  out[9] = zy - wx;\n  out[10] = 1 - xx - yy;\n  out[11] = 0;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = 0;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\n\nfunction frustum(out, left, right, bottom, top, near, far) {\n  var rl = 1 / (right - left);\n  var tb = 1 / (top - bottom);\n  var nf = 1 / (near - far);\n  out[0] = near * 2 * rl;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = near * 2 * tb;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = (right + left) * rl;\n  out[9] = (top + bottom) * tb;\n  out[10] = (far + near) * nf;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[14] = far * near * 2 * nf;\n  out[15] = 0;\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\n\n\nfunction perspective(out, fovy, aspect, near, far) {\n  var f = 1.0 / Math.tan(fovy / 2),\n      nf;\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n\n  if (far != null && far !== Infinity) {\n    nf = 1 / (near - far);\n    out[10] = (far + near) * nf;\n    out[14] = 2 * far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -2 * near;\n  }\n\n  return out;\n}\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\n\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n  var xScale = 2.0 / (leftTan + rightTan);\n  var yScale = 2.0 / (upTan + downTan);\n  out[0] = xScale;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  out[4] = 0.0;\n  out[5] = yScale;\n  out[6] = 0.0;\n  out[7] = 0.0;\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\n  out[9] = (upTan - downTan) * yScale * 0.5;\n  out[10] = far / (near - far);\n  out[11] = -1.0;\n  out[12] = 0.0;\n  out[13] = 0.0;\n  out[14] = far * near / (near - far);\n  out[15] = 0.0;\n  return out;\n}\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\n\n\nfunction ortho(out, left, right, bottom, top, near, far) {\n  var lr = 1 / (left - right);\n  var bt = 1 / (bottom - top);\n  var nf = 1 / (near - far);\n  out[0] = -2 * lr;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = -2 * bt;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[10] = 2 * nf;\n  out[11] = 0;\n  out[12] = (left + right) * lr;\n  out[13] = (top + bottom) * bt;\n  out[14] = (far + near) * nf;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\n\nfunction lookAt(out, eye, center, up) {\n  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;\n  var eyex = eye[0];\n  var eyey = eye[1];\n  var eyez = eye[2];\n  var upx = up[0];\n  var upy = up[1];\n  var upz = up[2];\n  var centerx = center[0];\n  var centery = center[1];\n  var centerz = center[2];\n\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n    return identity(out);\n  }\n\n  z0 = eyex - centerx;\n  z1 = eyey - centery;\n  z2 = eyez - centerz;\n  len = 1 / Math.hypot(z0, z1, z2);\n  z0 *= len;\n  z1 *= len;\n  z2 *= len;\n  x0 = upy * z2 - upz * z1;\n  x1 = upz * z0 - upx * z2;\n  x2 = upx * z1 - upy * z0;\n  len = Math.hypot(x0, x1, x2);\n\n  if (!len) {\n    x0 = 0;\n    x1 = 0;\n    x2 = 0;\n  } else {\n    len = 1 / len;\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  y0 = z1 * x2 - z2 * x1;\n  y1 = z2 * x0 - z0 * x2;\n  y2 = z0 * x1 - z1 * x0;\n  len = Math.hypot(y0, y1, y2);\n\n  if (!len) {\n    y0 = 0;\n    y1 = 0;\n    y2 = 0;\n  } else {\n    len = 1 / len;\n    y0 *= len;\n    y1 *= len;\n    y2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = y0;\n  out[2] = z0;\n  out[3] = 0;\n  out[4] = x1;\n  out[5] = y1;\n  out[6] = z1;\n  out[7] = 0;\n  out[8] = x2;\n  out[9] = y2;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {ReadonlyVec3} eye Position of the viewer\r\n * @param {ReadonlyVec3} center Point the viewer is looking at\r\n * @param {ReadonlyVec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\n\n\nfunction targetTo(out, eye, target, up) {\n  var eyex = eye[0],\n      eyey = eye[1],\n      eyez = eye[2],\n      upx = up[0],\n      upy = up[1],\n      upz = up[2];\n  var z0 = eyex - target[0],\n      z1 = eyey - target[1],\n      z2 = eyez - target[2];\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n  }\n\n  var x0 = upy * z2 - upz * z1,\n      x1 = upz * z0 - upx * z2,\n      x2 = upx * z1 - upy * z0;\n  len = x0 * x0 + x1 * x1 + x2 * x2;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n  }\n\n  out[0] = x0;\n  out[1] = x1;\n  out[2] = x2;\n  out[3] = 0;\n  out[4] = z1 * x2 - z2 * x1;\n  out[5] = z2 * x0 - z0 * x2;\n  out[6] = z0 * x1 - z1 * x0;\n  out[7] = 0;\n  out[8] = z0;\n  out[9] = z1;\n  out[10] = z2;\n  out[11] = 0;\n  out[12] = eyex;\n  out[13] = eyey;\n  out[14] = eyez;\n  out[15] = 1;\n  return out;\n}\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {ReadonlyMat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\n\n\nfunction str(a) {\n  return \"mat4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \", \" + a[9] + \", \" + a[10] + \", \" + a[11] + \", \" + a[12] + \", \" + a[13] + \", \" + a[14] + \", \" + a[15] + \")\";\n}\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\n\n\nfunction frob(a) {\n  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);\n}\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  out[9] = a[9] + b[9];\n  out[10] = a[10] + b[10];\n  out[11] = a[11] + b[11];\n  out[12] = a[12] + b[12];\n  out[13] = a[13] + b[13];\n  out[14] = a[14] + b[14];\n  out[15] = a[15] + b[15];\n  return out;\n}\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @returns {mat4} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  out[9] = a[9] - b[9];\n  out[10] = a[10] - b[10];\n  out[11] = a[11] - b[11];\n  out[12] = a[12] - b[12];\n  out[13] = a[13] - b[13];\n  out[14] = a[14] - b[14];\n  out[15] = a[15] - b[15];\n  return out;\n}\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {ReadonlyMat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\n\n\nfunction multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  out[9] = a[9] * b;\n  out[10] = a[10] * b;\n  out[11] = a[11] * b;\n  out[12] = a[12] * b;\n  out[13] = a[13] * b;\n  out[14] = a[14] * b;\n  out[15] = a[15] * b;\n  return out;\n}\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {ReadonlyMat4} a the first operand\r\n * @param {ReadonlyMat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\n\n\nfunction multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  out[9] = a[9] + b[9] * scale;\n  out[10] = a[10] + b[10] * scale;\n  out[11] = a[11] + b[11] * scale;\n  out[12] = a[12] + b[12] * scale;\n  out[13] = a[13] + b[13] * scale;\n  out[14] = a[14] + b[14] * scale;\n  out[15] = a[15] + b[15] * scale;\n  return out;\n}\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n}\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyMat4} a The first matrix.\r\n * @param {ReadonlyMat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var a8 = a[8],\n      a9 = a[9],\n      a10 = a[10],\n      a11 = a[11];\n  var a12 = a[12],\n      a13 = a[13],\n      a14 = a[14],\n      a15 = a[15];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  var b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  var b8 = b[8],\n      b9 = b[9],\n      b10 = b[10],\n      b11 = b[11];\n  var b12 = b[12],\n      b13 = b[13],\n      b14 = b[14],\n      b15 = b[15];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n}\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\n\n\nvar mul = multiply;\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar sub = subtract;\nexports.sub = sub;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.identity = identity;\nexports.setAxisAngle = setAxisAngle;\nexports.getAxisAngle = getAxisAngle;\nexports.getAngle = getAngle;\nexports.multiply = multiply;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.calculateW = calculateW;\nexports.exp = exp;\nexports.ln = ln;\nexports.pow = pow;\nexports.slerp = slerp;\nexports.random = random;\nexports.invert = invert;\nexports.conjugate = conjugate;\nexports.fromMat3 = fromMat3;\nexports.fromEuler = fromEuler;\nexports.str = str;\nexports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nvar mat3 = _interopRequireWildcard(require(\"./mat3.js\"));\n\nvar vec3 = _interopRequireWildcard(require(\"./vec3.js\"));\n\nvar vec4 = _interopRequireWildcard(require(\"./vec4.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * Quaternion\r\n * @module quat\r\n */\n\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyVec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\n\n\nfunction setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\n\n\nfunction getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n\n  return rad;\n}\n/**\r\n * Gets the angular distance between two unit quaternions\r\n *\r\n * @param  {ReadonlyQuat} a     Origin unit quaternion\r\n * @param  {ReadonlyQuat} b     Destination unit quaternion\r\n * @return {Number}     Angle, in radians, between the two quaternions\r\n */\n\n\nfunction getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {quat} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\n\nfunction rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\n\nfunction rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var by = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {ReadonlyQuat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\n\n\nfunction rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bz = Math.sin(rad),\n      bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\n\n\nfunction calculateW(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n/**\r\n * Calculate the exponential of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate the exponential of\r\n * @returns {quat} out\r\n */\n\n\nfunction exp(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n/**\r\n * Calculate the natural logarithm of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate the exponential of\r\n * @returns {quat} out\r\n */\n\n\nfunction ln(out, a) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n/**\r\n * Calculate the scalar power of a unit quaternion.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate the exponential of\r\n * @param {Number} b amount to scale the quaternion by\r\n * @returns {quat} out\r\n */\n\n\nfunction pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\n\nfunction slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2],\n      bw = b[3];\n  var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  } // calculate coefficients\n\n\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  } // calculate final values\n\n\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n/**\r\n * Generates a random unit quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\n\n\nfunction random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\n\n\nfunction invert(out, a) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\n\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyMat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\n\n\nfunction fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n\n  return out;\n}\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\n\n\nfunction fromEuler(out, x, y, z) {\n  var halfToRad = 0.5 * Math.PI / 180.0;\n  x *= halfToRad;\n  y *= halfToRad;\n  z *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  out[0] = sx * cy * cz - cx * sy * sz;\n  out[1] = cx * sy * cz + sx * cy * sz;\n  out[2] = cx * cy * sz - sx * sy * cz;\n  out[3] = cx * cy * cz + sx * sy * sz;\n  return out;\n}\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {ReadonlyQuat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\n\nfunction str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {ReadonlyQuat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\n\nvar clone = vec4.clone;\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\n\nexports.clone = clone;\nvar fromValues = vec4.fromValues;\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexports.fromValues = fromValues;\nvar copy = vec4.copy;\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexports.copy = copy;\nvar set = vec4.set;\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexports.set = set;\nvar add = vec4.add;\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\n\nexports.add = add;\nvar mul = multiply;\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {ReadonlyQuat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexports.mul = mul;\nvar scale = vec4.scale;\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\nexports.scale = scale;\nvar dot = vec4.dot;\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexports.dot = dot;\nvar lerp = vec4.lerp;\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {ReadonlyQuat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexports.lerp = lerp;\nvar length = vec4.length;\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\n\nexports.length = length;\nvar len = length;\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {ReadonlyQuat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexports.len = len;\nvar squaredLength = vec4.squaredLength;\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\n\nexports.squaredLength = squaredLength;\nvar sqrLen = squaredLength;\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\n\nexports.sqrLen = sqrLen;\nvar normalize = vec4.normalize;\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyQuat} a The first quaternion.\r\n * @param {ReadonlyQuat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexports.normalize = normalize;\nvar exactEquals = vec4.exactEquals;\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyQuat} a The first vector.\r\n * @param {ReadonlyQuat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexports.exactEquals = exactEquals;\nvar equals = vec4.equals;\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {ReadonlyVec3} a the initial vector\r\n * @param {ReadonlyVec3} b the destination vector\r\n * @returns {quat} out\r\n */\n\nexports.equals = equals;\n\nvar rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {ReadonlyQuat} a the first operand\r\n * @param {ReadonlyQuat} b the second operand\r\n * @param {ReadonlyQuat} c the third operand\r\n * @param {ReadonlyQuat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\n\n\nexports.rotationTo = rotationTo;\n\nvar sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\r\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\r\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\n\n\nexports.sqlerp = sqlerp;\n\nvar setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();\n\nexports.setAxes = setAxes;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.length = length;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.hermite = hermite;\nexports.bezier = bezier;\nexports.random = random;\nexports.transformMat4 = transformMat4;\nexports.transformMat3 = transformMat3;\nexports.transformQuat = transformQuat;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.angle = angle;\nexports.zero = zero;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\n\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\n\n\nfunction fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the source vector\r\n * @returns {vec3} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\n\n\nfunction set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\n\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to floor\r\n * @returns {vec3} out\r\n */\n\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to round\r\n * @returns {vec3} out\r\n */\n\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\n\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\n\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {ReadonlyVec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to negate\r\n * @returns {vec3} out\r\n */\n\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to invert\r\n * @returns {vec3} out\r\n */\n\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\n\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\n\nfunction hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the first operand\r\n * @param {ReadonlyVec3} b the second operand\r\n * @param {ReadonlyVec3} c the third operand\r\n * @param {ReadonlyVec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\n\n\nfunction bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\n\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\n\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\n\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec3} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\n\n\nfunction transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\n\nfunction rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\n\nfunction rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {ReadonlyVec3} a The vec3 point to rotate\r\n * @param {ReadonlyVec3} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec3} out\r\n */\n\n\nfunction rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {ReadonlyVec3} a The first operand\r\n * @param {ReadonlyVec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\n\nfunction angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec3 to zero\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @returns {vec3} out\r\n */\n\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\n\nfunction str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec3} a The first vector.\r\n * @param {ReadonlyVec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\n\n\nvar sub = subtract;\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\n\nexports.sub = sub;\nvar mul = multiply;\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar div = divide;\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\n\nexports.div = div;\nvar dist = distance;\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\n\nexports.dist = dist;\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\n\nexports.sqrDist = sqrDist;\nvar len = length;\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\n\nexports.len = len;\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexports.sqrLen = sqrLen;\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();\n\nexports.forEach = forEach;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.length = length;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.random = random;\nexports.transformMat4 = transformMat4;\nexports.transformQuat = transformQuat;\nexports.zero = zero;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\n\nfunction fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\n\nfunction set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\n\nfunction distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\n\nfunction length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {ReadonlyVec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\n\nfunction squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\n\nfunction normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {ReadonlyVec4} result the receiving vector\r\n * @param {ReadonlyVec4} U the first vector\r\n * @param {ReadonlyVec4} V the second vector\r\n * @param {ReadonlyVec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\n\nfunction cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the first operand\r\n * @param {ReadonlyVec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\n\nfunction random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\n\nfunction transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {ReadonlyVec4} a the vector to transform\r\n * @param {ReadonlyQuat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\n\nfunction transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\n\nfunction str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec4} a The first vector.\r\n * @param {ReadonlyVec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\n\nvar sub = subtract;\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nexports.sub = sub;\nvar mul = multiply;\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar div = divide;\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nexports.div = div;\nvar dist = distance;\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nexports.dist = dist;\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nexports.sqrDist = sqrDist;\nvar len = length;\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nexports.len = len;\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexports.sqrLen = sqrLen;\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();\n\nexports.forEach = forEach;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.fromRotationTranslationValues = fromRotationTranslationValues;\nexports.fromRotationTranslation = fromRotationTranslation;\nexports.fromTranslation = fromTranslation;\nexports.fromRotation = fromRotation;\nexports.fromMat4 = fromMat4;\nexports.copy = copy;\nexports.identity = identity;\nexports.set = set;\nexports.getDual = getDual;\nexports.setDual = setDual;\nexports.getTranslation = getTranslation;\nexports.translate = translate;\nexports.rotateX = rotateX;\nexports.rotateY = rotateY;\nexports.rotateZ = rotateZ;\nexports.rotateByQuatAppend = rotateByQuatAppend;\nexports.rotateByQuatPrepend = rotateByQuatPrepend;\nexports.rotateAroundAxis = rotateAroundAxis;\nexports.add = add;\nexports.multiply = multiply;\nexports.scale = scale;\nexports.lerp = lerp;\nexports.invert = invert;\nexports.conjugate = conjugate;\nexports.normalize = normalize;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nvar quat = _interopRequireWildcard(require(\"./quat.js\"));\n\nvar mat4 = _interopRequireWildcard(require(\"./mat4.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * Dual Quaternion<br>\r\n * Format: [real, dual]<br>\r\n * Quaternion format: XYZW<br>\r\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\r\n * @module quat2\r\n */\n\n/**\r\n * Creates a new identity dual quat\r\n *\r\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\r\n */\nfunction create() {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    dq[0] = 0;\n    dq[1] = 0;\n    dq[2] = 0;\n    dq[4] = 0;\n    dq[5] = 0;\n    dq[6] = 0;\n    dq[7] = 0;\n  }\n\n  dq[3] = 1;\n  return dq;\n}\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {ReadonlyQuat2} a dual quaternion to clone\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\n\nfunction clone(a) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = a[0];\n  dq[1] = a[1];\n  dq[2] = a[2];\n  dq[3] = a[3];\n  dq[4] = a[4];\n  dq[5] = a[5];\n  dq[6] = a[6];\n  dq[7] = a[7];\n  return dq;\n}\n/**\r\n * Creates a new dual quat initialized with the given values\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\n\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  dq[4] = x2;\n  dq[5] = y2;\n  dq[6] = z2;\n  dq[7] = w2;\n  return dq;\n}\n/**\r\n * Creates a new dual quat from the given values (quat and translation)\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component (translation)\r\n * @param {Number} y2 Y component (translation)\r\n * @param {Number} z2 Z component (translation)\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\n\n\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\n  var dq = new glMatrix.ARRAY_TYPE(8);\n  dq[0] = x1;\n  dq[1] = y1;\n  dq[2] = z1;\n  dq[3] = w1;\n  var ax = x2 * 0.5,\n      ay = y2 * 0.5,\n      az = z2 * 0.5;\n  dq[4] = ax * w1 + ay * z1 - az * y1;\n  dq[5] = ay * w1 + az * x1 - ax * z1;\n  dq[6] = az * w1 + ax * y1 - ay * x1;\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\n  return dq;\n}\n/**\r\n * Creates a dual quat from a quaternion and a translation\r\n *\r\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\r\n * @param {ReadonlyQuat} q a normalized quaternion\r\n * @param {ReadonlyVec3} t tranlation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\n\nfunction fromRotationTranslation(out, q, t) {\n  var ax = t[0] * 0.5,\n      ay = t[1] * 0.5,\n      az = t[2] * 0.5,\n      bx = q[0],\n      by = q[1],\n      bz = q[2],\n      bw = q[3];\n  out[0] = bx;\n  out[1] = by;\n  out[2] = bz;\n  out[3] = bw;\n  out[4] = ax * bw + ay * bz - az * by;\n  out[5] = ay * bw + az * bx - ax * bz;\n  out[6] = az * bw + ax * by - ay * bx;\n  out[7] = -ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Creates a dual quat from a translation\r\n *\r\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\r\n * @param {ReadonlyVec3} t translation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\n\nfunction fromTranslation(out, t) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = t[0] * 0.5;\n  out[5] = t[1] * 0.5;\n  out[6] = t[2] * 0.5;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a dual quat from a quaternion\r\n *\r\n * @param {ReadonlyQuat2} dual quaternion receiving operation result\r\n * @param {ReadonlyQuat} q the quaternion\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\n\n\nfunction fromRotation(out, q) {\n  out[0] = q[0];\n  out[1] = q[1];\n  out[2] = q[2];\n  out[3] = q[3];\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Creates a new dual quat from a matrix (4x4)\r\n *\r\n * @param {quat2} out the dual quaternion\r\n * @param {ReadonlyMat4} a the matrix\r\n * @returns {quat2} dual quat receiving operation result\r\n * @function\r\n */\n\n\nfunction fromMat4(out, a) {\n  //TODO Optimize this\n  var outer = quat.create();\n  mat4.getRotation(outer, a);\n  var t = new glMatrix.ARRAY_TYPE(3);\n  mat4.getTranslation(t, a);\n  fromRotationTranslation(out, outer, t);\n  return out;\n}\n/**\r\n * Copy the values from one dual quat to another\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the source dual quaternion\r\n * @returns {quat2} out\r\n * @function\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Set a dual quat to the identity dual quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @returns {quat2} out\r\n */\n\n\nfunction identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  return out;\n}\n/**\r\n * Set the components of a dual quat to the given values\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} out\r\n * @function\r\n */\n\n\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\n  out[0] = x1;\n  out[1] = y1;\n  out[2] = z1;\n  out[3] = w1;\n  out[4] = x2;\n  out[5] = y2;\n  out[6] = z2;\n  out[7] = w2;\n  return out;\n}\n/**\r\n * Gets the real part of a dual quat\r\n * @param  {quat} out real part\r\n * @param  {ReadonlyQuat2} a Dual Quaternion\r\n * @return {quat} real part\r\n */\n\n\nvar getReal = quat.copy;\n/**\r\n * Gets the dual part of a dual quat\r\n * @param  {quat} out dual part\r\n * @param  {ReadonlyQuat2} a Dual Quaternion\r\n * @return {quat} dual part\r\n */\n\nexports.getReal = getReal;\n\nfunction getDual(out, a) {\n  out[0] = a[4];\n  out[1] = a[5];\n  out[2] = a[6];\n  out[3] = a[7];\n  return out;\n}\n/**\r\n * Set the real component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {ReadonlyQuat} q a quaternion representing the real part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\n\nvar setReal = quat.copy;\n/**\r\n * Set the dual component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {ReadonlyQuat} q a quaternion representing the dual part\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexports.setReal = setReal;\n\nfunction setDual(out, q) {\n  out[4] = q[0];\n  out[5] = q[1];\n  out[6] = q[2];\n  out[7] = q[3];\n  return out;\n}\n/**\r\n * Gets the translation of a normalized dual quat\r\n * @param  {vec3} out translation\r\n * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed\r\n * @return {vec3} translation\r\n */\n\n\nfunction getTranslation(out, a) {\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3];\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\n  return out;\n}\n/**\r\n * Translates a dual quat by the given vector\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to translate\r\n * @param {ReadonlyVec3} v vector to translate by\r\n * @returns {quat2} out\r\n */\n\n\nfunction translate(out, a, v) {\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3],\n      bx1 = v[0] * 0.5,\n      by1 = v[1] * 0.5,\n      bz1 = v[2] * 0.5,\n      ax2 = a[4],\n      ay2 = a[5],\n      az2 = a[6],\n      aw2 = a[7];\n  out[0] = ax1;\n  out[1] = ay1;\n  out[2] = az1;\n  out[3] = aw1;\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the X axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\n\nfunction rotateX(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateX(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Y axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\n\nfunction rotateY(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateY(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around the Z axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\n\n\nfunction rotateZ(out, a, rad) {\n  var bx = -a[0],\n      by = -a[1],\n      bz = -a[2],\n      bw = a[3],\n      ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7],\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\n  quat.rotateZ(out, a, rad);\n  bx = out[0];\n  by = out[1];\n  bz = out[2];\n  bw = out[3];\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (a * q)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {ReadonlyQuat} q quaternion to rotate by\r\n * @returns {quat2} out\r\n */\n\n\nfunction rotateByQuatAppend(out, a, q) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      ax = a[0],\n      ay = a[1],\n      az = a[2],\n      aw = a[3];\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\n  ax = a[4];\n  ay = a[5];\n  az = a[6];\n  aw = a[7];\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\n  return out;\n}\n/**\r\n * Rotates a dual quat by a given quaternion (q * a)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat} q quaternion to rotate by\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @returns {quat2} out\r\n */\n\n\nfunction rotateByQuatPrepend(out, q, a) {\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3],\n      bx = a[0],\n      by = a[1],\n      bz = a[2],\n      bw = a[3];\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\n  bx = a[4];\n  by = a[5];\n  bz = a[6];\n  bw = a[7];\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\n  return out;\n}\n/**\r\n * Rotates a dual quat around a given axis. Does the normalisation automatically\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the dual quaternion to rotate\r\n * @param {ReadonlyVec3} axis the axis to rotate around\r\n * @param {Number} rad how far the rotation should be\r\n * @returns {quat2} out\r\n */\n\n\nfunction rotateAroundAxis(out, a, axis, rad) {\n  //Special case for rad = 0\n  if (Math.abs(rad) < glMatrix.EPSILON) {\n    return copy(out, a);\n  }\n\n  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  var bx = s * axis[0] / axisLength;\n  var by = s * axis[1] / axisLength;\n  var bz = s * axis[2] / axisLength;\n  var bw = Math.cos(rad);\n  var ax1 = a[0],\n      ay1 = a[1],\n      az1 = a[2],\n      aw1 = a[3];\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\n  var ax = a[4],\n      ay = a[5],\n      az = a[6],\n      aw = a[7];\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n/**\r\n * Adds two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @returns {quat2} out\r\n * @function\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  return out;\n}\n/**\r\n * Multiplies two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @returns {quat2} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  var ax0 = a[0],\n      ay0 = a[1],\n      az0 = a[2],\n      aw0 = a[3],\n      bx1 = b[4],\n      by1 = b[5],\n      bz1 = b[6],\n      bw1 = b[7],\n      ax1 = a[4],\n      ay1 = a[5],\n      az1 = a[6],\n      aw1 = a[7],\n      bx0 = b[0],\n      by0 = b[1],\n      bz0 = b[2],\n      bw0 = b[3];\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\n  return out;\n}\n/**\r\n * Alias for {@link quat2.multiply}\r\n * @function\r\n */\n\n\nvar mul = multiply;\n/**\r\n * Scales a dual quat by a scalar number\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {ReadonlyQuat2} a the dual quat to scale\r\n * @param {Number} b amount to scale the dual quat by\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexports.mul = mul;\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  return out;\n}\n/**\r\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\r\n *\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\n\n\nvar dot = quat.dot;\n/**\r\n * Performs a linear interpolation between two dual quats's\r\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {ReadonlyQuat2} a the first operand\r\n * @param {ReadonlyQuat2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat2} out\r\n */\n\nexports.dot = dot;\n\nfunction lerp(out, a, b, t) {\n  var mt = 1 - t;\n  if (dot(a, b) < 0) t = -t;\n  out[0] = a[0] * mt + b[0] * t;\n  out[1] = a[1] * mt + b[1] * t;\n  out[2] = a[2] * mt + b[2] * t;\n  out[3] = a[3] * mt + b[3] * t;\n  out[4] = a[4] * mt + b[4] * t;\n  out[5] = a[5] * mt + b[5] * t;\n  out[6] = a[6] * mt + b[6] * t;\n  out[7] = a[7] * mt + b[7] * t;\n  return out;\n}\n/**\r\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a dual quat to calculate inverse of\r\n * @returns {quat2} out\r\n */\n\n\nfunction invert(out, a) {\n  var sqlen = squaredLength(a);\n  out[0] = -a[0] / sqlen;\n  out[1] = -a[1] / sqlen;\n  out[2] = -a[2] / sqlen;\n  out[3] = a[3] / sqlen;\n  out[4] = -a[4] / sqlen;\n  out[5] = -a[5] / sqlen;\n  out[6] = -a[6] / sqlen;\n  out[7] = a[7] / sqlen;\n  return out;\n}\n/**\r\n * Calculates the conjugate of a dual quat\r\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {ReadonlyQuat2} a quat to calculate conjugate of\r\n * @returns {quat2} out\r\n */\n\n\nfunction conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  out[4] = -a[4];\n  out[5] = -a[5];\n  out[6] = -a[6];\n  out[7] = a[7];\n  return out;\n}\n/**\r\n * Calculates the length of a dual quat\r\n *\r\n * @param {ReadonlyQuat2} a dual quat to calculate length of\r\n * @returns {Number} length of a\r\n * @function\r\n */\n\n\nvar length = quat.length;\n/**\r\n * Alias for {@link quat2.length}\r\n * @function\r\n */\n\nexports.length = length;\nvar len = length;\n/**\r\n * Calculates the squared length of a dual quat\r\n *\r\n * @param {ReadonlyQuat2} a dual quat to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\n\nexports.len = len;\nvar squaredLength = quat.squaredLength;\n/**\r\n * Alias for {@link quat2.squaredLength}\r\n * @function\r\n */\n\nexports.squaredLength = squaredLength;\nvar sqrLen = squaredLength;\n/**\r\n * Normalize a dual quat\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {ReadonlyQuat2} a dual quaternion to normalize\r\n * @returns {quat2} out\r\n * @function\r\n */\n\nexports.sqrLen = sqrLen;\n\nfunction normalize(out, a) {\n  var magnitude = squaredLength(a);\n\n  if (magnitude > 0) {\n    magnitude = Math.sqrt(magnitude);\n    var a0 = a[0] / magnitude;\n    var a1 = a[1] / magnitude;\n    var a2 = a[2] / magnitude;\n    var a3 = a[3] / magnitude;\n    var b0 = a[4];\n    var b1 = a[5];\n    var b2 = a[6];\n    var b3 = a[7];\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\n  }\n\n  return out;\n}\n/**\r\n * Returns a string representation of a dual quatenion\r\n *\r\n * @param {ReadonlyQuat2} a dual quaternion to represent as a string\r\n * @returns {String} string representation of the dual quat\r\n */\n\n\nfunction str(a) {\n  return \"quat2(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \")\";\n}\n/**\r\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyQuat2} a the first dual quaternion.\r\n * @param {ReadonlyQuat2} b the second dual quaternion.\r\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\n}\n/**\r\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyQuat2} a the first dual quat.\r\n * @param {ReadonlyQuat2} b the second dual quat.\r\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3],\n      a4 = a[4],\n      a5 = a[5],\n      a6 = a[6],\n      a7 = a[7];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3],\n      b4 = b[4],\n      b5 = b[5],\n      b6 = b[6],\n      b7 = b[7];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));\n}","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.create = create;\nexports.clone = clone;\nexports.fromValues = fromValues;\nexports.copy = copy;\nexports.set = set;\nexports.add = add;\nexports.subtract = subtract;\nexports.multiply = multiply;\nexports.divide = divide;\nexports.ceil = ceil;\nexports.floor = floor;\nexports.min = min;\nexports.max = max;\nexports.round = round;\nexports.scale = scale;\nexports.scaleAndAdd = scaleAndAdd;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.length = length;\nexports.squaredLength = squaredLength;\nexports.negate = negate;\nexports.inverse = inverse;\nexports.normalize = normalize;\nexports.dot = dot;\nexports.cross = cross;\nexports.lerp = lerp;\nexports.random = random;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\nexports.transformMat3 = transformMat3;\nexports.transformMat4 = transformMat4;\nexports.rotate = rotate;\nexports.angle = angle;\nexports.zero = zero;\nexports.str = str;\nexports.exactEquals = exactEquals;\nexports.equals = equals;\nexports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;\n\nvar glMatrix = _interopRequireWildcard(require(\"./common.js\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\n\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\nfunction create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {ReadonlyVec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\n\n\nfunction clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\n\n\nfunction fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the source vector\r\n * @returns {vec2} out\r\n */\n\n\nfunction copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\n\n\nfunction set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\n\nfunction add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\n\nfunction subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\n\nfunction multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\n\nfunction divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\n\n\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to floor\r\n * @returns {vec2} out\r\n */\n\n\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\n\nfunction min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec2} out\r\n */\n\n\nfunction max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to round\r\n * @returns {vec2} out\r\n */\n\n\nfunction round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\n\n\nfunction scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\n\n\nfunction scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\n\nfunction distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\n\nfunction squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\n\nfunction length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {ReadonlyVec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\n\nfunction squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to negate\r\n * @returns {vec2} out\r\n */\n\n\nfunction negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to invert\r\n * @returns {vec2} out\r\n */\n\n\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\n\n\nfunction normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\n\nfunction dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @returns {vec3} out\r\n */\n\n\nfunction cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the first operand\r\n * @param {ReadonlyVec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\n\n\nfunction lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\n\n\nfunction random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\n\nfunction transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\n\nfunction transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\n\nfunction transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {ReadonlyVec2} a the vector to transform\r\n * @param {ReadonlyMat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\n\n\nfunction transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {ReadonlyVec2} a The vec2 point to rotate\r\n * @param {ReadonlyVec2} b The origin of the rotation\r\n * @param {Number} rad The angle of rotation in radians\r\n * @returns {vec2} out\r\n */\n\n\nfunction rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {ReadonlyVec2} a The first operand\r\n * @param {ReadonlyVec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\n\n\nfunction angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\r\n * Set the components of a vec2 to zero\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @returns {vec2} out\r\n */\n\n\nfunction zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {ReadonlyVec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\n\nfunction str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\n\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {ReadonlyVec2} a The first vector.\r\n * @param {ReadonlyVec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\n\nfunction equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\n\n\nvar len = length;\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\n\nexports.len = len;\nvar sub = subtract;\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\n\nexports.sub = sub;\nvar mul = multiply;\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\n\nexports.mul = mul;\nvar div = divide;\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\n\nexports.div = div;\nvar dist = distance;\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\n\nexports.dist = dist;\nvar sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\n\nexports.sqrDist = sqrDist;\nvar sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexports.sqrLen = sqrLen;\n\nvar forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();\n\nexports.forEach = forEach;"],"names":["window","name","app","mount","document","body","module","exports","require","Object","defineProperty","value","str","expectsLowerCase","map","create","list","split","i","length","val","toLowerCase","PatchFlagNames","slotFlagsText","GLOBALS_WHITE_LISTED","isGloballyWhitelisted","makeMap","range","source","start","end","lines","count","res","j","line","push","repeat","Math","max","String","lineLength","pad","min","join","specialBooleanAttrs","isSpecialBooleanAttr","isBooleanAttr","unsafeAttrCharRE","attrValidationCache","hasOwnProperty","isUnsafe","test","console","error","propsToAttrMap","acceptCharset","className","htmlFor","httpEquiv","isNoUnitNumericStyleProp","isKnownAttr","isArray","item","normalized","normalizeStyle","isString","parseStringStyle","key","isObject","listDelimiterRE","propertyDelimiterRE","cssText","ret","forEach","tmp","trim","styles","normalizedKey","startsWith","hyphenate","normalizeClass","HTML_TAGS","SVG_TAGS","VOID_TAGS","isHTMLTag","isSVGTag","isVoidTag","escapeRE","string","match","exec","html","escaped","index","lastIndex","charCodeAt","substring","commentStripRE","src","replace","a","b","equal","looseEqual","aValidType","isDate","bValidType","getTime","looseCompareArrays","aKeysCount","keys","bKeysCount","aHasKey","bHasKey","arr","findIndex","toDisplayString","JSON","stringify","replacer","_key","isMap","size","entries","reduce","isSet","values","isPlainObject","babelParserDefaultPlugins","EMPTY_OBJ","EMPTY_ARR","NOOP","NO","onRE","isOn","isModelListener","extend","assign","remove","el","indexOf","splice","prototype","hasOwn","call","Array","toTypeString","Date","isFunction","isSymbol","isPromise","then","catch","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","isReservedProp","cacheStringFunction","fn","cache","hit","camelizeRE","camelize","_","c","toUpperCase","hyphenateRE","capitalize","charAt","toHandlerKey","hasChanged","oldValue","invokeArrayFns","fns","arg","def","obj","configurable","enumerable","toNumber","n","parseFloat","isNaN","_globalThis","getGlobalThis","globalThis","self","global","escapeHtml","escapeHtmlComment","generateCodeFrame","isSSRSafeAttrName","looseIndexOf","stringifyStyle","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","TokenType","constructor","label","conf","keyword","rightAssociative","binop","updateContext","keywords","Map","createKeyword","options","token","set","createBinop","types","num","bigint","decimal","regexp","eof","bracketL","bracketHashL","bracketBarL","bracketR","bracketBarR","braceL","braceBarL","braceHashL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","template","ellipsis","backQuote","dollarBraceL","at","hash","interpreterDirective","eq","incDec","bang","tilde","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","exponent","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","RegExp","isNewLine","code","skipWhiteSpace","isWhitespace","Position","col","column","SourceLocation","filename","identifierName","getLineInfo","input","offset","lineStart","BaseParser","sawUnambiguousESM","ambiguousScriptDifferentAst","hasPlugin","plugins","has","getPluginOption","plugin","get","last","stack","CommentsParser","addComment","comment","loc","state","trailingComments","leadingComments","adjustCommentsAfterTrailingComma","node","elements","takeAllComments","lastElement","commentPreviousNode","newTrailingComments","leadingComment","undefined","processComment","type","commentStack","firstChild","lastChild","lastInStack","pop","properties","arguments","innerComments","firstTrailingCommentIndex","ErrorMessages","freeze","AccessorIsGenerator","ArgumentsInClass","AsyncFunctionInSingleStatementContext","AwaitBindingIdentifier","AwaitBindingIdentifierInStaticBlock","AwaitExpressionFormalParameter","AwaitNotInAsyncContext","AwaitNotInAsyncFunction","BadGetterArity","BadSetterArity","BadSetterRestParameter","ConstructorClassField","ConstructorClassPrivateField","ConstructorIsAccessor","ConstructorIsAsync","ConstructorIsGenerator","DeclarationMissingInitializer","DecoratorBeforeExport","DecoratorConstructor","DecoratorExportClass","DecoratorSemicolon","DecoratorStaticBlock","DeletePrivateField","DestructureNamedImport","DuplicateConstructor","DuplicateDefaultExport","DuplicateExport","DuplicateProto","DuplicateRegExpFlags","ElementAfterRest","EscapedCharNotAnIdentifier","ExportBindingIsString","ExportDefaultFromAsIdentifier","ForInOfLoopInitializer","ForOfLet","GeneratorInSingleStatementContext","IllegalBreakContinue","IllegalLanguageModeDirective","IllegalReturn","ImportBindingIsString","ImportCallArgumentTrailingComma","ImportCallArity","ImportCallNotNewExpression","ImportCallSpreadArgument","ImportMetaOutsideModule","ImportOutsideModule","InvalidBigIntLiteral","InvalidCodePoint","InvalidDecimal","InvalidDigit","InvalidEscapeSequence","InvalidEscapeSequenceTemplate","InvalidEscapedReservedWord","InvalidIdentifier","InvalidLhs","InvalidLhsBinding","InvalidNumber","InvalidOrMissingExponent","InvalidOrUnexpectedToken","InvalidParenthesizedAssignment","InvalidPrivateFieldResolution","InvalidPropertyBindingPattern","InvalidRecordProperty","InvalidRestAssignmentPattern","LabelRedeclaration","LetInLexicalBinding","LineTerminatorBeforeArrow","MalformedRegExpFlags","MissingClassName","MissingEqInAssignment","MissingSemicolon","MissingUnicodeEscape","MixingCoalesceWithLogical","ModuleAttributeDifferentFromType","ModuleAttributeInvalidValue","ModuleAttributesWithDuplicateKeys","ModuleExportNameHasLoneSurrogate","ModuleExportUndefined","MultipleDefaultsInSwitch","NewlineAfterThrow","NoCatchOrFinally","NumberIdentifier","NumericSeparatorInEscapeSequence","ObsoleteAwaitStar","OptionalChainingNoNew","OptionalChainingNoTemplate","ParamDupe","PatternHasAccessor","PatternHasMethod","PipelineBodyNoArrow","PipelineBodySequenceExpression","PipelineHeadSequenceExpression","PipelineTopicUnused","PrimaryTopicNotAllowed","PrimaryTopicRequiresSmartPipeline","PrivateInExpectedIn","PrivateNameRedeclaration","RecordExpressionBarIncorrectEndSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","RecordExpressionHashIncorrectStartSyntaxType","RecordNoProto","RestTrailingComma","SloppyFunction","StaticPrototype","StrictDelete","StrictEvalArguments","StrictEvalArgumentsBinding","StrictFunction","StrictNumericEscape","StrictOctalLiteral","StrictWith","SuperNotAllowed","SuperPrivateField","TrailingDecorator","TupleExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","UnexpectedArgumentPlaceholder","UnexpectedAwaitAfterPipelineBody","UnexpectedDigitAfterHash","UnexpectedImportExport","UnexpectedKeyword","UnexpectedLeadingDecorator","UnexpectedLexicalDeclaration","UnexpectedNewTarget","UnexpectedNumericSeparator","UnexpectedPrivateField","UnexpectedReservedWord","UnexpectedSuper","UnexpectedToken","UnexpectedTokenUnaryExponentiation","UnsupportedBind","UnsupportedDecoratorExport","UnsupportedDefaultExport","UnsupportedImport","UnsupportedMetaProperty","UnsupportedParameterDecorator","UnsupportedPropertyDecorator","UnsupportedSuper","UnterminatedComment","UnterminatedRegExp","UnterminatedString","UnterminatedTemplate","VarRedeclaration","YieldBindingIdentifier","YieldInParameter","ZeroDigitNumericSeparator","ParserError","getLocationForPosition","pos","startLoc","lastTokStart","lastTokStartLoc","endLoc","lastTokEnd","lastTokEndLoc","raise","errorTemplate","params","raiseWithData","raiseOverwrite","message","errorRecovery","errors","_raise","data","errorContext","err","SyntaxError","isLookahead","superClass","estreeParseRegExpLiteral","pattern","flags","regex","e","estreeParseLiteral","estreeParseBigIntLiteral","bigInt","BigInt","estreeParseDecimalLiteral","parseLiteral","directiveToStmt","directive","directiveLiteral","stmt","startNodeAt","expression","extra","expressionValue","raw","finishNodeAt","initFunction","isAsync","checkDeclaration","isObjectProperty","getObjectOrClassMethodParams","method","isValidDirective","parenthesized","stmtToDirective","addExtra","parseBlockBody","args","directiveStatements","directives","d","concat","pushClassMethod","classBody","isGenerator","isConstructor","allowsDirectSuper","parseMethod","typeParameters","parseExprAtom","refExpressionErrors","tt","parseMaybePrivateName","convertPrivateNameToPrivateIdentifier","getPrivateNameSV","id","isPrivateName","startPos","parseFunctionBody","allowExpression","isMethod","allowDirectSuper","inClassScope","funcNode","startNode","kind","computed","finishNode","parseClassProperty","propertyNode","parseClassPrivateProperty","parseObjectMethod","prop","isPattern","isAccessor","shorthand","parseObjectProperty","toAssignable","isLHS","toAssignableObjectExpressionProp","Errors","finishCallExpression","optional","callee","toReferencedArguments","parseExport","exported","specifiers","parseSubscript","base","noCalls","optionalChainMember","stop","chain","startNodeAtNode","hasPropertyAsPrivateName","isOptionalChain","isObjectMethod","TokContext","isExpr","preserveSpace","override","braceStatement","braceExpression","recordExpression","templateQuasi","parenStatement","parenExpression","p","readTmplToken","functionExpression","functionStatement","context","exprAllowed","out","curContext","prevType","allowed","isIterator","braceIsBlock","statementParens","hasPrecedingLineBreak","b_stat","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","isIdentifierStart","fromCharCode","isIdentifierChar","reservedWords","strict","strictBind","Set","reservedWordsStrictSet","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","isStrictBindOnlyReservedWord","isStrictBindReservedWord","isKeyword","keywordRelationalOperator","isIteratorStart","current","next","SCOPE_OTHER","SCOPE_PROGRAM","SCOPE_FUNCTION","SCOPE_ARROW","SCOPE_SIMPLE_CATCH","SCOPE_SUPER","SCOPE_DIRECT_SUPER","SCOPE_CLASS","SCOPE_STATIC_BLOCK","SCOPE_TS_MODULE","SCOPE_VAR","BIND_KIND_VALUE","BIND_KIND_TYPE","BIND_SCOPE_VAR","BIND_SCOPE_LEXICAL","BIND_SCOPE_FUNCTION","BIND_FLAGS_NONE","BIND_FLAGS_CLASS","BIND_FLAGS_TS_ENUM","BIND_FLAGS_TS_CONST_ENUM","BIND_FLAGS_TS_EXPORT_ONLY","BIND_FLAGS_FLOW_DECLARE_FN","BIND_CLASS","BIND_LEXICAL","BIND_VAR","BIND_FUNCTION","BIND_TS_INTERFACE","BIND_TS_TYPE","BIND_TS_ENUM","BIND_TS_AMBIENT","BIND_NONE","BIND_OUTSIDE","BIND_TS_CONST_ENUM","BIND_TS_NAMESPACE","BIND_FLOW_DECLARE_FN","CLASS_ELEMENT_FLAG_STATIC","CLASS_ELEMENT_KIND_GETTER","CLASS_ELEMENT_KIND_SETTER","CLASS_ELEMENT_KIND_ACCESSOR","CLASS_ELEMENT_STATIC_GETTER","CLASS_ELEMENT_STATIC_SETTER","CLASS_ELEMENT_INSTANCE_GETTER","CLASS_ELEMENT_INSTANCE_SETTER","CLASS_ELEMENT_OTHER","Scope","var","lexical","functions","ScopeHandler","scopeStack","undefinedExports","undefinedPrivateNames","inFunction","currentVarScope","allowSuper","currentThisScope","inClass","inStaticBlock","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","currentScope","createScope","enter","exit","scope","declareName","bindingType","checkRedeclarationInScope","maybeExportDefined","delete","isRedeclaredInScope","checkLocalExport","FlowScope","declareFunctions","FlowScopeHandler","includes","reservedTypes","FlowErrors","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","GetterMayNotHaveThisParam","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","OptionalBindingPattern","SetterMayNotHaveThisParam","SpreadVariance","ThisParamAnnotationRequired","ThisParamBannedInConstructor","ThisParamMayNotBeOptional","ThisParamMustBeFirst","ThisParamNoDefault","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","isEsModuleType","bodyElement","declaration","hasTypeImportKind","importKind","isMaybeDefaultImport","exportSuggestions","const","let","interface","partition","list1","list2","FLOW_PRAGMA_REGEX","flowPragma","getScopeHandler","shouldParseTypes","shouldParseEnums","finishToken","matches","Error","flowParseTypeInitialiser","tok","oldInType","inType","expect","flowParseType","flowParsePredicate","moduloLoc","moduloPos","checksLoc","expectContextual","eat","parseExpression","flowParseTypeAndPredicateInitialiser","predicate","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","parseIdentifier","typeNode","typeContainer","isRelational","flowParseTypeParameterDeclaration","flowParseFunctionTypeParams","rest","this","returnType","typeAnnotation","resetEndLocation","semicolon","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","unexpected","flowParseTypeAnnotatableIdentifier","bodyNode","parseImport","hasModuleExport","default","isLet","suggestion","exportKind","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","checkReservedType","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStart","variance","flowParseVariance","ident","bound","jsxTagStart","defaultRequired","typeParameter","expectRelational","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","flowParseObjectTypeInternalSlot","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","callProperties","indexers","internalSlots","endDelim","exact","inexact","protoStart","inexactStart","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","isInexactToken","argument","proto","flowCheckGetterSetterParams","property","paramCount","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","first","lh","isThis","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","createIdentifier","flowParsePostfixType","canInsertSemicolon","elementType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatement","topLevel","flowParseEnumDeclaration","parseExpressionStatement","expr","shouldParseExportDeclaration","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","refNeedsArrowPos","result","tryParse","failState","clone","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","parseMaybeAssignAllowIn","disallowInvalid","arrows","finishArrowValidation","every","isAssignable","toAssignableList","trailingComma","checkParams","parse","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","parseClassMember","member","parseClassMemberFromModifier","getTokenFromCode","finishOp","readWord","isBinding","element","operator","exprList","trailingCommaPos","toReferencedList","isParenthesizedExpr","parseArrayLike","close","canBePattern","isTuple","maybeInArrowParameters","checkLVal","isClassMethod","isClassProperty","isNonstaticConstructor","isThisParam","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","checkGetterSetterParams","parsePropertyName","isPrivateNameAllowed","parseObjPropValue","parseAssignableListItemTypes","parseMaybeDefault","left","shouldParseDefaultImport","parseImportSpecifierLocal","specifier","contextDescription","local","maybeParseDefaultImportSpecifier","parseImportSpecifier","firstIdentLoc","firstIdent","parseModuleExportName","specifierTypeKind","isLookaheadContextual","as_ident","imported","__clone","nodeIsTypeImport","specifierIsTypeImport","checkReservedWord","parseBindingAtom","parseFunctionParams","allowModifiers","parseVarId","parseAsyncArrowFromCallExpression","shouldParseAsyncArrow","afterLeftParse","jsx","tc","j_oTag","j_expr","abort","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","subscriptState","isLookaheadToken_lt","typeArguments","parseNewArguments","targs","parseArrowExpression","readToken_mult_modulo","hasFlowComment","nextToken","readToken_pipe_amp","parseTopLevel","file","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","shiftToFirstNonWhiteSpace","ch2","ch3","flowEnumErrorBooleanMemberNotInitialized","enumName","memberName","flowEnumErrorInvalidMemberName","flowEnumErrorDuplicateMemberName","flowEnumErrorInconsistentMemberValues","flowEnumErrorInvalidExplicitType","suppliedType","flowEnumErrorInvalidMemberInitializer","explicitType","flowEnumErrorNumberMemberNotInitialized","flowEnumErrorStringMemberInconsistentlyInitailized","flowEnumMemberInit","endOfInit","literal","parseBooleanLiteral","flowEnumMemberRaw","init","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","hasUnknownMembers","memberNode","add","flowEnumStringMembers","initializedMembers","flowEnumParseExplicitType","flowEnumBody","nameLoc","empty","boolsLen","numsLen","strsLen","defaultedLen","nextTokenStart","afterNext","entities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","HEX_NUMBER","DECIMAL_NUMBER","JsxErrors","AttributeIsEmpty","MissingClosingTagElement","MissingClosingTagFragment","UnexpectedSequenceExpression","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","j_cTag","jsxName","jsxText","jsxTagEnd","isFragment","object","getQualifiedJSXName","namespace","jsxReadToken","chunkStart","ch","jsxReadEntity","jsxReadNewLine","normalizeCRLF","curLine","jsxReadString","quote","entity","substr","fromCodePoint","XHTMLEntities","jsxReadWord","jsxParseIdentifier","jsxParseNamespacedName","jsxParseElementName","newNode","jsxParseAttributeValue","jsxParseExpressionContainer","jsxParseEmptyExpression","jsxParseSpreadChild","jsxParseAttribute","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","attributes","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","openingFragment","closingFragment","jsxParseElement","inPropertyName","TypeScriptScope","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","isConst","wasConst","PARAM","PARAM_YIELD","PARAM_AWAIT","PARAM_RETURN","PARAM_IN","ProductionParameterHandler","stacks","currentFlags","hasAwait","hasYield","hasReturn","hasIn","functionFlags","nonNull","x","assert","TSErrors","AbstractMethodHasImplementation","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstructorHasTypeParameters","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateAccessibilityModifier","DuplicateModifier","EmptyHeritageClauseType","EmptyTypeArguments","EmptyTypeParameters","ExpectedAmbientAfterExportDeclare","ImportAliasHasImportType","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasDeclare","IndexSignatureHasStatic","InvalidModifierOnTypeMember","InvalidTupleMemberLabel","MixedLabeledAndUnlabeledElements","NonAbstractClassHasAbstractMethod","NonClassMethodPropertyHasAbstractModifer","OptionalTypeBeforeRequired","PatternIsOptional","PrivateElementHasAbstract","PrivateElementHasAccessibility","ReadonlyForMethodSignature","TypeAnnotationAfterAssign","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","keywordTypeFromName","tsIsAccessModifier","modifier","tsIsIdentifier","tsNextTokenCanFollowModifier","isLiteralPropertyName","tsParseModifier","allowedModifiers","tsTryParse","bind","tsParseModifiers","modified","disallowedModifiers","accessibility","tsIsListTerminator","tsParseList","parseElement","tsParseDelimitedList","tsParseDelimitedListWorker","expectSuccess","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","tsParseTypeAnnotation","asserts","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseTypeParameter","parseIdentifierName","constraint","tsEatThenParseType","tsTryParseTypeParameters","tsParseTypeParameters","tsTryNextParseConstantContext","tsFillSignature","returnToken","signature","returnTokenRequired","parameters","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsParseTypeMemberSemicolon","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","nodeAny","tsParseTypeMember","idx","tsParseTypeLiteral","tsParseObjectTypeMembers","tsIsStartOfMappedType","tsParseMappedTypeParameter","tsExpectThenParseType","tsParseMappedType","nameType","tsParseType","tsTryParseType","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","labeledElements","elementNode","isLabeled","labeled","labeledNode","optionalTypeNode","restNode","tsParseParenthesizedType","tsParseFunctionOrConstructorType","abstract","tsParseLiteralTypeNode","tsParseTemplateLiteralType","parseTemplate","parseTemplateSubstitution","tsParseThisTypeOrThisTypePredicate","thisKeyword","tsParseNonArrayType","lookaheadCharCode","parseMaybeUnary","tsParseArrayTypeOrHigher","objectType","indexType","tsParseTypeOperator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","find","kw","tsParseUnionOrIntersectionType","parseConstituentType","hasLeadingOperator","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","braceStackCounter","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","containsEsc","eatColon","tsParseNonConditionalType","checkType","extendsType","trueType","falseType","isAbstractConstructorSignature","tsParseTypeAssertion","tsNextThenParseType","tsParseHeritageClause","descriptor","originalStart","delimitedList","tsParseExpressionWithTypeArguments","tsParseInterfaceDeclaration","tsParseTypeAliasDeclaration","tsInNoContext","cb","oldContext","tsDoThenParseType","tsParseEnumMember","initializer","tsParseEnumDeclaration","tsParseModuleBlock","parseBlockOrModuleBlockBody","tsParseModuleOrNamespaceDeclaration","nested","inner","prodParam","tsParseAmbientExternalModuleDeclaration","tsParseImportEqualsDeclaration","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","tsTryParseAndCatch","tsTryParseDeclare","nany","isLineTerminator","starttype","tsInDeclareContext","parseFunctionStatement","parseClass","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","mod","tsCheckLineTerminator","tsParseAbstractDeclaration","hasFollowingLineBreak","tsTryParseGenericAsyncArrowFunction","oldMaybeInArrowParameters","tsIsDeclarationStart","parseAssignableListItem","decorators","parseAccessModifier","elt","pp","parameter","bodilessType","isDeclareContext","registerFunctionStatementId","tsCheckForInvalidTypeCasts","items","isInParens","nonNullExpression","atPossibleAsyncArrow","asyncArrowFn","parseTaggedTemplateExpression","parseExprOp","leftStartPos","leftStartLoc","minPrec","reScan_lt_gt","checkKeywords","checkDuplicateExports","ahead","importNode","isAbstractClass","cls","parseStatementContent","callParseClassMember","parseClassMemberWithIsStatic","inAbstractClass","parsePostMemberNameModifiers","methodOrProp","isDeclare","resetStartLocation","parseClassPropertyAnnotation","definite","typeCast","ct","toAssignableParenthesizedExpression","parseMaybeDecoratorArguments","checkCommaAfterRest","readToken_lt_gt","canHaveLeadingDecorator","getGetterSetterExpectedParamCount","baseCount","firstParam","hasContextParam","parseCatchClauseParam","oldIsDeclareContext","oldInAbstractClass","hasBody","placeholder","parsePlaceholder","expectedNode","assertNoSpace","finishPlaceholder","isFinished","verifyBreakContinue","parseBlock","parseFunctionId","takeDecorators","oldStrict","parseClassBody","expectPlugin","isUnparsedContextual","nextTokenStartSince","maybeParseExportDefaultSpecifier","checkExport","filter","hasStarImport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","parseV8Intrinsic","v8IntrinsicStart","identifier","some","option","PIPELINE_PROPOSALS","RECORD_AND_TUPLE_SYNTAX_TYPES","validatePlugins","decoratorsBeforeExport","moduleAttributesVerionPluginOption","mixinPlugins","estree","flow","typescript","v8intrinsic","placeholders","mixinPluginNames","defaultOptions","sourceType","sourceFilename","startLine","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","allowUndeclaredExports","strictMode","ranges","tokens","createParenthesizedExpressions","getOptions","opts","State","potentialArrowAt","inPipeline","topicContext","maxNumOfResolvableTopics","maxTopicIndex","soloAwait","inFSharpPipelineDirectBody","labels","decoratorStack","comments","strictErrors","exportedIdentifiers","tokensLength","curPosition","skipArrays","isDigit","VALID_REGEX_FLAGS","forbiddenNumericSeparatorSiblings","decBinOct","hex","allowedNumericSeparatorSiblings","bin","oct","dec","Token","Tokenizer","ParserErrors","pushToken","checkKeywordEscapes","old","curr","skip","setStrict","clear","skipSpace","codePointAt","pushComment","block","text","skipLineComment","startSkip","loop","readToken_numberSign","readToken_interpreter","nextPos","readToken_dot","readNumber","readToken_slash","readRegexp","width","readToken_caret","readToken_plus_min","readToken_eq_excl","readToken_question","next2","readRadixNumber","readString","content","mods","char","charCode","readInt","radix","len","forceLen","allowNumSeparator","forbiddenSiblings","allowedSiblings","total","Infinity","prev","Number","isBigInt","startsWithDot","isFloat","isDecimal","hasExponent","isOctal","hasLeadingZero","integer","recordStrictModeErrors","underscorePos","readCodePoint","throwOnInvalid","codePos","readHexChar","readEscapedChar","containsInvalid","inTemplate","octalStr","octal","readWord1","escStart","identifierCheck","esc","keywordTypes","parent","update","ClassScope","privateNames","loneAccessors","ClassScopeHandler","oldClassScope","from","declarePrivateName","classScope","redefined","accessor","oldStatic","newStatic","oldKind","newKind","usePrivateName","kExpression","kMaybeArrowParameterDeclaration","kMaybeAsyncArrowParameterDeclaration","kParameterDeclaration","ExpressionScope","canBeArrowParameterDeclaration","isCertainlyParameterDeclaration","ArrowHeadParsingScope","recordDeclarationError","clearDeclarationError","iterateErrors","iterator","ExpressionScopeHandler","recordParameterInitializerError","recordParenthesizedIdentifierError","recordAsyncArrowParametersError","validateAsPattern","newParameterDeclarationScope","newArrowHeadScope","newAsyncArrowScope","newExpressionScope","UtilParser","op","nameStart","nameEnd","allowAsi","messageOrType","missingPlugin","expectOnePlugin","names","oldState","abortSignal","checkExpressionErrors","andThrow","shorthandAssign","doubleProto","initializeScopes","oldLabels","oldExportedIdentifiers","oldInModule","oldScope","oldProdParam","oldExpressionScope","expressionScope","enterInitialScopes","paramFlags","ExpressionErrors","Node","parser","NodeUtils","locationNode","unwrapParenthesizedExpression","LValParser","isLast","raiseRestNotLast","checkToRestConversion","raiseTrailingCommaAfterRest","toReferencedListDeep","parseSpread","parseRestBinding","parseObjectLike","closeCharCode","allowEmpty","elts","parseDecorator","checkClashes","disallowLetBinding","strictModeChanged","elem","ExpressionParser","checkProto","isRecord","protoRef","used","shouldExitDescending","getExpression","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","expressions","parseMaybeAssignDisallowIn","parseYield","ownExpressionErrors","parseMaybeConditional","parseExprOps","prec","checkPipelineAtInfixOperator","logical","coalesce","parseExprOpRightExpr","nextOp","withTopicPermittingContext","parseSmartPipelineBody","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","checkExponentialAfterUnary","sawUnary","isAwait","isAwaitAllowed","parseAwait","parseModuleExpression","isDelete","parseUpdate","isAmbiguousAwait","parseExprSubscripts","maybeAsyncArrow","parseBind","parseCoverCallAndAsyncArrowHead","parseMember","parseNoCallExpr","tag","quasi","possibleAsyncArrow","dynamicImport","allowPlaceholder","nodeForExtra","oldInFSharpPipelineDirectBody","parseExprListItem","parseSuper","parseImportMetaProperty","parseFunction","parseAsyncArrowUnaryFunction","parseDo","parseFunctionOrFunctionSent","parseDecorators","parseNewOrNewTarget","primaryTopicReferenceIsAllowedInCurrentTopicContext","registerTopicReference","nextCh","lookaheadCh","isPrivate","meta","parseMetaProperty","propertyName","innerStartPos","innerStartLoc","spreadStart","optionalCommaStart","spreadNodeStartPos","spreadNodeStartLoc","innerEndPos","innerEndLoc","arrowNode","metaProp","parseNew","parseExprList","parseTemplateElement","isTagged","cooked","tail","curElt","quasis","propHash","parsePropertyDefinition","maybeAsyncOrAccessorProp","keyName","oldInPropertyName","generator","isExpression","hasStrictModeDirective","nonSimple","isSimpleParamList","errorPos","reservedTest","delegate","childExpression","checkSmartPipelineBodyEarlyErrors","parseSmartPipelineBodyInStyle","isSimpleReference","topicReferenceWasUsedInCurrentTopicContext","callback","outerContextTopicState","withTopicForbiddingContext","outerContextSoloAwaitState","prodParamToSet","prodParamToClear","revertScopes","parseProgram","loopLabel","switchLabel","FUNC_NO_FLAGS","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","loneSurrogate","StatementParser","interpreter","parseInterpreterDirective","isLetKeyword","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","nextTokenCharCode","isAsyncFunction","maybeName","parseLabeledStatement","allowExport","currentContextDecorators","decorator","isBreak","lab","parseHeaderExpression","awaitAt","parseFor","startsWithLet","parseVar","declarations","parseForIn","isForOf","description","declarationPosition","discriminant","cases","cur","sawDefault","isCase","simple","handler","clause","finalizer","statementStart","allowDirectives","createNewLexicalScope","afterBlockParse","parsedNonDirective","isForIn","await","isFor","isTypescript","statement","isHangingStatement","requireId","constructorAllowsSuper","hadConstructor","parseClassStaticBlock","publicMethod","privateMethod","publicProp","privateProp","publicMember","parseClassElementName","isSimple","maybeQuestionTokenStart","pushClassPrivateProperty","pushClassProperty","parseInitializer","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","l","hasFrom","nextAfterFrom","assertions","maybeParseImportAssertions","checkNames","isDefault","isFrom","exportedName","nodes","surrogate","parseNext","maybeParseModuleAttributes","parseAssertEntries","attrs","attrNames","Parser","pluginsMap","pluginMap","getParser","ast","moduleError","getParserClass","parserClassCache","pluginsFromOptions","pluginList","factory","define","amd","estreeWalker","should_skip","should_remove","replacement","WalkerBase","leave","visit","_should_skip","_should_remove","_replacement","skipped","removed","instance","SyncWalker","AsyncWalker","asyncWalk","walk","script","initialize","__esModule","render","__cssModules","__scopeId","__file","imgSize","drawLine","ctx","color","beginPath","strokeStyle","moveTo","y","lineTo","to","stroke","lineWidth","fillStyle","arc","PI","fill","other","success","primary","setup","srcCanvasRef","srcMousedown","srcMousemove","srcMouseup","dstCanvasRef","dstMousedown","dstMousemove","dstMouseup","lookLineIdx","mode","removeLine","lineArr","currLine","currIdx","renderCanvas","srcCtx","dstCtx","srcCanvas","getContext","dstCanvas","down","move","tempLine","pageX","offsetLeft","pageY","offsetTop","dst","clearRect","img","srcImg","dstImg","drawImage","channel","BroadcastChannel","onmessage","event","msg","msgType","postMessage","link","openView","open","loadImg","inp","createElement","accept","onchange","files","reader","FileReader","addEventListener","Image","onload","readAsDataURL","click","close_icon","_withId","_hoisted_1","class","_hoisted_2","_hoisted_3","_hoisted_4","_hoisted_5","_hoisted_6","_ctx","_cache","ref","height","onMousedown","onMousemove","onMouseup","onMouseover","onClick","$event","round","alt","run","time","canvasRef","gl","createGl","bg_program","fg_program","transforms","pos_arr","uv_arr","idx_arr","fg_vao","bg_vao","fg_texture","bg_texture","w","h","calcWH","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","withTime","srcWeights","ceil","ws","lineIdx","w_acc","acc","floor","deleteVertexArray","dstWeights","line1","vec2","fromValues","line2","deleteTexture","createTexture","bindTexture","TEXTURE_2D","texStorage2D","RGB8","texSubImage2D","RGB","UNSIGNED_BYTE","generateMipmap","canvas","preserveDrawingBuffer","premultipliedAlpha","clearColor","clearDepth","viewport","enable","CULL_FACE","DEPTH_TEST","depthMask","depthFunc","LEQUAL","BLEND","blendFunc","SRC_ALPHA","DST_ALPHA","calcVecLen","vec","calcLineLen","calcDist","point","vec1","vec2Len","vec3","calcWeight","dist","lineLen","genShaderProgram","lineNum","isBg","vs_source","fs_source","createProgram","genBufferData","vao","texture","transformMat3s","useProgram","bindVertexArray","u_textureLocation","getUniformLocation","uniform1i","activeTexture","TEXTURE0","u_timeLocation","uniform1f","m","u_mLocation","uniformMatrix3fv","drawElements","TRIANGLES","UNSIGNED_INT","genVAO","weights","createVertexArray","enableVertexAttribArray","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","vertexAttribPointer","FLOAT","texcoordBuffer","weight","weightBuffer","ebo","ELEMENT_ARRAY_BUFFER","Uint32Array","vsSource","fsSource","vertexShader","compileShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","log","getProgramInfoLog","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","r90","v","rotate","mat3","mul","Mat3","p1","p2","Line","angle","scale","displacement","transformMat3","x_axis","t1","fromTranslation","negate","x_angle","r1","fromRotation","s","fromScaling","neg_r1","r2","org","tran2org","rotate2x","scaling","derotate2x","rotate2target","detran2org","tran2target","style","step","onInput"],"version":3,"file":"index.378abbca.js.map"}