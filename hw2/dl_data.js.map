{
  "version": 3,
  "sources": ["../node_modules/data-uri-to-buffer/src/index.ts", "../node_modules/web-streams-polyfill/src/stub/symbol.ts", "../node_modules/web-streams-polyfill/src/utils.ts", "../node_modules/web-streams-polyfill/src/lib/helpers/miscellaneous.ts", "../node_modules/web-streams-polyfill/src/lib/helpers/webidl.ts", "../node_modules/web-streams-polyfill/src/lib/simple-queue.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/generic-reader.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/internal-methods.ts", "../node_modules/web-streams-polyfill/src/stub/number-isfinite.ts", "../node_modules/web-streams-polyfill/src/stub/math-trunc.ts", "../node_modules/web-streams-polyfill/src/lib/validators/basic.ts", "../node_modules/web-streams-polyfill/src/lib/validators/readable-stream.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/default-reader.ts", "../node_modules/web-streams-polyfill/src/target/es2018/stub/async-iterator-prototype.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/async-iterator.ts", "../node_modules/web-streams-polyfill/src/stub/number-isnan.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/ecmascript.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/miscellaneous.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/queue-with-sizes.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/byte-stream-controller.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/byob-reader.ts", "../node_modules/web-streams-polyfill/src/lib/abstract-ops/queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/validators/underlying-sink.ts", "../node_modules/web-streams-polyfill/src/lib/validators/writable-stream.ts", "../node_modules/web-streams-polyfill/src/lib/abort-signal.ts", "../node_modules/web-streams-polyfill/src/lib/writable-stream.ts", "../node_modules/web-streams-polyfill/src/stub/native.ts", "../node_modules/web-streams-polyfill/src/stub/dom-exception.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/pipe.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/default-controller.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream/tee.ts", "../node_modules/web-streams-polyfill/src/lib/validators/underlying-source.ts", "../node_modules/web-streams-polyfill/src/lib/validators/reader-options.ts", "../node_modules/web-streams-polyfill/src/lib/validators/iterator-options.ts", "../node_modules/web-streams-polyfill/src/lib/validators/pipe-options.ts", "../node_modules/web-streams-polyfill/src/lib/validators/readable-writable-pair.ts", "../node_modules/web-streams-polyfill/src/lib/readable-stream.ts", "../node_modules/web-streams-polyfill/src/lib/validators/queuing-strategy-init.ts", "../node_modules/web-streams-polyfill/src/lib/byte-length-queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/count-queuing-strategy.ts", "../node_modules/web-streams-polyfill/src/lib/validators/transformer.ts", "../node_modules/web-streams-polyfill/src/lib/transform-stream.ts", "../node_modules/fetch-blob/streams.cjs", "dl_data.ts", "../node_modules/node-fetch/src/index.js", "../node_modules/node-fetch/src/body.js", "../node_modules/fetch-blob/index.js", "../node_modules/node-fetch/src/errors/base.js", "../node_modules/node-fetch/src/errors/fetch-error.js", "../node_modules/node-fetch/src/utils/form-data.js", "../node_modules/node-fetch/src/utils/is.js", "../node_modules/node-fetch/src/headers.js", "../node_modules/node-fetch/src/utils/is-redirect.js", "../node_modules/node-fetch/src/response.js", "../node_modules/node-fetch/src/request.js", "../node_modules/node-fetch/src/utils/get-search.js", "../node_modules/node-fetch/src/errors/abort-error.js"],
  "sourcesContent": [null, "/// <reference lib=\"es2015.symbol\" />\n\nconst SymbolPolyfill: (description?: string) => symbol =\n  typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})` as any as symbol;\n\nexport default SymbolPolyfill;\n", "/// <reference lib=\"dom\" />\n\nexport function noop(): undefined {\n  return undefined;\n}\n\nfunction getGlobals() {\n  if (typeof self !== 'undefined') {\n    return self;\n  } else if (typeof window !== 'undefined') {\n    return window;\n  } else if (typeof global !== 'undefined') {\n    return global;\n  }\n  return undefined;\n}\n\nexport const globals = getGlobals();\n", "import { noop } from '../../utils';\nimport { AssertionError } from '../../stub/assert';\n\nexport function typeIsObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport const rethrowAssertionErrorRejection: (e: any) => void =\n  DEBUG ? e => {\n    // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors\n    // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't\n    // expect any errors, but assertion errors are always problematic.\n    if (e && e instanceof AssertionError) {\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    }\n  } : noop;\n", "import { globals } from '../../utils';\nimport { rethrowAssertionErrorRejection } from './miscellaneous';\nimport assert from '../../stub/assert';\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\n\nexport function newPromise<T>(executor: (\n  resolve: (value: T | PromiseLike<T>) => void,\n  reject: (reason?: any) => void\n) => void): Promise<T> {\n  return new originalPromise(executor);\n}\n\nexport function promiseResolvedWith<T>(value: T | PromiseLike<T>): Promise<T> {\n  return originalPromiseResolve(value);\n}\n\nexport function promiseRejectedWith<T = never>(reason: any): Promise<T> {\n  return originalPromiseReject(reason);\n}\n\nexport function PerformPromiseThen<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  onRejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n  // approximation.\n  return originalPromiseThen.call(promise, onFulfilled, onRejected) as Promise<TResult1 | TResult2>;\n}\n\nexport function uponPromise<T>(\n  promise: Promise<T>,\n  onFulfilled?: (value: T) => void | PromiseLike<void>,\n  onRejected?: (reason: any) => void | PromiseLike<void>): void {\n  PerformPromiseThen(\n    PerformPromiseThen(promise, onFulfilled, onRejected),\n    undefined,\n    rethrowAssertionErrorRejection\n  );\n}\n\nexport function uponFulfillment<T>(promise: Promise<T>, onFulfilled: (value: T) => void | PromiseLike<void>): void {\n  uponPromise(promise, onFulfilled);\n}\n\nexport function uponRejection(promise: Promise<unknown>, onRejected: (reason: any) => void | PromiseLike<void>): void {\n  uponPromise(promise, undefined, onRejected);\n}\n\nexport function transformPromiseWith<T, TResult1 = T, TResult2 = never>(\n  promise: Promise<T>,\n  fulfillmentHandler?: (value: T) => TResult1 | PromiseLike<TResult1>,\n  rejectionHandler?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\n\nexport function setPromiseIsHandledToTrue(promise: Promise<unknown>): void {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\n\nexport const queueMicrotask: (fn: () => void) => void = (() => {\n  const globalQueueMicrotask = globals && globals.queueMicrotask;\n  if (typeof globalQueueMicrotask === 'function') {\n    return globalQueueMicrotask;\n  }\n\n  const resolvedPromise = promiseResolvedWith(undefined);\n  return (fn: () => void) => PerformPromiseThen(resolvedPromise, fn);\n})();\n\nexport function reflectCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R, V: T, args: A): R {\n  if (typeof F !== 'function') {\n    throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n}\n\nexport function promiseCall<T, A extends any[], R>(F: (this: T, ...fnArgs: A) => R | PromiseLike<R>,\n                                                   V: T,\n                                                   args: A): Promise<R> {\n  assert(typeof F === 'function');\n  assert(V !== undefined);\n  assert(Array.isArray(args));\n  try {\n    return promiseResolvedWith(reflectCall(F, V, args));\n  } catch (value) {\n    return promiseRejectedWith(value);\n  }\n}\n", "import assert from '../stub/assert';\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n\ninterface Node<T> {\n  _elements: T[];\n  _next: Node<T> | undefined;\n}\n\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nexport class SimpleQueue<T> {\n  private _front: Node<T>;\n  private _back: Node<T>;\n  private _cursor = 0;\n  private _size = 0;\n\n  constructor() {\n    // _front and _back are always defined.\n    this._front = {\n      _elements: [],\n      _next: undefined\n    };\n    this._back = this._front;\n    // The cursor is used to avoid calling Array.shift().\n    // It contains the index of the front element of the array inside the\n    // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n    this._cursor = 0;\n    // When there is only one node, size === elements.length - cursor.\n    this._size = 0;\n  }\n\n  get length(): number {\n    return this._size;\n  }\n\n  // For exception safety, this method is structured in order:\n  // 1. Read state\n  // 2. Calculate required state mutations\n  // 3. Perform state mutations\n  push(element: T): void {\n    const oldBack = this._back;\n    let newBack = oldBack;\n    assert(oldBack._next === undefined);\n    if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n      newBack = {\n        _elements: [],\n        _next: undefined\n      };\n    }\n\n    // push() is the mutation most likely to throw an exception, so it\n    // goes first.\n    oldBack._elements.push(element);\n    if (newBack !== oldBack) {\n      this._back = newBack;\n      oldBack._next = newBack;\n    }\n    ++this._size;\n  }\n\n  // Like push(), shift() follows the read -> calculate -> mutate pattern for\n  // exception safety.\n  shift(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const oldFront = this._front;\n    let newFront = oldFront;\n    const oldCursor = this._cursor;\n    let newCursor = oldCursor + 1;\n\n    const elements = oldFront._elements;\n    const element = elements[oldCursor];\n\n    if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n      assert(elements.length === QUEUE_MAX_ARRAY_SIZE);\n      assert(oldFront._next !== undefined);\n      newFront = oldFront._next!;\n      newCursor = 0;\n    }\n\n    // No mutations before this point.\n    --this._size;\n    this._cursor = newCursor;\n    if (oldFront !== newFront) {\n      this._front = newFront;\n    }\n\n    // Permit shifted element to be garbage collected.\n    elements[oldCursor] = undefined!;\n\n    return element;\n  }\n\n  // The tricky thing about forEach() is that it can be called\n  // re-entrantly. The queue may be mutated inside the callback. It is easy to\n  // see that push() within the callback has no negative effects since the end\n  // of the queue is checked for on every iteration. If shift() is called\n  // repeatedly within the callback then the next iteration may return an\n  // element that has been removed. In this case the callback will be called\n  // with undefined values until we either \"catch up\" with elements that still\n  // exist or reach the back of the queue.\n  forEach(callback: (element: T) => void): void {\n    let i = this._cursor;\n    let node = this._front;\n    let elements = node._elements;\n    while (i !== elements.length || node._next !== undefined) {\n      if (i === elements.length) {\n        assert(node._next !== undefined);\n        assert(i === QUEUE_MAX_ARRAY_SIZE);\n        node = node._next!;\n        elements = node._elements;\n        i = 0;\n        if (elements.length === 0) {\n          break;\n        }\n      }\n      callback(elements[i]);\n      ++i;\n    }\n  }\n\n  // Return the element that would be returned if shift() was called now,\n  // without modifying the queue.\n  peek(): T {\n    assert(this._size > 0); // must not be called on an empty queue\n\n    const front = this._front;\n    const cursor = this._cursor;\n    return front._elements[cursor];\n  }\n}\n", "import assert from '../../stub/assert';\nimport { ReadableStream, ReadableStreamCancel, ReadableStreamReader } from '../readable-stream';\nimport { newPromise, setPromiseIsHandledToTrue } from '../helpers/webidl';\n\nexport function ReadableStreamReaderGenericInitialize<R>(reader: ReadableStreamReader<R>, stream: ReadableStream<R>) {\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n\n  if (stream._state === 'readable') {\n    defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n    defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n    assert(stream._state === 'errored');\n\n    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n}\n\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\n\nexport function ReadableStreamReaderGenericCancel(reader: ReadableStreamReader<any>, reason: any): Promise<undefined> {\n  const stream = reader._ownerReadableStream;\n  assert(stream !== undefined);\n  return ReadableStreamCancel(stream, reason);\n}\n\nexport function ReadableStreamReaderGenericRelease(reader: ReadableStreamReader<any>) {\n  assert(reader._ownerReadableStream !== undefined);\n  assert(reader._ownerReadableStream._reader === reader);\n\n  if (reader._ownerReadableStream._state === 'readable') {\n    defaultReaderClosedPromiseReject(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  } else {\n    defaultReaderClosedPromiseResetToRejected(\n      reader,\n      new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n  }\n\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined!;\n}\n\n// Helper functions for the readers.\n\nexport function readerLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nexport function defaultReaderClosedPromiseInitialize(reader: ReadableStreamReader<any>) {\n  reader._closedPromise = newPromise((resolve, reject) => {\n    reader._closedPromise_resolve = resolve;\n    reader._closedPromise_reject = reject;\n  });\n}\n\nexport function defaultReaderClosedPromiseInitializeAsRejected(reader: ReadableStreamReader<any>, reason: any) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseInitializeAsResolved(reader: ReadableStreamReader<any>) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n}\n\nexport function defaultReaderClosedPromiseReject(reader: ReadableStreamReader<any>, reason: any) {\n  if (reader._closedPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n\nexport function defaultReaderClosedPromiseResetToRejected(reader: ReadableStreamReader<any>, reason: any) {\n  assert(reader._closedPromise_resolve === undefined);\n  assert(reader._closedPromise_reject === undefined);\n\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\n\nexport function defaultReaderClosedPromiseResolve(reader: ReadableStreamReader<any>) {\n  if (reader._closedPromise_resolve === undefined) {\n    return;\n  }\n\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n}\n", "export const AbortSteps = Symbol('[[AbortSteps]]');\nexport const ErrorSteps = Symbol('[[ErrorSteps]]');\nexport const CancelSteps = Symbol('[[CancelSteps]]');\nexport const PullSteps = Symbol('[[PullSteps]]');\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite: typeof Number.isFinite = Number.isFinite || function (x) {\n  return typeof x === 'number' && isFinite(x);\n};\n\nexport default NumberIsFinite;\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc: typeof Math.trunc = Math.trunc || function (v) {\n  return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\nexport default MathTrunc;\n", "import NumberIsFinite from '../../stub/number-isfinite';\nimport MathTrunc from '../../stub/math-trunc';\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nexport function isDictionary(x: any): x is object | null {\n  return typeof x === 'object' || typeof x === 'function';\n}\n\nexport function assertDictionary(obj: unknown,\n                                 context: string): asserts obj is object | null | undefined {\n  if (obj !== undefined && !isDictionary(obj)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport type AnyFunction = (...args: any[]) => any;\n\n// https://heycam.github.io/webidl/#idl-callback-functions\nexport function assertFunction(x: unknown, context: string): asserts x is AnyFunction {\n  if (typeof x !== 'function') {\n    throw new TypeError(`${context} is not a function.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-object\nexport function isObject(x: any): x is object {\n  return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\n\nexport function assertObject(x: unknown,\n                             context: string): asserts x is object {\n  if (!isObject(x)) {\n    throw new TypeError(`${context} is not an object.`);\n  }\n}\n\nexport function assertRequiredArgument<T extends any>(x: T | undefined,\n                                                      position: number,\n                                                      context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n  }\n}\n\nexport function assertRequiredField<T extends any>(x: T | undefined,\n                                                   field: string,\n                                                   context: string): asserts x is T {\n  if (x === undefined) {\n    throw new TypeError(`${field} is required in '${context}'.`);\n  }\n}\n\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nexport function convertUnrestrictedDouble(value: unknown): number {\n  return Number(value);\n}\n\nfunction censorNegativeZero(x: number): number {\n  return x === 0 ? 0 : x;\n}\n\nfunction integerPart(x: number): number {\n  return censorNegativeZero(MathTrunc(x));\n}\n\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nexport function convertUnsignedLongLongWithEnforceRange(value: unknown, context: string): number {\n  const lowerBound = 0;\n  const upperBound = Number.MAX_SAFE_INTEGER;\n\n  let x = Number(value);\n  x = censorNegativeZero(x);\n\n  if (!NumberIsFinite(x)) {\n    throw new TypeError(`${context} is not a finite number`);\n  }\n\n  x = integerPart(x);\n\n  if (x < lowerBound || x > upperBound) {\n    throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n  }\n\n  if (!NumberIsFinite(x) || x === 0) {\n    return 0;\n  }\n\n  // TODO Use BigInt if supported?\n  // let xBigInt = BigInt(integerPart(x));\n  // xBigInt = BigInt.asUintN(64, xBigInt);\n  // return Number(xBigInt);\n\n  return x;\n}\n", "import { IsReadableStream, ReadableStream } from '../readable-stream';\n\nexport function assertReadableStream(x: unknown, context: string): asserts x is ReadableStream {\n  if (!IsReadableStream(x)) {\n    throw new TypeError(`${context} is not a ReadableStream.`);\n  }\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableStream } from '../readable-stream';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { PullSteps } from '../abstract-ops/internal-methods';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\n\n/**\n * A result returned by {@link ReadableStreamDefaultReader.read}.\n *\n * @public\n */\nexport type ReadableStreamDefaultReadResult<T> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value?: undefined;\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamDefaultReader<R>(stream: ReadableStream): ReadableStreamDefaultReader<R> {\n  return new ReadableStreamDefaultReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadRequest<R>(stream: ReadableStream<R>,\n                                                readRequest: ReadRequest<R>): void {\n  assert(IsReadableStreamDefaultReader(stream._reader));\n  assert(stream._state === 'readable');\n\n  (stream._reader! as ReadableStreamDefaultReader<R>)._readRequests.push(readRequest);\n}\n\nexport function ReadableStreamFulfillReadRequest<R>(stream: ReadableStream<R>, chunk: R | undefined, done: boolean) {\n  const reader = stream._reader as ReadableStreamDefaultReader<R>;\n\n  assert(reader._readRequests.length > 0);\n\n  const readRequest = reader._readRequests.shift()!;\n  if (done) {\n    readRequest._closeSteps();\n  } else {\n    readRequest._chunkSteps(chunk!);\n  }\n}\n\nexport function ReadableStreamGetNumReadRequests<R>(stream: ReadableStream<R>): number {\n  return (stream._reader as ReadableStreamDefaultReader<R>)._readRequests.length;\n}\n\nexport function ReadableStreamHasDefaultReader(stream: ReadableStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamDefaultReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadRequest<R> {\n  _chunkSteps(chunk: R): void;\n\n  _closeSteps(): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamDefaultReader<R = any> {\n  /** @internal */\n  _ownerReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readRequests: SimpleQueue<ReadRequest<R>>;\n\n  constructor(stream: ReadableStream<R>) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed,\n   * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (!IsReadableStreamDefaultReader(this)) {\n      return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamDefaultReaderRead(this, readRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamDefaultReader(this)) {\n      throw defaultReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamDefaultReader<R = any>(x: any): x is ReadableStreamDefaultReader<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultReader;\n}\n\nexport function ReadableStreamDefaultReaderRead<R>(reader: ReadableStreamDefaultReader<R>,\n                                                   readRequest: ReadRequest<R>): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    readRequest._closeSteps();\n  } else if (stream._state === 'errored') {\n    readRequest._errorSteps(stream._storedError);\n  } else {\n    assert(stream._state === 'readable');\n    stream._readableStreamController[PullSteps](readRequest as ReadRequest<any>);\n  }\n}\n\n// Helper functions for the ReadableStreamDefaultReader.\n\nfunction defaultReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n", "/// <reference lib=\"es2018.asynciterable\" />\n\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const AsyncIteratorPrototype: AsyncIterable<any> | undefined =\n  Object.getPrototypeOf(Object.getPrototypeOf(async function* (): AsyncIterableIterator<any> {}).prototype);\n", "/// <reference lib=\"es2018.asynciterable\" />\n\nimport { ReadableStream } from '../readable-stream';\nimport {\n  AcquireReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  ReadableStreamDefaultReadResult,\n  ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport assert from '../../stub/assert';\nimport { AsyncIteratorPrototype } from '@@target/stub/async-iterator-prototype';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  queueMicrotask,\n  transformPromiseWith\n} from '../helpers/webidl';\n\n/**\n * An async iterator returned by {@link ReadableStream.values}.\n *\n * @public\n */\nexport interface ReadableStreamAsyncIterator<R> extends AsyncIterator<R> {\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nexport class ReadableStreamAsyncIteratorImpl<R> {\n  private readonly _reader: ReadableStreamDefaultReader<R>;\n  private readonly _preventCancel: boolean;\n  private _ongoingPromise: Promise<ReadableStreamDefaultReadResult<R>> | undefined = undefined;\n  private _isFinished = false;\n\n  constructor(reader: ReadableStreamDefaultReader<R>, preventCancel: boolean) {\n    this._reader = reader;\n    this._preventCancel = preventCancel;\n  }\n\n  next(): Promise<ReadableStreamDefaultReadResult<R>> {\n    const nextSteps = () => this._nextSteps();\n    this._ongoingPromise = this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n      nextSteps();\n    return this._ongoingPromise;\n  }\n\n  return(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    const returnSteps = () => this._returnSteps(value);\n    return this._ongoingPromise ?\n      transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n      returnSteps();\n  }\n\n  private _nextSteps(): Promise<ReadableStreamDefaultReadResult<R>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value: undefined, done: true });\n    }\n\n    const reader = this._reader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('iterate'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamDefaultReadResult<R>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamDefaultReadResult<R>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        this._ongoingPromise = undefined;\n        // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n        // FIXME Is this a bug in the specification, or in the test?\n        queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n      },\n      _closeSteps: () => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        resolvePromise({ value: undefined, done: true });\n      },\n      _errorSteps: reason => {\n        this._ongoingPromise = undefined;\n        this._isFinished = true;\n        ReadableStreamReaderGenericRelease(reader);\n        rejectPromise(reason);\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n    return promise;\n  }\n\n  private _returnSteps(value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (this._isFinished) {\n      return Promise.resolve({ value, done: true });\n    }\n    this._isFinished = true;\n\n    const reader = this._reader;\n    if (reader._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('finish iterating'));\n    }\n\n    assert(reader._readRequests.length === 0);\n\n    if (!this._preventCancel) {\n      const result = ReadableStreamReaderGenericCancel(reader, value);\n      ReadableStreamReaderGenericRelease(reader);\n      return transformPromiseWith(result, () => ({ value, done: true }));\n    }\n\n    ReadableStreamReaderGenericRelease(reader);\n    return promiseResolvedWith({ value, done: true });\n  }\n}\n\ndeclare class ReadableStreamAsyncIteratorInstance<R> implements ReadableStreamAsyncIterator<R> {\n  /** @interal */\n  _asyncIteratorImpl: ReadableStreamAsyncIteratorImpl<R>;\n\n  next(): Promise<IteratorResult<R, undefined>>;\n\n  return(value?: any): Promise<IteratorResult<any>>;\n}\n\nconst ReadableStreamAsyncIteratorPrototype: ReadableStreamAsyncIteratorInstance<any> = {\n  next(this: ReadableStreamAsyncIteratorInstance<any>): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n    }\n    return this._asyncIteratorImpl.next();\n  },\n\n  return(this: ReadableStreamAsyncIteratorInstance<any>, value: any): Promise<ReadableStreamDefaultReadResult<any>> {\n    if (!IsReadableStreamAsyncIterator(this)) {\n      return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n    }\n    return this._asyncIteratorImpl.return(value);\n  }\n} as any;\nif (AsyncIteratorPrototype !== undefined) {\n  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamAsyncIterator<R>(stream: ReadableStream<R>,\n                                                      preventCancel: boolean): ReadableStreamAsyncIterator<R> {\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n  const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n  const iterator: ReadableStreamAsyncIteratorInstance<R> = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorImpl = impl;\n  return iterator;\n}\n\nfunction IsReadableStreamAsyncIterator<R = any>(x: any): x is ReadableStreamAsyncIterator<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n    return false;\n  }\n\n  try {\n    // noinspection SuspiciousTypeOfGuard\n    return (x as ReadableStreamAsyncIteratorInstance<any>)._asyncIteratorImpl instanceof\n      ReadableStreamAsyncIteratorImpl;\n  } catch {\n    return false;\n  }\n}\n\n// Helper functions for the ReadableStream.\n\nfunction streamAsyncIteratorBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n", "/// <reference lib=\"es2015.core\" />\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN: typeof Number.isNaN = Number.isNaN || function (x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n};\n\nexport default NumberIsNaN;\n", "export function CreateArrayFromList<T extends any[]>(elements: T): T {\n  // We use arrays to represent lists, so this is basically a no-op.\n  // Do a slice though just in case we happen to depend on the unique-ness.\n  return elements.slice() as T;\n}\n\nexport function CopyDataBlockBytes(dest: ArrayBuffer,\n                                   destOffset: number,\n                                   src: ArrayBuffer,\n                                   srcOffset: number,\n                                   n: number) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n\n// Not implemented correctly\nexport function TransferArrayBuffer<T extends ArrayBufferLike>(O: T): T {\n  return O;\n}\n\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function CanTransferArrayBuffer(O: ArrayBufferLike): boolean {\n  return true;\n}\n\n// Not implemented correctly\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function IsDetachedBuffer(O: ArrayBufferLike): boolean {\n  return false;\n}\n\nexport function ArrayBufferSlice(buffer: ArrayBufferLike, begin: number, end: number): ArrayBufferLike {\n  // ArrayBuffer.prototype.slice is not available on IE10\n  // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n  if (buffer.slice) {\n    return buffer.slice(begin, end);\n  }\n  const length = end - begin;\n  const slice = new ArrayBuffer(length);\n  CopyDataBlockBytes(slice, 0, buffer, begin, length);\n  return slice;\n}\n", "import NumberIsNaN from '../../stub/number-isnan';\nimport { ArrayBufferSlice } from './ecmascript';\n\nexport function IsNonNegativeNumber(v: number): boolean {\n  if (typeof v !== 'number') {\n    return false;\n  }\n\n  if (NumberIsNaN(v)) {\n    return false;\n  }\n\n  if (v < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function CloneAsUint8Array(O: ArrayBufferView): Uint8Array {\n  const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n  return new Uint8Array(buffer);\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsNonNegativeNumber } from './miscellaneous';\n\nexport interface QueueContainer<T> {\n  _queue: SimpleQueue<T>;\n  _queueTotalSize: number;\n}\n\nexport interface QueuePair<T> {\n  value: T;\n  size: number;\n}\n\nexport function DequeueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.shift()!;\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n    container._queueTotalSize = 0;\n  }\n\n  return pair.value;\n}\n\nexport function EnqueueValueWithSize<T>(container: QueueContainer<QueuePair<T>>, value: T, size: number) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  if (!IsNonNegativeNumber(size) || size === Infinity) {\n    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n\n  container._queue.push({ value, size });\n  container._queueTotalSize += size;\n}\n\nexport function PeekQueueValue<T>(container: QueueContainer<QueuePair<T>>): T {\n  assert('_queue' in container && '_queueTotalSize' in container);\n  assert(container._queue.length > 0);\n\n  const pair = container._queue.peek();\n  return pair.value;\n}\n\nexport function ResetQueue<T>(container: QueueContainer<T>) {\n  assert('_queue' in container && '_queueTotalSize' in container);\n\n  container._queue = new SimpleQueue<T>();\n  container._queueTotalSize = 0;\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport { ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadableStreamHasDefaultReader,\n  ReadRequest\n} from './default-reader';\nimport {\n  ReadableStreamAddReadIntoRequest,\n  ReadableStreamFulfillReadIntoRequest,\n  ReadableStreamGetNumReadIntoRequests,\n  ReadableStreamHasBYOBReader,\n  ReadIntoRequest\n} from './byob-reader';\nimport NumberIsInteger from '../../stub/number-isinteger';\nimport {\n  IsReadableStreamLocked,\n  ReadableByteStream,\n  ReadableStreamClose,\n  ReadableStreamError\n} from '../readable-stream';\nimport { ValidatedUnderlyingByteSource } from './underlying-source';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport {\n  ArrayBufferSlice,\n  CanTransferArrayBuffer,\n  CopyDataBlockBytes,\n  IsDetachedBuffer,\n  TransferArrayBuffer\n} from '../abstract-ops/ecmascript';\nimport { CancelSteps, PullSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\nimport { assertRequiredArgument, convertUnsignedLongLongWithEnforceRange } from '../validators/basic';\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nexport class ReadableStreamBYOBRequest {\n  /** @internal */\n  _associatedReadableByteStreamController!: ReadableByteStreamController;\n  /** @internal */\n  _view!: ArrayBufferView | null;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n   */\n  get view(): ArrayBufferView | null {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('view');\n    }\n\n    return this._view;\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that `bytesWritten` bytes were written into\n   * {@link ReadableStreamBYOBRequest.view | view}, causing the result be surfaced to the consumer.\n   *\n   * After this method is called, {@link ReadableStreamBYOBRequest.view | view} will be transferred and no longer\n   * modifiable.\n   */\n  respond(bytesWritten: number): void;\n  respond(bytesWritten: number | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respond');\n    }\n    assertRequiredArgument(bytesWritten, 1, 'respond');\n    bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(this._view!.buffer)) {\n      throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n    }\n\n    assert(this._view!.byteLength > 0);\n    assert(this._view!.buffer.byteLength > 0);\n\n    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  }\n\n  /**\n   * Indicates to the associated readable byte stream that instead of writing into\n   * {@link ReadableStreamBYOBRequest.view | view}, the underlying byte source is providing a new `ArrayBufferView`,\n   * which will be given to the consumer of the readable byte stream.\n   *\n   * After this method is called, `view` will be transferred and no longer modifiable.\n   */\n  respondWithNewView(view: ArrayBufferView): void;\n  respondWithNewView(view: ArrayBufferView | undefined): void {\n    if (!IsReadableStreamBYOBRequest(this)) {\n      throw byobRequestBrandCheckException('respondWithNewView');\n    }\n    assertRequiredArgument(view, 1, 'respondWithNewView');\n\n    if (!ArrayBuffer.isView(view)) {\n      throw new TypeError('You can only respond with array buffer views');\n    }\n\n    if (this._associatedReadableByteStreamController === undefined) {\n      throw new TypeError('This BYOB request has been invalidated');\n    }\n\n    if (IsDetachedBuffer(view.buffer)) {\n      throw new TypeError('The given view\\'s buffer has been detached and so cannot be used as a response');\n    }\n\n    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n  respond: { enumerable: true },\n  respondWithNewView: { enumerable: true },\n  view: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBRequest',\n    configurable: true\n  });\n}\n\ninterface ArrayBufferViewConstructor<T extends ArrayBufferView = ArrayBufferView> {\n  new(buffer: ArrayBufferLike, byteOffset: number, length?: number): T;\n\n  readonly prototype: T;\n  readonly BYTES_PER_ELEMENT: number;\n}\n\ninterface ByteQueueElement {\n  buffer: ArrayBufferLike;\n  byteOffset: number;\n  byteLength: number;\n}\n\ntype PullIntoDescriptor<T extends ArrayBufferView = ArrayBufferView> =\n  DefaultPullIntoDescriptor\n  | BYOBPullIntoDescriptor<T>;\n\ninterface DefaultPullIntoDescriptor {\n  buffer: ArrayBufferLike;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<Uint8Array>;\n  readerType: 'default';\n}\n\ninterface BYOBPullIntoDescriptor<T extends ArrayBufferView = ArrayBufferView> {\n  buffer: ArrayBufferLike;\n  bufferByteLength: number;\n  byteOffset: number;\n  byteLength: number;\n  bytesFilled: number;\n  elementSize: number;\n  viewConstructor: ArrayBufferViewConstructor<T>;\n  readerType: 'byob';\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableByteStreamController {\n  /** @internal */\n  _controlledReadableByteStream!: ReadableByteStream;\n  /** @internal */\n  _queue!: SimpleQueue<ByteQueueElement>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n  /** @internal */\n  _autoAllocateChunkSize: number | undefined;\n  /** @internal */\n  _byobRequest: ReadableStreamBYOBRequest | null;\n  /** @internal */\n  _pendingPullIntos!: SimpleQueue<PullIntoDescriptor>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the current BYOB pull request, or `null` if there isn't one.\n   */\n  get byobRequest(): ReadableStreamBYOBRequest | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n\n    return ReadableByteStreamControllerGetBYOBRequest(this);\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableByteStreamControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('close');\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('The stream has already been closed; do not close it again!');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n    }\n\n    ReadableByteStreamControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk chunk in the controlled readable stream.\n   * The chunk has to be an `ArrayBufferView` instance, or else a `TypeError` will be thrown.\n   */\n  enqueue(chunk: ArrayBufferView): void;\n  enqueue(chunk: ArrayBufferView | undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('enqueue');\n    }\n\n    assertRequiredArgument(chunk, 1, 'enqueue');\n    if (!ArrayBuffer.isView(chunk)) {\n      throw new TypeError('chunk must be an array buffer view');\n    }\n    if (chunk.byteLength === 0) {\n      throw new TypeError('chunk must have non-zero byteLength');\n    }\n    if (chunk.buffer.byteLength === 0) {\n      throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n    }\n\n    if (this._closeRequested) {\n      throw new TypeError('stream is closed or draining');\n    }\n\n    const state = this._controlledReadableByteStream._state;\n    if (state !== 'readable') {\n      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n    }\n\n    ReadableByteStreamControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableByteStreamController(this)) {\n      throw byteStreamControllerBrandCheckException('error');\n    }\n\n    ReadableByteStreamControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ReadableByteStreamControllerClearPendingPullIntos(this);\n\n    ResetQueue(this);\n\n    const result = this._cancelAlgorithm(reason);\n    ReadableByteStreamControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<Uint8Array>): void {\n    const stream = this._controlledReadableByteStream;\n    assert(ReadableStreamHasDefaultReader(stream));\n\n    if (this._queueTotalSize > 0) {\n      assert(ReadableStreamGetNumReadRequests(stream) === 0);\n\n      const entry = this._queue.shift()!;\n      this._queueTotalSize -= entry.byteLength;\n\n      ReadableByteStreamControllerHandleQueueDrain(this);\n\n      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n\n      readRequest._chunkSteps(view);\n      return;\n    }\n\n    const autoAllocateChunkSize = this._autoAllocateChunkSize;\n    if (autoAllocateChunkSize !== undefined) {\n      let buffer: ArrayBuffer;\n      try {\n        buffer = new ArrayBuffer(autoAllocateChunkSize);\n      } catch (bufferE) {\n        readRequest._errorSteps(bufferE);\n        return;\n      }\n\n      const pullIntoDescriptor: DefaultPullIntoDescriptor = {\n        buffer,\n        bufferByteLength: autoAllocateChunkSize,\n        byteOffset: 0,\n        byteLength: autoAllocateChunkSize,\n        bytesFilled: 0,\n        elementSize: 1,\n        viewConstructor: Uint8Array,\n        readerType: 'default'\n      };\n\n      this._pendingPullIntos.push(pullIntoDescriptor);\n    }\n\n    ReadableStreamAddReadRequest(stream, readRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(this);\n  }\n}\n\nObject.defineProperties(ReadableByteStreamController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  byobRequest: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {\n    value: 'ReadableByteStreamController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableByteStreamController.\n\nexport function IsReadableByteStreamController(x: any): x is ReadableByteStreamController {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableByteStreamController;\n}\n\nfunction IsReadableStreamBYOBRequest(x: any): x is ReadableStreamBYOBRequest {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBRequest;\n}\n\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller: ReadableByteStreamController): void {\n  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  // TODO: Test controller argument\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableByteStreamControllerError(controller, e);\n    }\n  );\n}\n\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller: ReadableByteStreamController) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n}\n\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor<T extends ArrayBufferView>(\n  stream: ReadableByteStream,\n  pullIntoDescriptor: PullIntoDescriptor<T>\n) {\n  assert(stream._state !== 'errored');\n\n  let done = false;\n  if (stream._state === 'closed') {\n    assert(pullIntoDescriptor.bytesFilled === 0);\n    done = true;\n  }\n\n  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n    ReadableStreamFulfillReadRequest(stream, filledView as unknown as Uint8Array, done);\n  } else {\n    assert(pullIntoDescriptor.readerType === 'byob');\n    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n}\n\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor<T extends ArrayBufferView>(\n  pullIntoDescriptor: PullIntoDescriptor<T>\n): T {\n  const bytesFilled = pullIntoDescriptor.bytesFilled;\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  assert(bytesFilled <= pullIntoDescriptor.byteLength);\n  assert(bytesFilled % elementSize === 0);\n\n  return new pullIntoDescriptor.viewConstructor(\n    pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize) as T;\n}\n\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller: ReadableByteStreamController,\n                                                         buffer: ArrayBufferLike,\n                                                         byteOffset: number,\n                                                         byteLength: number) {\n  controller._queue.push({ buffer, byteOffset, byteLength });\n  controller._queueTotalSize += byteLength;\n}\n\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller: ReadableByteStreamController,\n                                                                     pullIntoDescriptor: PullIntoDescriptor) {\n  const elementSize = pullIntoDescriptor.elementSize;\n\n  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n\n  const maxBytesToCopy = Math.min(controller._queueTotalSize,\n                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n\n  let totalBytesToCopyRemaining = maxBytesToCopy;\n  let ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n    ready = true;\n  }\n\n  const queue = controller._queue;\n\n  while (totalBytesToCopyRemaining > 0) {\n    const headOfQueue = queue.peek();\n\n    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n\n    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n    if (headOfQueue.byteLength === bytesToCopy) {\n      queue.shift();\n    } else {\n      headOfQueue.byteOffset += bytesToCopy;\n      headOfQueue.byteLength -= bytesToCopy;\n    }\n    controller._queueTotalSize -= bytesToCopy;\n\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n\n    totalBytesToCopyRemaining -= bytesToCopy;\n  }\n\n  if (!ready) {\n    assert(controller._queueTotalSize === 0);\n    assert(pullIntoDescriptor.bytesFilled > 0);\n    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);\n  }\n\n  return ready;\n}\n\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller: ReadableByteStreamController,\n                                                                size: number,\n                                                                pullIntoDescriptor: PullIntoDescriptor) {\n  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos.peek() === pullIntoDescriptor);\n  assert(controller._byobRequest === null);\n  pullIntoDescriptor.bytesFilled += size;\n}\n\nfunction ReadableByteStreamControllerHandleQueueDrain(controller: ReadableByteStreamController) {\n  assert(controller._controlledReadableByteStream._state === 'readable');\n\n  if (controller._queueTotalSize === 0 && controller._closeRequested) {\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n}\n\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller: ReadableByteStreamController) {\n  if (controller._byobRequest === null) {\n    return;\n  }\n\n  controller._byobRequest._associatedReadableByteStreamController = undefined!;\n  controller._byobRequest._view = null!;\n  controller._byobRequest = null;\n}\n\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller: ReadableByteStreamController) {\n  assert(!controller._closeRequested);\n\n  while (controller._pendingPullIntos.length > 0) {\n    if (controller._queueTotalSize === 0) {\n      return;\n    }\n\n    const pullIntoDescriptor = controller._pendingPullIntos.peek();\n\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n      ReadableByteStreamControllerCommitPullIntoDescriptor(\n        controller._controlledReadableByteStream,\n        pullIntoDescriptor\n      );\n    }\n  }\n}\n\nexport function ReadableByteStreamControllerPullInto<T extends ArrayBufferView>(\n  controller: ReadableByteStreamController,\n  view: T,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = controller._controlledReadableByteStream;\n\n  let elementSize = 1;\n  if (view.constructor !== DataView) {\n    elementSize = (view.constructor as ArrayBufferViewConstructor<T>).BYTES_PER_ELEMENT;\n  }\n\n  const ctor = view.constructor as ArrayBufferViewConstructor<T>;\n\n  // try {\n  const buffer = TransferArrayBuffer(view.buffer);\n  // } catch (e) {\n  //   readIntoRequest._errorSteps(e);\n  //   return;\n  // }\n\n  const pullIntoDescriptor: BYOBPullIntoDescriptor<T> = {\n    buffer,\n    bufferByteLength: buffer.byteLength,\n    byteOffset: view.byteOffset,\n    byteLength: view.byteLength,\n    bytesFilled: 0,\n    elementSize,\n    viewConstructor: ctor,\n    readerType: 'byob'\n  };\n\n  if (controller._pendingPullIntos.length > 0) {\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n    // - No change happens on desiredSize\n    // - The source has already been notified of that there's at least 1 pending read(view)\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    return;\n  }\n\n  if (stream._state === 'closed') {\n    const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n    readIntoRequest._closeSteps(emptyView);\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor<T>(pullIntoDescriptor);\n\n      ReadableByteStreamControllerHandleQueueDrain(controller);\n\n      readIntoRequest._chunkSteps(filledView);\n      return;\n    }\n\n    if (controller._closeRequested) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      readIntoRequest._errorSteps(e);\n      return;\n    }\n  }\n\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n\n  ReadableStreamAddReadIntoRequest<T>(stream, readIntoRequest);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInClosedState(controller: ReadableByteStreamController,\n                                                          firstDescriptor: PullIntoDescriptor) {\n  assert(firstDescriptor.bytesFilled === 0);\n\n  const stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream)) {\n    while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n      ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n    }\n  }\n}\n\nfunction ReadableByteStreamControllerRespondInReadableState(controller: ReadableByteStreamController,\n                                                            bytesWritten: number,\n                                                            pullIntoDescriptor: PullIntoDescriptor) {\n  assert(pullIntoDescriptor.bytesFilled + bytesWritten <= pullIntoDescriptor.byteLength);\n\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n    return;\n  }\n\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n\n  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n    const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\n\nfunction ReadableByteStreamControllerRespondInternal(controller: ReadableByteStreamController, bytesWritten: number) {\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  assert(CanTransferArrayBuffer(firstDescriptor.buffer));\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  const state = controller._controlledReadableByteStream._state;\n  if (state === 'closed') {\n    assert(bytesWritten === 0);\n    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n    assert(state === 'readable');\n    assert(bytesWritten > 0);\n    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nfunction ReadableByteStreamControllerShiftPendingPullInto(\n  controller: ReadableByteStreamController\n): PullIntoDescriptor {\n  assert(controller._byobRequest === null);\n  const descriptor = controller._pendingPullIntos.shift()!;\n  return descriptor;\n}\n\nfunction ReadableByteStreamControllerShouldCallPull(controller: ReadableByteStreamController): boolean {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return false;\n  }\n\n  if (controller._closeRequested) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableByteStreamControllerClearAlgorithms(controller: ReadableByteStreamController) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n}\n\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\nexport function ReadableByteStreamControllerClose(controller: ReadableByteStreamController) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  if (controller._queueTotalSize > 0) {\n    controller._closeRequested = true;\n\n    return;\n  }\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (firstPendingPullInto.bytesFilled > 0) {\n      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n      ReadableByteStreamControllerError(controller, e);\n\n      throw e;\n    }\n  }\n\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n}\n\nexport function ReadableByteStreamControllerEnqueue(controller: ReadableByteStreamController, chunk: ArrayBufferView) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (controller._closeRequested || stream._state !== 'readable') {\n    return;\n  }\n\n  const buffer = chunk.buffer;\n  const byteOffset = chunk.byteOffset;\n  const byteLength = chunk.byteLength;\n  if (IsDetachedBuffer(buffer)) {\n    throw new TypeError('chunk\\'s buffer is detached and so cannot be enqueued');\n  }\n  const transferredBuffer = TransferArrayBuffer(buffer);\n\n  if (controller._pendingPullIntos.length > 0) {\n    const firstPendingPullInto = controller._pendingPullIntos.peek();\n    if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n      throw new TypeError(\n        'The BYOB request\\'s buffer has been detached and so cannot be filled with an enqueued chunk'\n      );\n    }\n    firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n  }\n\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n  if (ReadableStreamHasDefaultReader(stream)) {\n    if (ReadableStreamGetNumReadRequests(stream) === 0) {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    } else {\n      assert(controller._queue.length === 0);\n\n      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n      ReadableStreamFulfillReadRequest(stream, transferredView, false);\n    }\n  } else if (ReadableStreamHasBYOBReader(stream)) {\n    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n    assert(!IsReadableStreamLocked(stream));\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableByteStreamControllerError(controller: ReadableByteStreamController, e: any) {\n  const stream = controller._controlledReadableByteStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableByteStreamControllerGetBYOBRequest(\n  controller: ReadableByteStreamController\n): ReadableStreamBYOBRequest | null {\n  if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const view = new Uint8Array(firstDescriptor.buffer,\n                                firstDescriptor.byteOffset + firstDescriptor.bytesFilled,\n                                firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n\n    const byobRequest: ReadableStreamBYOBRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n    SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n    controller._byobRequest = byobRequest;\n  }\n  return controller._byobRequest;\n}\n\nfunction ReadableByteStreamControllerGetDesiredSize(controller: ReadableByteStreamController): number | null {\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nexport function ReadableByteStreamControllerRespond(controller: ReadableByteStreamController, bytesWritten: number) {\n  assert(controller._pendingPullIntos.length > 0);\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (bytesWritten !== 0) {\n      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (bytesWritten === 0) {\n      throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n    }\n    if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n      throw new RangeError('bytesWritten out of range');\n    }\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\n\nexport function ReadableByteStreamControllerRespondWithNewView(controller: ReadableByteStreamController,\n                                                               view: ArrayBufferView) {\n  assert(controller._pendingPullIntos.length > 0);\n  assert(!IsDetachedBuffer(view.buffer));\n\n  const firstDescriptor = controller._pendingPullIntos.peek();\n  const state = controller._controlledReadableByteStream._state;\n\n  if (state === 'closed') {\n    if (view.byteLength !== 0) {\n      throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n    }\n  } else {\n    assert(state === 'readable');\n    if (view.byteLength === 0) {\n      throw new TypeError(\n        'The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream'\n      );\n    }\n  }\n\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n    throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n    throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n    throw new RangeError('The region specified by view is larger than byobRequest');\n  }\n\n  firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\n\nexport function SetUpReadableByteStreamController(stream: ReadableByteStream,\n                                                  controller: ReadableByteStreamController,\n                                                  startAlgorithm: () => void | PromiseLike<void>,\n                                                  pullAlgorithm: () => Promise<void>,\n                                                  cancelAlgorithm: (reason: any) => Promise<void>,\n                                                  highWaterMark: number,\n                                                  autoAllocateChunkSize: number | undefined) {\n  assert(stream._readableStreamController === undefined);\n  if (autoAllocateChunkSize !== undefined) {\n    assert(NumberIsInteger(autoAllocateChunkSize));\n    assert(autoAllocateChunkSize > 0);\n  }\n\n  controller._controlledReadableByteStream = stream;\n\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._byobRequest = null;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._closeRequested = false;\n  controller._started = false;\n\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n\n  controller._pendingPullIntos = new SimpleQueue();\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableByteStreamControllerError(controller, r);\n    }\n  );\n}\n\nexport function SetUpReadableByteStreamControllerFromUnderlyingSource(\n  stream: ReadableByteStream,\n  underlyingByteSource: ValidatedUnderlyingByteSource,\n  highWaterMark: number\n) {\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let pullAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let cancelAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingByteSource.start !== undefined) {\n    startAlgorithm = () => underlyingByteSource.start!(controller);\n  }\n  if (underlyingByteSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingByteSource.pull!(controller);\n  }\n  if (underlyingByteSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingByteSource.cancel!(reason);\n  }\n\n  const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize === 0) {\n    throw new TypeError('autoAllocateChunkSize must be greater than 0');\n  }\n\n  SetUpReadableByteStreamController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize\n  );\n}\n\nfunction SetUpReadableStreamBYOBRequest(request: ReadableStreamBYOBRequest,\n                                        controller: ReadableByteStreamController,\n                                        view: ArrayBufferView) {\n  assert(IsReadableByteStreamController(controller));\n  assert(typeof view === 'object');\n  assert(ArrayBuffer.isView(view));\n  assert(!IsDetachedBuffer(view.buffer));\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n}\n\n// Helper functions for the ReadableStreamBYOBRequest.\n\nfunction byobRequestBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n\n// Helper functions for the ReadableByteStreamController.\n\nfunction byteStreamControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n", "import assert from '../../stub/assert';\nimport { SimpleQueue } from '../simple-queue';\nimport {\n  ReadableStreamReaderGenericCancel,\n  ReadableStreamReaderGenericInitialize,\n  ReadableStreamReaderGenericRelease,\n  readerLockException\n} from './generic-reader';\nimport { IsReadableStreamLocked, ReadableByteStream, ReadableStream } from '../readable-stream';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamController,\n  ReadableByteStreamControllerPullInto\n} from './byte-stream-controller';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { newPromise, promiseRejectedWith } from '../helpers/webidl';\nimport { assertRequiredArgument } from '../validators/basic';\nimport { assertReadableStream } from '../validators/readable-stream';\nimport { IsDetachedBuffer } from '../abstract-ops/ecmascript';\n\n/**\n * A result returned by {@link ReadableStreamBYOBReader.read}.\n *\n * @public\n */\nexport type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {\n  done: false;\n  value: T;\n} | {\n  done: true;\n  value: T | undefined;\n};\n\n// Abstract operations for the ReadableStream.\n\nexport function AcquireReadableStreamBYOBReader(stream: ReadableByteStream): ReadableStreamBYOBReader {\n  return new ReadableStreamBYOBReader(stream);\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamAddReadIntoRequest<T extends ArrayBufferView>(stream: ReadableByteStream,\n                                                                            readIntoRequest: ReadIntoRequest<T>): void {\n  assert(IsReadableStreamBYOBReader(stream._reader));\n  assert(stream._state === 'readable' || stream._state === 'closed');\n\n  (stream._reader! as ReadableStreamBYOBReader)._readIntoRequests.push(readIntoRequest);\n}\n\nexport function ReadableStreamFulfillReadIntoRequest(stream: ReadableByteStream,\n                                                     chunk: ArrayBufferView,\n                                                     done: boolean) {\n  const reader = stream._reader as ReadableStreamBYOBReader;\n\n  assert(reader._readIntoRequests.length > 0);\n\n  const readIntoRequest = reader._readIntoRequests.shift()!;\n  if (done) {\n    readIntoRequest._closeSteps(chunk);\n  } else {\n    readIntoRequest._chunkSteps(chunk);\n  }\n}\n\nexport function ReadableStreamGetNumReadIntoRequests(stream: ReadableByteStream): number {\n  return (stream._reader as ReadableStreamBYOBReader)._readIntoRequests.length;\n}\n\nexport function ReadableStreamHasBYOBReader(stream: ReadableByteStream): boolean {\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return false;\n  }\n\n  if (!IsReadableStreamBYOBReader(reader)) {\n    return false;\n  }\n\n  return true;\n}\n\n// Readers\n\nexport interface ReadIntoRequest<T extends ArrayBufferView> {\n  _chunkSteps(chunk: T): void;\n\n  _closeSteps(chunk: T | undefined): void;\n\n  _errorSteps(e: any): void;\n}\n\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nexport class ReadableStreamBYOBReader {\n  /** @internal */\n  _ownerReadableStream!: ReadableByteStream;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readIntoRequests: SimpleQueue<ReadIntoRequest<any>>;\n\n  constructor(stream: ReadableByteStream) {\n    assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n    assertReadableStream(stream, 'First parameter');\n\n    if (IsReadableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n    }\n\n    if (!IsReadableByteStreamController(stream._readableStreamController)) {\n      throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n        'source');\n    }\n\n    ReadableStreamReaderGenericInitialize(this, stream);\n\n    this._readIntoRequests = new SimpleQueue();\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the reader's lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('cancel'));\n    }\n\n    return ReadableStreamReaderGenericCancel(this, reason);\n  }\n\n  /**\n   * Attempts to reads bytes into view, and returns a promise resolved with the result.\n   *\n   * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n   */\n  read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamBYOBReadResult<T>> {\n    if (!IsReadableStreamBYOBReader(this)) {\n      return promiseRejectedWith(byobReaderBrandCheckException('read'));\n    }\n\n    if (!ArrayBuffer.isView(view)) {\n      return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n    }\n    if (view.byteLength === 0) {\n      return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n    }\n    if (view.buffer.byteLength === 0) {\n      return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n    }\n    if (IsDetachedBuffer(view.buffer)) {\n      return promiseRejectedWith(new TypeError('view\\'s buffer has been detached'));\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return promiseRejectedWith(readerLockException('read from'));\n    }\n\n    let resolvePromise!: (result: ReadableStreamBYOBReadResult<T>) => void;\n    let rejectPromise!: (reason: any) => void;\n    const promise = newPromise<ReadableStreamBYOBReadResult<T>>((resolve, reject) => {\n      resolvePromise = resolve;\n      rejectPromise = reject;\n    });\n    const readIntoRequest: ReadIntoRequest<T> = {\n      _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n      _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n      _errorSteps: e => rejectPromise(e)\n    };\n    ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n    return promise;\n  }\n\n  /**\n   * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n   * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n   * from now on; otherwise, the reader will appear closed.\n   *\n   * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n   * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n   * do so will throw a `TypeError` and leave the reader locked to the stream.\n   */\n  releaseLock(): void {\n    if (!IsReadableStreamBYOBReader(this)) {\n      throw byobReaderBrandCheckException('releaseLock');\n    }\n\n    if (this._ownerReadableStream === undefined) {\n      return;\n    }\n\n    if (this._readIntoRequests.length > 0) {\n      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n    }\n\n    ReadableStreamReaderGenericRelease(this);\n  }\n}\n\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n  cancel: { enumerable: true },\n  read: { enumerable: true },\n  releaseLock: { enumerable: true },\n  closed: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamBYOBReader',\n    configurable: true\n  });\n}\n\n// Abstract operations for the readers.\n\nexport function IsReadableStreamBYOBReader(x: any): x is ReadableStreamBYOBReader {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamBYOBReader;\n}\n\nexport function ReadableStreamBYOBReaderRead<T extends ArrayBufferView>(\n  reader: ReadableStreamBYOBReader,\n  view: T,\n  readIntoRequest: ReadIntoRequest<T>\n): void {\n  const stream = reader._ownerReadableStream;\n\n  assert(stream !== undefined);\n\n  stream._disturbed = true;\n\n  if (stream._state === 'errored') {\n    readIntoRequest._errorSteps(stream._storedError);\n  } else {\n    ReadableByteStreamControllerPullInto(\n      stream._readableStreamController as ReadableByteStreamController,\n      view,\n      readIntoRequest\n    );\n  }\n}\n\n// Helper functions for the ReadableStreamBYOBReader.\n\nfunction byobReaderBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n", "import { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport NumberIsNaN from '../../stub/number-isnan';\n\nexport function ExtractHighWaterMark(strategy: QueuingStrategy, defaultHWM: number): number {\n  const { highWaterMark } = strategy;\n\n  if (highWaterMark === undefined) {\n    return defaultHWM;\n  }\n\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n    throw new RangeError('Invalid highWaterMark');\n  }\n\n  return highWaterMark;\n}\n\nexport function ExtractSizeAlgorithm<T>(strategy: QueuingStrategy<T>): QueuingStrategySizeCallback<T> {\n  const { size } = strategy;\n\n  if (!size) {\n    return () => 1;\n  }\n\n  return size;\n}\n", "import { QueuingStrategy, QueuingStrategySizeCallback } from '../queuing-strategy';\nimport { assertDictionary, assertFunction, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategy<T>(init: QueuingStrategy<T> | null | undefined,\n                                          context: string): QueuingStrategy<T> {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  const size = init?.size;\n  return {\n    highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n    size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n  };\n}\n\nfunction convertQueuingStrategySize<T>(fn: QueuingStrategySizeCallback<T>,\n                                       context: string): QueuingStrategySizeCallback<T> {\n  assertFunction(fn, context);\n  return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from '../writable-stream/underlying-sink';\nimport { WritableStreamDefaultController } from '../writable-stream';\n\nexport function convertUnderlyingSink<W>(original: UnderlyingSink<W> | null,\n                                         context: string): ValidatedUnderlyingSink<W> {\n  assertDictionary(original, context);\n  const abort = original?.abort;\n  const close = original?.close;\n  const start = original?.start;\n  const type = original?.type;\n  const write = original?.write;\n  return {\n    abort: abort === undefined ?\n      undefined :\n      convertUnderlyingSinkAbortCallback(abort, original!, `${context} has member 'abort' that`),\n    close: close === undefined ?\n      undefined :\n      convertUnderlyingSinkCloseCallback(close, original!, `${context} has member 'close' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSinkStartCallback(start, original!, `${context} has member 'start' that`),\n    write: write === undefined ?\n      undefined :\n      convertUnderlyingSinkWriteCallback(write, original!, `${context} has member 'write' that`),\n    type\n  };\n}\n\nfunction convertUnderlyingSinkAbortCallback(\n  fn: UnderlyingSinkAbortCallback,\n  original: UnderlyingSink,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSinkCloseCallback(\n  fn: UnderlyingSinkCloseCallback,\n  original: UnderlyingSink,\n  context: string\n): () => Promise<void> {\n  assertFunction(fn, context);\n  return () => promiseCall(fn, original, []);\n}\n\nfunction convertUnderlyingSinkStartCallback(\n  fn: UnderlyingSinkStartCallback,\n  original: UnderlyingSink,\n  context: string\n): UnderlyingSinkStartCallback {\n  assertFunction(fn, context);\n  return (controller: WritableStreamDefaultController) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSinkWriteCallback<W>(\n  fn: UnderlyingSinkWriteCallback<W>,\n  original: UnderlyingSink<W>,\n  context: string\n): (chunk: W, controller: WritableStreamDefaultController) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: W, controller: WritableStreamDefaultController) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import { IsWritableStream, WritableStream } from '../writable-stream';\n\nexport function assertWritableStream(x: unknown, context: string): asserts x is WritableStream {\n  if (!IsWritableStream(x)) {\n    throw new TypeError(`${context} is not a WritableStream.`);\n  }\n}\n", "/**\n * A signal object that allows you to communicate with a request and abort it if required\n * via its associated `AbortController` object.\n *\n * @remarks\n *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @public\n */\nexport interface AbortSignal {\n  /**\n   * Whether the request is aborted.\n   */\n  readonly aborted: boolean;\n\n  /**\n   * Add an event listener to be triggered when this signal becomes aborted.\n   */\n  addEventListener(type: 'abort', listener: () => void): void;\n\n  /**\n   * Remove an event listener that was previously added with {@link AbortSignal.addEventListener}.\n   */\n  removeEventListener(type: 'abort', listener: () => void): void;\n}\n\nexport function isAbortSignal(value: unknown): value is AbortSignal {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n  try {\n    return typeof (value as AbortSignal).aborted === 'boolean';\n  } catch {\n    // AbortSignal.prototype.aborted throws if its brand check fails\n    return false;\n  }\n}\n\n/**\n * A controller object that allows you to abort an `AbortSignal` when desired.\n *\n * @remarks\n *   This interface is compatible with the `AbortController` interface defined in TypeScript's DOM types.\n *   It is redefined here, so it can be polyfilled without a DOM, for example with\n *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.\n *\n * @internal\n */\nexport interface AbortController {\n  readonly signal: AbortSignal;\n\n  abort(): void;\n}\n\ninterface AbortControllerConstructor {\n  new(): AbortController;\n}\n\nconst supportsAbortController = typeof (AbortController as any) === 'function';\n\n/**\n * Construct a new AbortController, if supported by the platform.\n *\n * @internal\n */\nexport function createAbortController(): AbortController | undefined {\n  if (supportsAbortController) {\n    return new (AbortController as AbortControllerConstructor)();\n  }\n  return undefined;\n}\n", "import assert from '../stub/assert';\nimport {\n  newPromise,\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponPromise\n} from './helpers/webidl';\nimport {\n  DequeueValue,\n  EnqueueValueWithSize,\n  PeekQueueValue,\n  QueuePair,\n  ResetQueue\n} from './abstract-ops/queue-with-sizes';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { SimpleQueue } from './simple-queue';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { AbortSteps, ErrorSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport {\n  UnderlyingSink,\n  UnderlyingSinkAbortCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  ValidatedUnderlyingSink\n} from './writable-stream/underlying-sink';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertUnderlyingSink } from './validators/underlying-sink';\nimport { assertWritableStream } from './validators/writable-stream';\nimport { AbortController, AbortSignal, createAbortController } from './abort-signal';\n\ntype WritableStreamState = 'writable' | 'closed' | 'erroring' | 'errored';\n\ninterface WriteOrCloseRequest {\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n}\n\ntype WriteRequest = WriteOrCloseRequest;\ntype CloseRequest = WriteOrCloseRequest;\n\ninterface PendingAbortRequest {\n  _promise: Promise<undefined>;\n  _resolve: (value?: undefined) => void;\n  _reject: (reason: any) => void;\n  _reason: any;\n  _wasAlreadyErroring: boolean;\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream<W = any> {\n  /** @internal */\n  _state!: WritableStreamState;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _writer: WritableStreamDefaultWriter<W> | undefined;\n  /** @internal */\n  _writableStreamController!: WritableStreamDefaultController<W>;\n  /** @internal */\n  _writeRequests!: SimpleQueue<WriteRequest>;\n  /** @internal */\n  _inFlightWriteRequest: WriteRequest | undefined;\n  /** @internal */\n  _closeRequest: CloseRequest | undefined;\n  /** @internal */\n  _inFlightCloseRequest: CloseRequest | undefined;\n  /** @internal */\n  _pendingAbortRequest: PendingAbortRequest | undefined;\n  /** @internal */\n  _backpressure!: boolean;\n\n  constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);\n  constructor(rawUnderlyingSink: UnderlyingSink<W> | null | undefined = {},\n              rawStrategy: QueuingStrategy<W> | null | undefined = {}) {\n    if (rawUnderlyingSink === undefined) {\n      rawUnderlyingSink = null;\n    } else {\n      assertObject(rawUnderlyingSink, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n\n    InitializeWritableStream(this);\n\n    const type = underlyingSink.type;\n    if (type !== undefined) {\n      throw new RangeError('Invalid type is specified');\n    }\n\n    const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n    const highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n    SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n\n  /**\n   * Returns whether or not the writable stream is locked to a writer.\n   */\n  get locked(): boolean {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsWritableStreamLocked(this);\n  }\n\n  /**\n   * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n   * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n   * mechanism of the underlying sink.\n   *\n   * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n   * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n   * the stream) if the stream is currently locked.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('abort'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n    }\n\n    return WritableStreamAbort(this, reason);\n  }\n\n  /**\n   * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n   * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n   *\n   * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n   * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n   * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n   */\n  close() {\n    if (!IsWritableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('close'));\n    }\n\n    if (IsWritableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(this)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamClose(this);\n  }\n\n  /**\n   * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n   * is locked, no other writer can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n   * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n   * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n   */\n  getWriter(): WritableStreamDefaultWriter<W> {\n    if (!IsWritableStream(this)) {\n      throw streamBrandCheckException('getWriter');\n    }\n\n    return AcquireWritableStreamDefaultWriter(this);\n  }\n}\n\nObject.defineProperties(WritableStream.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  getWriter: { enumerable: true },\n  locked: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {\n    value: 'WritableStream',\n    configurable: true\n  });\n}\n\nexport {\n  AcquireWritableStreamDefaultWriter,\n  CreateWritableStream,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamDefaultControllerErrorIfNeeded,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite,\n  WritableStreamCloseQueuedOrInFlight,\n  UnderlyingSink,\n  UnderlyingSinkStartCallback,\n  UnderlyingSinkWriteCallback,\n  UnderlyingSinkCloseCallback,\n  UnderlyingSinkAbortCallback\n};\n\n// Abstract operations for the WritableStream.\n\nfunction AcquireWritableStreamDefaultWriter<W>(stream: WritableStream<W>): WritableStreamDefaultWriter<W> {\n  return new WritableStreamDefaultWriter(stream);\n}\n\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream<W>(startAlgorithm: () => void | PromiseLike<void>,\n                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                 closeAlgorithm: () => Promise<void>,\n                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                 highWaterMark = 1,\n                                 sizeAlgorithm: QueuingStrategySizeCallback<W> = () => 1) {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: WritableStream<W> = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n\n  const controller: WritableStreamDefaultController<W> = Object.create(WritableStreamDefaultController.prototype);\n\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm,\n                                       abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n}\n\nfunction InitializeWritableStream<W>(stream: WritableStream<W>) {\n  stream._state = 'writable';\n\n  // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n  // 'erroring' or 'errored'. May be set to an undefined value.\n  stream._storedError = undefined;\n\n  stream._writer = undefined;\n\n  // Initialize to undefined first because the constructor of the controller checks this\n  // variable to validate the caller.\n  stream._writableStreamController = undefined!;\n\n  // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n  // producer without waiting for the queued writes to finish.\n  stream._writeRequests = new SimpleQueue();\n\n  // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n  // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n  stream._inFlightWriteRequest = undefined;\n\n  // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n  // has been detached.\n  stream._closeRequest = undefined;\n\n  // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n  // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n  stream._inFlightCloseRequest = undefined;\n\n  // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n  stream._pendingAbortRequest = undefined;\n\n  // The backpressure signal set by the controller.\n  stream._backpressure = false;\n}\n\nfunction IsWritableStream(x: unknown): x is WritableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n    return false;\n  }\n\n  return x instanceof WritableStream;\n}\n\nfunction IsWritableStreamLocked(stream: WritableStream): boolean {\n  assert(IsWritableStream(stream));\n\n  if (stream._writer === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamAbort(stream: WritableStream, reason: any): Promise<undefined> {\n  if (stream._state === 'closed' || stream._state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  stream._writableStreamController._abortReason = reason;\n  stream._writableStreamController._abortController?.abort();\n\n  // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n  // but it doesn't know that signaling abort runs author code that might have changed the state.\n  // Widen the type again by casting to WritableStreamState.\n  const state = stream._state as WritableStreamState;\n\n  if (state === 'closed' || state === 'errored') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n    return stream._pendingAbortRequest._promise;\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  let wasAlreadyErroring = false;\n  if (state === 'erroring') {\n    wasAlreadyErroring = true;\n    // reason will not be used, so don't keep a reference to it.\n    reason = undefined;\n  }\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    stream._pendingAbortRequest = {\n      _promise: undefined!,\n      _resolve: resolve,\n      _reject: reject,\n      _reason: reason,\n      _wasAlreadyErroring: wasAlreadyErroring\n    };\n  });\n  stream._pendingAbortRequest!._promise = promise;\n\n  if (!wasAlreadyErroring) {\n    WritableStreamStartErroring(stream, reason);\n  }\n\n  return promise;\n}\n\nfunction WritableStreamClose(stream: WritableStream<any>): Promise<undefined> {\n  const state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n    return promiseRejectedWith(new TypeError(\n      `The stream (in ${state} state) is not in the writable state and cannot be closed`));\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const closeRequest: CloseRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._closeRequest = closeRequest;\n  });\n\n  const writer = stream._writer;\n  if (writer !== undefined && stream._backpressure && state === 'writable') {\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n\n  return promise;\n}\n\n// WritableStream API exposed for controllers.\n\nfunction WritableStreamAddWriteRequest(stream: WritableStream): Promise<undefined> {\n  assert(IsWritableStreamLocked(stream));\n  assert(stream._state === 'writable');\n\n  const promise = newPromise<undefined>((resolve, reject) => {\n    const writeRequest: WriteRequest = {\n      _resolve: resolve,\n      _reject: reject\n    };\n\n    stream._writeRequests.push(writeRequest);\n  });\n\n  return promise;\n}\n\nfunction WritableStreamDealWithRejection(stream: WritableStream, error: any) {\n  const state = stream._state;\n\n  if (state === 'writable') {\n    WritableStreamStartErroring(stream, error);\n    return;\n  }\n\n  assert(state === 'erroring');\n  WritableStreamFinishErroring(stream);\n}\n\nfunction WritableStreamStartErroring(stream: WritableStream, reason: any) {\n  assert(stream._storedError === undefined);\n  assert(stream._state === 'writable');\n\n  const controller = stream._writableStreamController;\n  assert(controller !== undefined);\n\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n\n  if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n    WritableStreamFinishErroring(stream);\n  }\n}\n\nfunction WritableStreamFinishErroring(stream: WritableStream) {\n  assert(stream._state === 'erroring');\n  assert(!WritableStreamHasOperationMarkedInFlight(stream));\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n\n  const storedError = stream._storedError;\n  stream._writeRequests.forEach(writeRequest => {\n    writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n\n  if (stream._pendingAbortRequest === undefined) {\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n\n  if (abortRequest._wasAlreadyErroring) {\n    abortRequest._reject(storedError);\n    WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    return;\n  }\n\n  const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(\n    promise,\n    () => {\n      abortRequest._resolve();\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    },\n    (reason: any) => {\n      abortRequest._reject(reason);\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\n\nfunction WritableStreamFinishInFlightWrite(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n}\n\nfunction WritableStreamFinishInFlightWriteWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightWriteRequest !== undefined);\n  stream._inFlightWriteRequest!._reject(error);\n  stream._inFlightWriteRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  WritableStreamDealWithRejection(stream, error);\n}\n\nfunction WritableStreamFinishInFlightClose(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n\n  const state = stream._state;\n\n  assert(state === 'writable' || state === 'erroring');\n\n  if (state === 'erroring') {\n    // The error was too late to do anything, so it is ignored.\n    stream._storedError = undefined;\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._resolve();\n      stream._pendingAbortRequest = undefined;\n    }\n  }\n\n  stream._state = 'closed';\n\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  assert(stream._pendingAbortRequest === undefined);\n  assert(stream._storedError === undefined);\n}\n\nfunction WritableStreamFinishInFlightCloseWithError(stream: WritableStream, error: any) {\n  assert(stream._inFlightCloseRequest !== undefined);\n  stream._inFlightCloseRequest!._reject(error);\n  stream._inFlightCloseRequest = undefined;\n\n  assert(stream._state === 'writable' || stream._state === 'erroring');\n\n  // Never execute sink abort() after sink close().\n  if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._reject(error);\n    stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n}\n\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream: WritableStream): boolean {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamHasOperationMarkedInFlight(stream: WritableStream): boolean {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction WritableStreamMarkCloseRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightCloseRequest === undefined);\n  assert(stream._closeRequest !== undefined);\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n}\n\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream: WritableStream) {\n  assert(stream._inFlightWriteRequest === undefined);\n  assert(stream._writeRequests.length !== 0);\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\n\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream: WritableStream) {\n  assert(stream._state === 'errored');\n  if (stream._closeRequest !== undefined) {\n    assert(stream._inFlightCloseRequest === undefined);\n\n    stream._closeRequest._reject(stream._storedError);\n    stream._closeRequest = undefined;\n  }\n  const writer = stream._writer;\n  if (writer !== undefined) {\n    defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n}\n\nfunction WritableStreamUpdateBackpressure(stream: WritableStream, backpressure: boolean) {\n  assert(stream._state === 'writable');\n  assert(!WritableStreamCloseQueuedOrInFlight(stream));\n\n  const writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n    if (backpressure) {\n      defaultWriterReadyPromiseReset(writer);\n    } else {\n      assert(!backpressure);\n\n      defaultWriterReadyPromiseResolve(writer);\n    }\n  }\n\n  stream._backpressure = backpressure;\n}\n\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nexport class WritableStreamDefaultWriter<W = any> {\n  /** @internal */\n  _ownerWritableStream: WritableStream<W>;\n  /** @internal */\n  _closedPromise!: Promise<undefined>;\n  /** @internal */\n  _closedPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _closedPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _closedPromiseState!: 'pending' | 'resolved' | 'rejected';\n  /** @internal */\n  _readyPromise!: Promise<undefined>;\n  /** @internal */\n  _readyPromise_resolve?: (value?: undefined) => void;\n  /** @internal */\n  _readyPromise_reject?: (reason: any) => void;\n  /** @internal */\n  _readyPromiseState!: 'pending' | 'fulfilled' | 'rejected';\n\n  constructor(stream: WritableStream<W>) {\n    assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n    assertWritableStream(stream, 'First parameter');\n\n    if (IsWritableStreamLocked(stream)) {\n      throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n    }\n\n    this._ownerWritableStream = stream;\n    stream._writer = this;\n\n    const state = stream._state;\n\n    if (state === 'writable') {\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n        defaultWriterReadyPromiseInitialize(this);\n      } else {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n      }\n\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'erroring') {\n      defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n      defaultWriterClosedPromiseInitialize(this);\n    } else if (state === 'closed') {\n      defaultWriterReadyPromiseInitializeAsResolved(this);\n      defaultWriterClosedPromiseInitializeAsResolved(this);\n    } else {\n      assert(state === 'errored');\n\n      const storedError = stream._storedError;\n      defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n      defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n    }\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n   * the writer\u2019s lock is released before the stream finishes closing.\n   */\n  get closed(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n\n    return this._closedPromise;\n  }\n\n  /**\n   * Returns the desired size to fill the stream\u2019s internal queue. It can be negative, if the queue is over-full.\n   * A producer can use this information to determine the right amount of data to write.\n   *\n   * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n   * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n   * the writer\u2019s lock is released.\n   */\n  get desiredSize(): number | null {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('desiredSize');\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      throw defaultWriterLockException('desiredSize');\n    }\n\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n  }\n\n  /**\n   * Returns a promise that will be fulfilled when the desired size to fill the stream\u2019s internal queue transitions\n   * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n   * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n   *\n   * If the stream becomes errored or aborted, or the writer\u2019s lock is released, the returned promise will become\n   * rejected.\n   */\n  get ready(): Promise<undefined> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n\n    return this._readyPromise;\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n   */\n  abort(reason: any = undefined): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('abort'));\n    }\n\n    return WritableStreamDefaultWriterAbort(this, reason);\n  }\n\n  /**\n   * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n   */\n  close(): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('close'));\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream)) {\n      return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n    }\n\n    return WritableStreamDefaultWriterClose(this);\n  }\n\n  /**\n   * Releases the writer\u2019s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n   * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n   * now on; otherwise, the writer will appear closed.\n   *\n   * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n   * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n   * It\u2019s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n   * other producers from writing in an interleaved manner.\n   */\n  releaseLock(): void {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      throw defaultWriterBrandCheckException('releaseLock');\n    }\n\n    const stream = this._ownerWritableStream;\n\n    if (stream === undefined) {\n      return;\n    }\n\n    assert(stream._writer !== undefined);\n\n    WritableStreamDefaultWriterRelease(this);\n  }\n\n  /**\n   * Writes the given chunk to the writable stream, by waiting until any previous writes have finished successfully,\n   * and then sending the chunk to the underlying sink's {@link UnderlyingSink.write | write()} method. It will return\n   * a promise that fulfills with undefined upon a successful write, or rejects if the write fails or stream becomes\n   * errored before the writing process is initiated.\n   *\n   * Note that what \"success\" means is up to the underlying sink; it might indicate simply that the chunk has been\n   * accepted, and not necessarily that it is safely saved to its ultimate destination.\n   */\n  write(chunk: W): Promise<void>;\n  write(chunk: W = undefined!): Promise<void> {\n    if (!IsWritableStreamDefaultWriter(this)) {\n      return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n    }\n\n    if (this._ownerWritableStream === undefined) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    return WritableStreamDefaultWriterWrite(this, chunk);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n  abort: { enumerable: true },\n  close: { enumerable: true },\n  releaseLock: { enumerable: true },\n  write: { enumerable: true },\n  closed: { enumerable: true },\n  desiredSize: { enumerable: true },\n  ready: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultWriter',\n    configurable: true\n  });\n}\n\n// Abstract operations for the WritableStreamDefaultWriter.\n\nfunction IsWritableStreamDefaultWriter<W = any>(x: any): x is WritableStreamDefaultWriter<W> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultWriter;\n}\n\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultWriterAbort(writer: WritableStreamDefaultWriter, reason: any) {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamAbort(stream, reason);\n}\n\nfunction WritableStreamDefaultWriterClose(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  return WritableStreamClose(stream);\n}\n\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer: WritableStreamDefaultWriter): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable' || state === 'erroring');\n\n  return WritableStreamDefaultWriterClose(writer);\n}\n\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._closedPromiseState === 'pending') {\n    defaultWriterClosedPromiseReject(writer, error);\n  } else {\n    defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer: WritableStreamDefaultWriter, error: any) {\n  if (writer._readyPromiseState === 'pending') {\n    defaultWriterReadyPromiseReject(writer, error);\n  } else {\n    defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n}\n\nfunction WritableStreamDefaultWriterGetDesiredSize(writer: WritableStreamDefaultWriter): number | null {\n  const stream = writer._ownerWritableStream;\n  const state = stream._state;\n\n  if (state === 'errored' || state === 'erroring') {\n    return null;\n  }\n\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\n\nfunction WritableStreamDefaultWriterRelease(writer: WritableStreamDefaultWriter) {\n  const stream = writer._ownerWritableStream;\n  assert(stream !== undefined);\n  assert(stream._writer === writer);\n\n  const releasedError = new TypeError(\n    `Writer was released and can no longer be used to monitor the stream's closedness`);\n\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n\n  // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n  // rejected until afterwards. This means that simply testing state will not work.\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined!;\n}\n\nfunction WritableStreamDefaultWriterWrite<W>(writer: WritableStreamDefaultWriter<W>, chunk: W): Promise<undefined> {\n  const stream = writer._ownerWritableStream;\n\n  assert(stream !== undefined);\n\n  const controller = stream._writableStreamController;\n\n  const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n  if (stream !== writer._ownerWritableStream) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n\n  const state = stream._state;\n  if (state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n    return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  assert(state === 'writable');\n\n  const promise = WritableStreamAddWriteRequest(stream);\n\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n\n  return promise;\n}\n\nconst closeSentinel: unique symbol = {} as any;\n\ntype QueueRecord<W> = W | typeof closeSentinel;\n\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nexport class WritableStreamDefaultController<W = any> {\n  /** @internal */\n  _controlledWritableStream!: WritableStream<W>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<QueueRecord<W>>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _abortReason: any;\n  /** @internal */\n  _abortController: AbortController | undefined;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<W>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _writeAlgorithm!: (chunk: W) => Promise<void>;\n  /** @internal */\n  _closeAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _abortAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n   */\n  get abortReason(): any {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('abortReason');\n    }\n    return this._abortReason;\n  }\n\n  /**\n   * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n   */\n  get signal(): AbortSignal {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('signal');\n    }\n    if (this._abortController === undefined) {\n      // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n      // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n      // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n      throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n    }\n    return this._abortController.signal;\n  }\n\n  /**\n   * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n   *\n   * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n   * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n   * normal lifecycle of interactions with the underlying sink.\n   */\n  error(e: any = undefined): void {\n    if (!IsWritableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n    const state = this._controlledWritableStream._state;\n    if (state !== 'writable') {\n      // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n      // just treat it as a no-op.\n      return;\n    }\n\n    WritableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [AbortSteps](reason: any): Promise<void> {\n    const result = this._abortAlgorithm(reason);\n    WritableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [ErrorSteps]() {\n    ResetQueue(this);\n  }\n}\n\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n  error: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'WritableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations implementing interface required by the WritableStream.\n\nfunction IsWritableStreamDefaultController(x: any): x is WritableStreamDefaultController<any> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n    return false;\n  }\n\n  return x instanceof WritableStreamDefaultController;\n}\n\nfunction SetUpWritableStreamDefaultController<W>(stream: WritableStream<W>,\n                                                 controller: WritableStreamDefaultController<W>,\n                                                 startAlgorithm: () => void | PromiseLike<void>,\n                                                 writeAlgorithm: (chunk: W) => Promise<void>,\n                                                 closeAlgorithm: () => Promise<void>,\n                                                 abortAlgorithm: (reason: any) => Promise<void>,\n                                                 highWaterMark: number,\n                                                 sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  assert(IsWritableStream(stream));\n  assert(stream._writableStreamController === undefined);\n\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n\n  // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._abortReason = undefined;\n  controller._abortController = createAbortController();\n  controller._started = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n\n  const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n\n  const startResult = startAlgorithm();\n  const startPromise = promiseResolvedWith(startResult);\n  uponPromise(\n    startPromise,\n    () => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    r => {\n      assert(stream._state === 'writable' || stream._state === 'erroring');\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n    }\n  );\n}\n\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink<W>(stream: WritableStream<W>,\n                                                                   underlyingSink: ValidatedUnderlyingSink<W>,\n                                                                   highWaterMark: number,\n                                                                   sizeAlgorithm: QueuingStrategySizeCallback<W>) {\n  const controller = Object.create(WritableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let writeAlgorithm: (chunk: W) => Promise<void> = () => promiseResolvedWith(undefined);\n  let closeAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let abortAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingSink.start !== undefined) {\n    startAlgorithm = () => underlyingSink.start!(controller);\n  }\n  if (underlyingSink.write !== undefined) {\n    writeAlgorithm = chunk => underlyingSink.write!(chunk, controller);\n  }\n  if (underlyingSink.close !== undefined) {\n    closeAlgorithm = () => underlyingSink.close!();\n  }\n  if (underlyingSink.abort !== undefined) {\n    abortAlgorithm = reason => underlyingSink.abort!(reason);\n  }\n\n  SetUpWritableStreamDefaultController(\n    stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller: WritableStreamDefaultController<any>) {\n  controller._writeAlgorithm = undefined!;\n  controller._closeAlgorithm = undefined!;\n  controller._abortAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\nfunction WritableStreamDefaultControllerClose<W>(controller: WritableStreamDefaultController<W>) {\n  EnqueueValueWithSize(controller, closeSentinel, 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\nfunction WritableStreamDefaultControllerGetChunkSize<W>(controller: WritableStreamDefaultController<W>,\n                                                        chunk: W): number {\n  try {\n    return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n    return 1;\n  }\n}\n\nfunction WritableStreamDefaultControllerGetDesiredSize(controller: WritableStreamDefaultController<any>): number {\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\nfunction WritableStreamDefaultControllerWrite<W>(controller: WritableStreamDefaultController<W>,\n                                                 chunk: W,\n                                                 chunkSize: number) {\n  try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n  } catch (enqueueE) {\n    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n    return;\n  }\n\n  const stream = controller._controlledWritableStream;\n  if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n\n// Abstract operations for the WritableStreamDefaultController.\n\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded<W>(controller: WritableStreamDefaultController<W>) {\n  const stream = controller._controlledWritableStream;\n\n  if (!controller._started) {\n    return;\n  }\n\n  if (stream._inFlightWriteRequest !== undefined) {\n    return;\n  }\n\n  const state = stream._state;\n  assert(state !== 'closed' && state !== 'errored');\n  if (state === 'erroring') {\n    WritableStreamFinishErroring(stream);\n    return;\n  }\n\n  if (controller._queue.length === 0) {\n    return;\n  }\n\n  const value = PeekQueueValue(controller);\n  if (value === closeSentinel) {\n    WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n    WritableStreamDefaultControllerProcessWrite(controller, value);\n  }\n}\n\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller: WritableStreamDefaultController<any>, error: any) {\n  if (controller._controlledWritableStream._state === 'writable') {\n    WritableStreamDefaultControllerError(controller, error);\n  }\n}\n\nfunction WritableStreamDefaultControllerProcessClose(controller: WritableStreamDefaultController<any>) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkCloseRequestInFlight(stream);\n\n  DequeueValue(controller);\n  assert(controller._queue.length === 0);\n\n  const sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(\n    sinkClosePromise,\n    () => {\n      WritableStreamFinishInFlightClose(stream);\n    },\n    reason => {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerProcessWrite<W>(controller: WritableStreamDefaultController<W>, chunk: W) {\n  const stream = controller._controlledWritableStream;\n\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n  const sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(\n    sinkWritePromise,\n    () => {\n      WritableStreamFinishInFlightWrite(stream);\n\n      const state = stream._state;\n      assert(state === 'writable' || state === 'erroring');\n\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    },\n    reason => {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    }\n  );\n}\n\nfunction WritableStreamDefaultControllerGetBackpressure(controller: WritableStreamDefaultController<any>): boolean {\n  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n}\n\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\nfunction WritableStreamDefaultControllerError(controller: WritableStreamDefaultController<any>, error: any) {\n  const stream = controller._controlledWritableStream;\n\n  assert(stream._state === 'writable');\n\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n}\n\n// Helper functions for the WritableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n\n// Helper functions for the WritableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n}\n\n\n// Helper functions for the WritableStreamDefaultWriter.\n\nfunction defaultWriterBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\n\nfunction defaultWriterLockException(name: string): TypeError {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\n\nfunction defaultWriterClosedPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._closedPromise = newPromise((resolve, reject) => {\n    writer._closedPromise_resolve = resolve;\n    writer._closedPromise_reject = reject;\n    writer._closedPromiseState = 'pending';\n  });\n}\n\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n}\n\nfunction defaultWriterClosedPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._closedPromise_reject === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n}\n\nfunction defaultWriterClosedPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._closedPromise_resolve === undefined);\n  assert(writer._closedPromise_reject === undefined);\n  assert(writer._closedPromiseState !== 'pending');\n\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterClosedPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._closedPromise_resolve === undefined) {\n    return;\n  }\n  assert(writer._closedPromiseState === 'pending');\n\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n}\n\nfunction defaultWriterReadyPromiseInitialize(writer: WritableStreamDefaultWriter) {\n  writer._readyPromise = newPromise((resolve, reject) => {\n    writer._readyPromise_resolve = resolve;\n    writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n}\n\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer: WritableStreamDefaultWriter) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n}\n\nfunction defaultWriterReadyPromiseReject(writer: WritableStreamDefaultWriter, reason: any) {\n  if (writer._readyPromise_reject === undefined) {\n    return;\n  }\n\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n}\n\nfunction defaultWriterReadyPromiseReset(writer: WritableStreamDefaultWriter) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitialize(writer);\n}\n\nfunction defaultWriterReadyPromiseResetToRejected(writer: WritableStreamDefaultWriter, reason: any) {\n  assert(writer._readyPromise_resolve === undefined);\n  assert(writer._readyPromise_reject === undefined);\n\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\n\nfunction defaultWriterReadyPromiseResolve(writer: WritableStreamDefaultWriter) {\n  if (writer._readyPromise_resolve === undefined) {\n    return;\n  }\n\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n}\n", "/// <reference lib=\"dom\" />\nexport const NativeDOMException: typeof DOMException | undefined =\n  typeof DOMException !== 'undefined' ? DOMException : undefined;\n", "/// <reference types=\"node\" />\nimport { NativeDOMException } from './native';\n\ndeclare class DOMExceptionClass extends Error {\n  constructor(message?: string, name?: string);\n\n  name: string;\n  message: string;\n}\n\ntype DOMException = DOMExceptionClass;\ntype DOMExceptionConstructor = typeof DOMExceptionClass;\n\nfunction isDOMExceptionConstructor(ctor: unknown): ctor is DOMExceptionConstructor {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n    return false;\n  }\n  try {\n    new (ctor as DOMExceptionConstructor)();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction createDOMExceptionPolyfill(): DOMExceptionConstructor {\n  // eslint-disable-next-line no-shadow\n  const ctor = function DOMException(this: DOMException, message?: string, name?: string) {\n    this.message = message || '';\n    this.name = name || 'Error';\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  } as any;\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n  return ctor;\n}\n\n// eslint-disable-next-line no-redeclare\nconst DOMException: DOMExceptionConstructor =\n  isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nexport { DOMException };\n", "import { IsReadableStream, IsReadableStreamLocked, ReadableStream, ReadableStreamCancel } from '../readable-stream';\nimport { AcquireReadableStreamDefaultReader, ReadableStreamDefaultReaderRead } from './default-reader';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireWritableStreamDefaultWriter,\n  IsWritableStream,\n  IsWritableStreamLocked,\n  WritableStream,\n  WritableStreamAbort,\n  WritableStreamCloseQueuedOrInFlight,\n  WritableStreamDefaultWriterCloseWithErrorPropagation,\n  WritableStreamDefaultWriterRelease,\n  WritableStreamDefaultWriterWrite\n} from '../writable-stream';\nimport assert from '../../stub/assert';\nimport {\n  newPromise,\n  PerformPromiseThen,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  uponFulfillment,\n  uponPromise,\n  uponRejection\n} from '../helpers/webidl';\nimport { noop } from '../../utils';\nimport { AbortSignal, isAbortSignal } from '../abort-signal';\nimport { DOMException } from '../../stub/dom-exception';\n\nexport function ReadableStreamPipeTo<T>(source: ReadableStream<T>,\n                                        dest: WritableStream<T>,\n                                        preventClose: boolean,\n                                        preventAbort: boolean,\n                                        preventCancel: boolean,\n                                        signal: AbortSignal | undefined): Promise<undefined> {\n  assert(IsReadableStream(source));\n  assert(IsWritableStream(dest));\n  assert(typeof preventClose === 'boolean');\n  assert(typeof preventAbort === 'boolean');\n  assert(typeof preventCancel === 'boolean');\n  assert(signal === undefined || isAbortSignal(signal));\n  assert(!IsReadableStreamLocked(source));\n  assert(!IsWritableStreamLocked(dest));\n\n  const reader = AcquireReadableStreamDefaultReader<T>(source);\n  const writer = AcquireWritableStreamDefaultWriter<T>(dest);\n\n  source._disturbed = true;\n\n  let shuttingDown = false;\n\n  // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n  let currentWrite = promiseResolvedWith<void>(undefined);\n\n  return newPromise((resolve, reject) => {\n    let abortAlgorithm: () => void;\n    if (signal !== undefined) {\n      abortAlgorithm = () => {\n        const error = new DOMException('Aborted', 'AbortError');\n        const actions: Array<() => Promise<void>> = [];\n        if (!preventAbort) {\n          actions.push(() => {\n            if (dest._state === 'writable') {\n              return WritableStreamAbort(dest, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        if (!preventCancel) {\n          actions.push(() => {\n            if (source._state === 'readable') {\n              return ReadableStreamCancel(source, error);\n            }\n            return promiseResolvedWith(undefined);\n          });\n        }\n        shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n      };\n\n      if (signal.aborted) {\n        abortAlgorithm();\n        return;\n      }\n\n      signal.addEventListener('abort', abortAlgorithm);\n    }\n\n    // Using reader and writer, read all chunks from this and write them to dest\n    // - Backpressure must be enforced\n    // - Shutdown must stop all activity\n    function pipeLoop() {\n      return newPromise<void>((resolveLoop, rejectLoop) => {\n        function next(done: boolean) {\n          if (done) {\n            resolveLoop();\n          } else {\n            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n            PerformPromiseThen(pipeStep(), next, rejectLoop);\n          }\n        }\n\n        next(false);\n      });\n    }\n\n    function pipeStep(): Promise<boolean> {\n      if (shuttingDown) {\n        return promiseResolvedWith(true);\n      }\n\n      return PerformPromiseThen(writer._readyPromise, () => {\n        return newPromise<boolean>((resolveRead, rejectRead) => {\n          ReadableStreamDefaultReaderRead(\n            reader,\n            {\n              _chunkSteps: chunk => {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: () => resolveRead(true),\n              _errorSteps: rejectRead\n            }\n          );\n        });\n      });\n    }\n\n    // Errors must be propagated forward\n    isOrBecomesErrored(source, reader._closedPromise, storedError => {\n      if (!preventAbort) {\n        shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Errors must be propagated backward\n    isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n      } else {\n        shutdown(true, storedError);\n      }\n    });\n\n    // Closing must be propagated forward\n    isOrBecomesClosed(source, reader._closedPromise, () => {\n      if (!preventClose) {\n        shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n      } else {\n        shutdown();\n      }\n    });\n\n    // Closing must be propagated backward\n    if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n      const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n      if (!preventCancel) {\n        shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n      } else {\n        shutdown(true, destClosed);\n      }\n    }\n\n    setPromiseIsHandledToTrue(pipeLoop());\n\n    function waitForWritesToFinish(): Promise<void> {\n      // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n      // for that too.\n      const oldCurrentWrite = currentWrite;\n      return PerformPromiseThen(\n        currentWrite,\n        () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined\n      );\n    }\n\n    function isOrBecomesErrored(stream: ReadableStream | WritableStream,\n                                promise: Promise<void>,\n                                action: (reason: any) => void) {\n      if (stream._state === 'errored') {\n        action(stream._storedError);\n      } else {\n        uponRejection(promise, action);\n      }\n    }\n\n    function isOrBecomesClosed(stream: ReadableStream | WritableStream, promise: Promise<void>, action: () => void) {\n      if (stream._state === 'closed') {\n        action();\n      } else {\n        uponFulfillment(promise, action);\n      }\n    }\n\n    function shutdownWithAction(action: () => Promise<unknown>, originalIsError?: boolean, originalError?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), doTheRest);\n      } else {\n        doTheRest();\n      }\n\n      function doTheRest() {\n        uponPromise(\n          action(),\n          () => finalize(originalIsError, originalError),\n          newError => finalize(true, newError)\n        );\n      }\n    }\n\n    function shutdown(isError?: boolean, error?: any) {\n      if (shuttingDown) {\n        return;\n      }\n      shuttingDown = true;\n\n      if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n        uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n      } else {\n        finalize(isError, error);\n      }\n    }\n\n    function finalize(isError?: boolean, error?: any) {\n      WritableStreamDefaultWriterRelease(writer);\n      ReadableStreamReaderGenericRelease(reader);\n\n      if (signal !== undefined) {\n        signal.removeEventListener('abort', abortAlgorithm);\n      }\n      if (isError) {\n        reject(error);\n      } else {\n        resolve(undefined);\n      }\n    }\n  });\n}\n", "import { QueuingStrategySizeCallback } from '../queuing-strategy';\nimport assert from '../../stub/assert';\nimport { DequeueValue, EnqueueValueWithSize, QueuePair, ResetQueue } from '../abstract-ops/queue-with-sizes';\nimport {\n  ReadableStreamAddReadRequest,\n  ReadableStreamFulfillReadRequest,\n  ReadableStreamGetNumReadRequests,\n  ReadRequest\n} from './default-reader';\nimport { SimpleQueue } from '../simple-queue';\nimport { IsReadableStreamLocked, ReadableStream, ReadableStreamClose, ReadableStreamError } from '../readable-stream';\nimport { ValidatedUnderlyingSource } from './underlying-source';\nimport { typeIsObject } from '../helpers/miscellaneous';\nimport { CancelSteps, PullSteps } from '../abstract-ops/internal-methods';\nimport { promiseResolvedWith, uponPromise } from '../helpers/webidl';\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nexport class ReadableStreamDefaultController<R> {\n  /** @internal */\n  _controlledReadableStream!: ReadableStream<R>;\n  /** @internal */\n  _queue!: SimpleQueue<QueuePair<R>>;\n  /** @internal */\n  _queueTotalSize!: number;\n  /** @internal */\n  _started!: boolean;\n  /** @internal */\n  _closeRequested!: boolean;\n  /** @internal */\n  _pullAgain!: boolean;\n  /** @internal */\n  _pulling !: boolean;\n  /** @internal */\n  _strategySizeAlgorithm!: QueuingStrategySizeCallback<R>;\n  /** @internal */\n  _strategyHWM!: number;\n  /** @internal */\n  _pullAlgorithm!: () => Promise<void>;\n  /** @internal */\n  _cancelAlgorithm!: (reason: any) => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n   * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n   */\n  get desiredSize(): number | null {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n  }\n\n  /**\n   * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n   * the stream, but once those are read, the stream will become closed.\n   */\n  close(): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('close');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits close');\n    }\n\n    ReadableStreamDefaultControllerClose(this);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the controlled readable stream.\n   */\n  enqueue(chunk: R): void;\n  enqueue(chunk: R = undefined!): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n      throw new TypeError('The stream is not in a state that permits enqueue');\n    }\n\n    return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n   */\n  error(e: any = undefined): void {\n    if (!IsReadableStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    ReadableStreamDefaultControllerError(this, e);\n  }\n\n  /** @internal */\n  [CancelSteps](reason: any): Promise<void> {\n    ResetQueue(this);\n    const result = this._cancelAlgorithm(reason);\n    ReadableStreamDefaultControllerClearAlgorithms(this);\n    return result;\n  }\n\n  /** @internal */\n  [PullSteps](readRequest: ReadRequest<R>): void {\n    const stream = this._controlledReadableStream;\n\n    if (this._queue.length > 0) {\n      const chunk = DequeueValue(this);\n\n      if (this._closeRequested && this._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        ReadableStreamClose(stream);\n      } else {\n        ReadableStreamDefaultControllerCallPullIfNeeded(this);\n      }\n\n      readRequest._chunkSteps(chunk);\n    } else {\n      ReadableStreamAddReadRequest(stream, readRequest);\n      ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n  }\n}\n\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n  close: { enumerable: true },\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'ReadableStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Abstract operations for the ReadableStreamDefaultController.\n\nfunction IsReadableStreamDefaultController<R = any>(x: any): x is ReadableStreamDefaultController<R> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n    return false;\n  }\n\n  return x instanceof ReadableStreamDefaultController;\n}\n\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller: ReadableStreamDefaultController<any>): void {\n  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (!shouldPull) {\n    return;\n  }\n\n  if (controller._pulling) {\n    controller._pullAgain = true;\n    return;\n  }\n\n  assert(!controller._pullAgain);\n\n  controller._pulling = true;\n\n  const pullPromise = controller._pullAlgorithm();\n  uponPromise(\n    pullPromise,\n    () => {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    },\n    e => {\n      ReadableStreamDefaultControllerError(controller, e);\n    }\n  );\n}\n\nfunction ReadableStreamDefaultControllerShouldCallPull(controller: ReadableStreamDefaultController<any>): boolean {\n  const stream = controller._controlledReadableStream;\n\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return false;\n  }\n\n  if (!controller._started) {\n    return false;\n  }\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    return true;\n  }\n\n  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  assert(desiredSize !== null);\n  if (desiredSize! > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller: ReadableStreamDefaultController<any>) {\n  controller._pullAlgorithm = undefined!;\n  controller._cancelAlgorithm = undefined!;\n  controller._strategySizeAlgorithm = undefined!;\n}\n\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\nexport function ReadableStreamDefaultControllerClose(controller: ReadableStreamDefaultController<any>) {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  controller._closeRequested = true;\n\n  if (controller._queue.length === 0) {\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n}\n\nexport function ReadableStreamDefaultControllerEnqueue<R>(\n  controller: ReadableStreamDefaultController<R>,\n  chunk: R\n): void {\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n    return;\n  }\n\n  const stream = controller._controlledReadableStream;\n\n  if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n    ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n    let chunkSize;\n    try {\n      chunkSize = controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      ReadableStreamDefaultControllerError(controller, chunkSizeE);\n      throw chunkSizeE;\n    }\n\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      ReadableStreamDefaultControllerError(controller, enqueueE);\n      throw enqueueE;\n    }\n  }\n\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\n\nexport function ReadableStreamDefaultControllerError(controller: ReadableStreamDefaultController<any>, e: any) {\n  const stream = controller._controlledReadableStream;\n\n  if (stream._state !== 'readable') {\n    return;\n  }\n\n  ResetQueue(controller);\n\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n}\n\nexport function ReadableStreamDefaultControllerGetDesiredSize(\n  controller: ReadableStreamDefaultController<any>\n): number | null {\n  const state = controller._controlledReadableStream._state;\n\n  if (state === 'errored') {\n    return null;\n  }\n  if (state === 'closed') {\n    return 0;\n  }\n\n  return controller._strategyHWM - controller._queueTotalSize;\n}\n\n// This is used in the implementation of TransformStream.\nexport function ReadableStreamDefaultControllerHasBackpressure(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function ReadableStreamDefaultControllerCanCloseOrEnqueue(\n  controller: ReadableStreamDefaultController<any>\n): boolean {\n  const state = controller._controlledReadableStream._state;\n\n  if (!controller._closeRequested && state === 'readable') {\n    return true;\n  }\n\n  return false;\n}\n\nexport function SetUpReadableStreamDefaultController<R>(stream: ReadableStream<R>,\n                                                        controller: ReadableStreamDefaultController<R>,\n                                                        startAlgorithm: () => void | PromiseLike<void>,\n                                                        pullAlgorithm: () => Promise<void>,\n                                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                                        highWaterMark: number,\n                                                        sizeAlgorithm: QueuingStrategySizeCallback<R>) {\n  assert(stream._readableStreamController === undefined);\n\n  controller._controlledReadableStream = stream;\n\n  controller._queue = undefined!;\n  controller._queueTotalSize = undefined!;\n  ResetQueue(controller);\n\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n\n  stream._readableStreamController = controller;\n\n  const startResult = startAlgorithm();\n  uponPromise(\n    promiseResolvedWith(startResult),\n    () => {\n      controller._started = true;\n\n      assert(!controller._pulling);\n      assert(!controller._pullAgain);\n\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    },\n    r => {\n      ReadableStreamDefaultControllerError(controller, r);\n    }\n  );\n}\n\nexport function SetUpReadableStreamDefaultControllerFromUnderlyingSource<R>(\n  stream: ReadableStream<R>,\n  underlyingSource: ValidatedUnderlyingSource<R>,\n  highWaterMark: number,\n  sizeAlgorithm: QueuingStrategySizeCallback<R>\n) {\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n\n  let startAlgorithm: () => void | PromiseLike<void> = () => undefined;\n  let pullAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n  let cancelAlgorithm: (reason: any) => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (underlyingSource.start !== undefined) {\n    startAlgorithm = () => underlyingSource.start!(controller);\n  }\n  if (underlyingSource.pull !== undefined) {\n    pullAlgorithm = () => underlyingSource.pull!(controller);\n  }\n  if (underlyingSource.cancel !== undefined) {\n    cancelAlgorithm = reason => underlyingSource.cancel!(reason);\n  }\n\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n}\n\n// Helper functions for the ReadableStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n", "import {\n  CreateReadableByteStream,\n  CreateReadableStream,\n  IsReadableStream,\n  ReadableByteStream,\n  ReadableStream,\n  ReadableStreamCancel,\n  ReadableStreamReader\n} from '../readable-stream';\nimport { ReadableStreamReaderGenericRelease } from './generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReaderRead,\n  ReadRequest\n} from './default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReaderRead,\n  ReadIntoRequest\n} from './byob-reader';\nimport assert from '../../stub/assert';\nimport { newPromise, promiseResolvedWith, queueMicrotask, uponRejection } from '../helpers/webidl';\nimport {\n  ReadableStreamDefaultController,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError\n} from './default-controller';\nimport {\n  IsReadableByteStreamController,\n  ReadableByteStreamControllerClose,\n  ReadableByteStreamControllerEnqueue,\n  ReadableByteStreamControllerError,\n  ReadableByteStreamControllerGetBYOBRequest,\n  ReadableByteStreamControllerRespond,\n  ReadableByteStreamControllerRespondWithNewView\n} from './byte-stream-controller';\nimport { CreateArrayFromList } from '../abstract-ops/ecmascript';\nimport { CloneAsUint8Array } from '../abstract-ops/miscellaneous';\n\nexport function ReadableStreamTee<R>(stream: ReadableStream<R>,\n                                     cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n  if (IsReadableByteStreamController(stream._readableStreamController)) {\n    return ReadableByteStreamTee(stream as unknown as ReadableByteStream) as\n      unknown as [ReadableStream<R>, ReadableStream<R>];\n  }\n  return ReadableStreamDefaultTee(stream, cloneForBranch2);\n}\n\nexport function ReadableStreamDefaultTee<R>(stream: ReadableStream<R>,\n                                            cloneForBranch2: boolean): [ReadableStream<R>, ReadableStream<R>] {\n  assert(IsReadableStream(stream));\n  assert(typeof cloneForBranch2 === 'boolean');\n\n  const reader = AcquireReadableStreamDefaultReader<R>(stream);\n\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableStream<R>;\n  let branch2: ReadableStream<R>;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<undefined>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function pullAlgorithm(): Promise<void> {\n    if (reading) {\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const readRequest: ReadRequest<R> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          reading = false;\n          const chunk1 = chunk;\n          const chunk2 = chunk;\n\n          // There is no way to access the cloning code right now in the reference implementation.\n          // If we add one then we'll need an implementation for serializable objects.\n          // if (!canceled2 && cloneForBranch2) {\n          //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n          // }\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerEnqueue(\n              branch1._readableStreamController as ReadableStreamDefaultController<R>,\n              chunk1\n            );\n          }\n\n          if (!canceled2) {\n            ReadableStreamDefaultControllerEnqueue(\n              branch2._readableStreamController as ReadableStreamDefaultController<R>,\n              chunk2\n            );\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableStreamDefaultControllerClose(branch1._readableStreamController as ReadableStreamDefaultController<R>);\n        }\n        if (!canceled2) {\n          ReadableStreamDefaultControllerClose(branch2._readableStreamController as ReadableStreamDefaultController<R>);\n        }\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm() {\n    // do nothing\n  }\n\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n\n  uponRejection(reader._closedPromise, (r: any) => {\n    ReadableStreamDefaultControllerError(branch1._readableStreamController as ReadableStreamDefaultController<R>, r);\n    ReadableStreamDefaultControllerError(branch2._readableStreamController as ReadableStreamDefaultController<R>, r);\n    if (!canceled1 || !canceled2) {\n      resolveCancelPromise(undefined);\n    }\n  });\n\n  return [branch1, branch2];\n}\n\nexport function ReadableByteStreamTee(stream: ReadableByteStream): [ReadableByteStream, ReadableByteStream] {\n  assert(IsReadableStream(stream));\n  assert(IsReadableByteStreamController(stream._readableStreamController));\n\n  let reader: ReadableStreamReader<Uint8Array> = AcquireReadableStreamDefaultReader(stream);\n  let reading = false;\n  let canceled1 = false;\n  let canceled2 = false;\n  let reason1: any;\n  let reason2: any;\n  let branch1: ReadableByteStream;\n  let branch2: ReadableByteStream;\n\n  let resolveCancelPromise: (value: undefined | Promise<undefined>) => void;\n  const cancelPromise = newPromise<void>(resolve => {\n    resolveCancelPromise = resolve;\n  });\n\n  function forwardReaderError(thisReader: ReadableStreamReader<Uint8Array>) {\n    uponRejection(thisReader._closedPromise, r => {\n      if (thisReader !== reader) {\n        return;\n      }\n      ReadableByteStreamControllerError(branch1._readableStreamController, r);\n      ReadableByteStreamControllerError(branch2._readableStreamController, r);\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n    });\n  }\n\n  function pullWithDefaultReader() {\n    if (IsReadableStreamBYOBReader(reader)) {\n      assert(reader._readIntoRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamDefaultReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const readRequest: ReadRequest<Uint8Array> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          reading = false;\n\n          const chunk1 = chunk;\n          let chunk2 = chunk;\n          if (!canceled1 && !canceled2) {\n            try {\n              chunk2 = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n          }\n\n          if (!canceled1) {\n            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n          }\n          if (!canceled2) {\n            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n          }\n        });\n      },\n      _closeSteps: () => {\n        reading = false;\n        if (!canceled1) {\n          ReadableByteStreamControllerClose(branch1._readableStreamController);\n        }\n        if (!canceled2) {\n          ReadableByteStreamControllerClose(branch2._readableStreamController);\n        }\n        if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n        }\n        if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n        }\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamDefaultReaderRead(reader, readRequest);\n  }\n\n  function pullWithBYOBReader(view: ArrayBufferView, forBranch2: boolean) {\n    if (IsReadableStreamDefaultReader<Uint8Array>(reader)) {\n      assert(reader._readRequests.length === 0);\n      ReadableStreamReaderGenericRelease(reader);\n\n      reader = AcquireReadableStreamBYOBReader(stream);\n      forwardReaderError(reader);\n    }\n\n    const byobBranch = forBranch2 ? branch2 : branch1;\n    const otherBranch = forBranch2 ? branch1 : branch2;\n\n    const readIntoRequest: ReadIntoRequest<ArrayBufferView> = {\n      _chunkSteps: chunk => {\n        // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n        // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n        // successful synchronously-available reads get ahead of asynchronously-available errors.\n        queueMicrotask(() => {\n          reading = false;\n\n          const byobCanceled = forBranch2 ? canceled2 : canceled1;\n          const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!otherCanceled) {\n            let clonedChunk;\n            try {\n              clonedChunk = CloneAsUint8Array(chunk);\n            } catch (cloneE) {\n              ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n              ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n              resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n              return;\n            }\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n          } else if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n        });\n      },\n      _closeSteps: chunk => {\n        reading = false;\n\n        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n        if (!byobCanceled) {\n          ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n        }\n        if (!otherCanceled) {\n          ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n        }\n\n        if (chunk !== undefined) {\n          assert(chunk.byteLength === 0);\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n          }\n          if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n          }\n        }\n\n        if (!byobCanceled || !otherCanceled) {\n          resolveCancelPromise(undefined);\n        }\n      },\n      _errorSteps: () => {\n        reading = false;\n      }\n    };\n    ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n  }\n\n  function pull1Algorithm(): Promise<void> {\n    if (reading) {\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, false);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function pull2Algorithm(): Promise<void> {\n    if (reading) {\n      return promiseResolvedWith(undefined);\n    }\n\n    reading = true;\n\n    const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n    if (byobRequest === null) {\n      pullWithDefaultReader();\n    } else {\n      pullWithBYOBReader(byobRequest._view!, true);\n    }\n\n    return promiseResolvedWith(undefined);\n  }\n\n  function cancel1Algorithm(reason: any): Promise<void> {\n    canceled1 = true;\n    reason1 = reason;\n    if (canceled2) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function cancel2Algorithm(reason: any): Promise<void> {\n    canceled2 = true;\n    reason2 = reason;\n    if (canceled1) {\n      const compositeReason = CreateArrayFromList([reason1, reason2]);\n      const cancelResult = ReadableStreamCancel(stream, compositeReason);\n      resolveCancelPromise(cancelResult);\n    }\n    return cancelPromise;\n  }\n\n  function startAlgorithm(): void {\n    return;\n  }\n\n  branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n  branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n\n  forwardReaderError(reader);\n\n  return [branch1, branch2];\n}\n", "import { assertDictionary, assertFunction, convertUnsignedLongLongWithEnforceRange } from './basic';\nimport {\n  ReadableStreamController,\n  UnderlyingByteSource,\n  UnderlyingDefaultOrByteSource,\n  UnderlyingDefaultOrByteSourcePullCallback,\n  UnderlyingDefaultOrByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  ValidatedUnderlyingDefaultOrByteSource\n} from '../readable-stream/underlying-source';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\n\nexport function convertUnderlyingDefaultOrByteSource<R>(\n  source: UnderlyingSource<R> | UnderlyingByteSource | null,\n  context: string\n): ValidatedUnderlyingDefaultOrByteSource<R> {\n  assertDictionary(source, context);\n  const original = source as (UnderlyingDefaultOrByteSource<R> | null);\n  const autoAllocateChunkSize = original?.autoAllocateChunkSize;\n  const cancel = original?.cancel;\n  const pull = original?.pull;\n  const start = original?.start;\n  const type = original?.type;\n  return {\n    autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n      undefined :\n      convertUnsignedLongLongWithEnforceRange(\n        autoAllocateChunkSize,\n        `${context} has member 'autoAllocateChunkSize' that`\n      ),\n    cancel: cancel === undefined ?\n      undefined :\n      convertUnderlyingSourceCancelCallback(cancel, original!, `${context} has member 'cancel' that`),\n    pull: pull === undefined ?\n      undefined :\n      convertUnderlyingSourcePullCallback(pull, original!, `${context} has member 'pull' that`),\n    start: start === undefined ?\n      undefined :\n      convertUnderlyingSourceStartCallback(start, original!, `${context} has member 'start' that`),\n    type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n  };\n}\n\nfunction convertUnderlyingSourceCancelCallback(\n  fn: UnderlyingSourceCancelCallback,\n  original: UnderlyingDefaultOrByteSource,\n  context: string\n): (reason: any) => Promise<void> {\n  assertFunction(fn, context);\n  return (reason: any) => promiseCall(fn, original, [reason]);\n}\n\nfunction convertUnderlyingSourcePullCallback<R>(\n  fn: UnderlyingDefaultOrByteSourcePullCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): (controller: ReadableStreamController<R>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertUnderlyingSourceStartCallback<R>(\n  fn: UnderlyingDefaultOrByteSourceStartCallback<R>,\n  original: UnderlyingDefaultOrByteSource<R>,\n  context: string\n): UnderlyingDefaultOrByteSourceStartCallback<R> {\n  assertFunction(fn, context);\n  return (controller: ReadableStreamController<R>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertReadableStreamType(type: string, context: string): 'bytes' {\n  type = `${type}`;\n  if (type !== 'bytes') {\n    throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n  }\n  return type;\n}\n", "import { assertDictionary } from './basic';\nimport { ReadableStreamGetReaderOptions } from '../readable-stream/reader-options';\n\nexport function convertReaderOptions(options: ReadableStreamGetReaderOptions | null | undefined,\n                                     context: string): ReadableStreamGetReaderOptions {\n  assertDictionary(options, context);\n  const mode = options?.mode;\n  return {\n    mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n  };\n}\n\nfunction convertReadableStreamReaderMode(mode: string, context: string): 'byob' {\n  mode = `${mode}`;\n  if (mode !== 'byob') {\n    throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  }\n  return mode;\n}\n", "import { assertDictionary } from './basic';\nimport {\n  ReadableStreamIteratorOptions,\n  ValidatedReadableStreamIteratorOptions\n} from '../readable-stream/iterator-options';\n\nexport function convertIteratorOptions(options: ReadableStreamIteratorOptions | null | undefined,\n                                       context: string): ValidatedReadableStreamIteratorOptions {\n  assertDictionary(options, context);\n  const preventCancel = options?.preventCancel;\n  return { preventCancel: Boolean(preventCancel) };\n}\n", "import { assertDictionary } from './basic';\nimport { StreamPipeOptions, ValidatedStreamPipeOptions } from '../readable-stream/pipe-options';\nimport { AbortSignal, isAbortSignal } from '../abort-signal';\n\nexport function convertPipeOptions(options: StreamPipeOptions | null | undefined,\n                                   context: string): ValidatedStreamPipeOptions {\n  assertDictionary(options, context);\n  const preventAbort = options?.preventAbort;\n  const preventCancel = options?.preventCancel;\n  const preventClose = options?.preventClose;\n  const signal = options?.signal;\n  if (signal !== undefined) {\n    assertAbortSignal(signal, `${context} has member 'signal' that`);\n  }\n  return {\n    preventAbort: Boolean(preventAbort),\n    preventCancel: Boolean(preventCancel),\n    preventClose: Boolean(preventClose),\n    signal\n  };\n}\n\nfunction assertAbortSignal(signal: unknown, context: string): asserts signal is AbortSignal {\n  if (!isAbortSignal(signal)) {\n    throw new TypeError(`${context} is not an AbortSignal.`);\n  }\n}\n", "import { assertDictionary, assertRequiredField } from './basic';\nimport { ReadableStream } from '../readable-stream';\nimport { WritableStream } from '../writable-stream';\nimport { assertReadableStream } from './readable-stream';\nimport { assertWritableStream } from './writable-stream';\n\nexport function convertReadableWritablePair<RS extends ReadableStream, WS extends WritableStream>(\n  pair: { readable: RS; writable: WS } | null | undefined,\n  context: string\n): { readable: RS; writable: WS } {\n  assertDictionary(pair, context);\n\n  const readable = pair?.readable;\n  assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n  assertReadableStream(readable, `${context} has member 'readable' that`);\n\n  const writable = pair?.writable;\n  assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n  assertWritableStream(writable, `${context} has member 'writable' that`);\n\n  return { readable, writable };\n}\n", "import assert from '../stub/assert';\nimport {\n  promiseRejectedWith,\n  promiseResolvedWith,\n  setPromiseIsHandledToTrue,\n  transformPromiseWith\n} from './helpers/webidl';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { AcquireReadableStreamAsyncIterator, ReadableStreamAsyncIterator } from './readable-stream/async-iterator';\nimport { defaultReaderClosedPromiseReject, defaultReaderClosedPromiseResolve } from './readable-stream/generic-reader';\nimport {\n  AcquireReadableStreamDefaultReader,\n  IsReadableStreamDefaultReader,\n  ReadableStreamDefaultReader,\n  ReadableStreamDefaultReadResult\n} from './readable-stream/default-reader';\nimport {\n  AcquireReadableStreamBYOBReader,\n  IsReadableStreamBYOBReader,\n  ReadableStreamBYOBReader,\n  ReadableStreamBYOBReadResult\n} from './readable-stream/byob-reader';\nimport { ReadableStreamPipeTo } from './readable-stream/pipe';\nimport { ReadableStreamTee } from './readable-stream/tee';\nimport { IsWritableStream, IsWritableStreamLocked, WritableStream } from './writable-stream';\nimport { SimpleQueue } from './simple-queue';\nimport {\n  ReadableByteStreamController,\n  ReadableStreamBYOBRequest,\n  SetUpReadableByteStreamController,\n  SetUpReadableByteStreamControllerFromUnderlyingSource\n} from './readable-stream/byte-stream-controller';\nimport {\n  ReadableStreamDefaultController,\n  SetUpReadableStreamDefaultController,\n  SetUpReadableStreamDefaultControllerFromUnderlyingSource\n} from './readable-stream/default-controller';\nimport {\n  UnderlyingByteSource,\n  UnderlyingByteSourcePullCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingSource,\n  UnderlyingSourceCancelCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceStartCallback\n} from './readable-stream/underlying-source';\nimport { noop } from '../utils';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { CreateArrayFromList } from './abstract-ops/ecmascript';\nimport { CancelSteps } from './abstract-ops/internal-methods';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { assertObject, assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport { convertUnderlyingDefaultOrByteSource } from './validators/underlying-source';\nimport { ReadableStreamGetReaderOptions } from './readable-stream/reader-options';\nimport { convertReaderOptions } from './validators/reader-options';\nimport { StreamPipeOptions, ValidatedStreamPipeOptions } from './readable-stream/pipe-options';\nimport { ReadableStreamIteratorOptions } from './readable-stream/iterator-options';\nimport { convertIteratorOptions } from './validators/iterator-options';\nimport { convertPipeOptions } from './validators/pipe-options';\nimport { ReadableWritablePair } from './readable-stream/readable-writable-pair';\nimport { convertReadableWritablePair } from './validators/readable-writable-pair';\n\nexport type ReadableByteStream = ReadableStream<Uint8Array> & {\n  _readableStreamController: ReadableByteStreamController\n};\n\ntype ReadableStreamState = 'readable' | 'closed' | 'errored';\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nexport class ReadableStream<R = any> {\n  /** @internal */\n  _state!: ReadableStreamState;\n  /** @internal */\n  _reader: ReadableStreamReader<R> | undefined;\n  /** @internal */\n  _storedError: any;\n  /** @internal */\n  _disturbed!: boolean;\n  /** @internal */\n  _readableStreamController!: ReadableStreamDefaultController<R> | ReadableByteStreamController;\n\n  constructor(underlyingSource: UnderlyingByteSource, strategy?: { highWaterMark?: number; size?: undefined });\n  constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);\n  constructor(rawUnderlyingSource: UnderlyingSource<R> | UnderlyingByteSource | null | undefined = {},\n              rawStrategy: QueuingStrategy<R> | null | undefined = {}) {\n    if (rawUnderlyingSource === undefined) {\n      rawUnderlyingSource = null;\n    } else {\n      assertObject(rawUnderlyingSource, 'First parameter');\n    }\n\n    const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n    const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n\n    InitializeReadableStream(this);\n\n    if (underlyingSource.type === 'bytes') {\n      if (strategy.size !== undefined) {\n        throw new RangeError('The strategy for a byte stream cannot have a size function');\n      }\n      const highWaterMark = ExtractHighWaterMark(strategy, 0);\n      SetUpReadableByteStreamControllerFromUnderlyingSource(\n        this as unknown as ReadableByteStream,\n        underlyingSource,\n        highWaterMark\n      );\n    } else {\n      assert(underlyingSource.type === undefined);\n      const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      const highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpReadableStreamDefaultControllerFromUnderlyingSource(\n        this,\n        underlyingSource,\n        highWaterMark,\n        sizeAlgorithm\n      );\n    }\n  }\n\n  /**\n   * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n   */\n  get locked(): boolean {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('locked');\n    }\n\n    return IsReadableStreamLocked(this);\n  }\n\n  /**\n   * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n   *\n   * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n   * method, which might or might not use it.\n   */\n  cancel(reason: any = undefined): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('cancel'));\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n    }\n\n    return ReadableStreamCancel(this, reason);\n  }\n\n  /**\n   * Creates a {@link ReadableStreamBYOBReader} and locks the stream to the new reader.\n   *\n   * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams,\n   * i.e. streams which were constructed specifically with the ability to handle \"bring your own buffer\" reading.\n   * The returned BYOB reader provides the ability to directly read individual chunks from the stream via its\n   * {@link ReadableStreamBYOBReader.read | read()} method, into developer-supplied buffers, allowing more precise\n   * control over allocation.\n   */\n  getReader({ mode }: { mode: 'byob' }): ReadableStreamBYOBReader;\n  /**\n   * Creates a {@link ReadableStreamDefaultReader} and locks the stream to the new reader.\n   * While the stream is locked, no other reader can be acquired until this one is released.\n   *\n   * This functionality is especially useful for creating abstractions that desire the ability to consume a stream\n   * in its entirety. By getting a reader for the stream, you can ensure nobody else can interleave reads with yours\n   * or cancel the stream, which would interfere with your abstraction.\n   */\n  getReader(): ReadableStreamDefaultReader<R>;\n  getReader(\n    rawOptions: ReadableStreamGetReaderOptions | null | undefined = undefined\n  ): ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('getReader');\n    }\n\n    const options = convertReaderOptions(rawOptions, 'First parameter');\n\n    if (options.mode === undefined) {\n      return AcquireReadableStreamDefaultReader(this);\n    }\n\n    assert(options.mode === 'byob');\n    return AcquireReadableStreamBYOBReader(this as unknown as ReadableByteStream);\n  }\n\n  /**\n   * Provides a convenient, chainable way of piping this readable stream through a transform stream\n   * (or any other `{ writable, readable }` pair). It simply {@link ReadableStream.pipeTo | pipes} the stream\n   * into the writable side of the supplied pair, and returns the readable side for further use.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeThrough<RS extends ReadableStream>(\n    transform: { readable: RS; writable: WritableStream<R> },\n    options?: StreamPipeOptions\n  ): RS;\n  pipeThrough<RS extends ReadableStream>(\n    rawTransform: { readable: RS; writable: WritableStream<R> } | null | undefined,\n    rawOptions: StreamPipeOptions | null | undefined = {}\n  ): RS {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('pipeThrough');\n    }\n    assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n\n    const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n    const options = convertPipeOptions(rawOptions, 'Second parameter');\n\n    if (IsReadableStreamLocked(this)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n    }\n    if (IsWritableStreamLocked(transform.writable)) {\n      throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n    }\n\n    const promise = ReadableStreamPipeTo(\n      this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n\n    setPromiseIsHandledToTrue(promise);\n\n    return transform.readable;\n  }\n\n  /**\n   * Pipes this readable stream to a given writable stream. The way in which the piping process behaves under\n   * various error conditions can be customized with a number of passed options. It returns a promise that fulfills\n   * when the piping process completes successfully, or rejects if any errors were encountered.\n   *\n   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.\n   */\n  pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;\n  pipeTo(destination: WritableStream<R> | null | undefined,\n         rawOptions: StreamPipeOptions | null | undefined = {}): Promise<void> {\n    if (!IsReadableStream(this)) {\n      return promiseRejectedWith(streamBrandCheckException('pipeTo'));\n    }\n\n    if (destination === undefined) {\n      return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n    }\n    if (!IsWritableStream(destination)) {\n      return promiseRejectedWith(\n        new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`)\n      );\n    }\n\n    let options: ValidatedStreamPipeOptions;\n    try {\n      options = convertPipeOptions(rawOptions, 'Second parameter');\n    } catch (e) {\n      return promiseRejectedWith(e);\n    }\n\n    if (IsReadableStreamLocked(this)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')\n      );\n    }\n    if (IsWritableStreamLocked(destination)) {\n      return promiseRejectedWith(\n        new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')\n      );\n    }\n\n    return ReadableStreamPipeTo<R>(\n      this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal\n    );\n  }\n\n  /**\n   * Tees this readable stream, returning a two-element array containing the two resulting branches as\n   * new {@link ReadableStream} instances.\n   *\n   * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n   * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n   * propagated to the stream's underlying source.\n   *\n   * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n   * this could allow interference between the two branches.\n   */\n  tee(): [ReadableStream<R>, ReadableStream<R>] {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('tee');\n    }\n\n    const branches = ReadableStreamTee(this, false);\n    return CreateArrayFromList(branches);\n  }\n\n  /**\n   * Asynchronously iterates over the chunks in the stream's internal queue.\n   *\n   * Asynchronously iterating over the stream will lock it, preventing any other consumer from acquiring a reader.\n   * The lock will be released if the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method\n   * is called, e.g. by breaking out of the loop.\n   *\n   * By default, calling the async iterator's {@link ReadableStreamAsyncIterator.return | return()} method will also\n   * cancel the stream. To prevent this, use the stream's {@link ReadableStream.values | values()} method, passing\n   * `true` for the `preventCancel` option.\n   */\n  values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;\n  values(rawOptions: ReadableStreamIteratorOptions | null | undefined = undefined): ReadableStreamAsyncIterator<R> {\n    if (!IsReadableStream(this)) {\n      throw streamBrandCheckException('values');\n    }\n\n    const options = convertIteratorOptions(rawOptions, 'First parameter');\n    return AcquireReadableStreamAsyncIterator<R>(this, options.preventCancel);\n  }\n\n  /**\n   * {@inheritDoc ReadableStream.values}\n   */\n  [Symbol.asyncIterator]: (options?: ReadableStreamIteratorOptions) => ReadableStreamAsyncIterator<R>;\n}\n\nObject.defineProperties(ReadableStream.prototype, {\n  cancel: { enumerable: true },\n  getReader: { enumerable: true },\n  pipeThrough: { enumerable: true },\n  pipeTo: { enumerable: true },\n  tee: { enumerable: true },\n  values: { enumerable: true },\n  locked: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, {\n    value: 'ReadableStream',\n    configurable: true\n  });\n}\nif (typeof Symbol.asyncIterator === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, Symbol.asyncIterator, {\n    value: ReadableStream.prototype.values,\n    writable: true,\n    configurable: true\n  });\n}\n\nexport {\n  ReadableStreamAsyncIterator,\n  ReadableStreamDefaultReadResult,\n  ReadableStreamBYOBReadResult,\n  UnderlyingByteSource,\n  UnderlyingSource,\n  UnderlyingSourceStartCallback,\n  UnderlyingSourcePullCallback,\n  UnderlyingSourceCancelCallback,\n  UnderlyingByteSourceStartCallback,\n  UnderlyingByteSourcePullCallback,\n  StreamPipeOptions,\n  ReadableWritablePair,\n  ReadableStreamIteratorOptions\n};\n\n// Abstract operations for the ReadableStream.\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableStream<R>(startAlgorithm: () => void | PromiseLike<void>,\n                                        pullAlgorithm: () => Promise<void>,\n                                        cancelAlgorithm: (reason: any) => Promise<void>,\n                                        highWaterMark = 1,\n                                        sizeAlgorithm: QueuingStrategySizeCallback<R> = () => 1): ReadableStream<R> {\n  assert(IsNonNegativeNumber(highWaterMark));\n\n  const stream: ReadableStream<R> = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableStreamDefaultController<R> = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(\n    stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm\n  );\n\n  return stream;\n}\n\n// Throws if and only if startAlgorithm throws.\nexport function CreateReadableByteStream(\n  startAlgorithm: () => void | PromiseLike<void>,\n  pullAlgorithm: () => Promise<void>,\n  cancelAlgorithm: (reason: any) => Promise<void>\n): ReadableByteStream {\n  const stream: ReadableByteStream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n\n  const controller: ReadableByteStreamController = Object.create(ReadableByteStreamController.prototype);\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n\n  return stream;\n}\n\nfunction InitializeReadableStream(stream: ReadableStream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n}\n\nexport function IsReadableStream(x: unknown): x is ReadableStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n    return false;\n  }\n\n  return x instanceof ReadableStream;\n}\n\nexport function IsReadableStreamDisturbed(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  return stream._disturbed;\n}\n\nexport function IsReadableStreamLocked(stream: ReadableStream): boolean {\n  assert(IsReadableStream(stream));\n\n  if (stream._reader === undefined) {\n    return false;\n  }\n\n  return true;\n}\n\n// ReadableStream API exposed for controllers.\n\nexport function ReadableStreamCancel<R>(stream: ReadableStream<R>, reason: any): Promise<undefined> {\n  stream._disturbed = true;\n\n  if (stream._state === 'closed') {\n    return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n    return promiseRejectedWith(stream._storedError);\n  }\n\n  ReadableStreamClose(stream);\n\n  const reader = stream._reader;\n  if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n    reader._readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._closeSteps(undefined);\n    });\n    reader._readIntoRequests = new SimpleQueue();\n  }\n\n  const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n}\n\nexport function ReadableStreamClose<R>(stream: ReadableStream<R>): void {\n  assert(stream._state === 'readable');\n\n  stream._state = 'closed';\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseResolve(reader);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    reader._readRequests.forEach(readRequest => {\n      readRequest._closeSteps();\n    });\n    reader._readRequests = new SimpleQueue();\n  }\n}\n\nexport function ReadableStreamError<R>(stream: ReadableStream<R>, e: any): void {\n  assert(IsReadableStream(stream));\n  assert(stream._state === 'readable');\n\n  stream._state = 'errored';\n  stream._storedError = e;\n\n  const reader = stream._reader;\n\n  if (reader === undefined) {\n    return;\n  }\n\n  defaultReaderClosedPromiseReject(reader, e);\n\n  if (IsReadableStreamDefaultReader<R>(reader)) {\n    reader._readRequests.forEach(readRequest => {\n      readRequest._errorSteps(e);\n    });\n\n    reader._readRequests = new SimpleQueue();\n  } else {\n    assert(IsReadableStreamBYOBReader(reader));\n\n    reader._readIntoRequests.forEach(readIntoRequest => {\n      readIntoRequest._errorSteps(e);\n    });\n\n    reader._readIntoRequests = new SimpleQueue();\n  }\n}\n\n// Readers\n\nexport type ReadableStreamReader<R> = ReadableStreamDefaultReader<R> | ReadableStreamBYOBReader;\n\nexport {\n  ReadableStreamDefaultReader,\n  ReadableStreamBYOBReader\n};\n\n// Controllers\n\nexport {\n  ReadableStreamDefaultController,\n  ReadableStreamBYOBRequest,\n  ReadableByteStreamController\n};\n\n// Helper functions for the ReadableStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n", "import { QueuingStrategyInit } from '../queuing-strategy';\nimport { assertDictionary, assertRequiredField, convertUnrestrictedDouble } from './basic';\n\nexport function convertQueuingStrategyInit(init: QueuingStrategyInit | null | undefined,\n                                           context: string): QueuingStrategyInit {\n  assertDictionary(init, context);\n  const highWaterMark = init?.highWaterMark;\n  assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n  return {\n    highWaterMark: convertUnrestrictedDouble(highWaterMark)\n  };\n}\n", "import { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst byteLengthSizeFunction = (chunk: ArrayBufferView): number => {\n  return chunk.byteLength;\n};\nObject.defineProperty(byteLengthSizeFunction, 'name', {\n  value: 'size',\n  configurable: true\n});\n\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nexport default class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {\n  /** @internal */\n  readonly _byteLengthQueuingStrategyHighWaterMark: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('highWaterMark');\n    }\n    return this._byteLengthQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by returning the value of its `byteLength` property.\n   */\n  get size(): (chunk: ArrayBufferView) => number {\n    if (!IsByteLengthQueuingStrategy(this)) {\n      throw byteLengthBrandCheckException('size');\n    }\n    return byteLengthSizeFunction;\n  }\n}\n\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'ByteLengthQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the ByteLengthQueuingStrategy.\n\nfunction byteLengthBrandCheckException(name: string): TypeError {\n  return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\n\nexport function IsByteLengthQueuingStrategy(x: any): x is ByteLengthQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof ByteLengthQueuingStrategy;\n}\n", "import { QueuingStrategy, QueuingStrategyInit } from './queuing-strategy';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { assertRequiredArgument } from './validators/basic';\nimport { convertQueuingStrategyInit } from './validators/queuing-strategy-init';\n\n// The size function must not have a prototype property nor be a constructor\nconst countSizeFunction = (): 1 => {\n  return 1;\n};\nObject.defineProperty(countSizeFunction, 'name', {\n  value: 'size',\n  configurable: true\n});\n\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nexport default class CountQueuingStrategy implements QueuingStrategy<any> {\n  /** @internal */\n  readonly _countQueuingStrategyHighWaterMark!: number;\n\n  constructor(options: QueuingStrategyInit) {\n    assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n    options = convertQueuingStrategyInit(options, 'First parameter');\n    this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n  }\n\n  /**\n   * Returns the high water mark provided to the constructor.\n   */\n  get highWaterMark(): number {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('highWaterMark');\n    }\n    return this._countQueuingStrategyHighWaterMark;\n  }\n\n  /**\n   * Measures the size of `chunk` by always returning 1.\n   * This ensures that the total queue size is a count of the number of chunks in the queue.\n   */\n  get size(): (chunk: any) => 1 {\n    if (!IsCountQueuingStrategy(this)) {\n      throw countBrandCheckException('size');\n    }\n    return countSizeFunction;\n  }\n}\n\nObject.defineProperties(CountQueuingStrategy.prototype, {\n  highWaterMark: { enumerable: true },\n  size: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {\n    value: 'CountQueuingStrategy',\n    configurable: true\n  });\n}\n\n// Helper functions for the CountQueuingStrategy.\n\nfunction countBrandCheckException(name: string): TypeError {\n  return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\n\nexport function IsCountQueuingStrategy(x: any): x is CountQueuingStrategy {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n    return false;\n  }\n\n  return x instanceof CountQueuingStrategy;\n}\n", "import { assertDictionary, assertFunction } from './basic';\nimport { promiseCall, reflectCall } from '../helpers/webidl';\nimport {\n  Transformer,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from '../transform-stream/transformer';\nimport { TransformStreamDefaultController } from '../transform-stream';\n\nexport function convertTransformer<I, O>(original: Transformer<I, O> | null,\n                                         context: string): ValidatedTransformer<I, O> {\n  assertDictionary(original, context);\n  const flush = original?.flush;\n  const readableType = original?.readableType;\n  const start = original?.start;\n  const transform = original?.transform;\n  const writableType = original?.writableType;\n  return {\n    flush: flush === undefined ?\n      undefined :\n      convertTransformerFlushCallback(flush, original!, `${context} has member 'flush' that`),\n    readableType,\n    start: start === undefined ?\n      undefined :\n      convertTransformerStartCallback(start, original!, `${context} has member 'start' that`),\n    transform: transform === undefined ?\n      undefined :\n      convertTransformerTransformCallback(transform, original!, `${context} has member 'transform' that`),\n    writableType\n  };\n}\n\nfunction convertTransformerFlushCallback<I, O>(\n  fn: TransformerFlushCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): (controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [controller]);\n}\n\nfunction convertTransformerStartCallback<I, O>(\n  fn: TransformerStartCallback<O>,\n  original: Transformer<I, O>,\n  context: string\n): TransformerStartCallback<O> {\n  assertFunction(fn, context);\n  return (controller: TransformStreamDefaultController<O>) => reflectCall(fn, original, [controller]);\n}\n\nfunction convertTransformerTransformCallback<I, O>(\n  fn: TransformerTransformCallback<I, O>,\n  original: Transformer<I, O>,\n  context: string\n): (chunk: I, controller: TransformStreamDefaultController<O>) => Promise<void> {\n  assertFunction(fn, context);\n  return (chunk: I, controller: TransformStreamDefaultController<O>) => promiseCall(fn, original, [chunk, controller]);\n}\n", "import assert from '../stub/assert';\nimport { newPromise, promiseRejectedWith, promiseResolvedWith, transformPromiseWith } from './helpers/webidl';\nimport { CreateReadableStream, ReadableStream, ReadableStreamDefaultController } from './readable-stream';\nimport {\n  ReadableStreamDefaultControllerCanCloseOrEnqueue,\n  ReadableStreamDefaultControllerClose,\n  ReadableStreamDefaultControllerEnqueue,\n  ReadableStreamDefaultControllerError,\n  ReadableStreamDefaultControllerGetDesiredSize,\n  ReadableStreamDefaultControllerHasBackpressure\n} from './readable-stream/default-controller';\nimport { QueuingStrategy, QueuingStrategySizeCallback } from './queuing-strategy';\nimport { CreateWritableStream, WritableStream, WritableStreamDefaultControllerErrorIfNeeded } from './writable-stream';\nimport { typeIsObject } from './helpers/miscellaneous';\nimport { IsNonNegativeNumber } from './abstract-ops/miscellaneous';\nimport { convertQueuingStrategy } from './validators/queuing-strategy';\nimport { ExtractHighWaterMark, ExtractSizeAlgorithm } from './abstract-ops/queuing-strategy';\nimport {\n  Transformer,\n  TransformerFlushCallback,\n  TransformerStartCallback,\n  TransformerTransformCallback,\n  ValidatedTransformer\n} from './transform-stream/transformer';\nimport { convertTransformer } from './validators/transformer';\n\n// Class TransformStream\n\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nexport class TransformStream<I = any, O = any> {\n  /** @internal */\n  _writable!: WritableStream<I>;\n  /** @internal */\n  _readable!: ReadableStream<O>;\n  /** @internal */\n  _backpressure!: boolean;\n  /** @internal */\n  _backpressureChangePromise!: Promise<void>;\n  /** @internal */\n  _backpressureChangePromise_resolve!: () => void;\n  /** @internal */\n  _transformStreamController!: TransformStreamDefaultController<O>;\n\n  constructor(\n    transformer?: Transformer<I, O>,\n    writableStrategy?: QueuingStrategy<I>,\n    readableStrategy?: QueuingStrategy<O>\n  );\n  constructor(rawTransformer: Transformer<I, O> | null | undefined = {},\n              rawWritableStrategy: QueuingStrategy<I> | null | undefined = {},\n              rawReadableStrategy: QueuingStrategy<O> | null | undefined = {}) {\n    if (rawTransformer === undefined) {\n      rawTransformer = null;\n    }\n\n    const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n    const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n\n    const transformer = convertTransformer(rawTransformer, 'First parameter');\n    if (transformer.readableType !== undefined) {\n      throw new RangeError('Invalid readableType specified');\n    }\n    if (transformer.writableType !== undefined) {\n      throw new RangeError('Invalid writableType specified');\n    }\n\n    const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n    const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n    const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n    const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n\n    let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n    const startPromise = newPromise<void>(resolve => {\n      startPromise_resolve = resolve;\n    });\n\n    InitializeTransformStream(\n      this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm\n    );\n    SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n    if (transformer.start !== undefined) {\n      startPromise_resolve(transformer.start(this._transformStreamController));\n    } else {\n      startPromise_resolve(undefined);\n    }\n  }\n\n  /**\n   * The readable side of the transform stream.\n   */\n  get readable(): ReadableStream<O> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('readable');\n    }\n\n    return this._readable;\n  }\n\n  /**\n   * The writable side of the transform stream.\n   */\n  get writable(): WritableStream<I> {\n    if (!IsTransformStream(this)) {\n      throw streamBrandCheckException('writable');\n    }\n\n    return this._writable;\n  }\n}\n\nObject.defineProperties(TransformStream.prototype, {\n  readable: { enumerable: true },\n  writable: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {\n    value: 'TransformStream',\n    configurable: true\n  });\n}\n\nexport {\n  Transformer,\n  TransformerStartCallback,\n  TransformerFlushCallback,\n  TransformerTransformCallback\n};\n\n// Transform Stream Abstract Operations\n\nexport function CreateTransformStream<I, O>(startAlgorithm: () => void | PromiseLike<void>,\n                                            transformAlgorithm: (chunk: I) => Promise<void>,\n                                            flushAlgorithm: () => Promise<void>,\n                                            writableHighWaterMark = 1,\n                                            writableSizeAlgorithm: QueuingStrategySizeCallback<I> = () => 1,\n                                            readableHighWaterMark = 0,\n                                            readableSizeAlgorithm: QueuingStrategySizeCallback<O> = () => 1) {\n  assert(IsNonNegativeNumber(writableHighWaterMark));\n  assert(IsNonNegativeNumber(readableHighWaterMark));\n\n  const stream: TransformStream<I, O> = Object.create(TransformStream.prototype);\n\n  let startPromise_resolve!: (value: void | PromiseLike<void>) => void;\n  const startPromise = newPromise<void>(resolve => {\n    startPromise_resolve = resolve;\n  });\n\n  InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark,\n                            readableSizeAlgorithm);\n\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n\n  const startResult = startAlgorithm();\n  startPromise_resolve(startResult);\n  return stream;\n}\n\nfunction InitializeTransformStream<I, O>(stream: TransformStream<I, O>,\n                                         startPromise: Promise<void>,\n                                         writableHighWaterMark: number,\n                                         writableSizeAlgorithm: QueuingStrategySizeCallback<I>,\n                                         readableHighWaterMark: number,\n                                         readableSizeAlgorithm: QueuingStrategySizeCallback<O>) {\n  function startAlgorithm(): Promise<void> {\n    return startPromise;\n  }\n\n  function writeAlgorithm(chunk: I): Promise<void> {\n    return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n\n  function abortAlgorithm(reason: any): Promise<void> {\n    return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n\n  function closeAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm,\n                                          writableHighWaterMark, writableSizeAlgorithm);\n\n  function pullAlgorithm(): Promise<void> {\n    return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n\n  function cancelAlgorithm(reason: any): Promise<void> {\n    TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n    return promiseResolvedWith(undefined);\n  }\n\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark,\n                                          readableSizeAlgorithm);\n\n  // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n  stream._backpressure = undefined!;\n  stream._backpressureChangePromise = undefined!;\n  stream._backpressureChangePromise_resolve = undefined!;\n  TransformStreamSetBackpressure(stream, true);\n\n  stream._transformStreamController = undefined!;\n}\n\nfunction IsTransformStream(x: unknown): x is TransformStream {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n    return false;\n  }\n\n  return x instanceof TransformStream;\n}\n\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream: TransformStream, e: any) {\n  ReadableStreamDefaultControllerError(\n    stream._readable._readableStreamController as ReadableStreamDefaultController<any>,\n    e\n  );\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\n\nfunction TransformStreamErrorWritableAndUnblockWrite(stream: TransformStream, e: any) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure) {\n    // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n    // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n    // _backpressure is set.\n    TransformStreamSetBackpressure(stream, false);\n  }\n}\n\nfunction TransformStreamSetBackpressure(stream: TransformStream, backpressure: boolean) {\n  // Passes also when called during construction.\n  assert(stream._backpressure !== backpressure);\n\n  if (stream._backpressureChangePromise !== undefined) {\n    stream._backpressureChangePromise_resolve();\n  }\n\n  stream._backpressureChangePromise = newPromise(resolve => {\n    stream._backpressureChangePromise_resolve = resolve;\n  });\n\n  stream._backpressure = backpressure;\n}\n\n// Class TransformStreamDefaultController\n\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nexport class TransformStreamDefaultController<O> {\n  /** @internal */\n  _controlledTransformStream: TransformStream<any, O>;\n  /** @internal */\n  _transformAlgorithm: (chunk: any) => Promise<void>;\n  /** @internal */\n  _flushAlgorithm: () => Promise<void>;\n\n  private constructor() {\n    throw new TypeError('Illegal constructor');\n  }\n\n  /**\n   * Returns the desired size to fill the readable side\u2019s internal queue. It can be negative, if the queue is over-full.\n   */\n  get desiredSize(): number | null {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('desiredSize');\n    }\n\n    const readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController as ReadableStreamDefaultController<O>);\n  }\n\n  /**\n   * Enqueues the given chunk `chunk` in the readable side of the controlled transform stream.\n   */\n  enqueue(chunk: O): void;\n  enqueue(chunk: O = undefined!): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('enqueue');\n    }\n\n    TransformStreamDefaultControllerEnqueue(this, chunk);\n  }\n\n  /**\n   * Errors both the readable side and the writable side of the controlled transform stream, making all future\n   * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n   */\n  error(reason: any = undefined): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('error');\n    }\n\n    TransformStreamDefaultControllerError(this, reason);\n  }\n\n  /**\n   * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n   * transformer only needs to consume a portion of the chunks written to the writable side.\n   */\n  terminate(): void {\n    if (!IsTransformStreamDefaultController(this)) {\n      throw defaultControllerBrandCheckException('terminate');\n    }\n\n    TransformStreamDefaultControllerTerminate(this);\n  }\n}\n\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n  enqueue: { enumerable: true },\n  error: { enumerable: true },\n  terminate: { enumerable: true },\n  desiredSize: { enumerable: true }\n});\nif (typeof Symbol.toStringTag === 'symbol') {\n  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {\n    value: 'TransformStreamDefaultController',\n    configurable: true\n  });\n}\n\n// Transform Stream Default Controller Abstract Operations\n\nfunction IsTransformStreamDefaultController<O = any>(x: any): x is TransformStreamDefaultController<O> {\n  if (!typeIsObject(x)) {\n    return false;\n  }\n\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n    return false;\n  }\n\n  return x instanceof TransformStreamDefaultController;\n}\n\nfunction SetUpTransformStreamDefaultController<I, O>(stream: TransformStream<I, O>,\n                                                     controller: TransformStreamDefaultController<O>,\n                                                     transformAlgorithm: (chunk: I) => Promise<void>,\n                                                     flushAlgorithm: () => Promise<void>) {\n  assert(IsTransformStream(stream));\n  assert(stream._transformStreamController === undefined);\n\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n}\n\nfunction SetUpTransformStreamDefaultControllerFromTransformer<I, O>(stream: TransformStream<I, O>,\n                                                                    transformer: ValidatedTransformer<I, O>) {\n  const controller: TransformStreamDefaultController<O> = Object.create(TransformStreamDefaultController.prototype);\n\n  let transformAlgorithm = (chunk: I): Promise<void> => {\n    try {\n      TransformStreamDefaultControllerEnqueue(controller, chunk as unknown as O);\n      return promiseResolvedWith(undefined);\n    } catch (transformResultE) {\n      return promiseRejectedWith(transformResultE);\n    }\n  };\n\n  let flushAlgorithm: () => Promise<void> = () => promiseResolvedWith(undefined);\n\n  if (transformer.transform !== undefined) {\n    transformAlgorithm = chunk => transformer.transform!(chunk, controller);\n  }\n  if (transformer.flush !== undefined) {\n    flushAlgorithm = () => transformer.flush!(controller);\n  }\n\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\n\nfunction TransformStreamDefaultControllerClearAlgorithms(controller: TransformStreamDefaultController<any>) {\n  controller._transformAlgorithm = undefined!;\n  controller._flushAlgorithm = undefined!;\n}\n\nfunction TransformStreamDefaultControllerEnqueue<O>(controller: TransformStreamDefaultController<O>, chunk: O) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController as ReadableStreamDefaultController<O>;\n  if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n    throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n\n  // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n  // accept TransformStreamDefaultControllerEnqueue() calls.\n\n  try {\n    ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n    // This happens when readableStrategy.size() throws.\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n\n    throw stream._readable._storedError;\n  }\n\n  const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n    assert(backpressure);\n    TransformStreamSetBackpressure(stream, true);\n  }\n}\n\nfunction TransformStreamDefaultControllerError(controller: TransformStreamDefaultController<any>, e: any) {\n  TransformStreamError(controller._controlledTransformStream, e);\n}\n\nfunction TransformStreamDefaultControllerPerformTransform<I, O>(controller: TransformStreamDefaultController<O>,\n                                                                chunk: I) {\n  const transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, r => {\n    TransformStreamError(controller._controlledTransformStream, r);\n    throw r;\n  });\n}\n\nfunction TransformStreamDefaultControllerTerminate<O>(controller: TransformStreamDefaultController<O>) {\n  const stream = controller._controlledTransformStream;\n  const readableController = stream._readable._readableStreamController as ReadableStreamDefaultController<O>;\n\n  ReadableStreamDefaultControllerClose(readableController);\n\n  const error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n\n// TransformStreamDefaultSink Algorithms\n\nfunction TransformStreamDefaultSinkWriteAlgorithm<I, O>(stream: TransformStream<I, O>, chunk: I): Promise<void> {\n  assert(stream._writable._state === 'writable');\n\n  const controller = stream._transformStreamController;\n\n  if (stream._backpressure) {\n    const backpressureChangePromise = stream._backpressureChangePromise;\n    assert(backpressureChangePromise !== undefined);\n    return transformPromiseWith(backpressureChangePromise, () => {\n      const writable = stream._writable;\n      const state = writable._state;\n      if (state === 'erroring') {\n        throw writable._storedError;\n      }\n      assert(state === 'writable');\n      return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n    });\n  }\n\n  return TransformStreamDefaultControllerPerformTransform<I, O>(controller, chunk);\n}\n\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream: TransformStream, reason: any): Promise<void> {\n  // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n  // errored.\n  TransformStreamError(stream, reason);\n  return promiseResolvedWith(undefined);\n}\n\nfunction TransformStreamDefaultSinkCloseAlgorithm<I, O>(stream: TransformStream<I, O>): Promise<void> {\n  // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n  const readable = stream._readable;\n\n  const controller = stream._transformStreamController;\n  const flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n\n  // Return a promise that is fulfilled with undefined on success.\n  return transformPromiseWith(flushPromise, () => {\n    if (readable._state === 'errored') {\n      throw readable._storedError;\n    }\n    ReadableStreamDefaultControllerClose(readable._readableStreamController as ReadableStreamDefaultController<O>);\n  }, r => {\n    TransformStreamError(stream, r);\n    throw readable._storedError;\n  });\n}\n\n// TransformStreamDefaultSource Algorithms\n\nfunction TransformStreamDefaultSourcePullAlgorithm(stream: TransformStream): Promise<void> {\n  // Invariant. Enforced by the promises returned by start() and pull().\n  assert(stream._backpressure);\n\n  assert(stream._backpressureChangePromise !== undefined);\n\n  TransformStreamSetBackpressure(stream, false);\n\n  // Prevent the next pull() call until there is backpressure.\n  return stream._backpressureChangePromise;\n}\n\n// Helper functions for the TransformStreamDefaultController.\n\nfunction defaultControllerBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n\n// Helper functions for the TransformStream.\n\nfunction streamBrandCheckException(name: string): TypeError {\n  return new TypeError(\n    `TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n", "/* c8 ignore start */\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n\nif (!globalThis.ReadableStream) {\n  try {\n    Object.assign(globalThis, require('stream/web'))\n  } catch (error) {\n\t\t// TODO: Remove when only supporting node >= 16.5.0\n    Object.assign(globalThis, require('web-streams-polyfill/dist/ponyfill.es2018.js'))\n  }\n}\n\ntry {\n  const {Blob} = require('buffer')\n  if (Blob && !Blob.prototype.stream) {\n\t\tBlob.prototype.stream = function name(params) {\n\t\t\tlet position = 0;\n\t\t\tconst blob = this;\n\n\t\t\treturn new ReadableStream({\n\t\t\t\ttype: 'bytes',\n\t\t\t\tasync pull(ctrl) {\n\t\t\t\t\tconst chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE));\n\t\t\t\t\tconst buffer = await chunk.arrayBuffer();\n\t\t\t\t\tposition += buffer.byteLength;\n\t\t\t\t\tctrl.enqueue(new Uint8Array(buffer))\n\n\t\t\t\t\tif (position === blob.size) {\n\t\t\t\t\t\tctrl.close()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n} catch (error) {}\n/* c8 ignore end */\n", "import fs from \"fs\";\nimport fetch from \"node-fetch\";\n\nlet pmids = fs\n  .readFileSync(`${__dirname}/pmid-bipolardis-set.txt`, \"utf8\")\n  .matchAll(/[0-9][0-9]*/g);\n\nlet pmid_list = \"\";\nlet count = 0;\n\nlet f = (url: string, idx: number) => () =>\n  fetch(url)\n    .then((response) => response.text())\n    .then((xml) => fs.writeFileSync(`${__dirname}/.data/${idx}.xml`, xml));\nlet fn_arr = [];\n\nfor (let [pmid] of pmids) {\n  pmid_list += pmid + \",\";\n  count += 1;\n  if (count % 100 == 0) {\n    let url = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${pmid_list}&retmode=abstract&rettype=xml`;\n    fn_arr.push(f(url, count / 100));\n    pmid_list = \"\";\n  }\n  if (count == 1000) break;\n}\n\nfn_arr.reduce((p, f) => p.then(f), Promise.resolve());\n", "/**\n * Index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport http from 'http';\nimport https from 'https';\nimport zlib from 'zlib';\nimport Stream, {PassThrough, pipeline as pump} from 'stream';\nimport dataUriToBuffer from 'data-uri-to-buffer';\n\nimport {writeToStream} from './body.js';\nimport Response from './response.js';\nimport Headers, {fromRawHeaders} from './headers.js';\nimport Request, {getNodeRequestOptions} from './request.js';\nimport {FetchError} from './errors/fetch-error.js';\nimport {AbortError} from './errors/abort-error.js';\nimport {isRedirect} from './utils/is-redirect.js';\n\nexport {Headers, Request, Response, FetchError, AbortError, isRedirect};\n\nconst supportedSchemas = new Set(['data:', 'http:', 'https:']);\n\n/**\n * Fetch function\n *\n * @param   {string | URL | import('./request').default} url - Absolute url or Request instance\n * @param   {*} [options_] - Fetch options\n * @return  {Promise<import('./response').default>}\n */\nexport default async function fetch(url, options_) {\n\treturn new Promise((resolve, reject) => {\n\t\t// Build request object\n\t\tconst request = new Request(url, options_);\n\t\tconst options = getNodeRequestOptions(request);\n\t\tif (!supportedSchemas.has(options.protocol)) {\n\t\t\tthrow new TypeError(`node-fetch cannot load ${url}. URL scheme \"${options.protocol.replace(/:$/, '')}\" is not supported.`);\n\t\t}\n\n\t\tif (options.protocol === 'data:') {\n\t\t\tconst data = dataUriToBuffer(request.url);\n\t\t\tconst response = new Response(data, {headers: {'Content-Type': data.typeFull}});\n\t\t\tresolve(response);\n\t\t\treturn;\n\t\t}\n\n\t\t// Wrap http.request into fetch\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst {signal} = request;\n\t\tlet response = null;\n\n\t\tconst abort = () => {\n\t\t\tconst error = new AbortError('The operation was aborted.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\n\t\t\tif (!response || !response.body) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = () => {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// Send request\n\t\tconst request_ = send(options);\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tconst finalize = () => {\n\t\t\trequest_.abort();\n\t\t\tif (signal) {\n\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t}\n\t\t};\n\n\t\trequest_.on('error', error => {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));\n\t\t\tfinalize();\n\t\t});\n\n\t\tfixResponseChunkedTransferBadEnding(request_, error => {\n\t\t\tresponse.body.destroy(error);\n\t\t});\n\n\t\t/* c8 ignore next 18 */\n\t\tif (process.version < 'v14') {\n\t\t\t// Before Node.js 14, pipeline() does not fully support async iterators and does not always\n\t\t\t// properly handle when the socket close/end events are out of order.\n\t\t\trequest_.on('socket', s => {\n\t\t\t\tlet endedWithEventsCount;\n\t\t\t\ts.prependListener('end', () => {\n\t\t\t\t\tendedWithEventsCount = s._eventsCount;\n\t\t\t\t});\n\t\t\t\ts.prependListener('close', hadError => {\n\t\t\t\t\t// if end happened before close but the socket didn't emit an error, do it now\n\t\t\t\t\tif (response && endedWithEventsCount < s._eventsCount && !hadError) {\n\t\t\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\t\t\tresponse.body.emit('error', error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\trequest_.on('response', response_ => {\n\t\t\trequest_.setTimeout(0);\n\t\t\tconst headers = fromRawHeaders(response_.rawHeaders);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (isRedirect(response_.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : new URL(location, request.url);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// Node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow': {\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOptions = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (response_.statusCode !== 303 && request.body && options_.body instanceof Stream.Readable) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {\n\t\t\t\t\t\t\trequestOptions.method = 'GET';\n\t\t\t\t\t\t\trequestOptions.body = undefined;\n\t\t\t\t\t\t\trequestOptions.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOptions)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Prepare response\n\t\t\tif (signal) {\n\t\t\t\tresponse_.once('end', () => {\n\t\t\t\t\tsignal.removeEventListener('abort', abortAndFinalize);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet body = pump(response_, new PassThrough(), reject);\n\t\t\t// see https://github.com/nodejs/node/pull/29376\n\t\t\tif (process.version < 'v12.10') {\n\t\t\t\tresponse_.on('aborted', abortAndFinalize);\n\t\t\t}\n\n\t\t\tconst responseOptions = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: response_.statusCode,\n\t\t\t\tstatusText: response_.statusMessage,\n\t\t\t\theaders,\n\t\t\t\tsize: request.size,\n\t\t\t\tcounter: request.counter,\n\t\t\t\thighWaterMark: request.highWaterMark\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// For gzip\n\t\t\tif (codings === 'gzip' || codings === 'x-gzip') {\n\t\t\t\tbody = pump(body, zlib.createGunzip(zlibOptions), reject);\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For deflate\n\t\t\tif (codings === 'deflate' || codings === 'x-deflate') {\n\t\t\t\t// Handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = pump(response_, new PassThrough(), reject);\n\t\t\t\traw.once('data', chunk => {\n\t\t\t\t\t// See http://stackoverflow.com/questions/37519828\n\t\t\t\t\tbody = (chunk[0] & 0x0F) === 0x08 ? pump(body, zlib.createInflate(), reject) : pump(body, zlib.createInflateRaw(), reject);\n\n\t\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For br\n\t\t\tif (codings === 'br') {\n\t\t\t\tbody = pump(body, zlib.createBrotliDecompress(), reject);\n\t\t\t\tresponse = new Response(body, responseOptions);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, use response as-is\n\t\t\tresponse = new Response(body, responseOptions);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(request_, request);\n\t});\n}\n\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n\tconst LAST_CHUNK = Buffer.from('0\\r\\n\\r\\n');\n\n\tlet isChunkedTransfer = false;\n\tlet properLastChunkReceived = false;\n\tlet previousChunk;\n\n\trequest.on('response', response => {\n\t\tconst {headers} = response;\n\t\tisChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];\n\t});\n\n\trequest.on('socket', socket => {\n\t\tconst onSocketClose = () => {\n\t\t\tif (isChunkedTransfer && !properLastChunkReceived) {\n\t\t\t\tconst error = new Error('Premature close');\n\t\t\t\terror.code = 'ERR_STREAM_PREMATURE_CLOSE';\n\t\t\t\terrorCallback(error);\n\t\t\t}\n\t\t};\n\n\t\tsocket.prependListener('close', onSocketClose);\n\n\t\trequest.on('abort', () => {\n\t\t\tsocket.removeListener('close', onSocketClose);\n\t\t});\n\n\t\tsocket.on('data', buf => {\n\t\t\tproperLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;\n\n\t\t\t// Sometimes final 0-length chunk and end of message code are in separate packets\n\t\t\tif (!properLastChunkReceived && previousChunk) {\n\t\t\t\tproperLastChunkReceived = (\n\t\t\t\t\tBuffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&\n\t\t\t\t\tBuffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tpreviousChunk = buf;\n\t\t});\n\t});\n}\n", "\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nimport Stream, {PassThrough} from 'stream';\nimport {types} from 'util';\n\nimport Blob from 'fetch-blob';\n\nimport {FetchError} from './errors/fetch-error.js';\nimport {FetchBaseError} from './errors/base.js';\nimport {formDataIterator, getBoundary, getFormDataLength} from './utils/form-data.js';\nimport {isBlob, isURLSearchParameters, isFormData} from './utils/is.js';\n\nconst INTERNALS = Symbol('Body internals');\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Body {\n\tconstructor(body, {\n\t\tsize = 0\n\t} = {}) {\n\t\tlet boundary = null;\n\n\t\tif (body === null) {\n\t\t\t// Body is undefined or null\n\t\t\tbody = null;\n\t\t} else if (isURLSearchParameters(body)) {\n\t\t// Body is a URLSearchParams\n\t\t\tbody = Buffer.from(body.toString());\n\t\t} else if (isBlob(body)) {\n\t\t\t// Body is blob\n\t\t} else if (Buffer.isBuffer(body)) {\n\t\t\t// Body is Buffer\n\t\t} else if (types.isAnyArrayBuffer(body)) {\n\t\t\t// Body is ArrayBuffer\n\t\t\tbody = Buffer.from(body);\n\t\t} else if (ArrayBuffer.isView(body)) {\n\t\t\t// Body is ArrayBufferView\n\t\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t\t} else if (body instanceof Stream) {\n\t\t\t// Body is stream\n\t\t} else if (isFormData(body)) {\n\t\t\t// Body is an instance of formdata-node\n\t\t\tboundary = `NodeFetchFormDataBoundary${getBoundary()}`;\n\t\t\tbody = Stream.Readable.from(formDataIterator(body, boundary));\n\t\t} else {\n\t\t\t// None of the above\n\t\t\t// coerce to string then buffer\n\t\t\tbody = Buffer.from(String(body));\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tbody,\n\t\t\tboundary,\n\t\t\tdisturbed: false,\n\t\t\terror: null\n\t\t};\n\t\tthis.size = size;\n\n\t\tif (body instanceof Stream) {\n\t\t\tbody.on('error', error_ => {\n\t\t\t\tconst error = error_ instanceof FetchBaseError ?\n\t\t\t\t\terror_ :\n\t\t\t\t\tnew FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);\n\t\t\t\tthis[INTERNALS].error = error;\n\t\t\t});\n\t\t}\n\t}\n\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t}\n\n\t/**\n\t * Decode response as ArrayBuffer\n\t *\n\t * @return  Promise\n\t */\n\tasync arrayBuffer() {\n\t\tconst {buffer, byteOffset, byteLength} = await consumeBody(this);\n\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t}\n\n\t/**\n\t * Return raw response as Blob\n\t *\n\t * @return Promise\n\t */\n\tasync blob() {\n\t\tconst ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS].body && this[INTERNALS].body.type) || '';\n\t\tconst buf = await this.buffer();\n\n\t\treturn new Blob([buf], {\n\t\t\ttype: ct\n\t\t});\n\t}\n\n\t/**\n\t * Decode response as json\n\t *\n\t * @return  Promise\n\t */\n\tasync json() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn JSON.parse(buffer.toString());\n\t}\n\n\t/**\n\t * Decode response as text\n\t *\n\t * @return  Promise\n\t */\n\tasync text() {\n\t\tconst buffer = await consumeBody(this);\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * Decode response as buffer (non-spec api)\n\t *\n\t * @return  Promise\n\t */\n\tbuffer() {\n\t\treturn consumeBody(this);\n\t}\n}\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: {enumerable: true},\n\tbodyUsed: {enumerable: true},\n\tarrayBuffer: {enumerable: true},\n\tblob: {enumerable: true},\n\tjson: {enumerable: true},\n\ttext: {enumerable: true}\n});\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\nasync function consumeBody(data) {\n\tif (data[INTERNALS].disturbed) {\n\t\tthrow new TypeError(`body used already for: ${data.url}`);\n\t}\n\n\tdata[INTERNALS].disturbed = true;\n\n\tif (data[INTERNALS].error) {\n\t\tthrow data[INTERNALS].error;\n\t}\n\n\tlet {body} = data;\n\n\t// Body is null\n\tif (body === null) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\tbody = Stream.Readable.from(body.stream());\n\t}\n\n\t// Body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body;\n\t}\n\n\t/* c8 ignore next 3 */\n\tif (!(body instanceof Stream)) {\n\t\treturn Buffer.alloc(0);\n\t}\n\n\t// Body is stream\n\t// get ready to actually consume the body\n\tconst accum = [];\n\tlet accumBytes = 0;\n\n\ttry {\n\t\tfor await (const chunk of body) {\n\t\t\tif (data.size > 0 && accumBytes + chunk.length > data.size) {\n\t\t\t\tconst error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');\n\t\t\t\tbody.destroy(error);\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t}\n\t} catch (error) {\n\t\tconst error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);\n\t\tthrow error_;\n\t}\n\n\tif (body.readableEnded === true || body._readableState.ended === true) {\n\t\ttry {\n\t\t\tif (accum.every(c => typeof c === 'string')) {\n\t\t\t\treturn Buffer.from(accum.join(''));\n\t\t\t}\n\n\t\t\treturn Buffer.concat(accum, accumBytes);\n\t\t} catch (error) {\n\t\t\tthrow new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);\n\t\t}\n\t} else {\n\t\tthrow new FetchError(`Premature close of server response while trying to fetch ${data.url}`);\n\t}\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\nexport const clone = (instance, highWaterMark) => {\n\tlet p1;\n\tlet p2;\n\tlet {body} = instance;\n\n\t// Don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// Check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n\t\t// Tee instance body\n\t\tp1 = new PassThrough({highWaterMark});\n\t\tp2 = new PassThrough({highWaterMark});\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// Set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n};\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\nexport const extractContentType = (body, request) => {\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn null;\n\t}\n\n\t// Body is string\n\tif (typeof body === 'string') {\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n\n\t// Body is a URLSearchParams\n\tif (isURLSearchParameters(body)) {\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t}\n\n\t// Body is blob\n\tif (isBlob(body)) {\n\t\treturn body.type || null;\n\t}\n\n\t// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\tif (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n\t\treturn null;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getBoundary === 'function') {\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t}\n\n\tif (isFormData(body)) {\n\t\treturn `multipart/form-data; boundary=${request[INTERNALS].boundary}`;\n\t}\n\n\t// Body is stream - can't really do much about this\n\tif (body instanceof Stream) {\n\t\treturn null;\n\t}\n\n\t// Body constructor defaults other things to string\n\treturn 'text/plain;charset=UTF-8';\n};\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\nexport const getTotalBytes = request => {\n\tconst {body} = request;\n\n\t// Body is null or undefined\n\tif (body === null) {\n\t\treturn 0;\n\t}\n\n\t// Body is Blob\n\tif (isBlob(body)) {\n\t\treturn body.size;\n\t}\n\n\t// Body is Buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn body.length;\n\t}\n\n\t// Detect form data input from form-data module\n\tif (body && typeof body.getLengthSync === 'function') {\n\t\treturn body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n\t}\n\n\t// Body is a spec-compliant form-data\n\tif (isFormData(body)) {\n\t\treturn getFormDataLength(request[INTERNALS].boundary);\n\t}\n\n\t// Body is stream\n\treturn null;\n};\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {void}\n */\nexport const writeToStream = (dest, {body}) => {\n\tif (body === null) {\n\t\t// Body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\t// Body is Blob\n\t\tStream.Readable.from(body.stream()).pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// Body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// Body is stream\n\t\tbody.pipe(dest);\n\t}\n};\n", "\n// TODO (jimmywarting): in the feature use conditional loading with top level await (requires 14.x)\n// Node has recently added whatwg stream into core\n\nimport './streams.cjs';\n\n/** @typedef {import('buffer').Blob} NodeBlob} */\n\n// 64 KiB (same size chrome slice theirs blob into Uint8array's)\nconst POOL_SIZE = 65536;\n\n/** @param {(Blob | NodeBlob | Uint8Array)[]} parts */\nasync function * toIterator (parts, clone = true) {\n\tfor (let part of parts) {\n\t\tif ('stream' in part) {\n\t\t\tyield * part.stream();\n\t\t} else if (ArrayBuffer.isView(part)) {\n\t\t\tif (clone) {\n\t\t\t\tlet position = part.byteOffset;\n\t\t\t\tlet end = part.byteOffset + part.byteLength;\n\t\t\t\twhile (position !== end) {\n\t\t\t\t\tconst size = Math.min(end - position, POOL_SIZE);\n\t\t\t\t\tconst chunk = part.buffer.slice(position, position + size);\n\t\t\t\t\tposition += chunk.byteLength;\n\t\t\t\t\tyield new Uint8Array(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyield part;\n\t\t\t}\n\t\t} else {\n\t\t\t/* c8 ignore start */\n\t\t\t// For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)\n\t\t\tlet position = 0;\n\t\t\twhile (position !== part.size) {\n\t\t\t\tconst chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));\n\t\t\t\tconst buffer = await chunk.arrayBuffer();\n\t\t\t\tposition += buffer.byteLength;\n\t\t\t\tyield new Uint8Array(buffer);\n\t\t\t}\n\t\t\t/* c8 ignore end */\n\t\t}\n\t}\n}\n\nconst _Blob = class Blob {\n\n\t/** @type {Array.<(Blob|Uint8Array)>} */\n\t#parts = [];\n\t#type = '';\n\t#size = 0;\n\n\t/**\n\t * The Blob() constructor returns a new Blob object. The content\n\t * of the blob consists of the concatenation of the values given\n\t * in the parameter array.\n\t *\n\t * @param {*} blobParts\n\t * @param {{ type?: string }} [options]\n\t */\n\tconstructor(blobParts = [], options = {}) {\n\t\tlet size = 0;\n\n\t\tconst parts = blobParts.map(element => {\n\t\t\tlet part;\n\t\t\tif (ArrayBuffer.isView(element)) {\n\t\t\t\tpart = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));\n\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\tpart = new Uint8Array(element.slice(0));\n\t\t\t} else if (element instanceof Blob) {\n\t\t\t\tpart = element;\n\t\t\t} else {\n\t\t\t\tpart = new TextEncoder().encode(element);\n\t\t\t}\n\n\t\t\tsize += ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\t\t\treturn part;\n\t\t});\n\n\t\tconst type = options.type === undefined ? '' : String(options.type);\n\n\t\tthis.#type = /[^\\u0020-\\u007E]/.test(type) ? '' : type;\n\t\tthis.#size = size;\n\t\tthis.#parts = parts;\n\t}\n\n\t/**\n\t * The Blob interface's size property returns the\n\t * size of the Blob in bytes.\n\t */\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t/**\n\t * The type property of a Blob object returns the MIME type of the file.\n\t */\n\tget type() {\n\t\treturn this.#type;\n\t}\n\n\t/**\n\t * The text() method in the Blob interface returns a Promise\n\t * that resolves with a string containing the contents of\n\t * the blob, interpreted as UTF-8.\n\t *\n\t * @return {Promise<string>}\n\t */\n\tasync text() {\n\t\t// More optimized than using this.arrayBuffer()\n\t\t// that requires twice as much ram\n\t\tconst decoder = new TextDecoder();\n\t\tlet str = '';\n\t\tfor await (let part of toIterator(this.#parts, false)) {\n\t\t\tstr += decoder.decode(part, { stream: true });\n\t\t}\n\t\t// Remaining\n\t\tstr += decoder.decode();\n\t\treturn str;\n\t}\n\n\t/**\n\t * The arrayBuffer() method in the Blob interface returns a\n\t * Promise that resolves with the contents of the blob as\n\t * binary data contained in an ArrayBuffer.\n\t *\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tasync arrayBuffer() {\n\t\t// Easier way... Just a unnecessary overhead\n\t\t// const view = new Uint8Array(this.size);\n\t\t// await this.stream().getReader({mode: 'byob'}).read(view);\n\t\t// return view.buffer;\n\n\t\tconst data = new Uint8Array(this.size);\n\t\tlet offset = 0;\n\t\tfor await (const chunk of toIterator(this.#parts, false)) {\n\t\t\tdata.set(chunk, offset);\n\t\t\toffset += chunk.length;\n\t\t}\n\n\t\treturn data.buffer;\n\t}\n\n\tstream() {\n\t\tconst it = toIterator(this.#parts, true);\n\n\t\treturn new ReadableStream({\n\t\t\ttype: 'bytes',\n\t\t\tasync pull(ctrl) {\n\t\t\t\tconst chunk = await it.next();\n\t\t\t\tchunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * The Blob interface's slice() method creates and returns a\n\t * new Blob object which contains data from a subset of the\n\t * blob on which it's called.\n\t *\n\t * @param {number} [start]\n\t * @param {number} [end]\n\t * @param {string} [type]\n\t */\n\tslice(start = 0, end = this.size, type = '') {\n\t\tconst {size} = this;\n\n\t\tlet relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n\t\tlet relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\t\tconst parts = this.#parts;\n\t\tconst blobParts = [];\n\t\tlet added = 0;\n\n\t\tfor (const part of parts) {\n\t\t\t// don't add the overflow to new blobParts\n\t\t\tif (added >= span) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst size = ArrayBuffer.isView(part) ? part.byteLength : part.size;\n\t\t\tif (relativeStart && size <= relativeStart) {\n\t\t\t\t// Skip the beginning and change the relative\n\t\t\t\t// start & end position as we skip the unwanted parts\n\t\t\t\trelativeStart -= size;\n\t\t\t\trelativeEnd -= size;\n\t\t\t} else {\n\t\t\t\tlet chunk\n\t\t\t\tif (ArrayBuffer.isView(part)) {\n\t\t\t\t\tchunk = part.subarray(relativeStart, Math.min(size, relativeEnd));\n\t\t\t\t\tadded += chunk.byteLength\n\t\t\t\t} else {\n\t\t\t\t\tchunk = part.slice(relativeStart, Math.min(size, relativeEnd));\n\t\t\t\t\tadded += chunk.size\n\t\t\t\t}\n\t\t\t\tblobParts.push(chunk);\n\t\t\t\trelativeStart = 0; // All next sequential parts should start at 0\n\t\t\t}\n\t\t}\n\n\t\tconst blob = new Blob([], {type: String(type).toLowerCase()});\n\t\tblob.#size = span;\n\t\tblob.#parts = blobParts;\n\n\t\treturn blob;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Blob';\n\t}\n\n\tstatic [Symbol.hasInstance](object) {\n\t\treturn (\n\t\t\tobject &&\n\t\t\ttypeof object === 'object' &&\n\t\t\ttypeof object.constructor === 'function' &&\n\t\t\t(\n\t\t\t\ttypeof object.stream === 'function' ||\n\t\t\t\ttypeof object.arrayBuffer === 'function'\n\t\t\t) &&\n\t\t\t/^(Blob|File)$/.test(object[Symbol.toStringTag])\n\t\t);\n\t}\n}\n\nObject.defineProperties(_Blob.prototype, {\n\tsize: {enumerable: true},\n\ttype: {enumerable: true},\n\tslice: {enumerable: true}\n});\n\n/** @type {typeof globalThis.Blob} */\nexport const Blob = _Blob;\nexport default Blob;\n", "export class FetchBaseError extends Error {\n\tconstructor(message, type) {\n\t\tsuper(message);\n\t\t// Hide custom error implementation details from end-users\n\t\tError.captureStackTrace(this, this.constructor);\n\n\t\tthis.type = type;\n\t}\n\n\tget name() {\n\t\treturn this.constructor.name;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n}\n", "\nimport {FetchBaseError} from './base.js';\n\n/**\n * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError\n*/\n\n/**\n * FetchError interface for operational errors\n */\nexport class FetchError extends FetchBaseError {\n\t/**\n\t * @param  {string} message -      Error message for human\n\t * @param  {string} [type] -        Error type for machine\n\t * @param  {SystemError} [systemError] - For Node.js system error\n\t */\n\tconstructor(message, type, systemError) {\n\t\tsuper(message, type);\n\t\t// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code\n\t\tif (systemError) {\n\t\t\t// eslint-disable-next-line no-multi-assign\n\t\t\tthis.code = this.errno = systemError.code;\n\t\t\tthis.erroredSysCall = systemError.syscall;\n\t\t}\n\t}\n}\n", "import {randomBytes} from 'crypto';\n\nimport {isBlob} from './is.js';\n\nconst carriage = '\\r\\n';\nconst dashes = '-'.repeat(2);\nconst carriageLength = Buffer.byteLength(carriage);\n\n/**\n * @param {string} boundary\n */\nconst getFooter = boundary => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;\n\n/**\n * @param {string} boundary\n * @param {string} name\n * @param {*} field\n *\n * @return {string}\n */\nfunction getHeader(boundary, name, field) {\n\tlet header = '';\n\n\theader += `${dashes}${boundary}${carriage}`;\n\theader += `Content-Disposition: form-data; name=\"${name}\"`;\n\n\tif (isBlob(field)) {\n\t\theader += `; filename=\"${field.name}\"${carriage}`;\n\t\theader += `Content-Type: ${field.type || 'application/octet-stream'}`;\n\t}\n\n\treturn `${header}${carriage.repeat(2)}`;\n}\n\n/**\n * @return {string}\n */\nexport const getBoundary = () => randomBytes(8).toString('hex');\n\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\nexport async function * formDataIterator(form, boundary) {\n\tfor (const [name, value] of form) {\n\t\tyield getHeader(boundary, name, value);\n\n\t\tif (isBlob(value)) {\n\t\t\tyield * value.stream();\n\t\t} else {\n\t\t\tyield value;\n\t\t}\n\n\t\tyield carriage;\n\t}\n\n\tyield getFooter(boundary);\n}\n\n/**\n * @param {FormData} form\n * @param {string} boundary\n */\nexport function getFormDataLength(form, boundary) {\n\tlet length = 0;\n\n\tfor (const [name, value] of form) {\n\t\tlength += Buffer.byteLength(getHeader(boundary, name, value));\n\n\t\tlength += isBlob(value) ? value.size : Buffer.byteLength(String(value));\n\n\t\tlength += carriageLength;\n\t}\n\n\tlength += Buffer.byteLength(getFooter(boundary));\n\n\treturn length;\n}\n", "/**\n * Is.js\n *\n * Object type checks.\n */\n\nconst NAME = Symbol.toStringTag;\n\n/**\n * Check if `obj` is a URLSearchParams object\n * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143\n *\n * @param  {*} obj\n * @return {boolean}\n */\nexport const isURLSearchParameters = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.append === 'function' &&\n\t\ttypeof object.delete === 'function' &&\n\t\ttypeof object.get === 'function' &&\n\t\ttypeof object.getAll === 'function' &&\n\t\ttypeof object.has === 'function' &&\n\t\ttypeof object.set === 'function' &&\n\t\ttypeof object.sort === 'function' &&\n\t\tobject[NAME] === 'URLSearchParams'\n\t);\n};\n\n/**\n * Check if `object` is a W3C `Blob` object (which `File` inherits from)\n *\n * @param  {*} obj\n * @return {boolean}\n */\nexport const isBlob = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.arrayBuffer === 'function' &&\n\t\ttypeof object.type === 'string' &&\n\t\ttypeof object.stream === 'function' &&\n\t\ttypeof object.constructor === 'function' &&\n\t\t/^(Blob|File)$/.test(object[NAME])\n\t);\n};\n\n/**\n * Check if `obj` is a spec-compliant `FormData` object\n *\n * @param {*} object\n * @return {boolean}\n */\nexport function isFormData(object) {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object.append === 'function' &&\n\t\ttypeof object.set === 'function' &&\n\t\ttypeof object.get === 'function' &&\n\t\ttypeof object.getAll === 'function' &&\n\t\ttypeof object.delete === 'function' &&\n\t\ttypeof object.keys === 'function' &&\n\t\ttypeof object.values === 'function' &&\n\t\ttypeof object.entries === 'function' &&\n\t\ttypeof object.constructor === 'function' &&\n\t\tobject[NAME] === 'FormData'\n\t);\n}\n\n/**\n * Check if `obj` is an instance of AbortSignal.\n *\n * @param  {*} obj\n * @return {boolean}\n */\nexport const isAbortSignal = object => {\n\treturn (\n\t\ttypeof object === 'object' && (\n\t\t\tobject[NAME] === 'AbortSignal' ||\n\t\t\tobject[NAME] === 'EventTarget'\n\t\t)\n\t);\n};\n\n", "/**\n * Headers.js\n *\n * Headers class offers convenient helpers\n */\n\nimport {types} from 'util';\nimport http from 'http';\n\nconst validateHeaderName = typeof http.validateHeaderName === 'function' ?\n\thttp.validateHeaderName :\n\tname => {\n\t\tif (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(name)) {\n\t\t\tconst error = new TypeError(`Header name must be a valid HTTP token [${name}]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\nconst validateHeaderValue = typeof http.validateHeaderValue === 'function' ?\n\thttp.validateHeaderValue :\n\t(name, value) => {\n\t\tif (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(value)) {\n\t\t\tconst error = new TypeError(`Invalid character in header content [\"${name}\"]`);\n\t\t\tObject.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});\n\t\t\tthrow error;\n\t\t}\n\t};\n\n/**\n * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit\n */\n\n/**\n * This Fetch API interface allows you to perform various actions on HTTP request and response headers.\n * These actions include retrieving, setting, adding to, and removing.\n * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.\n * You can add to this using methods like append() (see Examples.)\n * In all methods of this interface, header names are matched by case-insensitive byte sequence.\n *\n */\nexport default class Headers extends URLSearchParams {\n\t/**\n\t * Headers class\n\t *\n\t * @constructor\n\t * @param {HeadersInit} [init] - Response headers\n\t */\n\tconstructor(init) {\n\t\t// Validate and normalize init object in [name, value(s)][]\n\t\t/** @type {string[][]} */\n\t\tlet result = [];\n\t\tif (init instanceof Headers) {\n\t\t\tconst raw = init.raw();\n\t\t\tfor (const [name, values] of Object.entries(raw)) {\n\t\t\t\tresult.push(...values.map(value => [name, value]));\n\t\t\t}\n\t\t} else if (init == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\t\t// No op\n\t\t} else if (typeof init === 'object' && !types.isBoxedPrimitive(init)) {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\t\tif (method == null) {\n\t\t\t\t// Record<ByteString, ByteString>\n\t\t\t\tresult.push(...Object.entries(init));\n\t\t\t} else {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// Sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tresult = [...init]\n\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof pair !== 'object' || types.isBoxedPrimitive(pair)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be an iterable object');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t}).map(pair => {\n\t\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn [...pair];\n\t\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Failed to construct \\'Headers\\': The provided value is not of type \\'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');\n\t\t}\n\n\t\t// Validate and lowercase\n\t\tresult =\n\t\t\tresult.length > 0 ?\n\t\t\t\tresult.map(([name, value]) => {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn [String(name).toLowerCase(), String(value)];\n\t\t\t\t}) :\n\t\t\t\tundefined;\n\n\t\tsuper(result);\n\n\t\t// Returning a Proxy that will lowercase key names, validate parameters and sort keys\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn new Proxy(this, {\n\t\t\tget(target, p, receiver) {\n\t\t\t\tswitch (p) {\n\t\t\t\t\tcase 'append':\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\treturn (name, value) => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase(),\n\t\t\t\t\t\t\t\tString(value)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'delete':\n\t\t\t\t\tcase 'has':\n\t\t\t\t\tcase 'getAll':\n\t\t\t\t\t\treturn name => {\n\t\t\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\t\t\treturn URLSearchParams.prototype[p].call(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tString(name).toLowerCase()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\n\t\t\t\t\tcase 'keys':\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\ttarget.sort();\n\t\t\t\t\t\t\treturn new Set(URLSearchParams.prototype.keys.call(target)).keys();\n\t\t\t\t\t\t};\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn Reflect.get(target, p, receiver);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* c8 ignore next */\n\t\t});\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn this.constructor.name;\n\t}\n\n\ttoString() {\n\t\treturn Object.prototype.toString.call(this);\n\t}\n\n\tget(name) {\n\t\tconst values = this.getAll(name);\n\t\tif (values.length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet value = values.join(', ');\n\t\tif (/^content-encoding$/i.test(name)) {\n\t\t\tvalue = value.toLowerCase();\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tforEach(callback, thisArg = undefined) {\n\t\tfor (const name of this.keys()) {\n\t\t\tReflect.apply(callback, thisArg, [this.get(name), name, this]);\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield this.get(name);\n\t\t}\n\t}\n\n\t/**\n\t * @type {() => IterableIterator<[string, string]>}\n\t */\n\t* entries() {\n\t\tfor (const name of this.keys()) {\n\t\t\tyield [name, this.get(name)];\n\t\t}\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\t/**\n\t * Node-fetch non-spec method\n\t * returning all headers and their values as array\n\t * @returns {Record<string, string[]>}\n\t */\n\traw() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tresult[key] = this.getAll(key);\n\t\t\treturn result;\n\t\t}, {});\n\t}\n\n\t/**\n\t * For better console.log(headers) and also to convert Headers into Node.js Request compatible format\n\t */\n\t[Symbol.for('nodejs.util.inspect.custom')]() {\n\t\treturn [...this.keys()].reduce((result, key) => {\n\t\t\tconst values = this.getAll(key);\n\t\t\t// Http.request() only supports string as Host header.\n\t\t\t// This hack makes specifying custom Host header possible.\n\t\t\tif (key === 'host') {\n\t\t\t\tresult[key] = values[0];\n\t\t\t} else {\n\t\t\t\tresult[key] = values.length > 1 ? values : values[0];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, {});\n\t}\n}\n\n/**\n * Re-shaping object for Web IDL tests\n * Only need to do it for overridden methods\n */\nObject.defineProperties(\n\tHeaders.prototype,\n\t['get', 'entries', 'forEach', 'values'].reduce((result, property) => {\n\t\tresult[property] = {enumerable: true};\n\t\treturn result;\n\t}, {})\n);\n\n/**\n * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do\n * not conform to HTTP grammar productions.\n * @param {import('http').IncomingMessage['rawHeaders']} headers\n */\nexport function fromRawHeaders(headers = []) {\n\treturn new Headers(\n\t\theaders\n\t\t\t// Split into pairs\n\t\t\t.reduce((result, value, index, array) => {\n\t\t\t\tif (index % 2 === 0) {\n\t\t\t\t\tresult.push(array.slice(index, index + 2));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}, [])\n\t\t\t.filter(([name, value]) => {\n\t\t\t\ttry {\n\t\t\t\t\tvalidateHeaderName(name);\n\t\t\t\t\tvalidateHeaderValue(name, String(value));\n\t\t\t\t\treturn true;\n\t\t\t\t} catch {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t})\n\n\t);\n}\n", "const redirectStatus = new Set([301, 302, 303, 307, 308]);\n\n/**\n * Redirect code matching\n *\n * @param {number} code - Status code\n * @return {boolean}\n */\nexport const isRedirect = code => {\n\treturn redirectStatus.has(code);\n};\n", "/**\n * Response.js\n *\n * Response class provides content decoding\n */\n\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType} from './body.js';\nimport {isRedirect} from './utils/is-redirect.js';\n\nconst INTERNALS = Symbol('Response internals');\n\n/**\n * Response class\n *\n * Ref: https://fetch.spec.whatwg.org/#response-class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexport default class Response extends Body {\n\tconstructor(body = null, options = {}) {\n\t\tsuper(body, options);\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition\n\t\tconst status = options.status != null ? options.status : 200;\n\n\t\tconst headers = new Headers(options.headers);\n\n\t\tif (body !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\ttype: 'default',\n\t\t\turl: options.url,\n\t\t\tstatus,\n\t\t\tstatusText: options.statusText || '',\n\t\t\theaders,\n\t\t\tcounter: options.counter,\n\t\t\thighWaterMark: options.highWaterMark\n\t\t};\n\t}\n\n\tget type() {\n\t\treturn this[INTERNALS].type;\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS].status;\n\t}\n\n\t/**\n\t * Convenience property representing if the request ended normally\n\t */\n\tget ok() {\n\t\treturn this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget highWaterMark() {\n\t\treturn this[INTERNALS].highWaterMark;\n\t}\n\n\t/**\n\t * Clone this response\n\t *\n\t * @return  Response\n\t */\n\tclone() {\n\t\treturn new Response(clone(this, this.highWaterMark), {\n\t\t\ttype: this.type,\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected,\n\t\t\tsize: this.size\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} url    The URL that the new response is to originate from.\n\t * @param {number} status An optional status code for the response (e.g., 302.)\n\t * @returns {Response}    A Response object.\n\t */\n\tstatic redirect(url, status = 302) {\n\t\tif (!isRedirect(status)) {\n\t\t\tthrow new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n\t\t}\n\n\t\treturn new Response(null, {\n\t\t\theaders: {\n\t\t\t\tlocation: new URL(url).toString()\n\t\t\t},\n\t\t\tstatus\n\t\t});\n\t}\n\n\tstatic error() {\n\t\tconst response = new Response(null, {status: 0, statusText: ''});\n\t\tresponse[INTERNALS].type = 'error';\n\t\treturn response;\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Response';\n\t}\n}\n\nObject.defineProperties(Response.prototype, {\n\ttype: {enumerable: true},\n\turl: {enumerable: true},\n\tstatus: {enumerable: true},\n\tok: {enumerable: true},\n\tredirected: {enumerable: true},\n\tstatusText: {enumerable: true},\n\theaders: {enumerable: true},\n\tclone: {enumerable: true}\n});\n", "\n/**\n * Request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */\n\nimport {format as formatUrl} from 'url';\nimport Headers from './headers.js';\nimport Body, {clone, extractContentType, getTotalBytes} from './body.js';\nimport {isAbortSignal} from './utils/is.js';\nimport {getSearch} from './utils/get-search.js';\n\nconst INTERNALS = Symbol('Request internals');\n\n/**\n * Check if `obj` is an instance of Request.\n *\n * @param  {*} obj\n * @return {boolean}\n */\nconst isRequest = object => {\n\treturn (\n\t\ttypeof object === 'object' &&\n\t\ttypeof object[INTERNALS] === 'object'\n\t);\n};\n\n/**\n * Request class\n *\n * Ref: https://fetch.spec.whatwg.org/#request-class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nexport default class Request extends Body {\n\tconstructor(input, init = {}) {\n\t\tlet parsedURL;\n\n\t\t// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)\n\t\tif (isRequest(input)) {\n\t\t\tparsedURL = new URL(input.url);\n\t\t} else {\n\t\t\tparsedURL = new URL(input);\n\t\t\tinput = {};\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif (((init.body != null || isRequest(input)) && input.body !== null) &&\n\t\t\t(method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tconst inputBody = init.body ?\n\t\t\tinit.body :\n\t\t\t(isRequest(input) && input.body !== null ?\n\t\t\t\tclone(input) :\n\t\t\t\tnull);\n\n\t\tsuper(inputBody, {\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody !== null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody, this);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ?\n\t\t\tinput.signal :\n\t\t\tnull;\n\t\tif ('signal' in init) {\n\t\t\tsignal = init.signal;\n\t\t}\n\n\t\t// eslint-disable-next-line no-eq-null, eqeqeq\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');\n\t\t}\n\n\t\tthis[INTERNALS] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// Node-fetch-only options\n\t\tthis.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;\n\t\tthis.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t\tthis.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;\n\t\tthis.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS].method;\n\t}\n\n\tget url() {\n\t\treturn formatUrl(this[INTERNALS].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS].signal;\n\t}\n\n\t/**\n\t * Clone this request\n\t *\n\t * @return  Request\n\t */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn 'Request';\n\t}\n}\n\nObject.defineProperties(Request.prototype, {\n\tmethod: {enumerable: true},\n\turl: {enumerable: true},\n\theaders: {enumerable: true},\n\tredirect: {enumerable: true},\n\tclone: {enumerable: true},\n\tsignal: {enumerable: true}\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nexport const getNodeRequestOptions = request => {\n\tconst {parsedURL} = request[INTERNALS];\n\tconst headers = new Headers(request[INTERNALS].headers);\n\n\t// Fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body === null && /^(post|put)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\n\tif (request.body !== null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\t// Set Content-Length if totalBytes is a number (that is not NaN)\n\t\tif (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate,br');\n\t}\n\n\tlet {agent} = request;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\tconst search = getSearch(parsedURL);\n\n\t// Manually spread the URL object instead of spread syntax\n\tconst requestOptions = {\n\t\tpath: parsedURL.pathname + search,\n\t\tpathname: parsedURL.pathname,\n\t\thostname: parsedURL.hostname,\n\t\tprotocol: parsedURL.protocol,\n\t\tport: parsedURL.port,\n\t\thash: parsedURL.hash,\n\t\tsearch: parsedURL.search,\n\t\tquery: parsedURL.query,\n\t\thref: parsedURL.href,\n\t\tmethod: request.method,\n\t\theaders: headers[Symbol.for('nodejs.util.inspect.custom')](),\n\t\tinsecureHTTPParser: request.insecureHTTPParser,\n\t\tagent\n\t};\n\n\treturn requestOptions;\n};\n", "export const getSearch = parsedURL => {\n\tif (parsedURL.search) {\n\t\treturn parsedURL.search;\n\t}\n\n\tconst lastOffset = parsedURL.href.length - 1;\n\tconst hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');\n\treturn parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';\n};\n", "import {FetchBaseError} from './base.js';\n\n/**\n * AbortError interface for cancelled requests\n */\nexport class AbortError extends FetchBaseError {\n\tconstructor(message, type = 'aborted') {\n\t\tsuper(message, type);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
