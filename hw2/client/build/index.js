(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[Object.keys(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from) {
          for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
          return to;
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/util/node_modules/tslib/tslib.js
  var require_tslib2 = __commonJS({
    "node_modules/@antv/util/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/g-base/node_modules/tslib/tslib.js
  var require_tslib3 = __commonJS({
    "node_modules/@antv/g-base/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/adjust/node_modules/tslib/tslib.js
  var require_tslib4 = __commonJS({
    "node_modules/@antv/adjust/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (b.hasOwnProperty(p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding10 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar10 = function(m, exports2) {
          for (var p2 in m)
            if (p2 !== "default" && !exports2.hasOwnProperty(p2))
              exports2[p2] = m[p2];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (Object.hasOwnProperty.call(mod3, k))
                result[k] = mod3[k];
          }
          result["default"] = mod3;
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/attr/node_modules/tslib/tslib.js
  var require_tslib5 = __commonJS({
    "node_modules/@antv/attr/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (b.hasOwnProperty(p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding10 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar10 = function(m, exports2) {
          for (var p2 in m)
            if (p2 !== "default" && !exports2.hasOwnProperty(p2))
              exports2[p2] = m[p2];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (Object.hasOwnProperty.call(mod3, k))
                result[k] = mod3[k];
          }
          result["default"] = mod3;
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/coord/node_modules/tslib/tslib.js
  var require_tslib6 = __commonJS({
    "node_modules/@antv/coord/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/component/node_modules/tslib/tslib.js
  var require_tslib7 = __commonJS({
    "node_modules/@antv/component/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/g-canvas/node_modules/tslib/tslib.js
  var require_tslib8 = __commonJS({
    "node_modules/@antv/g-canvas/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/g-svg/node_modules/tslib/tslib.js
  var require_tslib9 = __commonJS({
    "node_modules/@antv/g-svg/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest10;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p2 in b)
            if (Object.prototype.hasOwnProperty.call(b, p2))
              d[p2] = b[p2];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p2 in s)
              if (Object.prototype.hasOwnProperty.call(s, p2))
                t[p2] = s[p2];
          }
          return t;
        };
        __rest10 = function(s, e) {
          var t = {};
          for (var p2 in s)
            if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
              t[p2] = s[p2];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
              if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
                t[p2[i]] = s[p2[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _6.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _6.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _6);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p2 in m)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o, p2))
              __createBinding10(o, m, p2);
        };
        __createBinding10 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p2;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p2 = !p2) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod3) {
          if (mod3 && mod3.__esModule)
            return mod3;
          var result = {};
          if (mod3 != null) {
            for (var k in mod3)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
                __createBinding10(result, mod3, k);
          }
          __setModuleDefault(result, mod3);
          return result;
        };
        __importDefault10 = function(mod3) {
          return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest10);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str4, expectsLowerCase) {
    const map5 = Object.create(null);
    const list = str4.split(",");
    for (let i = 0; i < list.length; i++) {
      map5[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map5[val.toLowerCase()] : (val) => !!map5[val];
  }
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value)) {
      return value;
    } else if (isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var NOOP = () => {
  };
  var NO = () => false;
  var onRE = /^on[^a-z]/;
  var isOn = (key) => onRE.test(key);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isFunction = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  var cacheStringFunction = (fn) => {
    const cache3 = Object.create(null);
    return (str4) => {
      const hit = cache3[str4];
      return hit || (cache3[str4] = fn(str4));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str4) => {
    return str4.replace(camelizeRE, (_6, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str4) => str4.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str4) => str4.charAt(0).toUpperCase() + str4.slice(1));
  var toHandlerKey = cacheStringFunction((str4) => str4 ? `on${capitalize(str4)}` : ``);
  var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  var invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  var def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  var toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };

  // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  var activeEffectScope;
  var effectScopeStack = [];
  var EffectScope = class {
    constructor(detached = false) {
      this.active = true;
      this.effects = [];
      this.cleanups = [];
      if (!detached && activeEffectScope) {
        this.parent = activeEffectScope;
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
      }
    }
    run(fn) {
      if (this.active) {
        try {
          this.on();
          return fn();
        } finally {
          this.off();
        }
      } else if (true) {
        warn(`cannot run an inactive effect scope.`);
      }
    }
    on() {
      if (this.active) {
        effectScopeStack.push(this);
        activeEffectScope = this;
      }
    }
    off() {
      if (this.active) {
        effectScopeStack.pop();
        activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
      }
    }
    stop(fromParent) {
      if (this.active) {
        this.effects.forEach((e) => e.stop());
        this.cleanups.forEach((cleanup) => cleanup());
        if (this.scopes) {
          this.scopes.forEach((e) => e.stop(true));
        }
        if (this.parent && !fromParent) {
          const last2 = this.parent.scopes.pop();
          if (last2 && last2 !== this) {
            this.parent.scopes[this.index] = last2;
            last2.index = this.index;
          }
        }
        this.active = false;
      }
    }
  };
  function recordEffectScope(effect2, scope) {
    scope = scope || activeEffectScope;
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  var createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
  };
  var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
  var newTracked = (dep) => (dep.n & trackOpBit) > 0;
  var initDepMarkers = ({ deps }) => {
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].w |= trackOpBit;
      }
    }
  };
  var finalizeDepMarkers = (effect2) => {
    const { deps } = effect2;
    if (deps.length) {
      let ptr = 0;
      for (let i = 0; i < deps.length; i++) {
        const dep = deps[i];
        if (wasTracked(dep) && !newTracked(dep)) {
          dep.delete(effect2);
        } else {
          deps[ptr++] = dep;
        }
        dep.w &= ~trackOpBit;
        dep.n &= ~trackOpBit;
      }
      deps.length = ptr;
    }
  };
  var targetMap = new WeakMap();
  var effectTrackDepth = 0;
  var trackOpBit = 1;
  var maxMarkerBits = 30;
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  var ReactiveEffect = class {
    constructor(fn, scheduler = null, scope) {
      this.fn = fn;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      recordEffectScope(this, scope);
    }
    run() {
      if (!this.active) {
        return this.fn();
      }
      if (!effectStack.includes(this)) {
        try {
          effectStack.push(activeEffect = this);
          enableTracking();
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          resetTracking();
          effectStack.pop();
          const n = effectStack.length;
          activeEffect = n > 0 ? effectStack[n - 1] : void 0;
        }
      }
    }
    stop() {
      if (this.active) {
        cleanupEffect(this);
        if (this.onStop) {
          this.onStop();
        }
        this.active = false;
      }
    }
  };
  function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect2);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function track(target, type, key) {
    if (!isTracking()) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = true ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
  function isTracking() {
    return shouldTrack && activeEffect !== void 0;
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
      if (!newTracked(dep)) {
        dep.n |= trackOpBit;
        shouldTrack2 = !wasTracked(dep);
      }
    } else {
      shouldTrack2 = !dep.has(activeEffect);
    }
    if (shouldTrack2) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.onTrack) {
        activeEffect.onTrack(Object.assign({
          effect: activeEffect
        }, debuggerEventExtraInfo));
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const eventInfo = true ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
    if (deps.length === 1) {
      if (deps[0]) {
        if (true) {
          triggerEffects(deps[0], eventInfo);
        } else {
          triggerEffects(deps[0]);
        }
      }
    } else {
      const effects = [];
      for (const dep of deps) {
        if (dep) {
          effects.push(...dep);
        }
      }
      if (true) {
        triggerEffects(createDep(effects), eventInfo);
      } else {
        triggerEffects(createDep(effects));
      }
    }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
    for (const effect2 of isArray(dep) ? dep : [...dep]) {
      if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (effect2.onTrigger) {
          effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get = /* @__PURE__ */ createGetter();
  var shallowGet = /* @__PURE__ */ createGetter(false, true);
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get2(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    };
  }
  var set = /* @__PURE__ */ createSetter();
  var shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set5(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (true) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (true) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  var shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
  });
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly2 = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly2 && track(rawTarget, "get", key);
    }
    !isReadonly2 && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly2 && track(rawTarget, "has", key);
    }
    !isReadonly2 && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow) {
    return function forEach3(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = new WeakMap();
  var shallowReactiveMap = new WeakMap();
  var readonlyMap = new WeakMap();
  var shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (target && target["__v_isReadonly"]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    def(value, "__v_skip", true);
    return value;
  }
  var toReactive = (value) => isObject(value) ? reactive(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function trackRefValue(ref2) {
    if (isTracking()) {
      ref2 = toRaw(ref2);
      if (!ref2.dep) {
        ref2.dep = createDep();
      }
      if (true) {
        trackEffects(ref2.dep, {
          target: ref2,
          type: "get",
          key: "value"
        });
      } else {
        trackEffects(ref2.dep);
      }
    }
  }
  function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    if (ref2.dep) {
      if (true) {
        triggerEffects(ref2.dep, {
          target: ref2,
          type: "set",
          key: "value",
          newValue: newVal
        });
      } else {
        triggerEffects(ref2.dep);
      }
    }
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  var RefImpl = class {
    constructor(value, _shallow) {
      this._shallow = _shallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = _shallow ? value : toRaw(value);
      this._value = _shallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      newVal = this._shallow ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = this._shallow ? newVal : toReactive(newVal);
        triggerRefValue(this, newVal);
      }
    }
  };
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  var shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  var ComputedRefImpl = class {
    constructor(getter, _setter, isReadonly2) {
      this._setter = _setter;
      this.dep = void 0;
      this._dirty = true;
      this.__v_isRef = true;
      this.effect = new ReactiveEffect(getter, () => {
        if (!this._dirty) {
          this._dirty = true;
          triggerRefValue(this);
        }
      });
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      trackRefValue(self2);
      if (self2._dirty) {
        self2._dirty = false;
        self2._value = self2.effect.run();
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
  };
  function computed(getterOrOptions, debugOptions) {
    let getter;
    let setter;
    const onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = true ? () => {
        console.warn("Write operation failed: computed value is readonly");
      } : NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);
    if (debugOptions) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  var _a;
  var tick = Promise.resolve();
  _a = "__v_isReadonly";

  // node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  var isHmrUpdating = false;
  var hmrDirtyComponents = new Set();
  if (true) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id);
      record = map.get(id);
    }
    record.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).delete(instance);
  }
  function createRecord(id) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, new Set());
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    [...record].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    const instances = [...record];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        extend(oldComp, newComp);
        for (const key in oldComp) {
          if (key !== "__file" && !(key in newComp)) {
            delete oldComp[key];
          }
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        queueJob(instance.parent.update);
        if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
          instance.parent.ceReload(newComp.styles);
        }
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
      }
    });
  }
  function tryWrap(fn) {
    return (id, arg) => {
      try {
        return fn(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
      }
    };
  }
  var devtools;
  var buffer = [];
  function emit(event, ...args) {
    if (devtools) {
      devtools.emit(event, ...args);
    } else {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook(hook, target) {
    devtools = hook;
    if (devtools) {
      devtools.enabled = true;
      buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
      buffer = [];
    } else {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook(newHook, target);
      });
    }
  }
  function devtoolsInitApp(app, version4) {
    emit("app:init", app, version4, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit("app:unmount", app);
  }
  var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
  var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
  var devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
  }
  var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
  var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
  function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
      emit(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit("component:emit", component.appContext.app, component, event, params);
  }
  function emit$1(instance, event, ...rawArgs) {
    const props = instance.vnode.props || EMPTY_OBJ;
    if (true) {
      const { emitsOptions, propsOptions: [propsOptions] } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
            warn2(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn2(`Invalid event arguments: event validation failed for event "${event}".`);
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a) => a.trim());
      } else if (number) {
        args = rawArgs.map(toNumber);
      }
    }
    if (true) {
      devtoolsComponentEmit(instance, event, args);
    }
    if (true) {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn2(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(handler, instance, 6, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache3 = appContext.emitsCache;
    const cached = cache3.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      cache3.set(comp, null);
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    cache3.set(comp, normalized);
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx3 = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx3)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx3);
      const res = fn(...args);
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
      if (true) {
        devtoolsComponentUpdated(ctx3);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  var accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const { type: Component2, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx: ctx3, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if (true) {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx3));
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component2;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(render2.length > 1 ? render2(props, true ? {
          get attrs() {
            markAttrsAccessed();
            return attrs;
          },
          slots,
          emit: emit2
        } : { attrs, slots, emit: emit2 }) : render2(props, null));
        fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }
          root = cloneVNode(root, fallthroughAttrs);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn2(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
          }
          if (eventAttrs.length) {
            warn2(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn2(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
      }
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn2(`Component inside <Transition> renders non-element root node that cannot be animated.`);
      }
      root.transition = vnode.transition;
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  var getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
      return [vnode, void 0];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  var getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  var filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  var isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent && parent.subTree === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    }
  }
  var isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  function provide(key, value) {
    if (!currentInstance) {
      if (true) {
        warn2(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
      const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
      } else if (true) {
        warn2(`injection "${String(key)}" not found.`);
      }
    } else if (true) {
      warn2(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  var TransitionHookValidator = [Function, Array];
  var BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevTransitionKey;
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        if (children.length > 1) {
          warn2("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (mode && !["in-out", "out-in", "default"].includes(mode)) {
          warn2(`invalid <transition> mode: ${mode}`);
        }
        const child = children[0];
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        let transitionKeyChanged = false;
        const { getTransitionKey } = innerChild.type;
        if (getTransitionKey) {
          const key = getTransitionKey();
          if (prevTransitionKey === void 0) {
            prevTransitionKey = key;
          } else if (key !== prevTransitionKey) {
            prevTransitionKey = key;
            transitionKeyChanged = true;
          }
        }
        if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
          const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              instance.update();
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el._leaveCb = () => {
                earlyRemove();
                el._leaveCb = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  var BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el._leaveCb) {
          el._leaveCb(true);
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
          leavingVNode.el._leaveCb();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el._enterCb = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el._enterCb = void 0;
        };
        if (hook) {
          hook(el, done);
          if (hook.length <= 1) {
            done();
          }
        } else {
          done();
        }
      },
      leave(el, remove3) {
        const key2 = String(vnode.key);
        if (el._enterCb) {
          el._enterCb(true);
        }
        if (state.isUnmounting) {
          return remove3();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el._leaveCb = (cancelled) => {
          if (called)
            return;
          called = true;
          remove3();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el._leaveCb = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          onLeave(el, done);
          if (onLeave.length <= 1) {
            done();
          }
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
      } else if (keepComment || child.type !== Comment) {
        ret.push(child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options) {
    return isFunction(options) ? { setup: options, name: options.name } : options;
  }
  var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (true) {
      const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
      warn2(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
  }
  var createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
  var onBeforeMount = createHook("bm");
  var onMounted = createHook("m");
  var onBeforeUpdate = createHook("bu");
  var onUpdated = createHook("u");
  var onBeforeUnmount = createHook("bum");
  var onUnmounted = createHook("um");
  var onServerPrefetch = createHook("sp");
  var onRenderTriggered = createHook("rtg");
  var onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  function createDuplicateChecker() {
    const cache3 = Object.create(null);
    return (type, key) => {
      if (cache3[key]) {
        warn2(`${type} property "${key}" is already defined in ${cache3[key]}.`);
      } else {
        cache3[key] = type;
      }
    };
  }
  var shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx3 = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = true ? createDuplicateChecker() : null;
    if (true) {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx3, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          if (true) {
            Object.defineProperty(ctx3, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx3[key] = methodHandler.bind(publicThis);
          }
          if (true) {
            checkDuplicateProperties("Methods", key);
          }
        } else if (true) {
          warn2(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn2(`The data option must be a function. Plain object usage is no longer supported.`);
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn2(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
      }
      if (!isObject(data)) {
        warn2(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        if (true) {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (key[0] !== "$" && key[0] !== "_") {
              Object.defineProperty(ctx3, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get2 === NOOP) {
          warn2(`Computed property "${key}" has no getter.`);
        }
        const set5 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : true ? () => {
          warn2(`Write operation failed: computed property "${key}" is readonly.`);
        } : NOOP;
        const c = computed({
          get: get2,
          set: set5
        });
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        if (true) {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx3, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register3, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register3(_hook.bind(publicThis)));
      } else if (hook) {
        register3(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx3, checkDuplicateProperties = NOOP, unwrapRef = false) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(opt.from || key, opt.default, true);
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        if (unwrapRef) {
          Object.defineProperty(ctx3, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          if (true) {
            warn2(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
          }
          ctx3[key] = injected;
        }
      } else {
        ctx3[key] = injected;
      }
      if (true) {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx3, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx3[raw];
      if (isFunction(handler)) {
        watch(getter, handler);
      } else if (true) {
        warn2(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx3, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx3[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else if (true) {
          warn2(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else if (true) {
      warn2(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache3, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache3.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache3.set(base, resolved);
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn2(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(extend(Object.create(null), to), from) : from;
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend(Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key)) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(null, props);
            unsetCurrentInstance();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache3 = appContext.propsCache;
    const cached = cache3.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2)
          needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      cache3.set(comp, EMPTY_ARR);
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn2(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn2(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : opt;
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    cache3.set(comp, res);
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$") {
      return true;
    } else if (true) {
      warn2(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? "null" : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type));
    } else if (isFunction(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
      let opt = options[key];
      if (opt == null)
        continue;
      validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
    }
  }
  function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    if (required && isAbsent) {
      warn2('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    if (type != null && type !== true) {
      let isValid = false;
      const types = isArray(type) ? type : [type];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid; i++) {
        const { valid, expectedType } = assertType(value, types[i]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn2(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value)) {
      warn2('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  var isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
  function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else if (expectedType === "null") {
      valid = value === null;
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return `"${value}"`;
    } else if (type === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  var isInternalKey = (key) => key[0] === "_" || key === "$stable";
  var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  var normalizeSlot = (key, rawSlot, ctx3) => {
    const normalized = withCtx((...args) => {
      if (currentInstance) {
        warn2(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx3);
    normalized._c = false;
    return normalized;
  };
  var normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx3 = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx3);
      } else if (value != null) {
        if (true) {
          warn2(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  var normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn2(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  var initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        instance.slots = toRaw(children);
        def(children, "_", type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  var updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (isHmrUpdating) {
          extend(slots, children);
        } else if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          extend(slots, children);
          if (!optimized && type === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
          delete slots[key];
        }
      }
    }
  };
  var isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text");
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn2("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap()
    };
  }
  var uid = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (rootProps != null && !isObject(rootProps)) {
        warn2(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = new Set();
      let isMounted = false;
      const app = context.app = {
        _uid: uid++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          if (true) {
            warn2(`app.config cannot be replaced. Modify individual options instead.`);
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn2(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else if (true) {
            warn2(`A plugin must either be a function or an object with an "install" function.`);
          }
          return app;
        },
        mixin(mixin) {
          if (__VUE_OPTIONS_API__) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (true) {
              warn2("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
            }
          } else if (true) {
            warn2("Mixins are only available in builds supporting Options API");
          }
          return app;
        },
        component(name, component) {
          if (true) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn2(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (true) {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn2(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, isSVG) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (true) {
              context.reload = () => {
                render(cloneVNode(vnode), rootContainer, isSVG);
              };
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render(vnode, rootContainer, isSVG);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (true) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          } else if (true) {
            warn2(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
          }
        },
        unmount() {
          if (isMounted) {
            render(null, app._container);
            if (true) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (true) {
            warn2(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn2(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
          }
          context.provides[key] = value;
          return app;
        }
      };
      return app;
    };
  }
  var supported;
  var perf;
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
      devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (true) {
      devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
      needWarn.push(`__VUE_OPTIONS_API__`);
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
      needWarn.push(`__VUE_PROD_DEVTOOLS__`);
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see http://link.vuejs.org/feature-flags.`);
    }
  }
  var queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (true) {
      setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref2, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, isSVG);
          } else if (true) {
            patchStaticNode(n1, n2, container, isSVG);
          }
          break;
        case Fragment:
          processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (true) {
            warn2("Invalid VNode type:", type, `(${typeof type})`);
          }
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    const patchStaticNode = (n1, n2, container, isSVG) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      isSVG = isSVG || n2.type === "svg";
      if (n1 == null) {
        mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
      if (false) {
        el = vnode.el = hostCloneNode(vnode.el);
      } else {
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      }
      if (true) {
        Object.defineProperty(el, "__vnode", {
          value: vnode,
          enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      const areChildrenSVG = isSVG && n2.type !== "foreignObject";
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        if (parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, isSVG);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
      if (oldProps !== newProps) {
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
          if (parentComponent && parentComponent.type.__hmrId) {
            traverseStaticChildren(n1, n2);
          } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(n1, n2, true);
          }
        } else {
          patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
          mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
      const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (true) {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (true) {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if (true) {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
        return;
      }
      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
      if (true) {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (true) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (true) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.update();
        }
      } else {
        n2.component = n1.component;
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          effect2.allowRecurse = false;
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          effect2.allowRecurse = true;
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (true) {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              if (true) {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
            } else {
              hydrateSubTree();
            }
          } else {
            if (true) {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
            if (true) {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
          }
          if (initialVNode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (true) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          let originNext = next;
          let vnodeHook;
          if (true) {
            pushWarningContext(next || instance.vnode);
          }
          effect2.allowRecurse = false;
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          effect2.allowRecurse = true;
          if (true) {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
          if (true) {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
          }
          if (true) {
            devtoolsComponentUpdated(instance);
          }
          if (true) {
            popWarningContext();
          }
        }
      };
      const effect2 = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
      const update3 = instance.update = effect2.run.bind(effect2);
      update3.id = instance.uid;
      effect2.allowRecurse = update3.allowRecurse = true;
      if (true) {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        update3.ownerInstance = instance;
      }
      update3();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(void 0, instance.update);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e22 = l2 - 1;
      while (i <= e1 && i <= e22) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e22) {
        const n1 = c1[e1];
        const n2 = c2[e22] = optimized ? cloneIfMounted(c2[e22]) : normalizeVNode(c2[e22]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e22--;
      }
      if (i > e1) {
        if (i <= e22) {
          const nextPos = e22 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e22) {
            patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            i++;
          }
        }
      } else if (i > e22) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = new Map();
        for (i = s2; i <= e22; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn2(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e22 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e22; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove4 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove4();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove4, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove3(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove3 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        removeFragment(el, anchor);
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update: update3, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update3) {
        update3.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (true) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, isSVG);
      }
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove3,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
      render,
      hydrate,
      createApp: createAppAPI(render, hydrate)
    };
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    if (!owner) {
      warn2(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref2) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isString(ref2)) {
      const doSet = () => {
        {
          refs[ref2] = value;
        }
        if (hasOwn(setupState, ref2)) {
          setupState[ref2] = value;
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (isRef(ref2)) {
      const doSet = () => {
        ref2.value = value;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (isFunction(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else if (true) {
      warn2("Invalid template ref type:", value, `(${typeof value})`);
    }
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len3 = arr.length;
    for (i = 0; i < len3; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  var isTeleport = (type) => type.__isTeleport;
  var NULL_DYNAMIC_COMPONENT = Symbol();
  var Fragment = Symbol(true ? "Fragment" : void 0);
  var Text = Symbol(true ? "Text" : void 0);
  var Comment = Symbol(true ? "Comment" : void 0);
  var Static = Symbol(true ? "Static" : void 0);
  var blockStack = [];
  var currentBlock = null;
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
      return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  var vnodeArgsTransformer;
  var createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
  };
  var InternalObjectKey = `__vInternal`;
  var normalizeKey = ({ key }) => key != null ? key : null;
  var normalizeRef = ({ ref: ref2 }) => {
    return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2 } : ref2 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn2(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = true ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!type) {
        warn2(`Invalid vnode type when creating vnode: ${type}.`);
      }
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(type, props, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn2(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref2, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor
    };
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(Fragment, null, child.slice());
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (existing !== incoming) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  var getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = extend(Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => true ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => () => queueJob(i.update),
    $nextTick: (i) => nextTick.bind(i.proxy),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
  });
  var PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      const { ctx: ctx3, setupState, data, props, accessCache, type, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn(setupState, key)) {
        return setupState[key];
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 0:
              return setupState[key];
            case 1:
              return data[key];
            case 3:
              return ctx3[key];
            case 2:
              return props[key];
          }
        } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
          accessCache[key] = 0;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 1;
          return data[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
          accessCache[key] = 2;
          return props[key];
        } else if (ctx3 !== EMPTY_OBJ && hasOwn(ctx3, key)) {
          accessCache[key] = 3;
          return ctx3[key];
        } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
          accessCache[key] = 4;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance, "get", key);
          markAttrsAccessed();
        }
        return publicGetter(instance);
      } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx3 !== EMPTY_OBJ && hasOwn(ctx3, key)) {
        accessCache[key] = 3;
        return ctx3[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && (key[0] === "$" || key[0] === "_") && hasOwn(data, key)) {
          warn2(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
        } else if (instance === currentRenderingInstance) {
          warn2(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx: ctx3 } = instance;
      if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        setupState[key] = value;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
      } else if (hasOwn(instance.props, key)) {
        warn2(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn2(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx3, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx3[key] = value;
        }
      }
      return true;
    },
    has({ _: { data, setupState, accessCache, ctx: ctx3, appContext, propsOptions } }, key) {
      let normalizedProps;
      return accessCache[key] !== void 0 || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx3, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    }
  };
  if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn2(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const { ctx: ctx3, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx: ctx3, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (key[0] === "$" || key[0] === "_") {
          warn2(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
          return;
        }
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  var emptyAppContext = createAppContext();
  var uid$1 = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid$1++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      update: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (true) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  var currentInstance = null;
  var getCurrentInstance = () => currentInstance || currentRenderingInstance;
  var setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
  };
  var unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
  };
  var isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
      warn2("Do not use built-in or reserved HTML elements as component id: " + name);
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component2 = instance.type;
    if (true) {
      if (Component2.name) {
        validateComponentName(Component2.name, instance.appContext.config);
      }
      if (Component2.components) {
        const names = Object.keys(Component2.components);
        for (let i = 0; i < names.length; i++) {
          validateComponentName(names[i], instance.appContext.config);
        }
      }
      if (Component2.directives) {
        const names = Object.keys(Component2.directives);
        for (let i = 0; i < names.length; i++) {
          validateDirectiveName(names[i]);
        }
      }
      if (Component2.compilerOptions && isRuntimeOnly()) {
        warn2(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
      }
    }
    instance.accessCache = Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if (true) {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component2;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(setup, instance, 0, [true ? shallowReadonly(instance.props) : instance.props, setupContext]);
      resetTracking();
      unsetCurrentInstance();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn2(`setup() should not return VNodes directly - return a render function instead.`);
      }
      if (true) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (true) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn2(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
  }
  var compile;
  var installWithProxy;
  var isRuntimeOnly = () => !compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component2 = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component2.render) {
        const template = Component2.template;
        if (template) {
          if (true) {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
          const finalCompilerOptions = extend(extend({
            isCustomElement,
            delimiters
          }, compilerOptions), componentCompilerOptions);
          Component2.render = compile(template, finalCompilerOptions);
          if (true) {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component2.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (__VUE_OPTIONS_API__ && true) {
      setCurrentInstance(instance);
      pauseTracking();
      applyOptions(instance);
      resetTracking();
      unsetCurrentInstance();
    }
    if (!Component2.render && instance.render === NOOP && !isSSR) {
      if (!compile && Component2.template) {
        warn2(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
      } else {
        warn2(`Component is missing template or render function.`);
      }
    }
  }
  function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, true ? {
      get(target, key) {
        markAttrsAccessed();
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn2(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn2(`setupContext.attrs is readonly.`);
        return false;
      }
    } : {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (instance.exposed) {
        warn2(`expose() should be called only once per setup().`);
      }
      instance.exposed = exposed || {};
    };
    let attrs;
    if (true) {
      return Object.freeze({
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        get slots() {
          return shallowReadonly(instance.slots);
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    } else {
      return {
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        }
      }));
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = (str4) => str4.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component2) {
    return isFunction(Component2) ? Component2.displayName || Component2.name : Component2.name;
  }
  function formatComponentName(instance, Component2, isRoot = false) {
    let name = getComponentName(Component2);
    if (!name && Component2.__file) {
      const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component2) {
            return key;
          }
        }
      };
      name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn2(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
      ]);
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  var ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next"
  };
  function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    const values2 = [];
    for (let i = 0; i < fn.length; i++) {
      values2.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values2;
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = true ? ErrorTypeStrings[type] : type;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    if (true) {
      const info = ErrorTypeStrings[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn2(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }
  var isFlushing = false;
  var isFlushPending = false;
  var queue = [];
  var flushIndex = 0;
  var pendingPreFlushCbs = [];
  var activePreFlushCbs = null;
  var preFlushIndex = 0;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = Promise.resolve();
  var currentFlushPromise = null;
  var currentPreFlushParentJob = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJobId = getId(queue[middle]);
      middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
  }
  function queueJob(job) {
    if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!isArray(cb)) {
      if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
        pendingQueue.push(cb);
      }
    } else {
      pendingQueue.push(...cb);
    }
    queueFlush();
  }
  function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
  }
  function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
  }
  function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
      currentPreFlushParentJob = parentJob;
      activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
      pendingPreFlushCbs.length = 0;
      if (true) {
        seen = seen || new Map();
      }
      for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
        if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
          continue;
        }
        activePreFlushCbs[preFlushIndex]();
      }
      activePreFlushCbs = null;
      preFlushIndex = 0;
      currentPreFlushParentJob = null;
      flushPreFlushCbs(seen, parentJob);
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (true) {
        seen = seen || new Map();
      }
      activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
          continue;
        }
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = (job) => job.id == null ? Infinity : job.id;
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if (true) {
      seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    queue.sort((a, b) => getId(a) - getId(b));
    const check = true ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (check(job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
      seen.set(fn, 1);
    } else {
      const count = seen.get(fn);
      if (count > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        warn2(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
        return true;
      } else {
        seen.set(fn, count + 1);
      }
    }
  }
  var INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn2(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    if (!cb) {
      if (immediate !== void 0) {
        warn2(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
      }
      if (deep !== void 0) {
        warn2(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
      }
    }
    const warnInvalidSource = (s) => {
      warn2(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = !!source._shallow;
    } else if (isReactive(source)) {
      getter = () => source;
      deep = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some(isReactive);
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse(s);
        } else if (isFunction(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(source, instance, 3, [onInvalidate]);
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onInvalidate = (fn) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
      };
    };
    if (isInSSRComponentSetup) {
      onInvalidate = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onInvalidate
        ]);
      }
      return NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
            onInvalidate
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      scheduler = () => {
        if (!instance || instance.isMounted) {
          queuePreFlushCb(job);
        } else {
          job();
        }
      };
    }
    const effect2 = new ReactiveEffect(getter, scheduler);
    if (true) {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
    } else {
      effect2.run();
    }
    return () => {
      effect2.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect2);
      }
    };
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx3, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx3;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, seen) {
    if (!isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse(value.value, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, seen);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], seen);
      }
    }
    return value;
  }
  true ? Object.freeze({}) : {};
  true ? Object.freeze([]) : [];
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  var ssrContextKey = Symbol(true ? `ssrContext` : ``);
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#0b1bc9" };
    const stringStyle = { style: "color:#b62e24" };
    const keywordStyle = { style: "color:#9d288c" };
    const formatter = {
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      const opts = Comp[type];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (v._shallow) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  var version = "3.2.19";

  // node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var svgNS = "http://www.w3.org/2000/svg";
  var doc = typeof document !== "undefined" ? document : null;
  var staticTemplateCache = new Map();
  var nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props) => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    cloneNode(el) {
      const cloned = el.cloneNode(true);
      if (`_value` in el) {
        cloned._value = el._value;
      }
      return cloned;
    },
    insertStaticContent(content, parent, anchor, isSVG) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      let template = staticTemplateCache.get(content);
      if (!template) {
        const t = doc.createElement("template");
        t.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
        template = t.content;
        if (isSVG) {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        staticTemplateCache.set(content, template);
      }
      parent.insertBefore(template.cloneNode(true), anchor);
      return [
        before ? before.nextSibling : parent.firstChild,
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  function patchStyle(el, prev, next) {
    const style = el.style;
    const currentDisplay = style.display;
    if (!next) {
      el.removeAttribute("style");
    } else if (isString(next)) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else {
      for (const key in next) {
        setStyle(style, key, next[key]);
      }
      if (prev && !isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
  var importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  var prefixes = ["Webkit", "Moz", "ms"];
  var prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  var xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean3 = isSpecialBooleanAttr(key);
      if (value == null || isBoolean3 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean3 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    if (key === "value" && el.tagName !== "PROGRESS") {
      el._value = value;
      const newValue = value == null ? "" : value;
      if (el.value !== newValue) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      return;
    }
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        el[key] = includeBooleanAttr(value);
        return;
      } else if (value == null && type === "string") {
        el[key] = "";
        el.removeAttribute(key);
        return;
      } else if (type === "number") {
        try {
          el[key] = 0;
        } catch (_a4) {
        }
        el.removeAttribute(key);
        return;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (true) {
        warn2(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
      }
    }
  }
  var _getNow = Date.now;
  var skipTimestampCheck = false;
  if (typeof window !== "undefined") {
    if (_getNow() > document.createEvent("Event").timeStamp) {
      _getNow = () => performance.now();
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  var cachedNow = 0;
  var p = Promise.resolve();
  var reset = () => {
    cachedNow = 0;
  };
  var getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  var optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    return [hyphenate(name.slice(2)), options];
  }
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      const timeStamp = e.timeStamp || _getNow();
      if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
        callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
      }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map((fn) => (e3) => !e3._stopped && fn(e3));
    } else {
      return value;
    }
  }
  var nativeOnRE = /^on[a-z]/;
  var patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && nativeOnRE.test(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (nativeOnRE.test(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  var DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  var TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
  var callHook2 = (hook, args = []) => {
    if (isArray(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  var hasExplicitCallback = (hook) => {
    return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        const resolve = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve);
          }
        });
        callHook2(onLeave, [el, resolve]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (true)
      validateDuration(res);
    return res;
  }
  function validateDuration(val) {
    if (typeof val !== "number") {
      warn2(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn2(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
    }
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el._vtc || (el._vtc = new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el._vtc = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  var endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout2 + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(TRANSITION + "Delay");
    const transitionDurations = getStyleProperties(TRANSITION + "Duration");
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + "Delay");
    const animationDurations = getStyleProperties(ANIMATION + "Duration");
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout2 = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout2 = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout2 = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout2 = Math.max(transitionTimeout, animationTimeout);
      type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
    return {
      type,
      timeout: timeout2,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  var positionMap = new WeakMap();
  var newPositionMap = new WeakMap();
  var rendererOptions = extend({ patchProp }, nodeOps);
  var renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  var createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    if (true) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn2(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn2(msg);
          return compilerOptions;
        },
        set() {
          warn2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn2(`Failed to mount app: mount target selector "${container}" returned null.`);
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn2(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
  }

  // node_modules/vue/dist/vue.runtime.esm-bundler.js
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  if (true) {
    initDev();
  }

  // node_modules/tslib/modules/index.js
  var import_tslib = __toModule(require_tslib());
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // node_modules/@antv/util/esm/is-array-like.js
  var isArrayLike = function(value) {
    return value !== null && typeof value !== "function" && isFinite(value.length);
  };
  var is_array_like_default = isArrayLike;

  // node_modules/@antv/util/esm/contains.js
  var contains = function(arr, value) {
    if (!is_array_like_default(arr)) {
      return false;
    }
    return arr.indexOf(value) > -1;
  };
  var contains_default = contains;

  // node_modules/@antv/util/esm/filter.js
  var filter = function(arr, func) {
    if (!is_array_like_default(arr)) {
      return arr;
    }
    var result = [];
    for (var index = 0; index < arr.length; index++) {
      var value = arr[index];
      if (func(value, index)) {
        result.push(value);
      }
    }
    return result;
  };
  var filter_default = filter;

  // node_modules/@antv/util/esm/difference.js
  var difference = function(arr, values2) {
    if (values2 === void 0) {
      values2 = [];
    }
    return filter_default(arr, function(value) {
      return !contains_default(values2, value);
    });
  };
  var difference_default = difference;

  // node_modules/@antv/util/esm/is-type.js
  var toString = {}.toString;
  var isType = function(value, type) {
    return toString.call(value) === "[object " + type + "]";
  };
  var is_type_default = isType;

  // node_modules/@antv/util/esm/is-function.js
  var is_function_default = function(value) {
    return is_type_default(value, "Function");
  };

  // node_modules/@antv/util/esm/is-nil.js
  var isNil = function(value) {
    return value === null || value === void 0;
  };
  var is_nil_default = isNil;

  // node_modules/@antv/util/esm/is-array.js
  var is_array_default = function(value) {
    return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
  };

  // node_modules/@antv/util/esm/is-object.js
  var is_object_default = function(value) {
    var type = typeof value;
    return value !== null && type === "object" || type === "function";
  };

  // node_modules/@antv/util/esm/each.js
  function each(elements, func) {
    if (!elements) {
      return;
    }
    var rst;
    if (is_array_default(elements)) {
      for (var i = 0, len3 = elements.length; i < len3; i++) {
        rst = func(elements[i], i);
        if (rst === false) {
          break;
        }
      }
    } else if (is_object_default(elements)) {
      for (var k in elements) {
        if (elements.hasOwnProperty(k)) {
          rst = func(elements[k], k);
          if (rst === false) {
            break;
          }
        }
      }
    }
  }
  var each_default = each;

  // node_modules/@antv/util/esm/keys.js
  var keys = Object.keys ? function(obj) {
    return Object.keys(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value, key) {
      if (!(is_function_default(obj) && key === "prototype")) {
        result.push(key);
      }
    });
    return result;
  };
  var keys_default = keys;

  // node_modules/@antv/util/esm/is-match.js
  function isMatch(obj, attrs) {
    var _keys = keys_default(attrs);
    var length3 = _keys.length;
    if (is_nil_default(obj))
      return !length3;
    for (var i = 0; i < length3; i += 1) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) {
        return false;
      }
    }
    return true;
  }
  var is_match_default = isMatch;

  // node_modules/@antv/util/esm/is-object-like.js
  var isObjectLike = function(value) {
    return typeof value === "object" && value !== null;
  };
  var is_object_like_default = isObjectLike;

  // node_modules/@antv/util/esm/is-plain-object.js
  var isPlainObject2 = function(value) {
    if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
      return false;
    }
    if (Object.getPrototypeOf(value) === null) {
      return true;
    }
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  };
  var is_plain_object_default = isPlainObject2;

  // node_modules/@antv/util/esm/find.js
  function find(arr, predicate) {
    if (!is_array_default(arr))
      return null;
    var _predicate;
    if (is_function_default(predicate)) {
      _predicate = predicate;
    }
    if (is_plain_object_default(predicate)) {
      _predicate = function(a) {
        return is_match_default(a, predicate);
      };
    }
    if (_predicate) {
      for (var i = 0; i < arr.length; i += 1) {
        if (_predicate(arr[i])) {
          return arr[i];
        }
      }
    }
    return null;
  }
  var find_default = find;

  // node_modules/@antv/util/esm/first-value.js
  var firstValue = function(data, name) {
    var rst = null;
    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var value = obj[name];
      if (!is_nil_default(value)) {
        if (is_array_default(value)) {
          rst = value[0];
        } else {
          rst = value;
        }
        break;
      }
    }
    return rst;
  };
  var first_value_default = firstValue;

  // node_modules/@antv/util/esm/flatten.js
  var flatten = function(arr) {
    if (!is_array_default(arr)) {
      return [];
    }
    var rst = [];
    for (var i = 0; i < arr.length; i++) {
      rst = rst.concat(arr[i]);
    }
    return rst;
  };
  var flatten_default = flatten;

  // node_modules/@antv/util/esm/max.js
  var max_default = function(arr) {
    if (!is_array_default(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.max(prev, curr);
    }, arr[0]);
  };

  // node_modules/@antv/util/esm/min.js
  var min_default = function(arr) {
    if (!is_array_default(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.min(prev, curr);
    }, arr[0]);
  };

  // node_modules/@antv/util/esm/get-range.js
  var getRange = function(values2) {
    var filterValues = values2.filter(function(v) {
      return !isNaN(v);
    });
    if (!filterValues.length) {
      return {
        min: 0,
        max: 0
      };
    }
    if (is_array_default(values2[0])) {
      var tmp = [];
      for (var i = 0; i < values2.length; i++) {
        tmp = tmp.concat(values2[i]);
      }
      filterValues = tmp;
    }
    var max3 = max_default(filterValues);
    var min3 = min_default(filterValues);
    return {
      min: min3,
      max: max3
    };
  };
  var get_range_default = getRange;

  // node_modules/@antv/util/esm/pull.js
  var arrPrototype = Array.prototype;
  var splice = arrPrototype.splice;
  var indexOf = arrPrototype.indexOf;

  // node_modules/@antv/util/esm/pull-at.js
  var splice2 = Array.prototype.splice;
  var pullAt = function pullAt2(arr, indexes) {
    if (!is_array_like_default(arr)) {
      return [];
    }
    var length3 = arr ? indexes.length : 0;
    var last2 = length3 - 1;
    while (length3--) {
      var previous = void 0;
      var index = indexes[length3];
      if (length3 === last2 || index !== previous) {
        previous = index;
        splice2.call(arr, index, 1);
      }
    }
    return arr;
  };
  var pull_at_default = pullAt;

  // node_modules/@antv/util/esm/reduce.js
  var reduce = function(arr, fn, init) {
    if (!is_array_default(arr) && !is_plain_object_default(arr)) {
      return arr;
    }
    var result = init;
    each_default(arr, function(data, i) {
      result = fn(result, data, i);
    });
    return result;
  };
  var reduce_default = reduce;

  // node_modules/@antv/util/esm/remove.js
  var remove2 = function(arr, predicate) {
    var result = [];
    if (!is_array_like_default(arr)) {
      return result;
    }
    var i = -1;
    var indexes = [];
    var length3 = arr.length;
    while (++i < length3) {
      var value = arr[i];
      if (predicate(value, i, arr)) {
        result.push(value);
        indexes.push(i);
      }
    }
    pull_at_default(arr, indexes);
    return result;
  };
  var remove_default = remove2;

  // node_modules/@antv/util/esm/is-string.js
  var is_string_default = function(str4) {
    return is_type_default(str4, "String");
  };

  // node_modules/@antv/util/esm/uniq.js
  function uniq(arr, cache3) {
    if (cache3 === void 0) {
      cache3 = new Map();
    }
    var r = [];
    if (Array.isArray(arr)) {
      for (var i = 0, len3 = arr.length; i < len3; i++) {
        var item = arr[i];
        if (!cache3.has(item)) {
          r.push(item);
          cache3.set(item, true);
        }
      }
    }
    return r;
  }

  // node_modules/@antv/util/esm/values-of-key.js
  var values_of_key_default = function(data, name) {
    var rst = [];
    var tmpMap = {};
    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var value = obj[name];
      if (!is_nil_default(value)) {
        if (!is_array_default(value)) {
          value = [value];
        }
        for (var j = 0; j < value.length; j++) {
          var val = value[j];
          if (!tmpMap[val]) {
            rst.push(val);
            tmpMap[val] = true;
          }
        }
      }
    }
    return rst;
  };

  // node_modules/@antv/util/esm/head.js
  function head(o) {
    if (is_array_like_default(o)) {
      return o[0];
    }
    return void 0;
  }

  // node_modules/@antv/util/esm/last.js
  function last(o) {
    if (is_array_like_default(o)) {
      var arr = o;
      return arr[arr.length - 1];
    }
    return void 0;
  }

  // node_modules/@antv/util/esm/every.js
  var every = function(arr, func) {
    for (var i = 0; i < arr.length; i++) {
      if (!func(arr[i], i))
        return false;
    }
    return true;
  };
  var every_default = every;

  // node_modules/@antv/util/esm/some.js
  var some = function(arr, func) {
    for (var i = 0; i < arr.length; i++) {
      if (func(arr[i], i))
        return true;
    }
    return false;
  };
  var some_default = some;

  // node_modules/@antv/util/esm/group-by.js
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function groupBy(data, condition) {
    if (!condition || !is_array_default(data)) {
      return {};
    }
    var result = {};
    var predicate = is_function_default(condition) ? condition : function(item2) {
      return item2[condition];
    };
    var key;
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      key = predicate(item);
      if (hasOwnProperty2.call(result, key)) {
        result[key].push(item);
      } else {
        result[key] = [item];
      }
    }
    return result;
  }
  var group_by_default = groupBy;

  // node_modules/@antv/util/esm/group-to-map.js
  function groupToMap(data, condition) {
    if (!condition) {
      return {
        0: data
      };
    }
    if (!is_function_default(condition)) {
      var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
      condition = function(row) {
        var unique = "_";
        for (var i = 0, l = paramscondition_1.length; i < l; i++) {
          unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
        }
        return unique;
      };
    }
    return group_by_default(data, condition);
  }

  // node_modules/@antv/util/esm/group.js
  var group_default = function(data, condition) {
    if (!condition) {
      return [data];
    }
    var groups = groupToMap(data, condition);
    var array = [];
    for (var i in groups) {
      array.push(groups[i]);
    }
    return array;
  };

  // node_modules/@antv/util/esm/clamp.js
  var clamp = function(a, min3, max3) {
    if (a < min3) {
      return min3;
    } else if (a > max3) {
      return max3;
    }
    return a;
  };
  var clamp_default = clamp;

  // node_modules/@antv/util/esm/fixed-base.js
  var fixedBase = function(v, base) {
    var str4 = base.toString();
    var index = str4.indexOf(".");
    if (index === -1) {
      return Math.round(v);
    }
    var length3 = str4.substr(index + 1).length;
    if (length3 > 20) {
      length3 = 20;
    }
    return parseFloat(v.toFixed(length3));
  };
  var fixed_base_default = fixedBase;

  // node_modules/@antv/util/esm/is-number.js
  var isNumber = function(value) {
    return is_type_default(value, "Number");
  };
  var is_number_default = isNumber;

  // node_modules/@antv/util/esm/is-integer.js
  var isInteger = Number.isInteger ? Number.isInteger : function(num) {
    return is_number_default(num) && num % 1 === 0;
  };

  // node_modules/@antv/util/esm/is-number-equal.js
  var PRECISION = 1e-5;
  function isNumberEqual(a, b, precision) {
    if (precision === void 0) {
      precision = PRECISION;
    }
    return Math.abs(a - b) < precision;
  }

  // node_modules/@antv/util/esm/mod.js
  var mod = function(n, m) {
    return (n % m + m) % m;
  };
  var mod_default = mod;

  // node_modules/@antv/util/esm/to-degree.js
  var DEGREE = 180 / Math.PI;

  // node_modules/@antv/util/esm/to-radian.js
  var RADIAN = Math.PI / 180;
  var toRadian = function(degree2) {
    return RADIAN * degree2;
  };
  var to_radian_default = toRadian;

  // node_modules/@antv/util/esm/has.js
  var has_default = function(obj, key) {
    return obj.hasOwnProperty(key);
  };

  // node_modules/@antv/util/esm/has-key.js
  var has_key_default = has_default;

  // node_modules/@antv/util/esm/values.js
  var values = Object.values ? function(obj) {
    return Object.values(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value, key) {
      if (!(is_function_default(obj) && key === "prototype")) {
        result.push(value);
      }
    });
    return result;
  };
  var values_default = values;

  // node_modules/@antv/util/esm/to-string.js
  var to_string_default = function(value) {
    if (is_nil_default(value))
      return "";
    return value.toString();
  };

  // node_modules/@antv/util/esm/lower-case.js
  var lowerCase = function(str4) {
    return to_string_default(str4).toLowerCase();
  };
  var lower_case_default = lowerCase;

  // node_modules/@antv/util/esm/substitute.js
  function substitute(str4, o) {
    if (!str4 || !o) {
      return str4;
    }
    return str4.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
      if (match.charAt(0) === "\\") {
        return match.slice(1);
      }
      return o[name] === void 0 ? "" : o[name];
    });
  }
  var substitute_default = substitute;

  // node_modules/@antv/util/esm/upper-first.js
  var upperFirst = function(value) {
    var str4 = to_string_default(value);
    return str4.charAt(0).toUpperCase() + str4.substring(1);
  };
  var upper_first_default = upperFirst;

  // node_modules/@antv/util/esm/get-type.js
  var toString2 = {}.toString;
  var getType2 = function(value) {
    return toString2.call(value).replace(/^\[object /, "").replace(/]$/, "");
  };
  var get_type_default = getType2;

  // node_modules/@antv/util/esm/is-boolean.js
  var isBoolean2 = function(value) {
    return is_type_default(value, "Boolean");
  };
  var is_boolean_default = isBoolean2;

  // node_modules/@antv/util/esm/is-date.js
  var isDate = function(value) {
    return is_type_default(value, "Date");
  };
  var is_date_default = isDate;

  // node_modules/@antv/util/esm/is-null.js
  var isNull = function(value) {
    return value === null;
  };
  var is_null_default = isNull;

  // node_modules/@antv/util/esm/is-prototype.js
  var objectProto = Object.prototype;
  var isPrototype = function(value) {
    var Ctor = value && value.constructor;
    var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var is_prototype_default = isPrototype;

  // node_modules/@antv/util/esm/is-undefined.js
  var isUndefined = function(value) {
    return value === void 0;
  };
  var is_undefined_default = isUndefined;

  // node_modules/@antv/util/esm/is-element.js
  var isElement = function(o) {
    return o instanceof Element || o instanceof HTMLDocument;
  };
  var is_element_default = isElement;

  // node_modules/@antv/util/esm/request-animation-frame.js
  function requestAnimationFrame2(fn) {
    var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
      return setTimeout(f, 16);
    };
    return method(fn);
  }

  // node_modules/@antv/util/esm/clear-animation-frame.js
  function cancelAnimationFrame(handler) {
    var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
    method(handler);
  }

  // node_modules/@antv/util/esm/mix.js
  function _mix(dist3, obj) {
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
        dist3[key] = obj[key];
      }
    }
  }
  function mix(dist3, src1, src2, src3) {
    if (src1)
      _mix(dist3, src1);
    if (src2)
      _mix(dist3, src2);
    if (src3)
      _mix(dist3, src3);
    return dist3;
  }

  // node_modules/@antv/util/esm/clone.js
  var clone = function(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (is_array_default(obj)) {
      rst = [];
      for (var i = 0, l = obj.length; i < l; i++) {
        if (typeof obj[i] === "object" && obj[i] != null) {
          rst[i] = clone(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (typeof obj[k] === "object" && obj[k] != null) {
          rst[k] = clone(obj[k]);
        } else {
          rst[k] = obj[k];
        }
      }
    }
    return rst;
  };
  var clone_default = clone;

  // node_modules/@antv/util/esm/debounce.js
  function debounce(func, wait, immediate) {
    var timeout2;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout2 = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout2;
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }
  var debounce_default = debounce;

  // node_modules/@antv/util/esm/memoize.js
  var memoize_default = function(f, resolver) {
    if (!is_function_default(f)) {
      throw new TypeError("Expected a function");
    }
    var memoized = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache3 = memoized.cache;
      if (cache3.has(key)) {
        return cache3.get(key);
      }
      var result = f.apply(this, args);
      cache3.set(key, result);
      return result;
    };
    memoized.cache = new Map();
    return memoized;
  };

  // node_modules/@antv/util/esm/deep-mix.js
  var MAX_MIX_LEVEL = 5;
  function _deepMix(dist3, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        var value = src[key];
        if (value !== null && is_plain_object_default(value)) {
          if (!is_plain_object_default(dist3[key])) {
            dist3[key] = {};
          }
          if (level < maxLevel) {
            _deepMix(dist3[key], value, level + 1, maxLevel);
          } else {
            dist3[key] = src[key];
          }
        } else if (is_array_default(value)) {
          dist3[key] = [];
          dist3[key] = dist3[key].concat(value);
        } else if (value !== void 0) {
          dist3[key] = value;
        }
      }
    }
  }
  var deepMix = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      _deepMix(rst, args[i]);
    }
    return rst;
  };
  var deep_mix_default = deepMix;

  // node_modules/@antv/util/esm/index-of.js
  var indexOf2 = function(arr, obj) {
    if (!is_array_like_default(arr)) {
      return -1;
    }
    var m = Array.prototype.indexOf;
    if (m) {
      return m.call(arr, obj);
    }
    var index = -1;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === obj) {
        index = i;
        break;
      }
    }
    return index;
  };
  var index_of_default = indexOf2;

  // node_modules/@antv/util/esm/is-empty.js
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
  function isEmpty(value) {
    if (is_nil_default(value)) {
      return true;
    }
    if (is_array_like_default(value)) {
      return !value.length;
    }
    var type = get_type_default(value);
    if (type === "Map" || type === "Set") {
      return !value.size;
    }
    if (is_prototype_default(value)) {
      return !Object.keys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty3.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  var is_empty_default = isEmpty;

  // node_modules/@antv/util/esm/is-equal.js
  var isEqual = function(value, other) {
    if (value === other) {
      return true;
    }
    if (!value || !other) {
      return false;
    }
    if (is_string_default(value) || is_string_default(other)) {
      return false;
    }
    if (is_array_like_default(value) || is_array_like_default(other)) {
      if (value.length !== other.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < value.length; i++) {
        rst = isEqual(value[i], other[i]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    if (is_object_like_default(value) || is_object_like_default(other)) {
      var valueKeys = Object.keys(value);
      var otherKeys = Object.keys(other);
      if (valueKeys.length !== otherKeys.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < valueKeys.length; i++) {
        rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    return false;
  };
  var is_equal_default = isEqual;

  // node_modules/@antv/util/esm/map.js
  var map2 = function(arr, func) {
    if (!is_array_like_default(arr)) {
      return arr;
    }
    var result = [];
    for (var index = 0; index < arr.length; index++) {
      var value = arr[index];
      result.push(func(value, index));
    }
    return result;
  };
  var map_default = map2;

  // node_modules/@antv/util/esm/map-values.js
  var identity = function(v) {
    return v;
  };
  var map_values_default = function(object, func) {
    if (func === void 0) {
      func = identity;
    }
    var r = {};
    if (is_object_default(object) && !is_nil_default(object)) {
      Object.keys(object).forEach(function(key) {
        r[key] = func(object[key], key);
      });
    }
    return r;
  };

  // node_modules/@antv/util/esm/get.js
  var get_default = function(obj, key, defaultValue) {
    var p2 = 0;
    var keyArr = is_string_default(key) ? key.split(".") : key;
    while (obj && p2 < keyArr.length) {
      obj = obj[keyArr[p2++]];
    }
    return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
  };

  // node_modules/@antv/util/esm/set.js
  var set_default = function(obj, path, value) {
    var o = obj;
    var keyArr = is_string_default(path) ? path.split(".") : path;
    keyArr.forEach(function(key, idx) {
      if (idx < keyArr.length - 1) {
        if (!is_object_default(o[key])) {
          o[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
        }
        o = o[key];
      } else {
        o[key] = value;
      }
    });
    return obj;
  };

  // node_modules/@antv/util/esm/pick.js
  var hasOwnProperty4 = Object.prototype.hasOwnProperty;
  var pick_default = function(object, keys2) {
    if (object === null || !is_plain_object_default(object)) {
      return {};
    }
    var result = {};
    each_default(keys2, function(key) {
      if (hasOwnProperty4.call(object, key)) {
        result[key] = object[key];
      }
    });
    return result;
  };

  // node_modules/@antv/util/esm/throttle.js
  var throttle_default = function(func, wait, options) {
    var timeout2, context, args, result;
    var previous = 0;
    if (!options)
      options = {};
    var later = function() {
      previous = options.leading === false ? 0 : Date.now();
      timeout2 = null;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    };
    var throttled = function() {
      var now2 = Date.now();
      if (!previous && options.leading === false)
        previous = now2;
      var remaining = wait - (now2 - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
        previous = now2;
        result = func.apply(context, args);
        if (!timeout2)
          context = args = null;
      } else if (!timeout2 && options.trailing !== false) {
        timeout2 = setTimeout(later, remaining);
      }
      return result;
    };
    throttled.cancel = function() {
      clearTimeout(timeout2);
      previous = 0;
      timeout2 = context = args = null;
    };
    return throttled;
  };

  // node_modules/@antv/util/esm/to-array.js
  var to_array_default = function(value) {
    return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
  };

  // node_modules/@antv/util/esm/unique-id.js
  var map3 = {};
  var unique_id_default = function(prefix) {
    prefix = prefix || "g";
    if (!map3[prefix]) {
      map3[prefix] = 1;
    } else {
      map3[prefix] += 1;
    }
    return prefix + map3[prefix];
  };

  // node_modules/@antv/util/esm/noop.js
  var noop_default = function() {
  };

  // node_modules/@antv/util/esm/size.js
  function size2(o) {
    if (is_nil_default(o)) {
      return 0;
    }
    if (is_array_like_default(o)) {
      return o.length;
    }
    return Object.keys(o).length;
  }

  // node_modules/@antv/util/node_modules/tslib/modules/index.js
  var import_tslib2 = __toModule(require_tslib2());
  var {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter2,
    __generator: __generator2,
    __exportStar: __exportStar2,
    __createBinding: __createBinding2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __spreadArray: __spreadArray2,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2
  } = import_tslib2.default;

  // node_modules/@antv/util/esm/measure-text-width.js
  var ctx;
  var measure_text_width_default = memoize_default(function(text, font) {
    if (font === void 0) {
      font = {};
    }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (!ctx) {
      ctx = document.createElement("canvas").getContext("2d");
    }
    ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
    return ctx.measureText(is_string_default(text) ? text : "").width;
  }, function(text, font) {
    if (font === void 0) {
      font = {};
    }
    return __spreadArrays2([text], values_default(font)).join("");
  });

  // node_modules/@antv/util/esm/get-ellipsis-text.js
  var get_ellipsis_text_default = function(text, maxWidth, font, str4) {
    if (str4 === void 0) {
      str4 = "...";
    }
    var STEP = 16;
    var PLACEHOLDER_WIDTH = measure_text_width_default(str4, font);
    var leftText = !is_string_default(text) ? to_string_default(text) : text;
    var leftWidth = maxWidth;
    var r = [];
    var currentText;
    var currentWidth;
    if (measure_text_width_default(text, font) <= maxWidth) {
      return text;
    }
    while (true) {
      currentText = leftText.substr(0, STEP);
      currentWidth = measure_text_width_default(currentText, font);
      if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
        if (currentWidth > leftWidth) {
          break;
        }
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(STEP);
      if (!leftText) {
        return r.join("");
      }
    }
    while (true) {
      currentText = leftText.substr(0, 1);
      currentWidth = measure_text_width_default(currentText, font);
      if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
        break;
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(1);
      if (!leftText) {
        return r.join("");
      }
    }
    return "" + r.join("") + str4;
  };

  // node_modules/@antv/util/esm/cache.js
  var default_1 = function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def2) {
      var v = this.map[key];
      return v === void 0 ? def2 : v;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }();
  var cache_default = default_1;

  // node_modules/@antv/g2/esm/constant.js
  var LAYER;
  (function(LAYER2) {
    LAYER2["FORE"] = "fore";
    LAYER2["MID"] = "mid";
    LAYER2["BG"] = "bg";
  })(LAYER || (LAYER = {}));
  var DIRECTION;
  (function(DIRECTION2) {
    DIRECTION2["TOP"] = "top";
    DIRECTION2["TOP_LEFT"] = "top-left";
    DIRECTION2["TOP_RIGHT"] = "top-right";
    DIRECTION2["RIGHT"] = "right";
    DIRECTION2["RIGHT_TOP"] = "right-top";
    DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
    DIRECTION2["LEFT"] = "left";
    DIRECTION2["LEFT_TOP"] = "left-top";
    DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
    DIRECTION2["BOTTOM"] = "bottom";
    DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
    DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
    DIRECTION2["RADIUS"] = "radius";
    DIRECTION2["CIRCLE"] = "circle";
    DIRECTION2["NONE"] = "none";
  })(DIRECTION || (DIRECTION = {}));
  var COMPONENT_TYPE;
  (function(COMPONENT_TYPE2) {
    COMPONENT_TYPE2["AXIS"] = "axis";
    COMPONENT_TYPE2["GRID"] = "grid";
    COMPONENT_TYPE2["LEGEND"] = "legend";
    COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
    COMPONENT_TYPE2["ANNOTATION"] = "annotation";
    COMPONENT_TYPE2["SLIDER"] = "slider";
    COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
    COMPONENT_TYPE2["OTHER"] = "other";
  })(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
  var GROUP_Z_INDEX = {
    FORE: 3,
    MID: 2,
    BG: 1
  };
  var VIEW_LIFE_CIRCLE;
  (function(VIEW_LIFE_CIRCLE2) {
    VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
    VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
    VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
    VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
    VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
    VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
    VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
    VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
    VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
    VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
    VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
  })(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
  var GEOMETRY_LIFE_CIRCLE;
  (function(GEOMETRY_LIFE_CIRCLE2) {
    GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
    GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
  })(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
  var PLOT_EVENTS;
  (function(PLOT_EVENTS2) {
    PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
    PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
    PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
    PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
    PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
    PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
    PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
    PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
    PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
    PLOT_EVENTS2["CLICK"] = "plot:click";
    PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
    PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
    PLOT_EVENTS2["LEAVE"] = "plot:leave";
    PLOT_EVENTS2["ENTER"] = "plot:enter";
  })(PLOT_EVENTS || (PLOT_EVENTS = {}));
  var ELEMENT_STATE;
  (function(ELEMENT_STATE2) {
    ELEMENT_STATE2["ACTIVE"] = "active";
    ELEMENT_STATE2["INACTIVE"] = "inactive";
    ELEMENT_STATE2["SELECTED"] = "selected";
    ELEMENT_STATE2["DEFAULT"] = "default";
  })(ELEMENT_STATE || (ELEMENT_STATE = {}));
  var GROUP_ATTRS = ["color", "shape", "size"];
  var FIELD_ORIGIN = "_origin";
  var MIN_CHART_WIDTH = 1;
  var MIN_CHART_HEIGHT = 1;
  var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;

  // node_modules/@antv/g2/esm/engine/index.js
  var ENGINES = {};
  function getEngine(name) {
    var G = ENGINES[name];
    if (!G) {
      throw new Error("G engine '" + name + "' is not exist, please register it at first.");
    }
    return G;
  }
  function registerEngine(name, engine) {
    ENGINES[name] = engine;
  }

  // node_modules/@antv/dom-util/esm/add-event-listener.js
  function addEventListener2(target, eventType, callback) {
    if (target) {
      if (typeof target.addEventListener === "function") {
        target.addEventListener(eventType, callback, false);
        return {
          remove: function() {
            target.removeEventListener(eventType, callback, false);
          }
        };
      }
      if (typeof target.attachEvent === "function") {
        target.attachEvent("on" + eventType, callback);
        return {
          remove: function() {
            target.detachEvent("on" + eventType, callback);
          }
        };
      }
    }
  }

  // node_modules/@antv/dom-util/esm/create-dom.js
  var TABLE;
  var TABLE_TR;
  var FRAGMENT_REG;
  var CONTAINERS;
  function initConstants() {
    TABLE = document.createElement("table");
    TABLE_TR = document.createElement("tr");
    FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
    CONTAINERS = {
      tr: document.createElement("tbody"),
      tbody: TABLE,
      thead: TABLE,
      tfoot: TABLE,
      td: TABLE_TR,
      th: TABLE_TR,
      "*": document.createElement("div")
    };
  }
  function createDom(str4) {
    if (!TABLE) {
      initConstants();
    }
    var name = FRAGMENT_REG.test(str4) && RegExp.$1;
    if (!name || !(name in CONTAINERS)) {
      name = "*";
    }
    var container = CONTAINERS[name];
    str4 = str4.replace(/(^\s*)|(\s*$)/g, "");
    container.innerHTML = "" + str4;
    var dom = container.childNodes[0];
    container.removeChild(dom);
    return dom;
  }

  // node_modules/@antv/dom-util/esm/get-style.js
  function getStyle(dom, name, defaultValue) {
    var v;
    try {
      v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
    } catch (e) {
    } finally {
      v = v === void 0 ? defaultValue : v;
    }
    return v;
  }

  // node_modules/@antv/dom-util/esm/get-height.js
  function getHeight(el, defaultValue) {
    var height = getStyle(el, "height", defaultValue);
    if (height === "auto") {
      height = el.offsetHeight;
    }
    return parseFloat(height);
  }

  // node_modules/@antv/dom-util/esm/get-outer-height.js
  function getOuterHeight(el, defaultValue) {
    var height = getHeight(el, defaultValue);
    var bTop = parseFloat(getStyle(el, "borderTopWidth")) || 0;
    var pTop = parseFloat(getStyle(el, "paddingTop")) || 0;
    var pBottom = parseFloat(getStyle(el, "paddingBottom")) || 0;
    var bBottom = parseFloat(getStyle(el, "borderBottomWidth")) || 0;
    var mTop = parseFloat(getStyle(el, "marginTop")) || 0;
    var mBottom = parseFloat(getStyle(el, "marginBottom")) || 0;
    return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
  }

  // node_modules/@antv/dom-util/esm/get-width.js
  function getHeight2(el, defaultValue) {
    var width = getStyle(el, "width", defaultValue);
    if (width === "auto") {
      width = el.offsetWidth;
    }
    return parseFloat(width);
  }

  // node_modules/@antv/dom-util/esm/get-outer-width.js
  function getOuterWidth(el, defaultValue) {
    var width = getHeight2(el, defaultValue);
    var bLeft = parseFloat(getStyle(el, "borderLeftWidth")) || 0;
    var pLeft = parseFloat(getStyle(el, "paddingLeft")) || 0;
    var pRight = parseFloat(getStyle(el, "paddingRight")) || 0;
    var bRight = parseFloat(getStyle(el, "borderRightWidth")) || 0;
    var mRight = parseFloat(getStyle(el, "marginRight")) || 0;
    var mLeft = parseFloat(getStyle(el, "marginLeft")) || 0;
    return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
  }

  // node_modules/@antv/dom-util/esm/modify-css.js
  function modifyCSS(dom, css) {
    if (dom) {
      for (var key in css) {
        if (css.hasOwnProperty(key)) {
          dom.style[key] = css[key];
        }
      }
    }
    return dom;
  }

  // node_modules/@antv/g2/esm/util/dom.js
  function getElementSize(ele) {
    var style = getComputedStyle(ele);
    return {
      width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
      height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
    };
  }
  function isNumber2(v) {
    return typeof v === "number" && !isNaN(v);
  }
  function getChartSize(ele, autoFit, width, height) {
    var w = width;
    var h2 = height;
    if (autoFit) {
      var size3 = getElementSize(ele);
      w = size3.width ? size3.width : w;
      h2 = size3.height ? size3.height : h2;
    }
    return {
      width: Math.max(isNumber2(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
      height: Math.max(isNumber2(h2) ? h2 : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
    };
  }
  function removeDom(dom) {
    var parent = dom.parentNode;
    if (parent) {
      parent.removeChild(dom);
    }
  }

  // node_modules/@antv/event-emitter/esm/index.js
  var WILDCARD = "*";
  var EventEmitter = function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      this.on(evt, callback, true);
      return this;
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length3 = es.length;
        for (var i = 0; i < length3; i++) {
          if (!es[i]) {
            continue;
          }
          var _a4 = es[i], callback = _a4.callback, once = _a4.once;
          if (once) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length3--;
            i--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }();
  var esm_default = EventEmitter;

  // node_modules/@antv/g2/esm/base.js
  var Base = function(_super) {
    __extends(Base4, _super);
    function Base4(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var _a4 = cfg.visible, visible = _a4 === void 0 ? true : _a4;
      _this.visible = visible;
      return _this;
    }
    Base4.prototype.show = function() {
      var visible = this.visible;
      if (!visible) {
        this.changeVisible(true);
      }
    };
    Base4.prototype.hide = function() {
      var visible = this.visible;
      if (visible) {
        this.changeVisible(false);
      }
    };
    Base4.prototype.destroy = function() {
      this.off();
      this.destroyed = true;
    };
    Base4.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;
    };
    return Base4;
  }(esm_default);
  var base_default = Base;

  // node_modules/@antv/g-base/esm/util/path.js
  var path_exports = {};
  __export(path_exports, {
    catmullRomToBezier: () => catmullRomToBezier,
    fillPath: () => fillPath,
    fillPathByDiff: () => fillPathByDiff,
    formatPath: () => formatPath,
    intersection: () => intersection,
    parsePathArray: () => parsePathArray,
    parsePathString: () => parsePathString,
    pathToAbsolute: () => pathToAbsolute,
    pathToCurve: () => pathToCurve,
    rectPath: () => rectPath
  });
  var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
  var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
  var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
  var parsePathString = function(pathString) {
    if (!pathString) {
      return null;
    }
    if (is_array_default(pathString)) {
      return pathString;
    }
    var paramCounts = {
      a: 7,
      c: 6,
      o: 2,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      u: 3,
      z: 0
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND, function(a, b, c) {
      var params = [];
      var name = b.toLowerCase();
      c.replace(PATH_VALUES, function(a2, b10) {
        b10 && params.push(+b10);
      });
      if (name === "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = "l";
        b = b === "m" ? "l" : "L";
      }
      if (name === "o" && params.length === 1) {
        data.push([b, params[0]]);
      }
      if (name === "r") {
        data.push([b].concat(params));
      } else {
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      }
      return pathString;
    });
    return data;
  };
  var catmullRomToBezier = function(crp, z) {
    var d = [];
    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
      var p2 = [
        {
          x: +crp[i - 2],
          y: +crp[i - 1]
        },
        {
          x: +crp[i],
          y: +crp[i + 1]
        },
        {
          x: +crp[i + 2],
          y: +crp[i + 3]
        },
        {
          x: +crp[i + 4],
          y: +crp[i + 5]
        }
      ];
      if (z) {
        if (!i) {
          p2[0] = {
            x: +crp[iLen - 2],
            y: +crp[iLen - 1]
          };
        } else if (iLen - 4 === i) {
          p2[3] = {
            x: +crp[0],
            y: +crp[1]
          };
        } else if (iLen - 2 === i) {
          p2[2] = {
            x: +crp[0],
            y: +crp[1]
          };
          p2[3] = {
            x: +crp[2],
            y: +crp[3]
          };
        }
      } else {
        if (iLen - 4 === i) {
          p2[3] = p2[2];
        } else if (!i) {
          p2[0] = {
            x: +crp[i],
            y: +crp[i + 1]
          };
        }
      }
      d.push([
        "C",
        (-p2[0].x + 6 * p2[1].x + p2[2].x) / 6,
        (-p2[0].y + 6 * p2[1].y + p2[2].y) / 6,
        (p2[1].x + 6 * p2[2].x - p2[3].x) / 6,
        (p2[1].y + 6 * p2[2].y - p2[3].y) / 6,
        p2[2].x,
        p2[2].y
      ]);
    }
    return d;
  };
  var ellipsePath = function(x, y, rx, ry, a) {
    var res = [];
    if (a === null && ry === null) {
      ry = rx;
    }
    x = +x;
    y = +y;
    rx = +rx;
    ry = +ry;
    if (a !== null) {
      var rad = Math.PI / 180;
      var x1 = x + rx * Math.cos(-ry * rad);
      var x2 = x + rx * Math.cos(-a * rad);
      var y1 = y + rx * Math.sin(-ry * rad);
      var y2 = y + rx * Math.sin(-a * rad);
      res = [
        ["M", x1, y1],
        ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
      ];
    } else {
      res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
    }
    return res;
  };
  var pathToAbsolute = function(pathArray) {
    pathArray = parsePathString(pathArray);
    if (!pathArray || !pathArray.length) {
      return [["M", 0, 0]];
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    if (pathArray[0][0] === "M") {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ["M", x, y];
    }
    var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
    for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
      res.push(r = []);
      pa = pathArray[i];
      pa0 = pa[0];
      if (pa0 !== pa0.toUpperCase()) {
        r[0] = pa0.toUpperCase();
        switch (r[0]) {
          case "A":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case "V":
            r[1] = +pa[1] + y;
            break;
          case "H":
            r[1] = +pa[1] + x;
            break;
          case "R":
            dots = [x, y].concat(pa.slice(1));
            for (var j = 2, jj = dots.length; j < jj; j++) {
              dots[j] = +dots[j] + x;
              dots[++j] = +dots[j] + y;
            }
            res.pop();
            res = res.concat(catmullRomToBezier(dots, crz));
            break;
          case "O":
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
            break;
          case "U":
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ["U"].concat(res[res.length - 1].slice(-2));
            break;
          case "M":
            mx = +pa[1] + x;
            my = +pa[2] + y;
            break;
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else if (pa0 === "R") {
        dots = [x, y].concat(pa.slice(1));
        res.pop();
        res = res.concat(catmullRomToBezier(dots, crz));
        r = ["R"].concat(pa.slice(-2));
      } else if (pa0 === "O") {
        res.pop();
        dots = ellipsePath(x, y, pa[1], pa[2]);
        dots.push(dots[0]);
        res = res.concat(dots);
      } else if (pa0 === "U") {
        res.pop();
        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
        r = ["U"].concat(res[res.length - 1].slice(-2));
      } else {
        for (var k = 0, kk = pa.length; k < kk; k++) {
          r[k] = pa[k];
        }
      }
      pa0 = pa0.toUpperCase();
      if (pa0 !== "O") {
        switch (r[0]) {
          case "Z":
            x = +mx;
            y = +my;
            break;
          case "H":
            x = r[1];
            break;
          case "V":
            y = r[1];
            break;
          case "M":
            mx = r[r.length - 2];
            my = r[r.length - 1];
            break;
          default:
            x = r[r.length - 2];
            y = r[r.length - 1];
        }
      }
    }
    return res;
  };
  var l2c = function(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  };
  var q2c = function(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3;
    var _23 = 2 / 3;
    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  };
  var a2c = function(x1, y1, rx, ry, angle3, large_arc_flag, sweep_flag, x2, y2, recursive) {
    if (rx === ry) {
      rx += 1;
    }
    var _120 = Math.PI * 120 / 180;
    var rad = Math.PI / 180 * (+angle3 || 0);
    var res = [];
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    var rotate5 = function(x3, y3, rad2) {
      var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
      var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
      return {
        x: X,
        y: Y
      };
    };
    if (!recursive) {
      xy = rotate5(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate5(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      if (x1 === x2 && y1 === y2) {
        x2 += 1;
        y2 += 1;
      }
      var x = (x1 - x2) / 2;
      var y = (y1 - y2) / 2;
      var h2 = x * x / (rx * rx) + y * y / (ry * ry);
      if (h2 > 1) {
        h2 = Math.sqrt(h2);
        rx = h2 * rx;
        ry = h2 * ry;
      }
      var rx2 = rx * rx;
      var ry2 = ry * ry;
      var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
      cx = k * rx * y / ry + (x1 + x2) / 2;
      cy = k * -ry * x / rx + (y1 + y2) / 2;
      f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
      f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
      f1 = x1 < cx ? Math.PI - f1 : f1;
      f2 = x2 < cx ? Math.PI - f2 : f2;
      f1 < 0 && (f1 = Math.PI * 2 + f1);
      f2 < 0 && (f2 = Math.PI * 2 + f2);
      if (sweep_flag && f1 > f2) {
        f1 = f1 - Math.PI * 2;
      }
      if (!sweep_flag && f2 > f1) {
        f2 = f2 - Math.PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > _120) {
      var f2old = f2;
      var x2old = x2;
      var y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * Math.cos(f2);
      y2 = cy + ry * Math.sin(f2);
      res = a2c(x2, y2, rx, ry, angle3, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c2 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = 4 / 3 * rx * t;
    var hy = 4 / 3 * ry * t;
    var m1 = [x1, y1];
    var m2 = [x1 + hx * s1, y1 - hy * c1];
    var m3 = [x2 + hx * s2, y2 - hy * c2];
    var m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
      return [m2, m3, m4].concat(res);
    }
    res = [m2, m3, m4].concat(res).join().split(",");
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i++) {
      newres[i] = i % 2 ? rotate5(res[i - 1], res[i], rad).y : rotate5(res[i], res[i + 1], rad).x;
    }
    return newres;
  };
  var pathToCurve = function(path, path2) {
    var p2 = pathToAbsolute(path);
    var p22 = path2 && pathToAbsolute(path2);
    var attrs = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    };
    var attrs2 = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    };
    var pcoms1 = [];
    var pcoms2 = [];
    var pfirst = "";
    var pcom = "";
    var ii;
    var processPath = function(path3, d, pcom2) {
      var nx;
      var ny;
      if (!path3) {
        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
      }
      !(path3[0] in {
        T: 1,
        Q: 1
      }) && (d.qx = d.qy = null);
      switch (path3[0]) {
        case "M":
          d.X = path3[1];
          d.Y = path3[2];
          break;
        case "A":
          path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
          break;
        case "S":
          if (pcom2 === "C" || pcom2 === "S") {
            nx = d.x * 2 - d.bx;
            ny = d.y * 2 - d.by;
          } else {
            nx = d.x;
            ny = d.y;
          }
          path3 = ["C", nx, ny].concat(path3.slice(1));
          break;
        case "T":
          if (pcom2 === "Q" || pcom2 === "T") {
            d.qx = d.x * 2 - d.qx;
            d.qy = d.y * 2 - d.qy;
          } else {
            d.qx = d.x;
            d.qy = d.y;
          }
          path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
          break;
        case "Q":
          d.qx = path3[1];
          d.qy = path3[2];
          path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
          break;
        case "L":
          path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
          break;
        case "H":
          path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
          break;
        case "V":
          path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
          break;
        case "Z":
          path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
          break;
        default:
          break;
      }
      return path3;
    };
    var fixArc = function(pp, i2) {
      if (pp[i2].length > 7) {
        pp[i2].shift();
        var pi2 = pp[i2];
        while (pi2.length) {
          pcoms1[i2] = "A";
          p22 && (pcoms2[i2] = "A");
          pp.splice(i2++, 0, ["C"].concat(pi2.splice(0, 6)));
        }
        pp.splice(i2, 1);
        ii = Math.max(p2.length, p22 && p22.length || 0);
      }
    };
    var fixM = function(path1, path22, a1, a2, i2) {
      if (path1 && path22 && path1[i2][0] === "M" && path22[i2][0] !== "M") {
        path22.splice(i2, 0, ["M", a2.x, a2.y]);
        a1.bx = 0;
        a1.by = 0;
        a1.x = path1[i2][1];
        a1.y = path1[i2][2];
        ii = Math.max(p2.length, p22 && p22.length || 0);
      }
    };
    ii = Math.max(p2.length, p22 && p22.length || 0);
    for (var i = 0; i < ii; i++) {
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== "C") {
        pcoms1[i] = pfirst;
        i && (pcom = pcoms1[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs, pcom);
      if (pcoms1[i] !== "A" && pfirst === "C")
        pcoms1[i] = "C";
      fixArc(p2, i);
      if (p22) {
        p22[i] && (pfirst = p22[i][0]);
        if (pfirst !== "C") {
          pcoms2[i] = pfirst;
          i && (pcom = pcoms2[i - 1]);
        }
        p22[i] = processPath(p22[i], attrs2, pcom);
        if (pcoms2[i] !== "A" && pfirst === "C") {
          pcoms2[i] = "C";
        }
        fixArc(p22, i);
      }
      fixM(p2, p22, attrs, attrs2, i);
      fixM(p22, p2, attrs2, attrs, i);
      var seg = p2[i];
      var seg2 = p22 && p22[i];
      var seglen = seg.length;
      var seg2len = p22 && seg2.length;
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
      attrs2.bx = p22 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
      attrs2.by = p22 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
      attrs2.x = p22 && seg2[seg2len - 2];
      attrs2.y = p22 && seg2[seg2len - 1];
    }
    return p22 ? [p2, p22] : p2;
  };
  var p2s = /,?([a-z]),?/gi;
  var parsePathArray = function(path) {
    return path.join(",").replace(p2s, "$1");
  };
  var base3 = function(t, p1, p2, p3, p4) {
    var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
    var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p2;
  };
  var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z === null) {
      z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2;
    var n = 12;
    var Tvalues = [
      -0.1252,
      0.1252,
      -0.3678,
      0.3678,
      -0.5873,
      0.5873,
      -0.7699,
      0.7699,
      -0.9041,
      0.9041,
      -0.9816,
      0.9816
    ];
    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
    var sum = 0;
    for (var i = 0; i < n; i++) {
      var ct = z2 * Tvalues[i] + z2;
      var xbase = base3(ct, x1, x2, x3, x4);
      var ybase = base3(ct, y1, y2, y3, y4);
      var comb = xbase * xbase + ybase * ybase;
      sum += Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum;
  };
  var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [];
    var bounds = [[], []];
    var a;
    var b;
    var c;
    var t;
    for (var i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (t > 0 && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      var b2ac = b * b - 4 * c * a;
      var sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0) {
        continue;
      }
      var t1 = (-b + sqrtb2ac) / (2 * a);
      if (t1 > 0 && t1 < 1) {
        tvalues.push(t1);
      }
      var t2 = (-b - sqrtb2ac) / (2 * a);
      if (t2 > 0 && t2 < 1) {
        tvalues.push(t2);
      }
    }
    var j = tvalues.length;
    var jlen = j;
    var mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
      min: {
        x: Math.min.apply(0, bounds[0]),
        y: Math.min.apply(0, bounds[1])
      },
      max: {
        x: Math.max.apply(0, bounds[0]),
        y: Math.max.apply(0, bounds[1])
      }
    };
  };
  var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
    if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
      return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
      return;
    }
    var px = nx / denominator;
    var py = ny / denominator;
    var px2 = +px.toFixed(2);
    var py2 = +py.toFixed(2);
    if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
      return;
    }
    return {
      x: px,
      y: py
    };
  };
  var isPointInsideBBox = function(bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  };
  var rectPath = function(x, y, w, h2, r) {
    if (r) {
      return [
        ["M", +x + +r, y],
        ["l", w - r * 2, 0],
        ["a", r, r, 0, 0, 1, r, r],
        ["l", 0, h2 - r * 2],
        ["a", r, r, 0, 0, 1, -r, r],
        ["l", r * 2 - w, 0],
        ["a", r, r, 0, 0, 1, -r, -r],
        ["l", 0, r * 2 - h2],
        ["a", r, r, 0, 0, 1, r, -r],
        ["z"]
      ];
    }
    var res = [["M", x, y], ["l", w, 0], ["l", 0, h2], ["l", -w, 0], ["z"]];
    res.parsePathArray = parsePathArray;
    return res;
  };
  var box = function(x, y, width, height) {
    if (x === null) {
      x = y = width = height = 0;
    }
    if (y === null) {
      y = x.y;
      width = x.width;
      height = x.height;
      x = x.x;
    }
    return {
      x,
      y,
      width,
      w: width,
      height,
      h: height,
      x2: x + width,
      y2: y + height,
      cx: x + width / 2,
      cy: y + height / 2,
      r1: Math.min(width, height) / 2,
      r2: Math.max(width, height) / 2,
      r0: Math.sqrt(width * width + height * height) / 2,
      path: rectPath(x, y, width, height),
      vb: [x, y, width, height].join(" ")
    };
  };
  var isBBoxIntersect = function(bbox1, bbox2) {
    bbox1 = box(bbox1);
    bbox2 = box(bbox2);
    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
  };
  var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!is_array_default(p1x)) {
      p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }
    var bbox = curveDim.apply(null, p1x);
    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
  };
  var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    var t13 = Math.pow(t1, 3);
    var t12 = Math.pow(t1, 2);
    var t2 = t * t;
    var t3 = t2 * t;
    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
    var ax = t1 * p1x + t * c1x;
    var ay = t1 * p1y + t * c1y;
    var cx = t1 * c2x + t * p2x;
    var cy = t1 * c2y + t * p2y;
    var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
    return {
      x,
      y,
      m: {
        x: mx,
        y: my
      },
      n: {
        x: nx,
        y: ny
      },
      start: {
        x: ax,
        y: ay
      },
      end: {
        x: cx,
        y: cy
      },
      alpha
    };
  };
  var interHelper = function(bez1, bez2, justCount) {
    var bbox1 = bezierBBox(bez1);
    var bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
      return justCount ? 0 : [];
    }
    var l1 = bezlen.apply(0, bez1);
    var l2 = bezlen.apply(0, bez2);
    var n1 = ~~(l1 / 8);
    var n2 = ~~(l2 / 8);
    var dots1 = [];
    var dots2 = [];
    var xy = {};
    var res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
      var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
      dots1.push({
        x: d.x,
        y: d.y,
        t: i / n1
      });
    }
    for (var i = 0; i < n2 + 1; i++) {
      var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
      dots2.push({
        x: d.x,
        y: d.y,
        t: i / n2
      });
    }
    for (var i = 0; i < n1; i++) {
      for (var j = 0; j < n2; j++) {
        var di = dots1[i];
        var di1 = dots1[i + 1];
        var dj = dots2[j];
        var dj1 = dots2[j + 1];
        var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
        var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
        var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
        if (is) {
          if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
            continue;
          }
          xy[is.x.toFixed(4)] = is.y.toFixed(4);
          var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
          var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
          if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
            if (justCount) {
              res += 1;
            } else {
              res.push({
                x: is.x,
                y: is.y,
                t1,
                t2
              });
            }
          }
        }
      }
    }
    return res;
  };
  var interPathHelper = function(path1, path2, justCount) {
    path1 = pathToCurve(path1);
    path2 = pathToCurve(path2);
    var x1;
    var y1;
    var x2;
    var y2;
    var x1m;
    var y1m;
    var x2m;
    var y2m;
    var bez1;
    var bez2;
    var res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
      var pi2 = path1[i];
      if (pi2[0] === "M") {
        x1 = x1m = pi2[1];
        y1 = y1m = pi2[2];
      } else {
        if (pi2[0] === "C") {
          bez1 = [x1, y1].concat(pi2.slice(1));
          x1 = bez1[6];
          y1 = bez1[7];
        } else {
          bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
          x1 = x1m;
          y1 = y1m;
        }
        for (var j = 0, jj = path2.length; j < jj; j++) {
          var pj = path2[j];
          if (pj[0] === "M") {
            x2 = x2m = pj[1];
            y2 = y2m = pj[2];
          } else {
            if (pj[0] === "C") {
              bez2 = [x2, y2].concat(pj.slice(1));
              x2 = bez2[6];
              y2 = bez2[7];
            } else {
              bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
              x2 = x2m;
              y2 = y2m;
            }
            var intr = interHelper(bez1, bez2, justCount);
            if (justCount) {
              res += intr;
            } else {
              for (var k = 0, kk = intr.length; k < kk; k++) {
                intr[k].segment1 = i;
                intr[k].segment2 = j;
                intr[k].bez1 = bez1;
                intr[k].bez2 = bez2;
              }
              res = res.concat(intr);
            }
          }
        }
      }
    }
    return res;
  };
  var intersection = function(path1, path2) {
    return interPathHelper(path1, path2);
  };
  function decasteljau(points, t) {
    var left = [];
    var right = [];
    function recurse(points2, t2) {
      if (points2.length === 1) {
        left.push(points2[0]);
        right.push(points2[0]);
      } else {
        var middlePoints = [];
        for (var i = 0; i < points2.length - 1; i++) {
          if (i === 0) {
            left.push(points2[0]);
          }
          if (i === points2.length - 2) {
            right.push(points2[i + 1]);
          }
          middlePoints[i] = [
            (1 - t2) * points2[i][0] + t2 * points2[i + 1][0],
            (1 - t2) * points2[i][1] + t2 * points2[i + 1][1]
          ];
        }
        recurse(middlePoints, t2);
      }
    }
    if (points.length) {
      recurse(points, t);
    }
    return { left, right: right.reverse() };
  }
  function splitCurve(start, end, count) {
    var points = [[start[1], start[2]]];
    count = count || 2;
    var segments = [];
    if (end[0] === "A") {
      points.push(end[6]);
      points.push(end[7]);
    } else if (end[0] === "C") {
      points.push([end[1], end[2]]);
      points.push([end[3], end[4]]);
      points.push([end[5], end[6]]);
    } else if (end[0] === "S" || end[0] === "Q") {
      points.push([end[1], end[2]]);
      points.push([end[3], end[4]]);
    } else {
      points.push([end[1], end[2]]);
    }
    var leftSegments = points;
    var t = 1 / count;
    for (var i = 0; i < count - 1; i++) {
      var rt = t / (1 - t * i);
      var split = decasteljau(leftSegments, rt);
      segments.push(split.left);
      leftSegments = split.right;
    }
    segments.push(leftSegments);
    var result = segments.map(function(segment) {
      var cmd = [];
      if (segment.length === 4) {
        cmd.push("C");
        cmd = cmd.concat(segment[2]);
      }
      if (segment.length >= 3) {
        if (segment.length === 3) {
          cmd.push("Q");
        }
        cmd = cmd.concat(segment[1]);
      }
      if (segment.length === 2) {
        cmd.push("L");
      }
      cmd = cmd.concat(segment[segment.length - 1]);
      return cmd;
    });
    return result;
  }
  var splitSegment = function(start, end, count) {
    if (count === 1) {
      return [[].concat(start)];
    }
    var segments = [];
    if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
      segments = segments.concat(splitCurve(start, end, count));
    } else {
      var temp = [].concat(start);
      if (temp[0] === "M") {
        temp[0] = "L";
      }
      for (var i = 0; i <= count - 1; i++) {
        segments.push(temp);
      }
    }
    return segments;
  };
  var fillPath = function(source, target) {
    if (source.length === 1) {
      return source;
    }
    var sourceLen = source.length - 1;
    var targetLen = target.length - 1;
    var ratio = sourceLen / targetLen;
    var segmentsToFill = [];
    if (source.length === 1 && source[0][0] === "M") {
      for (var i = 0; i < targetLen - sourceLen; i++) {
        source.push(source[0]);
      }
      return source;
    }
    for (var i = 0; i < targetLen; i++) {
      var index = Math.floor(ratio * i);
      segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
    }
    var filled = segmentsToFill.reduce(function(filled2, count, i2) {
      if (i2 === sourceLen) {
        return filled2.concat(source[sourceLen]);
      }
      return filled2.concat(splitSegment(source[i2], source[i2 + 1], count));
    }, []);
    filled.unshift(source[0]);
    if (target[targetLen] === "Z" || target[targetLen] === "z") {
      filled.push("Z");
    }
    return filled;
  };
  var isEqual2 = function(obj1, obj2) {
    if (obj1.length !== obj2.length) {
      return false;
    }
    var result = true;
    each_default(obj1, function(item, i) {
      if (item !== obj2[i]) {
        result = false;
        return false;
      }
    });
    return result;
  };
  function getMinDiff(del, add5, modify) {
    var type = null;
    var min3 = modify;
    if (add5 < min3) {
      min3 = add5;
      type = "add";
    }
    if (del < min3) {
      min3 = del;
      type = "del";
    }
    return {
      type,
      min: min3
    };
  }
  var levenshteinDistance = function(source, target) {
    var sourceLen = source.length;
    var targetLen = target.length;
    var sourceSegment;
    var targetSegment;
    var temp = 0;
    if (sourceLen === 0 || targetLen === 0) {
      return null;
    }
    var dist3 = [];
    for (var i = 0; i <= sourceLen; i++) {
      dist3[i] = [];
      dist3[i][0] = { min: i };
    }
    for (var j = 0; j <= targetLen; j++) {
      dist3[0][j] = { min: j };
    }
    for (var i = 1; i <= sourceLen; i++) {
      sourceSegment = source[i - 1];
      for (var j = 1; j <= targetLen; j++) {
        targetSegment = target[j - 1];
        if (isEqual2(sourceSegment, targetSegment)) {
          temp = 0;
        } else {
          temp = 1;
        }
        var del = dist3[i - 1][j].min + 1;
        var add5 = dist3[i][j - 1].min + 1;
        var modify = dist3[i - 1][j - 1].min + temp;
        dist3[i][j] = getMinDiff(del, add5, modify);
      }
    }
    return dist3;
  };
  var fillPathByDiff = function(source, target) {
    var diffMatrix = levenshteinDistance(source, target);
    var sourceLen = source.length;
    var targetLen = target.length;
    var changes = [];
    var index = 1;
    var minPos = 1;
    if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
      for (var i = 1; i <= sourceLen; i++) {
        var min3 = diffMatrix[i][i].min;
        minPos = i;
        for (var j = index; j <= targetLen; j++) {
          if (diffMatrix[i][j].min < min3) {
            min3 = diffMatrix[i][j].min;
            minPos = j;
          }
        }
        index = minPos;
        if (diffMatrix[i][index].type) {
          changes.push({ index: i - 1, type: diffMatrix[i][index].type });
        }
      }
      for (var i = changes.length - 1; i >= 0; i--) {
        index = changes[i].index;
        if (changes[i].type === "add") {
          source.splice(index, 0, [].concat(source[index]));
        } else {
          source.splice(index, 1);
        }
      }
    }
    sourceLen = source.length;
    var diff2 = targetLen - sourceLen;
    if (sourceLen < targetLen) {
      for (var i = 0; i < diff2; i++) {
        if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
          source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
        } else {
          source.push(source[sourceLen - 1]);
        }
        sourceLen += 1;
      }
    }
    return source;
  };
  function _splitPoints(points, former, count) {
    var result = [].concat(points);
    var index;
    var t = 1 / (count + 1);
    var formerEnd = _getSegmentPoints(former)[0];
    for (var i = 1; i <= count; i++) {
      t *= i;
      index = Math.floor(points.length * t);
      if (index === 0) {
        result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
      } else {
        result.splice(index, 0, [
          formerEnd[0] * t + points[index][0] * (1 - t),
          formerEnd[1] * t + points[index][1] * (1 - t)
        ]);
      }
    }
    return result;
  }
  function _getSegmentPoints(segment) {
    var points = [];
    switch (segment[0]) {
      case "M":
        points.push([segment[1], segment[2]]);
        break;
      case "L":
        points.push([segment[1], segment[2]]);
        break;
      case "A":
        points.push([segment[6], segment[7]]);
        break;
      case "Q":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "T":
        points.push([segment[1], segment[2]]);
        break;
      case "C":
        points.push([segment[5], segment[6]]);
        points.push([segment[1], segment[2]]);
        points.push([segment[3], segment[4]]);
        break;
      case "S":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "H":
        points.push([segment[1], segment[1]]);
        break;
      case "V":
        points.push([segment[1], segment[1]]);
        break;
      default:
    }
    return points;
  }
  var formatPath = function(fromPath, toPath) {
    if (fromPath.length <= 1) {
      return fromPath;
    }
    var points;
    for (var i = 0; i < toPath.length; i++) {
      if (fromPath[i][0] !== toPath[i][0]) {
        points = _getSegmentPoints(fromPath[i]);
        switch (toPath[i][0]) {
          case "M":
            fromPath[i] = ["M"].concat(points[0]);
            break;
          case "L":
            fromPath[i] = ["L"].concat(points[0]);
            break;
          case "A":
            fromPath[i] = [].concat(toPath[i]);
            fromPath[i][6] = points[0][0];
            fromPath[i][7] = points[0][1];
            break;
          case "Q":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "T":
            fromPath[i] = ["T"].concat(points[0]);
            break;
          case "C":
            if (points.length < 3) {
              if (i > 0) {
                points = _splitPoints(points, fromPath[i - 1], 2);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "S":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          default:
            fromPath[i] = toPath[i];
        }
      }
    }
    return fromPath;
  };

  // node_modules/@antv/g-base/esm/event/graph-event.js
  var GraphEvent = function() {
    function GraphEvent3(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent3.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent3.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent3.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent3.prototype.save = function() {
    };
    GraphEvent3.prototype.restore = function() {
    };
    return GraphEvent3;
  }();
  var graph_event_default = GraphEvent;

  // node_modules/@antv/g-base/node_modules/tslib/modules/index.js
  var import_tslib5 = __toModule(require_tslib3());
  var {
    __extends: __extends3,
    __assign: __assign3,
    __rest: __rest3,
    __decorate: __decorate3,
    __param: __param3,
    __metadata: __metadata3,
    __awaiter: __awaiter3,
    __generator: __generator3,
    __exportStar: __exportStar3,
    __createBinding: __createBinding3,
    __values: __values3,
    __read: __read3,
    __spread: __spread3,
    __spreadArrays: __spreadArrays3,
    __spreadArray: __spreadArray3,
    __await: __await3,
    __asyncGenerator: __asyncGenerator3,
    __asyncDelegator: __asyncDelegator3,
    __asyncValues: __asyncValues3,
    __makeTemplateObject: __makeTemplateObject3,
    __importStar: __importStar3,
    __importDefault: __importDefault3,
    __classPrivateFieldGet: __classPrivateFieldGet3,
    __classPrivateFieldSet: __classPrivateFieldSet3
  } = import_tslib5.default;

  // node_modules/@antv/g-base/esm/util/util.js
  function removeFromArray(arr, obj) {
    var index = arr.indexOf(obj);
    if (index !== -1) {
      arr.splice(index, 1);
    }
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isParent(container, shape) {
    if (container.isCanvas()) {
      return true;
    }
    var parent = shape.getParent();
    var isParent3 = false;
    while (parent) {
      if (parent === container) {
        isParent3 = true;
        break;
      }
      parent = parent.getParent();
    }
    return isParent3;
  }
  function isAllowCapture(element) {
    return element.cfg.visible && element.cfg.capture;
  }

  // node_modules/@antv/g-base/esm/abstract/base.js
  var Base2 = function(_super) {
    __extends3(Base4, _super);
    function Base4(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base4.prototype.getDefaultCfg = function() {
      return {};
    };
    Base4.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base4.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base4.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base4;
  }(esm_default);
  var base_default2 = Base2;

  // node_modules/detect-browser/es/index.js
  var __spreadArray4 = function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var BrowserInfo = function() {
    function BrowserInfo2(name, version4, os) {
      this.name = name;
      this.version = version4;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }();
  var NodeInfo = function() {
    function NodeInfo2(version4) {
      this.version = version4;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }();
  var SearchBotDeviceInfo = function() {
    function SearchBotDeviceInfo2(name, version4, os, bot) {
      this.name = name;
      this.version = version4;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }();
  var BotInfo = function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }();
  var ReactNativeInfo = function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }();
  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", SEARCHBOX_UA_REGEX]
  ];
  var operatingSystemRules = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/]
  ];
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua) {
    return ua !== "" && userAgentRules.reduce(function(matched, _a4) {
      var browser3 = _a4[0], regex = _a4[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser3, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
      return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArray4(__spreadArray4([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
      }
    } else {
      versionParts = [];
    }
    var version4 = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name, version4, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version4, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a4 = operatingSystemRules[ii], os = _a4[0], regex = _a4[1];
      var match = regex.exec(ua);
      if (match) {
        return os;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode = typeof process !== "undefined" && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
      output.push("0");
    }
    return output;
  }

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };

  // node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add2,
    adjoint: () => adjoint,
    clone: () => clone2,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity2,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set2,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  function clone2(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a, b, scale4) {
    out[0] = a[0] + b[0] * scale4;
    out[1] = a[1] + b[1] * scale4;
    out[2] = a[2] + b[2] * scale4;
    out[3] = a[3] + b[3] * scale4;
    out[4] = a[4] + b[4] * scale4;
    out[5] = a[5] + b[5] * scale4;
    out[6] = a[6] + b[6] * scale4;
    out[7] = a[7] + b[7] * scale4;
    out[8] = a[8] + b[8] * scale4;
    return out;
  }
  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  function equals(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b02 = b[0], b12 = b[1], b22 = b[2], b32 = b[3], b42 = b[4], b52 = b[5], b62 = b[6], b72 = b[7], b82 = b[8];
    return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
  }
  var mul = multiply;
  var sub = subtract;

  // node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add3,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone3,
    copy: () => copy2,
    create: () => create2,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals2,
    exactEquals: () => exactEquals2,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues2,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul2,
    multiply: () => multiply2,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    round: () => round,
    scale: () => scale2,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set3,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone3(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues2(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function copy2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function set3(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply2(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  function scale2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  function scaleAndAdd(out, a, b, scale4) {
    out[0] = a[0] + b[0] * scale4;
    out[1] = a[1] + b[1] * scale4;
    out[2] = a[2] + b[2] * scale4;
    return out;
  }
  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len3 = x * x + y * y + z * z;
    if (len3 > 0) {
      len3 = 1 / Math.sqrt(len3);
    }
    out[0] = a[0] * len3;
    out[1] = a[1] * len3;
    out[2] = a[2] * len3;
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function random(out, scale4) {
    scale4 = scale4 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale4;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale4;
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a, b, rad) {
    var p2 = [], r = [];
    p2[0] = a[0] - b[0];
    p2[1] = a[1] - b[1];
    p2[2] = a[2] - b[2];
    r[0] = p2[0];
    r[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
    r[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY(out, a, b, rad) {
    var p2 = [], r = [];
    p2[0] = a[0] - b[0];
    p2[1] = a[1] - b[1];
    p2[2] = a[2] - b[2];
    r[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
    r[1] = p2[1];
    r[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ(out, a, b, rad) {
    var p2 = [], r = [];
    p2[0] = a[0] - b[0];
    p2[1] = a[1] - b[1];
    p2[2] = a[2] - b[2];
    r[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
    r[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
    r[2] = p2[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str2(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
  }
  function exactEquals2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  function equals2(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b02 = b[0], b12 = b[1], b22 = b[2];
    return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a2 - b22) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b22));
  }
  var sub2 = subtract2;
  var mul2 = multiply2;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var len = length;
  var sqrLen = squaredLength;
  var forEach = function() {
    var vec = create2();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // node_modules/gl-matrix/esm/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add4,
    angle: () => angle2,
    ceil: () => ceil2,
    clone: () => clone4,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals3,
    exactEquals: () => exactEquals3,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues3,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max2,
    min: () => min2,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    rotate: () => rotate2,
    round: () => round2,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set4,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat42,
    zero: () => zero2
  });
  function create3() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone4(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  function fromValues3(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  function copy3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  function set4(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  function add4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  function subtract3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  function multiply3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  function divide2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  function ceil2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  function floor2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  function min2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  function max2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  function round2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  function scaleAndAdd2(out, a, b, scale4) {
    out[0] = a[0] + b[0] * scale4;
    out[1] = a[1] + b[1] * scale4;
    return out;
  }
  function distance2(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  function squaredDistance2(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
  }
  function length2(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
  }
  function squaredLength2(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  function inverse2(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
  }
  function normalize2(out, a) {
    var x = a[0], y = a[1];
    var len3 = x * x + y * y;
    if (len3 > 0) {
      len3 = 1 / Math.sqrt(len3);
    }
    out[0] = a[0] * len3;
    out[1] = a[1] * len3;
    return out;
  }
  function dot2(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function cross2(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function random2(out, scale4) {
    scale4 = scale4 || 1;
    var r = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale4;
    out[1] = Math.sin(r) * scale4;
    return out;
  }
  function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  function transformMat32(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  function rotate2(out, a, b, rad) {
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  function angle2(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str3(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
  }
  function exactEquals3(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  function equals3(a, b) {
    var a0 = a[0], a1 = a[1];
    var b02 = b[0], b12 = b[1];
    return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12));
  }
  var len2 = length2;
  var sub3 = subtract3;
  var mul3 = multiply3;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var sqrLen2 = squaredLength2;
  var forEach2 = function() {
    var vec = create3();
    return function(a, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // node_modules/@antv/matrix-util/esm/ext.js
  var ext_exports = {};
  __export(ext_exports, {
    angleTo: () => angleTo,
    direction: () => direction,
    leftRotate: () => leftRotate,
    leftScale: () => leftScale,
    leftTranslate: () => leftTranslate,
    transform: () => transform,
    vertical: () => vertical
  });
  function leftTranslate(out, a, v) {
    var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    mat3_exports.fromTranslation(transMat, v);
    return mat3_exports.multiply(out, transMat, a);
  }
  function leftRotate(out, a, rad) {
    var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    mat3_exports.fromRotation(rotateMat, rad);
    return mat3_exports.multiply(out, rotateMat, a);
  }
  function leftScale(out, a, v) {
    var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    mat3_exports.fromScaling(scaleMat, v);
    return mat3_exports.multiply(out, scaleMat, a);
  }
  function leftMultiply(out, a, a1) {
    return mat3_exports.multiply(out, a1, a);
  }
  function transform(m, actions) {
    var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
    for (var i = 0, len3 = actions.length; i < len3; i++) {
      var action = actions[i];
      switch (action[0]) {
        case "t":
          leftTranslate(matrix, matrix, [action[1], action[2]]);
          break;
        case "s":
          leftScale(matrix, matrix, [action[1], action[2]]);
          break;
        case "r":
          leftRotate(matrix, matrix, action[1]);
          break;
        case "m":
          leftMultiply(matrix, matrix, action[1]);
          break;
        default:
          break;
      }
    }
    return matrix;
  }
  function direction(v1, v2) {
    return v1[0] * v2[1] - v2[0] * v1[1];
  }
  function angleTo(v1, v2, direct) {
    var ang = vec2_exports.angle(v1, v2);
    var angleLargeThanPI = direction(v1, v2) >= 0;
    if (direct) {
      if (angleLargeThanPI) {
        return Math.PI * 2 - ang;
      }
      return ang;
    }
    if (angleLargeThanPI) {
      return ang;
    }
    return Math.PI * 2 - ang;
  }
  function vertical(out, v, flag) {
    if (flag) {
      out[0] = v[1];
      out[1] = -1 * v[0];
    } else {
      out[0] = -1 * v[1];
      out[1] = v[0];
    }
    return out;
  }

  // node_modules/@antv/g-base/esm/util/matrix.js
  function multiplyMatrix(a, b) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b00 = b[0];
    var b01 = b[1];
    var b02 = b[2];
    var b10 = b[3];
    var b11 = b[4];
    var b12 = b[5];
    var b20 = b[6];
    var b21 = b[7];
    var b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function multiplyVec2(m, v) {
    var out = [];
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function invert2(a) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }

  // node_modules/@antv/g-base/esm/abstract/element.js
  var transform2 = ext_exports.transform;
  var MATRIX = "matrix";
  var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
  var RESERVED_PORPS = ["repeat"];
  var DELEGATION_SPLIT = ":";
  var WILDCARD2 = "*";
  function _cloneArrayAttr(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
      if (is_array_default(arr[i])) {
        result.push([].concat(arr[i]));
      } else {
        result.push(arr[i]);
      }
    }
    return result;
  }
  function getFormatFromAttrs(toAttrs, shape) {
    var fromAttrs = {};
    var attrs = shape.attrs;
    for (var k in toAttrs) {
      fromAttrs[k] = attrs[k];
    }
    return fromAttrs;
  }
  function getFormatToAttrs(props, shape) {
    var toAttrs = {};
    var attrs = shape.attr();
    each_default(props, function(v, k) {
      if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
        toAttrs[k] = v;
      }
    });
    return toAttrs;
  }
  function checkExistedAttrs(animations, animation) {
    if (animation.onFrame) {
      return animations;
    }
    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
    var hasOwnProperty5 = Object.prototype.hasOwnProperty;
    each_default(animations, function(item) {
      if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
        each_default(animation.toAttrs, function(v, k) {
          if (hasOwnProperty5.call(item.toAttrs, k)) {
            delete item.toAttrs[k];
            delete item.fromAttrs[k];
          }
        });
      }
    });
    return animations;
  }
  var Element2 = function(_super) {
    __extends3(Element5, _super);
    function Element5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element5.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element5.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element5.prototype.onCanvasChange = function(changeType) {
    };
    Element5.prototype.initAttrs = function(attrs) {
    };
    Element5.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element5.prototype.isGroup = function() {
      return false;
    };
    Element5.prototype.getParent = function() {
      return this.get("parent");
    };
    Element5.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element5.prototype.attr = function() {
      var _a4;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a4 = {}, _a4[name] = value, _a4));
        return this;
      }
      return this.attrs[name];
    };
    Element5.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element5.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element5.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element5.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element5.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element5.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element5.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element5.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element5.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element5.prototype.setMatrix = function(m) {
      this.attr(MATRIX, m);
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element5.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element5.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element5.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2(matrix, v);
      }
      return v;
    };
    Element5.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert2(matrix);
        if (invertMatrix) {
          return multiplyVec2(invertMatrix, v);
        }
      }
      return v;
    };
    Element5.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase4 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase4[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element5.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element5.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone5 = new cons({ attrs });
      each_default(CLONE_CFGS, function(cfgName) {
        clone5.set(cfgName, _this.get(cfgName));
      });
      return clone5;
    };
    Element5.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element5.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element5.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a4 = args[2], easing = _a4 === void 0 ? "easeLinear" : _a4, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat = animateCfg.repeat || repeat || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element5.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element5.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element5.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element5.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element5.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD2]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element5.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element5.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element5.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtStart = function(rotate5) {
      var _a4 = this.attr(), x = _a4.x, y = _a4.y;
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtPoint = function(x, y, rotate5) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element5;
  }(base_default2);
  var element_default = Element2;

  // node_modules/@antv/g-base/esm/abstract/container.js
  var SHAPE_MAP = {};
  var INDEX = "_INDEX";
  function setCanvas(element, canvas) {
    element.set("canvas", canvas);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setCanvas(child, canvas);
        });
      }
    }
  }
  function setTimeline(element, timeline) {
    element.set("timeline", timeline);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setTimeline(child, timeline);
        });
      }
    }
  }
  function removeChild(container, element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (destroy) {
      element.destroy();
    } else {
      element.set("parent", null);
      element.set("canvas", null);
    }
    removeFromArray(container.getChildren(), element);
  }
  function getComparer(compare) {
    return function(left, right) {
      var result = compare(left, right);
      return result === 0 ? left[INDEX] - right[INDEX] : result;
    };
  }
  var Container = function(_super) {
    __extends3(Container3, _super);
    function Container3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container3.prototype.isCanvas = function() {
      return false;
    };
    Container3.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container3.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getCanvasBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container3.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container3.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container3.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP[cfg.type] = shapeType;
      }
      var ShapeBase4 = this.getShapeBase();
      var shape = new ShapeBase4[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container3.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group2;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group2 = new groupClass(cfg);
        } else {
          group2 = new groupClass({
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group2 = new TmpGroupClass(tmpCfg);
      }
      this.add(group2);
      return group2;
    };
    Container3.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container3.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container3.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container3.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container3.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container3.prototype.getChildren = function() {
      return this.get("children");
    };
    Container3.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index) {
        child[INDEX] = index;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container3.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container3.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container3.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container3.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container3.prototype.getChildByIndex = function(index) {
      var children = this.getChildren();
      return children[index];
    };
    Container3.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container3.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container3.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container3.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container3.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container3.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container3.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container3.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container3;
  }(element_default);
  var container_default = Container;

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0)
        t._call.call(null, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-ease/src/index.js
  var src_exports = {};
  __export(src_exports, {
    easeBack: () => backInOut,
    easeBackIn: () => backIn,
    easeBackInOut: () => backInOut,
    easeBackOut: () => backOut,
    easeBounce: () => bounceOut,
    easeBounceIn: () => bounceIn,
    easeBounceInOut: () => bounceInOut,
    easeBounceOut: () => bounceOut,
    easeCircle: () => circleInOut,
    easeCircleIn: () => circleIn,
    easeCircleInOut: () => circleInOut,
    easeCircleOut: () => circleOut,
    easeCubic: () => cubicInOut,
    easeCubicIn: () => cubicIn,
    easeCubicInOut: () => cubicInOut,
    easeCubicOut: () => cubicOut,
    easeElastic: () => elasticOut,
    easeElasticIn: () => elasticIn,
    easeElasticInOut: () => elasticInOut,
    easeElasticOut: () => elasticOut,
    easeExp: () => expInOut,
    easeExpIn: () => expIn,
    easeExpInOut: () => expInOut,
    easeExpOut: () => expOut,
    easeLinear: () => linear,
    easePoly: () => polyInOut,
    easePolyIn: () => polyIn,
    easePolyInOut: () => polyInOut,
    easePolyOut: () => polyOut,
    easeQuad: () => quadInOut,
    easeQuadIn: () => quadIn,
    easeQuadInOut: () => quadInOut,
    easeQuadOut: () => quadOut,
    easeSin: () => sinInOut,
    easeSinIn: () => sinIn,
    easeSinInOut: () => sinInOut,
    easeSinOut: () => sinOut
  });

  // node_modules/d3-ease/src/linear.js
  function linear(t) {
    return +t;
  }

  // node_modules/d3-ease/src/quad.js
  function quadIn(t) {
    return t * t;
  }
  function quadOut(t) {
    return t * (2 - t);
  }
  function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }

  // node_modules/d3-ease/src/cubic.js
  function cubicIn(t) {
    return t * t * t;
  }
  function cubicOut(t) {
    return --t * t * t + 1;
  }
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  // node_modules/d3-ease/src/poly.js
  var exponent = 3;
  var polyIn = function custom(e) {
    e = +e;
    function polyIn2(t) {
      return Math.pow(t, e);
    }
    polyIn2.exponent = custom;
    return polyIn2;
  }(exponent);
  var polyOut = function custom2(e) {
    e = +e;
    function polyOut2(t) {
      return 1 - Math.pow(1 - t, e);
    }
    polyOut2.exponent = custom2;
    return polyOut2;
  }(exponent);
  var polyInOut = function custom3(e) {
    e = +e;
    function polyInOut2(t) {
      return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }
    polyInOut2.exponent = custom3;
    return polyInOut2;
  }(exponent);

  // node_modules/d3-ease/src/sin.js
  var pi = Math.PI;
  var halfPi = pi / 2;
  function sinIn(t) {
    return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
  }
  function sinOut(t) {
    return Math.sin(t * halfPi);
  }
  function sinInOut(t) {
    return (1 - Math.cos(pi * t)) / 2;
  }

  // node_modules/d3-ease/src/math.js
  function tpmt(x) {
    return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
  }

  // node_modules/d3-ease/src/exp.js
  function expIn(t) {
    return tpmt(1 - +t);
  }
  function expOut(t) {
    return 1 - tpmt(t);
  }
  function expInOut(t) {
    return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
  }

  // node_modules/d3-ease/src/circle.js
  function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function circleOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }

  // node_modules/d3-ease/src/bounce.js
  var b1 = 4 / 11;
  var b2 = 6 / 11;
  var b3 = 8 / 11;
  var b4 = 3 / 4;
  var b5 = 9 / 11;
  var b6 = 10 / 11;
  var b7 = 15 / 16;
  var b8 = 21 / 22;
  var b9 = 63 / 64;
  var b0 = 1 / b1 / b1;
  function bounceIn(t) {
    return 1 - bounceOut(1 - t);
  }
  function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
  }
  function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
  }

  // node_modules/d3-ease/src/back.js
  var overshoot = 1.70158;
  var backIn = function custom4(s) {
    s = +s;
    function backIn2(t) {
      return (t = +t) * t * (s * (t - 1) + t);
    }
    backIn2.overshoot = custom4;
    return backIn2;
  }(overshoot);
  var backOut = function custom5(s) {
    s = +s;
    function backOut2(t) {
      return --t * t * ((t + 1) * s + t) + 1;
    }
    backOut2.overshoot = custom5;
    return backOut2;
  }(overshoot);
  var backInOut = function custom6(s) {
    s = +s;
    function backInOut2(t) {
      return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
    }
    backInOut2.overshoot = custom6;
    return backInOut2;
  }(overshoot);

  // node_modules/d3-ease/src/elastic.js
  var tau = 2 * Math.PI;
  var amplitude = 1;
  var period = 0.3;
  var elasticIn = function custom7(a, p2) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p2 /= tau);
    function elasticIn2(t) {
      return a * tpmt(- --t) * Math.sin((s - t) / p2);
    }
    elasticIn2.amplitude = function(a2) {
      return custom7(a2, p2 * tau);
    };
    elasticIn2.period = function(p3) {
      return custom7(a, p3);
    };
    return elasticIn2;
  }(amplitude, period);
  var elasticOut = function custom8(a, p2) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p2 /= tau);
    function elasticOut2(t) {
      return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p2);
    }
    elasticOut2.amplitude = function(a2) {
      return custom8(a2, p2 * tau);
    };
    elasticOut2.period = function(p3) {
      return custom8(a, p3);
    };
    return elasticOut2;
  }(amplitude, period);
  var elasticInOut = function custom9(a, p2) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p2 /= tau);
    function elasticInOut2(t) {
      return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p2) : 2 - a * tpmt(t) * Math.sin((s + t) / p2)) / 2;
    }
    elasticInOut2.amplitude = function(a2) {
      return custom9(a2, p2 * tau);
    };
    elasticInOut2.period = function(p3) {
      return custom9(a, p3);
    };
    return elasticInOut2;
  }(amplitude, period);

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend2(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
  var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
  var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
  var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
  var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
  var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend2(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }
  function rgb_formatRgb() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h2, s, l, a) {
    if (a <= 0)
      h2 = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h2 = s = NaN;
    else if (s <= 0)
      h2 = NaN;
    return new Hsl(h2, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min3 = Math.min(r, g, b), max3 = Math.max(r, g, b), h2 = NaN, s = max3 - min3, l = (max3 + min3) / 2;
    if (s) {
      if (r === max3)
        h2 = (g - b) / s + (g < b) * 6;
      else if (g === max3)
        h2 = (b - r) / s + 2;
      else
        h2 = (r - g) / s + 4;
      s /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
      h2 *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h2;
    }
    return new Hsl(h2, s, l, o.opacity);
  }
  function hsl(h2, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s, l, opacity) {
    this.h = +h2;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend2(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
    }
  }));
  function hsl2rgb(h2, m1, m2) {
    return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values2) {
    var n = values2.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values2) {
    var n = values2.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  function constant_default(x) {
    return function() {
      return x;
    };
  }

  // node_modules/d3-interpolate/src/color.js
  function linear2(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear2(a, d) : constant_default(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y) {
    var color2 = gamma(y);
    function rgb2(start, end) {
      var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i)
        c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function array_default(a, b) {
    return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
  }
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i)
        c[i] = x[i](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = new Date();
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i)
        c[k] = i[k](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero3(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero3(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/@antv/g-base/esm/util/color.js
  var isColorProp = function(prop) {
    return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
  };
  var isGradientColor = function(val) {
    return /^[r,R,L,l]{1}[\s]*\(/.test(val);
  };

  // node_modules/@antv/g-base/esm/animate/timeline.js
  var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  function _update(shape, animation, ratio) {
    var cProps = {};
    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
    if (shape.destroyed) {
      return;
    }
    var interf;
    for (var k in toAttrs) {
      if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
        if (k === "path") {
          var toPath = toAttrs[k];
          var fromPath = fromAttrs[k];
          if (toPath.length > fromPath.length) {
            toPath = parsePathString(toAttrs[k]);
            fromPath = parsePathString(fromAttrs[k]);
            fromPath = fillPathByDiff(fromPath, toPath);
            fromPath = formatPath(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
          } else if (!animation.pathFormatted) {
            toPath = parsePathString(toAttrs[k]);
            fromPath = parsePathString(fromAttrs[k]);
            fromPath = formatPath(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
            animation.pathFormatted = true;
          }
          cProps[k] = [];
          for (var i = 0; i < toPath.length; i++) {
            var toPathPoint = toPath[i];
            var fromPathPoint = fromPath[i];
            var cPathPoint = [];
            for (var j = 0; j < toPathPoint.length; j++) {
              if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
                interf = value_default(fromPathPoint[j], toPathPoint[j]);
                cPathPoint.push(interf(ratio));
              } else {
                cPathPoint.push(toPathPoint[j]);
              }
            }
            cProps[k].push(cPathPoint);
          }
        } else if (k === "matrix") {
          var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
          var currentMatrix = matrixFn(ratio);
          cProps[k] = currentMatrix;
        } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
          cProps[k] = toAttrs[k];
        } else if (!is_function_default(toAttrs[k])) {
          interf = value_default(fromAttrs[k], toAttrs[k]);
          cProps[k] = interf(ratio);
        }
      }
    }
    shape.attr(cProps);
  }
  function update(shape, animation, elapsed) {
    var startTime = animation.startTime, delay = animation.delay;
    if (elapsed < startTime + delay || animation._paused) {
      return false;
    }
    var ratio;
    var duration = animation.duration;
    var easing = animation.easing;
    elapsed = elapsed - startTime - animation.delay;
    if (animation.repeat) {
      ratio = elapsed % duration / duration;
      ratio = src_exports[easing](ratio);
    } else {
      ratio = elapsed / duration;
      if (ratio < 1) {
        ratio = src_exports[easing](ratio);
      } else {
        if (animation.onFrame) {
          shape.attr(animation.onFrame(1));
        } else {
          shape.attr(animation.toAttrs);
        }
        return true;
      }
    }
    if (animation.onFrame) {
      var attrs = animation.onFrame(ratio);
      shape.attr(attrs);
    } else {
      _update(shape, animation, ratio);
    }
    return false;
  }
  var Timeline = function() {
    function Timeline3(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline3.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation = animations[j];
                isFinished = update(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline3.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline3.prototype.removeAnimator = function(index) {
      this.animators.splice(index, 1);
    };
    Timeline3.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline3.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline3.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline3.prototype.getTime = function() {
      return this.current;
    };
    return Timeline3;
  }();
  var timeline_default = Timeline;

  // node_modules/@antv/g-base/esm/event/event-contoller.js
  var CLICK_OFFSET = 40;
  var LEFT_BTN_CODE = 0;
  var EVENTS = [
    "mousedown",
    "mouseup",
    "dblclick",
    "mouseout",
    "mouseover",
    "mousemove",
    "mouseleave",
    "mouseenter",
    "touchstart",
    "touchmove",
    "touchend",
    "dragenter",
    "dragover",
    "dragleave",
    "drop",
    "contextmenu",
    "mousewheel"
  ];
  function emitTargetEvent(target, type, eventObj) {
    eventObj.name = type;
    eventObj.target = target;
    eventObj.currentTarget = target;
    eventObj.delegateTarget = target;
    target.emit(type, eventObj);
  }
  function bubbleEvent(container, type, eventObj) {
    if (eventObj.bubbles) {
      var relativeShape = void 0;
      var isOverEvent = false;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
        isOverEvent = true;
      } else if (type === "mouseleave") {
        isOverEvent = true;
        relativeShape = eventObj.toShape;
      }
      if (container.isCanvas() && isOverEvent) {
        return;
      }
      if (relativeShape && isParent(container, relativeShape)) {
        eventObj.bubbles = false;
        return;
      }
      eventObj.name = type;
      eventObj.currentTarget = container;
      eventObj.delegateTarget = container;
      container.emit(type, eventObj);
    }
  }
  var EventController = function() {
    function EventController3(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController3.prototype.init = function() {
      this._bindEvents();
    };
    EventController3.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
      var eventObj = new graph_event_default(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point.x;
      eventObj.y = point.y;
      eventObj.clientX = point.clientX;
      eventObj.clientY = point.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController3.prototype._getShape = function(point, ev) {
      return this.canvas.getShape(point.x, point.y, ev);
    };
    EventController3.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point = canvas.getPointByEvent(ev);
      return {
        x: point.x,
        y: point.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController3.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController3.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController3.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController3.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController3.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController3.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController3.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController3.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now2 = event.timeStamp;
          var timeWindow = now2 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist3 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist3 > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController3.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController3.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController3;
  }();
  var event_contoller_default = EventController;

  // node_modules/@antv/g-base/esm/abstract/canvas.js
  var PX_SUFFIX = "px";
  var browser = detect();
  var isFirefox = browser && browser.name === "firefox";
  var Canvas = function(_super) {
    __extends3(Canvas5, _super);
    function Canvas5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas5.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas5.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas5.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas5.prototype.initEvents = function() {
      var eventController = new event_contoller_default({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas5.prototype.initTimeline = function() {
      var timeline = new timeline_default(this);
      this.set("timeline", timeline);
    };
    Canvas5.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas5.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas5.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas5.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas5.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas5.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a4 = this.getClientByEvent(ev), clientX = _a4.x, clientY = _a4.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas5.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas5.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas5.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas5.prototype.draw = function() {
    };
    Canvas5.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas5.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas5.prototype.isCanvas = function() {
      return true;
    };
    Canvas5.prototype.getParent = function() {
      return null;
    };
    Canvas5.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas5;
  }(container_default);
  var canvas_default = Canvas;

  // node_modules/@antv/g-base/esm/abstract/group.js
  var AbstractGroup = function(_super) {
    __extends3(AbstractGroup3, _super);
    function AbstractGroup3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup3.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup3.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup3.prototype.clone = function() {
      var clone5 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone5.add(child.clone());
      }
      return clone5;
    };
    return AbstractGroup3;
  }(container_default);
  var group_default2 = AbstractGroup;

  // node_modules/@antv/g-base/esm/abstract/shape.js
  var AbstractShape = function(_super) {
    __extends3(AbstractShape3, _super);
    function AbstractShape3(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape3.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape3.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape3.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape3.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a4 = attrs.shadowBlur, shadowBlur = _a4 === void 0 ? 0 : _a4, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape3.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape3.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape3.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape3.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape3;
  }(element_default);
  var shape_default = AbstractShape;

  // node_modules/@antv/g-base/esm/bbox/register.js
  var cache = new Map();
  function register(type, method) {
    cache.set(type, method);
  }
  function getMethod(type) {
    return cache.get(type);
  }

  // node_modules/@antv/g-base/esm/bbox/rect.js
  function rect_default(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
    return {
      x,
      y,
      width,
      height
    };
  }

  // node_modules/@antv/g-base/esm/bbox/circle.js
  function circle_default(shape) {
    var _a4 = shape.attr(), x = _a4.x, y = _a4.y, r = _a4.r;
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  }

  // node_modules/@antv/g-math/esm/util.js
  var util_exports = {};
  __export(util_exports, {
    distance: () => distance3,
    getBBoxByArray: () => getBBoxByArray,
    getBBoxRange: () => getBBoxRange,
    isNumberEqual: () => isNumberEqual2,
    piMod: () => piMod
  });
  function minNum(array) {
    return Math.min.apply(null, array);
  }
  function maxNum(array) {
    return Math.max.apply(null, array);
  }
  function distance3(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function isNumberEqual2(v1, v2) {
    return Math.abs(v1 - v2) < 1e-3;
  }
  function getBBoxByArray(xArr, yArr) {
    var minX = minNum(xArr);
    var minY = minNum(yArr);
    var maxX = maxNum(xArr);
    var maxY = maxNum(yArr);
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getBBoxRange(x1, y1, x2, y2) {
    return {
      minX: minNum([x1, x2]),
      maxX: maxNum([x1, x2]),
      minY: minNum([y1, y2]),
      maxY: maxNum([y1, y2])
    };
  }
  function piMod(angle3) {
    return (angle3 + Math.PI * 2) % (Math.PI * 2);
  }

  // node_modules/@antv/g-math/esm/line.js
  var line_default = {
    box: function(x1, y1, x2, y2) {
      return getBBoxByArray([x1, x2], [y1, y2]);
    },
    length: function(x1, y1, x2, y2) {
      return distance3(x1, y1, x2, y2);
    },
    pointAt: function(x1, y1, x2, y2, t) {
      return {
        x: (1 - t) * x1 + t * x2,
        y: (1 - t) * y1 + t * y2
      };
    },
    pointDistance: function(x1, y1, x2, y2, x, y) {
      var cross3 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
      if (cross3 < 0) {
        return distance3(x1, y1, x, y);
      }
      var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (cross3 > lengthSquare) {
        return distance3(x2, y2, x, y);
      }
      return this.pointToLine(x1, y1, x2, y2, x, y);
    },
    pointToLine: function(x1, y1, x2, y2, x, y) {
      var d = [x2 - x1, y2 - y1];
      if (exactEquals3(d, [0, 0])) {
        return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      }
      var u = [-d[1], d[0]];
      normalize2(u, u);
      var a = [x - x1, y - y1];
      return Math.abs(dot2(a, u));
    },
    tangentAngle: function(x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1);
    }
  };

  // node_modules/@antv/g-math/esm/bezier.js
  var EPSILON2 = 1e-4;
  function nearestPoint(xArr, yArr, x, y, tCallback, length3) {
    var t;
    var d = Infinity;
    var v0 = [x, y];
    var segNum = 20;
    if (length3 && length3 > 200) {
      segNum = length3 / 10;
    }
    var increaseRate = 1 / segNum;
    var interval2 = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
      var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count = xArr.length;
      return {
        x: xArr[count - 1],
        y: yArr[count - 1]
      };
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval2 < EPSILON2) {
        break;
      }
      var prev = t - interval2;
      var next = t + interval2;
      var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
      var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
        var d2 = distance3(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval2 *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(null, xArr.concat([t])),
      y: tCallback.apply(null, yArr.concat([t]))
    };
  }
  function snapLength(xArr, yArr) {
    var totalLength = 0;
    var count = xArr.length;
    for (var i = 0; i < count; i++) {
      var x = xArr[i];
      var y = yArr[i];
      var nextX = xArr[(i + 1) % count];
      var nextY = yArr[(i + 1) % count];
      totalLength += distance3(x, y, nextX, nextY);
    }
    return totalLength / 2;
  }

  // node_modules/@antv/g-math/esm/quadratic.js
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  function extrema(p0, p1, p2) {
    var a = p0 + p2 - 2 * p1;
    if (isNumberEqual2(a, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function derivativeAt(p0, p1, p2, t) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
  }
  function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
    var xt = quadraticAt(x1, x2, x3, t);
    var yt = quadraticAt(y1, y2, y3, t);
    var controlPoint1 = line_default.pointAt(x1, y1, x2, y2, t);
    var controlPoint2 = line_default.pointAt(x2, y2, x3, y3, t);
    return [
      [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
      [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
    ];
  }
  function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
    if (iterationCount === 0) {
      return (distance3(x1, y1, x2, y2) + distance3(x2, y2, x3, y3) + distance3(x1, y1, x3, y3)) / 2;
    }
    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
    var left = quadratics[0];
    var right = quadratics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
  }
  var quadratic_default = {
    box: function(x1, y1, x2, y2, x3, y3) {
      var xExtrema2 = extrema(x1, x2, x3)[0];
      var yExtrema2 = extrema(y1, y2, y3)[0];
      var xArr = [x1, x3];
      var yArr = [y1, y3];
      if (xExtrema2 !== void 0) {
        xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
      }
      if (yExtrema2 !== void 0) {
        yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function(x1, y1, x2, y2, x3, y3) {
      return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
    },
    nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
      return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
    },
    pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
      return distance3(point.x, point.y, x0, y0);
    },
    interpolationAt: quadraticAt,
    pointAt: function(x1, y1, x2, y2, x3, y3, t) {
      return {
        x: quadraticAt(x1, x2, x3, t),
        y: quadraticAt(y1, y2, y3, t)
      };
    },
    divide: function(x1, y1, x2, y2, x3, y3, t) {
      return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
    },
    tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
      var dx = derivativeAt(x1, x2, x3, t);
      var dy = derivativeAt(y1, y2, y3, t);
      var angle3 = Math.atan2(dy, dx);
      return piMod(angle3);
    }
  };

  // node_modules/@antv/g-math/esm/cubic.js
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function derivativeAt2(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
  }
  function extrema2(p0, p1, p2, p3) {
    var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual2(a, 0)) {
      if (!isNumberEqual2(b, 0)) {
        t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isNumberEqual2(disc, 0)) {
        extremas.push(-b / (2 * a));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a);
        t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var xt = cubicAt(x1, x2, x3, x4, t);
    var yt = cubicAt(y1, y2, y3, y4, t);
    var c1 = line_default.pointAt(x1, y1, x2, y2, t);
    var c2 = line_default.pointAt(x2, y2, x3, y3, t);
    var c3 = line_default.pointAt(x3, y3, x4, y4, t);
    var c12 = line_default.pointAt(c1.x, c1.y, c2.x, c2.y, t);
    var c23 = line_default.pointAt(c2.x, c2.y, c3.x, c3.y, t);
    return [
      [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
      [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
    ];
  }
  function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
    if (iterationCount === 0) {
      return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
    }
    var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
    var left = cubics[0];
    var right = cubics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return cubicLength.apply(null, left) + cubicLength.apply(null, right);
  }
  var cubic_default = {
    extrema: extrema2,
    box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      var xArr = [x1, x4];
      var yArr = [y1, y4];
      var xExtrema2 = extrema2(x1, x2, x3, x4);
      var yExtrema2 = extrema2(y1, y2, y3, y4);
      for (var i = 0; i < xExtrema2.length; i++) {
        xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
      }
      for (var i = 0; i < yExtrema2.length; i++) {
        yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
    },
    nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3) {
      return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length3);
    },
    pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3);
      return distance3(point.x, point.y, x0, y0);
    },
    interpolationAt: cubicAt,
    pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return {
        x: cubicAt(x1, x2, x3, x4, t),
        y: cubicAt(y1, y2, y3, y4, t)
      };
    },
    divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
    },
    tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      var dx = derivativeAt2(x1, x2, x3, x4, t);
      var dy = derivativeAt2(y1, y2, y3, y4, t);
      return piMod(Math.atan2(dy, dx));
    }
  };

  // node_modules/@antv/g-math/esm/ellipse.js
  function copysign(v1, v2) {
    var absv = Math.abs(v1);
    return v2 > 0 ? absv : absv * -1;
  }
  var ellipse_default = {
    box: function(x, y, rx, ry) {
      return {
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2
      };
    },
    length: function(x, y, rx, ry) {
      return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
    },
    nearestPoint: function(x, y, rx, ry, x0, y0) {
      var a = rx;
      var b = ry;
      if (a === 0 || b === 0) {
        return {
          x,
          y
        };
      }
      var relativeX = x0 - x;
      var relativeY = y0 - y;
      var px = Math.abs(relativeX);
      var py = Math.abs(relativeY);
      var squareA = a * a;
      var squareB = b * b;
      var t = Math.PI / 4;
      var nearestX;
      var nearestY;
      for (var i = 0; i < 4; i++) {
        nearestX = a * Math.cos(t);
        nearestY = b * Math.sin(t);
        var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
        var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
        var rx1 = nearestX - ex;
        var ry1 = nearestY - ey;
        var qx = px - ex;
        var qy = py - ey;
        var r = Math.hypot(ry1, rx1);
        var q = Math.hypot(qy, qx);
        var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
        var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
        t += delta_t;
        t = Math.min(Math.PI / 2, Math.max(0, t));
      }
      return {
        x: x + copysign(nearestX, relativeX),
        y: y + copysign(nearestY, relativeY)
      };
    },
    pointDistance: function(x, y, rx, ry, x0, y0) {
      var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
      return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
    },
    pointAt: function(x, y, rx, ry, t) {
      var angle3 = 2 * Math.PI * t;
      return {
        x: x + rx * Math.cos(angle3),
        y: y + ry * Math.sin(angle3)
      };
    },
    tangentAngle: function(x, y, rx, ry, t) {
      var angle3 = 2 * Math.PI * t;
      var tangentAngle = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
      return piMod(tangentAngle);
    }
  };

  // node_modules/@antv/g-math/esm/arc.js
  function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
    return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
  }
  function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
    return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
  }
  function xExtrema(rx, ry, xRotation) {
    return Math.atan(-ry / rx * Math.tan(xRotation));
  }
  function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
  }
  function xAt(cx, cy, rx, ry, xRotation, angle3) {
    return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
  }
  function yAt(cx, cy, rx, ry, xRotation, angle3) {
    return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
  }
  function getAngle(rx, ry, x0, y0) {
    var angle3 = Math.atan2(y0 * rx, x0 * ry);
    return (angle3 + Math.PI * 2) % (Math.PI * 2);
  }
  function getPoint(rx, ry, angle3) {
    return {
      x: rx * Math.cos(angle3),
      y: ry * Math.sin(angle3)
    };
  }
  function rotate3(x, y, angle3) {
    var cos2 = Math.cos(angle3);
    var sin2 = Math.sin(angle3);
    return [x * cos2 - y * sin2, x * sin2 + y * cos2];
  }
  var arc_default = {
    box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
      var xDim = xExtrema(rx, ry, xRotation);
      var minX = Infinity;
      var maxX = -Infinity;
      var xs = [startAngle, endAngle];
      for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
        var xAngle = xDim + i;
        if (startAngle < endAngle) {
          if (startAngle < xAngle && xAngle < endAngle) {
            xs.push(xAngle);
          }
        } else {
          if (endAngle < xAngle && xAngle < startAngle) {
            xs.push(xAngle);
          }
        }
      }
      for (var i = 0; i < xs.length; i++) {
        var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
        if (x < minX) {
          minX = x;
        }
        if (x > maxX) {
          maxX = x;
        }
      }
      var yDim = yExtrema(rx, ry, xRotation);
      var minY = Infinity;
      var maxY = -Infinity;
      var ys = [startAngle, endAngle];
      for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
        var yAngle = yDim + i;
        if (startAngle < endAngle) {
          if (startAngle < yAngle && yAngle < endAngle) {
            ys.push(yAngle);
          }
        } else {
          if (endAngle < yAngle && yAngle < startAngle) {
            ys.push(yAngle);
          }
        }
      }
      for (var i = 0; i < ys.length; i++) {
        var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
        if (y < minY) {
          minY = y;
        }
        if (y > maxY) {
          maxY = y;
        }
      }
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    },
    nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
      var relativeVector = rotate3(x0 - cx, y0 - cy, -xRotation);
      var x1 = relativeVector[0], y1 = relativeVector[1];
      var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
      var angle3 = getAngle(rx, ry, relativePoint.x, relativePoint.y);
      if (angle3 < startAngle) {
        relativePoint = getPoint(rx, ry, startAngle);
      } else if (angle3 > endAngle) {
        relativePoint = getPoint(rx, ry, endAngle);
      }
      var vector = rotate3(relativePoint.x, relativePoint.y, xRotation);
      return {
        x: vector[0] + cx,
        y: vector[1] + cy
      };
    },
    pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
      var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
      return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
    },
    pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
      var angle3 = (endAngle - startAngle) * t + startAngle;
      return {
        x: xAt(cx, cy, rx, ry, xRotation, angle3),
        y: yAt(cx, cy, rx, ry, xRotation, angle3)
      };
    },
    tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
      var angle3 = (endAngle - startAngle) * t + startAngle;
      var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
      var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
      return piMod(Math.atan2(dy, dx));
    }
  };

  // node_modules/@antv/g-math/esm/segments.js
  function analyzePoints(points) {
    var totalLength = 0;
    var segments = [];
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      var length_1 = distance3(from[0], from[1], to[0], to[1]);
      var seg = {
        from,
        to,
        length: length_1
      };
      segments.push(seg);
      totalLength += length_1;
    }
    return { segments, totalLength };
  }
  function lengthOfSegment(points) {
    if (points.length < 2) {
      return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      totalLength += distance3(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
  }
  function pointAtSegments(points, t) {
    if (t > 1 || t < 0 || points.length < 2) {
      return null;
    }
    var _a4 = analyzePoints(points), segments = _a4.segments, totalLength = _a4.totalLength;
    if (totalLength === 0) {
      return {
        x: points[0][0],
        y: points[0][1]
      };
    }
    var startRatio = 0;
    var point = null;
    for (var i = 0; i < segments.length; i++) {
      var seg = segments[i];
      var from = seg.from, to = seg.to;
      var currentRatio = seg.length / totalLength;
      if (t >= startRatio && t <= startRatio + currentRatio) {
        var localRatio = (t - startRatio) / currentRatio;
        point = line_default.pointAt(from[0], from[1], to[0], to[1], localRatio);
        break;
      }
      startRatio += currentRatio;
    }
    return point;
  }
  function angleAtSegments(points, t) {
    if (t > 1 || t < 0 || points.length < 2) {
      return 0;
    }
    var _a4 = analyzePoints(points), segments = _a4.segments, totalLength = _a4.totalLength;
    var startRatio = 0;
    var angle3 = 0;
    for (var i = 0; i < segments.length; i++) {
      var seg = segments[i];
      var from = seg.from, to = seg.to;
      var currentRatio = seg.length / totalLength;
      if (t >= startRatio && t <= startRatio + currentRatio) {
        angle3 = Math.atan2(to[1] - from[1], to[0] - from[0]);
        break;
      }
      startRatio += currentRatio;
    }
    return angle3;
  }
  function distanceAtSegment(points, x, y) {
    var minDistance = Infinity;
    for (var i = 0; i < points.length - 1; i++) {
      var point = points[i];
      var nextPoint = points[i + 1];
      var distance_1 = line_default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
      if (distance_1 < minDistance) {
        minDistance = distance_1;
      }
    }
    return minDistance;
  }

  // node_modules/@antv/g-math/esm/polyline.js
  var polyline_default = {
    box: function(points) {
      var xArr = [];
      var yArr = [];
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        xArr.push(point[0]);
        yArr.push(point[1]);
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function(points) {
      return lengthOfSegment(points);
    },
    pointAt: function(points, t) {
      return pointAtSegments(points, t);
    },
    pointDistance: function(points, x, y) {
      return distanceAtSegment(points, x, y);
    },
    tangentAngle: function(points, t) {
      return angleAtSegments(points, t);
    }
  };

  // node_modules/@antv/g-base/esm/bbox/util.js
  function mergeBBox(bbox1, bbox2) {
    if (!bbox1 || !bbox2) {
      return bbox1 || bbox2;
    }
    return {
      minX: Math.min(bbox1.minX, bbox2.minX),
      minY: Math.min(bbox1.minY, bbox2.minY),
      maxX: Math.max(bbox1.maxX, bbox2.maxX),
      maxY: Math.max(bbox1.maxY, bbox2.maxY)
    };
  }
  function mergeArrowBBox(shape, bbox) {
    var startArrowShape = shape.get("startArrowShape");
    var endArrowShape = shape.get("endArrowShape");
    var startArrowBBox = null;
    var endArrowBBox = null;
    if (startArrowShape) {
      startArrowBBox = startArrowShape.getCanvasBBox();
      bbox = mergeBBox(bbox, startArrowBBox);
    }
    if (endArrowShape) {
      endArrowBBox = endArrowShape.getCanvasBBox();
      bbox = mergeBBox(bbox, endArrowBBox);
    }
    return bbox;
  }

  // node_modules/@antv/g-base/esm/bbox/polyline.js
  function polyline_default2(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    var _a4 = util_exports.getBBoxByArray(xArr, yArr), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/g-base/esm/bbox/polygon.js
  function polygon_default2(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return util_exports.getBBoxByArray(xArr, yArr);
  }

  // node_modules/@antv/g-base/esm/util/offscreen.js
  var offScreenCtx = null;
  function getOffScreenContext() {
    if (!offScreenCtx) {
      var canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      offScreenCtx = canvas.getContext("2d");
    }
    return offScreenCtx;
  }

  // node_modules/@antv/g-base/esm/util/text.js
  function getTextHeight(text, fontSize, lineHeight) {
    var lineCount = 1;
    if (is_string_default(text)) {
      lineCount = text.split("\n").length;
    }
    if (lineCount > 1) {
      var spaceingY = getLineSpaceing(fontSize, lineHeight);
      return fontSize * lineCount + spaceingY * (lineCount - 1);
    }
    return fontSize;
  }
  function getLineSpaceing(fontSize, lineHeight) {
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  }
  function getTextWidth(text, font) {
    var context = getOffScreenContext();
    var width = 0;
    if (is_nil_default(text) || text === "") {
      return width;
    }
    context.save();
    context.font = font;
    if (is_string_default(text) && text.includes("\n")) {
      var textArr = text.split("\n");
      each_default(textArr, function(subText) {
        var measureWidth = context.measureText(subText).width;
        if (width < measureWidth) {
          width = measureWidth;
        }
      });
    } else {
      width = context.measureText(text).width;
    }
    context.restore();
    return width;
  }
  function assembleFont(attrs) {
    var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
    return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
  }

  // node_modules/@antv/g-base/esm/bbox/text.js
  function text_default(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
    var font = attrs.font;
    if (!font) {
      font = assembleFont(attrs);
    }
    var width = getTextWidth(text, font);
    var bbox;
    if (!width) {
      bbox = {
        x,
        y,
        width: 0,
        height: 0
      };
    } else {
      var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
      var height = getTextHeight(text, fontSize, lineHeight);
      var point = {
        x,
        y: y - height
      };
      if (textAlign) {
        if (textAlign === "end" || textAlign === "right") {
          point.x -= width;
        } else if (textAlign === "center") {
          point.x -= width / 2;
        }
      }
      if (textBaseline) {
        if (textBaseline === "top") {
          point.y += height;
        } else if (textBaseline === "middle") {
          point.y += height / 2;
        }
      }
      bbox = {
        x: point.x,
        y: point.y,
        width,
        height
      };
    }
    return bbox;
  }

  // node_modules/@antv/path-util/esm/parse-path.js
  var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
  var regexDot = /[^\s\,]+/ig;
  function parsePath(p2) {
    var path = p2 || [];
    if (is_array_default(path)) {
      return path;
    }
    if (is_string_default(path)) {
      path = path.match(regexTags);
      each_default(path, function(item, index) {
        item = item.match(regexDot);
        if (item[0].length > 1) {
          var tag = item[0].charAt(0);
          item.splice(1, 0, item[0].substr(1));
          item[0] = tag;
        }
        each_default(item, function(sub4, i) {
          if (!isNaN(sub4)) {
            item[i] = +sub4;
          }
        });
        path[index] = item;
      });
      return path;
    }
  }
  var parse_path_default = parsePath;

  // node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
  function smoothBezier(points, smooth, isLoop, constraint) {
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min3;
    var max3;
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      min3 = constraint[0], max3 = constraint[1];
      for (var i = 0, l = points.length; i < l; i += 1) {
        var point = points[i];
        min3 = vec2_exports.min([0, 0], min3, point);
        max3 = vec2_exports.max([0, 0], max3, point);
      }
    }
    for (var i = 0, len3 = points.length; i < len3; i += 1) {
      var point = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point;
      } else if (i === len3 - 1 && !isLoop) {
        cp1 = point;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        var prevIdx = [i ? i - 1 : len3 - 1, i - 1][isLoop ? 0 : 1];
        prevPoint = points[prevIdx];
        nextPoint = points[isLoop ? (i + 1) % len3 : i + 1];
        var v = [0, 0];
        v = vec2_exports.sub(v, nextPoint, prevPoint);
        v = vec2_exports.scale(v, v, smooth);
        var d0 = vec2_exports.distance(point, prevPoint);
        var d1 = vec2_exports.distance(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }
        var v1 = vec2_exports.scale([0, 0], v, -d0);
        var v2 = vec2_exports.scale([0, 0], v, d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
        nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
        v1 = vec2_exports.sub([0, 0], nextCp0, point);
        v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
        cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
        v2 = vec2_exports.sub([0, 0], point, cp1);
        v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        if (hasConstraint) {
          cp1 = vec2_exports.max([0, 0], cp1, min3);
          cp1 = vec2_exports.min([0, 0], cp1, max3);
          nextCp0 = vec2_exports.max([0, 0], nextCp0, min3);
          nextCp0 = vec2_exports.min([0, 0], nextCp0, max3);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function catmullRom2Bezier(crp, z, constraint) {
    if (z === void 0) {
      z = false;
    }
    if (constraint === void 0) {
      constraint = [
        [0, 0],
        [1, 1]
      ];
    }
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len3 = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p2;
    for (var i = 0; i < len3 - 1; i += 1) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p2 = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len3];
      cp2 = controlPointList[len3 + 1];
      p2 = pointList[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    return d1;
  }
  var catmull_rom_2_bezier_default = catmullRom2Bezier;

  // node_modules/@antv/path-util/esm/parse-path-string.js
  var SPACES2 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
  var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
  var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
  function parsePathString2(pathString) {
    if (!pathString) {
      return null;
    }
    if (is_array_default(pathString)) {
      return pathString;
    }
    var paramCounts = {
      a: 7,
      c: 6,
      o: 2,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      u: 3,
      z: 0
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND2, function(a, b, c) {
      var params = [];
      var name = b.toLowerCase();
      c.replace(PATH_VALUES2, function(a2, b10) {
        b10 && params.push(+b10);
      });
      if (name === "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = "l";
        b = b === "m" ? "l" : "L";
      }
      if (name === "o" && params.length === 1) {
        data.push([b, params[0]]);
      }
      if (name === "r") {
        data.push([b].concat(params));
      } else {
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      }
      return "";
    });
    return data;
  }

  // node_modules/@antv/path-util/esm/path-2-absolute.js
  var REGEX_MD = /[a-z]/;
  function toSymmetry(p2, c) {
    return [
      c[0] + (c[0] - p2[0]),
      c[1] + (c[1] - p2[1])
    ];
  }
  function pathToAbsolute2(pathString) {
    var pathArray = parsePathString2(pathString);
    if (!pathArray || !pathArray.length) {
      return [
        ["M", 0, 0]
      ];
    }
    var needProcess = false;
    for (var i = 0; i < pathArray.length; i++) {
      var cmd = pathArray[i][0];
      if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
        needProcess = true;
        break;
      }
    }
    if (!needProcess) {
      return pathArray;
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    var first = pathArray[0];
    if (first[0] === "M" || first[0] === "m") {
      x = +first[1];
      y = +first[2];
      mx = x;
      my = y;
      start++;
      res[0] = ["M", x, y];
    }
    for (var i = start, ii = pathArray.length; i < ii; i++) {
      var pa = pathArray[i];
      var preParams = res[i - 1];
      var r = [];
      var cmd = pa[0];
      var upCmd = cmd.toUpperCase();
      if (cmd !== upCmd) {
        r[0] = upCmd;
        switch (upCmd) {
          case "A":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case "V":
            r[1] = +pa[1] + y;
            break;
          case "H":
            r[1] = +pa[1] + x;
            break;
          case "M":
            mx = +pa[1] + x;
            my = +pa[2] + y;
            r[1] = mx;
            r[2] = my;
            break;
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else {
        r = pathArray[i];
      }
      switch (upCmd) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          r = ["L", x, y];
          break;
        case "V":
          y = r[1];
          r = ["L", x, y];
          break;
        case "T":
          x = r[1];
          y = r[2];
          var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
          r = ["Q", symetricT[0], symetricT[1], x, y];
          break;
        case "S":
          x = r[r.length - 2];
          y = r[r.length - 1];
          var length_1 = preParams.length;
          var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
          r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
      res.push(r);
    }
    return res;
  }

  // node_modules/@antv/path-util/esm/process/arc-2-cubic.js
  var TAU = Math.PI * 2;

  // node_modules/@antv/path-util/esm/get-arc-params.js
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function isSamePoint(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
  }
  function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    var x2 = params[6];
    var y2 = params[7];
    var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
    var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle([1, 0], u);
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return {
      cx,
      cy,
      rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
      ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }

  // node_modules/@antv/path-util/esm/path-2-segments.js
  function toSymmetry2(point, center) {
    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
  }
  function getSegments(path) {
    path = parse_path_default(path);
    var segments = [];
    var currentPoint = null;
    var nextParams = null;
    var startMovePoint = null;
    var lastStartMovePointIndex = 0;
    var count = path.length;
    for (var i = 0; i < count; i++) {
      var params = path[i];
      nextParams = path[i + 1];
      var command = params[0];
      var segment = {
        command,
        prePoint: currentPoint,
        params,
        startTangent: null,
        endTangent: null
      };
      switch (command) {
        case "M":
          startMovePoint = [params[1], params[2]];
          lastStartMovePointIndex = i;
          break;
        case "A":
          var arcParams = getArcParams(currentPoint, params);
          segment["arcParams"] = arcParams;
          break;
        default:
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
        nextParams = path[lastStartMovePointIndex + 1];
      } else {
        var len3 = params.length;
        currentPoint = [params[len3 - 2], params[len3 - 1]];
      }
      if (nextParams && nextParams[0] === "Z") {
        nextParams = path[lastStartMovePointIndex];
        if (segments[lastStartMovePointIndex]) {
          segments[lastStartMovePointIndex].prePoint = currentPoint;
        }
      }
      segment["currentPoint"] = currentPoint;
      if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
        segments[lastStartMovePointIndex].prePoint = segment.prePoint;
      }
      var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
      segment["nextPoint"] = nextPoint;
      var prePoint = segment.prePoint;
      if (["L", "H", "V"].includes(command)) {
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      } else if (command === "Q") {
        var cp = [params[1], params[2]];
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else if (command === "T") {
        var preSegment = segments[i - 1];
        var cp = toSymmetry2(preSegment.currentPoint, prePoint);
        if (preSegment.command === "Q") {
          segment.command = "Q";
          segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
          segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
        } else {
          segment.command = "TL";
          segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
          segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
        }
      } else if (command === "C") {
        var cp1 = [params[1], params[2]];
        var cp2 = [params[3], params[4]];
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
          segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        }
        if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
          segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
        }
      } else if (command === "S") {
        var preSegment = segments[i - 1];
        var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
        var cp2 = [params[1], params[2]];
        if (preSegment.command === "C") {
          segment.command = "C";
          segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
          segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        } else {
          segment.command = "SQ";
          segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
          segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        }
      } else if (command === "A") {
        var d = 1e-3;
        var _a4 = segment["arcParams"] || {}, _b = _a4.cx, cx = _b === void 0 ? 0 : _b, _c = _a4.cy, cy = _c === void 0 ? 0 : _c, _d = _a4.rx, rx = _d === void 0 ? 0 : _d, _e = _a4.ry, ry = _e === void 0 ? 0 : _e, _f = _a4.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a4.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a4.endAngle, endAngle = _h === void 0 ? 0 : _h;
        if (sweepFlag === 0) {
          d *= -1;
        }
        var dx1 = rx * Math.cos(startAngle - d) + cx;
        var dy1 = ry * Math.sin(startAngle - d) + cy;
        segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
        var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
        var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
        segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
      }
      segments.push(segment);
    }
    return segments;
  }

  // node_modules/@antv/path-util/esm/get-line-intersect.js
  var isBetween = function(value, min3, max3) {
    return value >= min3 && value <= max3;
  };
  function getLineIntersect(p0, p1, p2, p3) {
    var tolerance3 = 1e-3;
    var E = {
      x: p2.x - p0.x,
      y: p2.y - p0.y
    };
    var D0 = {
      x: p1.x - p0.x,
      y: p1.y - p0.y
    };
    var D1 = {
      x: p3.x - p2.x,
      y: p3.y - p2.y
    };
    var kross = D0.x * D1.y - D0.y * D1.x;
    var sqrKross = kross * kross;
    var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
    var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
    var point = null;
    if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
      var s = (E.x * D1.y - E.y * D1.x) / kross;
      var t = (E.x * D0.y - E.y * D0.x) / kross;
      if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
        point = {
          x: p0.x + s * D0.x,
          y: p0.y + s * D0.y
        };
      }
    }
    return point;
  }

  // node_modules/@antv/path-util/esm/point-in-polygon.js
  var tolerance = 1e-6;
  function dcmp(x) {
    if (Math.abs(x) < tolerance) {
      return 0;
    }
    return x < 0 ? -1 : 1;
  }
  function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
      return true;
    }
    return false;
  }
  function isInPolygon(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
      return false;
    }
    for (var i = 0; i < n; i++) {
      var p1 = points[i];
      var p2 = points[(i + 1) % n];
      if (onSegment(p1, p2, [x, y])) {
        return true;
      }
      if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }

  // node_modules/@antv/path-util/esm/is-polygons-intersect.js
  function parseToLines(points) {
    var lines = [];
    var count = points.length;
    for (var i = 0; i < count - 1; i++) {
      var point = points[i];
      var next = points[i + 1];
      lines.push({
        from: {
          x: point[0],
          y: point[1]
        },
        to: {
          x: next[0],
          y: next[1]
        }
      });
    }
    if (lines.length > 1) {
      var first = points[0];
      var last2 = points[count - 1];
      lines.push({
        from: {
          x: last2[0],
          y: last2[1]
        },
        to: {
          x: first[0],
          y: first[1]
        }
      });
    }
    return lines;
  }
  function lineIntersectPolygon(lines, line) {
    var isIntersect2 = false;
    each_default(lines, function(l) {
      if (getLineIntersect(l.from, l.to, line.from, line.to)) {
        isIntersect2 = true;
        return false;
      }
    });
    return isIntersect2;
  }
  function getBBox(points) {
    var xArr = points.map(function(p2) {
      return p2[0];
    });
    var yArr = points.map(function(p2) {
      return p2[1];
    });
    return {
      minX: Math.min.apply(null, xArr),
      maxX: Math.max.apply(null, xArr),
      minY: Math.min.apply(null, yArr),
      maxY: Math.max.apply(null, yArr)
    };
  }
  function intersectBBox(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
  }
  function isPolygonsIntersect(points1, points2) {
    if (points1.length < 2 || points2.length < 2) {
      return false;
    }
    var bbox1 = getBBox(points1);
    var bbox2 = getBBox(points2);
    if (!intersectBBox(bbox1, bbox2)) {
      return false;
    }
    var isIn = false;
    each_default(points2, function(point) {
      if (isInPolygon(points1, point[0], point[1])) {
        isIn = true;
        return false;
      }
    });
    if (isIn) {
      return true;
    }
    each_default(points1, function(point) {
      if (isInPolygon(points2, point[0], point[1])) {
        isIn = true;
        return false;
      }
    });
    if (isIn) {
      return true;
    }
    var lines1 = parseToLines(points1);
    var lines2 = parseToLines(points2);
    var isIntersect2 = false;
    each_default(lines2, function(line) {
      if (lineIntersectPolygon(lines1, line)) {
        isIntersect2 = true;
        return false;
      }
    });
    return isIntersect2;
  }

  // node_modules/@antv/g-base/esm/bbox/path.js
  function getPathBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    var minX = min_default(xArr);
    var minY = min_default(yArr);
    var maxX = max_default(xArr);
    var maxY = max_default(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    for (var i = 0; i < segmentsWithAngle.length; i++) {
      var segment = segmentsWithAngle[i];
      var currentPoint = segment.currentPoint;
      var extra = void 0;
      if (currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        minX = minX - extra.xExtra;
      } else if (currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        maxX = maxX + extra.xExtra;
      }
      if (currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        minY = minY - extra.yExtra;
      } else if (currentPoint[1] === maxY) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        maxY = maxY + extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function path_default(shape) {
    var attrs = shape.attr();
    var path = attrs.path, stroke = attrs.stroke;
    var lineWidth = stroke ? attrs.lineWidth : 0;
    var segments = shape.get("segments") || getSegments(path);
    var _a4 = getPathBox(segments, lineWidth), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/g-base/esm/bbox/line.js
  function line_default2(shape) {
    var attrs = shape.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var bbox = {
      minX,
      maxX,
      minY,
      maxY
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/g-base/esm/bbox/ellipse.js
  function ellipse_default2(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  }

  // node_modules/@antv/g-base/esm/bbox/index.js
  register("rect", rect_default);
  register("image", rect_default);
  register("circle", circle_default);
  register("marker", circle_default);
  register("polyline", polyline_default2);
  register("polygon", polygon_default2);
  register("text", text_default);
  register("path", path_default);
  register("line", line_default2);
  register("ellipse", ellipse_default2);

  // node_modules/@antv/adjust/esm/constant.js
  var DEFAULT_Y = 0;
  var MARGIN_RATIO = 1 / 2;
  var DODGE_RATIO = 1 / 2;
  var GAP = 0.05;

  // node_modules/@antv/adjust/esm/adjusts/adjust.js
  var Adjust = function() {
    function Adjust2(cfg) {
      var xField = cfg.xField, yField = cfg.yField, _a4 = cfg.adjustNames, adjustNames = _a4 === void 0 ? ["x", "y"] : _a4;
      this.adjustNames = adjustNames;
      this.xField = xField;
      this.yField = yField;
    }
    Adjust2.prototype.isAdjust = function(dim) {
      return this.adjustNames.indexOf(dim) >= 0;
    };
    Adjust2.prototype.getAdjustRange = function(dim, dimValue, values2) {
      var yField = this.yField;
      var index = values2.indexOf(dimValue);
      var length3 = values2.length;
      var pre;
      var next;
      if (!yField && this.isAdjust("y")) {
        pre = 0;
        next = 1;
      } else if (length3 > 1) {
        pre = values2[index === 0 ? 0 : index - 1];
        next = values2[index === length3 - 1 ? length3 - 1 : index + 1];
        if (index !== 0) {
          pre += (dimValue - pre) / 2;
        } else {
          pre -= (next - dimValue) / 2;
        }
        if (index !== length3 - 1) {
          next -= (next - dimValue) / 2;
        } else {
          next += (dimValue - values2[length3 - 2]) / 2;
        }
      } else {
        pre = dimValue === 0 ? 0 : dimValue - 0.5;
        next = dimValue === 0 ? 1 : dimValue + 0.5;
      }
      return {
        pre,
        next
      };
    };
    Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
      var _this = this;
      var dimValuesMap = this.getDimValues(mergedData);
      each_default(groupedDataArray, function(dataArray, index) {
        each_default(dimValuesMap, function(values2, dim) {
          _this.adjustDim(dim, values2, dataArray, index);
        });
      });
    };
    Adjust2.prototype.groupData = function(data, dim) {
      each_default(data, function(record) {
        if (record[dim] === void 0) {
          record[dim] = DEFAULT_Y;
        }
      });
      return group_by_default(data, dim);
    };
    Adjust2.prototype.adjustDim = function(dim, values2, data, index) {
    };
    Adjust2.prototype.getDimValues = function(mergedData) {
      var _a4 = this, xField = _a4.xField, yField = _a4.yField;
      var dimValuesMap = {};
      var dims = [];
      if (xField && this.isAdjust("x")) {
        dims.push(xField);
      }
      if (yField && this.isAdjust("y")) {
        dims.push(yField);
      }
      dims.forEach(function(dim2) {
        dimValuesMap[dim2] = values_of_key_default(mergedData, dim2).sort(function(v1, v2) {
          return v1 - v2;
        });
      });
      if (!yField && this.isAdjust("y")) {
        var dim = "y";
        dimValuesMap[dim] = [DEFAULT_Y, 1];
      }
      return dimValuesMap;
    };
    return Adjust2;
  }();
  var adjust_default = Adjust;

  // node_modules/@antv/adjust/esm/factory.js
  var ADJUST_MAP = {};
  var getAdjust = function(type) {
    return ADJUST_MAP[type.toLowerCase()];
  };
  var registerAdjust = function(type, ctor) {
    if (getAdjust(type)) {
      throw new Error("Adjust type '" + type + "' existed.");
    }
    ADJUST_MAP[type.toLowerCase()] = ctor;
  };

  // node_modules/@antv/adjust/node_modules/tslib/modules/index.js
  var import_tslib12 = __toModule(require_tslib4());
  var {
    __extends: __extends4,
    __assign: __assign4,
    __rest: __rest4,
    __decorate: __decorate4,
    __param: __param4,
    __metadata: __metadata4,
    __awaiter: __awaiter4,
    __generator: __generator4,
    __exportStar: __exportStar4,
    __createBinding: __createBinding4,
    __values: __values4,
    __read: __read4,
    __spread: __spread4,
    __spreadArrays: __spreadArrays4,
    __await: __await4,
    __asyncGenerator: __asyncGenerator4,
    __asyncDelegator: __asyncDelegator4,
    __asyncValues: __asyncValues4,
    __makeTemplateObject: __makeTemplateObject4,
    __importStar: __importStar4,
    __importDefault: __importDefault4,
    __classPrivateFieldGet: __classPrivateFieldGet4,
    __classPrivateFieldSet: __classPrivateFieldSet4
  } = import_tslib12.default;

  // node_modules/@antv/adjust/esm/adjusts/dodge.js
  var Dodge = function(_super) {
    __extends4(Dodge2, _super);
    function Dodge2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.cacheMap = {};
      _this.adjustDataArray = [];
      _this.mergeData = [];
      var _a4 = cfg.marginRatio, marginRatio = _a4 === void 0 ? MARGIN_RATIO : _a4, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio;
      _this.marginRatio = marginRatio;
      _this.dodgeRatio = dodgeRatio;
      _this.dodgeBy = dodgeBy;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.xDimensionLegenth = xDimensionLength;
      _this.groupNum = groupNum;
      _this.defaultSize = defaultSize;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      return _this;
    }
    Dodge2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone_default(groupDataArray);
      var mergeData = flatten_default(groupedDataArray);
      var dodgeBy = this.dodgeBy;
      var adjustDataArray = dodgeBy ? group_default(mergeData, dodgeBy) : groupedDataArray;
      this.cacheMap = {};
      this.adjustDataArray = adjustDataArray;
      this.mergeData = mergeData;
      this.adjustData(adjustDataArray, mergeData);
      this.adjustDataArray = [];
      this.mergeData = [];
      return groupedDataArray;
    };
    Dodge2.prototype.adjustDim = function(dim, values2, data, frameIndex) {
      var _this = this;
      var map5 = this.getDistribution(dim);
      var groupData = this.groupData(data, dim);
      each_default(groupData, function(group2, key) {
        var range;
        if (values2.length === 1) {
          range = {
            pre: values2[0] - 1,
            next: values2[0] + 1
          };
        } else {
          range = _this.getAdjustRange(dim, parseFloat(key), values2);
        }
        each_default(group2, function(d) {
          var value = d[dim];
          var valueArr = map5[value];
          var valIndex = valueArr.indexOf(frameIndex);
          d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
        });
      });
      return [];
    };
    Dodge2.prototype.getDodgeOffset = function(range, idx, len3) {
      var _a4 = this, dodgeRatio = _a4.dodgeRatio, marginRatio = _a4.marginRatio, intervalPadding = _a4.intervalPadding, dodgePadding = _a4.dodgePadding;
      var pre = range.pre, next = range.next;
      var tickLength = next - pre;
      var position;
      if (!is_nil_default(intervalPadding) && is_nil_default(dodgePadding) && intervalPadding >= 0) {
        var offset = this.getIntervalOnlyOffset(len3, idx);
        position = pre + offset;
      } else if (!is_nil_default(dodgePadding) && is_nil_default(intervalPadding) && dodgePadding >= 0) {
        var offset = this.getDodgeOnlyOffset(len3, idx);
        position = pre + offset;
      } else if (!is_nil_default(intervalPadding) && !is_nil_default(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
        var offset = this.getIntervalAndDodgeOffset(len3, idx);
        position = pre + offset;
      } else {
        var width = tickLength * dodgeRatio / len3;
        var margin = marginRatio * width;
        var offset = 1 / 2 * (tickLength - len3 * width - (len3 - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
        position = (pre + next) / 2 + offset;
      }
      return position;
    };
    Dodge2.prototype.getIntervalOnlyOffset = function(len3, idx) {
      var _a4 = this, defaultSize = _a4.defaultSize, intervalPadding = _a4.intervalPadding, xDimensionLegenth = _a4.xDimensionLegenth, groupNum = _a4.groupNum, dodgeRatio = _a4.dodgeRatio, maxColumnWidth = _a4.maxColumnWidth, minColumnWidth = _a4.minColumnWidth, columnWidthRatio = _a4.columnWidthRatio;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len3 - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      geomWidth = !is_nil_default(columnWidthRatio) ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
      if (!is_nil_default(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!is_nil_default(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len3 * geomWidth) / (len3 - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDodgeOnlyOffset = function(len3, idx) {
      var _a4 = this, defaultSize = _a4.defaultSize, dodgePadding = _a4.dodgePadding, xDimensionLegenth = _a4.xDimensionLegenth, groupNum = _a4.groupNum, marginRatio = _a4.marginRatio, maxColumnWidth = _a4.maxColumnWidth, minColumnWidth = _a4.minColumnWidth, columnWidthRatio = _a4.columnWidthRatio;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      geomWidth = columnWidthRatio ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
      if (!is_nil_default(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!is_nil_default(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedIntervalPadding = (1 - (geomWidth * len3 + normalizedDodgePadding * (len3 - 1)) * groupNum) / (groupNum - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getIntervalAndDodgeOffset = function(len3, idx) {
      var _a4 = this, intervalPadding = _a4.intervalPadding, dodgePadding = _a4.dodgePadding, xDimensionLegenth = _a4.xDimensionLegenth, groupNum = _a4.groupNum;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDistribution = function(dim) {
      var groupedDataArray = this.adjustDataArray;
      var cacheMap = this.cacheMap;
      var map5 = cacheMap[dim];
      if (!map5) {
        map5 = {};
        each_default(groupedDataArray, function(data, index) {
          var values2 = values_of_key_default(data, dim);
          if (!values2.length) {
            values2.push(0);
          }
          each_default(values2, function(val) {
            if (!map5[val]) {
              map5[val] = [];
            }
            map5[val].push(index);
          });
        });
        cacheMap[dim] = map5;
      }
      return map5;
    };
    return Dodge2;
  }(adjust_default);
  var dodge_default = Dodge;

  // node_modules/@antv/adjust/esm/adjusts/jitter.js
  function randomNumber(min3, max3) {
    return (max3 - min3) * Math.random() + min3;
  }
  var Jitter = function(_super) {
    __extends4(Jitter2, _super);
    function Jitter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Jitter2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone_default(groupDataArray);
      var mergeData = flatten_default(groupedDataArray);
      this.adjustData(groupedDataArray, mergeData);
      return groupedDataArray;
    };
    Jitter2.prototype.adjustDim = function(dim, values2, dataArray) {
      var _this = this;
      var groupDataArray = this.groupData(dataArray, dim);
      return each_default(groupDataArray, function(data, dimValue) {
        return _this.adjustGroup(data, dim, parseFloat(dimValue), values2);
      });
    };
    Jitter2.prototype.getAdjustOffset = function(range) {
      var pre = range.pre, next = range.next;
      var margin = (next - pre) * GAP;
      return randomNumber(pre + margin, next - margin);
    };
    Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values2) {
      var _this = this;
      var range = this.getAdjustRange(dim, dimValue, values2);
      each_default(group2, function(data) {
        data[dim] = _this.getAdjustOffset(range);
      });
      return group2;
    };
    return Jitter2;
  }(adjust_default);
  var jitter_default = Jitter;

  // node_modules/@antv/adjust/esm/adjusts/stack.js
  var Cache = cache_default;
  var Stack = function(_super) {
    __extends4(Stack2, _super);
    function Stack2(cfg) {
      var _this = _super.call(this, cfg) || this;
      var _a4 = cfg.adjustNames, adjustNames = _a4 === void 0 ? ["y"] : _a4, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size3 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
      _this.adjustNames = adjustNames;
      _this.height = height;
      _this.size = size3;
      _this.reverseOrder = reverseOrder;
      return _this;
    }
    Stack2.prototype.process = function(groupDataArray) {
      var _a4 = this, yField = _a4.yField, reverseOrder = _a4.reverseOrder;
      var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
      return reverseOrder ? this.reverse(d) : d;
    };
    Stack2.prototype.reverse = function(groupedDataArray) {
      return groupedDataArray.slice(0).reverse();
    };
    Stack2.prototype.processStack = function(groupDataArray) {
      var _a4 = this, xField = _a4.xField, yField = _a4.yField, reverseOrder = _a4.reverseOrder;
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var positive = new Cache();
      var negative = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data) {
          var _a5;
          var x = get_default(data, xField, 0);
          var y = get_default(data, [yField]);
          var xKey = x.toString();
          y = is_array_default(y) ? y[1] : y;
          if (!is_nil_default(y)) {
            var cache3 = y >= 0 ? positive : negative;
            if (!cache3.has(xKey)) {
              cache3.set(xKey, 0);
            }
            var xValue = cache3.get(xKey);
            var newXValue = y + xValue;
            cache3.set(xKey, newXValue);
            return __assign4(__assign4({}, data), (_a5 = {}, _a5[yField] = [xValue, newXValue], _a5));
          }
          return data;
        });
      });
    };
    Stack2.prototype.processOneDimStack = function(groupDataArray) {
      var _this = this;
      var _a4 = this, xField = _a4.xField, height = _a4.height, reverseOrder = _a4.reverseOrder;
      var yField = "y";
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var cache3 = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data) {
          var _a5;
          var size3 = _this.size;
          var xValue = data[xField];
          var stackHeight = size3 * 2 / height;
          if (!cache3.has(xValue)) {
            cache3.set(xValue, stackHeight / 2);
          }
          var stackValue = cache3.get(xValue);
          cache3.set(xValue, stackValue + stackHeight);
          return __assign4(__assign4({}, data), (_a5 = {}, _a5[yField] = stackValue, _a5));
        });
      });
    };
    return Stack2;
  }(adjust_default);
  var stack_default = Stack;

  // node_modules/@antv/adjust/esm/adjusts/symmetric.js
  var Symmetric = function(_super) {
    __extends4(Symmetric2, _super);
    function Symmetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Symmetric2.prototype.process = function(groupDataArray) {
      var mergeData = flatten_default(groupDataArray);
      var _a4 = this, xField = _a4.xField, yField = _a4.yField;
      var cache3 = this.getXValuesMaxMap(mergeData);
      var max3 = Math.max.apply(Math, Object.keys(cache3).map(function(key) {
        return cache3[key];
      }));
      return map_default(groupDataArray, function(dataArray) {
        return map_default(dataArray, function(data) {
          var _a5, _b;
          var yValue = data[yField];
          var xValue = data[xField];
          if (is_array_default(yValue)) {
            var off_1 = (max3 - cache3[xValue]) / 2;
            return __assign4(__assign4({}, data), (_a5 = {}, _a5[yField] = map_default(yValue, function(y) {
              return off_1 + y;
            }), _a5));
          }
          var offset = (max3 - yValue) / 2;
          return __assign4(__assign4({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
        });
      });
    };
    Symmetric2.prototype.getXValuesMaxMap = function(mergeData) {
      var _this = this;
      var _a4 = this, xField = _a4.xField, yField = _a4.yField;
      var groupDataArray = group_by_default(mergeData, function(data) {
        return data[xField];
      });
      return map_values_default(groupDataArray, function(dataArray) {
        return _this.getDimMaxValue(dataArray, yField);
      });
    };
    Symmetric2.prototype.getDimMaxValue = function(mergeData, dim) {
      var dimValues = map_default(mergeData, function(data) {
        return get_default(data, dim, []);
      });
      var flattenValues = flatten_default(dimValues);
      return Math.max.apply(Math, flattenValues);
    };
    return Symmetric2;
  }(adjust_default);
  var symmetric_default = Symmetric;

  // node_modules/@antv/adjust/esm/index.js
  registerAdjust("Dodge", dodge_default);
  registerAdjust("Jitter", jitter_default);
  registerAdjust("Stack", stack_default);
  registerAdjust("Symmetric", symmetric_default);

  // node_modules/@antv/attr/esm/attributes/base.js
  var toScaleString = function(scale4, value) {
    if (is_string_default(value)) {
      return value;
    }
    return scale4.invert(scale4.scale(value));
  };
  var Attribute = function() {
    function Attribute2(cfg) {
      this.names = [];
      this.scales = [];
      this.linear = false;
      this.values = [];
      this.callback = function() {
        return [];
      };
      this._parseCfg(cfg);
    }
    Attribute2.prototype.mapping = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      var values2 = params.map(function(param, idx) {
        return _this._toOriginParam(param, _this.scales[idx]);
      });
      return this.callback.apply(this, values2);
    };
    Attribute2.prototype.getLinearValue = function(percent) {
      var steps = this.values.length - 1;
      var step = Math.floor(steps * percent);
      var leftPercent = steps * percent - step;
      var start = this.values[step];
      var end = step === steps ? start : this.values[step + 1];
      return start + (end - start) * leftPercent;
    };
    Attribute2.prototype.getNames = function() {
      var scales = this.scales;
      var names = this.names;
      var length3 = Math.min(scales.length, names.length);
      var rst = [];
      for (var i = 0; i < length3; i += 1) {
        rst.push(names[i]);
      }
      return rst;
    };
    Attribute2.prototype.getFields = function() {
      return this.scales.map(function(scale4) {
        return scale4.field;
      });
    };
    Attribute2.prototype.getScale = function(name) {
      return this.scales[this.names.indexOf(name)];
    };
    Attribute2.prototype.defaultCallback = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 0) {
        return this.values;
      }
      return params.map(function(param, idx) {
        var scale4 = _this.scales[idx];
        return scale4.type === "identity" ? scale4.values[0] : _this._getAttributeValue(scale4, param);
      });
    };
    Attribute2.prototype._parseCfg = function(cfg) {
      var _this = this;
      var _a4 = cfg.type, type = _a4 === void 0 ? "base" : _a4, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values2 = _d === void 0 ? [] : _d, callback = cfg.callback;
      this.type = type;
      this.scales = scales;
      this.values = values2;
      this.names = names;
      this.callback = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        if (callback) {
          var ret = callback.apply(void 0, params);
          if (!is_nil_default(ret)) {
            return [ret];
          }
        }
        return _this.defaultCallback.apply(_this, params);
      };
    };
    Attribute2.prototype._getAttributeValue = function(scale4, value) {
      if (scale4.isCategory && !this.linear) {
        var idx = scale4.translate(value);
        return this.values[idx % this.values.length];
      }
      var percent = scale4.scale(value);
      return this.getLinearValue(percent);
    };
    Attribute2.prototype._toOriginParam = function(param, scale4) {
      return !scale4.isLinear ? is_array_default(param) ? param.map(function(p2) {
        return toScaleString(scale4, p2);
      }) : toScaleString(scale4, param) : param;
    };
    return Attribute2;
  }();
  var base_default3 = Attribute;

  // node_modules/@antv/attr/node_modules/tslib/modules/index.js
  var import_tslib17 = __toModule(require_tslib5());
  var {
    __extends: __extends5,
    __assign: __assign5,
    __rest: __rest5,
    __decorate: __decorate5,
    __param: __param5,
    __metadata: __metadata5,
    __awaiter: __awaiter5,
    __generator: __generator5,
    __exportStar: __exportStar5,
    __createBinding: __createBinding5,
    __values: __values5,
    __read: __read5,
    __spread: __spread5,
    __spreadArrays: __spreadArrays5,
    __await: __await5,
    __asyncGenerator: __asyncGenerator5,
    __asyncDelegator: __asyncDelegator5,
    __asyncValues: __asyncValues5,
    __makeTemplateObject: __makeTemplateObject5,
    __importStar: __importStar5,
    __importDefault: __importDefault5,
    __classPrivateFieldGet: __classPrivateFieldGet5,
    __classPrivateFieldSet: __classPrivateFieldSet5
  } = import_tslib17.default;

  // node_modules/@antv/color-util/esm/index.js
  var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
  var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  var isGradientColor2 = function(val) {
    return /^[r,R,L,l]{1}[\s]*\(/.test(val);
  };
  var createTmp = function() {
    var i = document.createElement("i");
    i.title = "Web Colour Picker";
    i.style.display = "none";
    document.body.appendChild(i);
    return i;
  };
  var getValue = function(start, end, percent, index) {
    return start[index] + (end[index] - start[index]) * percent;
  };
  function arr2rgb(arr) {
    return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
  }
  var rgb2arr = function(str4) {
    return [
      parseInt(str4.substr(1, 2), 16),
      parseInt(str4.substr(3, 2), 16),
      parseInt(str4.substr(5, 2), 16)
    ];
  };
  var toHex = function(value) {
    var x16Value = Math.round(value).toString(16);
    return x16Value.length === 1 ? "0" + x16Value : x16Value;
  };
  var calColor = function(points, percent) {
    var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
    var steps = points.length - 1;
    var step = Math.floor(steps * fixedPercent);
    var left = steps * fixedPercent - step;
    var start = points[step];
    var end = step === steps ? start : points[step + 1];
    return arr2rgb([
      getValue(start, end, left, 0),
      getValue(start, end, left, 1),
      getValue(start, end, left, 2)
    ]);
  };
  var iEl;
  var toRGB = function(color2) {
    if (color2[0] === "#" && color2.length === 7) {
      return color2;
    }
    if (!iEl) {
      iEl = createTmp();
    }
    iEl.style.color = color2;
    var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
    var matches = RGB_REG.exec(rst);
    var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
      return Number(s);
    });
    rst = arr2rgb(cArray);
    return rst;
  };
  var gradient = function(colors) {
    var colorArray = is_string_default(colors) ? colors.split("-") : colors;
    var points = map_default(colorArray, function(color2) {
      return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
    });
    return function(percent) {
      return calColor(points, percent);
    };
  };
  var toCSSGradient = function(gradientColor) {
    if (isGradientColor2(gradientColor)) {
      var cssColor_1;
      var steps = void 0;
      if (gradientColor[0] === "l") {
        var arr = regexLG.exec(gradientColor);
        var angle3 = +arr[1] + 90;
        steps = arr[2];
        cssColor_1 = "linear-gradient(" + angle3 + "deg, ";
      } else if (gradientColor[0] === "r") {
        cssColor_1 = "radial-gradient(";
        var arr = regexRG.exec(gradientColor);
        steps = arr[4];
      }
      var colorStops_1 = steps.match(regexColorStop);
      each_default(colorStops_1, function(item, index) {
        var itemArr = item.split(":");
        cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
        if (index !== colorStops_1.length - 1) {
          cssColor_1 += ", ";
        }
      });
      cssColor_1 += ")";
      return cssColor_1;
    }
    return gradientColor;
  };
  var esm_default2 = {
    rgb2arr,
    gradient,
    toRGB: memoize_default(toRGB),
    toCSSGradient
  };

  // node_modules/@antv/attr/esm/attributes/color.js
  var Color2 = function(_super) {
    __extends5(Color3, _super);
    function Color3(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "color";
      _this.names = ["color"];
      if (is_string_default(_this.values)) {
        _this.linear = true;
      }
      _this.gradient = esm_default2.gradient(_this.values);
      return _this;
    }
    Color3.prototype.getLinearValue = function(percent) {
      return this.gradient(percent);
    };
    return Color3;
  }(base_default3);
  var color_default = Color2;

  // node_modules/@antv/attr/esm/attributes/opacity.js
  var Opacity = function(_super) {
    __extends5(Opacity2, _super);
    function Opacity2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "opacity";
      _this.names = ["opacity"];
      return _this;
    }
    return Opacity2;
  }(base_default3);
  var opacity_default = Opacity;

  // node_modules/@antv/attr/esm/attributes/position.js
  var Position = function(_super) {
    __extends5(Position2, _super);
    function Position2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.names = ["x", "y"];
      _this.type = "position";
      return _this;
    }
    Position2.prototype.mapping = function(x, y) {
      var _a4 = this.scales, scaleX = _a4[0], scaleY = _a4[1];
      if (is_nil_default(x) || is_nil_default(y)) {
        return [];
      }
      return [
        is_array_default(x) ? x.map(function(xi) {
          return scaleX.scale(xi);
        }) : scaleX.scale(x),
        is_array_default(y) ? y.map(function(yi) {
          return scaleY.scale(yi);
        }) : scaleY.scale(y)
      ];
    };
    return Position2;
  }(base_default3);
  var position_default = Position;

  // node_modules/@antv/attr/esm/attributes/shape.js
  var Shape = function(_super) {
    __extends5(Shape2, _super);
    function Shape2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "shape";
      _this.names = ["shape"];
      return _this;
    }
    Shape2.prototype.getLinearValue = function(percent) {
      var idx = Math.round((this.values.length - 1) * percent);
      return this.values[idx];
    };
    return Shape2;
  }(base_default3);
  var shape_default2 = Shape;

  // node_modules/@antv/attr/esm/attributes/size.js
  var Size = function(_super) {
    __extends5(Size2, _super);
    function Size2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "size";
      _this.names = ["size"];
      return _this;
    }
    return Size2;
  }(base_default3);
  var size_default = Size;

  // node_modules/@antv/scale/esm/tick-method/register.js
  var methodCache = {};
  function getTickMethod(key) {
    return methodCache[key];
  }
  function registerTickMethod(key, method) {
    methodCache[key] = method;
  }

  // node_modules/@antv/scale/esm/base.js
  var Scale = function() {
    function Scale2(cfg) {
      this.type = "base";
      this.isCategory = false;
      this.isLinear = false;
      this.isContinuous = false;
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    Scale2.prototype.translate = function(v) {
      return v;
    };
    Scale2.prototype.change = function(cfg) {
      mix(this.__cfg__, cfg);
      this.init();
    };
    Scale2.prototype.clone = function() {
      return this.constructor(this.__cfg__);
    };
    Scale2.prototype.getTicks = function() {
      var _this = this;
      return map_default(this.ticks, function(tick2, idx) {
        if (is_object_default(tick2)) {
          return tick2;
        }
        return {
          text: _this.getText(tick2, idx),
          tickValue: tick2,
          value: _this.scale(tick2)
        };
      });
    };
    Scale2.prototype.getText = function(value, key) {
      var formatter = this.formatter;
      var res = formatter ? formatter(value, key) : value;
      if (is_nil_default(res) || !is_function_default(res.toString)) {
        return "";
      }
      return res.toString();
    };
    Scale2.prototype.getConfig = function(key) {
      return this.__cfg__[key];
    };
    Scale2.prototype.init = function() {
      mix(this, this.__cfg__);
      this.setDomain();
      if (is_empty_default(this.getConfig("ticks"))) {
        this.ticks = this.calculateTicks();
      }
    };
    Scale2.prototype.initCfg = function() {
    };
    Scale2.prototype.setDomain = function() {
    };
    Scale2.prototype.calculateTicks = function() {
      var tickMethod = this.tickMethod;
      var ticks = [];
      if (is_string_default(tickMethod)) {
        var method = getTickMethod(tickMethod);
        if (!method) {
          throw new Error("There is no method to to calculate ticks!");
        }
        ticks = method(this);
      } else if (is_function_default(tickMethod)) {
        ticks = tickMethod(this);
      }
      return ticks;
    };
    Scale2.prototype.rangeMin = function() {
      return this.range[0];
    };
    Scale2.prototype.rangeMax = function() {
      return this.range[1];
    };
    Scale2.prototype.calcPercent = function(value, min3, max3) {
      if (is_number_default(value)) {
        return (value - min3) / (max3 - min3);
      }
      return NaN;
    };
    Scale2.prototype.calcValue = function(percent, min3, max3) {
      return min3 + percent * (max3 - min3);
    };
    return Scale2;
  }();
  var base_default4 = Scale;

  // node_modules/@antv/scale/esm/category/base.js
  var Category = function(_super) {
    __extends(Category3, _super);
    function Category3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cat";
      _this.isCategory = true;
      return _this;
    }
    Category3.prototype.buildIndexMap = function() {
      if (!this.translateIndexMap) {
        this.translateIndexMap = new Map();
        for (var i = 0; i < this.values.length; i++) {
          this.translateIndexMap.set(this.values[i], i);
        }
      }
    };
    Category3.prototype.translate = function(value) {
      this.buildIndexMap();
      var idx = this.translateIndexMap.get(value);
      if (idx === void 0) {
        idx = is_number_default(value) ? value : NaN;
      }
      return idx;
    };
    Category3.prototype.scale = function(value) {
      var order = this.translate(value);
      var percent = this.calcPercent(order, this.min, this.max);
      return this.calcValue(percent, this.rangeMin(), this.rangeMax());
    };
    Category3.prototype.invert = function(scaledValue) {
      var domainRange = this.max - this.min;
      var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
      var idx = Math.round(domainRange * percent) + this.min;
      if (idx < this.min || idx > this.max) {
        return NaN;
      }
      return this.values[idx];
    };
    Category3.prototype.getText = function(value) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var v = value;
      if (is_number_default(value) && !this.values.includes(value)) {
        v = this.values[v];
      }
      return _super.prototype.getText.apply(this, __spreadArray([v], args, false));
    };
    Category3.prototype.initCfg = function() {
      this.tickMethod = "cat";
    };
    Category3.prototype.setDomain = function() {
      if (is_nil_default(this.getConfig("min"))) {
        this.min = 0;
      }
      if (is_nil_default(this.getConfig("max"))) {
        var size3 = this.values.length;
        this.max = size3 > 1 ? size3 - 1 : size3;
      }
      if (this.translateIndexMap) {
        this.translateIndexMap = void 0;
      }
    };
    return Category3;
  }(base_default4);
  var base_default5 = Category;

  // node_modules/fecha/lib/fecha.js
  var fecha_exports = {};
  __export(fecha_exports, {
    assign: () => assign,
    default: () => fecha_default,
    defaultI18n: () => defaultI18n,
    format: () => format,
    parse: () => parse,
    setGlobalDateI18n: () => setGlobalDateI18n,
    setGlobalDateMasks: () => setGlobalDateMasks
  });
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigitsOptional = "[1-9]\\d?";
  var twoDigits = "\\d\\d";
  var threeDigits = "\\d{3}";
  var fourDigits = "\\d{4}";
  var word = "[^\\s]+";
  var literal = /\[([^]*?)\]/gm;
  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len3 = arr.length; i < len3; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }
  var monthUpdate = function(arrName) {
    return function(v, i18n) {
      var lowerCaseArr = i18n[arrName].map(function(v2) {
        return v2.toLowerCase();
      });
      var index = lowerCaseArr.indexOf(v.toLowerCase());
      if (index > -1) {
        return index;
      }
      return null;
    };
  };
  function assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var _a4 = 0, args_1 = args; _a4 < args_1.length; _a4++) {
      var obj = args_1[_a4];
      for (var key in obj) {
        origObj[key] = obj[key];
      }
    }
    return origObj;
  }
  var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var defaultI18n = {
    dayNamesShort,
    dayNames,
    monthNamesShort,
    monthNames,
    amPm: ["am", "pm"],
    DoFn: function(dayOfMonth) {
      return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
    }
  };
  var globalI18n = assign({}, defaultI18n);
  var setGlobalDateI18n = function(i18n) {
    return globalI18n = assign(globalI18n, i18n);
  };
  var regexEscape = function(str4) {
    return str4.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
  };
  var pad = function(val, len3) {
    if (len3 === void 0) {
      len3 = 2;
    }
    val = String(val);
    while (val.length < len3) {
      val = "0" + val;
    }
    return val;
  };
  var formatFlags = {
    D: function(dateObj) {
      return String(dateObj.getDate());
    },
    DD: function(dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return String(dateObj.getDay());
    },
    dd: function(dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return String(dateObj.getMonth() + 1);
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function(dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return String(dateObj.getHours() % 12 || 12);
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return String(dateObj.getHours());
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return String(dateObj.getMinutes());
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return String(dateObj.getSeconds());
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var offset = dateObj.getTimezoneOffset();
      return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
    },
    Z: function(dateObj) {
      var offset = dateObj.getTimezoneOffset();
      return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
    }
  };
  var monthParse = function(v) {
    return +v - 1;
  };
  var emptyDigits = [null, twoDigitsOptional];
  var emptyWord = [null, word];
  var amPm = [
    "isPm",
    word,
    function(v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        return 0;
      } else if (val === i18n.amPm[1]) {
        return 1;
      }
      return null;
    }
  ];
  var timezoneOffset = [
    "timezoneOffset",
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
    function(v) {
      var parts = (v + "").match(/([+-]|\d\d)/gi);
      if (parts) {
        var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
        return parts[0] === "+" ? minutes : -minutes;
      }
      return 0;
    }
  ];
  var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function(v) {
      return parseInt(v, 10);
    }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
      "year",
      twoDigits,
      function(v) {
        var now2 = new Date();
        var cent = +("" + now2.getFullYear()).substr(0, 2);
        return +("" + (+v > 68 ? cent - 1 : cent) + v);
      }
    ],
    h: ["hour", twoDigitsOptional, void 0, "isPm"],
    hh: ["hour", twoDigits, void 0, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\d", function(v) {
      return +v * 100;
    }],
    SS: ["millisecond", twoDigits, function(v) {
      return +v * 10;
    }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
  };
  var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
  };
  var setGlobalDateMasks = function(masks) {
    return assign(globalMasks, masks);
  };
  var format = function(dateObj, mask, i18n) {
    if (mask === void 0) {
      mask = globalMasks["default"];
    }
    if (i18n === void 0) {
      i18n = {};
    }
    if (typeof dateObj === "number") {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
      throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return "@@@";
    });
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    mask = mask.replace(token, function($0) {
      return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    return mask.replace(/@@@/g, function() {
      return literals.shift();
    });
  };
  function parse(dateStr, format2, i18n) {
    if (i18n === void 0) {
      i18n = {};
    }
    if (typeof format2 !== "string") {
      throw new Error("Invalid format in fecha parse");
    }
    format2 = globalMasks[format2] || format2;
    if (dateStr.length > 1e3) {
      return null;
    }
    var today = new Date();
    var dateInfo = {
      year: today.getFullYear(),
      month: 0,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
      isPm: null,
      timezoneOffset: null
    };
    var parseInfo = [];
    var literals = [];
    var newFormat = format2.replace(literal, function($0, $1) {
      literals.push(regexEscape($1));
      return "@@@";
    });
    var specifiedFields = {};
    var requiredFields = {};
    newFormat = regexEscape(newFormat).replace(token, function($0) {
      var info = parseFlags[$0];
      var field2 = info[0], regex = info[1], requiredField = info[3];
      if (specifiedFields[field2]) {
        throw new Error("Invalid format. " + field2 + " specified twice in format");
      }
      specifiedFields[field2] = true;
      if (requiredField) {
        requiredFields[requiredField] = true;
      }
      parseInfo.push(info);
      return "(" + regex + ")";
    });
    Object.keys(requiredFields).forEach(function(field2) {
      if (!specifiedFields[field2]) {
        throw new Error("Invalid format. " + field2 + " is required in specified format");
      }
    });
    newFormat = newFormat.replace(/@@@/g, function() {
      return literals.shift();
    });
    var matches = dateStr.match(new RegExp(newFormat, "i"));
    if (!matches) {
      return null;
    }
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    for (var i = 1; i < matches.length; i++) {
      var _a4 = parseInfo[i - 1], field = _a4[0], parser = _a4[2];
      var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
      if (value == null) {
        return null;
      }
      dateInfo[field] = value;
    }
    if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }
    var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i = 0, len3 = validateFields.length; i < len3; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()) {
        return null;
      }
    }
    if (dateInfo.timezoneOffset == null) {
      return dateWithoutTZ;
    }
    return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
  }
  var fecha = {
    format,
    parse,
    defaultI18n,
    setGlobalDateI18n,
    setGlobalDateMasks
  };
  var fecha_default = fecha;

  // node_modules/@antv/scale/esm/util/bisector.js
  function bisector_default(getter) {
    return function(a, x, _lo, _hi) {
      var lo = is_nil_default(_lo) ? 0 : _lo;
      var hi = is_nil_default(_hi) ? a.length : _hi;
      while (lo < hi) {
        var mid2 = lo + hi >>> 1;
        if (getter(a[mid2]) > x) {
          hi = mid2;
        } else {
          lo = mid2 + 1;
        }
      }
      return lo;
    };
  }

  // node_modules/@antv/scale/esm/util/time.js
  var FORMAT_METHOD = "format";
  function timeFormat(time, mask) {
    var method = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
    return method(time, mask);
  }
  function toTimeStamp(value) {
    if (is_string_default(value)) {
      if (value.indexOf("T") > 0) {
        value = new Date(value).getTime();
      } else {
        value = new Date(value.replace(/-/gi, "/")).getTime();
      }
    }
    if (is_date_default(value)) {
      value = value.getTime();
    }
    return value;
  }
  var SECOND = 1e3;
  var MINUTE = 60 * SECOND;
  var HOUR = 60 * MINUTE;
  var DAY = 24 * HOUR;
  var MONTH = DAY * 31;
  var YEAR = DAY * 365;
  var intervals = [
    ["HH:mm:ss", SECOND],
    ["HH:mm:ss", SECOND * 10],
    ["HH:mm:ss", SECOND * 30],
    ["HH:mm", MINUTE],
    ["HH:mm", MINUTE * 10],
    ["HH:mm", MINUTE * 30],
    ["HH", HOUR],
    ["HH", HOUR * 6],
    ["HH", HOUR * 12],
    ["YYYY-MM-DD", DAY],
    ["YYYY-MM-DD", DAY * 4],
    ["YYYY-WW", DAY * 7],
    ["YYYY-MM", MONTH],
    ["YYYY-MM", MONTH * 4],
    ["YYYY-MM", MONTH * 6],
    ["YYYY", DAY * 380]
  ];
  function getTickInterval(min3, max3, tickCount) {
    var target = (max3 - min3) / tickCount;
    var idx = bisector_default(function(o) {
      return o[1];
    })(intervals, target) - 1;
    var interval2 = intervals[idx];
    if (idx < 0) {
      interval2 = intervals[0];
    } else if (idx >= intervals.length) {
      interval2 = last(intervals);
    }
    return interval2;
  }

  // node_modules/@antv/scale/esm/category/time.js
  var TimeCat = function(_super) {
    __extends(TimeCat2, _super);
    function TimeCat2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "timeCat";
      return _this;
    }
    TimeCat2.prototype.translate = function(value) {
      value = toTimeStamp(value);
      var index = this.values.indexOf(value);
      if (index === -1) {
        if (is_number_default(value) && value < this.values.length) {
          index = value;
        } else {
          index = NaN;
        }
      }
      return index;
    };
    TimeCat2.prototype.getText = function(value, tickIndex) {
      var index = this.translate(value);
      if (index > -1) {
        var result = this.values[index];
        var formatter = this.formatter;
        result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
        return result;
      }
      return value;
    };
    TimeCat2.prototype.initCfg = function() {
      this.tickMethod = "time-cat";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
    };
    TimeCat2.prototype.setDomain = function() {
      var values2 = this.values;
      each_default(values2, function(v, i) {
        values2[i] = toTimeStamp(v);
      });
      values2.sort(function(v1, v2) {
        return v1 - v2;
      });
      _super.prototype.setDomain.call(this);
    };
    return TimeCat2;
  }(base_default5);
  var time_default = TimeCat;

  // node_modules/@antv/scale/esm/continuous/base.js
  var Continuous = function(_super) {
    __extends(Continuous2, _super);
    function Continuous2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isContinuous = true;
      return _this;
    }
    Continuous2.prototype.scale = function(value) {
      if (is_nil_default(value)) {
        return NaN;
      }
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var max3 = this.max;
      var min3 = this.min;
      if (max3 === min3) {
        return rangeMin;
      }
      var percent = this.getScalePercent(value);
      return rangeMin + percent * (rangeMax - rangeMin);
    };
    Continuous2.prototype.init = function() {
      _super.prototype.init.call(this);
      var ticks = this.ticks;
      var firstTick = head(ticks);
      var lastTick = last(ticks);
      if (firstTick < this.min) {
        this.min = firstTick;
      }
      if (lastTick > this.max) {
        this.max = lastTick;
      }
      if (!is_nil_default(this.minLimit)) {
        this.min = firstTick;
      }
      if (!is_nil_default(this.maxLimit)) {
        this.max = lastTick;
      }
    };
    Continuous2.prototype.setDomain = function() {
      var _a4 = get_range_default(this.values), min3 = _a4.min, max3 = _a4.max;
      if (is_nil_default(this.min)) {
        this.min = min3;
      }
      if (is_nil_default(this.max)) {
        this.max = max3;
      }
      if (this.min > this.max) {
        this.min = min3;
        this.max = max3;
      }
    };
    Continuous2.prototype.calculateTicks = function() {
      var _this = this;
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        ticks = filter_default(ticks, function(tick2) {
          return tick2 >= _this.min && tick2 <= _this.max;
        });
      }
      return ticks;
    };
    Continuous2.prototype.getScalePercent = function(value) {
      var max3 = this.max;
      var min3 = this.min;
      return (value - min3) / (max3 - min3);
    };
    Continuous2.prototype.getInvertPercent = function(value) {
      return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous2;
  }(base_default4);
  var base_default6 = Continuous;

  // node_modules/@antv/scale/esm/continuous/linear.js
  var Linear = function(_super) {
    __extends(Linear2, _super);
    function Linear2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "linear";
      _this.isLinear = true;
      return _this;
    }
    Linear2.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      return this.min + percent * (this.max - this.min);
    };
    Linear2.prototype.initCfg = function() {
      this.tickMethod = "wilkinson-extended";
      this.nice = false;
    };
    return Linear2;
  }(base_default6);
  var linear_default = Linear;

  // node_modules/@antv/scale/esm/util/math.js
  function calBase(a, b) {
    var e = Math.E;
    var value;
    if (b >= 0) {
      value = Math.pow(e, Math.log(b) / a);
    } else {
      value = Math.pow(e, Math.log(-b) / a) * -1;
    }
    return value;
  }
  function log(a, b) {
    if (a === 1) {
      return 1;
    }
    return Math.log(b) / Math.log(a);
  }
  function getLogPositiveMin(values2, base, max3) {
    if (is_nil_default(max3)) {
      max3 = Math.max.apply(null, values2);
    }
    var positiveMin = max3;
    each_default(values2, function(value) {
      if (value > 0 && value < positiveMin) {
        positiveMin = value;
      }
    });
    if (positiveMin === max3) {
      positiveMin = max3 / base;
    }
    if (positiveMin > 1) {
      positiveMin = 1;
    }
    return positiveMin;
  }

  // node_modules/@antv/scale/esm/continuous/log.js
  var Log = function(_super) {
    __extends(Log2, _super);
    function Log2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      return _this;
    }
    Log2.prototype.invert = function(value) {
      var base = this.base;
      var max3 = log(base, this.max);
      var rangeMin = this.rangeMin();
      var range = this.rangeMax() - rangeMin;
      var min3;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        if (value === 0) {
          return 0;
        }
        min3 = log(base, positiveMin / base);
        var appendPercent = 1 / (max3 - min3) * range;
        if (value < appendPercent) {
          return value / appendPercent * positiveMin;
        }
      } else {
        min3 = log(base, this.min);
      }
      var percent = (value - rangeMin) / range;
      var tmp = percent * (max3 - min3) + min3;
      return Math.pow(base, tmp);
    };
    Log2.prototype.initCfg = function() {
      this.tickMethod = "log";
      this.base = 10;
      this.tickCount = 6;
      this.nice = true;
    };
    Log2.prototype.setDomain = function() {
      _super.prototype.setDomain.call(this);
      var min3 = this.min;
      if (min3 < 0) {
        throw new Error("When you use log scale, the minimum value must be greater than zero!");
      }
      if (min3 === 0) {
        this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
      }
    };
    Log2.prototype.getScalePercent = function(value) {
      var max3 = this.max;
      var min3 = this.min;
      if (max3 === min3) {
        return 0;
      }
      if (value <= 0) {
        return 0;
      }
      var base = this.base;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        min3 = positiveMin * 1 / base;
      }
      var percent;
      if (value < positiveMin) {
        percent = value / positiveMin / (log(base, max3) - log(base, min3));
      } else {
        percent = (log(base, value) - log(base, min3)) / (log(base, max3) - log(base, min3));
      }
      return percent;
    };
    return Log2;
  }(base_default6);
  var log_default = Log;

  // node_modules/@antv/scale/esm/continuous/pow.js
  var Pow = function(_super) {
    __extends(Pow2, _super);
    function Pow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pow";
      return _this;
    }
    Pow2.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      var exponent2 = this.exponent;
      var max3 = calBase(exponent2, this.max);
      var min3 = calBase(exponent2, this.min);
      var tmp = percent * (max3 - min3) + min3;
      var factor = tmp >= 0 ? 1 : -1;
      return Math.pow(tmp, exponent2) * factor;
    };
    Pow2.prototype.initCfg = function() {
      this.tickMethod = "pow";
      this.exponent = 2;
      this.tickCount = 5;
      this.nice = true;
    };
    Pow2.prototype.getScalePercent = function(value) {
      var max3 = this.max;
      var min3 = this.min;
      if (max3 === min3) {
        return 0;
      }
      var exponent2 = this.exponent;
      var percent = (calBase(exponent2, value) - calBase(exponent2, min3)) / (calBase(exponent2, max3) - calBase(exponent2, min3));
      return percent;
    };
    return Pow2;
  }(base_default6);
  var pow_default = Pow;

  // node_modules/@antv/scale/esm/continuous/time.js
  var Time = function(_super) {
    __extends(Time2, _super);
    function Time2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "time";
      return _this;
    }
    Time2.prototype.getText = function(value, index) {
      var numberValue = this.translate(value);
      var formatter = this.formatter;
      return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
    };
    Time2.prototype.scale = function(value) {
      var v = value;
      if (is_string_default(v) || is_date_default(v)) {
        v = this.translate(v);
      }
      return _super.prototype.scale.call(this, v);
    };
    Time2.prototype.translate = function(v) {
      return toTimeStamp(v);
    };
    Time2.prototype.initCfg = function() {
      this.tickMethod = "time-pretty";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
      this.nice = false;
    };
    Time2.prototype.setDomain = function() {
      var values2 = this.values;
      var minConfig = this.getConfig("min");
      var maxConfig = this.getConfig("max");
      if (!is_nil_default(minConfig) || !is_number_default(minConfig)) {
        this.min = this.translate(this.min);
      }
      if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) {
        this.max = this.translate(this.max);
      }
      if (values2 && values2.length) {
        var timeStamps_1 = [];
        var min_1 = Infinity;
        var secondMin_1 = min_1;
        var max_1 = 0;
        each_default(values2, function(v) {
          var timeStamp = toTimeStamp(v);
          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: " + v + " in time scale!");
          }
          if (min_1 > timeStamp) {
            secondMin_1 = min_1;
            min_1 = timeStamp;
          } else if (secondMin_1 > timeStamp) {
            secondMin_1 = timeStamp;
          }
          if (max_1 < timeStamp) {
            max_1 = timeStamp;
          }
          timeStamps_1.push(timeStamp);
        });
        if (values2.length > 1) {
          this.minTickInterval = secondMin_1 - min_1;
        }
        if (is_nil_default(minConfig)) {
          this.min = min_1;
        }
        if (is_nil_default(maxConfig)) {
          this.max = max_1;
        }
      }
    };
    return Time2;
  }(linear_default);
  var time_default2 = Time;

  // node_modules/@antv/scale/esm/continuous/quantize.js
  var Quantize = function(_super) {
    __extends(Quantize2, _super);
    function Quantize2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantize";
      return _this;
    }
    Quantize2.prototype.invert = function(value) {
      var ticks = this.ticks;
      var length3 = ticks.length;
      var percent = this.getInvertPercent(value);
      var minIndex = Math.floor(percent * (length3 - 1));
      if (minIndex >= length3 - 1) {
        return last(ticks);
      }
      if (minIndex < 0) {
        return head(ticks);
      }
      var minTick = ticks[minIndex];
      var nextTick2 = ticks[minIndex + 1];
      var minIndexPercent = minIndex / (length3 - 1);
      var maxIndexPercent = (minIndex + 1) / (length3 - 1);
      return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick2 - minTick);
    };
    Quantize2.prototype.initCfg = function() {
      this.tickMethod = "r-pretty";
      this.tickCount = 5;
      this.nice = true;
    };
    Quantize2.prototype.calculateTicks = function() {
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        if (last(ticks) !== this.max) {
          ticks.push(this.max);
        }
        if (head(ticks) !== this.min) {
          ticks.unshift(this.min);
        }
      }
      return ticks;
    };
    Quantize2.prototype.getScalePercent = function(value) {
      var ticks = this.ticks;
      if (value < head(ticks)) {
        return 0;
      }
      if (value > last(ticks)) {
        return 1;
      }
      var minIndex = 0;
      each_default(ticks, function(tick2, index) {
        if (value >= tick2) {
          minIndex = index;
        } else {
          return false;
        }
      });
      return minIndex / (ticks.length - 1);
    };
    return Quantize2;
  }(base_default6);
  var quantize_default = Quantize;

  // node_modules/@antv/scale/esm/continuous/quantile.js
  var Quantile = function(_super) {
    __extends(Quantile2, _super);
    function Quantile2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantile";
      return _this;
    }
    Quantile2.prototype.initCfg = function() {
      this.tickMethod = "quantile";
      this.tickCount = 5;
      this.nice = true;
    };
    return Quantile2;
  }(quantize_default);
  var quantile_default = Quantile;

  // node_modules/@antv/scale/esm/factory.js
  var map4 = {};
  function getClass(key) {
    return map4[key];
  }
  function registerClass(key, cls) {
    if (getClass(key)) {
      throw new Error("type '" + key + "' existed.");
    }
    map4[key] = cls;
  }

  // node_modules/@antv/scale/esm/identity/index.js
  var Identity = function(_super) {
    __extends(Identity2, _super);
    function Identity2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "identity";
      _this.isIdentity = true;
      return _this;
    }
    Identity2.prototype.calculateTicks = function() {
      return this.values;
    };
    Identity2.prototype.scale = function(value) {
      if (this.values[0] !== value && is_number_default(value)) {
        return value;
      }
      return this.range[0];
    };
    Identity2.prototype.invert = function(value) {
      var range = this.range;
      if (value < range[0] || value > range[1]) {
        return NaN;
      }
      return this.values[0];
    };
    return Identity2;
  }(base_default4);
  var identity_default2 = Identity;

  // node_modules/@antv/scale/esm/util/pretty-number.js
  function prettyNumber(n) {
    return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
  }

  // node_modules/@antv/scale/esm/util/extended.js
  var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
  var eps = Number.EPSILON * 100;
  function mod2(n, m) {
    return (n % m + m) % m;
  }
  function round3(n) {
    return Math.round(n * 1e12) / 1e12;
  }
  function simplicity(q, Q, j, lmin, lmax, lstep) {
    var n = size2(Q);
    var i = index_of_default(Q, q);
    var v = 0;
    var m = mod2(lmin, lstep);
    if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
      v = 1;
    }
    return 1 - i / (n - 1) - j + v;
  }
  function simplicityMax(q, Q, j) {
    var n = size2(Q);
    var i = index_of_default(Q, q);
    var v = 1;
    return 1 - i / (n - 1) - j + v;
  }
  function density(k, m, dMin, dMax, lMin, lMax) {
    var r = (k - 1) / (lMax - lMin);
    var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
    return 2 - Math.max(r / rt, rt / r);
  }
  function densityMax(k, m) {
    if (k >= m) {
      return 2 - (k - 1) / (m - 1);
    }
    return 1;
  }
  function coverage(dMin, dMax, lMin, lMax) {
    var range = dMax - dMin;
    return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
  }
  function coverageMax(dMin, dMax, span) {
    var range = dMax - dMin;
    if (span > range) {
      var half = (span - range) / 2;
      return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
    }
    return 1;
  }
  function legibility() {
    return 1;
  }
  function extended(dMin, dMax, n, onlyLoose, Q, w) {
    if (n === void 0) {
      n = 5;
    }
    if (onlyLoose === void 0) {
      onlyLoose = true;
    }
    if (Q === void 0) {
      Q = DEFAULT_Q;
    }
    if (w === void 0) {
      w = [0.25, 0.2, 0.5, 0.05];
    }
    var m = n < 0 ? 0 : Math.round(n);
    if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
      return {
        min: 0,
        max: 0,
        ticks: []
      };
    }
    if (dMax - dMin < 1e-15 || m === 1) {
      return {
        min: dMin,
        max: dMax,
        ticks: [dMin]
      };
    }
    var best = {
      score: -2,
      lmin: 0,
      lmax: 0,
      lstep: 0
    };
    var j = 1;
    while (j < Infinity) {
      for (var i = 0; i < Q.length; i += 1) {
        var q = Q[i];
        var sm = simplicityMax(q, Q, j);
        if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
          j = Infinity;
          break;
        }
        var k = 2;
        while (k < Infinity) {
          var dm = densityMax(k, m);
          if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
            break;
          }
          var delta = (dMax - dMin) / (k + 1) / j / q;
          var z = Math.ceil(Math.log10(delta));
          while (z < Infinity) {
            var step = j * q * Math.pow(10, z);
            var cm = coverageMax(dMin, dMax, step * (k - 1));
            if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
              break;
            }
            var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
            var maxStart = Math.ceil(dMin / step) * j;
            if (minStart <= maxStart) {
              var count = maxStart - minStart;
              for (var i_1 = 0; i_1 <= count; i_1 += 1) {
                var start = minStart + i_1;
                var lMin = start * (step / j);
                var lMax = lMin + step * (k - 1);
                var lStep = step;
                var s = simplicity(q, Q, j, lMin, lMax, lStep);
                var c = coverage(dMin, dMax, lMin, lMax);
                var g = density(k, m, dMin, dMax, lMin, lMax);
                var l = legibility();
                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
                if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                  best.lmin = lMin;
                  best.lmax = lMax;
                  best.lstep = lStep;
                  best.score = score;
                }
              }
            }
            z += 1;
          }
          k += 1;
        }
      }
      j += 1;
    }
    var lmax = prettyNumber(best.lmax);
    var lmin = prettyNumber(best.lmin);
    var lstep = prettyNumber(best.lstep);
    var tickCount = Math.floor(round3((lmax - lmin) / lstep)) + 1;
    var ticks = new Array(tickCount);
    ticks[0] = prettyNumber(lmin);
    for (var i = 1; i < tickCount; i++) {
      ticks[i] = prettyNumber(ticks[i - 1] + lstep);
    }
    return {
      min: Math.min(dMin, head(ticks)),
      max: Math.max(dMax, last(ticks)),
      ticks
    };
  }

  // node_modules/@antv/scale/esm/tick-method/cat.js
  function calculateCatTicks(cfg) {
    var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount;
    var ticks = values2;
    if (is_number_default(tickInterval)) {
      return filter_default(ticks, function(__, i) {
        return i % tickInterval === 0;
      });
    }
    var min3 = cfg.min, max3 = cfg.max;
    if (is_nil_default(min3)) {
      min3 = 0;
    }
    if (is_nil_default(max3)) {
      max3 = values2.length - 1;
    }
    if (is_number_default(tickCount) && tickCount < max3 - min3) {
      var ticks_1 = extended(min3, max3, tickCount, false, [1, 2, 5, 3, 4, 7, 6, 8, 9]).ticks;
      var valid = filter_default(ticks_1, function(tick2) {
        return tick2 >= min3 && tick2 <= max3;
      });
      return valid.map(function(index) {
        return values2[index];
      });
    }
    return values2.slice(min3, max3 + 1);
  }

  // node_modules/@antv/scale/esm/util/d3-linear.js
  function d3Linear(cfg) {
    var min3 = cfg.min, max3 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
    var linear4 = new D3Linear();
    linear4.domain([min3, max3]);
    if (nice) {
      linear4.nice(tickCount);
    }
    return linear4.ticks(tickCount);
  }
  var DEFAULT_COUNT = 5;
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  var D3Linear = function() {
    function D3Linear2() {
      this._domain = [0, 1];
    }
    D3Linear2.prototype.domain = function(domain) {
      if (domain) {
        this._domain = Array.from(domain, Number);
        return this;
      }
      return this._domain.slice();
    };
    D3Linear2.prototype.nice = function(count) {
      var _a4, _b;
      if (count === void 0) {
        count = DEFAULT_COUNT;
      }
      var d = this._domain.slice();
      var i0 = 0;
      var i1 = this._domain.length - 1;
      var start = this._domain[i0];
      var stop2 = this._domain[i1];
      var step;
      if (stop2 < start) {
        _a4 = [stop2, start], start = _a4[0], stop2 = _a4[1];
        _b = [i1, i0], i0 = _b[0], i1 = _b[1];
      }
      step = tickIncrement(start, stop2, count);
      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop2 = Math.ceil(stop2 / step) * step;
        step = tickIncrement(start, stop2, count);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop2 = Math.floor(stop2 * step) / step;
        step = tickIncrement(start, stop2, count);
      }
      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop2 / step) * step;
        this.domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop2 * step) / step;
        this.domain(d);
      }
      return this;
    };
    D3Linear2.prototype.ticks = function(count) {
      if (count === void 0) {
        count = DEFAULT_COUNT;
      }
      return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
    };
    return D3Linear2;
  }();
  function d3ArrayTicks(start, stop2, count) {
    var reverse;
    var i = -1;
    var n;
    var ticks;
    var step;
    stop2 = +stop2, start = +start, count = +count;
    if (start === stop2 && count > 0) {
      return [start];
    }
    if (reverse = stop2 < start) {
      n = start, start = stop2, stop2 = n;
    }
    if ((step = tickIncrement(start, stop2, count)) === 0 || !isFinite(step)) {
      return [];
    }
    if (step > 0) {
      start = Math.ceil(start / step);
      stop2 = Math.floor(stop2 / step);
      ticks = new Array(n = Math.ceil(stop2 - start + 1));
      while (++i < n) {
        ticks[i] = (start + i) * step;
      }
    } else {
      start = Math.floor(start * step);
      stop2 = Math.ceil(stop2 * step);
      ticks = new Array(n = Math.ceil(start - stop2 + 1));
      while (++i < n) {
        ticks[i] = (start - i) / step;
      }
    }
    if (reverse) {
      ticks.reverse();
    }
    return ticks;
  }
  function tickIncrement(start, stop2, count) {
    var step = (stop2 - start) / Math.max(0, count);
    var power = Math.floor(Math.log(step) / Math.LN10);
    var error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  // node_modules/@antv/scale/esm/util/interval.js
  function snapMultiple(v, base, snapType) {
    var div3;
    if (snapType === "ceil") {
      div3 = Math.ceil(v / base);
    } else if (snapType === "floor") {
      div3 = Math.floor(v / base);
    } else {
      div3 = Math.round(v / base);
    }
    return div3 * base;
  }
  function intervalTicks(min3, max3, interval2) {
    var minTick = snapMultiple(min3, interval2, "floor");
    var maxTick = snapMultiple(max3, interval2, "ceil");
    minTick = fixed_base_default(minTick, interval2);
    maxTick = fixed_base_default(maxTick, interval2);
    var ticks = [];
    for (var i = minTick; i <= maxTick; i = i + interval2) {
      var tickValue = fixed_base_default(i, interval2);
      ticks.push(tickValue);
    }
    return {
      min: minTick,
      max: maxTick,
      ticks
    };
  }

  // node_modules/@antv/scale/esm/util/strict-limit.js
  function strictLimit(cfg, defaultMin, defaultMax) {
    var _a4;
    var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min3 = cfg.min, max3 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
    var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min3 : defaultMin : minLimit;
    var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max3 : defaultMax : maxLimit;
    if (tickMin > tickMax) {
      _a4 = [tickMin, tickMax], tickMax = _a4[0], tickMin = _a4[1];
    }
    if (tickCount <= 2) {
      return [tickMin, tickMax];
    }
    var step = (tickMax - tickMin) / (tickCount - 1);
    var ticks = [];
    for (var i = 0; i < tickCount; i++) {
      ticks.push(tickMin + step * i);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/d3-linear.js
  function d3LinearTickMethod(cfg) {
    var min3 = cfg.min, max3 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = d3Linear(cfg);
    if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
      return strictLimit(cfg, head(ticks), last(ticks));
    }
    if (tickInterval) {
      return intervalTicks(min3, max3, tickInterval).ticks;
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/linear.js
  function linear3(cfg) {
    var min3 = cfg.min, max3 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = extended(min3, max3, tickCount, nice).ticks;
    if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
      return strictLimit(cfg, head(ticks), last(ticks));
    }
    if (tickInterval) {
      return intervalTicks(min3, max3, tickInterval).ticks;
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/log.js
  function calculateLogTicks(cfg) {
    var base = cfg.base, tickCount = cfg.tickCount, min3 = cfg.min, max3 = cfg.max, values2 = cfg.values;
    var minTick;
    var maxTick = log(base, max3);
    if (min3 > 0) {
      minTick = Math.floor(log(base, min3));
    } else {
      var positiveMin = getLogPositiveMin(values2, base, max3);
      minTick = Math.floor(log(base, positiveMin));
    }
    var count = maxTick - minTick;
    var avg2 = Math.ceil(count / tickCount);
    var ticks = [];
    for (var i = minTick; i < maxTick + avg2; i = i + avg2) {
      ticks.push(Math.pow(base, i));
    }
    if (min3 <= 0) {
      ticks.unshift(0);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/util/pretty.js
  function pretty(min3, max3, m) {
    if (m === void 0) {
      m = 5;
    }
    if (min3 === max3) {
      return {
        max: max3,
        min: min3,
        ticks: [min3]
      };
    }
    var n = m < 0 ? 0 : Math.round(m);
    if (n === 0)
      return { max: max3, min: min3, ticks: [] };
    var h2 = 1.5;
    var h5 = 0.5 + 1.5 * h2;
    var d = max3 - min3;
    var c = d / n;
    var base = Math.pow(10, Math.floor(Math.log10(c)));
    var unit = base;
    if (2 * base - c < h2 * (c - unit)) {
      unit = 2 * base;
      if (5 * base - c < h5 * (c - unit)) {
        unit = 5 * base;
        if (10 * base - c < h2 * (c - unit)) {
          unit = 10 * base;
        }
      }
    }
    var nu = Math.ceil(max3 / unit);
    var ns = Math.floor(min3 / unit);
    var hi = Math.max(nu * unit, max3);
    var lo = Math.min(ns * unit, min3);
    var size3 = Math.floor((hi - lo) / unit) + 1;
    var ticks = new Array(size3);
    for (var i = 0; i < size3; i++) {
      ticks[i] = prettyNumber(lo + i * unit);
    }
    return {
      min: lo,
      max: hi,
      ticks
    };
  }

  // node_modules/@antv/scale/esm/tick-method/pow.js
  function calculatePowTicks(cfg) {
    var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
    var max3 = Math.ceil(calBase(exponent2, cfg.max));
    var min3 = Math.floor(calBase(exponent2, cfg.min));
    var ticks = pretty(min3, max3, tickCount).ticks;
    return ticks.map(function(tick2) {
      var factor = tick2 >= 0 ? 1 : -1;
      return Math.pow(tick2, exponent2) * factor;
    });
  }

  // node_modules/@antv/scale/esm/tick-method/quantile.js
  function quantileSorted(x, p2) {
    var idx = x.length * p2;
    if (p2 === 1) {
      return x[x.length - 1];
    } else if (p2 === 0) {
      return x[0];
    } else if (idx % 1 !== 0) {
      return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
      return (x[idx - 1] + x[idx]) / 2;
    } else {
      return x[idx];
    }
  }
  function calculateTicks(cfg) {
    var tickCount = cfg.tickCount, values2 = cfg.values;
    if (!values2 || !values2.length) {
      return [];
    }
    var sorted = values2.slice().sort(function(a, b) {
      return a - b;
    });
    var ticks = [];
    for (var i = 0; i < tickCount; i++) {
      var p2 = i / (tickCount - 1);
      ticks.push(quantileSorted(sorted, p2));
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/r-prettry.js
  function linearPretty(cfg) {
    var min3 = cfg.min, max3 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = pretty(min3, max3, tickCount).ticks;
    if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
      return strictLimit(cfg, head(ticks), last(ticks));
    }
    if (tickInterval) {
      return intervalTicks(min3, max3, tickInterval).ticks;
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/time.js
  function calculateTimeTicks(cfg) {
    var min3 = cfg.min, max3 = cfg.max, minTickInterval = cfg.minTickInterval;
    var tickInterval = cfg.tickInterval;
    var tickCount = cfg.tickCount;
    if (tickInterval) {
      tickCount = Math.ceil((max3 - min3) / tickInterval);
    } else {
      tickInterval = getTickInterval(min3, max3, tickCount)[1];
      var count = (max3 - min3) / tickInterval;
      var ratio = count / tickCount;
      if (ratio > 1) {
        tickInterval = tickInterval * Math.ceil(ratio);
      }
      if (minTickInterval && tickInterval < minTickInterval) {
        tickInterval = minTickInterval;
      }
    }
    var ticks = [];
    for (var i = min3; i < max3 + tickInterval; i += tickInterval) {
      ticks.push(i);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/time-cat.js
  function calculateTimeCatTicks(cfg) {
    var ticks = calculateCatTicks(cfg);
    var lastValue = last(cfg.values);
    if (lastValue !== last(ticks)) {
      ticks.push(lastValue);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/time-pretty.js
  function getYear(date) {
    return new Date(date).getFullYear();
  }
  function createYear(year) {
    return new Date(year, 0, 1).getTime();
  }
  function getMonth(date) {
    return new Date(date).getMonth();
  }
  function diffMonth(min3, max3) {
    var minYear = getYear(min3);
    var maxYear = getYear(max3);
    var minMonth = getMonth(min3);
    var maxMonth = getMonth(max3);
    return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
  }
  function creatMonth(year, month) {
    return new Date(year, month, 1).getTime();
  }
  function diffDay(min3, max3) {
    return Math.ceil((max3 - min3) / DAY);
  }
  function diffHour(min3, max3) {
    return Math.ceil((max3 - min3) / HOUR);
  }
  function diffMinus(min3, max3) {
    return Math.ceil((max3 - min3) / (60 * 1e3));
  }
  function timePretty(cfg) {
    var min3 = cfg.min, max3 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
    var tickInterval = cfg.tickInterval;
    var ticks = [];
    if (!tickInterval) {
      tickInterval = (max3 - min3) / tickCount;
      if (minTickInterval && tickInterval < minTickInterval) {
        tickInterval = minTickInterval;
      }
    }
    var minYear = getYear(min3);
    if (tickInterval > YEAR) {
      var maxYear = getYear(max3);
      var yearInterval = Math.ceil(tickInterval / YEAR);
      for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
        ticks.push(createYear(i));
      }
    } else if (tickInterval > MONTH) {
      var monthInterval = Math.ceil(tickInterval / MONTH);
      var mmMoth = getMonth(min3);
      var dMonths = diffMonth(min3, max3);
      for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
        ticks.push(creatMonth(minYear, i + mmMoth));
      }
    } else if (tickInterval > DAY) {
      var date = new Date(min3);
      var year = date.getFullYear();
      var month = date.getMonth();
      var mday = date.getDate();
      var day = Math.ceil(tickInterval / DAY);
      var ddays = diffDay(min3, max3);
      for (var i = 0; i < ddays + day; i = i + day) {
        ticks.push(new Date(year, month, mday + i).getTime());
      }
    } else if (tickInterval > HOUR) {
      var date = new Date(min3);
      var year = date.getFullYear();
      var month = date.getMonth();
      var day = date.getDate();
      var hour = date.getHours();
      var hours = Math.ceil(tickInterval / HOUR);
      var dHours = diffHour(min3, max3);
      for (var i = 0; i <= dHours + hours; i = i + hours) {
        ticks.push(new Date(year, month, day, hour + i).getTime());
      }
    } else if (tickInterval > MINUTE) {
      var dMinus = diffMinus(min3, max3);
      var minutes = Math.ceil(tickInterval / MINUTE);
      for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
        ticks.push(min3 + i * MINUTE);
      }
    } else {
      var interval2 = tickInterval;
      if (interval2 < SECOND) {
        interval2 = SECOND;
      }
      var minSecond = Math.floor(min3 / SECOND) * SECOND;
      var dSeconds = Math.ceil((max3 - min3) / SECOND);
      var seconds = Math.ceil(interval2 / SECOND);
      for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
        ticks.push(minSecond + i * SECOND);
      }
    }
    if (ticks.length >= 512) {
      console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/index.js
  registerTickMethod("cat", calculateCatTicks);
  registerTickMethod("time-cat", calculateTimeCatTicks);
  registerTickMethod("wilkinson-extended", linear3);
  registerTickMethod("r-pretty", linearPretty);
  registerTickMethod("time", calculateTimeTicks);
  registerTickMethod("time-pretty", timePretty);
  registerTickMethod("log", calculateLogTicks);
  registerTickMethod("pow", calculatePowTicks);
  registerTickMethod("quantile", calculateTicks);
  registerTickMethod("d3-linear", d3LinearTickMethod);

  // node_modules/@antv/scale/esm/index.js
  registerClass("cat", base_default5);
  registerClass("category", base_default5);
  registerClass("identity", identity_default2);
  registerClass("linear", linear_default);
  registerClass("log", log_default);
  registerClass("pow", pow_default);
  registerClass("time", time_default2);
  registerClass("timeCat", time_default);
  registerClass("quantize", quantize_default);
  registerClass("quantile", quantile_default);

  // node_modules/@antv/attr/esm/factory.js
  var ATTRIBUTE_MAP = {};
  var getAttribute = function(type) {
    return ATTRIBUTE_MAP[type.toLowerCase()];
  };
  var registerAttribute = function(type, ctor) {
    if (getAttribute(type)) {
      throw new Error("Attribute type '" + type + "' existed.");
    }
    ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
  };

  // node_modules/@antv/attr/esm/index.js
  registerAttribute("Color", color_default);
  registerAttribute("Opacity", opacity_default);
  registerAttribute("Position", position_default);
  registerAttribute("Shape", shape_default2);
  registerAttribute("Size", size_default);

  // node_modules/@antv/coord/node_modules/tslib/modules/index.js
  var import_tslib33 = __toModule(require_tslib6());
  var {
    __extends: __extends6,
    __assign: __assign6,
    __rest: __rest6,
    __decorate: __decorate6,
    __param: __param6,
    __metadata: __metadata6,
    __awaiter: __awaiter6,
    __generator: __generator6,
    __exportStar: __exportStar6,
    __createBinding: __createBinding6,
    __values: __values6,
    __read: __read6,
    __spread: __spread6,
    __spreadArrays: __spreadArrays6,
    __spreadArray: __spreadArray5,
    __await: __await6,
    __asyncGenerator: __asyncGenerator6,
    __asyncDelegator: __asyncDelegator6,
    __asyncValues: __asyncValues6,
    __makeTemplateObject: __makeTemplateObject6,
    __importStar: __importStar6,
    __importDefault: __importDefault6,
    __classPrivateFieldGet: __classPrivateFieldGet6,
    __classPrivateFieldSet: __classPrivateFieldSet6
  } = import_tslib33.default;

  // node_modules/@antv/coord/esm/coord/base.js
  var Coordinate = function() {
    function Coordinate2(cfg) {
      this.type = "coordinate";
      this.isRect = false;
      this.isHelix = false;
      this.isPolar = false;
      this.isReflectX = false;
      this.isReflectY = false;
      var start = cfg.start, end = cfg.end, _a4 = cfg.matrix, matrix = _a4 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a4, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
      this.start = start;
      this.end = end;
      this.matrix = matrix;
      this.originalMatrix = __spreadArray5([], matrix);
      this.isTransposed = isTransposed;
    }
    Coordinate2.prototype.initial = function() {
      this.center = {
        x: (this.start.x + this.end.x) / 2,
        y: (this.start.y + this.end.y) / 2
      };
      this.width = Math.abs(this.end.x - this.start.x);
      this.height = Math.abs(this.end.y - this.start.y);
    };
    Coordinate2.prototype.update = function(cfg) {
      mix(this, cfg);
      this.initial();
    };
    Coordinate2.prototype.convertDim = function(percent, dim) {
      var _a4;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a4 = [end, start], start = _a4[0], end = _a4[1];
      }
      return start + percent * (end - start);
    };
    Coordinate2.prototype.invertDim = function(value, dim) {
      var _a4;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a4 = [end, start], start = _a4[0], end = _a4[1];
      }
      return (value - start) / (end - start);
    };
    Coordinate2.prototype.applyMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var vector = [x, y, tag];
      vec3_exports.transformMat3(vector, vector, matrix);
      return vector;
    };
    Coordinate2.prototype.invertMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var inverted = mat3_exports.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
      var vector = [x, y, tag];
      if (inverted) {
        vec3_exports.transformMat3(vector, vector, inverted);
      }
      return vector;
    };
    Coordinate2.prototype.convert = function(point) {
      var _a4 = this.convertPoint(point), x = _a4.x, y = _a4.y;
      var vector = this.applyMatrix(x, y, 1);
      return {
        x: vector[0],
        y: vector[1]
      };
    };
    Coordinate2.prototype.invert = function(point) {
      var vector = this.invertMatrix(point.x, point.y, 1);
      return this.invertPoint({
        x: vector[0],
        y: vector[1]
      });
    };
    Coordinate2.prototype.rotate = function(radian) {
      var matrix = this.matrix;
      var center = this.center;
      ext_exports.leftTranslate(matrix, matrix, [-center.x, -center.y]);
      ext_exports.leftRotate(matrix, matrix, radian);
      ext_exports.leftTranslate(matrix, matrix, [center.x, center.y]);
      return this;
    };
    Coordinate2.prototype.reflect = function(dim) {
      if (dim === "x") {
        this.isReflectX = !this.isReflectX;
      } else {
        this.isReflectY = !this.isReflectY;
      }
      return this;
    };
    Coordinate2.prototype.scale = function(s1, s2) {
      var matrix = this.matrix;
      var center = this.center;
      ext_exports.leftTranslate(matrix, matrix, [-center.x, -center.y]);
      ext_exports.leftScale(matrix, matrix, [s1, s2]);
      ext_exports.leftTranslate(matrix, matrix, [center.x, center.y]);
      return this;
    };
    Coordinate2.prototype.translate = function(x, y) {
      var matrix = this.matrix;
      ext_exports.leftTranslate(matrix, matrix, [x, y]);
      return this;
    };
    Coordinate2.prototype.transpose = function() {
      this.isTransposed = !this.isTransposed;
      return this;
    };
    Coordinate2.prototype.getCenter = function() {
      return this.center;
    };
    Coordinate2.prototype.getWidth = function() {
      return this.width;
    };
    Coordinate2.prototype.getHeight = function() {
      return this.height;
    };
    Coordinate2.prototype.getRadius = function() {
      return this.radius;
    };
    Coordinate2.prototype.isReflect = function(dim) {
      return dim === "x" ? this.isReflectX : this.isReflectY;
    };
    Coordinate2.prototype.resetMatrix = function(matrix) {
      this.matrix = matrix ? matrix : __spreadArray5([], this.originalMatrix);
    };
    return Coordinate2;
  }();
  var base_default7 = Coordinate;

  // node_modules/@antv/coord/esm/coord/cartesian.js
  var Cartesian = function(_super) {
    __extends6(Cartesian2, _super);
    function Cartesian2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isRect = true;
      _this.type = "cartesian";
      _this.initial();
      return _this;
    }
    Cartesian2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var start = this.start;
      var end = this.end;
      this.x = {
        start: start.x,
        end: end.x
      };
      this.y = {
        start: start.y,
        end: end.y
      };
    };
    Cartesian2.prototype.convertPoint = function(point) {
      var _a4;
      var x = point.x, y = point.y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      return {
        x: this.convertDim(x, "x"),
        y: this.convertDim(y, "y")
      };
    };
    Cartesian2.prototype.invertPoint = function(point) {
      var _a4;
      var x = this.invertDim(point.x, "x");
      var y = this.invertDim(point.y, "y");
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      return { x, y };
    };
    return Cartesian2;
  }(base_default7);
  var cartesian_default = Cartesian;

  // node_modules/@antv/coord/esm/coord/helix.js
  var Helix = function(_super) {
    __extends6(Helix2, _super);
    function Helix2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isHelix = true;
      _this.type = "helix";
      var _a4 = cfg.startAngle, startAngle = _a4 === void 0 ? 1.25 * Math.PI : _a4, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Helix2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
      var maxRadius = Math.min(this.width, this.height) / 2;
      if (this.radius && this.radius >= 0 && this.radius <= 1) {
        maxRadius = maxRadius * this.radius;
      }
      this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);
      this.a = this.d / (Math.PI * 2);
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * maxRadius,
        end: this.innerRadius * maxRadius + this.d * 0.99
      };
    };
    Helix2.prototype.convertPoint = function(point) {
      var _a4;
      var x = point.x, y = point.y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      var thi = this.convertDim(x, "x");
      var r = this.a * thi;
      var newY = this.convertDim(y, "y");
      return {
        x: this.center.x + Math.cos(thi) * (r + newY),
        y: this.center.y + Math.sin(thi) * (r + newY)
      };
    };
    Helix2.prototype.invertPoint = function(point) {
      var _a4;
      var d = this.d + this.y.start;
      var v = vec2_exports.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);
      var thi = ext_exports.angleTo(v, [1, 0], true);
      var rMin = thi * this.a;
      if (vec2_exports.length(v) < rMin) {
        rMin = vec2_exports.length(v);
      }
      var index = Math.floor((vec2_exports.length(v) - rMin) / d);
      thi = 2 * index * Math.PI + thi;
      var r = this.a * thi;
      var newY = vec2_exports.length(v) - r;
      newY = isNumberEqual(newY, 0) ? 0 : newY;
      var x = this.invertDim(thi, "x");
      var y = this.invertDim(newY, "y");
      x = isNumberEqual(x, 0) ? 0 : x;
      y = isNumberEqual(y, 0) ? 0 : y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      return { x, y };
    };
    return Helix2;
  }(base_default7);
  var helix_default = Helix;

  // node_modules/@antv/coord/esm/coord/polar.js
  var Polar = function(_super) {
    __extends6(Polar2, _super);
    function Polar2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isPolar = true;
      _this.type = "polar";
      var _a4 = cfg.startAngle, startAngle = _a4 === void 0 ? -Math.PI / 2 : _a4, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Polar2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      while (this.endAngle < this.startAngle) {
        this.endAngle += Math.PI * 2;
      }
      var oneBox = this.getOneBox();
      var oneWidth = oneBox.maxX - oneBox.minX;
      var oneHeight = oneBox.maxY - oneBox.minY;
      var left = Math.abs(oneBox.minX) / oneWidth;
      var top = Math.abs(oneBox.minY) / oneHeight;
      var maxRadius;
      if (this.height / oneHeight > this.width / oneWidth) {
        maxRadius = this.width / oneWidth;
        this.circleCenter = {
          x: this.center.x - (0.5 - left) * this.width,
          y: this.center.y - (0.5 - top) * maxRadius * oneHeight
        };
      } else {
        maxRadius = this.height / oneHeight;
        this.circleCenter = {
          x: this.center.x - (0.5 - left) * maxRadius * oneWidth,
          y: this.center.y - (0.5 - top) * this.height
        };
      }
      this.polarRadius = this.radius;
      if (!this.radius) {
        this.polarRadius = maxRadius;
      } else if (this.radius > 0 && this.radius <= 1) {
        this.polarRadius = maxRadius * this.radius;
      } else if (this.radius <= 0 || this.radius > maxRadius) {
        this.polarRadius = maxRadius;
      }
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * this.polarRadius,
        end: this.polarRadius
      };
    };
    Polar2.prototype.getRadius = function() {
      return this.polarRadius;
    };
    Polar2.prototype.convertPoint = function(point) {
      var _a4;
      var center = this.getCenter();
      var x = point.x, y = point.y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      x = this.convertDim(x, "x");
      y = this.convertDim(y, "y");
      return {
        x: center.x + Math.cos(x) * y,
        y: center.y + Math.sin(x) * y
      };
    };
    Polar2.prototype.invertPoint = function(point) {
      var _a4;
      var center = this.getCenter();
      var vPoint = [point.x - center.x, point.y - center.y];
      var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
      if (this.isReflect("x")) {
        _a4 = [endAngle, startAngle], startAngle = _a4[0], endAngle = _a4[1];
      }
      var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      ext_exports.leftRotate(m, m, startAngle);
      var vStart3 = [1, 0, 0];
      vec3_exports.transformMat3(vStart3, vStart3, m);
      var vStart2 = [vStart3[0], vStart3[1]];
      var angle3 = ext_exports.angleTo(vStart2, vPoint, endAngle < startAngle);
      if (isNumberEqual(angle3, Math.PI * 2)) {
        angle3 = 0;
      }
      var radius = vec2_exports.length(vPoint);
      var xPercent = angle3 / (endAngle - startAngle);
      xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
      var yPercent = this.invertDim(radius, "y");
      var rst = { x: 0, y: 0 };
      rst.x = this.isTransposed ? yPercent : xPercent;
      rst.y = this.isTransposed ? xPercent : yPercent;
      return rst;
    };
    Polar2.prototype.getCenter = function() {
      return this.circleCenter;
    };
    Polar2.prototype.getOneBox = function() {
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
        return {
          minX: -1,
          maxX: 1,
          minY: -1,
          maxY: 1
        };
      }
      var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
      var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
      for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
        xs.push(Math.cos(i));
        ys.push(Math.sin(i));
      }
      return {
        minX: Math.min.apply(Math, xs),
        maxX: Math.max.apply(Math, xs),
        minY: Math.min.apply(Math, ys),
        maxY: Math.max.apply(Math, ys)
      };
    };
    return Polar2;
  }(base_default7);
  var polar_default = Polar;

  // node_modules/@antv/coord/esm/factory.js
  var COORDINATE_MAP = {};
  var getCoordinate = function(type) {
    return COORDINATE_MAP[type.toLowerCase()];
  };
  var registerCoordinate = function(type, ctor) {
    COORDINATE_MAP[type.toLowerCase()] = ctor;
  };

  // node_modules/@antv/coord/esm/index.js
  registerCoordinate("rect", cartesian_default);
  registerCoordinate("cartesian", cartesian_default);
  registerCoordinate("polar", polar_default);
  registerCoordinate("helix", helix_default);

  // node_modules/@antv/component/esm/annotation/index.js
  var annotation_exports = {};
  __export(annotation_exports, {
    Arc: () => arc_default2,
    DataMarker: () => data_marker_default,
    DataRegion: () => data_region_default,
    Html: () => html_default,
    Image: () => image_default,
    Line: () => line_default4,
    Region: () => region_default,
    RegionFilter: () => region_filter_default,
    Shape: () => shape_default4,
    Text: () => text_default3
  });

  // node_modules/@antv/component/node_modules/tslib/modules/index.js
  var import_tslib38 = __toModule(require_tslib7());
  var {
    __extends: __extends7,
    __assign: __assign7,
    __rest: __rest7,
    __decorate: __decorate7,
    __param: __param7,
    __metadata: __metadata7,
    __awaiter: __awaiter7,
    __generator: __generator7,
    __exportStar: __exportStar7,
    __createBinding: __createBinding7,
    __values: __values7,
    __read: __read7,
    __spread: __spread7,
    __spreadArrays: __spreadArrays7,
    __spreadArray: __spreadArray6,
    __await: __await7,
    __asyncGenerator: __asyncGenerator7,
    __asyncDelegator: __asyncDelegator7,
    __asyncValues: __asyncValues7,
    __makeTemplateObject: __makeTemplateObject7,
    __importStar: __importStar7,
    __importDefault: __importDefault7,
    __classPrivateFieldGet: __classPrivateFieldGet7,
    __classPrivateFieldSet: __classPrivateFieldSet7
  } = import_tslib38.default;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/path.js
  var SPACES3 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
  var PATH_COMMAND3 = new RegExp("([a-z])[" + SPACES3 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES3 + "]*,?[" + SPACES3 + "]*)+)", "ig");
  var PATH_VALUES3 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES3 + "]*,?[" + SPACES3 + "]*", "ig");
  var parsePathString3 = function(pathString) {
    if (!pathString) {
      return null;
    }
    if (is_array_default(pathString)) {
      return pathString;
    }
    var paramCounts = {
      a: 7,
      c: 6,
      o: 2,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      u: 3,
      z: 0
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND3, function(a, b, c) {
      var params = [];
      var name = b.toLowerCase();
      c.replace(PATH_VALUES3, function(a2, b10) {
        b10 && params.push(+b10);
      });
      if (name === "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = "l";
        b = b === "m" ? "l" : "L";
      }
      if (name === "o" && params.length === 1) {
        data.push([b, params[0]]);
      }
      if (name === "r") {
        data.push([b].concat(params));
      } else {
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      }
      return pathString;
    });
    return data;
  };
  var isEqual3 = function(obj1, obj2) {
    if (obj1.length !== obj2.length) {
      return false;
    }
    var result = true;
    each_default(obj1, function(item, i) {
      if (item !== obj2[i]) {
        result = false;
        return false;
      }
    });
    return result;
  };
  function getMinDiff2(del, add5, modify) {
    var type = null;
    var min3 = modify;
    if (add5 < min3) {
      min3 = add5;
      type = "add";
    }
    if (del < min3) {
      min3 = del;
      type = "del";
    }
    return {
      type,
      min: min3
    };
  }
  var levenshteinDistance2 = function(source, target) {
    var sourceLen = source.length;
    var targetLen = target.length;
    var sourceSegment;
    var targetSegment;
    var temp = 0;
    if (sourceLen === 0 || targetLen === 0) {
      return null;
    }
    var dist3 = [];
    for (var i = 0; i <= sourceLen; i++) {
      dist3[i] = [];
      dist3[i][0] = { min: i };
    }
    for (var j = 0; j <= targetLen; j++) {
      dist3[0][j] = { min: j };
    }
    for (var i = 1; i <= sourceLen; i++) {
      sourceSegment = source[i - 1];
      for (var j = 1; j <= targetLen; j++) {
        targetSegment = target[j - 1];
        if (isEqual3(sourceSegment, targetSegment)) {
          temp = 0;
        } else {
          temp = 1;
        }
        var del = dist3[i - 1][j].min + 1;
        var add5 = dist3[i][j - 1].min + 1;
        var modify = dist3[i - 1][j - 1].min + temp;
        dist3[i][j] = getMinDiff2(del, add5, modify);
      }
    }
    return dist3;
  };
  var fillPathByDiff3 = function(source, target) {
    var diffMatrix = levenshteinDistance2(source, target);
    var sourceLen = source.length;
    var targetLen = target.length;
    var changes = [];
    var index = 1;
    var minPos = 1;
    if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
      for (var i = 1; i <= sourceLen; i++) {
        var min3 = diffMatrix[i][i].min;
        minPos = i;
        for (var j = index; j <= targetLen; j++) {
          if (diffMatrix[i][j].min < min3) {
            min3 = diffMatrix[i][j].min;
            minPos = j;
          }
        }
        index = minPos;
        if (diffMatrix[i][index].type) {
          changes.push({ index: i - 1, type: diffMatrix[i][index].type });
        }
      }
      for (var i = changes.length - 1; i >= 0; i--) {
        index = changes[i].index;
        if (changes[i].type === "add") {
          source.splice(index, 0, [].concat(source[index]));
        } else {
          source.splice(index, 1);
        }
      }
    }
    sourceLen = source.length;
    var diff2 = targetLen - sourceLen;
    if (sourceLen < targetLen) {
      for (var i = 0; i < diff2; i++) {
        if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
          source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
        } else {
          source.push(source[sourceLen - 1]);
        }
        sourceLen += 1;
      }
    }
    return source;
  };
  function _splitPoints2(points, former, count) {
    var result = [].concat(points);
    var index;
    var t = 1 / (count + 1);
    var formerEnd = _getSegmentPoints2(former)[0];
    for (var i = 1; i <= count; i++) {
      t *= i;
      index = Math.floor(points.length * t);
      if (index === 0) {
        result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
      } else {
        result.splice(index, 0, [
          formerEnd[0] * t + points[index][0] * (1 - t),
          formerEnd[1] * t + points[index][1] * (1 - t)
        ]);
      }
    }
    return result;
  }
  function _getSegmentPoints2(segment) {
    var points = [];
    switch (segment[0]) {
      case "M":
        points.push([segment[1], segment[2]]);
        break;
      case "L":
        points.push([segment[1], segment[2]]);
        break;
      case "A":
        points.push([segment[6], segment[7]]);
        break;
      case "Q":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "T":
        points.push([segment[1], segment[2]]);
        break;
      case "C":
        points.push([segment[5], segment[6]]);
        points.push([segment[1], segment[2]]);
        points.push([segment[3], segment[4]]);
        break;
      case "S":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "H":
        points.push([segment[1], segment[1]]);
        break;
      case "V":
        points.push([segment[1], segment[1]]);
        break;
      default:
    }
    return points;
  }
  var formatPath3 = function(fromPath, toPath) {
    if (fromPath.length <= 1) {
      return fromPath;
    }
    var points;
    for (var i = 0; i < toPath.length; i++) {
      if (fromPath[i][0] !== toPath[i][0]) {
        points = _getSegmentPoints2(fromPath[i]);
        switch (toPath[i][0]) {
          case "M":
            fromPath[i] = ["M"].concat(points[0]);
            break;
          case "L":
            fromPath[i] = ["L"].concat(points[0]);
            break;
          case "A":
            fromPath[i] = [].concat(toPath[i]);
            fromPath[i][6] = points[0][0];
            fromPath[i][7] = points[0][1];
            break;
          case "Q":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints2(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "T":
            fromPath[i] = ["T"].concat(points[0]);
            break;
          case "C":
            if (points.length < 3) {
              if (i > 0) {
                points = _splitPoints2(points, fromPath[i - 1], 2);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "S":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints2(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          default:
            fromPath[i] = toPath[i];
        }
      }
    }
    return fromPath;
  };

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/event/graph-event.js
  var GraphEvent2 = function() {
    function GraphEvent3(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent3.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent3.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent3.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent3.prototype.save = function() {
    };
    GraphEvent3.prototype.restore = function() {
    };
    return GraphEvent3;
  }();
  var graph_event_default2 = GraphEvent2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/util.js
  function removeFromArray2(arr, obj) {
    var index = arr.indexOf(obj);
    if (index !== -1) {
      arr.splice(index, 1);
    }
  }
  var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isParent2(container, shape) {
    if (container.isCanvas()) {
      return true;
    }
    var parent = shape.getParent();
    var isParent3 = false;
    while (parent) {
      if (parent === container) {
        isParent3 = true;
        break;
      }
      parent = parent.getParent();
    }
    return isParent3;
  }
  function isAllowCapture2(element) {
    return element.cfg.visible && element.cfg.capture;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/base.js
  var Base3 = function(_super) {
    __extends7(Base4, _super);
    function Base4(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base4.prototype.getDefaultCfg = function() {
      return {};
    };
    Base4.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base4.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base4.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base4;
  }(esm_default);
  var base_default8 = Base3;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/matrix.js
  function multiplyMatrix2(a, b) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b00 = b[0];
    var b01 = b[1];
    var b02 = b[2];
    var b10 = b[3];
    var b11 = b[4];
    var b12 = b[5];
    var b20 = b[6];
    var b21 = b[7];
    var b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function multiplyVec22(m, v) {
    var out = [];
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function invert3(a) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/element.js
  var transform3 = ext_exports.transform;
  var MATRIX2 = "matrix";
  var CLONE_CFGS2 = ["zIndex", "capture", "visible", "type"];
  var RESERVED_PORPS2 = ["repeat"];
  var DELEGATION_SPLIT2 = ":";
  var WILDCARD3 = "*";
  function _cloneArrayAttr2(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
      if (is_array_default(arr[i])) {
        result.push([].concat(arr[i]));
      } else {
        result.push(arr[i]);
      }
    }
    return result;
  }
  function getFormatFromAttrs2(toAttrs, shape) {
    var fromAttrs = {};
    var attrs = shape.attrs;
    for (var k in toAttrs) {
      fromAttrs[k] = attrs[k];
    }
    return fromAttrs;
  }
  function getFormatToAttrs2(props, shape) {
    var toAttrs = {};
    var attrs = shape.attr();
    each_default(props, function(v, k) {
      if (RESERVED_PORPS2.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
        toAttrs[k] = v;
      }
    });
    return toAttrs;
  }
  function checkExistedAttrs2(animations, animation) {
    if (animation.onFrame) {
      return animations;
    }
    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
    var hasOwnProperty5 = Object.prototype.hasOwnProperty;
    each_default(animations, function(item) {
      if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
        each_default(animation.toAttrs, function(v, k) {
          if (hasOwnProperty5.call(item.toAttrs, k)) {
            delete item.toAttrs[k];
            delete item.fromAttrs[k];
          }
        });
      }
    });
    return animations;
  }
  var Element3 = function(_super) {
    __extends7(Element5, _super);
    function Element5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element5.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element5.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element5.prototype.onCanvasChange = function(changeType) {
    };
    Element5.prototype.initAttrs = function(attrs) {
    };
    Element5.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element5.prototype.isGroup = function() {
      return false;
    };
    Element5.prototype.getParent = function() {
      return this.get("parent");
    };
    Element5.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element5.prototype.attr = function() {
      var _a4;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a4 = {}, _a4[name] = value, _a4));
        return this;
      }
      return this.attrs[name];
    };
    Element5.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element5.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element5.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element5.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element5.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element5.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element5.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element5.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray2(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element5.prototype.resetMatrix = function() {
      this.attr(MATRIX2, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getMatrix = function() {
      return this.attr(MATRIX2);
    };
    Element5.prototype.setMatrix = function(m) {
      this.attr(MATRIX2, m);
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix2(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element5.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix2(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element5.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element5.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec22(matrix, v);
      }
      return v;
    };
    Element5.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert3(matrix);
        if (invertMatrix) {
          return multiplyVec22(invertMatrix, v);
        }
      }
      return v;
    };
    Element5.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase4 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase4[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element5.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element5.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr2(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone5 = new cons({ attrs });
      each_default(CLONE_CFGS2, function(cfgName) {
        clone5.set(cfgName, _this.get(cfgName));
      });
      return clone5;
    };
    Element5.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element5.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element5.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a4 = args[2], easing = _a4 === void 0 ? "easeLinear" : _a4, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat = animateCfg.repeat || repeat || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs2(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs2(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs2(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element5.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element5.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element5.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element5.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent2(element, relativeShape)) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element5.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT2 + eventObj.type;
      if (events[eventName] || events[WILDCARD3]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element5.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element5.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element5.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtStart = function(rotate5) {
      var _a4 = this.attr(), x = _a4.x, y = _a4.y;
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtPoint = function(x, y, rotate5) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element5;
  }(base_default8);
  var element_default2 = Element3;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/container.js
  var SHAPE_MAP2 = {};
  var INDEX2 = "_INDEX";
  function setCanvas2(element, canvas) {
    element.set("canvas", canvas);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setCanvas2(child, canvas);
        });
      }
    }
  }
  function setTimeline2(element, timeline) {
    element.set("timeline", timeline);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setTimeline2(child, timeline);
        });
      }
    }
  }
  function removeChild2(container, element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (destroy) {
      element.destroy();
    } else {
      element.set("parent", null);
      element.set("canvas", null);
    }
    removeFromArray2(container.getChildren(), element);
  }
  function getComparer2(compare) {
    return function(left, right) {
      var result = compare(left, right);
      return result === 0 ? left[INDEX2] - right[INDEX2] : result;
    };
  }
  var Container2 = function(_super) {
    __extends7(Container3, _super);
    function Container3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container3.prototype.isCanvas = function() {
      return false;
    };
    Container3.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container3.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getCanvasBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container3.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container3.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container3.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP2[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP2[cfg.type] = shapeType;
      }
      var ShapeBase4 = this.getShapeBase();
      var shape = new ShapeBase4[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container3.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group2;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group2 = new groupClass(cfg);
        } else {
          group2 = new groupClass({
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group2 = new TmpGroupClass(tmpCfg);
      }
      this.add(group2);
      return group2;
    };
    Container3.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container3.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture2(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container3.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture2(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container3.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild2(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas2(element, canvas);
      }
      if (timeline) {
        setTimeline2(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container3.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container3.prototype.getChildren = function() {
      return this.get("children");
    };
    Container3.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index) {
        child[INDEX2] = index;
        return child;
      });
      children.sort(getComparer2(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container3.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container3.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container3.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container3.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container3.prototype.getChildByIndex = function(index) {
      var children = this.getChildren();
      return children[index];
    };
    Container3.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container3.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container3.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container3.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container3.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container3.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container3.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container3.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container3;
  }(element_default2);
  var container_default2 = Container2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/color.js
  var isColorProp2 = function(prop) {
    return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
  };
  var isGradientColor3 = function(val) {
    return /^[r,R,L,l]{1}[\s]*\(/.test(val);
  };

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/animate/timeline.js
  var IDENTITY_MATRIX2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  function _update2(shape, animation, ratio) {
    var cProps = {};
    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
    if (shape.destroyed) {
      return;
    }
    var interf;
    for (var k in toAttrs) {
      if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
        if (k === "path") {
          var toPath = toAttrs[k];
          var fromPath = fromAttrs[k];
          if (toPath.length > fromPath.length) {
            toPath = parsePathString3(toAttrs[k]);
            fromPath = parsePathString3(fromAttrs[k]);
            fromPath = fillPathByDiff3(fromPath, toPath);
            fromPath = formatPath3(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
          } else if (!animation.pathFormatted) {
            toPath = parsePathString3(toAttrs[k]);
            fromPath = parsePathString3(fromAttrs[k]);
            fromPath = formatPath3(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
            animation.pathFormatted = true;
          }
          cProps[k] = [];
          for (var i = 0; i < toPath.length; i++) {
            var toPathPoint = toPath[i];
            var fromPathPoint = fromPath[i];
            var cPathPoint = [];
            for (var j = 0; j < toPathPoint.length; j++) {
              if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
                interf = value_default(fromPathPoint[j], toPathPoint[j]);
                cPathPoint.push(interf(ratio));
              } else {
                cPathPoint.push(toPathPoint[j]);
              }
            }
            cProps[k].push(cPathPoint);
          }
        } else if (k === "matrix") {
          var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX2, toAttrs[k] || IDENTITY_MATRIX2);
          var currentMatrix = matrixFn(ratio);
          cProps[k] = currentMatrix;
        } else if (isColorProp2(k) && isGradientColor3(toAttrs[k])) {
          cProps[k] = toAttrs[k];
        } else if (!is_function_default(toAttrs[k])) {
          interf = value_default(fromAttrs[k], toAttrs[k]);
          cProps[k] = interf(ratio);
        }
      }
    }
    shape.attr(cProps);
  }
  function update2(shape, animation, elapsed) {
    var startTime = animation.startTime, delay = animation.delay;
    if (elapsed < startTime + delay || animation._paused) {
      return false;
    }
    var ratio;
    var duration = animation.duration;
    var easing = animation.easing;
    elapsed = elapsed - startTime - animation.delay;
    if (animation.repeat) {
      ratio = elapsed % duration / duration;
      ratio = src_exports[easing](ratio);
    } else {
      ratio = elapsed / duration;
      if (ratio < 1) {
        ratio = src_exports[easing](ratio);
      } else {
        if (animation.onFrame) {
          shape.attr(animation.onFrame(1));
        } else {
          shape.attr(animation.toAttrs);
        }
        return true;
      }
    }
    if (animation.onFrame) {
      var attrs = animation.onFrame(ratio);
      shape.attr(attrs);
    } else {
      _update2(shape, animation, ratio);
    }
    return false;
  }
  var Timeline2 = function() {
    function Timeline3(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline3.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation = animations[j];
                isFinished = update2(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline3.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline3.prototype.removeAnimator = function(index) {
      this.animators.splice(index, 1);
    };
    Timeline3.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline3.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline3.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline3.prototype.getTime = function() {
      return this.current;
    };
    return Timeline3;
  }();
  var timeline_default2 = Timeline2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/event/event-contoller.js
  var CLICK_OFFSET2 = 40;
  var LEFT_BTN_CODE2 = 0;
  var EVENTS2 = [
    "mousedown",
    "mouseup",
    "dblclick",
    "mouseout",
    "mouseover",
    "mousemove",
    "mouseleave",
    "mouseenter",
    "touchstart",
    "touchmove",
    "touchend",
    "dragenter",
    "dragover",
    "dragleave",
    "drop",
    "contextmenu",
    "mousewheel"
  ];
  function emitTargetEvent2(target, type, eventObj) {
    eventObj.name = type;
    eventObj.target = target;
    eventObj.currentTarget = target;
    eventObj.delegateTarget = target;
    target.emit(type, eventObj);
  }
  function bubbleEvent2(container, type, eventObj) {
    if (eventObj.bubbles) {
      var relativeShape = void 0;
      var isOverEvent = false;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
        isOverEvent = true;
      } else if (type === "mouseleave") {
        isOverEvent = true;
        relativeShape = eventObj.toShape;
      }
      if (container.isCanvas() && isOverEvent) {
        return;
      }
      if (relativeShape && isParent2(container, relativeShape)) {
        eventObj.bubbles = false;
        return;
      }
      eventObj.name = type;
      eventObj.currentTarget = container;
      eventObj.delegateTarget = container;
      container.emit(type, eventObj);
    }
  }
  var EventController2 = function() {
    function EventController3(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController3.prototype.init = function() {
      this._bindEvents();
    };
    EventController3.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS2, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS2, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
      var eventObj = new graph_event_default2(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point.x;
      eventObj.y = point.y;
      eventObj.clientX = point.clientX;
      eventObj.clientY = point.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController3.prototype._getShape = function(point, ev) {
      return this.canvas.getShape(point.x, point.y, ev);
    };
    EventController3.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point = canvas.getPointByEvent(ev);
      return {
        x: point.x,
        y: point.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController3.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController3.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE2) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController3.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController3.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController3.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController3.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE2) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController3.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController3.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now2 = event.timeStamp;
          var timeWindow = now2 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist3 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist3 > CLICK_OFFSET2) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController3.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent2(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent2(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent2(canvas, type, eventObj);
      }
    };
    EventController3.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController3;
  }();
  var event_contoller_default2 = EventController2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/canvas.js
  var PX_SUFFIX2 = "px";
  var browser2 = detect();
  var isFirefox2 = browser2 && browser2.name === "firefox";
  var Canvas2 = function(_super) {
    __extends7(Canvas5, _super);
    function Canvas5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas5.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas5.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas5.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas5.prototype.initEvents = function() {
      var eventController = new event_contoller_default2({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas5.prototype.initTimeline = function() {
      var timeline = new timeline_default2(this);
      this.set("timeline", timeline);
    };
    Canvas5.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser2) {
        el.style.width = width + PX_SUFFIX2;
        el.style.height = height + PX_SUFFIX2;
      }
    };
    Canvas5.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas5.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas5.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas5.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser2 && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas5.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox2 && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a4 = this.getClientByEvent(ev), clientX = _a4.x, clientY = _a4.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas5.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas5.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas5.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas5.prototype.draw = function() {
    };
    Canvas5.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas5.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas5.prototype.isCanvas = function() {
      return true;
    };
    Canvas5.prototype.getParent = function() {
      return null;
    };
    Canvas5.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas5;
  }(container_default2);

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/group.js
  var AbstractGroup2 = function(_super) {
    __extends7(AbstractGroup3, _super);
    function AbstractGroup3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup3.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup3.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup3.prototype.clone = function() {
      var clone5 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone5.add(child.clone());
      }
      return clone5;
    };
    return AbstractGroup3;
  }(container_default2);

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/shape.js
  var AbstractShape2 = function(_super) {
    __extends7(AbstractShape3, _super);
    function AbstractShape3(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape3.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape3.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape3.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape3.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec22(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec22(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec22(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec22(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a4 = attrs.shadowBlur, shadowBlur = _a4 === void 0 ? 0 : _a4, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape3.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape3.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape3.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape3.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape3;
  }(element_default2);

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/register.js
  var cache2 = new Map();
  function register2(type, method) {
    cache2.set(type, method);
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/rect.js
  function rect_default2(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
    return {
      x,
      y,
      width,
      height
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/circle.js
  function circle_default2(shape) {
    var _a4 = shape.attr(), x = _a4.x, y = _a4.y, r = _a4.r;
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/util.js
  function mergeBBox2(bbox1, bbox2) {
    if (!bbox1 || !bbox2) {
      return bbox1 || bbox2;
    }
    return {
      minX: Math.min(bbox1.minX, bbox2.minX),
      minY: Math.min(bbox1.minY, bbox2.minY),
      maxX: Math.max(bbox1.maxX, bbox2.maxX),
      maxY: Math.max(bbox1.maxY, bbox2.maxY)
    };
  }
  function mergeArrowBBox2(shape, bbox) {
    var startArrowShape = shape.get("startArrowShape");
    var endArrowShape = shape.get("endArrowShape");
    var startArrowBBox = null;
    var endArrowBBox = null;
    if (startArrowShape) {
      startArrowBBox = startArrowShape.getCanvasBBox();
      bbox = mergeBBox2(bbox, startArrowBBox);
    }
    if (endArrowShape) {
      endArrowBBox = endArrowShape.getCanvasBBox();
      bbox = mergeBBox2(bbox, endArrowBBox);
    }
    return bbox;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/polyline.js
  function polyline_default3(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    var _a4 = util_exports.getBBoxByArray(xArr, yArr), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox2(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/polygon.js
  function polygon_default3(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return util_exports.getBBoxByArray(xArr, yArr);
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/offscreen.js
  var offScreenCtx2 = null;
  function getOffScreenContext2() {
    if (!offScreenCtx2) {
      var canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      offScreenCtx2 = canvas.getContext("2d");
    }
    return offScreenCtx2;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/text.js
  function getTextHeight2(text, fontSize, lineHeight) {
    var lineCount = 1;
    if (is_string_default(text)) {
      lineCount = text.split("\n").length;
    }
    if (lineCount > 1) {
      var spaceingY = getLineSpaceing2(fontSize, lineHeight);
      return fontSize * lineCount + spaceingY * (lineCount - 1);
    }
    return fontSize;
  }
  function getLineSpaceing2(fontSize, lineHeight) {
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  }
  function getTextWidth2(text, font) {
    var context = getOffScreenContext2();
    var width = 0;
    if (is_nil_default(text) || text === "") {
      return width;
    }
    context.save();
    context.font = font;
    if (is_string_default(text) && text.includes("\n")) {
      var textArr = text.split("\n");
      each_default(textArr, function(subText) {
        var measureWidth = context.measureText(subText).width;
        if (width < measureWidth) {
          width = measureWidth;
        }
      });
    } else {
      width = context.measureText(text).width;
    }
    context.restore();
    return width;
  }
  function assembleFont2(attrs) {
    var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
    return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/text.js
  function text_default2(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
    var font = attrs.font;
    if (!font) {
      font = assembleFont2(attrs);
    }
    var width = getTextWidth2(text, font);
    var bbox;
    if (!width) {
      bbox = {
        x,
        y,
        width: 0,
        height: 0
      };
    } else {
      var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
      var height = getTextHeight2(text, fontSize, lineHeight);
      var point = {
        x,
        y: y - height
      };
      if (textAlign) {
        if (textAlign === "end" || textAlign === "right") {
          point.x -= width;
        } else if (textAlign === "center") {
          point.x -= width / 2;
        }
      }
      if (textBaseline) {
        if (textBaseline === "top") {
          point.y += height;
        } else if (textBaseline === "middle") {
          point.y += height / 2;
        }
      }
      bbox = {
        x: point.x,
        y: point.y,
        width,
        height
      };
    }
    return bbox;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/path.js
  function getPathBox2(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    var minX = min_default(xArr);
    var minY = min_default(yArr);
    var maxX = max_default(xArr);
    var maxY = max_default(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    for (var i = 0; i < segmentsWithAngle.length; i++) {
      var segment = segmentsWithAngle[i];
      var currentPoint = segment.currentPoint;
      var extra = void 0;
      if (currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        minX = minX - extra.xExtra;
      } else if (currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        maxX = maxX + extra.xExtra;
      }
      if (currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        minY = minY - extra.yExtra;
      } else if (currentPoint[1] === maxY) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        maxY = maxY + extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getExtraFromSegmentWithAngle2(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function path_default2(shape) {
    var attrs = shape.attr();
    var path = attrs.path, stroke = attrs.stroke;
    var lineWidth = stroke ? attrs.lineWidth : 0;
    var segments = shape.get("segments") || getSegments(path);
    var _a4 = getPathBox2(segments, lineWidth), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox2(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/line.js
  function line_default3(shape) {
    var attrs = shape.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var bbox = {
      minX,
      maxX,
      minY,
      maxY
    };
    bbox = mergeArrowBBox2(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/ellipse.js
  function ellipse_default3(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/index.js
  register2("rect", rect_default2);
  register2("image", rect_default2);
  register2("circle", circle_default2);
  register2("marker", circle_default2);
  register2("polyline", polyline_default3);
  register2("polygon", polygon_default3);
  register2("text", text_default2);
  register2("path", path_default2);
  register2("line", line_default3);
  register2("ellipse", ellipse_default3);

  // node_modules/@antv/component/esm/util/event.js
  function propagationDelegate(group2, eventName, eventObject) {
    var event = new graph_event_default2(eventName, eventObject);
    event.target = group2;
    event.propagationPath.push(group2);
    group2.emitDelegation(eventName, event);
    var parent = group2.getParent();
    while (parent) {
      parent.emitDelegation(eventName, event);
      event.propagationPath.push(parent);
      parent = parent.getParent();
    }
  }

  // node_modules/@antv/component/esm/util/matrix.js
  var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  function getMatrixByAngle(point, angle3, matrix) {
    if (matrix === void 0) {
      matrix = identityMatrix;
    }
    if (!angle3) {
      return null;
    }
    var m = ext_exports.transform(matrix, [
      ["t", -point.x, -point.y],
      ["r", angle3],
      ["t", point.x, point.y]
    ]);
    return m;
  }
  function getMatrixByTranslate(point, currentMatrix) {
    if (!point.x && !point.y) {
      return null;
    }
    return ext_exports.transform(currentMatrix || identityMatrix, [["t", point.x, point.y]]);
  }
  function getAngleByMatrix(matrix) {
    var xVector = [1, 0, 0];
    var out = [0, 0, 0];
    vec3_exports.transformMat3(out, xVector, matrix);
    return Math.atan2(out[1], out[0]);
  }
  function multiplyVec23(matrix, v) {
    var out = [0, 0];
    vec2_exports.transformMat3(out, v, matrix);
    return out;
  }
  function applyMatrix2BBox(matrix, bbox) {
    var topLeft = multiplyVec23(matrix, [bbox.minX, bbox.minY]);
    var topRight = multiplyVec23(matrix, [bbox.maxX, bbox.minY]);
    var bottomLeft = multiplyVec23(matrix, [bbox.minX, bbox.maxY]);
    var bottomRight = multiplyVec23(matrix, [bbox.maxX, bbox.maxY]);
    var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
    var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
    var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function applyRotate(shape, rotate5, x, y) {
    if (rotate5) {
      var matrix = getMatrixByAngle({ x, y }, rotate5, shape.getMatrix());
      shape.setMatrix(matrix);
    }
  }
  function applyTranslate(shape, x, y) {
    var translateMatrix = getMatrixByTranslate({ x, y });
    shape.attr("matrix", translateMatrix);
  }

  // node_modules/@antv/component/esm/util/util.js
  function formatPadding(padding) {
    var top = 0;
    var left = 0;
    var right = 0;
    var bottom = 0;
    if (is_number_default(padding)) {
      top = left = right = bottom = padding;
    } else if (is_array_default(padding)) {
      top = padding[0];
      right = !is_nil_default(padding[1]) ? padding[1] : padding[0];
      bottom = !is_nil_default(padding[2]) ? padding[2] : padding[0];
      left = !is_nil_default(padding[3]) ? padding[3] : right;
    }
    return [top, right, bottom, left];
  }
  function clearDom(container) {
    var children = container.childNodes;
    var length3 = children.length;
    for (var i = length3 - 1; i >= 0; i--) {
      container.removeChild(children[i]);
    }
  }
  function hasClass(elements, cName) {
    return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
  }
  function regionToBBox(region) {
    var start = region.start, end = region.end;
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    var maxX = Math.max(start.x, end.x);
    var maxY = Math.max(start.y, end.y);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function pointsToBBox(points) {
    var xs = points.map(function(point) {
      return point.x;
    });
    var ys = points.map(function(point) {
      return point.y;
    });
    var minX = Math.min.apply(Math, xs);
    var minY = Math.min.apply(Math, ys);
    var maxX = Math.max.apply(Math, xs);
    var maxY = Math.max.apply(Math, ys);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function createBBox(x, y, width, height) {
    var maxX = x + width;
    var maxY = y + height;
    return {
      x,
      y,
      width,
      height,
      minX: x,
      minY: y,
      maxX: isNaN(maxX) ? 0 : maxX,
      maxY: isNaN(maxY) ? 0 : maxY
    };
  }
  function getValueByPercent(min3, max3, percent) {
    return (1 - percent) * min3 + max3 * percent;
  }
  function getCirclePoint(center, radius, angle3) {
    return {
      x: center.x + Math.cos(angle3) * radius,
      y: center.y + Math.sin(angle3) * radius
    };
  }
  function distance4(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  var near = function(x, y, e) {
    if (e === void 0) {
      e = Math.pow(Number.EPSILON, 0.5);
    }
    return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
  };
  function intersectBBox2(box1, box2) {
    var minX = Math.max(box1.minX, box2.minX);
    var minY = Math.max(box1.minY, box2.minY);
    var maxX = Math.min(box1.maxX, box2.maxX);
    var maxY = Math.min(box1.maxY, box2.maxY);
    return createBBox(minX, minY, maxX - minX, maxY - minY);
  }
  function getBBoxWithClip(element) {
    var clipShape = element.getClip();
    var clipBBox = clipShape && clipShape.getBBox();
    var bbox;
    if (!element.isGroup()) {
      bbox = element.getBBox();
    } else {
      var minX_1 = Infinity;
      var maxX_1 = -Infinity;
      var minY_1 = Infinity;
      var maxY_1 = -Infinity;
      var children = element.getChildren();
      if (children.length > 0) {
        each_default(children, function(child) {
          if (child.get("visible")) {
            if (child.isGroup() && child.get("children").length === 0) {
              return true;
            }
            var box2 = getBBoxWithClip(child);
            var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
            var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
            var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
            var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
            var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
            var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
            var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
            var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
            if (boxMinX < minX_1) {
              minX_1 = boxMinX;
            }
            if (boxMaxX > maxX_1) {
              maxX_1 = boxMaxX;
            }
            if (boxMinY < minY_1) {
              minY_1 = boxMinY;
            }
            if (boxMaxY > maxY_1) {
              maxY_1 = boxMaxY;
            }
          }
        });
      } else {
        minX_1 = 0;
        maxX_1 = 0;
        minY_1 = 0;
        maxY_1 = 0;
      }
      bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
    }
    if (clipBBox) {
      return intersectBBox2(bbox, clipBBox);
    } else {
      return bbox;
    }
  }
  function updateClip(element, newElement) {
    if (!element.getClip() && !newElement.getClip()) {
      return;
    }
    var newClipShape = newElement.getClip();
    if (!newClipShape) {
      element.setClip(null);
      return;
    }
    var clipCfg = {
      type: newClipShape.get("type"),
      attrs: newClipShape.attr()
    };
    element.setClip(clipCfg);
  }
  function toPx(number) {
    return number + "px";
  }
  function getTextPoint(start, end, position, offset) {
    var lineLength = distance4(start, end);
    var offsetPercent = offset / lineLength;
    var percent = 0;
    if (position === "start") {
      percent = 0 - offsetPercent;
    } else if (position === "end") {
      percent = 1 + offsetPercent;
    }
    return {
      x: getValueByPercent(start.x, end.x, percent),
      y: getValueByPercent(start.y, end.y, percent)
    };
  }

  // node_modules/@antv/component/esm/abstract/component.js
  var LOCATION_FIELD_MAP = {
    none: [],
    point: ["x", "y"],
    region: ["start", "end"],
    points: ["points"],
    circle: ["center", "radius", "startAngle", "endAngle"]
  };
  var Component = function(_super) {
    __extends7(Component2, _super);
    function Component2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initCfg();
      return _this;
    }
    Component2.prototype.getDefaultCfg = function() {
      return {
        id: "",
        name: "",
        type: "",
        locationType: "none",
        offsetX: 0,
        offsetY: 0,
        animate: false,
        capture: true,
        updateAutoRender: false,
        animateOption: {
          appear: null,
          update: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          enter: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          leave: {
            duration: 350,
            easing: "easeQuadIn"
          }
        },
        events: null,
        defaultCfg: {},
        visible: true
      };
    };
    Component2.prototype.clear = function() {
    };
    Component2.prototype.update = function(cfg) {
      var _this = this;
      var defaultCfg = this.get("defaultCfg");
      each_default(cfg, function(value, name) {
        var originCfg = _this.get(name);
        var newCfg = value;
        if (originCfg !== value) {
          if (is_object_default(value) && defaultCfg[name]) {
            newCfg = deep_mix_default({}, defaultCfg[name], value);
          }
          _this.set(name, newCfg);
        }
      });
      this.updateInner(cfg);
      this.afterUpdate(cfg);
    };
    Component2.prototype.updateInner = function(cfg) {
    };
    Component2.prototype.afterUpdate = function(cfg) {
      if (has_key_default(cfg, "visible")) {
        if (cfg.visible) {
          this.show();
        } else {
          this.hide();
        }
      }
      if (has_key_default(cfg, "capture")) {
        this.setCapture(cfg.capture);
      }
    };
    Component2.prototype.getLayoutBBox = function() {
      return this.getBBox();
    };
    Component2.prototype.getLocationType = function() {
      return this.get("locationType");
    };
    Component2.prototype.getOffset = function() {
      return {
        offsetX: this.get("offsetX"),
        offsetY: this.get("offsetY")
      };
    };
    Component2.prototype.setOffset = function(offsetX, offsetY) {
      this.update({
        offsetX,
        offsetY
      });
    };
    Component2.prototype.setLocation = function(cfg) {
      var location = __assign7({}, cfg);
      this.update(location);
    };
    Component2.prototype.getLocation = function() {
      var _this = this;
      var location = {};
      var locationType = this.get("locationType");
      var fields = LOCATION_FIELD_MAP[locationType];
      each_default(fields, function(field) {
        location[field] = _this.get(field);
      });
      return location;
    };
    Component2.prototype.isList = function() {
      return false;
    };
    Component2.prototype.isSlider = function() {
      return false;
    };
    Component2.prototype.init = function() {
    };
    Component2.prototype.initCfg = function() {
      var _this = this;
      var defaultCfg = this.get("defaultCfg");
      each_default(defaultCfg, function(value, name) {
        var cfg = _this.get(name);
        if (is_object_default(cfg)) {
          var newCfg = deep_mix_default({}, value, cfg);
          _this.set(name, newCfg);
        }
      });
    };
    return Component2;
  }(base_default8);
  var component_default = Component;

  // node_modules/@antv/component/esm/abstract/group-component.js
  var STATUS_UPDATE = "update_status";
  var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
  var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
  var GroupComponent = function(_super) {
    __extends7(GroupComponent2, _super);
    function GroupComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        container: null,
        shapesMap: {},
        group: null,
        capture: true,
        isRegister: false,
        isUpdating: false,
        isInit: true
      });
    };
    GroupComponent2.prototype.remove = function() {
      this.clear();
      var group2 = this.get("group");
      group2.remove();
    };
    GroupComponent2.prototype.clear = function() {
      var group2 = this.get("group");
      group2.clear();
      this.set("shapesMap", {});
      this.clearOffScreenCache();
      this.set("isInit", true);
    };
    GroupComponent2.prototype.getChildComponentById = function(id) {
      var group2 = this.getElementById(id);
      var inst = group2 && group2.get("component");
      return inst;
    };
    GroupComponent2.prototype.getElementById = function(id) {
      return this.get("shapesMap")[id];
    };
    GroupComponent2.prototype.getElementByLocalId = function(localId) {
      var id = this.getElementId(localId);
      return this.getElementById(id);
    };
    GroupComponent2.prototype.getElementsByName = function(name) {
      var rst = [];
      each_default(this.get("shapesMap"), function(elem) {
        if (elem.get("name") === name) {
          rst.push(elem);
        }
      });
      return rst;
    };
    GroupComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    GroupComponent2.prototype.updateInner = function(cfg) {
      this.offScreenRender();
      if (this.get("updateAutoRender")) {
        this.render();
      }
    };
    GroupComponent2.prototype.render = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (!offScreenGroup) {
        offScreenGroup = this.offScreenRender();
      }
      var group2 = this.get("group");
      this.updateElements(offScreenGroup, group2);
      this.deleteElements();
      this.applyOffset();
      if (!this.get("eventInitted")) {
        this.initEvent();
        this.set("eventInitted", true);
      }
      this.set("isInit", false);
    };
    GroupComponent2.prototype.show = function() {
      var group2 = this.get("group");
      group2.show();
      this.set("visible", true);
    };
    GroupComponent2.prototype.hide = function() {
      var group2 = this.get("group");
      group2.hide();
      this.set("visible", false);
    };
    GroupComponent2.prototype.setCapture = function(capture) {
      var group2 = this.get("group");
      group2.set("capture", capture);
      this.set("capture", capture);
    };
    GroupComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.remove();
      _super.prototype.destroy.call(this);
    };
    GroupComponent2.prototype.getBBox = function() {
      return this.get("group").getCanvasBBox();
    };
    GroupComponent2.prototype.getLayoutBBox = function() {
      var group2 = this.get("group");
      var bbox = this.getInnerLayoutBBox();
      var matrix = group2.getTotalMatrix();
      if (matrix) {
        bbox = applyMatrix2BBox(matrix, bbox);
      }
      return bbox;
    };
    GroupComponent2.prototype.on = function(evt, callback, once) {
      var group2 = this.get("group");
      group2.on(evt, callback, once);
      return this;
    };
    GroupComponent2.prototype.off = function(evt, callback) {
      var group2 = this.get("group");
      group2 && group2.off(evt, callback);
      return this;
    };
    GroupComponent2.prototype.emit = function(eventName, eventObject) {
      var group2 = this.get("group");
      group2.emit(eventName, eventObject);
    };
    GroupComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      if (!this.get("group")) {
        this.initGroup();
      }
      this.offScreenRender();
    };
    GroupComponent2.prototype.getInnerLayoutBBox = function() {
      return this.get("offScreenBBox") || this.get("group").getBBox();
    };
    GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
      var group2 = this.get("group");
      eventObject.target = group2;
      group2.emit(eventName, eventObject);
      propagationDelegate(group2, eventName, eventObject);
    };
    GroupComponent2.prototype.createOffScreenGroup = function() {
      var group2 = this.get("group");
      var GroupClass = group2.getGroupBase();
      var newGroup = new GroupClass({
        delegateObject: this.getDelegateObject()
      });
      return newGroup;
    };
    GroupComponent2.prototype.applyOffset = function() {
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: offsetX,
        y: offsetY
      });
    };
    GroupComponent2.prototype.initGroup = function() {
      var container = this.get("container");
      this.set("group", container.addGroup({
        id: this.get("id"),
        name: this.get("name"),
        capture: this.get("capture"),
        visible: this.get("visible"),
        isComponent: true,
        component: this,
        delegateObject: this.getDelegateObject()
      }));
    };
    GroupComponent2.prototype.offScreenRender = function() {
      this.clearOffScreenCache();
      var offScreenGroup = this.createOffScreenGroup();
      this.renderInner(offScreenGroup);
      this.set("offScreenGroup", offScreenGroup);
      this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
      return offScreenGroup;
    };
    GroupComponent2.prototype.addGroup = function(parent, cfg) {
      this.appendDelegateObject(parent, cfg);
      var group2 = parent.addGroup(cfg);
      if (this.get("isRegister")) {
        this.registerElement(group2);
      }
      return group2;
    };
    GroupComponent2.prototype.addShape = function(parent, cfg) {
      this.appendDelegateObject(parent, cfg);
      var shape = parent.addShape(cfg);
      if (this.get("isRegister")) {
        this.registerElement(shape);
      }
      return shape;
    };
    GroupComponent2.prototype.addComponent = function(parent, cfg) {
      var id = cfg.id, Ctor = cfg.component, restCfg = __rest7(cfg, ["id", "component"]);
      var inst = new Ctor(__assign7(__assign7({}, restCfg), { id, container: parent, updateAutoRender: this.get("updateAutoRender") }));
      inst.init();
      inst.render();
      if (this.get("isRegister")) {
        this.registerElement(inst.get("group"));
      }
      return inst;
    };
    GroupComponent2.prototype.initEvent = function() {
    };
    GroupComponent2.prototype.removeEvent = function() {
      var group2 = this.get("group");
      group2.off();
    };
    GroupComponent2.prototype.getElementId = function(localId) {
      var id = this.get("id");
      var name = this.get("name");
      return id + "-" + name + "-" + localId;
    };
    GroupComponent2.prototype.registerElement = function(element) {
      var id = element.get("id");
      this.get("shapesMap")[id] = element;
    };
    GroupComponent2.prototype.unregisterElement = function(element) {
      var id = element.get("id");
      delete this.get("shapesMap")[id];
    };
    GroupComponent2.prototype.moveElementTo = function(element, point) {
      var matrix = getMatrixByTranslate(point);
      element.attr("matrix", matrix);
    };
    GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
      var originOpacity = newElement.attr("opacity");
      if (is_nil_default(originOpacity)) {
        originOpacity = 1;
      }
      newElement.attr("opacity", 0);
      newElement.animate({ opacity: originOpacity }, animateCfg);
    };
    GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
      originElement.animate({ opacity: 0 }, animateCfg);
    };
    GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
      originElement.animate(newAttrs, animateCfg);
    };
    GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
      var _this = this;
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      var children = newGroup.getChildren().slice(0);
      var preElement;
      each_default(children, function(element) {
        var elementId = element.get("id");
        var originElement = _this.getElementById(elementId);
        var elementName = element.get("name");
        if (originElement) {
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            var origChildComponent = originElement.get("component");
            var newCfg = pick_default(childComponent.cfg, difference_default(keys_default(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
            origChildComponent.update(newCfg);
            originElement.set(STATUS_UPDATE, "update");
          } else {
            var replaceAttrs = _this.getReplaceAttrs(originElement, element);
            if (animate && animateOption.update) {
              _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
            } else {
              originElement.attr(replaceAttrs);
            }
            if (element.isGroup()) {
              _this.updateElements(element, originElement);
            }
            each_default(COPY_PROPERTIES, function(name) {
              originElement.set(name, element.get(name));
            });
            updateClip(originElement, element);
            preElement = originElement;
            originElement.set(STATUS_UPDATE, "update");
          }
        } else {
          originGroup.add(element);
          var siblings = originGroup.getChildren();
          siblings.splice(siblings.length - 1, 1);
          if (preElement) {
            var index = siblings.indexOf(preElement);
            siblings.splice(index + 1, 0, element);
          } else {
            siblings.unshift(element);
          }
          _this.registerElement(element);
          element.set(STATUS_UPDATE, "add");
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            childComponent.set("container", originGroup);
          } else if (element.isGroup()) {
            _this.registerNewGroup(element);
          }
          preElement = element;
          if (animate) {
            var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
            if (animateCfg) {
              _this.addAnimation(elementName, element, animateCfg);
            }
          }
        }
      });
    };
    GroupComponent2.prototype.clearUpdateStatus = function(group2) {
      var children = group2.getChildren();
      each_default(children, function(el) {
        el.set(STATUS_UPDATE, null);
      });
    };
    GroupComponent2.prototype.clearOffScreenCache = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (offScreenGroup) {
        offScreenGroup.destroy();
      }
      this.set("offScreenGroup", null);
      this.set("offScreenBBox", null);
    };
    GroupComponent2.prototype.getDelegateObject = function() {
      var _a4;
      var name = this.get("name");
      var delegateObject = (_a4 = {}, _a4[name] = this, _a4.component = this, _a4);
      return delegateObject;
    };
    GroupComponent2.prototype.appendDelegateObject = function(parent, cfg) {
      var parentObject = parent.get("delegateObject");
      if (!cfg.delegateObject) {
        cfg.delegateObject = {};
      }
      mix(cfg.delegateObject, parentObject);
    };
    GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
      var originAttrs = originElement.attr();
      var newAttrs = newElement.attr();
      each_default(originAttrs, function(v, k) {
        if (newAttrs[k] === void 0) {
          newAttrs[k] = void 0;
        }
      });
      return newAttrs;
    };
    GroupComponent2.prototype.registerNewGroup = function(group2) {
      var _this = this;
      var children = group2.getChildren();
      each_default(children, function(element) {
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
      });
    };
    GroupComponent2.prototype.deleteElements = function() {
      var _this = this;
      var shapesMap = this.get("shapesMap");
      var deleteArray = [];
      each_default(shapesMap, function(element, id) {
        if (!element.get(STATUS_UPDATE) || element.destroyed) {
          deleteArray.push([id, element]);
        } else {
          element.set(STATUS_UPDATE, null);
        }
      });
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      each_default(deleteArray, function(item) {
        var id = item[0], element = item[1];
        if (!element.destroyed) {
          var elementName = element.get("name");
          if (animate && animateOption.leave) {
            var callbackAnimCfg = mix({
              callback: function() {
                _this.removeElement(element);
              }
            }, animateOption.leave);
            _this.removeAnimation(elementName, element, callbackAnimCfg);
          } else {
            _this.removeElement(element);
          }
        }
        delete shapesMap[id];
      });
    };
    GroupComponent2.prototype.removeElement = function(element) {
      if (element.get("isGroup")) {
        var component = element.get("component");
        if (component) {
          component.destroy();
        }
      }
      element.remove();
    };
    return GroupComponent2;
  }(component_default);
  var group_component_default = GroupComponent;

  // node_modules/@antv/component/esm/util/text.js
  var ELLIPSIS_CODE = "\u2026";
  function strLen(str4) {
    var len3 = 0;
    for (var i = 0; i < str4.length; i++) {
      len3 += charAtLength(str4, i);
    }
    return len3;
  }
  function charAtLength(str4, i) {
    if (str4.charCodeAt(i) > 0 && str4.charCodeAt(i) < 128) {
      return 1;
    } else {
      return 2;
    }
  }
  function ellipsisString(str4, reseveLength, position) {
    if (position === void 0) {
      position = "tail";
    }
    var count = str4.length;
    var rst = "";
    if (position === "tail") {
      for (var i = 0, index = 0; i < reseveLength; ) {
        var charLength = charAtLength(str4, index);
        if (i + charLength <= reseveLength) {
          rst += str4[index];
          i += charAtLength(str4, index);
          index++;
        } else {
          break;
        }
      }
      rst += ELLIPSIS_CODE;
    } else if (position === "head") {
      for (var i = 0, index = count - 1; i < reseveLength; ) {
        var charLength = charAtLength(str4, index);
        if (i + charLength <= reseveLength) {
          rst += str4[index];
          i += charAtLength(str4, index);
          index--;
        } else {
          break;
        }
      }
      rst = ELLIPSIS_CODE + rst;
    } else {
      var startStr = "";
      var endStr = "";
      for (var i = 0, startIndex = 0, endIndex = count - 1; i < reseveLength; ) {
        var startCodeLen = charAtLength(str4, startIndex);
        var hasAdd = false;
        if (startCodeLen + i <= reseveLength) {
          startStr += str4[startIndex];
          startIndex++;
          i += startCodeLen;
          hasAdd = true;
        }
        var endCodeLen = charAtLength(str4, endIndex);
        if (endCodeLen + i <= reseveLength) {
          endStr = str4[endIndex] + endStr;
          i += endCodeLen;
          endIndex--;
          hasAdd = true;
        }
        if (!hasAdd) {
          break;
        }
      }
      rst = startStr + ELLIPSIS_CODE + endStr;
    }
    return rst;
  }

  // node_modules/@antv/component/esm/util/label.js
  var ELLIPSIS_CODE2 = "\u2026";
  var ELLIPSIS_CODE_LENGTH = 2;
  var OPTIMIZE_THRESHOLD = 400;
  function getMaxLabelWidthOptimized(labels) {
    var texts = labels.map(function(label) {
      var text = label.attr("text");
      return is_nil_default(text) ? "" : "" + text;
    });
    var maxLen = 0;
    var maxIdx = 0;
    for (var i = 0; i < texts.length; i += 1) {
      var len3 = 0;
      for (var j = 0; j <= texts[i].length; j += 1) {
        var code = texts[i].charCodeAt(j);
        if (code >= 19968 && code <= 40869) {
          len3 += 2;
        } else {
          len3 += 1;
        }
      }
      if (len3 > maxLen) {
        maxLen = len3;
        maxIdx = i;
      }
    }
    return labels[maxIdx].getBBox().width;
  }
  function getMaxLabelWidth(labels) {
    if (labels.length > OPTIMIZE_THRESHOLD) {
      return getMaxLabelWidthOptimized(labels);
    }
    var max3 = 0;
    each_default(labels, function(label) {
      var bbox = label.getBBox();
      var width = bbox.width;
      if (max3 < width) {
        max3 = width;
      }
    });
    return max3;
  }
  function getLabelLength(isVertical2, label) {
    var bbox = label.getCanvasBBox();
    return isVertical2 ? bbox.width : bbox.height;
  }
  function ellipsisLabel(isVertical2, label, limitLength, position) {
    var _a4;
    if (position === void 0) {
      position = "tail";
    }
    var text = (_a4 = label.attr("text")) !== null && _a4 !== void 0 ? _a4 : "";
    if (position === "tail") {
      var font = pick_default(label.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
      var ellipsisText = get_ellipsis_text_default(text, limitLength, font, "\u2026");
      if (text !== ellipsisText) {
        label.attr("text", ellipsisText);
        label.set("tip", text);
        return true;
      }
      label.set("tip", null);
      return false;
    }
    var labelLength = getLabelLength(isVertical2, label);
    var codeLength = strLen(text);
    var ellipsisFlag = false;
    if (limitLength < labelLength) {
      var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
      var newText = void 0;
      if (reserveLength >= 0) {
        newText = ellipsisString(text, reserveLength, position);
      } else {
        newText = ELLIPSIS_CODE2;
      }
      if (newText) {
        label.attr("text", newText);
        ellipsisFlag = true;
      }
    }
    if (ellipsisFlag) {
      label.set("tip", text);
    } else {
      label.set("tip", null);
    }
    return ellipsisFlag;
  }

  // node_modules/@antv/component/esm/util/graphic.js
  function renderTag(container, tagCfg) {
    var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id = tagCfg.id, name = tagCfg.name, rotate5 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
    var tagGroup = container.addGroup({
      id: id + "-group",
      name: name + "-group",
      attrs: {
        x,
        y
      }
    });
    var text = tagGroup.addShape({
      type: "text",
      id,
      name,
      attrs: __assign7({ x: 0, y: 0, text: content }, style)
    });
    var padding = formatPadding(get_default(background, "padding", 0));
    if (maxLength && autoEllipsis) {
      var maxTextLength = maxLength - (padding[1] + padding[3]);
      ellipsisLabel(!isVertical2, text, maxTextLength, ellipsisPosition);
    }
    if (background) {
      var backgroundStyle = get_default(background, "style", {});
      var _a4 = text.getCanvasBBox(), minX = _a4.minX, minY = _a4.minY, width = _a4.width, height = _a4.height;
      var tagBg = tagGroup.addShape("rect", {
        id: id + "-bg",
        name: id + "-bg",
        attrs: __assign7({ x: minX - padding[3], y: minY - padding[0], width: width + padding[1] + padding[3], height: height + padding[0] + padding[2] }, backgroundStyle)
      });
      tagBg.toBack();
    }
    applyTranslate(tagGroup, x, y);
    applyRotate(tagGroup, rotate5, x, y);
  }

  // node_modules/@antv/component/esm/util/theme.js
  var theme_default = {
    fontFamily: '\n  "-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
    textColor: "#2C3542",
    activeTextColor: "#333333",
    uncheckedColor: "#D8D8D8",
    lineColor: "#416180",
    regionColor: "#CCD7EB",
    verticalAxisRotate: -Math.PI / 4,
    horizontalAxisRotate: Math.PI / 4
  };

  // node_modules/@antv/component/esm/annotation/line.js
  var LineAnnotation = function(_super) {
    __extends7(LineAnnotation2, _super);
    function LineAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "bottom",
          fontFamily: theme_default.fontFamily
        },
        text: {
          position: "center",
          autoRotate: true,
          content: null,
          offsetX: 0,
          offsetY: 0,
          style: {
            stroke: theme_default.lineColor,
            lineWidth: 1
          }
        }
      } });
    };
    LineAnnotation2.prototype.renderInner = function(group2) {
      this.renderLine(group2);
      if (this.get("text")) {
        this.renderLabel(group2);
      }
    };
    LineAnnotation2.prototype.renderLine = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      this.addShape(group2, {
        type: "line",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: __assign7({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style)
      });
    };
    LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
      var percent;
      if (position === "start") {
        percent = 0;
      } else if (position === "center") {
        percent = 0.5;
      } else if (is_string_default(position) && position.indexOf("%") !== -1) {
        percent = parseInt(position, 10) / 100;
      } else if (is_number_default(position)) {
        percent = position;
      } else {
        percent = 1;
      }
      if (percent > 1 || percent < 0) {
        percent = 1;
      }
      return {
        x: getValueByPercent(start.x, end.x, percent),
        y: getValueByPercent(start.y, end.y, percent)
      };
    };
    LineAnnotation2.prototype.renderLabel = function(group2) {
      var text = this.get("text");
      var start = this.get("start");
      var end = this.get("end");
      var position = text.position, content = text.content, style = text.style, offsetX = text.offsetX, offsetY = text.offsetY, autoRotate = text.autoRotate, maxLength = text.maxLength, autoEllipsis = text.autoEllipsis, ellipsisPosition = text.ellipsisPosition, background = text.background, _a4 = text.isVertical, isVertical2 = _a4 === void 0 ? false : _a4;
      var point = this.getLabelPoint(start, end, position);
      var x = point.x + offsetX;
      var y = point.y + offsetY;
      var cfg = {
        id: this.getElementId("line-text"),
        name: "annotation-line-text",
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis,
        ellipsisPosition,
        background,
        isVertical: isVertical2
      };
      if (autoRotate) {
        var vector = [end.x - start.x, end.y - start.y];
        cfg.rotate = Math.atan2(vector[1], vector[0]);
      }
      renderTag(group2, cfg);
    };
    return LineAnnotation2;
  }(group_component_default);
  var line_default4 = LineAnnotation;

  // node_modules/@antv/component/esm/annotation/text.js
  var TextAnnotation = function(_super) {
    __extends7(TextAnnotation2, _super);
    function TextAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TextAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: theme_default.fontFamily
        }
      } });
    };
    TextAnnotation2.prototype.setLocation = function(location) {
      this.set("x", location.x);
      this.set("y", location.y);
      this.resetLocation();
    };
    TextAnnotation2.prototype.renderInner = function(group2) {
      var _a4 = this.getLocation(), x = _a4.x, y = _a4.y;
      var content = this.get("content");
      var style = this.get("style");
      var id = this.getElementId("text");
      var name = this.get("name") + "-text";
      var maxLength = this.get("maxLength");
      var autoEllipsis = this.get("autoEllipsis");
      var isVertical2 = this.get("isVertical");
      var ellipsisPosition = this.get("ellipsisPosition");
      var background = this.get("background");
      var rotate5 = this.get("rotate");
      var cfg = {
        id,
        name,
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis,
        isVertical: isVertical2,
        ellipsisPosition,
        background,
        rotate: rotate5
      };
      renderTag(group2, cfg);
    };
    TextAnnotation2.prototype.resetLocation = function() {
      var textGroup = this.getElementByLocalId("text-group");
      if (textGroup) {
        var _a4 = this.getLocation(), x = _a4.x, y = _a4.y;
        var rotate5 = this.get("rotate");
        applyTranslate(textGroup, x, y);
        applyRotate(textGroup, rotate5, x, y);
      }
    };
    return TextAnnotation2;
  }(group_component_default);
  var text_default3 = TextAnnotation;

  // node_modules/@antv/component/esm/annotation/arc.js
  var ArcAnnotation = function(_super) {
    __extends7(ArcAnnotation2, _super);
    function ArcAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ArcAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
        stroke: "#999",
        lineWidth: 1
      } });
    };
    ArcAnnotation2.prototype.renderInner = function(group2) {
      this.renderArc(group2);
    };
    ArcAnnotation2.prototype.getArcPath = function() {
      var _a4 = this.getLocation(), center = _a4.center, radius = _a4.radius, startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var startPoint = getCirclePoint(center, radius, startAngle);
      var endPoint = getCirclePoint(center, radius, endAngle);
      var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
      var path = [["M", startPoint.x, startPoint.y]];
      if (endAngle - startAngle === Math.PI * 2) {
        var middlePoint = getCirclePoint(center, radius, startAngle + Math.PI);
        path.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
        path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      } else {
        path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      }
      return path;
    };
    ArcAnnotation2.prototype.renderArc = function(group2) {
      var path = this.getArcPath();
      var style = this.get("style");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("arc"),
        name: "annotation-arc",
        attrs: __assign7({ path }, style)
      });
    };
    return ArcAnnotation2;
  }(group_component_default);
  var arc_default2 = ArcAnnotation;

  // node_modules/@antv/component/esm/annotation/region.js
  var RegionAnnotation = function(_super) {
    __extends7(RegionAnnotation2, _super);
    function RegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
        style: {
          lineWidth: 0,
          fill: theme_default.regionColor,
          opacity: 0.4
        }
      } });
    };
    RegionAnnotation2.prototype.renderInner = function(group2) {
      this.renderRegion(group2);
    };
    RegionAnnotation2.prototype.renderRegion = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign7({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style)
      });
    };
    return RegionAnnotation2;
  }(group_component_default);
  var region_default = RegionAnnotation;

  // node_modules/@antv/component/esm/annotation/image.js
  var ImageAnnotation = function(_super) {
    __extends7(ImageAnnotation2, _super);
    function ImageAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
    };
    ImageAnnotation2.prototype.renderInner = function(group2) {
      this.renderImage(group2);
    };
    ImageAnnotation2.prototype.getImageAttrs = function() {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      var src = this.get("src");
      return __assign7({ x: bbox.x, y: bbox.y, img: src, width: bbox.width, height: bbox.height }, style);
    };
    ImageAnnotation2.prototype.renderImage = function(group2) {
      this.addShape(group2, {
        type: "image",
        id: this.getElementId("image"),
        name: "annotation-image",
        attrs: this.getImageAttrs()
      });
    };
    return ImageAnnotation2;
  }(group_component_default);
  var image_default = ImageAnnotation;

  // node_modules/@antv/component/esm/annotation/data-marker.js
  var DataMarkerAnnotation = function(_super) {
    __extends7(DataMarkerAnnotation2, _super);
    function DataMarkerAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
        point: {
          display: true,
          style: {
            r: 3,
            fill: "#FFFFFF",
            stroke: "#1890FF",
            lineWidth: 2
          }
        },
        line: {
          display: true,
          length: 20,
          style: {
            stroke: theme_default.lineColor,
            lineWidth: 1
          }
        },
        text: {
          content: "",
          display: true,
          style: {
            fill: theme_default.textColor,
            opacity: 0.65,
            fontSize: 12,
            textAlign: "start",
            fontFamily: theme_default.fontFamily
          }
        }
      } });
    };
    DataMarkerAnnotation2.prototype.renderInner = function(group2) {
      if (get_default(this.get("line"), "display")) {
        this.renderLine(group2);
      }
      if (get_default(this.get("text"), "display")) {
        this.renderText(group2);
      }
      if (get_default(this.get("point"), "display")) {
        this.renderPoint(group2);
      }
      if (this.get("autoAdjust")) {
        this.autoAdjust(group2);
      }
    };
    DataMarkerAnnotation2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x") + this.get("offsetX"),
        y: this.get("y") + this.get("offsetY")
      });
    };
    DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
      var point = this.getShapeAttrs().point;
      this.addShape(group2, {
        type: "circle",
        id: this.getElementId("point"),
        name: "annotation-point",
        attrs: point
      });
    };
    DataMarkerAnnotation2.prototype.renderLine = function(group2) {
      var line = this.getShapeAttrs().line;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: line
      });
    };
    DataMarkerAnnotation2.prototype.renderText = function(group2) {
      var textAttrs = this.getShapeAttrs().text;
      var x = textAttrs.x, y = textAttrs.y, text = textAttrs.text, style = __rest7(textAttrs, ["x", "y", "text"]);
      var _a4 = this.get("text"), background = _a4.background, maxLength = _a4.maxLength, autoEllipsis = _a4.autoEllipsis, isVertival = _a4.isVertival, ellipsisPosition = _a4.ellipsisPosition;
      var tagCfg = {
        x,
        y,
        id: this.getElementId("text"),
        name: "annotation-text",
        content: text,
        style,
        background,
        maxLength,
        autoEllipsis,
        isVertival,
        ellipsisPosition
      };
      renderTag(group2, tagCfg);
    };
    DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
      var direction2 = this.get("direction");
      var x = this.get("x");
      var y = this.get("y");
      var lineLength = get_default(this.get("line"), "length", 0);
      var coordinateBBox = this.get("coordinateBBox");
      var _a4 = group2.getBBox(), minX = _a4.minX, maxX = _a4.maxX, minY = _a4.minY, maxY = _a4.maxY;
      var textGroup = group2.findById(this.getElementId("text-group"));
      var textShape = group2.findById(this.getElementId("text"));
      var lineShape = group2.findById(this.getElementId("line"));
      if (!coordinateBBox) {
        return;
      }
      if (textGroup) {
        if (x + minX <= coordinateBBox.minX) {
          var overflow = coordinateBBox.minX - (x + minX);
          applyTranslate(textGroup, textGroup.attr("x") + overflow, textGroup.attr("y"));
        }
        if (x + maxX >= coordinateBBox.maxX) {
          var overflow = x + maxX - coordinateBBox.maxX;
          applyTranslate(textGroup, textGroup.attr("x") - overflow, textGroup.attr("y"));
        }
      }
      if (direction2 === "upward" && y + minY <= coordinateBBox.minY || direction2 !== "upward" && y + maxY >= coordinateBBox.maxY) {
        var textBaseline = void 0;
        var factor = void 0;
        if (direction2 === "upward" && y + minY <= coordinateBBox.minY) {
          textBaseline = "top";
          factor = 1;
        } else {
          textBaseline = "bottom";
          factor = -1;
        }
        textShape.attr("textBaseline", textBaseline);
        if (lineShape) {
          lineShape.attr("path", [
            ["M", 0, 0],
            ["L", 0, lineLength * factor]
          ]);
        }
        applyTranslate(textGroup, textGroup.attr("x"), (lineLength + 2) * factor);
      }
    };
    DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
      var lineDisplay = get_default(this.get("line"), "display");
      var pointStyle = get_default(this.get("point"), "style", {});
      var lineStyle = get_default(this.get("line"), "style", {});
      var textStyle2 = get_default(this.get("text"), "style", {});
      var direction2 = this.get("direction");
      var lineLength = lineDisplay ? get_default(this.get("line"), "length", 0) : 0;
      var factor = direction2 === "upward" ? -1 : 1;
      return {
        point: __assign7({ x: 0, y: 0 }, pointStyle),
        line: __assign7({ path: [
          ["M", 0, 0],
          ["L", 0, lineLength * factor]
        ] }, lineStyle),
        text: __assign7({ x: 0, y: (lineLength + 2) * factor, text: get_default(this.get("text"), "content", ""), textBaseline: direction2 === "upward" ? "bottom" : "top" }, textStyle2)
      };
    };
    return DataMarkerAnnotation2;
  }(group_component_default);
  var data_marker_default = DataMarkerAnnotation;

  // node_modules/@antv/component/esm/annotation/data-region.js
  var DataRegionAnnotation = function(_super) {
    __extends7(DataRegionAnnotation2, _super);
    function DataRegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataRegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
        region: {
          style: {
            lineWidth: 0,
            fill: theme_default.regionColor,
            opacity: 0.4
          }
        },
        text: {
          content: "",
          style: {
            textAlign: "center",
            textBaseline: "bottom",
            fontSize: 12,
            fill: theme_default.textColor,
            fontFamily: theme_default.fontFamily
          }
        }
      } });
    };
    DataRegionAnnotation2.prototype.renderInner = function(group2) {
      var regionStyle = get_default(this.get("region"), "style", {});
      var textStyle2 = get_default(this.get("text"), "style", {});
      var lineLength = this.get("lineLength") || 0;
      var points = this.get("points");
      if (!points.length) {
        return;
      }
      var bbox = pointsToBBox(points);
      var path = [];
      path.push(["M", points[0].x, bbox.minY - lineLength]);
      points.forEach(function(point) {
        path.push(["L", point.x, point.y]);
      });
      path.push(["L", points[points.length - 1].x, points[points.length - 1].y - lineLength]);
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign7({ path }, regionStyle)
      });
      var textCfg = __assign7({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
      renderTag(group2, textCfg);
    };
    return DataRegionAnnotation2;
  }(group_component_default);
  var data_region_default = DataRegionAnnotation;

  // node_modules/@antv/component/esm/annotation/region-filter.js
  var RegionFilterAnnotation = function(_super) {
    __extends7(RegionFilterAnnotation2, _super);
    function RegionFilterAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
    };
    RegionFilterAnnotation2.prototype.renderInner = function(group2) {
      var _this = this;
      var start = this.get("start");
      var end = this.get("end");
      var layer = this.addGroup(group2, {
        id: this.getElementId("region-filter"),
        capture: false
      });
      each_default(this.get("shapes"), function(shape, shapeIdx) {
        var type = shape.get("type");
        var attrs = clone_default(shape.attr());
        _this.adjustShapeAttrs(attrs);
        _this.addShape(layer, {
          id: _this.getElementId("shape-" + type + "-" + shapeIdx),
          capture: false,
          type,
          attrs
        });
      });
      var clipBBox = regionToBBox({ start, end });
      layer.setClip({
        type: "rect",
        attrs: {
          x: clipBBox.minX,
          y: clipBBox.minY,
          width: clipBBox.width,
          height: clipBBox.height
        }
      });
    };
    RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
      var color2 = this.get("color");
      if (attr.fill) {
        attr.fill = attr.fillStyle = color2;
      }
      attr.stroke = attr.strokeStyle = color2;
    };
    return RegionFilterAnnotation2;
  }(group_component_default);
  var region_filter_default = RegionFilterAnnotation;

  // node_modules/@antv/component/esm/annotation/shape.js
  var ShapeAnnotation = function(_super) {
    __extends7(ShapeAnnotation2, _super);
    function ShapeAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "shape", draw: noop_default });
    };
    ShapeAnnotation2.prototype.renderInner = function(group2) {
      var render = this.get("render");
      if (is_function_default(render)) {
        render(group2);
      }
    };
    return ShapeAnnotation2;
  }(group_component_default);
  var shape_default4 = ShapeAnnotation;

  // node_modules/@antv/component/esm/abstract/html-component.js
  var HtmlComponent = function(_super) {
    __extends7(HtmlComponent2, _super);
    function HtmlComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
      return cfg;
    };
    HtmlComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    HtmlComponent2.prototype.show = function() {
      var container = this.get("container");
      container.style.display = "";
      this.set("visible", true);
    };
    HtmlComponent2.prototype.hide = function() {
      var container = this.get("container");
      container.style.display = "none";
      this.set("visible", false);
    };
    HtmlComponent2.prototype.setCapture = function(capture) {
      var container = this.getContainer();
      var value = capture ? "auto" : "none";
      container.style.pointerEvents = value;
      this.set("capture", capture);
    };
    HtmlComponent2.prototype.getBBox = function() {
      var container = this.getContainer();
      var x = parseFloat(container.style.left) || 0;
      var y = parseFloat(container.style.top) || 0;
      return createBBox(x, y, container.clientWidth, container.clientHeight);
    };
    HtmlComponent2.prototype.clear = function() {
      var container = this.get("container");
      clearDom(container);
    };
    HtmlComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    HtmlComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.initContainer();
      this.initDom();
      this.resetStyles();
      this.applyStyles();
      this.initEvent();
      this.initCapture();
      this.initVisible();
    };
    HtmlComponent2.prototype.initCapture = function() {
      this.setCapture(this.get("capture"));
    };
    HtmlComponent2.prototype.initVisible = function() {
      if (!this.get("visible")) {
        this.hide();
      } else {
        this.show();
      }
    };
    HtmlComponent2.prototype.initDom = function() {
    };
    HtmlComponent2.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_nil_default(container)) {
        container = this.createDom();
        var parent_1 = this.get("parent");
        if (is_string_default(parent_1)) {
          parent_1 = document.getElementById(parent_1);
          this.set("parent", parent_1);
        }
        parent_1.appendChild(container);
        this.set("container", container);
      } else if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
      if (!this.get("parent")) {
        this.set("parent", container.parentNode);
      }
    };
    HtmlComponent2.prototype.resetStyles = function() {
      var style = this.get("domStyles");
      var defaultStyles = this.get("defaultStyles");
      if (!style) {
        style = defaultStyles;
      } else {
        style = deep_mix_default({}, defaultStyles, style);
      }
      this.set("domStyles", style);
    };
    HtmlComponent2.prototype.applyStyles = function() {
      var domStyles = this.get("domStyles");
      if (!domStyles) {
        return;
      }
      var container = this.getContainer();
      this.applyChildrenStyles(container, domStyles);
      var containerClassName = this.get("containerClassName");
      if (containerClassName && hasClass(container, containerClassName)) {
        var containerCss = domStyles[containerClassName];
        modifyCSS(container, containerCss);
      }
    };
    HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
      each_default(styles, function(style, name) {
        var elements = element.getElementsByClassName(name);
        each_default(elements, function(el) {
          modifyCSS(el, style);
        });
      });
    };
    HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
      var domStyles = this.get("domStyles");
      modifyCSS(dom, domStyles[cssName]);
    };
    HtmlComponent2.prototype.createDom = function() {
      var containerTpl = this.get("containerTpl");
      return createDom(containerTpl);
    };
    HtmlComponent2.prototype.initEvent = function() {
    };
    HtmlComponent2.prototype.removeDom = function() {
      var container = this.get("container");
      container && container.parentNode && container.parentNode.removeChild(container);
    };
    HtmlComponent2.prototype.removeEvent = function() {
    };
    HtmlComponent2.prototype.updateInner = function(cfg) {
      if (has_key_default(cfg, "domStyles")) {
        this.resetStyles();
        this.applyStyles();
      }
      this.resetPosition();
    };
    HtmlComponent2.prototype.resetPosition = function() {
    };
    ;
    return HtmlComponent2;
  }(component_default);
  var html_component_default = HtmlComponent;

  // node_modules/@antv/component/esm/annotation/html.js
  var HtmlAnnotation = function(_super) {
    __extends7(HtmlAnnotation2, _super);
    function HtmlAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
    };
    HtmlAnnotation2.prototype.render = function() {
      var container = this.getContainer();
      var html = this.get("html");
      clearDom(container);
      var rst = is_function_default(html) ? html(container) : html;
      if (is_element_default(rst)) {
        container.appendChild(rst);
      } else if (is_string_default(rst)) {
        container.appendChild(createDom(rst));
      }
      this.resetPosition();
    };
    HtmlAnnotation2.prototype.resetPosition = function() {
      var container = this.getContainer();
      var _a4 = this.getLocation(), x = _a4.x, y = _a4.y;
      var alignX = this.get("alignX");
      var alignY = this.get("alignY");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      var domWidth = getOuterWidth(container);
      var domHeight = getOuterHeight(container);
      var position = {
        x,
        y
      };
      if (alignX === "middle") {
        position.x -= Math.round(domWidth / 2);
      } else if (alignX === "right") {
        position.x -= Math.round(domWidth);
      }
      if (alignY === "middle") {
        position.y -= Math.round(domHeight / 2);
      } else if (alignY === "bottom") {
        position.y -= Math.round(domHeight);
      }
      if (offsetX) {
        position.x += offsetX;
      }
      if (offsetY) {
        position.y += offsetY;
      }
      modifyCSS(container, {
        position: "absolute",
        left: position.x + "px",
        top: position.y + "px",
        zIndex: this.get("zIndex")
      });
    };
    return HtmlAnnotation2;
  }(html_component_default);
  var html_default = HtmlAnnotation;

  // node_modules/@antv/component/esm/axis/index.js
  var axis_exports = {};
  __export(axis_exports, {
    Base: () => base_default9,
    Circle: () => circle_default3,
    Line: () => line_default5
  });

  // node_modules/@antv/component/esm/util/state.js
  function getStatesStyle(item, elementName, stateStyles) {
    var styleName = elementName + "Style";
    var styles = null;
    each_default(stateStyles, function(v, state) {
      if (item[state] && v[styleName]) {
        if (!styles) {
          styles = {};
        }
        mix(styles, v[styleName]);
      }
    });
    return styles;
  }

  // node_modules/@antv/component/esm/axis/base.js
  var AxisBase = function(_super) {
    __extends7(AxisBase2, _super);
    function AxisBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        name: "axis",
        ticks: [],
        line: {},
        tickLine: {},
        subTickLine: null,
        title: null,
        label: {},
        verticalFactor: 1,
        verticalLimitLength: null,
        overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
        tickStates: {},
        optimize: {},
        defaultCfg: {
          line: {
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            }
          },
          tickLine: {
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            },
            alignTick: true,
            length: 5,
            displayWithLabel: true
          },
          subTickLine: {
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            },
            count: 4,
            length: 2
          },
          label: {
            autoRotate: true,
            autoHide: false,
            autoEllipsis: false,
            style: {
              fontSize: 12,
              fill: theme_default.textColor,
              fontFamily: theme_default.fontFamily,
              fontWeight: "normal"
            },
            offset: 10,
            offsetX: 0,
            offsetY: 0
          },
          title: {
            autoRotate: true,
            spacing: 5,
            position: "center",
            style: {
              fontSize: 12,
              fill: theme_default.textColor,
              textBaseline: "middle",
              fontFamily: theme_default.fontFamily,
              textAlign: "center"
            }
          },
          tickStates: {
            active: {
              labelStyle: {
                fontWeight: 500
              },
              tickLineStyle: {
                lineWidth: 2
              }
            },
            inactive: {
              labelStyle: {
                fill: theme_default.uncheckedColor
              }
            }
          },
          optimize: {
            enable: true,
            threshold: 400
          }
        },
        theme: {}
      });
    };
    AxisBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.drawLine(group2);
      }
      this.drawTicks(group2);
      if (this.get("title")) {
        this.drawTitle(group2);
      }
    };
    AxisBase2.prototype.isList = function() {
      return true;
    };
    AxisBase2.prototype.getItems = function() {
      return this.get("ticks");
    };
    AxisBase2.prototype.setItems = function(items) {
      this.update({
        ticks: items
      });
    };
    AxisBase2.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    AxisBase2.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("label-group");
      itemGroup && itemGroup.clear();
    };
    AxisBase2.prototype.setItemState = function(item, state, value) {
      item[state] = value;
      this.updateTickStates(item);
    };
    AxisBase2.prototype.hasState = function(item, state) {
      return !!item[state];
    };
    AxisBase2.prototype.getItemStates = function(item) {
      var tickStates = this.get("tickStates");
      var rst = [];
      each_default(tickStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    AxisBase2.prototype.clearItemsState = function(state) {
      var _this = this;
      var items = this.getItemsByState(state);
      each_default(items, function(item) {
        _this.setItemState(item, state, false);
      });
    };
    AxisBase2.prototype.getItemsByState = function(state) {
      var _this = this;
      var items = this.getItems();
      return filter_default(items, function(item) {
        return _this.hasState(item, state);
      });
    };
    AxisBase2.prototype.getSidePoint = function(point, offset) {
      var self2 = this;
      var vector = self2.getSideVector(offset, point);
      return {
        x: point.x + vector[0],
        y: point.y + vector[1]
      };
    };
    AxisBase2.prototype.getTextAnchor = function(vector) {
      var align;
      if (isNumberEqual(vector[0], 0)) {
        align = "center";
      } else if (vector[0] > 0) {
        align = "start";
      } else if (vector[0] < 0) {
        align = "end";
      }
      return align;
    };
    AxisBase2.prototype.getTextBaseline = function(vector) {
      var base;
      if (isNumberEqual(vector[1], 0)) {
        base = "middle";
      } else if (vector[1] > 0) {
        base = "top";
      } else if (vector[1] < 0) {
        base = "bottom";
      }
      return base;
    };
    AxisBase2.prototype.processOverlap = function(labelGroup) {
    };
    AxisBase2.prototype.drawLine = function(group2) {
      var path = this.getLinePath();
      var line = this.get("line");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "axis-line",
        attrs: mix({
          path
        }, line.style)
      });
    };
    AxisBase2.prototype.getTickLineItems = function(ticks) {
      var _this = this;
      var tickLineItems = [];
      var tickLine = this.get("tickLine");
      var alignTick = tickLine.alignTick;
      var tickLineLength = tickLine.length;
      var tickSegment = 1;
      var tickCount = ticks.length;
      if (tickCount >= 2) {
        tickSegment = ticks[1].value - ticks[0].value;
      }
      each_default(ticks, function(tick2) {
        var point = tick2.point;
        if (!alignTick) {
          point = _this.getTickPoint(tick2.value - tickSegment / 2);
        }
        var endPoint = _this.getSidePoint(point, tickLineLength);
        tickLineItems.push({
          startPoint: point,
          tickValue: tick2.value,
          endPoint,
          tickId: tick2.id,
          id: "tickline-" + tick2.id
        });
      });
      return tickLineItems;
    };
    AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
      var subTickLineItems = [];
      var subTickLine = this.get("subTickLine");
      var subCount = subTickLine.count;
      var tickLineCount = tickLineItems.length;
      if (tickLineCount >= 2) {
        for (var i = 0; i < tickLineCount - 1; i++) {
          var pre = tickLineItems[i];
          var next = tickLineItems[i + 1];
          for (var j = 0; j < subCount; j++) {
            var percent = (j + 1) / (subCount + 1);
            var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;
            var point = this.getTickPoint(tickValue);
            var endPoint = this.getSidePoint(point, subTickLine.length);
            subTickLineItems.push({
              startPoint: point,
              endPoint,
              tickValue,
              id: "sub-" + pre.id + "-" + j
            });
          }
        }
      }
      return subTickLineItems;
    };
    AxisBase2.prototype.getTickLineAttrs = function(tickItem, type, index, tickItems) {
      var style = this.get(type).style;
      var item = {
        points: [tickItem.startPoint, tickItem.endPoint]
      };
      var defaultTickLineStyle = get_default(this.get("theme"), ["tickLine", "style"], {});
      style = is_function_default(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
      var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
      return __assign7({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
    };
    AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type, index, tickItems) {
      this.addShape(tickLineGroup, {
        type: "line",
        id: this.getElementId(tickItem.id),
        name: "axis-" + type,
        attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
      });
    };
    AxisBase2.prototype.drawTickLines = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var subTickLine = this.get("subTickLine");
      var tickLineItems = this.getTickLineItems(ticks);
      var tickLineGroup = this.addGroup(group2, {
        name: "axis-tickline-group",
        id: this.getElementId("tickline-group")
      });
      var tickCfg = this.get("tickLine");
      each_default(tickLineItems, function(item, index) {
        if (tickCfg.displayWithLabel) {
          var labelId = _this.getElementId("label-" + item.tickId);
          if (group2.findById(labelId)) {
            _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
          }
        } else {
          _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
        }
      });
      if (subTickLine) {
        var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
        each_default(subTickLineItems_1, function(item, index) {
          _this.drawTick(item, tickLineGroup, "subTickLine", index, subTickLineItems_1);
        });
      }
    };
    AxisBase2.prototype.processTicks = function() {
      var _this = this;
      var ticks = this.get("ticks");
      each_default(ticks, function(tick2) {
        tick2.point = _this.getTickPoint(tick2.value);
        if (is_nil_default(tick2.id)) {
          tick2.id = tick2.name;
        }
      });
    };
    AxisBase2.prototype.drawTicks = function(group2) {
      var _this = this;
      this.optimizeTicks();
      this.processTicks();
      if (this.get("label")) {
        this.drawLabels(group2);
      }
      if (this.get("tickLine")) {
        this.drawTickLines(group2);
      }
      var ticks = this.get("ticks");
      each_default(ticks, function(tick2) {
        _this.applyTickStates(tick2, group2);
      });
    };
    AxisBase2.prototype.optimizeTicks = function() {
      var optimize = this.get("optimize");
      var ticks = this.get("ticks");
      if (optimize && optimize.enable && optimize.threshold > 0) {
        var len3 = size2(ticks);
        if (len3 > optimize.threshold) {
          var page_1 = Math.ceil(len3 / optimize.threshold);
          var optimizedTicks = ticks.filter(function(tick2, idx) {
            return idx % page_1 === 0;
          });
          this.set("ticks", optimizedTicks);
          this.set("originalTicks", ticks);
        }
      }
    };
    AxisBase2.prototype.getLabelAttrs = function(tick2, index, ticks) {
      var labelCfg = this.get("label");
      var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate5 = labelCfg.rotate, formatter = labelCfg.formatter;
      var point = this.getSidePoint(tick2.point, offset);
      var vector = this.getSideVector(offset, point);
      var text = formatter ? formatter(tick2.name, tick2, index) : tick2.name;
      var style = labelCfg.style;
      style = is_function_default(style) ? get_default(this.get("theme"), ["label", "style"], {}) : style;
      var attrs = mix({
        x: point.x + offsetX,
        y: point.y + offsetY,
        text,
        textAlign: this.getTextAnchor(vector),
        textBaseline: this.getTextBaseline(vector)
      }, style);
      if (rotate5) {
        attrs.matrix = getMatrixByAngle(point, rotate5);
      }
      return attrs;
    };
    AxisBase2.prototype.drawLabels = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var labelGroup = this.addGroup(group2, {
        name: "axis-label-group",
        id: this.getElementId("label-group")
      });
      each_default(ticks, function(tick2, index) {
        _this.addShape(labelGroup, {
          type: "text",
          name: "axis-label",
          id: _this.getElementId("label-" + tick2.id),
          attrs: _this.getLabelAttrs(tick2, index, ticks),
          delegateObject: {
            tick: tick2,
            item: tick2,
            index
          }
        });
      });
      this.processOverlap(labelGroup);
      var labels = labelGroup.getChildren();
      var defaultLabelStyle = get_default(this.get("theme"), ["label", "style"], {});
      var _a4 = this.get("label"), style = _a4.style, formatter = _a4.formatter;
      if (is_function_default(style)) {
        var afterProcessTicks_1 = labels.map(function(label) {
          return get_default(label.get("delegateObject"), "tick");
        });
        each_default(labels, function(label, index) {
          var tick2 = label.get("delegateObject").tick;
          var text = formatter ? formatter(tick2.name, tick2, index) : tick2.name;
          var newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
          label.attr(newStyle);
        });
      }
    };
    AxisBase2.prototype.getTitleAttrs = function() {
      var titleCfg = this.get("title");
      var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a4 = titleCfg.spacing, spacing = _a4 === void 0 ? 0 : _a4, autoRotate = titleCfg.autoRotate;
      var titleHeight = style.fontSize;
      var percent = 0.5;
      if (position === "start") {
        percent = 0;
      } else if (position === "end") {
        percent = 1;
      }
      var point = this.getTickPoint(percent);
      var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2);
      var attrs = mix({
        x: titlePoint.x,
        y: titlePoint.y,
        text: titleCfg.text
      }, style);
      var rotate5 = titleCfg.rotate;
      var angle3 = rotate5;
      if (is_nil_default(rotate5) && autoRotate) {
        var vector = this.getAxisVector(point);
        var v1 = [1, 0];
        angle3 = ext_exports.angleTo(vector, v1, true);
      }
      if (angle3) {
        var matrix = getMatrixByAngle(titlePoint, angle3);
        attrs.matrix = matrix;
      }
      return attrs;
    };
    AxisBase2.prototype.drawTitle = function(group2) {
      this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "axis-title",
        attrs: this.getTitleAttrs()
      });
    };
    AxisBase2.prototype.applyTickStates = function(tick2, group2) {
      var states = this.getItemStates(tick2);
      if (states.length) {
        var tickStates = this.get("tickStates");
        var labelId = this.getElementId("label-" + tick2.id);
        var labelShape = group2.findById(labelId);
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick2, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        var tickLineId = this.getElementId("tickline-" + tick2.id);
        var tickLineShape = group2.findById(tickLineId);
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick2, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      }
    };
    AxisBase2.prototype.updateTickStates = function(tick2) {
      var states = this.getItemStates(tick2);
      var tickStates = this.get("tickStates");
      var labelCfg = this.get("label");
      var labelShape = this.getElementByLocalId("label-" + tick2.id);
      var tickLineCfg = this.get("tickLine");
      var tickLineShape = this.getElementByLocalId("tickline-" + tick2.id);
      if (states.length) {
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick2, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick2, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      } else {
        if (labelShape) {
          labelShape.attr(labelCfg.style);
        }
        if (tickLineShape) {
          tickLineShape.attr(tickLineCfg.style);
        }
      }
    };
    return AxisBase2;
  }(group_component_default);
  var base_default9 = AxisBase;

  // node_modules/@antv/component/esm/axis/overlap/index.js
  var overlap_exports = {};
  __export(overlap_exports, {
    autoEllipsis: () => auto_ellipsis_exports,
    autoHide: () => auto_hide_exports,
    autoRotate: () => auto_rotate_exports
  });

  // node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js
  var auto_ellipsis_exports = {};
  __export(auto_ellipsis_exports, {
    ellipsisHead: () => ellipsisHead,
    ellipsisMiddle: () => ellipsisMiddle,
    ellipsisTail: () => ellipsisTail,
    getDefault: () => getDefault
  });
  function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
    var children = labelGroup.getChildren();
    var ellipsisFlag = false;
    each_default(children, function(label) {
      var rst = ellipsisLabel(isVertical2, label, limitLength, position);
      ellipsisFlag = ellipsisFlag || rst;
    });
    return ellipsisFlag;
  }
  function getDefault() {
    return ellipsisTail;
  }
  function ellipsisHead(isVertical2, labelGroup, limitLength) {
    return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
  }
  function ellipsisTail(isVertical2, labelGroup, limitLength) {
    return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
  }
  function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
    return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
  }

  // node_modules/@antv/component/esm/axis/overlap/auto-hide.js
  var auto_hide_exports = {};
  __export(auto_hide_exports, {
    equidistance: () => equidistance,
    equidistanceWithReverseBoth: () => equidistanceWithReverseBoth,
    getDefault: () => getDefault2,
    reserveBoth: () => reserveBoth,
    reserveFirst: () => reserveFirst,
    reserveLast: () => reserveLast
  });
  function isRotate(label) {
    var matrix = label.attr("matrix");
    return matrix && matrix[0] !== 1;
  }
  function getRotateAngle(label) {
    var angle3 = isRotate(label) ? getAngleByMatrix(label.attr("matrix")) : 0;
    return angle3 % 360;
  }
  function isOverlap(isVertical2, first, second, minGap) {
    var overlap2 = false;
    var angle3 = getRotateAngle(first);
    var distance8 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
    var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
    if (isVertical2) {
      var ratio = Math.abs(Math.cos(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        overlap2 = prevBBox.width + minGap > distance8;
      } else {
        overlap2 = prevBBox.height / ratio + minGap > distance8;
      }
    } else {
      var ratio = Math.abs(Math.sin(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        overlap2 = prevBBox.width + minGap > distance8;
      } else {
        overlap2 = prevBBox.height / ratio + minGap > distance8;
      }
    }
    return overlap2;
  }
  function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice().filter(function(item) {
      return item.get("visible");
    });
    if (!labels.length) {
      return false;
    }
    var hasHide = false;
    if (reversed) {
      labels.reverse();
    }
    var count = labels.length;
    var first = labels[0];
    var prev = first;
    for (var i = 1; i < count; i++) {
      var label = labels[i];
      var curBBox = label.getBBox();
      var isHide = isOverlap(isVertical2, prev, label, minGap);
      if (isHide) {
        label.hide();
        hasHide = true;
      } else {
        prev = label;
      }
    }
    return hasHide;
  }
  function parityHide(isVertical2, labelsGroup, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice();
    if (labels.length < 2) {
      return false;
    }
    var hasHide = false;
    var first = labels[0];
    var firstBBox = first.getBBox();
    var second = labels[1];
    var count = labels.length;
    var angle3 = getRotateAngle(first);
    var distance8 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
    var interval2 = 0;
    if (isVertical2) {
      var ratio = Math.abs(Math.cos(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        var maxWidth = getMaxLabelWidth(labels);
        interval2 = (maxWidth + minGap) / distance8;
      } else {
        interval2 = (firstBBox.height / ratio + minGap) / distance8;
      }
    } else {
      var ratio = Math.abs(Math.sin(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        var maxWidth = getMaxLabelWidth(labels);
        interval2 = (maxWidth + minGap) / distance8;
      } else {
        interval2 = (firstBBox.height / ratio + minGap) / distance8;
      }
    }
    if (interval2 > 1) {
      interval2 = Math.ceil(interval2);
      for (var i = 0; i < count; i++) {
        if (i % interval2 !== 0) {
          labels[i].hide();
          hasHide = true;
        }
      }
    }
    return hasHide;
  }
  function getDefault2() {
    return equidistance;
  }
  function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
  }
  function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
  }
  function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice();
    if (labels.length <= 2) {
      return false;
    }
    var hasHide = false;
    var count = labels.length;
    var first = labels[0];
    var last2 = labels[count - 1];
    var preLabel = first;
    for (var i = 1; i < count - 1; i++) {
      var label = labels[i];
      var curBBox = label.getBBox();
      var isHide = isOverlap(isVertical2, preLabel, label, minGap);
      if (isHide) {
        label.hide();
        hasHide = true;
      } else {
        preLabel = label;
      }
    }
    var overlap2 = isOverlap(isVertical2, preLabel, last2, minGap);
    if (overlap2) {
      preLabel.hide();
      hasHide = true;
    }
    return hasHide;
  }
  function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
    if (reserveOne(isVertical2, labelsGroup, false)) {
      hasHide = true;
    }
    return hasHide;
  }
  function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    var labels = labelsGroup.getChildren().slice();
    var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
    if (labels.length > 2) {
      var first = labels[0];
      var last2 = labels[labels.length - 1];
      if (!first.get("visible")) {
        first.show();
        if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
          hasHide = true;
        }
      }
      if (!last2.get("visible")) {
        last2.show();
        if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
          hasHide = true;
        }
      }
    }
    return hasHide;
  }

  // node_modules/@antv/component/esm/axis/overlap/auto-rotate.js
  var auto_rotate_exports = {};
  __export(auto_rotate_exports, {
    fixedAngle: () => fixedAngle,
    getDefault: () => getDefault3,
    unfixedAngle: () => unfixedAngle
  });
  function setLabelsAngle(labels, angle3) {
    each_default(labels, function(label) {
      var x = label.attr("x");
      var y = label.attr("y");
      var matrix = getMatrixByAngle({ x, y }, angle3);
      label.attr("matrix", matrix);
    });
  }
  function labelRotate(isVertical2, labelsGroup, limitLength, getAngle4) {
    var labels = labelsGroup.getChildren();
    if (!labels.length) {
      return false;
    }
    if (!isVertical2 && labels.length < 2) {
      return false;
    }
    var maxWidth = getMaxLabelWidth(labels);
    var isOverlap2 = false;
    if (isVertical2) {
      isOverlap2 = !!limitLength && maxWidth > limitLength;
    } else {
      var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
      isOverlap2 = maxWidth > tickWidth;
    }
    if (isOverlap2) {
      var angle3 = getAngle4(limitLength, maxWidth);
      setLabelsAngle(labels, angle3);
    }
    return isOverlap2;
  }
  function getDefault3() {
    return fixedAngle;
  }
  function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
    return labelRotate(isVertical2, labelsGroup, limitLength, function() {
      if (is_number_default(customRotate)) {
        return customRotate;
      }
      return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
    });
  }
  function unfixedAngle(isVertical2, labelsGroup, limitLength) {
    return labelRotate(isVertical2, labelsGroup, limitLength, function(length3, maxWidth) {
      if (!length3) {
        return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
      }
      if (isVertical2) {
        return -Math.acos(length3 / maxWidth);
      } else {
        var angle3 = 0;
        if (length3 > maxWidth) {
          angle3 = Math.PI / 4;
        } else {
          angle3 = Math.asin(length3 / maxWidth);
          if (angle3 > Math.PI / 4) {
            angle3 = Math.PI / 4;
          }
        }
        return angle3;
      }
    });
  }

  // node_modules/@antv/component/esm/axis/line.js
  var Line = function(_super) {
    __extends7(Line6, _super);
    function Line6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        type: "line",
        locationType: "region",
        start: null,
        end: null
      });
    };
    Line6.prototype.getLinePath = function() {
      var start = this.get("start");
      var end = this.get("end");
      var path = [];
      path.push(["M", start.x, start.y]);
      path.push(["L", end.x, end.y]);
      return path;
    };
    Line6.prototype.getInnerLayoutBBox = function() {
      var start = this.get("start");
      var end = this.get("end");
      var bbox = _super.prototype.getInnerLayoutBBox.call(this);
      var minX = Math.min(start.x, end.x, bbox.x);
      var minY = Math.min(start.y, end.y, bbox.y);
      var maxX = Math.max(start.x, end.x, bbox.maxX);
      var maxY = Math.max(start.y, end.y, bbox.maxY);
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    Line6.prototype.isVertical = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual(start.x, end.x);
    };
    Line6.prototype.isHorizontal = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual(start.y, end.y);
    };
    Line6.prototype.getTickPoint = function(tickValue) {
      var self2 = this;
      var start = self2.get("start");
      var end = self2.get("end");
      var regionX = end.x - start.x;
      var regionY = end.y - start.y;
      return {
        x: start.x + regionX * tickValue,
        y: start.y + regionY * tickValue
      };
    };
    Line6.prototype.getSideVector = function(offset) {
      var axisVector = this.getAxisVector();
      var normal = vec2_exports.normalize([0, 0], axisVector);
      var factor = this.get("verticalFactor");
      var verticalVector = [normal[1], normal[0] * -1];
      return vec2_exports.scale([0, 0], verticalVector, offset * factor);
    };
    Line6.prototype.getAxisVector = function() {
      var start = this.get("start");
      var end = this.get("end");
      return [end.x - start.x, end.y - start.y];
    };
    Line6.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var isHorizontal = this.isHorizontal();
      if (!isVertical2 && !isHorizontal) {
        return;
      }
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each_default(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (is_nil_default(titleCfg.offset)) {
          var bbox = labelGroup.getCanvasBBox();
          var length_1 = isVertical2 ? bbox.width : bbox.height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Line6.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return is_nil_default(labelCfg.rotate);
      }
      return true;
    };
    Line6.prototype.autoProcessOverlap = function(name, value, labelGroup, limitLength) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var hasAdjusted = false;
      var util = overlap_exports[name];
      if (value === true) {
        var labelCfg = this.get("label");
        hasAdjusted = util.getDefault()(isVertical2, labelGroup, limitLength);
      } else if (is_function_default(value)) {
        hasAdjusted = value(isVertical2, labelGroup, limitLength);
      } else if (is_object_default(value)) {
        var overlapCfg = value;
        if (util[overlapCfg.type]) {
          hasAdjusted = util[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util[value]) {
        hasAdjusted = util[value](isVertical2, labelGroup, limitLength);
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each_default(labels, function(label) {
            var textAlign = label.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each_default(children, function(label) {
          if (!label.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label);
            }
            label.remove();
          }
        });
      }
    };
    return Line6;
  }(base_default9);
  var line_default5 = Line;

  // node_modules/@antv/component/esm/axis/circle.js
  var Circle = function(_super) {
    __extends7(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    Circle6.prototype.getLinePath = function() {
      var center = this.get("center");
      var x = center.x;
      var y = center.y;
      var rx = this.get("radius");
      var ry = rx;
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var path = [];
      if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
        path = [["M", x, y - ry], ["A", rx, ry, 0, 1, 1, x, y + ry], ["A", rx, ry, 0, 1, 1, x, y - ry], ["Z"]];
      } else {
        var startPoint = this.getCirclePoint(startAngle);
        var endPoint = this.getCirclePoint(endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path = [
          ["M", x, y],
          ["L", startPoint.x, startPoint.y],
          ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
          ["L", x, y]
        ];
      }
      return path;
    };
    Circle6.prototype.getTickPoint = function(tickValue) {
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var angle3 = startAngle + (endAngle - startAngle) * tickValue;
      return this.getCirclePoint(angle3);
    };
    Circle6.prototype.getSideVector = function(offset, point) {
      var center = this.get("center");
      var vector = [point.x - center.x, point.y - center.y];
      var factor = this.get("verticalFactor");
      var vecLen = vec2_exports.length(vector);
      vec2_exports.scale(vector, vector, factor * offset / vecLen);
      return vector;
    };
    Circle6.prototype.getAxisVector = function(point) {
      var center = this.get("center");
      var vector = [point.x - center.x, point.y - center.y];
      return [vector[1], -1 * vector[0]];
    };
    Circle6.prototype.getCirclePoint = function(angle3, radius) {
      var center = this.get("center");
      radius = radius || this.get("radius");
      return {
        x: center.x + Math.cos(angle3) * radius,
        y: center.y + Math.sin(angle3) * radius
      };
    };
    Circle6.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return is_nil_default(labelCfg.rotate);
      }
      return true;
    };
    Circle6.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each_default(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (is_nil_default(titleCfg.offset)) {
          var length_1 = labelGroup.getCanvasBBox().height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Circle6.prototype.autoProcessOverlap = function(name, value, labelGroup, limitLength) {
      var _this = this;
      var hasAdjusted = false;
      var util = overlap_exports[name];
      if (limitLength > 0) {
        if (value === true) {
          hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
        } else if (is_function_default(value)) {
          hasAdjusted = value(false, labelGroup, limitLength);
        } else if (is_object_default(value)) {
          var overlapCfg = value;
          if (util[overlapCfg.type]) {
            hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
          }
        } else if (util[value]) {
          hasAdjusted = util[value](false, labelGroup, limitLength);
        }
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each_default(labels, function(label) {
            var textAlign = label.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each_default(children, function(label) {
          if (!label.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label);
            }
            label.remove();
          }
        });
      }
    };
    return Circle6;
  }(base_default9);
  var circle_default3 = Circle;

  // node_modules/@antv/component/esm/crosshair/index.js
  var crosshair_exports = {};
  __export(crosshair_exports, {
    Base: () => base_default10,
    Circle: () => circle_default4,
    Html: () => html_default2,
    Line: () => line_default6
  });

  // node_modules/@antv/component/esm/crosshair/base.js
  var CrosshairBase = function(_super) {
    __extends7(CrosshairBase2, _super);
    function CrosshairBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        },
        text: {
          position: "start",
          offset: 10,
          autoRotate: false,
          content: null,
          style: {
            fill: theme_default.textColor,
            textAlign: "center",
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily
          }
        },
        textBackground: {
          padding: 5,
          style: {
            stroke: theme_default.lineColor
          }
        }
      } });
    };
    CrosshairBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.renderLine(group2);
      }
      if (this.get("text")) {
        this.renderText(group2);
        this.renderBackground(group2);
      }
    };
    CrosshairBase2.prototype.renderText = function(group2) {
      var text = this.get("text");
      var style = text.style, autoRotate = text.autoRotate, content = text.content;
      if (!is_nil_default(content)) {
        var textPoint = this.getTextPoint();
        var matrix = null;
        if (autoRotate) {
          var angle3 = this.getRotateAngle();
          matrix = getMatrixByAngle(textPoint, angle3);
        }
        this.addShape(group2, {
          type: "text",
          name: "crosshair-text",
          id: this.getElementId("text"),
          attrs: __assign7(__assign7(__assign7({}, textPoint), { text: content, matrix }), style)
        });
      }
    };
    CrosshairBase2.prototype.renderLine = function(group2) {
      var path = this.getLinePath();
      var line = this.get("line");
      var style = line.style;
      this.addShape(group2, {
        type: "path",
        name: "crosshair-line",
        id: this.getElementId("line"),
        attrs: __assign7({ path }, style)
      });
    };
    CrosshairBase2.prototype.renderBackground = function(group2) {
      var textId = this.getElementId("text");
      var textShape = group2.findById(textId);
      var textBackground = this.get("textBackground");
      if (textBackground && textShape) {
        var textBBox = textShape.getBBox();
        var padding = formatPadding(textBackground.padding);
        var style = textBackground.style;
        var backgroundShape = this.addShape(group2, {
          type: "rect",
          name: "crosshair-text-background",
          id: this.getElementId("text-background"),
          attrs: __assign7({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2], matrix: textShape.attr("matrix") }, style)
        });
        backgroundShape.toBack();
      }
    };
    return CrosshairBase2;
  }(group_component_default);
  var base_default10 = CrosshairBase;

  // node_modules/@antv/component/esm/crosshair/line.js
  var LineCrosshair = function(_super) {
    __extends7(LineCrosshair3, _super);
    function LineCrosshair3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "line", locationType: "region", start: null, end: null });
    };
    LineCrosshair3.prototype.getRotateAngle = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      var position = this.get("text").position;
      var angle3 = Math.atan2(end.y - start.y, end.x - start.x);
      var tangentAngle = position === "start" ? angle3 - Math.PI / 2 : angle3 + Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair3.prototype.getTextPoint = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    LineCrosshair3.prototype.getLinePath = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      return [
        ["M", start.x, start.y],
        ["L", end.x, end.y]
      ];
    };
    return LineCrosshair3;
  }(base_default10);
  var line_default6 = LineCrosshair;

  // node_modules/@antv/component/esm/crosshair/circle.js
  var LineCrosshair2 = function(_super) {
    __extends7(LineCrosshair3, _super);
    function LineCrosshair3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    LineCrosshair3.prototype.getRotateAngle = function() {
      var _a4 = this.getLocation(), startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var position = this.get("text").position;
      var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair3.prototype.getTextPoint = function() {
      var text = this.get("text");
      var position = text.position, offset = text.offset;
      var _a4 = this.getLocation(), center = _a4.center, radius = _a4.radius, startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var angle3 = position === "start" ? startAngle : endAngle;
      var tangentAngle = this.getRotateAngle() - Math.PI;
      var point = getCirclePoint(center, radius, angle3);
      var offsetX = Math.cos(tangentAngle) * offset;
      var offsetY = Math.sin(tangentAngle) * offset;
      return {
        x: point.x + offsetX,
        y: point.y + offsetY
      };
    };
    LineCrosshair3.prototype.getLinePath = function() {
      var _a4 = this.getLocation(), center = _a4.center, radius = _a4.radius, startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var path = null;
      if (endAngle - startAngle === Math.PI * 2) {
        var x = center.x, y = center.y;
        path = [
          ["M", x, y - radius],
          ["A", radius, radius, 0, 1, 1, x, y + radius],
          ["A", radius, radius, 0, 1, 1, x, y - radius],
          ["Z"]
        ];
      } else {
        var startPoint = getCirclePoint(center, radius, startAngle);
        var endPoint = getCirclePoint(center, radius, endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path = [
          ["M", startPoint.x, startPoint.y],
          ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
        ];
      }
      return path;
    };
    return LineCrosshair3;
  }(base_default10);
  var circle_default4 = LineCrosshair2;

  // node_modules/@antv/component/esm/crosshair/css-const.js
  var CONTAINER_CLASS = "g2-crosshair";
  var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
  var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";

  // node_modules/@antv/component/esm/crosshair/html-theme.js
  var _a2;
  var html_theme_default = (_a2 = {}, _a2["" + CONTAINER_CLASS] = {
    position: "relative"
  }, _a2["" + CROSSHAIR_LINE] = {
    position: "absolute",
    backgroundColor: "rgba(0, 0, 0, 0.25)"
  }, _a2["" + CROSSHAIR_TEXT] = {
    position: "absolute",
    color: theme_default.textColor,
    fontFamily: theme_default.fontFamily
  }, _a2);

  // node_modules/@antv/component/esm/crosshair/html.js
  var HtmlCrosshair = function(_super) {
    __extends7(HtmlCrosshair2, _super);
    function HtmlCrosshair2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlCrosshair2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS, defaultStyles: html_theme_default, defaultCfg: {
        text: {
          position: "start",
          content: null,
          align: "center",
          offset: 10
        }
      } });
    };
    HtmlCrosshair2.prototype.render = function() {
      this.resetText();
      this.resetPosition();
    };
    HtmlCrosshair2.prototype.initCrossHair = function() {
      var container = this.getContainer();
      var crosshairTpl = this.get("crosshairTpl");
      var crosshairEl = createDom(crosshairTpl);
      container.appendChild(crosshairEl);
      this.applyStyle(CROSSHAIR_LINE, crosshairEl);
      this.set("crosshairEl", crosshairEl);
    };
    HtmlCrosshair2.prototype.getTextPoint = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    HtmlCrosshair2.prototype.resetText = function() {
      var text = this.get("text");
      var textEl = this.get("textEl");
      if (text) {
        var content = text.content;
        if (!textEl) {
          var container = this.getContainer();
          var textTpl = substitute_default(this.get("textTpl"), text);
          textEl = createDom(textTpl);
          container.appendChild(textEl);
          this.applyStyle(CROSSHAIR_TEXT, textEl);
          this.set("textEl", textEl);
        }
        textEl.innerHTML = content;
      } else if (textEl) {
        textEl.remove();
      }
    };
    HtmlCrosshair2.prototype.isVertical = function(start, end) {
      return start.x === end.x;
    };
    HtmlCrosshair2.prototype.resetPosition = function() {
      var crosshairEl = this.get("crosshairEl");
      if (!crosshairEl) {
        this.initCrossHair();
        crosshairEl = this.get("crosshairEl");
      }
      var start = this.get("start");
      var end = this.get("end");
      var minX = Math.min(start.x, end.x);
      var minY = Math.min(start.y, end.y);
      if (this.isVertical(start, end)) {
        modifyCSS(crosshairEl, {
          width: "1px",
          height: toPx(Math.abs(end.y - start.y))
        });
      } else {
        modifyCSS(crosshairEl, {
          height: "1px",
          width: toPx(Math.abs(end.x - start.x))
        });
      }
      modifyCSS(crosshairEl, {
        top: toPx(minY),
        left: toPx(minX)
      });
      this.alignText();
    };
    HtmlCrosshair2.prototype.alignText = function() {
      var textEl = this.get("textEl");
      if (textEl) {
        var align = this.get("text").align;
        var clientWidth = textEl.clientWidth;
        var point = this.getTextPoint();
        switch (align) {
          case "center":
            point.x = point.x - clientWidth / 2;
            break;
          case "right":
            point.x = point.x - clientWidth;
          case "left":
            break;
        }
        modifyCSS(textEl, {
          top: toPx(point.y),
          left: toPx(point.x)
        });
      }
    };
    HtmlCrosshair2.prototype.updateInner = function(cfg) {
      if (has_key_default(cfg, "text")) {
        this.resetText();
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    return HtmlCrosshair2;
  }(html_component_default);
  var html_default2 = HtmlCrosshair;

  // node_modules/@antv/component/esm/grid/index.js
  var grid_exports = {};
  __export(grid_exports, {
    Base: () => base_default11,
    Circle: () => circle_default5,
    Line: () => line_default7
  });

  // node_modules/@antv/component/esm/grid/base.js
  var GridBase = function(_super) {
    __extends7(GridBase2, _super);
    function GridBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GridBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
        line: {
          type: "line",
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        }
      } });
    };
    GridBase2.prototype.getLineType = function() {
      var line = this.get("line") || this.get("defaultCfg").line;
      return line.type;
    };
    GridBase2.prototype.renderInner = function(group2) {
      this.drawGrid(group2);
    };
    GridBase2.prototype.getAlternatePath = function(prePoints, points) {
      var regionPath = this.getGridPath(prePoints);
      var reversePoints = points.slice(0).reverse();
      var nextPath = this.getGridPath(reversePoints, true);
      var closed = this.get("closed");
      if (closed) {
        regionPath = regionPath.concat(nextPath);
      } else {
        nextPath[0][0] = "L";
        regionPath = regionPath.concat(nextPath);
        regionPath.push(["Z"]);
      }
      return regionPath;
    };
    GridBase2.prototype.getPathStyle = function() {
      return this.get("line").style;
    };
    GridBase2.prototype.drawGrid = function(group2) {
      var _this = this;
      var line = this.get("line");
      var items = this.get("items");
      var alternateColor = this.get("alternateColor");
      var preItem = null;
      each_default(items, function(item, index) {
        var id = item.id || index;
        if (line) {
          var style = _this.getPathStyle();
          style = is_function_default(style) ? style(item, index, items) : style;
          var lineId = _this.getElementId("line-" + id);
          var gridPath = _this.getGridPath(item.points);
          _this.addShape(group2, {
            type: "path",
            name: "grid-line",
            id: lineId,
            attrs: mix({
              path: gridPath
            }, style)
          });
        }
        if (alternateColor && index > 0) {
          var regionId = _this.getElementId("region-" + id);
          var isEven = index % 2 === 0;
          if (is_string_default(alternateColor)) {
            if (isEven) {
              _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
            }
          } else {
            var color2 = isEven ? alternateColor[1] : alternateColor[0];
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color2);
          }
        }
        preItem = item;
      });
    };
    GridBase2.prototype.drawAlternateRegion = function(id, group2, prePoints, points, color2) {
      var regionPath = this.getAlternatePath(prePoints, points);
      this.addShape(group2, {
        type: "path",
        id,
        name: "grid-region",
        attrs: {
          path: regionPath,
          fill: color2
        }
      });
    };
    return GridBase2;
  }(group_component_default);
  var base_default11 = GridBase;

  // node_modules/@antv/component/esm/grid/circle.js
  function distance5(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }
  var Circle2 = function(_super) {
    __extends7(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        type: "circle",
        center: null,
        closed: true
      });
    };
    Circle6.prototype.getGridPath = function(points, reversed) {
      var lineType = this.getLineType();
      var closed = this.get("closed");
      var path = [];
      if (points.length) {
        if (lineType === "circle") {
          var center = this.get("center");
          var firstPoint = points[0];
          var radius_1 = distance5(center.x, center.y, firstPoint.x, firstPoint.y);
          var sweepFlag_1 = reversed ? 0 : 1;
          if (closed) {
            path.push(["M", center.x, center.y - radius_1]);
            path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);
            path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);
            path.push(["Z"]);
          } else {
            each_default(points, function(point, index) {
              if (index === 0) {
                path.push(["M", point.x, point.y]);
              } else {
                path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);
              }
            });
          }
        } else {
          each_default(points, function(point, index) {
            if (index === 0) {
              path.push(["M", point.x, point.y]);
            } else {
              path.push(["L", point.x, point.y]);
            }
          });
          if (closed) {
            path.push(["Z"]);
          }
        }
      }
      return path;
    };
    return Circle6;
  }(base_default11);
  var circle_default5 = Circle2;

  // node_modules/@antv/component/esm/grid/line.js
  var Line2 = function(_super) {
    __extends7(Line6, _super);
    function Line6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "line" });
    };
    Line6.prototype.getGridPath = function(points) {
      var path = [];
      each_default(points, function(point, index) {
        if (index === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
      return path;
    };
    return Line6;
  }(base_default11);
  var line_default7 = Line2;

  // node_modules/@antv/component/esm/legend/index.js
  var legend_exports = {};
  __export(legend_exports, {
    Base: () => base_default12,
    Category: () => category_default,
    Continuous: () => continuous_default
  });

  // node_modules/@antv/component/esm/legend/base.js
  var LegendBase = function(_super) {
    __extends7(LegendBase2, _super);
    function LegendBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LegendBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        name: "legend",
        layout: "horizontal",
        locationType: "point",
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0,
        title: null,
        background: null
      });
    };
    LegendBase2.prototype.getLayoutBBox = function() {
      var bbox = _super.prototype.getLayoutBBox.call(this);
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var width = bbox.width, height = bbox.height;
      if (maxWidth) {
        width = Math.min(width, maxWidth);
      }
      if (maxHeight) {
        height = Math.min(height, maxHeight);
      }
      return createBBox(bbox.minX, bbox.minY, width, height);
    };
    LegendBase2.prototype.setLocation = function(cfg) {
      this.set("x", cfg.x);
      this.set("y", cfg.y);
      this.resetLocation();
    };
    LegendBase2.prototype.resetLocation = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: x + offsetX,
        y: y + offsetY
      });
    };
    LegendBase2.prototype.applyOffset = function() {
      this.resetLocation();
    };
    LegendBase2.prototype.getDrawPoint = function() {
      return this.get("currentPoint");
    };
    LegendBase2.prototype.setDrawPoint = function(point) {
      return this.set("currentPoint", point);
    };
    LegendBase2.prototype.renderInner = function(group2) {
      this.resetDraw();
      if (this.get("title")) {
        this.drawTitle(group2);
      }
      this.drawLegendContent(group2);
      if (this.get("background")) {
        this.drawBackground(group2);
      }
    };
    LegendBase2.prototype.drawBackground = function(group2) {
      var background = this.get("background");
      var bbox = group2.getBBox();
      var padding = formatPadding(background.padding);
      var attrs = __assign7({
        x: 0,
        y: 0,
        width: bbox.width + padding[1] + padding[3],
        height: bbox.height + padding[0] + padding[2]
      }, background.style);
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        name: "legend-background",
        attrs
      });
      backgroundShape.toBack();
    };
    LegendBase2.prototype.drawTitle = function(group2) {
      var currentPoint = this.get("currentPoint");
      var titleCfg = this.get("title");
      var spacing = titleCfg.spacing, style = titleCfg.style, text = titleCfg.text;
      var shape = this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "legend-title",
        attrs: __assign7({ text, x: currentPoint.x, y: currentPoint.y }, style)
      });
      var bbox = shape.getBBox();
      this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
    };
    LegendBase2.prototype.resetDraw = function() {
      var background = this.get("background");
      var currentPoint = { x: 0, y: 0 };
      if (background) {
        var padding = formatPadding(background.padding);
        currentPoint.x = padding[3];
        currentPoint.y = padding[0];
      }
      this.set("currentPoint", currentPoint);
    };
    return LegendBase2;
  }(group_component_default);
  var base_default12 = LegendBase;

  // node_modules/@antv/component/esm/legend/category.js
  var DEFAULT_PAGE_NAVIGATOR = {
    marker: {
      style: {
        inactiveFill: "#000",
        inactiveOpacity: 0.45,
        fill: "#000",
        opacity: 1,
        size: 12
      }
    },
    text: {
      style: {
        fill: "#ccc",
        fontSize: 12
      }
    }
  };
  var textStyle = {
    fill: theme_default.textColor,
    fontSize: 12,
    textAlign: "start",
    textBaseline: "middle",
    fontFamily: theme_default.fontFamily,
    fontWeight: "normal",
    lineHeight: 12
  };
  var Category2 = function(_super) {
    __extends7(Category3, _super);
    function Category3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.currentPageIndex = 1;
      _this.totalPagesCnt = 1;
      _this.pageWidth = 0;
      _this.pageHeight = 0;
      _this.startX = 0;
      _this.startY = 0;
      _this.onNavigationBack = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex > 1) {
          _this.currentPageIndex -= 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      _this.onNavigationAfter = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex < _this.totalPagesCnt) {
          _this.currentPageIndex += 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      return _this;
    }
    Category3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
        title: {
          spacing: 5,
          style: {
            fill: theme_default.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        },
        background: {
          padding: 5,
          style: {
            stroke: theme_default.lineColor
          }
        },
        itemBackground: {
          style: {
            opacity: 0,
            fill: "#fff"
          }
        },
        pageNavigator: DEFAULT_PAGE_NAVIGATOR,
        itemName: {
          spacing: 16,
          style: textStyle
        },
        marker: {
          spacing: 8,
          style: {
            r: 6,
            symbol: "circle"
          }
        },
        itemValue: {
          alignRight: false,
          formatter: null,
          style: textStyle
        },
        itemStates: {
          active: {
            nameStyle: {
              opacity: 0.8
            }
          },
          unchecked: {
            nameStyle: {
              fill: theme_default.uncheckedColor
            },
            markerStyle: {
              fill: theme_default.uncheckedColor,
              stroke: theme_default.uncheckedColor
            }
          },
          inactive: {
            nameStyle: {
              fill: theme_default.uncheckedColor
            },
            markerStyle: {
              opacity: 0.2
            }
          }
        }
      } });
    };
    Category3.prototype.isList = function() {
      return true;
    };
    Category3.prototype.getItems = function() {
      return this.get("items");
    };
    Category3.prototype.setItems = function(items) {
      this.update({
        items
      });
    };
    Category3.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    Category3.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("item-group");
      itemGroup && itemGroup.clear();
    };
    Category3.prototype.setItemState = function(item, state, value) {
      item[state] = value;
      var itemElement = this.getElementByLocalId("item-" + item.id);
      if (itemElement) {
        var items = this.getItems();
        var index = items.indexOf(item);
        var offsetGroup = this.createOffScreenGroup();
        var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
        this.updateElements(newElement, itemElement);
        this.clearUpdateStatus(itemElement);
      }
    };
    Category3.prototype.hasState = function(item, state) {
      return !!item[state];
    };
    Category3.prototype.getItemStates = function(item) {
      var itemStates = this.get("itemStates");
      var rst = [];
      each_default(itemStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    Category3.prototype.clearItemsState = function(state) {
      var _this = this;
      var items = this.getItemsByState(state);
      each_default(items, function(item) {
        _this.setItemState(item, state, false);
      });
    };
    Category3.prototype.getItemsByState = function(state) {
      var _this = this;
      var items = this.getItems();
      return filter_default(items, function(item) {
        return _this.hasState(item, state);
      });
    };
    Category3.prototype.drawLegendContent = function(group2) {
      this.processItems();
      this.drawItems(group2);
    };
    Category3.prototype.processItems = function() {
      var items = this.get("items");
      each_default(items, function(item) {
        if (!item.id) {
          item.id = item.name;
        }
      });
    };
    Category3.prototype.drawItems = function(group2) {
      var _this = this;
      var itemContainerGroup = this.addGroup(group2, {
        id: this.getElementId("item-container-group"),
        name: "legend-item-container-group"
      });
      var itemGroup = this.addGroup(itemContainerGroup, {
        id: this.getElementId("item-group"),
        name: "legend-item-group"
      });
      var itemHeight = this.getItemHeight();
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemMarginBottom = this.get("itemMarginBottom");
      var currentPoint = this.get("currentPoint");
      var startX = currentPoint.x;
      var startY = currentPoint.y;
      var layout = this.get("layout");
      var items = this.get("items");
      var wrapped = false;
      var pageWidth = 0;
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      each_default(items, function(item, index) {
        var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);
        var bbox = subGroup.getBBox();
        var width = itemWidth || bbox.width;
        if (width > pageWidth) {
          pageWidth = width;
        }
        if (layout === "horizontal") {
          if (maxWidth && maxWidth < currentPoint.x + width - startX) {
            wrapped = true;
            currentPoint.x = startX;
            currentPoint.y += itemHeight + itemMarginBottom;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.x += width + itemSpacing;
        } else {
          if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
            wrapped = true;
            currentPoint.x += pageWidth + itemSpacing;
            currentPoint.y = startY;
            pageWidth = 0;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.y += itemHeight + itemMarginBottom;
        }
      });
      if (wrapped && this.get("flipPage")) {
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.totalPagesCnt = 1;
        this.startX = startX;
        this.startY = startY;
        this.adjustNavigation(group2, itemGroup);
      }
    };
    Category3.prototype.getItemHeight = function() {
      var itemHeight = this.get("itemHeight");
      if (!itemHeight) {
        var style_1 = (this.get("itemName") || {}).style;
        if (is_function_default(style_1)) {
          var items_1 = this.getItems();
          items_1.forEach(function(item, index) {
            var fontSize = __assign7(__assign7({}, textStyle), style_1(item, index, items_1)).fontSize;
            if (itemHeight < fontSize) {
              itemHeight = fontSize;
            }
          });
        } else if (style_1) {
          itemHeight = style_1.fontSize;
        }
      }
      return itemHeight;
    };
    Category3.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
      var markerAttrs = __assign7(__assign7(__assign7({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get_default(item.marker, "symbol", "circle") }), get_default(item.marker, "style", {}));
      var shape = this.addShape(container, {
        type: "marker",
        id: this.getElementId("item-" + item.id + "-marker"),
        name: "legend-item-marker",
        attrs: markerAttrs
      });
      var bbox = shape.getBBox();
      shape.attr("x", bbox.width / 2);
      var _a4 = shape.attr(), stroke = _a4.stroke, fill = _a4.fill;
      if (stroke) {
        shape.set("isStroke", true);
      }
      if (fill) {
        shape.set("isFill", true);
      }
      return shape;
    };
    Category3.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index) {
      var formatter = cfg.formatter;
      var style = cfg.style;
      var attrs = __assign7(__assign7({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index) : item[textName] }, textStyle), is_function_default(style) ? style(item, index, this.getItems()) : style);
      return this.addShape(container, {
        type: "text",
        id: this.getElementId("item-" + item.id + "-" + textName),
        name: "legend-item-" + textName,
        attrs
      });
    };
    Category3.prototype.drawItem = function(item, index, itemHeight, itemGroup) {
      var groupId = "item-" + item.id;
      var subContainer = this.addGroup(itemGroup, {
        name: "legend-item-container",
        id: this.getElementId("item-container-" + groupId),
        delegateObject: {
          item,
          index
        }
      });
      var subGroup = this.addGroup(subContainer, {
        name: "legend-item",
        id: this.getElementId(groupId),
        delegateObject: {
          item,
          index
        }
      });
      var marker = this.get("marker");
      var itemName = this.get("itemName");
      var itemValue = this.get("itemValue");
      var itemBackground = this.get("itemBackground");
      var itemWidth = this.getLimitItemWidth();
      var curX = 0;
      if (marker) {
        var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
        var spacing = marker.spacing;
        var itemMarkerSpacing = get_default(item, ["marker", "spacing"]);
        if (is_number_default(itemMarkerSpacing)) {
          spacing = itemMarkerSpacing;
        }
        curX = markerShape.getBBox().maxX + spacing;
      }
      if (itemName) {
        var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index);
        if (itemWidth) {
          ellipsisLabel(true, nameShape, clamp_default(itemWidth - curX, 0, itemWidth));
        }
        curX = nameShape.getBBox().maxX + itemName.spacing;
      }
      if (itemValue) {
        var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index);
        if (itemWidth) {
          if (itemValue.alignRight) {
            valueShape.attr({
              textAlign: "right",
              x: itemWidth
            });
            ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth), "head");
          } else {
            ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth));
          }
        }
      }
      if (itemBackground) {
        var bbox = subGroup.getBBox();
        var backShape = this.addShape(subGroup, {
          type: "rect",
          name: "legend-item-background",
          id: this.getElementId(groupId + "-background"),
          attrs: __assign7({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
        });
        backShape.toBack();
      }
      this.applyItemStates(item, subGroup);
      return subGroup;
    };
    Category3.prototype.adjustNavigation = function(container, itemGroup) {
      var _this = this;
      var startX = this.startX;
      var startY = this.startY;
      var layout = this.get("layout");
      var subGroups = itemGroup.findAll(function(item) {
        return item.get("name") === "legend-item";
      });
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemHeight = this.getItemHeight();
      var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var navigation = this.drawNavigation(container, layout, "00/00", pageNavigator);
      var navigationBBox = navigation.getBBox();
      var currentPoint = { x: startX, y: startY };
      var pages = 1;
      var widthLimit = 0;
      var pageWidth = 0;
      var maxItemWidth = 0;
      var itemMarginBottom = this.get("itemMarginBottom");
      if (layout === "horizontal") {
        var maxRow = this.get("maxRow") || 1;
        var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
        this.pageHeight = maxRowHeight_1 * maxRow;
        each_default(subGroups, function(item) {
          var bbox = item.getBBox();
          var width = itemWidth || bbox.width;
          if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
            if (pages === 1) {
              widthLimit = currentPoint.x + itemSpacing;
              _this.pageWidth = widthLimit;
              _this.moveElementTo(navigation, {
                x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
                y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
              });
            }
            pages += 1;
            currentPoint.x = startX;
            currentPoint.y += maxRowHeight_1;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: width + itemSpacing,
              height: itemHeight
            }
          });
          currentPoint.x += width + itemSpacing;
        });
      } else {
        each_default(subGroups, function(item) {
          var bbox = item.getBBox();
          if (bbox.width > pageWidth) {
            pageWidth = bbox.width;
          }
        });
        maxItemWidth = pageWidth;
        pageWidth += itemSpacing;
        if (maxWidth) {
          pageWidth = Math.min(maxWidth, pageWidth);
          maxItemWidth = Math.min(maxWidth, maxItemWidth);
        }
        this.pageWidth = pageWidth;
        this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
        var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
        each_default(subGroups, function(item, index) {
          if (index !== 0 && index % cntPerPage_1 === 0) {
            pages += 1;
            currentPoint.x += pageWidth;
            currentPoint.y = startY;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: pageWidth,
              height: itemHeight
            }
          });
          currentPoint.y += itemHeight + itemMarginBottom;
        });
        this.totalPagesCnt = pages;
        this.moveElementTo(navigation, {
          x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
          y: maxHeight - navigationBBox.height - navigationBBox.minY
        });
      }
      if (this.pageHeight && this.pageWidth) {
        itemGroup.getParent().setClip({
          type: "rect",
          attrs: {
            x: this.startX,
            y: this.startY,
            width: this.pageWidth,
            height: this.pageHeight
          }
        });
      }
      if (layout === "horizontal" && this.get("maxRow")) {
        this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
      } else {
        this.totalPagesCnt = pages;
      }
      if (this.currentPageIndex > this.totalPagesCnt) {
        this.currentPageIndex = 1;
      }
      this.updateNavigation(navigation);
      itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
    };
    Category3.prototype.drawNavigation = function(group2, layout, text, styleCfg) {
      var currentPoint = { x: 0, y: 0 };
      var subGroup = this.addGroup(group2, {
        id: this.getElementId("navigation-group"),
        name: "legend-navigation"
      });
      var _a4 = get_default(styleCfg.marker, "style", {}), _b = _a4.size, size3 = _b === void 0 ? 12 : _b, arrowStyle = __rest7(_a4, ["size"]);
      var leftArrow = this.drawArrow(subGroup, currentPoint, "navigation-arrow-left", layout === "horizontal" ? "up" : "left", size3, arrowStyle);
      leftArrow.on("click", this.onNavigationBack);
      var leftArrowBBox = leftArrow.getBBox();
      currentPoint.x += leftArrowBBox.width + 2;
      var textShape = this.addShape(subGroup, {
        type: "text",
        id: this.getElementId("navigation-text"),
        name: "navigation-text",
        attrs: __assign7({ x: currentPoint.x, y: currentPoint.y + size3 / 2, text, textBaseline: "middle" }, get_default(styleCfg.text, "style"))
      });
      var textBBox = textShape.getBBox();
      currentPoint.x += textBBox.width + 2;
      var rightArrow = this.drawArrow(subGroup, currentPoint, "navigation-arrow-right", layout === "horizontal" ? "down" : "right", size3, arrowStyle);
      rightArrow.on("click", this.onNavigationAfter);
      return subGroup;
    };
    Category3.prototype.updateNavigation = function(navigation) {
      var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var _a4 = pageNavigator.marker.style, fill = _a4.fill, opacity = _a4.opacity, inactiveFill = _a4.inactiveFill, inactiveOpacity = _a4.inactiveOpacity;
      var text = this.currentPageIndex + "/" + this.totalPagesCnt;
      var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
      var leftArrow = navigation ? navigation.findById(this.getElementId("navigation-arrow-left")) : this.getElementByLocalId("navigation-arrow-left");
      var rightArrow = navigation ? navigation.findById(this.getElementId("navigation-arrow-right")) : this.getElementByLocalId("navigation-arrow-right");
      var origBBox = textShape.getBBox();
      textShape.attr("text", text);
      var newBBox = textShape.getBBox();
      textShape.attr("x", textShape.attr("x") - (newBBox.width - origBBox.width) / 2);
      leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
      leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill);
      leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
      rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
      rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
      rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
    };
    Category3.prototype.drawArrow = function(group2, currentPoint, name, direction2, size3, style) {
      var x = currentPoint.x, y = currentPoint.y;
      var rotateMap = {
        right: 90 * Math.PI / 180,
        left: (360 - 90) * Math.PI / 180,
        up: 0,
        down: 180 * Math.PI / 180
      };
      var shape = this.addShape(group2, {
        type: "path",
        id: this.getElementId(name),
        name,
        attrs: __assign7({ path: [["M", x + size3 / 2, y], ["L", x, y + size3], ["L", x + size3, y + size3], ["Z"]], cursor: "pointer" }, style)
      });
      shape.attr("matrix", getMatrixByAngle({ x: x + size3 / 2, y: y + size3 / 2 }, rotateMap[direction2]));
      return shape;
    };
    Category3.prototype.getCurrentNavigationMatrix = function() {
      var _a4 = this, currentPageIndex = _a4.currentPageIndex, pageWidth = _a4.pageWidth, pageHeight = _a4.pageHeight;
      var layout = this.get("layout");
      var translate3 = layout === "horizontal" ? {
        x: 0,
        y: pageHeight * (1 - currentPageIndex)
      } : {
        x: pageWidth * (1 - currentPageIndex),
        y: 0
      };
      return getMatrixByTranslate(translate3);
    };
    Category3.prototype.applyItemStates = function(item, subGroup) {
      var states = this.getItemStates(item);
      var hasStates = states.length > 0;
      if (hasStates) {
        var children = subGroup.getChildren();
        var itemStates_1 = this.get("itemStates");
        each_default(children, function(element) {
          var name = element.get("name");
          var elName = name.split("-")[2];
          var statesStyle = getStatesStyle(item, elName, itemStates_1);
          if (statesStyle) {
            element.attr(statesStyle);
            if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
              if (element.get("isStroke")) {
                element.attr("fill", null);
              }
              if (element.get("isFill")) {
                element.attr("stroke", null);
              }
            }
          }
        });
      }
    };
    Category3.prototype.getLimitItemWidth = function() {
      var itemWidth = this.get("itemWidth");
      var maxItemWidth = this.get("maxItemWidth");
      if (maxItemWidth) {
        if (itemWidth) {
          maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
        }
      } else if (itemWidth) {
        maxItemWidth = itemWidth;
      }
      return maxItemWidth;
    };
    return Category3;
  }(base_default12);
  var category_default = Category2;

  // node_modules/@antv/component/esm/legend/continuous.js
  var HANDLER_HEIGHT_RATIO = 1.4;
  var HANDLER_TRIANGLE_RATIO = 0.4;
  var ContinueLegend = function(_super) {
    __extends7(ContinueLegend2, _super);
    function ContinueLegend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ContinueLegend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
        label: {
          align: "rail",
          spacing: 5,
          formatter: null,
          style: {
            fontSize: 12,
            fill: theme_default.textColor,
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily
          }
        },
        handler: {
          size: 10,
          style: {
            fill: "#fff",
            stroke: "#333"
          }
        },
        track: {},
        rail: {
          type: "color",
          size: 20,
          defaultLength: 100,
          style: {
            fill: "#DCDEE2"
          }
        },
        title: {
          spacing: 5,
          style: {
            fill: theme_default.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        }
      } });
    };
    ContinueLegend2.prototype.isSlider = function() {
      return true;
    };
    ContinueLegend2.prototype.getValue = function() {
      return this.getCurrentValue();
    };
    ContinueLegend2.prototype.getRange = function() {
      return {
        min: this.get("min"),
        max: this.get("max")
      };
    };
    ContinueLegend2.prototype.setRange = function(min3, max3) {
      this.update({
        min: min3,
        max: max3
      });
    };
    ContinueLegend2.prototype.setValue = function(value) {
      var originValue = this.getValue();
      this.set("value", value);
      var group2 = this.get("group");
      this.resetTrackClip();
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value
      });
    };
    ContinueLegend2.prototype.initEvent = function() {
      var group2 = this.get("group");
      this.bindSliderEvent(group2);
      this.bindRailEvent(group2);
      this.bindTrackEvent(group2);
    };
    ContinueLegend2.prototype.drawLegendContent = function(group2) {
      this.drawRail(group2);
      this.drawLabels(group2);
      this.fixedElements(group2);
      this.resetTrack(group2);
      this.resetTrackClip(group2);
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
    };
    ContinueLegend2.prototype.bindSliderEvent = function(group2) {
      this.bindHandlersEvent(group2);
    };
    ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
      var _this = this;
      group2.on("legend-handler-min:drag", function(ev) {
        var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var maxValue = currentValue[1];
        if (maxValue < minValue) {
          maxValue = minValue;
        }
        _this.setValue([minValue, maxValue]);
      });
      group2.on("legend-handler-max:drag", function(ev) {
        var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var minValue = currentValue[0];
        if (minValue > maxValue) {
          minValue = maxValue;
        }
        _this.setValue([minValue, maxValue]);
      });
    };
    ContinueLegend2.prototype.bindRailEvent = function(group2) {
    };
    ContinueLegend2.prototype.bindTrackEvent = function(group2) {
      var _this = this;
      var prePoint = null;
      group2.on("legend-track:dragstart", function(ev) {
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:drag", function(ev) {
        if (!prePoint) {
          return;
        }
        var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
        var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var curDiff = currentValue[1] - currentValue[0];
        var range = _this.getRange();
        var dValue = curValue - preValue;
        if (dValue < 0) {
          if (currentValue[0] + dValue > range.min) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range.min, range.min + curDiff]);
          }
        } else if (dValue > 0) {
          if (dValue > 0 && currentValue[1] + dValue < range.max) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range.max - curDiff, range.max]);
          }
        }
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:dragend", function(ev) {
        prePoint = null;
      });
    };
    ContinueLegend2.prototype.drawLabels = function(group2) {
      this.drawLabel("min", group2);
      this.drawLabel("max", group2);
    };
    ContinueLegend2.prototype.drawLabel = function(name, group2) {
      var labelCfg = this.get("label");
      var style = labelCfg.style;
      var labelAlign = labelCfg.align;
      var labelFormatter = labelCfg.formatter;
      var value = this.get(name);
      var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
      var localId = "label-" + name;
      this.addShape(group2, {
        type: "text",
        id: this.getElementId(localId),
        name: "legend-label-" + name,
        attrs: __assign7(__assign7({ x: 0, y: 0, text: is_function_default(labelFormatter) ? labelFormatter(value) : value }, style), alignAttrs)
      });
    };
    ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
      var isVertical2 = this.isVertical();
      var textAlign = "center";
      var textBaseline = "middle";
      if (isVertical2) {
        textAlign = "start";
        if (align !== "rail") {
          if (name === "min") {
            textBaseline = "top";
          } else {
            textBaseline = "bottom";
          }
        } else {
          textBaseline = "top";
        }
      } else {
        if (align !== "rail") {
          textBaseline = "top";
          if (name === "min") {
            textAlign = "start";
          } else {
            textAlign = "end";
          }
        } else {
          textAlign = "start";
          textBaseline = "middle";
        }
      }
      return {
        textAlign,
        textBaseline
      };
    };
    ContinueLegend2.prototype.getRailPath = function(x, y, w, h2) {
      var railCfg = this.get("rail");
      var size3 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
      var isVertical2 = this.isVertical();
      var length3 = defaultLength;
      var width = w;
      var height = h2;
      if (!width) {
        width = isVertical2 ? size3 : length3;
      }
      if (!height) {
        height = isVertical2 ? length3 : size3;
      }
      var path = [];
      if (type === "color") {
        path.push(["M", x, y]);
        path.push(["L", x + width, y]);
        path.push(["L", x + width, y + height]);
        path.push(["L", x, y + height]);
        path.push(["Z"]);
      } else {
        path.push(["M", x + width, y]);
        path.push(["L", x + width, y + height]);
        path.push(["L", x, y + height]);
        path.push(["Z"]);
      }
      return path;
    };
    ContinueLegend2.prototype.drawRail = function(group2) {
      var railCfg = this.get("rail");
      var style = railCfg.style;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("rail"),
        name: "legend-rail",
        attrs: __assign7({ path: this.getRailPath(0, 0) }, style)
      });
    };
    ContinueLegend2.prototype.getTrackColor = function(colors) {
      var count = colors.length;
      if (!count) {
        return null;
      }
      if (count === 1) {
        return colors[0];
      }
      var color2;
      if (this.isVertical()) {
        color2 = "l(90)";
      } else {
        color2 = "l(0)";
      }
      for (var i = 0; i < count; i++) {
        var percent = i / (count - 1);
        color2 += " " + percent + ":" + colors[i];
      }
      return color2;
    };
    ContinueLegend2.prototype.getTrackPath = function(group2) {
      var railShape = this.getRailShape(group2);
      var path = railShape.attr("path");
      return clone_default(path);
    };
    ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
      var value = this.getCurrentValue();
      var min3 = value[0], max3 = value[1];
      var railBBox = this.getRailBBox(group2);
      var startPoint = this.getPointByValue(min3, group2);
      var endPoint = this.getPointByValue(max3, group2);
      var isVertical2 = this.isVertical();
      var x;
      var y;
      var width;
      var height;
      if (isVertical2) {
        x = railBBox.minX;
        y = startPoint.y;
        width = railBBox.width;
        height = endPoint.y - startPoint.y;
      } else {
        x = startPoint.x;
        y = railBBox.minY;
        width = endPoint.x - startPoint.x;
        height = railBBox.height;
      }
      return {
        x,
        y,
        width,
        height
      };
    };
    ContinueLegend2.prototype.getTrackAttrs = function(group2) {
      var trackCfg = this.get("track");
      var colors = this.get("colors");
      var path = this.getTrackPath(group2);
      return mix({
        path,
        fill: this.getTrackColor(colors)
      }, trackCfg.style);
    };
    ContinueLegend2.prototype.resetTrackClip = function(group2) {
      var container = group2 || this.get("group");
      var trackId = this.getElementId("track");
      var trackShape = container.findById(trackId);
      var clipShape = trackShape.getClip();
      var attrs = this.getClipTrackAttrs(group2);
      if (!clipShape) {
        trackShape.setClip({
          type: "rect",
          attrs
        });
      } else {
        clipShape.attr(attrs);
      }
    };
    ContinueLegend2.prototype.resetTrack = function(group2) {
      var trackId = this.getElementId("track");
      var trackShape = group2.findById(trackId);
      var trackAttrs = this.getTrackAttrs(group2);
      if (trackShape) {
        trackShape.attr(trackAttrs);
      } else {
        this.addShape(group2, {
          type: "path",
          id: trackId,
          draggable: this.get("slidable"),
          name: "legend-track",
          attrs: trackAttrs
        });
      }
    };
    ContinueLegend2.prototype.getPointByValue = function(value, group2) {
      var _a4 = this.getRange(), min3 = _a4.min, max3 = _a4.max;
      var percent = (value - min3) / (max3 - min3);
      var bbox = this.getRailBBox(group2);
      var isVertcal = this.isVertical();
      var point = { x: 0, y: 0 };
      if (isVertcal) {
        point.x = bbox.minX + bbox.width / 2;
        point.y = getValueByPercent(bbox.minY, bbox.maxY, percent);
      } else {
        point.x = getValueByPercent(bbox.minX, bbox.maxX, percent);
        point.y = bbox.minY + bbox.height / 2;
      }
      return point;
    };
    ContinueLegend2.prototype.getRailShape = function(group2) {
      var container = group2 || this.get("group");
      return container.findById(this.getElementId("rail"));
    };
    ContinueLegend2.prototype.getRailBBox = function(group2) {
      var railShape = this.getRailShape(group2);
      var bbox = railShape.getBBox();
      return bbox;
    };
    ContinueLegend2.prototype.getRailCanvasBBox = function() {
      var container = this.get("group");
      var railShape = container.findById(this.getElementId("rail"));
      var bbox = railShape.getCanvasBBox();
      return bbox;
    };
    ContinueLegend2.prototype.isVertical = function() {
      return this.get("layout") === "vertical";
    };
    ContinueLegend2.prototype.getValueByCanvasPoint = function(x, y) {
      var _a4 = this.getRange(), min3 = _a4.min, max3 = _a4.max;
      var bbox = this.getRailCanvasBBox();
      var isVertcal = this.isVertical();
      var step = this.get("step");
      var percent;
      if (isVertcal) {
        percent = (y - bbox.minY) / bbox.height;
      } else {
        percent = (x - bbox.minX) / bbox.width;
      }
      var value = getValueByPercent(min3, max3, percent);
      if (step) {
        var count = Math.round((value - min3) / step);
        value = min3 + count * step;
      }
      if (value > max3) {
        value = max3;
      }
      if (value < min3) {
        value = min3;
      }
      return value;
    };
    ContinueLegend2.prototype.getCurrentValue = function() {
      var value = this.get("value");
      if (!value) {
        var values2 = this.get("values");
        if (!values2) {
          return [this.get("min"), this.get("max")];
        }
        return [Math.max(Math.min.apply(Math, __spreadArrays7(values2, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays7(values2, [this.get("min")])), this.get("max"))];
      }
      return value;
    };
    ContinueLegend2.prototype.resetHandlers = function(group2) {
      var currentValue = this.getCurrentValue();
      var min3 = currentValue[0], max3 = currentValue[1];
      this.resetHandler(group2, "min", min3);
      this.resetHandler(group2, "max", max3);
    };
    ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point) {
      var isVertical2 = this.isVertical();
      var path = [];
      var width = handlerCfg.size;
      var x = point.x, y = point.y;
      var height = width * HANDLER_HEIGHT_RATIO;
      var halfWidth = width / 2;
      var oneSixthWidth = width / 6;
      if (isVertical2) {
        var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
        path.push(["M", x, y]);
        path.push(["L", triangleX, y + halfWidth]);
        path.push(["L", x + height, y + halfWidth]);
        path.push(["L", x + height, y - halfWidth]);
        path.push(["L", triangleX, y - halfWidth]);
        path.push(["Z"]);
        path.push(["M", triangleX, y + oneSixthWidth]);
        path.push(["L", x + height - 2, y + oneSixthWidth]);
        path.push(["M", triangleX, y - oneSixthWidth]);
        path.push(["L", x + height - 2, y - oneSixthWidth]);
      } else {
        var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
        path.push(["M", x, y]);
        path.push(["L", x - halfWidth, triangleY]);
        path.push(["L", x - halfWidth, y + height]);
        path.push(["L", x + halfWidth, y + height]);
        path.push(["L", x + halfWidth, triangleY]);
        path.push(["Z"]);
        path.push(["M", x - oneSixthWidth, triangleY]);
        path.push(["L", x - oneSixthWidth, y + height - 2]);
        path.push(["M", x + oneSixthWidth, triangleY]);
        path.push(["L", x + oneSixthWidth, y + height - 2]);
      }
      return path;
    };
    ContinueLegend2.prototype.resetHandler = function(group2, name, value) {
      var point = this.getPointByValue(value, group2);
      var handlerCfg = this.get("handler");
      var path = this.getHandlerPath(handlerCfg, point);
      var id = this.getElementId("handler-" + name);
      var handlerShape = group2.findById(id);
      var isVertical2 = this.isVertical();
      if (handlerShape) {
        handlerShape.attr("path", path);
      } else {
        this.addShape(group2, {
          type: "path",
          name: "legend-handler-" + name,
          draggable: true,
          id,
          attrs: __assign7(__assign7({ path }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
        });
      }
    };
    ContinueLegend2.prototype.fixedElements = function(group2) {
      var railShape = group2.findById(this.getElementId("rail"));
      var minLabel = group2.findById(this.getElementId("label-min"));
      var maxLabel = group2.findById(this.getElementId("label-max"));
      var startPoint = this.getDrawPoint();
      if (this.isVertical()) {
        this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
      } else {
        this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
      }
    };
    ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
      var isVertical2 = this.isVertical();
      var lengthField = isVertical2 ? "height" : "width";
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var maxLength = this.get("max" + upper_first_default(lengthField));
      if (maxLength) {
        var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
        var diff2 = elementsLength - maxLength;
        if (diff2 > 0) {
          this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
        }
      }
    };
    ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length3) {
      var bbox = railShape.getBBox();
      var path;
      if (lengthField === "height") {
        path = this.getRailPath(bbox.x, bbox.y, bbox.width, length3);
      } else {
        path = this.getRailPath(bbox.x, bbox.y, length3, bbox.height);
      }
      railShape.attr("path", path);
    };
    ContinueLegend2.prototype.changeRailPosition = function(railShape, x, y) {
      var bbox = railShape.getBBox();
      var path = this.getRailPath(x, y, bbox.width, bbox.height);
      railShape.attr("path", path);
    };
    ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      var railHeight = railBBox.height;
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railHeight / 2
        });
        this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
          y: startPoint.y + railHeight / 2
        });
      } else if (labelAlign === "top") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      } else {
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height + spacing
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y + railBBox.height + spacing
        });
      }
    };
    ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
        });
      } else if (labelAlign === "right") {
        minLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y + railBBox.height
        });
      } else {
        var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height
        });
      }
    };
    return ContinueLegend2;
  }(base_default12);
  var continuous_default = ContinueLegend;

  // node_modules/@antv/component/esm/tooltip/index.js
  var tooltip_exports = {};
  __export(tooltip_exports, {
    Html: () => html_default3
  });

  // node_modules/@antv/component/esm/tooltip/css-const.js
  var css_const_exports = {};
  __export(css_const_exports, {
    CONTAINER_CLASS: () => CONTAINER_CLASS2,
    CROSSHAIR_X: () => CROSSHAIR_X,
    CROSSHAIR_Y: () => CROSSHAIR_Y,
    LIST_CLASS: () => LIST_CLASS,
    LIST_ITEM_CLASS: () => LIST_ITEM_CLASS,
    MARKER_CLASS: () => MARKER_CLASS,
    NAME_CLASS: () => NAME_CLASS,
    TITLE_CLASS: () => TITLE_CLASS,
    VALUE_CLASS: () => VALUE_CLASS
  });
  var CONTAINER_CLASS2 = "g2-tooltip";
  var TITLE_CLASS = "g2-tooltip-title";
  var LIST_CLASS = "g2-tooltip-list";
  var LIST_ITEM_CLASS = "g2-tooltip-list-item";
  var MARKER_CLASS = "g2-tooltip-marker";
  var VALUE_CLASS = "g2-tooltip-value";
  var NAME_CLASS = "g2-tooltip-name";
  var CROSSHAIR_X = "g2-tooltip-crosshair-x";
  var CROSSHAIR_Y = "g2-tooltip-crosshair-y";

  // node_modules/@antv/component/esm/tooltip/html-theme.js
  var _a3;
  var html_theme_default2 = (_a3 = {}, _a3["" + CONTAINER_CLASS2] = {
    position: "absolute",
    visibility: "visible",
    zIndex: 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    backgroundColor: "rgba(255, 255, 255, 0.9)",
    boxShadow: "0px 0px 10px #aeaeae",
    borderRadius: "3px",
    color: "rgb(87, 87, 87)",
    fontSize: "12px",
    fontFamily: theme_default.fontFamily,
    lineHeight: "20px",
    padding: "10px 10px 6px 10px"
  }, _a3["" + TITLE_CLASS] = {
    marginBottom: "4px"
  }, _a3["" + LIST_CLASS] = {
    margin: "0px",
    listStyleType: "none",
    padding: "0px"
  }, _a3["" + LIST_ITEM_CLASS] = {
    listStyleType: "none",
    marginBottom: "4px"
  }, _a3["" + MARKER_CLASS] = {
    width: "8px",
    height: "8px",
    borderRadius: "50%",
    display: "inline-block",
    marginRight: "8px"
  }, _a3["" + VALUE_CLASS] = {
    display: "inline-block",
    float: "right",
    marginLeft: "30px"
  }, _a3["" + CROSSHAIR_X] = {
    position: "absolute",
    width: "1px",
    backgroundColor: "rgba(0, 0, 0, 0.25)"
  }, _a3["" + CROSSHAIR_Y] = {
    position: "absolute",
    height: "1px",
    backgroundColor: "rgba(0, 0, 0, 0.25)"
  }, _a3);

  // node_modules/@antv/component/esm/util/align.js
  function getOutSides(x, y, width, height, limitBox) {
    var hits = {
      left: x < limitBox.x,
      right: x + width > limitBox.x + limitBox.width,
      top: y < limitBox.y,
      bottom: y + height > limitBox.y + limitBox.height
    };
    return hits;
  }
  function getPointByPosition(x, y, offset, width, height, position) {
    var px = x;
    var py = y;
    switch (position) {
      case "left":
        px = x - width - offset;
        py = y - height / 2;
        break;
      case "right":
        px = x + offset;
        py = y - height / 2;
        break;
      case "top":
        px = x - width / 2;
        py = y - height - offset;
        break;
      case "bottom":
        px = x - width / 2;
        py = y + offset;
        break;
      default:
        px = x + offset;
        py = y - height - offset;
        break;
    }
    return {
      x: px,
      y: py
    };
  }
  function getAlignPoint(x, y, offset, width, height, position, limitBox) {
    var point = getPointByPosition(x, y, offset, width, height, position);
    if (limitBox) {
      var outSides = getOutSides(point.x, point.y, width, height, limitBox);
      if (position === "auto") {
        if (outSides.right) {
          point.x = Math.max(0, x - width - offset);
        }
        if (outSides.top) {
          point.y = Math.max(0, y - height - offset);
        }
      } else if (position === "top" || position === "bottom") {
        if (outSides.left) {
          point.x = limitBox.x;
        }
        if (outSides.right) {
          point.x = limitBox.x + limitBox.width - width;
        }
        if (position === "top" && outSides.top) {
          point.y = y + offset;
        }
        if (position === "bottom" && outSides.bottom) {
          point.y = y - height - offset;
        }
      } else {
        if (outSides.top) {
          point.y = limitBox.y;
        }
        if (outSides.bottom) {
          point.y = limitBox.y + limitBox.height - height;
        }
        if (position === "left" && outSides.left) {
          point.x = x + offset;
        }
        if (position === "right" && outSides.right) {
          point.x = x - width - offset;
        }
      }
    }
    return point;
  }

  // node_modules/@antv/component/esm/tooltip/html.js
  function hasOneKey(obj, keys2) {
    var result = false;
    each_default(keys2, function(key) {
      if (has_key_default(obj, key)) {
        result = true;
        return false;
      }
    });
    return result;
  }
  var Tooltip = function(_super) {
    __extends7(Tooltip3, _super);
    function Tooltip3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Tooltip3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        name: "tooltip",
        type: "html",
        x: 0,
        y: 0,
        items: [],
        customContent: null,
        containerTpl: '<div class="' + CONTAINER_CLASS2 + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
        itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
        xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
        yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
        title: null,
        showTitle: true,
        region: null,
        crosshairsRegion: null,
        containerClassName: CONTAINER_CLASS2,
        crosshairs: null,
        offset: 10,
        position: "right",
        domStyles: null,
        defaultStyles: html_theme_default2
      });
    };
    Tooltip3.prototype.render = function() {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        this.resetTitle();
        this.renderItems();
      }
      this.resetPosition();
    };
    Tooltip3.prototype.clear = function() {
      this.clearCrosshairs();
      this.setTitle("");
      this.clearItemDoms();
    };
    Tooltip3.prototype.show = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", true);
      modifyCSS(container, {
        visibility: "visible"
      });
      this.setCrossHairsVisible(true);
    };
    Tooltip3.prototype.hide = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", false);
      modifyCSS(container, {
        visibility: "hidden"
      });
      this.setCrossHairsVisible(false);
    };
    Tooltip3.prototype.getLocation = function() {
      return { x: this.get("x"), y: this.get("y") };
    };
    Tooltip3.prototype.setLocation = function(point) {
      this.set("x", point.x);
      this.set("y", point.y);
      this.resetPosition();
    };
    Tooltip3.prototype.setCrossHairsVisible = function(visible) {
      var display = visible ? "" : "none";
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && modifyCSS(xCrosshairDom, {
        display
      });
      yCrosshairDom && modifyCSS(yCrosshairDom, {
        display
      });
    };
    Tooltip3.prototype.initContainer = function() {
      _super.prototype.initContainer.call(this);
      if (this.get("customContent")) {
        if (this.get("container")) {
          this.get("container").remove();
        }
        var container = this.getHtmlContentNode();
        this.get("parent").appendChild(container);
        this.set("container", container);
        this.resetStyles();
        this.applyStyles();
      }
    };
    Tooltip3.prototype.updateInner = function(cfg) {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        if (hasOneKey(cfg, ["title", "showTitle"])) {
          this.resetTitle();
        }
        if (has_key_default(cfg, "items")) {
          this.renderItems();
        }
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    Tooltip3.prototype.initDom = function() {
      this.cacheDoms();
    };
    Tooltip3.prototype.removeDom = function() {
      _super.prototype.removeDom.call(this);
      this.clearCrosshairs();
    };
    Tooltip3.prototype.resetPosition = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offset = this.get("offset");
      var _a4 = this.getOffset(), offsetX = _a4.offsetX, offsetY = _a4.offsetY;
      var position = this.get("position");
      var region = this.get("region");
      var container = this.getContainer();
      var bbox = this.getBBox();
      var width = bbox.width, height = bbox.height;
      var limitBox;
      if (region) {
        limitBox = regionToBBox(region);
      }
      var point = getAlignPoint(x, y, offset, width, height, position, limitBox);
      modifyCSS(container, {
        left: toPx(point.x + offsetX),
        top: toPx(point.y + offsetY)
      });
      this.resetCrosshairs();
    };
    Tooltip3.prototype.renderCustomContent = function() {
      var node = this.getHtmlContentNode();
      var parent = this.get("parent");
      var curContainer = this.get("container");
      if (curContainer && curContainer.parentNode === parent) {
        parent.replaceChild(node, curContainer);
      } else {
        parent.appendChild(node);
      }
      this.set("container", node);
      this.resetStyles();
      this.applyStyles();
    };
    Tooltip3.prototype.getHtmlContentNode = function() {
      var node;
      var customContent = this.get("customContent");
      if (customContent) {
        var elem = customContent(this.get("title"), this.get("items"));
        if (is_element_default(elem)) {
          node = elem;
        } else {
          node = createDom(elem);
        }
      }
      return node;
    };
    Tooltip3.prototype.cacheDoms = function() {
      var container = this.getContainer();
      var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
      var listDom = container.getElementsByClassName(LIST_CLASS)[0];
      this.set("titleDom", titleDom);
      this.set("listDom", listDom);
    };
    Tooltip3.prototype.resetTitle = function() {
      var title = this.get("title");
      var showTitle = this.get("showTitle");
      if (showTitle && title) {
        this.setTitle(title);
      } else {
        this.setTitle("");
      }
    };
    Tooltip3.prototype.setTitle = function(text) {
      var titleDom = this.get("titleDom");
      if (titleDom) {
        titleDom.innerText = text;
      }
    };
    Tooltip3.prototype.resetCrosshairs = function() {
      var crosshairsRegion = this.get("crosshairsRegion");
      var crosshairs = this.get("crosshairs");
      if (!crosshairsRegion || !crosshairs) {
        this.clearCrosshairs();
      } else {
        var crosshairBox = regionToBBox(crosshairsRegion);
        var xCrosshairDom = this.get("xCrosshairDom");
        var yCrosshairDom = this.get("yCrosshairDom");
        if (crosshairs === "x") {
          this.resetCrosshair("x", crosshairBox);
          if (yCrosshairDom) {
            yCrosshairDom.remove();
            this.set("yCrosshairDom", null);
          }
        } else if (crosshairs === "y") {
          this.resetCrosshair("y", crosshairBox);
          if (xCrosshairDom) {
            xCrosshairDom.remove();
            this.set("xCrosshairDom", null);
          }
        } else {
          this.resetCrosshair("x", crosshairBox);
          this.resetCrosshair("y", crosshairBox);
        }
        this.setCrossHairsVisible(this.get("visible"));
      }
    };
    Tooltip3.prototype.resetCrosshair = function(name, bbox) {
      var croshairDom = this.checkCrosshair(name);
      var value = this.get(name);
      if (name === "x") {
        modifyCSS(croshairDom, {
          left: toPx(value),
          top: toPx(bbox.y),
          height: toPx(bbox.height)
        });
      } else {
        modifyCSS(croshairDom, {
          top: toPx(value),
          left: toPx(bbox.x),
          width: toPx(bbox.width)
        });
      }
    };
    Tooltip3.prototype.checkCrosshair = function(name) {
      var domName = name + "CrosshairDom";
      var tplName = name + "CrosshairTpl";
      var constName = "CROSSHAIR_" + name.toUpperCase();
      var styleName = css_const_exports[constName];
      var croshairDom = this.get(domName);
      var parent = this.get("parent");
      if (!croshairDom) {
        croshairDom = createDom(this.get(tplName));
        this.applyStyle(styleName, croshairDom);
        parent.appendChild(croshairDom);
        this.set(domName, croshairDom);
      }
      return croshairDom;
    };
    Tooltip3.prototype.renderItems = function() {
      this.clearItemDoms();
      var items = this.get("items");
      var itemTpl = this.get("itemTpl");
      var listDom = this.get("listDom");
      if (listDom) {
        each_default(items, function(item) {
          var color2 = esm_default2.toCSSGradient(item.color);
          var substituteObj = __assign7(__assign7({}, item), { color: color2 });
          var domStr = substitute_default(itemTpl, substituteObj);
          var itemDom = createDom(domStr);
          listDom.appendChild(itemDom);
        });
        this.applyChildrenStyles(listDom, this.get("domStyles"));
      }
    };
    Tooltip3.prototype.clearItemDoms = function() {
      if (this.get("listDom")) {
        clearDom(this.get("listDom"));
      }
    };
    Tooltip3.prototype.clearCrosshairs = function() {
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && xCrosshairDom.remove();
      yCrosshairDom && yCrosshairDom.remove();
      this.set("xCrosshairDom", null);
      this.set("yCrosshairDom", null);
    };
    return Tooltip3;
  }(html_component_default);
  var html_default3 = Tooltip;

  // node_modules/@antv/component/esm/trend/constant.js
  var BACKGROUND_STYLE = {
    opacity: 0
  };
  var LINE_STYLE = {
    stroke: "#C5C5C5",
    strokeOpacity: 0.85
  };
  var AREA_STYLE = {
    fill: "#CACED4",
    opacity: 0.85
  };

  // node_modules/@antv/component/esm/trend/path.js
  function pointsToPath(points) {
    return map_default(points, function(p2, idx) {
      var command = idx === 0 ? "M" : "L";
      var x = p2[0], y = p2[1];
      return [command, x, y];
    });
  }
  function getLinePath(points) {
    return pointsToPath(points);
  }
  function getSmoothLinePath(points) {
    if (points.length <= 2) {
      return getLinePath(points);
    }
    var data = [];
    each_default(points, function(p2) {
      if (!is_equal_default(p2, data.slice(data.length - 2))) {
        data.push(p2[0], p2[1]);
      }
    });
    var path = catmull_rom_2_bezier_default(data, false);
    var _a4 = head(points), x = _a4[0], y = _a4[1];
    path.unshift(["M", x, y]);
    return path;
  }
  function dataToPath(data, width, height, smooth) {
    if (smooth === void 0) {
      smooth = true;
    }
    var y = new linear_default({
      values: data
    });
    var x = new base_default5({
      values: map_default(data, function(v, idx) {
        return idx;
      })
    });
    var points = map_default(data, function(v, idx) {
      return [x.scale(idx) * width, height - y.scale(v) * height];
    });
    return smooth ? getSmoothLinePath(points) : getLinePath(points);
  }
  function getAreaLineY(data, height) {
    var y = new linear_default({
      values: data
    });
    var lineY = Math.max(0, y.min);
    return height - y.scale(lineY) * height;
  }
  function linePathToAreaPath(path, width, height, data) {
    var areaPath = __spreadArrays7(path);
    var lineYPx = getAreaLineY(data, height);
    areaPath.push(["L", width, lineYPx]);
    areaPath.push(["L", 0, lineYPx]);
    areaPath.push(["Z"]);
    return areaPath;
  }

  // node_modules/@antv/component/esm/trend/trend.js
  var Trend = function(_super) {
    __extends7(Trend2, _super);
    function Trend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Trend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
    };
    Trend2.prototype.renderInner = function(group2) {
      var _a4 = this.cfg, width = _a4.width, height = _a4.height, data = _a4.data, smooth = _a4.smooth, isArea = _a4.isArea, backgroundStyle = _a4.backgroundStyle, lineStyle = _a4.lineStyle, areaStyle = _a4.areaStyle;
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign7({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var path = dataToPath(data, width, height, smooth);
      this.addShape(group2, {
        id: this.getElementId("line"),
        type: "path",
        attrs: __assign7({ path }, lineStyle)
      });
      if (isArea) {
        var areaPath = linePathToAreaPath(path, width, height, data);
        this.addShape(group2, {
          id: this.getElementId("area"),
          type: "path",
          attrs: __assign7({ path: areaPath }, areaStyle)
        });
      }
    };
    Trend2.prototype.applyOffset = function() {
      var _a4 = this.cfg, x = _a4.x, y = _a4.y;
      this.moveElementTo(this.get("group"), {
        x,
        y
      });
    };
    return Trend2;
  }(group_component_default);

  // node_modules/@antv/component/esm/slider/handler.js
  var DEFAULT_HANDLER_STYLE = {
    fill: "#F7F7F7",
    stroke: "#BFBFBF",
    radius: 2,
    opacity: 1,
    cursor: "ew-resize",
    highLightFill: "#FFF"
  };
  var Handler = function(_super) {
    __extends7(Handler2, _super);
    function Handler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Handler2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
    };
    Handler2.prototype.renderInner = function(group2) {
      var _a4 = this.cfg, width = _a4.width, height = _a4.height, style = _a4.style;
      var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        attrs: {
          x: 0,
          y: 0,
          width,
          height,
          fill,
          stroke,
          radius,
          opacity,
          cursor
        }
      });
      var x1 = 1 / 3 * width;
      var x2 = 2 / 3 * width;
      var y1 = 1 / 4 * height;
      var y2 = 3 / 4 * height;
      this.addShape(group2, {
        id: this.getElementId("line-left"),
        type: "line",
        attrs: {
          x1,
          y1,
          x2: x1,
          y2,
          stroke,
          cursor
        }
      });
      this.addShape(group2, {
        id: this.getElementId("line-right"),
        type: "line",
        attrs: {
          x1: x2,
          y1,
          x2,
          y2,
          stroke,
          cursor
        }
      });
    };
    Handler2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Handler2.prototype.initEvent = function() {
      this.bindEvents();
    };
    Handler2.prototype.bindEvents = function() {
      var _this = this;
      this.get("group").on("mouseenter", function() {
        var highLightFill = _this.get("style").highLightFill;
        _this.getElementByLocalId("background").attr("fill", highLightFill);
        _this.draw();
      });
      this.get("group").on("mouseleave", function() {
        var fill = _this.get("style").fill;
        _this.getElementByLocalId("background").attr("fill", fill);
        _this.draw();
      });
    };
    Handler2.prototype.draw = function() {
      var canvas = this.get("container").get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    return Handler2;
  }(group_component_default);

  // node_modules/@antv/component/esm/slider/constant.js
  var BACKGROUND_STYLE2 = {
    fill: "#416180",
    opacity: 0.05
  };
  var FOREGROUND_STYLE = {
    fill: "#5B8FF9",
    opacity: 0.15,
    cursor: "move"
  };
  var DEFAULT_HANDLER_WIDTH = 10;
  var HANDLER_STYLE = {
    width: DEFAULT_HANDLER_WIDTH,
    height: 24
  };
  var TEXT_STYLE = {
    textBaseline: "middle",
    fill: "#000",
    opacity: 0.45
  };
  var SLIDER_CHANGE = "sliderchange";

  // node_modules/@antv/component/esm/slider/slider.js
  var Slider = function(_super) {
    __extends7(Slider3, _super);
    function Slider3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(target) {
        return function(e) {
          _this.currentTarget = target;
          var event = e.originalEvent;
          event.stopPropagation();
          event.preventDefault();
          _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
          _this.prevY = get_default(event, "touches.0.pageY", event.pageY);
          var containerDOM = _this.getContainerDOM();
          containerDOM.addEventListener("mousemove", _this.onMouseMove);
          containerDOM.addEventListener("mouseup", _this.onMouseUp);
          containerDOM.addEventListener("mouseleave", _this.onMouseUp);
          containerDOM.addEventListener("touchmove", _this.onMouseMove);
          containerDOM.addEventListener("touchend", _this.onMouseUp);
          containerDOM.addEventListener("touchcancel", _this.onMouseUp);
        };
      };
      _this.onMouseMove = function(event) {
        var width = _this.cfg.width;
        var originValue = [_this.get("start"), _this.get("end")];
        event.stopPropagation();
        event.preventDefault();
        var x = get_default(event, "touches.0.pageX", event.pageX);
        var y = get_default(event, "touches.0.pageY", event.pageY);
        var offsetX = x - _this.prevX;
        var offsetXRange = _this.adjustOffsetRange(offsetX / width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
        _this.prevX = x;
        _this.prevY = y;
        _this.draw();
        _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
        _this.delegateEmit("valuechanged", {
          originValue,
          value: [_this.get("start"), _this.get("end")]
        });
      };
      _this.onMouseUp = function() {
        if (_this.currentTarget) {
          _this.currentTarget = void 0;
        }
        var containerDOM = _this.getContainerDOM();
        if (containerDOM) {
          containerDOM.removeEventListener("mousemove", _this.onMouseMove);
          containerDOM.removeEventListener("mouseup", _this.onMouseUp);
          containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
          containerDOM.removeEventListener("touchmove", _this.onMouseMove);
          containerDOM.removeEventListener("touchend", _this.onMouseUp);
          containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
        }
      };
      return _this;
    }
    Slider3.prototype.setRange = function(min3, max3) {
      this.set("minLimit", min3);
      this.set("maxLimit", max3);
      var oldStart = this.get("start");
      var oldEnd = this.get("end");
      var newStart = clamp_default(oldStart, min3, max3);
      var newEnd = clamp_default(oldEnd, min3, max3);
      if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
        this.setValue([newStart, newEnd]);
      }
    };
    Slider3.prototype.getRange = function() {
      return {
        min: this.get("minLimit") || 0,
        max: this.get("maxLimit") || 1
      };
    };
    Slider3.prototype.setValue = function(value) {
      var range = this.getRange();
      if (is_array_default(value) && value.length === 2) {
        var originValue = [this.get("start"), this.get("end")];
        this.update({
          start: clamp_default(value[0], range.min, range.max),
          end: clamp_default(value[1], range.min, range.max)
        });
        if (!this.get("updateAutoRender")) {
          this.render();
        }
        this.delegateEmit("valuechanged", {
          originValue,
          value
        });
      }
    };
    Slider3.prototype.getValue = function() {
      return [this.get("start"), this.get("end")];
    };
    Slider3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
        backgroundStyle: BACKGROUND_STYLE2,
        foregroundStyle: FOREGROUND_STYLE,
        handlerStyle: HANDLER_STYLE,
        textStyle: TEXT_STYLE
      } });
    };
    Slider3.prototype.update = function(cfg) {
      var start = cfg.start, end = cfg.end;
      var validCfg = __assign7({}, cfg);
      if (!is_nil_default(start)) {
        validCfg.start = clamp_default(start, 0, 1);
      }
      if (!is_nil_default(end)) {
        validCfg.end = clamp_default(end, 0, 1);
      }
      _super.prototype.update.call(this, validCfg);
      this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
      this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
      this.trend = this.getChildComponentById(this.getElementId("trend"));
    };
    Slider3.prototype.init = function() {
      this.set("start", clamp_default(this.get("start"), 0, 1));
      this.set("end", clamp_default(this.get("end"), 0, 1));
      _super.prototype.init.call(this);
    };
    Slider3.prototype.render = function() {
      _super.prototype.render.call(this);
      this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
    };
    Slider3.prototype.renderInner = function(group2) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end, width = _a4.width, height = _a4.height, _b = _a4.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a4.minText, maxText = _a4.maxText, _c = _a4.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a4.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a4.textStyle, textStyle2 = _e === void 0 ? {} : _e;
      var handlerStyle = deep_mix_default({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
      var min3 = start * width;
      var max3 = end * width;
      if (size2(get_default(trendCfg, "data"))) {
        this.trend = this.addComponent(group2, __assign7({
          component: Trend,
          id: this.getElementId("trend"),
          x: 0,
          y: 0,
          width,
          height
        }, trendCfg));
      }
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign7({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var minTextShape = this.addShape(group2, {
        id: this.getElementId("minText"),
        type: "text",
        attrs: __assign7({
          y: height / 2,
          textAlign: "right",
          text: minText,
          silent: false
        }, textStyle2)
      });
      var maxTextShape = this.addShape(group2, {
        id: this.getElementId("maxText"),
        type: "text",
        attrs: __assign7({
          y: height / 2,
          textAlign: "left",
          text: maxText,
          silent: false
        }, textStyle2)
      });
      var foregroundShape = this.addShape(group2, {
        id: this.getElementId("foreground"),
        name: "foreground",
        type: "rect",
        attrs: __assign7({
          y: 0,
          height
        }, foregroundStyle)
      });
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var handlerHeight = get_default(handlerStyle, "height", 24);
      this.minHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("minHandler"),
        name: "handler-min",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
      this.maxHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("maxHandler"),
        name: "handler-max",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
    };
    Slider3.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Slider3.prototype.initEvent = function() {
      this.bindEvents();
    };
    Slider3.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end, width = _a4.width, minText = _a4.minText, maxText = _a4.maxText, handlerStyle = _a4.handlerStyle, height = _a4.height;
      var min3 = start * width;
      var max3 = end * width;
      if (this.trend) {
        this.trend.update({
          width,
          height
        });
        if (!this.get("updateAutoRender")) {
          this.trend.render();
        }
      }
      foregroundShape.attr("x", min3);
      foregroundShape.attr("width", max3 - min3);
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      minTextShape.attr("text", minText);
      maxTextShape.attr("text", maxText);
      var _b = this._dodgeText([min3, max3], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
      if (this.minHandler) {
        this.minHandler.update({
          x: min3 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.minHandler.render();
        }
      }
      each_default(minAttrs, function(v, k) {
        return minTextShape.attr(k, v);
      });
      if (this.maxHandler) {
        this.maxHandler.update({
          x: max3 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.maxHandler.render();
        }
      }
      each_default(maxAttrs, function(v, k) {
        return maxTextShape.attr(k, v);
      });
    };
    Slider3.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
      group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
      group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
      group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
      var foreground = group2.findById(this.getElementId("foreground"));
      foreground.on("mousedown", this.onMouseDown("foreground"));
      foreground.on("touchstart", this.onMouseDown("foreground"));
    };
    Slider3.prototype.adjustOffsetRange = function(offsetRange) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end;
      switch (this.currentTarget) {
        case "minHandler": {
          var min3 = 0 - start;
          var max3 = 1 - start;
          return Math.min(max3, Math.max(min3, offsetRange));
        }
        case "maxHandler": {
          var min3 = 0 - end;
          var max3 = 1 - end;
          return Math.min(max3, Math.max(min3, offsetRange));
        }
        case "foreground": {
          var min3 = 0 - start;
          var max3 = 1 - end;
          return Math.min(max3, Math.max(min3, offsetRange));
        }
      }
    };
    Slider3.prototype.updateStartEnd = function(offsetRange) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end;
      switch (this.currentTarget) {
        case "minHandler":
          start += offsetRange;
          break;
        case "maxHandler":
          end += offsetRange;
          break;
        case "foreground":
          start += offsetRange;
          end += offsetRange;
          break;
      }
      this.set("start", start);
      this.set("end", end);
    };
    Slider3.prototype._dodgeText = function(range, minTextShape, maxTextShape) {
      var _a4, _b;
      var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
      var PADDING = 2;
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var min3 = range[0], max3 = range[1];
      var sorted = false;
      if (min3 > max3) {
        _a4 = [max3, min3], min3 = _a4[0], max3 = _a4[1];
        _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
        sorted = true;
      }
      var minBBox = minTextShape.getBBox();
      var maxBBox = maxTextShape.getBBox();
      var minAttrs = minBBox.width > min3 - PADDING ? { x: min3 + handlerWidth / 2 + PADDING, textAlign: "left" } : { x: min3 - handlerWidth / 2 - PADDING, textAlign: "right" };
      var maxAttrs = maxBBox.width > width - max3 - PADDING ? { x: max3 - handlerWidth / 2 - PADDING, textAlign: "right" } : { x: max3 + handlerWidth / 2 + PADDING, textAlign: "left" };
      return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    Slider3.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Slider3.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    return Slider3;
  }(group_component_default);

  // node_modules/@antv/component/esm/scrollbar/scrollbar.js
  var DEFAULT_STYLE = {
    trackColor: "rgba(0,0,0,0)",
    thumbColor: "rgba(0,0,0,0.15)",
    size: 8,
    lineCap: "round"
  };
  var DEFAULT_THEME = {
    default: DEFAULT_STYLE,
    hover: {
      thumbColor: "rgba(0,0,0,0.2)"
    }
  };
  var Scrollbar = function(_super) {
    __extends7(Scrollbar3, _super);
    function Scrollbar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clearEvents = noop_default;
      _this.onStartEvent = function(isMobile) {
        return function(e) {
          _this.isMobile = isMobile;
          e.originalEvent.preventDefault();
          var clientX = isMobile ? get_default(e.originalEvent, "touches.0.clientX") : e.clientX;
          var clientY = isMobile ? get_default(e.originalEvent, "touches.0.clientY") : e.clientY;
          _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
          _this.bindLaterEvent();
        };
      };
      _this.bindLaterEvent = function() {
        var containerDOM = _this.getContainerDOM();
        var events = [];
        if (_this.isMobile) {
          events = [
            addEventListener2(containerDOM, "touchmove", _this.onMouseMove),
            addEventListener2(containerDOM, "touchend", _this.onMouseUp),
            addEventListener2(containerDOM, "touchcancel", _this.onMouseUp)
          ];
        } else {
          events = [
            addEventListener2(containerDOM, "mousemove", _this.onMouseMove),
            addEventListener2(containerDOM, "mouseup", _this.onMouseUp),
            addEventListener2(containerDOM, "mouseleave", _this.onMouseUp)
          ];
        }
        _this.clearEvents = function() {
          events.forEach(function(e) {
            e.remove();
          });
        };
      };
      _this.onMouseMove = function(e) {
        var _a4 = _this.cfg, isHorizontal = _a4.isHorizontal, thumbOffset = _a4.thumbOffset;
        e.preventDefault();
        var clientX = _this.isMobile ? get_default(e, "touches.0.clientX") : e.clientX;
        var clientY = _this.isMobile ? get_default(e, "touches.0.clientY") : e.clientY;
        var endPos = isHorizontal ? clientX : clientY;
        var diff2 = endPos - _this.startPos;
        _this.startPos = endPos;
        _this.updateThumbOffset(thumbOffset + diff2);
      };
      _this.onMouseUp = function(e) {
        e.preventDefault();
        _this.clearEvents();
      };
      _this.onTrackClick = function(e) {
        var _a4 = _this.cfg, isHorizontal = _a4.isHorizontal, x = _a4.x, y = _a4.y, thumbLen = _a4.thumbLen;
        var containerDOM = _this.getContainerDOM();
        var rect = containerDOM.getBoundingClientRect();
        var clientX = e.clientX, clientY = e.clientY;
        var offset = isHorizontal ? clientX - rect.left - x - thumbLen / 2 : clientY - rect.top - y - thumbLen / 2;
        var newOffset = _this.validateRange(offset);
        _this.updateThumbOffset(newOffset);
      };
      _this.onThumbMouseOver = function() {
        var thumbColor = _this.cfg.theme.hover.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      _this.onThumbMouseOut = function() {
        var thumbColor = _this.cfg.theme.default.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      return _this;
    }
    Scrollbar3.prototype.setRange = function(min3, max3) {
      this.set("minLimit", min3);
      this.set("maxLimit", max3);
      var curValue = this.getValue();
      var newValue = clamp_default(curValue, min3, max3);
      if (curValue !== newValue && !this.get("isInit")) {
        this.setValue(newValue);
      }
    };
    Scrollbar3.prototype.getRange = function() {
      var min3 = this.get("minLimit") || 0;
      var max3 = this.get("maxLimit") || 1;
      return { min: min3, max: max3 };
    };
    Scrollbar3.prototype.setValue = function(value) {
      var range = this.getRange();
      var originalValue = this.getValue();
      this.update({
        thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp_default(value, range.min, range.max)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: this.getValue()
      });
    };
    Scrollbar3.prototype.getValue = function() {
      return clamp_default(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
    };
    Scrollbar3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
    };
    Scrollbar3.prototype.renderInner = function(group2) {
      this.renderTrackShape(group2);
      this.renderThumbShape(group2);
    };
    Scrollbar3.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Scrollbar3.prototype.initEvent = function() {
      this.bindEvents();
    };
    Scrollbar3.prototype.renderTrackShape = function(group2) {
      var _a4 = this.cfg, trackLen = _a4.trackLen, _b = _a4.theme, theme = _b === void 0 ? { default: {} } : _b;
      var _c = deep_mix_default({}, DEFAULT_THEME, theme).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
      var size3 = get_default(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: 0 + size3 / 2,
        y1: size3 / 2,
        x2: trackLen - size3 / 2,
        y2: size3 / 2,
        lineWidth: size3,
        stroke: trackColor,
        lineCap
      } : {
        x1: size3 / 2,
        y1: 0 + size3 / 2,
        x2: size3 / 2,
        y2: trackLen - size3 / 2,
        lineWidth: size3,
        stroke: trackColor,
        lineCap
      };
      return this.addShape(group2, {
        id: this.getElementId("track"),
        name: "track",
        type: "line",
        attrs
      });
    };
    Scrollbar3.prototype.renderThumbShape = function(group2) {
      var _a4 = this.cfg, thumbOffset = _a4.thumbOffset, thumbLen = _a4.thumbLen, theme = _a4.theme;
      var _b = deep_mix_default({}, DEFAULT_THEME, theme).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
      var size3 = get_default(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: thumbOffset + size3 / 2,
        y1: size3 / 2,
        x2: thumbOffset + thumbLen - size3 / 2,
        y2: size3 / 2,
        lineWidth: size3,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      } : {
        x1: size3 / 2,
        y1: thumbOffset + size3 / 2,
        x2: size3 / 2,
        y2: thumbOffset + thumbLen - size3 / 2,
        lineWidth: size3,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      };
      return this.addShape(group2, {
        id: this.getElementId("thumb"),
        name: "thumb",
        type: "line",
        attrs
      });
    };
    Scrollbar3.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("mousedown", this.onStartEvent(false));
      group2.on("mouseup", this.onMouseUp);
      group2.on("touchstart", this.onStartEvent(true));
      group2.on("touchend", this.onMouseUp);
      var trackShape = group2.findById(this.getElementId("track"));
      trackShape.on("click", this.onTrackClick);
      var thumbShape = group2.findById(this.getElementId("thumb"));
      thumbShape.on("mouseover", this.onThumbMouseOver);
      thumbShape.on("mouseout", this.onThumbMouseOut);
    };
    Scrollbar3.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    Scrollbar3.prototype.validateRange = function(offset) {
      var _a4 = this.cfg, thumbLen = _a4.thumbLen, trackLen = _a4.trackLen;
      var newOffset = offset;
      if (offset + thumbLen > trackLen) {
        newOffset = trackLen - thumbLen;
      } else if (offset + thumbLen < thumbLen) {
        newOffset = 0;
      }
      return newOffset;
    };
    Scrollbar3.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Scrollbar3.prototype.updateThumbOffset = function(offset) {
      var _a4 = this.cfg, thumbOffset = _a4.thumbOffset, isHorizontal = _a4.isHorizontal, thumbLen = _a4.thumbLen, size3 = _a4.size;
      var newOffset = this.validateRange(offset);
      if (newOffset === thumbOffset) {
        return;
      }
      var thumbShape = this.getElementByLocalId("thumb");
      if (isHorizontal) {
        thumbShape.attr({
          x1: newOffset + size3 / 2,
          x2: newOffset + thumbLen - size3 / 2
        });
      } else {
        thumbShape.attr({
          y1: newOffset + size3 / 2,
          y2: newOffset + thumbLen - size3 / 2
        });
      }
      this.emitOffsetChange(newOffset);
    };
    Scrollbar3.prototype.emitOffsetChange = function(offset) {
      var _a4 = this.cfg, originalValue = _a4.thumbOffset, trackLen = _a4.trackLen, thumbLen = _a4.thumbLen;
      this.cfg.thumbOffset = offset;
      this.emit("scrollchange", {
        thumbOffset: offset,
        ratio: clamp_default(offset / (trackLen - thumbLen), 0, 1)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: offset
      });
    };
    return Scrollbar3;
  }(group_component_default);

  // node_modules/@antv/g2/esm/dependents.js
  var LineAxis = axis_exports.Line;
  var CircleAxis = axis_exports.Circle;
  var LineGrid = grid_exports.Line;
  var CircleGrid = grid_exports.Circle;
  var CategoryLegend = legend_exports.Category;
  var ContinuousLegend = legend_exports.Continuous;
  var HtmlTooltip = tooltip_exports.Html;

  // node_modules/@antv/g2/esm/util/graphics.js
  function getPointsBox(points) {
    if (is_empty_default(points)) {
      return null;
    }
    var minX = points[0].x;
    var maxX = points[0].x;
    var minY = points[0].y;
    var maxY = points[0].y;
    each_default(points, function(point) {
      minX = minX > point.x ? point.x : minX;
      maxX = maxX < point.x ? point.x : maxX;
      minY = minY > point.y ? point.y : minY;
      maxY = maxY < point.y ? point.y : maxY;
    });
    return {
      minX,
      maxX,
      minY,
      maxY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  function uniqueValues(array) {
    return Array.from(new Set(array)).length === 1;
  }
  function mid(array) {
    return (min_default(array) + max_default(array)) / 2;
  }
  function polarToCartesian(centerX, centerY, radius, angleInRadian) {
    return {
      x: centerX + radius * Math.cos(angleInRadian),
      y: centerY + radius * Math.sin(angleInRadian)
    };
  }
  function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
    if (innerRadius === void 0) {
      innerRadius = 0;
    }
    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
    var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
    var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
    if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
      var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
      var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
      var circlePathCommands = [
        ["M", start.x, start.y],
        ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
        ["A", radius, radius, 0, 1, 1, end.x, end.y],
        ["M", innerStart.x, innerStart.y]
      ];
      if (innerRadius) {
        circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
        circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
      }
      circlePathCommands.push(["M", start.x, start.y]);
      circlePathCommands.push(["Z"]);
      return circlePathCommands;
    }
    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
    var sectorPathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
      ["L", innerEnd.x, innerEnd.y]
    ];
    if (innerRadius) {
      sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
    }
    sectorPathCommands.push(["L", start.x, start.y]);
    sectorPathCommands.push(["Z"]);
    return sectorPathCommands;
  }
  function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
    if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
      var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
      return [
        ["M", start.x, start.y],
        ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
        ["A", radius, radius, 0, 1, 1, start.x, start.y],
        ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
        ["A", radius, radius, 0, 1, 0, start.x, start.y],
        ["Z"]
      ];
    }
    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
    ];
  }
  function getAngle2(shapeModel, coordinate) {
    var points = shapeModel.points;
    var box2 = getPointsBox(points);
    var endAngle;
    var startAngle;
    var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;
    var diffAngle = coordEndAngle - coordStartAngle;
    if (coordinate.isTransposed) {
      endAngle = box2.maxY * diffAngle;
      startAngle = box2.minY * diffAngle;
    } else {
      endAngle = box2.maxX * diffAngle;
      startAngle = box2.minX * diffAngle;
    }
    endAngle += coordStartAngle;
    startAngle += coordStartAngle;
    return {
      startAngle,
      endAngle
    };
  }
  function getPolygonCentroid(xs, ys) {
    if (is_number_default(xs) && is_number_default(ys)) {
      return [xs, ys];
    }
    xs = xs;
    ys = ys;
    if (uniqueValues(xs) || uniqueValues(ys))
      return [mid(xs), mid(ys)];
    var i = -1;
    var x = 0;
    var y = 0;
    var former;
    var current = xs.length - 1;
    var diff2;
    var k = 0;
    while (++i < xs.length) {
      former = current;
      current = i;
      k += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
      x += (xs[former] + xs[current]) * diff2;
      y += (ys[former] + ys[current]) * diff2;
    }
    k *= 3;
    return [x / k, y / k];
  }
  function getReplaceAttrs(sourceShape, targetShape) {
    var originAttrs = sourceShape.attr();
    var newAttrs = targetShape.attr();
    each_default(originAttrs, function(v, k) {
      if (newAttrs[k] === void 0) {
        newAttrs[k] = void 0;
      }
    });
    return newAttrs;
  }

  // node_modules/@antv/g2/esm/util/helper.js
  function isBetween2(value, start, end) {
    var min3 = Math.min(start, end);
    var max3 = Math.max(start, end);
    return value >= min3 && value <= max3;
  }
  function padEnd(source, targetLength, padValue) {
    if (is_string_default(source)) {
      return source.padEnd(targetLength, padValue);
    } else if (is_array_default(source)) {
      var sourceLength = source.length;
      if (sourceLength < targetLength) {
        var diff2 = targetLength - sourceLength;
        for (var i = 0; i < diff2; i++) {
          source.push(padValue);
        }
      }
    }
    return source;
  }
  function omit(obj, keys2) {
    if (typeof obj === "object") {
      keys2.forEach(function(key) {
        delete obj[key];
      });
    }
    return obj;
  }
  function uniq2(sourceArray, targetArray, map5) {
    if (targetArray === void 0) {
      targetArray = [];
    }
    if (map5 === void 0) {
      map5 = new Map();
    }
    for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {
      var source = sourceArray_1[_i];
      if (!map5.has(source)) {
        targetArray.push(source);
        map5.set(source, true);
      }
    }
    return targetArray;
  }

  // node_modules/@antv/g2/esm/util/bbox.js
  var BBox = function() {
    function BBox2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = x;
      this.y = y;
      this.height = height;
      this.width = width;
    }
    BBox2.fromRange = function(minX, minY, maxX, maxY) {
      return new BBox2(minX, minY, maxX - minX, maxY - minY);
    };
    BBox2.fromObject = function(bbox) {
      return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
    };
    Object.defineProperty(BBox2.prototype, "minX", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxX", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "minY", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxY", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tl", {
      get: function() {
        return { x: this.x, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tr", {
      get: function() {
        return { x: this.maxX, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bl", {
      get: function() {
        return { x: this.x, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "br", {
      get: function() {
        return { x: this.maxX, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.minY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return {
          x: this.maxX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.maxY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return {
          x: this.minX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    BBox2.prototype.isEqual = function(bbox) {
      return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
    };
    BBox2.prototype.contains = function(child) {
      return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
    };
    BBox2.prototype.clone = function() {
      return new BBox2(this.x, this.y, this.width, this.height);
    };
    BBox2.prototype.add = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each_default(subBBox, function(b) {
        bbox.x = Math.min(b.x, bbox.x);
        bbox.y = Math.min(b.y, bbox.y);
        bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.merge = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each_default(subBBox, function(b) {
        bbox.x = Math.max(b.x, bbox.x);
        bbox.y = Math.max(b.y, bbox.y);
        bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.cut = function(subBBox, direction2) {
      var width = subBBox.width;
      var height = subBBox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
        default:
          return this;
      }
    };
    BBox2.prototype.shrink = function(gap) {
      var top = gap[0], right = gap[1], bottom = gap[2], left = gap[3];
      return new BBox2(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);
    };
    BBox2.prototype.expand = function(gap) {
      var top = gap[0], right = gap[1], bottom = gap[2], left = gap[3];
      return new BBox2(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);
    };
    BBox2.prototype.exceed = function(bbox) {
      return [
        Math.max(-this.minY + bbox.minY, 0),
        Math.max(this.maxX - bbox.maxX, 0),
        Math.max(this.maxY - bbox.maxY, 0),
        Math.max(-this.minX + bbox.minX, 0)
      ];
    };
    BBox2.prototype.collide = function(bbox) {
      return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
    };
    BBox2.prototype.size = function() {
      return this.width * this.height;
    };
    BBox2.prototype.isPointIn = function(p2) {
      return p2.x >= this.minX && p2.x <= this.maxX && p2.y >= this.minY && p2.y <= this.maxY;
    };
    return BBox2;
  }();
  function toPoints(bbox) {
    return [
      [bbox.minX, bbox.minY],
      [bbox.maxX, bbox.minY],
      [bbox.maxX, bbox.maxY],
      [bbox.minX, bbox.maxY]
    ];
  }

  // node_modules/@antv/g2/esm/util/coordinate.js
  function getXDimensionLength(coordinate) {
    if (coordinate.isPolar && !coordinate.isTransposed) {
      return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();
    }
    var start = coordinate.convert({ x: 0, y: 0 });
    var end = coordinate.convert({ x: 1, y: 0 });
    return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
  }
  function isFullCircle(coordinate) {
    if (coordinate.isPolar) {
      var startAngle = coordinate.startAngle, endAngle = coordinate.endAngle;
      return endAngle - startAngle === Math.PI * 2;
    }
    return false;
  }
  function getDistanceToCenter(coordinate, point) {
    var center = coordinate.getCenter();
    return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
  }
  function isPointInCoordinate(coordinate, point) {
    var result = false;
    if (coordinate) {
      if (coordinate.type === "theta") {
        var start = coordinate.start, end = coordinate.end;
        result = isBetween2(point.x, start.x, end.x) && isBetween2(point.y, start.y, end.y);
      } else {
        var invertPoint = coordinate.invert(point);
        result = isBetween2(invertPoint.x, 0, 1) && isBetween2(invertPoint.y, 0, 1);
      }
    }
    return result;
  }
  function getAngleByPoint(coordinate, point) {
    var center = coordinate.getCenter();
    return Math.atan2(point.y - center.y, point.x - center.x);
  }
  function getCoordinateClipCfg(coordinate, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    if (coordinate.isPolar) {
      var startAngle_1 = coordinate.startAngle, endAngle_1 = coordinate.endAngle;
      var center_1 = coordinate.getCenter();
      var radius_1 = coordinate.getRadius();
      return {
        type: "path",
        startState: {
          path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
        },
        endState: function(ratio) {
          var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
          var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
          return {
            path
          };
        },
        attrs: {
          path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
        }
      };
    }
    var endState;
    if (coordinate.isTransposed) {
      endState = {
        height: height + margin * 2
      };
    } else {
      endState = {
        width: width + margin * 2
      };
    }
    return {
      type: "rect",
      startState: {
        x: start.x - margin,
        y: end.y - margin,
        width: coordinate.isTransposed ? width + margin * 2 : 0,
        height: coordinate.isTransposed ? 0 : height + margin * 2
      },
      endState,
      attrs: {
        x: start.x - margin,
        y: end.y - margin,
        width: width + margin * 2,
        height: height + margin * 2
      }
    };
  }
  function getCoordinateBBox(coordinate, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
  }

  // node_modules/@antv/g2/esm/util/scale.js
  var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
  function getDefaultType(value) {
    var type = "linear";
    if (dateRegex.test(value)) {
      type = "timeCat";
    } else if (is_string_default(value)) {
      type = "cat";
    }
    return type;
  }
  function createScaleByField(field, data, scaleDef) {
    var validData = data || [];
    if (is_number_default(field) || is_nil_default(first_value_default(validData, field)) && is_empty_default(scaleDef)) {
      var Identity2 = getClass("identity");
      return new Identity2({
        field: field.toString(),
        values: [field]
      });
    }
    var values2 = values_of_key_default(validData, field);
    var type = get_default(scaleDef, "type", getDefaultType(values2[0]));
    var ScaleCtor = getClass(type);
    return new ScaleCtor(__assign({ field, values: values2 }, scaleDef));
  }
  function syncScale(scale4, newScale) {
    if (scale4.type !== "identity" && newScale.type !== "identity") {
      var obj = {};
      for (var k in newScale) {
        if (Object.prototype.hasOwnProperty.call(newScale, k)) {
          obj[k] = newScale[k];
        }
      }
      scale4.change(obj);
    }
  }
  function getName(scale4) {
    return scale4.alias || scale4.field;
  }
  function getDefaultCategoryScaleRange(scale4, coordinate, theme) {
    var values2 = scale4.values;
    var count = values2.length;
    var range;
    if (count === 1) {
      range = [0.5, 1];
    } else {
      var widthRatio = 1;
      var offset = 0;
      if (isFullCircle(coordinate)) {
        if (!coordinate.isTransposed) {
          range = [0, 1 - 1 / count];
        } else {
          widthRatio = get_default(theme, "widthRatio.multiplePie", 1 / 1.3);
          offset = 1 / count * widthRatio;
          range = [offset / 2, 1 - offset / 2];
        }
      } else {
        offset = 1 / count / 2;
        range = [offset, 1 - offset];
      }
    }
    return range;
  }
  function getMaxScale(scale4) {
    var values2 = scale4.values.filter(function(item) {
      return !is_nil_default(item) && !isNaN(item);
    });
    return Math.max.apply(Math, __spreadArray(__spreadArray([], values2, false), [is_nil_default(scale4.max) ? -Infinity : scale4.max], false));
  }

  // node_modules/@antv/g2/esm/util/axis.js
  function getLineAxisRelativeRegion(direction2) {
    var start;
    var end;
    switch (direction2) {
      case DIRECTION.TOP:
        start = { x: 0, y: 1 };
        end = { x: 1, y: 1 };
        break;
      case DIRECTION.RIGHT:
        start = { x: 1, y: 0 };
        end = { x: 1, y: 1 };
        break;
      case DIRECTION.BOTTOM:
        start = { x: 0, y: 0 };
        end = { x: 1, y: 0 };
        break;
      case DIRECTION.LEFT:
        start = { x: 0, y: 0 };
        end = { x: 0, y: 1 };
        break;
      default:
        start = end = { x: 0, y: 0 };
    }
    return { start, end };
  }
  function getCircleAxisRelativeRegion(coordinate) {
    var start;
    var end;
    if (coordinate.isTransposed) {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 0
      };
    } else {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
    }
    return { start, end };
  }
  function getAxisRegion(coordinate, direction2) {
    var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
    if (coordinate.isRect) {
      region = getLineAxisRelativeRegion(direction2);
    } else if (coordinate.isPolar) {
      region = getCircleAxisRelativeRegion(coordinate);
    }
    var start = region.start, end = region.end;
    return {
      start: coordinate.convert(start),
      end: coordinate.convert(end)
    };
  }
  function isVertical(region) {
    var start = region.start, end = region.end;
    return start.x === end.x;
  }
  function getAxisFactorByRegion(region, center) {
    var start = region.start, end = region.end;
    var isAxisVertical = isVertical(region);
    if (isAxisVertical) {
      if ((start.y - end.y) * (center.x - start.x) > 0) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if ((end.x - start.x) * (start.y - center.y) > 0) {
        return -1;
      } else {
        return 1;
      }
    }
  }
  function getAxisThemeCfg(theme, direction2) {
    var axisTheme = get_default(theme, ["components", "axis"], {});
    return deep_mix_default({}, get_default(axisTheme, ["common"], {}), deep_mix_default({}, get_default(axisTheme, [direction2], {})));
  }
  function getAxisTitleOptions(theme, direction2, axisOptions) {
    var axisTheme = get_default(theme, ["components", "axis"], {});
    return deep_mix_default({}, get_default(axisTheme, ["common", "title"], {}), deep_mix_default({}, get_default(axisTheme, [direction2, "title"], {})), axisOptions);
  }
  function getCircleAxisCenterRadius(coordinate) {
    var x = coordinate.x, y = coordinate.y, center = coordinate.circleCenter;
    var isReflectY = y.start > y.end;
    var start = coordinate.isTransposed ? coordinate.convert({
      x: isReflectY ? 0 : 1,
      y: 0
    }) : coordinate.convert({
      x: 0,
      y: isReflectY ? 0 : 1
    });
    var startVector = [start.x - center.x, start.y - center.y];
    var normalVector = [1, 0];
    var startAngle = start.y > center.y ? vec2_exports.angle(startVector, normalVector) : vec2_exports.angle(startVector, normalVector) * -1;
    var endAngle = startAngle + (x.end - x.start);
    var radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
    return {
      center,
      radius,
      startAngle,
      endAngle
    };
  }
  function getAxisOption(axes, field) {
    if (is_boolean_default(axes)) {
      return axes === false ? false : {};
    }
    return get_default(axes, [field]);
  }
  function getAxisDirection(axisOption, def2) {
    return get_default(axisOption, "position", def2);
  }
  function getAxisTitleText(scale4, axisOption) {
    return get_default(axisOption, ["title", "text"], getName(scale4));
  }

  // node_modules/@antv/g2/esm/facet/facet.js
  var Facet = function() {
    function Facet2(view, cfg) {
      this.destroyed = false;
      this.facets = [];
      this.view = view;
      this.cfg = deep_mix_default({}, this.getDefaultCfg(), cfg);
    }
    Facet2.prototype.init = function() {
      if (!this.container) {
        this.container = this.createContainer();
      }
      var data = this.view.getData();
      this.facets = this.generateFacets(data);
    };
    Facet2.prototype.render = function() {
      this.renderViews();
    };
    Facet2.prototype.update = function() {
    };
    Facet2.prototype.clear = function() {
      this.clearFacetViews();
    };
    Facet2.prototype.destroy = function() {
      this.clear();
      if (this.container) {
        this.container.remove(true);
        this.container = void 0;
      }
      this.destroyed = true;
      this.view = void 0;
      this.facets = [];
    };
    Facet2.prototype.facetToView = function(facet) {
      var region = facet.region, data = facet.data, _a4 = facet.padding, padding = _a4 === void 0 ? this.cfg.padding : _a4;
      var view = this.view.createView({
        region,
        padding
      });
      view.data(data || []);
      facet.view = view;
      this.beforeEachView(view, facet);
      var eachView = this.cfg.eachView;
      if (eachView) {
        eachView(view, facet);
      }
      this.afterEachView(view, facet);
      return view;
    };
    Facet2.prototype.createContainer = function() {
      var foregroundGroup = this.view.getLayer(LAYER.FORE);
      return foregroundGroup.addGroup();
    };
    Facet2.prototype.renderViews = function() {
      this.createFacetViews();
    };
    Facet2.prototype.createFacetViews = function() {
      var _this = this;
      return this.facets.map(function(facet) {
        return _this.facetToView(facet);
      });
    };
    Facet2.prototype.clearFacetViews = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        if (facet.view) {
          _this.view.removeView(facet.view);
          facet.view = void 0;
        }
      });
    };
    Facet2.prototype.parseSpacing = function() {
      var _a4 = this.view.viewBBox, width = _a4.width, height = _a4.height;
      var spacing = this.cfg.spacing;
      return spacing.map(function(s, idx) {
        if (is_number_default(s))
          return s / (idx === 0 ? width : height);
        else
          return parseFloat(s) / 100;
      });
    };
    Facet2.prototype.getFieldValues = function(data, field) {
      var rst = [];
      var cache3 = {};
      each_default(data, function(d) {
        var value = d[field];
        if (!is_nil_default(value) && !cache3[value]) {
          rst.push(value);
          cache3[value] = true;
        }
      });
      return rst;
    };
    Facet2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var _a4 = this.parseSpacing(), xSpacing = _a4[0], ySpacing = _a4[1];
      var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
      var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
      var start = {
        x: (xRatio + xSpacing) * xIndex,
        y: (yRatio + ySpacing) * yIndex
      };
      var end = {
        x: start.x + xRatio,
        y: start.y + yRatio
      };
      return { start, end };
    };
    Facet2.prototype.getDefaultCfg = function() {
      return {
        eachView: void 0,
        showTitle: true,
        spacing: [0, 0],
        padding: 10,
        fields: []
      };
    };
    Facet2.prototype.getDefaultTitleCfg = function() {
      var fontFamily = this.view.getTheme().fontFamily;
      return {
        style: {
          fontSize: 14,
          fill: "#666",
          fontFamily
        }
      };
    };
    Facet2.prototype.processAxis = function(view, facet) {
      var options = view.getOptions();
      var coordinateOption = options.coordinate;
      var geometries = view.geometries;
      var coordinateType = get_default(coordinateOption, "type", "rect");
      if (coordinateType === "rect" && geometries.length) {
        if (is_nil_default(options.axes)) {
          options.axes = {};
        }
        var axes = options.axes;
        var _a4 = geometries[0].getXYFields(), x = _a4[0], y = _a4[1];
        var xOption = getAxisOption(axes, x);
        var yOption = getAxisOption(axes, y);
        if (xOption !== false) {
          options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
        }
        if (yOption !== false) {
          options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
        }
      }
    };
    Facet2.prototype.getFacetDataFilter = function(conditions) {
      return function(datum) {
        return every_default(conditions, function(condition) {
          var field = condition.field, value = condition.value;
          if (!is_nil_default(value) && field) {
            return datum[field] === value;
          }
          return true;
        });
      };
    };
    return Facet2;
  }();

  // node_modules/@antv/g2/esm/facet/index.js
  var Facets = {};
  var getFacet = function(type) {
    return Facets[lower_case_default(type)];
  };
  var registerFacet = function(type, ctor) {
    Facets[lower_case_default(type)] = ctor;
  };

  // node_modules/@antv/g2/esm/interaction/action/base.js
  var Action = function() {
    function Action2(context, cfg) {
      this.context = context;
      this.cfg = cfg;
      context.addAction(this);
    }
    Action2.prototype.applyCfg = function(cfg) {
      mix(this, cfg);
    };
    Action2.prototype.init = function() {
      this.applyCfg(this.cfg);
    };
    Action2.prototype.destroy = function() {
      this.context.removeAction(this);
      this.context = null;
    };
    return Action2;
  }();
  var base_default13 = Action;

  // node_modules/@antv/g2/esm/interaction/action/callback.js
  var CallbackAction = function(_super) {
    __extends(CallbackAction2, _super);
    function CallbackAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CallbackAction2.prototype.execute = function() {
      if (this.callback) {
        this.callback(this.context);
      }
    };
    CallbackAction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.callback = null;
    };
    return CallbackAction2;
  }(base_default13);
  var callback_default = CallbackAction;

  // node_modules/@antv/g2/esm/interaction/action/register.js
  var ActionCache = {};
  function createAction(actionName, context) {
    var actionOption = ActionCache[actionName];
    var action = null;
    if (actionOption) {
      var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
      action = new ActionClass(context, cfg);
      action.name = actionName;
      action.init();
    }
    return action;
  }
  function registerAction(actionName, ActionClass, cfg) {
    ActionCache[actionName] = {
      ActionClass,
      cfg
    };
  }
  function createCallbackAction(callback, context) {
    var action = new callback_default(context);
    action.callback = callback;
    action.name = "callback";
    return action;
  }

  // node_modules/@antv/g2/esm/geometry/shape/util/path.js
  function _points2path(points, isInCircle) {
    var path = [];
    if (points.length) {
      path.push(["M", points[0].x, points[0].y]);
      for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
        var item = points[i];
        path.push(["L", item.x, item.y]);
      }
      if (isInCircle) {
        path.push(["Z"]);
      }
    }
    return path;
  }
  function _convertArr(arr, coord) {
    var tmp = [arr[0]];
    for (var i = 1, len3 = arr.length; i < len3; i = i + 2) {
      var point = coord.convert({
        x: arr[i],
        y: arr[i + 1]
      });
      tmp.push(point.x, point.y);
    }
    return tmp;
  }
  function _convertArcPath(path, coord) {
    var isTransposed = coord.isTransposed;
    var r = path[1];
    var x = path[6];
    var y = path[7];
    var point = coord.convert({ x, y });
    var direction2 = isTransposed ? 0 : 1;
    return ["A", r, r, 0, 0, direction2, point.x, point.y];
  }
  function _convertPolarPath(pre, cur, coord) {
    var isTransposed = coord.isTransposed, startAngle = coord.startAngle, endAngle = coord.endAngle;
    var prePoint = pre[0].toLowerCase() === "a" ? {
      x: pre[6],
      y: pre[7]
    } : {
      x: pre[1],
      y: pre[2]
    };
    var curPoint = {
      x: cur[1],
      y: cur[2]
    };
    var rst = [];
    var xDim = isTransposed ? "y" : "x";
    var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
    var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
    var flag = angleRange > Math.PI ? 1 : 0;
    var convertPoint = coord.convert(curPoint);
    var r = getDistanceToCenter(coord, convertPoint);
    if (r >= 0.5) {
      if (angleRange === Math.PI * 2) {
        var middlePoint = {
          x: (curPoint.x + prePoint.x) / 2,
          y: (curPoint.y + prePoint.y) / 2
        };
        var middleConvertPoint = coord.convert(middlePoint);
        rst.push(["A", r, r, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
        rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
      } else {
        rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
      }
    }
    return rst;
  }
  function _filterFullCirleLine(path) {
    each_default(path, function(subPath, index) {
      var cur = subPath;
      if (cur[0].toLowerCase() === "a") {
        var pre = path[index - 1];
        var next = path[index + 1];
        if (next && next[0].toLowerCase() === "a") {
          if (pre && pre[0].toLowerCase() === "l") {
            pre[0] = "M";
          }
        } else if (pre && pre[0].toLowerCase() === "a") {
          if (next && next[0].toLowerCase() === "l") {
            next[0] = "M";
          }
        }
      }
    });
  }
  var smoothBezier2 = function(points, smooth, isLoop, constraint) {
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min3;
    var max3;
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      min3 = constraint[0], max3 = constraint[1];
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        min3 = vec2_exports.min([0, 0], min3, point);
        max3 = vec2_exports.max([0, 0], max3, point);
      }
    }
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point;
      } else if (i === len3 - 1 && !isLoop) {
        cp1 = point;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        prevPoint = points[isLoop ? i ? i - 1 : len3 - 1 : i - 1];
        nextPoint = points[isLoop ? (i + 1) % len3 : i + 1];
        var v = [0, 0];
        v = vec2_exports.sub(v, nextPoint, prevPoint);
        v = vec2_exports.scale(v, v, smooth);
        var d0 = vec2_exports.distance(point, prevPoint);
        var d1 = vec2_exports.distance(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }
        var v1 = vec2_exports.scale([0, 0], v, -d0);
        var v2 = vec2_exports.scale([0, 0], v, d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
        nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
        v1 = vec2_exports.sub([0, 0], nextCp0, point);
        v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
        cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
        v2 = vec2_exports.sub([0, 0], point, cp1);
        v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        if (hasConstraint) {
          cp1 = vec2_exports.max([0, 0], cp1, min3);
          cp1 = vec2_exports.min([0, 0], cp1, max3);
          nextCp0 = vec2_exports.max([0, 0], nextCp0, min3);
          nextCp0 = vec2_exports.min([0, 0], nextCp0, max3);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  };
  function catmullRom2bezier(crp, z, constraint) {
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier2(pointList, 0.4, isLoop, constraint);
    var len3 = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p2;
    for (var i = 0; i < len3 - 1; i++) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p2 = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len3];
      cp2 = controlPointList[len3 + 1];
      p2 = pointList[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    return d1;
  }
  function getLinePath2(points, isInCircle) {
    return _points2path(points, isInCircle);
  }
  function getSplinePath(points, isInCircle, constaint) {
    var data = [];
    var first = points[0];
    var prePoint = null;
    if (points.length <= 2) {
      return getLinePath2(points, isInCircle);
    }
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
        data.push(point.x);
        data.push(point.y);
        prePoint = point;
      }
    }
    var constraint = constaint || [
      [0, 0],
      [1, 1]
    ];
    var splinePath = catmullRom2bezier(data, isInCircle, constraint);
    splinePath.unshift(["M", first.x, first.y]);
    return splinePath;
  }
  function convertNormalPath(coord, path) {
    var tmp = [];
    each_default(path, function(subPath) {
      var action = subPath[0];
      switch (action.toLowerCase()) {
        case "m":
        case "l":
        case "c":
          tmp.push(_convertArr(subPath, coord));
          break;
        case "a":
          tmp.push(_convertArcPath(subPath, coord));
          break;
        case "z":
        default:
          tmp.push(subPath);
          break;
      }
    });
    return tmp;
  }
  function convertPolarPath(coord, path) {
    var tmp = [];
    var pre;
    var cur;
    var transposed;
    var equals4;
    each_default(path, function(subPath, index) {
      var action = subPath[0];
      switch (action.toLowerCase()) {
        case "m":
        case "c":
        case "q":
          tmp.push(_convertArr(subPath, coord));
          break;
        case "l":
          pre = path[index - 1];
          cur = subPath;
          transposed = coord.isTransposed;
          equals4 = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
          if (equals4) {
            tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
          } else {
            tmp.push(_convertArr(subPath, coord));
          }
          break;
        case "a":
          tmp.push(_convertArcPath(subPath, coord));
          break;
        case "z":
        default:
          tmp.push(subPath);
          break;
      }
    });
    _filterFullCirleLine(tmp);
    return tmp;
  }

  // node_modules/@antv/g2/esm/interaction/action/util.js
  function getMaskBBox(context, tolerance3) {
    var event = context.event;
    var maskShape = event.target;
    var maskBBox = maskShape.getCanvasBBox();
    if (!(maskBBox.width >= tolerance3 || maskBBox.height >= tolerance3)) {
      return null;
    }
    return maskBBox;
  }
  function getMaskPath(context, tolerance3) {
    var event = context.event;
    var maskShape = event.target;
    var maskBBox = maskShape.getCanvasBBox();
    if (!(maskBBox.width >= tolerance3 || maskBBox.height >= tolerance3)) {
      return null;
    }
    return maskShape.attr("path");
  }
  function getCurrentElement(context) {
    var event = context.event;
    var element;
    var target = event.target;
    if (target) {
      element = target.get("element");
    }
    return element;
  }
  function getDelegationObject(context) {
    var event = context.event;
    var target = event.target;
    var delegateObject;
    if (target) {
      delegateObject = target.get("delegateObject");
    }
    return delegateObject;
  }
  function isElementChange(context) {
    var event = context.event.gEvent;
    if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
      return false;
    }
    return true;
  }
  function isList(delegateObject) {
    return delegateObject && delegateObject.component && delegateObject.component.isList();
  }
  function isSlider(delegateObject) {
    return delegateObject && delegateObject.component && delegateObject.component.isSlider();
  }
  function isMask(context) {
    var event = context.event;
    var target = event.target;
    return target && target.get("name") === "mask";
  }
  function getMaskedElements(context, tolerance3) {
    var target = context.event.target;
    if (target.get("type") === "path") {
      var maskPath = getMaskPath(context, tolerance3);
      if (!maskPath) {
        return;
      }
      return getElementsByPath(context.view, maskPath);
    }
    var maskBBox = getMaskBBox(context, tolerance3);
    if (!maskBBox) {
      return null;
    }
    return getIntersectElements(context.view, maskBBox);
  }
  function getSiblingMaskElements(context, sibling, tolerance3) {
    var maskBBox = getMaskBBox(context, tolerance3);
    if (!maskBBox) {
      return null;
    }
    var view = context.view;
    var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
    var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
    var box2 = {
      minX: start.x,
      minY: start.y,
      maxX: end.x,
      maxY: end.y
    };
    return getIntersectElements(sibling, box2);
  }
  function getElements(view) {
    var geometries = view.geometries;
    var rst = [];
    each_default(geometries, function(geom) {
      var elements = geom.elements;
      rst = rst.concat(elements);
    });
    if (view.views && view.views.length) {
      each_default(view.views, function(subView) {
        rst = rst.concat(getElements(subView));
      });
    }
    return rst;
  }
  function getElementsByField(view, field, value) {
    var elements = getElements(view);
    return elements.filter(function(el) {
      return getElementValue(el, field) === value;
    });
  }
  function getElementsByState(view, stateName) {
    var geometries = view.geometries;
    var rst = [];
    each_default(geometries, function(geom) {
      var elements = geom.getElementsBy(function(el) {
        return el.hasState(stateName);
      });
      rst = rst.concat(elements);
    });
    return rst;
  }
  function getElementValue(element, field) {
    var model = element.getModel();
    var record = model.data;
    var value;
    if (is_array_default(record)) {
      value = record[0][field];
    } else {
      value = record[field];
    }
    return value;
  }
  function intersectRect(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
  }
  function getIntersectElements(view, box2) {
    var elements = getElements(view);
    var rst = [];
    each_default(elements, function(el) {
      var shape = el.shape;
      var shapeBBox = shape.getCanvasBBox();
      if (intersectRect(box2, shapeBBox)) {
        rst.push(el);
      }
    });
    return rst;
  }
  function pathToPoints(path) {
    var points = [];
    each_default(path, function(seg) {
      var command = seg[0];
      if (command !== "A") {
        for (var i = 1; i < seg.length; i = i + 2) {
          points.push([seg[i], seg[i + 1]]);
        }
      } else {
        var length_1 = seg.length;
        points.push([seg[length_1 - 2], seg[length_1 - 1]]);
      }
    });
    return points;
  }
  function getElementsByPath(view, path) {
    var elements = getElements(view);
    var points = pathToPoints(path);
    var rst = elements.filter(function(el) {
      var shape = el.shape;
      var shapePoints;
      if (shape.get("type") === "path") {
        shapePoints = pathToPoints(shape.attr("path"));
      } else {
        var shapeBBox = shape.getCanvasBBox();
        shapePoints = toPoints(shapeBBox);
      }
      return isPolygonsIntersect(points, shapePoints);
    });
    return rst;
  }
  function getComponents(view) {
    return view.getComponents().map(function(co) {
      return co.component;
    });
  }
  function distance6(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function getSpline(points, z) {
    if (points.length <= 2) {
      return getLinePath2(points, false);
    }
    var first = points[0];
    var arr = [];
    each_default(points, function(point) {
      arr.push(point.x);
      arr.push(point.y);
    });
    var path = catmullRom2bezier(arr, z, null);
    path.unshift(["M", first.x, first.y]);
    return path;
  }
  function isInBox(box2, point) {
    return box2.x <= point.x && box2.maxX >= point.x && box2.y <= point.y && box2.maxY > point.y;
  }
  function getSilbings(view) {
    var parent = view.parent;
    var siblings = null;
    if (parent) {
      siblings = parent.views.filter(function(sub4) {
        return sub4 !== view;
      });
    }
    return siblings;
  }
  function point2Normalize(view, point) {
    var coord = view.getCoordinate();
    return coord.invert(point);
  }
  function getSiblingPoint(view, sibling, point) {
    var normalPoint = point2Normalize(view, point);
    return sibling.getCoordinate().convert(normalPoint);
  }
  function isInRecords(records, record, xFiled, yField) {
    var isIn = false;
    each_default(records, function(r) {
      if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
        isIn = true;
        return false;
      }
    });
    return isIn;
  }
  function getScaleByField(view, field) {
    var scale4 = view.getScaleByField(field);
    if (!scale4 && view.views) {
      each_default(view.views, function(subView) {
        scale4 = getScaleByField(subView, field);
        if (scale4) {
          return false;
        }
      });
    }
    return scale4;
  }

  // node_modules/@antv/g2/esm/interaction/context.js
  var Context = function() {
    function Context2(view) {
      this.actions = [];
      this.event = null;
      this.cacheMap = {};
      this.view = view;
    }
    Context2.prototype.cache = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 1) {
        return this.cacheMap[params[0]];
      } else if (params.length === 2) {
        this.cacheMap[params[0]] = params[1];
      }
    };
    Context2.prototype.getAction = function(name) {
      return this.actions.find(function(action) {
        return action.name === name;
      });
    };
    Context2.prototype.addAction = function(action) {
      this.actions.push(action);
    };
    Context2.prototype.removeAction = function(action) {
      var actions = this.actions;
      var index = this.actions.indexOf(action);
      if (index >= 0) {
        actions.splice(index, 1);
      }
    };
    Context2.prototype.getCurrentPoint = function() {
      var event = this.event;
      if (event) {
        if (event.target instanceof HTMLElement) {
          var canvas = this.view.getCanvas();
          var point = canvas.getPointByClient(event.clientX, event.clientY);
          return point;
        } else {
          return {
            x: event.x,
            y: event.y
          };
        }
      }
      return null;
    };
    Context2.prototype.getCurrentShape = function() {
      return get_default(this.event, ["gEvent", "shape"]);
    };
    Context2.prototype.isInPlot = function() {
      var point = this.getCurrentPoint();
      if (point) {
        return this.view.isPointInPlot(point);
      }
      return false;
    };
    Context2.prototype.isInShape = function(name) {
      var shape = this.getCurrentShape();
      if (shape) {
        return shape.get("name") === name;
      }
      return false;
    };
    Context2.prototype.isInComponent = function(name) {
      var components = getComponents(this.view);
      var point = this.getCurrentPoint();
      if (point) {
        return !!components.find(function(component) {
          var bbox = component.getBBox();
          if (name) {
            return component.get("name") === name && isInBox(bbox, point);
          } else {
            return isInBox(bbox, point);
          }
        });
      }
      return false;
    };
    Context2.prototype.destroy = function() {
      each_default(this.actions.slice(), function(action) {
        action.destroy();
      });
      this.view = null;
      this.event = null;
      this.actions = null;
      this.cacheMap = null;
    };
    return Context2;
  }();
  var context_default = Context;

  // node_modules/@antv/g2/esm/interaction/interaction.js
  var Interaction = function() {
    function Interaction2(view, cfg) {
      this.view = view;
      this.cfg = cfg;
    }
    Interaction2.prototype.init = function() {
      this.initEvents();
    };
    Interaction2.prototype.initEvents = function() {
    };
    Interaction2.prototype.clearEvents = function() {
    };
    Interaction2.prototype.destroy = function() {
      this.clearEvents();
    };
    return Interaction2;
  }();
  var interaction_default = Interaction;

  // node_modules/@antv/g2/esm/interaction/grammar-interaction.js
  function parseAction(actionStr, context, arg) {
    var arr = actionStr.split(":");
    var actionName = arr[0];
    var action = context.getAction(actionName) || createAction(actionName, context);
    if (!action) {
      throw new Error("There is no action named " + actionName);
    }
    var methodName = arr[1];
    return {
      action,
      methodName,
      arg
    };
  }
  function executeAction(actionObject) {
    var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
    if (action[methodName]) {
      action[methodName](arg);
    } else {
      throw new Error("Action(" + action.name + ") doesn't have a method called " + methodName);
    }
  }
  var STEP_NAMES = {
    START: "start",
    SHOW_ENABLE: "showEnable",
    END: "end",
    ROLLBACK: "rollback",
    PROCESSING: "processing"
  };
  var GrammarInteraction = function(_super) {
    __extends(GrammarInteraction2, _super);
    function GrammarInteraction2(view, steps) {
      var _this = _super.call(this, view, steps) || this;
      _this.callbackCaches = {};
      _this.emitCaches = {};
      _this.steps = steps;
      return _this;
    }
    GrammarInteraction2.prototype.init = function() {
      this.initContext();
      _super.prototype.init.call(this);
    };
    GrammarInteraction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.steps = null;
      if (this.context) {
        this.context.destroy();
        this.context = null;
      }
      this.callbackCaches = null;
      this.view = null;
    };
    GrammarInteraction2.prototype.initEvents = function() {
      var _this = this;
      each_default(this.steps, function(stepArr, stepName) {
        each_default(stepArr, function(step) {
          var callback = _this.getActionCallback(stepName, step);
          if (callback) {
            _this.bindEvent(step.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.clearEvents = function() {
      var _this = this;
      each_default(this.steps, function(stepArr, stepName) {
        each_default(stepArr, function(step) {
          var callback = _this.getActionCallback(stepName, step);
          if (callback) {
            _this.offEvent(step.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.initContext = function() {
      var view = this.view;
      var context = new context_default(view);
      this.context = context;
      var steps = this.steps;
      each_default(steps, function(subSteps) {
        each_default(subSteps, function(step) {
          if (is_function_default(step.action)) {
            step.actionObject = {
              action: createCallbackAction(step.action, context),
              methodName: "execute"
            };
          } else if (is_string_default(step.action)) {
            step.actionObject = parseAction(step.action, context, step.arg);
          } else if (is_array_default(step.action)) {
            var actionArr = step.action;
            var argArr_1 = is_array_default(step.arg) ? step.arg : [step.arg];
            step.actionObject = [];
            each_default(actionArr, function(actionStr, idx) {
              step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
            });
          }
        });
      });
    };
    GrammarInteraction2.prototype.isAllowStep = function(stepName) {
      var currentStepName = this.currentStepName;
      var steps = this.steps;
      if (currentStepName === stepName) {
        return true;
      }
      if (stepName === STEP_NAMES.SHOW_ENABLE) {
        return true;
      }
      if (stepName === STEP_NAMES.PROCESSING) {
        return currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.START) {
        return currentStepName !== STEP_NAMES.PROCESSING;
      }
      if (stepName === STEP_NAMES.END) {
        return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.ROLLBACK) {
        if (steps[STEP_NAMES.END]) {
          return currentStepName === STEP_NAMES.END;
        } else if (currentStepName === STEP_NAMES.START) {
          return true;
        }
      }
      return false;
    };
    GrammarInteraction2.prototype.isAllowExecute = function(stepName, step) {
      if (this.isAllowStep(stepName)) {
        var key = this.getKey(stepName, step);
        if (step.once && this.emitCaches[key]) {
          return false;
        }
        if (step.isEnable) {
          return step.isEnable(this.context);
        }
        return true;
      }
      return false;
    };
    GrammarInteraction2.prototype.enterStep = function(stepName) {
      this.currentStepName = stepName;
      this.emitCaches = {};
    };
    GrammarInteraction2.prototype.afterExecute = function(stepName, step) {
      if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
        this.enterStep(stepName);
      }
      var key = this.getKey(stepName, step);
      this.emitCaches[key] = true;
    };
    GrammarInteraction2.prototype.getKey = function(stepName, step) {
      return stepName + step.trigger + step.action;
    };
    GrammarInteraction2.prototype.getActionCallback = function(stepName, step) {
      var _this = this;
      var context = this.context;
      var callbackCaches = this.callbackCaches;
      var actionObject = step.actionObject;
      if (step.action && actionObject) {
        var key = this.getKey(stepName, step);
        if (!callbackCaches[key]) {
          var actionCallback = function(event) {
            context.event = event;
            if (_this.isAllowExecute(stepName, step)) {
              if (is_array_default(actionObject)) {
                each_default(actionObject, function(obj) {
                  context.event = event;
                  executeAction(obj);
                });
              } else {
                context.event = event;
                executeAction(actionObject);
              }
              _this.afterExecute(stepName, step);
              if (step.callback) {
                context.event = event;
                step.callback(context);
              }
            } else {
              context.event = null;
            }
          };
          if (step.debounce) {
            callbackCaches[key] = debounce_default(actionCallback, step.debounce.wait, step.debounce.immediate);
          } else if (step.throttle) {
            callbackCaches[key] = throttle_default(actionCallback, step.throttle.wait, {
              leading: step.throttle.leading,
              trailing: step.throttle.trailing
            });
          } else {
            callbackCaches[key] = actionCallback;
          }
        }
        return callbackCaches[key];
      }
      return null;
    };
    GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.addEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.addEventListener(nameArr[1], callback);
      } else {
        this.view.on(eventName, callback);
      }
    };
    GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.removeEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.removeEventListener(nameArr[1], callback);
      } else {
        this.view.off(eventName, callback);
      }
    };
    return GrammarInteraction2;
  }(interaction_default);
  var grammar_interaction_default = GrammarInteraction;

  // node_modules/@antv/g2/esm/interaction/index.js
  var Interactions = {};
  function getInteraction(name) {
    return Interactions[lower_case_default(name)];
  }
  function registerInteraction(name, interaction) {
    Interactions[lower_case_default(name)] = interaction;
  }
  function createInteraction(name, view, cfg) {
    var interaciton = getInteraction(name);
    if (!interaciton) {
      return null;
    }
    if (is_plain_object_default(interaciton)) {
      var steps = mix(clone_default(interaciton), cfg);
      return new grammar_interaction_default(view, steps);
    } else {
      var cls = interaciton;
      return new cls(view, cfg);
    }
  }

  // node_modules/@antv/g2/esm/theme/util/create-by-style-sheet.js
  function createAxisStyles(styleSheet) {
    return {
      title: {
        autoRotate: true,
        position: "center",
        spacing: styleSheet.axisTitleSpacing,
        style: {
          fill: styleSheet.axisTitleTextFillColor,
          fontSize: styleSheet.axisTitleTextFontSize,
          lineHeight: styleSheet.axisTitleTextLineHeight,
          textBaseline: "middle",
          fontFamily: styleSheet.fontFamily
        }
      },
      label: {
        autoRotate: false,
        autoEllipsis: false,
        autoHide: { type: "equidistance", cfg: { minGap: 6 } },
        offset: styleSheet.axisLabelOffset,
        style: {
          fill: styleSheet.axisLabelFillColor,
          fontSize: styleSheet.axisLabelFontSize,
          lineHeight: styleSheet.axisLabelLineHeight,
          fontFamily: styleSheet.fontFamily
        }
      },
      line: {
        style: {
          lineWidth: styleSheet.axisLineBorder,
          stroke: styleSheet.axisLineBorderColor
        }
      },
      grid: {
        line: {
          type: "line",
          style: {
            stroke: styleSheet.axisGridBorderColor,
            lineWidth: styleSheet.axisGridBorder,
            lineDash: styleSheet.axisGridLineDash
          }
        },
        alignTick: true,
        animate: true
      },
      tickLine: {
        style: {
          lineWidth: styleSheet.axisTickLineBorder,
          stroke: styleSheet.axisTickLineBorderColor
        },
        alignTick: true,
        length: styleSheet.axisTickLineLength
      },
      subTickLine: null,
      animate: true
    };
  }
  function createLegendStyles(styleSheet) {
    return {
      title: null,
      marker: {
        symbol: "circle",
        spacing: styleSheet.legendMarkerSpacing,
        style: {
          r: styleSheet.legendCircleMarkerSize,
          fill: styleSheet.legendMarkerColor
        }
      },
      itemName: {
        spacing: 5,
        style: {
          fill: styleSheet.legendItemNameFillColor,
          fontFamily: styleSheet.fontFamily,
          fontSize: styleSheet.legendItemNameFontSize,
          lineHeight: styleSheet.legendItemNameLineHeight,
          fontWeight: styleSheet.legendItemNameFontWeight,
          textAlign: "start",
          textBaseline: "middle"
        }
      },
      itemStates: {
        active: {
          nameStyle: {
            opacity: 0.8
          }
        },
        unchecked: {
          nameStyle: {
            fill: "#D8D8D8"
          },
          markerStyle: {
            fill: "#D8D8D8",
            stroke: "#D8D8D8"
          }
        },
        inactive: {
          nameStyle: {
            fill: "#D8D8D8"
          },
          markerStyle: {
            opacity: 0.2
          }
        }
      },
      flipPage: true,
      pageNavigator: {
        marker: {
          style: {
            size: styleSheet.legendPageNavigatorMarkerSize,
            inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
            inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
            fill: styleSheet.legendPageNavigatorMarkerFillColor,
            opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
          }
        },
        text: {
          style: {
            fill: styleSheet.legendPageNavigatorTextFillColor,
            fontSize: styleSheet.legendPageNavigatorTextFontSize
          }
        }
      },
      animate: false,
      maxItemWidth: 200,
      itemSpacing: styleSheet.legendItemSpacing,
      itemMarginBottom: styleSheet.legendItemMarginBottom,
      padding: styleSheet.legendPadding
    };
  }
  function createThemeByStyleSheet(styleSheet) {
    var _a4;
    var shapeStyles = {
      point: {
        default: {
          fill: styleSheet.pointFillColor,
          r: styleSheet.pointSize,
          stroke: styleSheet.pointBorderColor,
          lineWidth: styleSheet.pointBorder,
          fillOpacity: styleSheet.pointFillOpacity
        },
        active: {
          stroke: styleSheet.pointActiveBorderColor,
          lineWidth: styleSheet.pointActiveBorder
        },
        selected: {
          stroke: styleSheet.pointSelectedBorderColor,
          lineWidth: styleSheet.pointSelectedBorder
        },
        inactive: {
          fillOpacity: styleSheet.pointInactiveFillOpacity,
          strokeOpacity: styleSheet.pointInactiveBorderOpacity
        }
      },
      hollowPoint: {
        default: {
          fill: styleSheet.hollowPointFillColor,
          lineWidth: styleSheet.hollowPointBorder,
          stroke: styleSheet.hollowPointBorderColor,
          strokeOpacity: styleSheet.hollowPointBorderOpacity,
          r: styleSheet.hollowPointSize
        },
        active: {
          stroke: styleSheet.hollowPointActiveBorderColor,
          strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
        },
        selected: {
          lineWidth: styleSheet.hollowPointSelectedBorder,
          stroke: styleSheet.hollowPointSelectedBorderColor,
          strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
        },
        inactive: {
          strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
        }
      },
      area: {
        default: {
          fill: styleSheet.areaFillColor,
          fillOpacity: styleSheet.areaFillOpacity,
          stroke: null
        },
        active: {
          fillOpacity: styleSheet.areaActiveFillOpacity
        },
        selected: {
          fillOpacity: styleSheet.areaSelectedFillOpacity
        },
        inactive: {
          fillOpacity: styleSheet.areaInactiveFillOpacity
        }
      },
      hollowArea: {
        default: {
          fill: null,
          stroke: styleSheet.hollowAreaBorderColor,
          lineWidth: styleSheet.hollowAreaBorder,
          strokeOpacity: styleSheet.hollowAreaBorderOpacity
        },
        active: {
          fill: null,
          lineWidth: styleSheet.hollowAreaActiveBorder
        },
        selected: {
          fill: null,
          lineWidth: styleSheet.hollowAreaSelectedBorder
        },
        inactive: {
          strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
        }
      },
      interval: {
        default: {
          fill: styleSheet.intervalFillColor,
          fillOpacity: styleSheet.intervalFillOpacity
        },
        active: {
          stroke: styleSheet.intervalActiveBorderColor,
          lineWidth: styleSheet.intervalActiveBorder
        },
        selected: {
          stroke: styleSheet.intervalSelectedBorderColor,
          lineWidth: styleSheet.intervalSelectedBorder
        },
        inactive: {
          fillOpacity: styleSheet.intervalInactiveFillOpacity,
          strokeOpacity: styleSheet.intervalInactiveBorderOpacity
        }
      },
      hollowInterval: {
        default: {
          fill: styleSheet.hollowIntervalFillColor,
          stroke: styleSheet.hollowIntervalBorderColor,
          lineWidth: styleSheet.hollowIntervalBorder,
          strokeOpacity: styleSheet.hollowIntervalBorderOpacity
        },
        active: {
          stroke: styleSheet.hollowIntervalActiveBorderColor,
          lineWidth: styleSheet.hollowIntervalActiveBorder,
          strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
        },
        selected: {
          stroke: styleSheet.hollowIntervalSelectedBorderColor,
          lineWidth: styleSheet.hollowIntervalSelectedBorder,
          strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
        },
        inactive: {
          stroke: styleSheet.hollowIntervalInactiveBorderColor,
          lineWidth: styleSheet.hollowIntervalInactiveBorder,
          strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
        }
      },
      line: {
        default: {
          stroke: styleSheet.lineBorderColor,
          lineWidth: styleSheet.lineBorder,
          strokeOpacity: styleSheet.lineBorderOpacity,
          fill: null,
          lineAppendWidth: 10,
          lineCap: "round",
          lineJoin: "round"
        },
        active: {
          lineWidth: styleSheet.lineActiveBorder
        },
        selected: {
          lineWidth: styleSheet.lineSelectedBorder
        },
        inactive: {
          strokeOpacity: styleSheet.lineInactiveBorderOpacity
        }
      }
    };
    var axisStyles = createAxisStyles(styleSheet);
    var legendStyles = createLegendStyles(styleSheet);
    return {
      background: styleSheet.backgroundColor,
      defaultColor: styleSheet.brandColor,
      subColor: styleSheet.subColor,
      semanticRed: styleSheet.paletteSemanticRed,
      semanticGreen: styleSheet.paletteSemanticGreen,
      padding: "auto",
      fontFamily: styleSheet.fontFamily,
      columnWidthRatio: 1 / 2,
      maxColumnWidth: null,
      minColumnWidth: null,
      roseWidthRatio: 0.9999999,
      multiplePieWidthRatio: 1 / 1.3,
      colors10: styleSheet.paletteQualitative10,
      colors20: styleSheet.paletteQualitative20,
      sequenceColors: styleSheet.paletteSequence,
      shapes: {
        point: [
          "hollow-circle",
          "hollow-square",
          "hollow-bowtie",
          "hollow-diamond",
          "hollow-hexagon",
          "hollow-triangle",
          "hollow-triangle-down",
          "circle",
          "square",
          "bowtie",
          "diamond",
          "hexagon",
          "triangle",
          "triangle-down",
          "cross",
          "tick",
          "plus",
          "hyphen",
          "line"
        ],
        line: ["line", "dash", "dot", "smooth"],
        area: ["area", "smooth", "line", "smooth-line"],
        interval: ["rect", "hollow-rect", "line", "tick"]
      },
      sizes: [1, 10],
      geometries: {
        interval: {
          rect: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: function(element) {
                var coordinate = element.geometry.coordinate;
                if (coordinate.isPolar && coordinate.isTransposed) {
                  var _a5 = getAngle2(element.getModel(), coordinate), startAngle = _a5.startAngle, endAngle = _a5.endAngle;
                  var middleAngle = (startAngle + endAngle) / 2;
                  var r = 7.5;
                  var x = r * Math.cos(middleAngle);
                  var y = r * Math.sin(middleAngle);
                  return {
                    matrix: ext_exports.transform(null, [["t", x, y]])
                  };
                }
                return shapeStyles.interval.selected;
              }
            }
          },
          "hollow-rect": {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          line: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          tick: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          funnel: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: shapeStyles.interval.selected
            }
          },
          pyramid: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: shapeStyles.interval.selected
            }
          }
        },
        line: {
          line: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          dot: {
            default: {
              style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
            },
            active: {
              style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
            },
            inactive: {
              style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
            },
            selected: {
              style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
            }
          },
          dash: {
            default: {
              style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
            },
            active: {
              style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
            },
            inactive: {
              style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
            },
            selected: {
              style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
            }
          },
          smooth: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          hv: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          vh: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          hvh: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          vhv: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          }
        },
        polygon: {
          polygon: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: shapeStyles.interval.selected
            }
          }
        },
        point: {
          circle: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          square: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          bowtie: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          diamond: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          hexagon: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          triangle: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          "triangle-down": {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          "hollow-circle": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-square": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-bowtie": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-diamond": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-hexagon": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-triangle": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-triangle-down": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          cross: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          tick: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          plus: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          hyphen: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          line: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          }
        },
        area: {
          area: {
            default: {
              style: shapeStyles.area.default
            },
            active: {
              style: shapeStyles.area.active
            },
            inactive: {
              style: shapeStyles.area.inactive
            },
            selected: {
              style: shapeStyles.area.selected
            }
          },
          smooth: {
            default: {
              style: shapeStyles.area.default
            },
            active: {
              style: shapeStyles.area.active
            },
            inactive: {
              style: shapeStyles.area.inactive
            },
            selected: {
              style: shapeStyles.area.selected
            }
          },
          line: {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          },
          "smooth-line": {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          }
        },
        schema: {
          candle: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          box: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          }
        },
        edge: {
          line: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          vhv: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          smooth: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          arc: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          }
        },
        violin: {
          violin: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          smooth: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          hollow: {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          },
          "hollow-smooth": {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          }
        }
      },
      components: {
        axis: {
          common: axisStyles,
          top: {
            position: "top",
            grid: null,
            title: null,
            verticalLimitLength: 1 / 2
          },
          bottom: {
            position: "bottom",
            grid: null,
            title: null,
            verticalLimitLength: 1 / 2
          },
          left: {
            position: "left",
            title: null,
            line: null,
            tickLine: null,
            verticalLimitLength: 1 / 3
          },
          right: {
            position: "right",
            title: null,
            line: null,
            tickLine: null,
            verticalLimitLength: 1 / 3
          },
          circle: {
            title: null,
            grid: deep_mix_default({}, axisStyles.grid, { line: { type: "line" } })
          },
          radius: {
            title: null,
            grid: deep_mix_default({}, axisStyles.grid, { line: { type: "circle" } })
          }
        },
        legend: {
          common: legendStyles,
          right: {
            layout: "vertical",
            padding: styleSheet.legendVerticalPadding
          },
          left: {
            layout: "vertical",
            padding: styleSheet.legendVerticalPadding
          },
          top: {
            layout: "horizontal",
            padding: styleSheet.legendHorizontalPadding
          },
          bottom: {
            layout: "horizontal",
            padding: styleSheet.legendHorizontalPadding
          },
          continuous: {
            title: null,
            background: null,
            track: {},
            rail: {
              type: "color",
              size: styleSheet.sliderRailHeight,
              defaultLength: styleSheet.sliderRailWidth,
              style: {
                fill: styleSheet.sliderRailFillColor,
                stroke: styleSheet.sliderRailBorderColor,
                lineWidth: styleSheet.sliderRailBorder
              }
            },
            label: {
              align: "rail",
              spacing: 4,
              formatter: null,
              style: {
                fill: styleSheet.sliderLabelTextFillColor,
                fontSize: styleSheet.sliderLabelTextFontSize,
                lineHeight: styleSheet.sliderLabelTextLineHeight,
                textBaseline: "middle",
                fontFamily: styleSheet.fontFamily
              }
            },
            handler: {
              size: styleSheet.sliderHandlerWidth,
              style: {
                fill: styleSheet.sliderHandlerFillColor,
                stroke: styleSheet.sliderHandlerBorderColor
              }
            },
            slidable: true,
            padding: legendStyles.padding
          }
        },
        tooltip: {
          showContent: true,
          follow: true,
          showCrosshairs: false,
          showMarkers: true,
          shared: false,
          enterable: false,
          position: "auto",
          marker: {
            symbol: "circle",
            stroke: "#fff",
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowColor: "rgba(0,0,0,0.09)",
            lineWidth: 2,
            r: 4
          },
          crosshairs: {
            line: {
              style: {
                stroke: styleSheet.tooltipCrosshairsBorderColor,
                lineWidth: styleSheet.tooltipCrosshairsBorder
              }
            },
            text: null,
            textBackground: {
              padding: 2,
              style: {
                fill: "rgba(0, 0, 0, 0.25)",
                lineWidth: 0,
                stroke: null
              }
            },
            follow: false
          },
          domStyles: (_a4 = {}, _a4["" + css_const_exports.CONTAINER_CLASS] = {
            position: "absolute",
            visibility: "hidden",
            zIndex: 8,
            transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
            backgroundColor: styleSheet.tooltipContainerFillColor,
            opacity: styleSheet.tooltipContainerFillOpacity,
            boxShadow: styleSheet.tooltipContainerShadow,
            borderRadius: styleSheet.tooltipContainerBorderRadius + "px",
            color: styleSheet.tooltipTextFillColor,
            fontSize: styleSheet.tooltipTextFontSize + "px",
            fontFamily: styleSheet.fontFamily,
            lineHeight: styleSheet.tooltipTextLineHeight + "px",
            padding: "0 12px 0 12px"
          }, _a4["" + css_const_exports.TITLE_CLASS] = {
            marginBottom: "12px",
            marginTop: "12px"
          }, _a4["" + css_const_exports.LIST_CLASS] = {
            margin: 0,
            listStyleType: "none",
            padding: 0
          }, _a4["" + css_const_exports.LIST_ITEM_CLASS] = {
            listStyleType: "none",
            padding: 0,
            marginBottom: "12px",
            marginTop: "12px",
            marginLeft: 0,
            marginRight: 0
          }, _a4["" + css_const_exports.MARKER_CLASS] = {
            width: "8px",
            height: "8px",
            borderRadius: "50%",
            display: "inline-block",
            marginRight: "8px"
          }, _a4["" + css_const_exports.VALUE_CLASS] = {
            display: "inline-block",
            float: "right",
            marginLeft: "30px"
          }, _a4)
        },
        annotation: {
          arc: {
            style: {
              stroke: styleSheet.annotationArcBorderColor,
              lineWidth: styleSheet.annotationArcBorder
            },
            animate: true
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineDash: styleSheet.annotationLineDash,
              lineWidth: styleSheet.annotationLineBorder
            },
            text: {
              position: "start",
              autoRotate: true,
              style: {
                fill: styleSheet.annotationTextFillColor,
                stroke: styleSheet.annotationTextBorderColor,
                lineWidth: styleSheet.annotationTextBorder,
                fontSize: styleSheet.annotationTextFontSize,
                textAlign: "start",
                fontFamily: styleSheet.fontFamily,
                textBaseline: "bottom"
              }
            },
            animate: true
          },
          text: {
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textBaseline: "middle",
              textAlign: "start",
              fontFamily: styleSheet.fontFamily
            },
            animate: true
          },
          region: {
            top: false,
            style: {
              lineWidth: styleSheet.annotationRegionBorder,
              stroke: styleSheet.annotationRegionBorderColor,
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            animate: true
          },
          image: {
            top: false,
            animate: true
          },
          dataMarker: {
            top: true,
            point: {
              style: {
                r: 3,
                stroke: styleSheet.brandColor,
                lineWidth: 2
              }
            },
            line: {
              style: {
                stroke: styleSheet.annotationLineBorderColor,
                lineWidth: styleSheet.annotationLineBorder
              },
              length: styleSheet.annotationDataMarkerLineLength
            },
            text: {
              style: {
                textAlign: "start",
                fill: styleSheet.annotationTextFillColor,
                stroke: styleSheet.annotationTextBorderColor,
                lineWidth: styleSheet.annotationTextBorder,
                fontSize: styleSheet.annotationTextFontSize,
                fontFamily: styleSheet.fontFamily
              }
            },
            direction: "upward",
            autoAdjust: true,
            animate: true
          },
          dataRegion: {
            style: {
              region: {
                fill: styleSheet.annotationRegionFillColor,
                fillOpacity: styleSheet.annotationRegionFillOpacity
              },
              text: {
                textAlign: "center",
                textBaseline: "bottom",
                fill: styleSheet.annotationTextFillColor,
                stroke: styleSheet.annotationTextBorderColor,
                lineWidth: styleSheet.annotationTextBorder,
                fontSize: styleSheet.annotationTextFontSize,
                fontFamily: styleSheet.fontFamily
              }
            },
            animate: true
          }
        },
        slider: {
          common: {
            padding: [8, 8, 8, 8],
            backgroundStyle: {
              fill: styleSheet.cSliderBackgroundFillColor,
              opacity: styleSheet.cSliderBackgroundFillOpacity
            },
            foregroundStyle: {
              fill: styleSheet.cSliderForegroundFillColor,
              opacity: styleSheet.cSliderForegroundFillOpacity
            },
            handlerStyle: {
              width: styleSheet.cSliderHandlerWidth,
              height: styleSheet.cSliderHandlerHeight,
              fill: styleSheet.cSliderHandlerFillColor,
              opacity: styleSheet.cSliderHandlerFillOpacity,
              stroke: styleSheet.cSliderHandlerBorderColor,
              lineWidth: styleSheet.cSliderHandlerBorder,
              radius: styleSheet.cSliderHandlerBorderRadius,
              highLightFill: styleSheet.cSliderHandlerHighlightFillColor
            },
            textStyle: {
              fill: styleSheet.cSliderTextFillColor,
              opacity: styleSheet.cSliderTextFillOpacity,
              fontSize: styleSheet.cSliderTextFontSize,
              lineHeight: styleSheet.cSliderTextLineHeight,
              fontWeight: styleSheet.cSliderTextFontWeight,
              stroke: styleSheet.cSliderTextBorderColor,
              lineWidth: styleSheet.cSliderTextBorder
            }
          }
        },
        scrollbar: {
          common: {
            padding: [8, 8, 8, 8]
          },
          default: {
            style: {
              trackColor: styleSheet.scrollbarTrackFillColor,
              thumbColor: styleSheet.scrollbarThumbFillColor
            }
          },
          hover: {
            style: {
              thumbColor: styleSheet.scrollbarThumbHighlightFillColor
            }
          }
        }
      },
      labels: {
        offset: 12,
        style: {
          fill: styleSheet.labelFillColor,
          fontSize: styleSheet.labelFontSize,
          fontFamily: styleSheet.fontFamily,
          stroke: styleSheet.labelBorderColor,
          lineWidth: styleSheet.labelBorder
        },
        fillColorDark: styleSheet.labelFillColorDark,
        fillColorLight: styleSheet.labelFillColorLight,
        autoRotate: true
      },
      innerLabels: {
        style: {
          fill: styleSheet.innerLabelFillColor,
          fontSize: styleSheet.innerLabelFontSize,
          fontFamily: styleSheet.fontFamily,
          stroke: styleSheet.innerLabelBorderColor,
          lineWidth: styleSheet.innerLabelBorder
        },
        autoRotate: true
      },
      overflowLabels: {
        style: {
          fill: styleSheet.overflowLabelFillColor,
          fontSize: styleSheet.overflowLabelFontSize,
          fontFamily: styleSheet.fontFamily,
          stroke: styleSheet.overflowLabelBorderColor,
          lineWidth: styleSheet.overflowLabelBorder
        }
      },
      pieLabels: {
        labelHeight: 14,
        offset: 10,
        labelLine: {
          style: {
            lineWidth: styleSheet.labelLineBorder
          }
        },
        autoRotate: true
      }
    };
  }

  // node_modules/@antv/g2/esm/theme/style-sheet/light.js
  var BLACK_COLORS = {
    100: "#000",
    95: "#0D0D0D",
    85: "#262626",
    65: "#595959",
    45: "#8C8C8C",
    25: "#BFBFBF",
    15: "#D9D9D9",
    6: "#F0F0F0"
  };
  var WHITE_COLORS = {
    100: "#FFFFFF",
    95: "#F2F2F2",
    85: "#D9D9D9",
    65: "#A6A6A6",
    45: "#737373",
    25: "#404040",
    15: "#262626",
    6: "#0F0F0F"
  };
  var QUALITATIVE_10 = [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
  var QUALITATIVE_20 = [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
  var SINGLE_SEQUENCE = [
    "#B8E1FF",
    "#9AC5FF",
    "#7DAAFF",
    "#5B8FF9",
    "#3D76DD",
    "#085EC0",
    "#0047A5",
    "#00318A",
    "#001D70"
  ];
  var createLightStyleSheet = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var _a4 = cfg.backgroundColor, backgroundColor = _a4 === void 0 ? "transparent" : _a4, _b = cfg.subColor, subColor = _b === void 0 ? "rgba(0,0,0,0.05)" : _b, _c = cfg.paletteQualitative10, paletteQualitative10 = _c === void 0 ? QUALITATIVE_10 : _c, _d = cfg.paletteQualitative20, paletteQualitative20 = _d === void 0 ? QUALITATIVE_20 : _d, _e = cfg.paletteSemanticRed, paletteSemanticRed = _e === void 0 ? "#F4664A" : _e, _f = cfg.paletteSemanticGreen, paletteSemanticGreen = _f === void 0 ? "#30BF78" : _f, _g = cfg.paletteSemanticYellow, paletteSemanticYellow = _g === void 0 ? "#FAAD14" : _g, _h = cfg.paletteSequence, paletteSequence = _h === void 0 ? SINGLE_SEQUENCE : _h, _j = cfg.fontFamily, fontFamily = _j === void 0 ? '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : _j;
    var _k = cfg.brandColor, brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
    return {
      backgroundColor,
      brandColor,
      subColor,
      paletteQualitative10,
      paletteQualitative20,
      paletteSemanticRed,
      paletteSemanticGreen,
      paletteSemanticYellow,
      paletteSequence,
      fontFamily,
      axisLineBorderColor: BLACK_COLORS[25],
      axisLineBorder: 1,
      axisLineDash: null,
      axisTitleTextFillColor: BLACK_COLORS[65],
      axisTitleTextFontSize: 12,
      axisTitleTextLineHeight: 12,
      axisTitleTextFontWeight: "normal",
      axisTitleSpacing: 12,
      axisTickLineBorderColor: BLACK_COLORS[25],
      axisTickLineLength: 4,
      axisTickLineBorder: 1,
      axisSubTickLineBorderColor: BLACK_COLORS[15],
      axisSubTickLineLength: 2,
      axisSubTickLineBorder: 1,
      axisLabelFillColor: BLACK_COLORS[45],
      axisLabelFontSize: 12,
      axisLabelLineHeight: 12,
      axisLabelFontWeight: "normal",
      axisLabelOffset: 8,
      axisGridBorderColor: BLACK_COLORS[15],
      axisGridBorder: 1,
      axisGridLineDash: null,
      legendTitleTextFillColor: BLACK_COLORS[45],
      legendTitleTextFontSize: 12,
      legendTitleTextLineHeight: 21,
      legendTitleTextFontWeight: "normal",
      legendMarkerColor: brandColor,
      legendMarkerSpacing: 8,
      legendMarkerSize: 4,
      legendCircleMarkerSize: 4,
      legendSquareMarkerSize: 4,
      legendLineMarkerSize: 5,
      legendItemNameFillColor: BLACK_COLORS[65],
      legendItemNameFontSize: 12,
      legendItemNameLineHeight: 12,
      legendItemNameFontWeight: "normal",
      legendItemSpacing: 24,
      legendItemMarginBottom: 12,
      legendPadding: [8, 8, 8, 8],
      legendHorizontalPadding: [8, 0, 8, 0],
      legendVerticalPadding: [0, 8, 0, 8],
      legendPageNavigatorMarkerSize: 12,
      legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[100],
      legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
      legendPageNavigatorMarkerFillColor: BLACK_COLORS[100],
      legendPageNavigatorMarkerFillOpacity: 1,
      legendPageNavigatorTextFillColor: BLACK_COLORS[45],
      legendPageNavigatorTextFontSize: 12,
      sliderRailFillColor: BLACK_COLORS[15],
      sliderRailBorder: 0,
      sliderRailBorderColor: null,
      sliderRailWidth: 100,
      sliderRailHeight: 12,
      sliderLabelTextFillColor: BLACK_COLORS[45],
      sliderLabelTextFontSize: 12,
      sliderLabelTextLineHeight: 12,
      sliderLabelTextFontWeight: "normal",
      sliderHandlerFillColor: BLACK_COLORS[6],
      sliderHandlerWidth: 10,
      sliderHandlerHeight: 14,
      sliderHandlerBorder: 1,
      sliderHandlerBorderColor: BLACK_COLORS[25],
      annotationArcBorderColor: BLACK_COLORS[15],
      annotationArcBorder: 1,
      annotationLineBorderColor: BLACK_COLORS[25],
      annotationLineBorder: 1,
      annotationLineDash: null,
      annotationTextFillColor: BLACK_COLORS[65],
      annotationTextFontSize: 12,
      annotationTextLineHeight: 12,
      annotationTextFontWeight: "normal",
      annotationTextBorderColor: null,
      annotationTextBorder: 0,
      annotationRegionFillColor: BLACK_COLORS[100],
      annotationRegionFillOpacity: 0.06,
      annotationRegionBorder: 0,
      annotationRegionBorderColor: null,
      annotationDataMarkerLineLength: 16,
      tooltipCrosshairsBorderColor: BLACK_COLORS[25],
      tooltipCrosshairsBorder: 1,
      tooltipCrosshairsLineDash: null,
      tooltipContainerFillColor: "rgb(255, 255, 255)",
      tooltipContainerFillOpacity: 0.95,
      tooltipContainerShadow: "0px 0px 10px #aeaeae",
      tooltipContainerBorderRadius: 3,
      tooltipTextFillColor: BLACK_COLORS[65],
      tooltipTextFontSize: 12,
      tooltipTextLineHeight: 12,
      tooltipTextFontWeight: "bold",
      labelFillColor: BLACK_COLORS[65],
      labelFillColorDark: "#2c3542",
      labelFillColorLight: "#ffffff",
      labelFontSize: 12,
      labelLineHeight: 12,
      labelFontWeight: "normal",
      labelBorderColor: null,
      labelBorder: 0,
      innerLabelFillColor: WHITE_COLORS[100],
      innerLabelFontSize: 12,
      innerLabelLineHeight: 12,
      innerLabelFontWeight: "normal",
      innerLabelBorderColor: null,
      innerLabelBorder: 0,
      overflowLabelFillColor: BLACK_COLORS[65],
      overflowLabelFontSize: 12,
      overflowLabelLineHeight: 12,
      overflowLabelFontWeight: "normal",
      overflowLabelBorderColor: WHITE_COLORS[100],
      overflowLabelBorder: 1,
      labelLineBorder: 1,
      labelLineBorderColor: BLACK_COLORS[25],
      cSliderRailHieght: 16,
      cSliderBackgroundFillColor: "#416180",
      cSliderBackgroundFillOpacity: 0.05,
      cSliderForegroundFillColor: "#5B8FF9",
      cSliderForegroundFillOpacity: 0.15,
      cSliderHandlerHeight: 24,
      cSliderHandlerWidth: 10,
      cSliderHandlerFillColor: "#F7F7F7",
      cSliderHandlerFillOpacity: 1,
      cSliderHandlerHighlightFillColor: "#FFF",
      cSliderHandlerBorderColor: "#BFBFBF",
      cSliderHandlerBorder: 1,
      cSliderHandlerBorderRadius: 2,
      cSliderTextFillColor: "#000",
      cSliderTextFillOpacity: 0.45,
      cSliderTextFontSize: 12,
      cSliderTextLineHeight: 12,
      cSliderTextFontWeight: "normal",
      cSliderTextBorderColor: null,
      cSliderTextBorder: 0,
      scrollbarTrackFillColor: "rgba(0,0,0,0)",
      scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
      scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
      pointFillColor: brandColor,
      pointFillOpacity: 0.95,
      pointSize: 4,
      pointBorder: 1,
      pointBorderColor: WHITE_COLORS[100],
      pointBorderOpacity: 1,
      pointActiveBorderColor: BLACK_COLORS[100],
      pointSelectedBorder: 2,
      pointSelectedBorderColor: BLACK_COLORS[100],
      pointInactiveFillOpacity: 0.3,
      pointInactiveBorderOpacity: 0.3,
      hollowPointSize: 4,
      hollowPointBorder: 1,
      hollowPointBorderColor: brandColor,
      hollowPointBorderOpacity: 0.95,
      hollowPointFillColor: WHITE_COLORS[100],
      hollowPointActiveBorder: 1,
      hollowPointActiveBorderColor: BLACK_COLORS[100],
      hollowPointActiveBorderOpacity: 1,
      hollowPointSelectedBorder: 2,
      hollowPointSelectedBorderColor: BLACK_COLORS[100],
      hollowPointSelectedBorderOpacity: 1,
      hollowPointInactiveBorderOpacity: 0.3,
      lineBorder: 2,
      lineBorderColor: brandColor,
      lineBorderOpacity: 1,
      lineActiveBorder: 3,
      lineSelectedBorder: 3,
      lineInactiveBorderOpacity: 0.3,
      areaFillColor: brandColor,
      areaFillOpacity: 0.25,
      areaActiveFillColor: brandColor,
      areaActiveFillOpacity: 0.5,
      areaSelectedFillColor: brandColor,
      areaSelectedFillOpacity: 0.5,
      areaInactiveFillOpacity: 0.3,
      hollowAreaBorderColor: brandColor,
      hollowAreaBorder: 2,
      hollowAreaBorderOpacity: 1,
      hollowAreaActiveBorder: 3,
      hollowAreaActiveBorderColor: BLACK_COLORS[100],
      hollowAreaSelectedBorder: 3,
      hollowAreaSelectedBorderColor: BLACK_COLORS[100],
      hollowAreaInactiveBorderOpacity: 0.3,
      intervalFillColor: brandColor,
      intervalFillOpacity: 0.95,
      intervalActiveBorder: 1,
      intervalActiveBorderColor: BLACK_COLORS[100],
      intervalActiveBorderOpacity: 1,
      intervalSelectedBorder: 2,
      intervalSelectedBorderColor: BLACK_COLORS[100],
      intervalSelectedBorderOpacity: 1,
      intervalInactiveBorderOpacity: 0.3,
      intervalInactiveFillOpacity: 0.3,
      hollowIntervalBorder: 2,
      hollowIntervalBorderColor: brandColor,
      hollowIntervalBorderOpacity: 1,
      hollowIntervalFillColor: WHITE_COLORS[100],
      hollowIntervalActiveBorder: 2,
      hollowIntervalActiveBorderColor: BLACK_COLORS[100],
      hollowIntervalSelectedBorder: 3,
      hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
      hollowIntervalSelectedBorderOpacity: 1,
      hollowIntervalInactiveBorderOpacity: 0.3
    };
  };
  var antvLight = createLightStyleSheet();

  // node_modules/@antv/g2/esm/theme/util/create-theme.js
  function createTheme(themeCfg) {
    var _a4 = themeCfg.styleSheet, styleSheetCfg = _a4 === void 0 ? {} : _a4, themeObject = __rest(themeCfg, ["styleSheet"]);
    var styleSheet = createLightStyleSheet(styleSheetCfg);
    return deep_mix_default({}, createThemeByStyleSheet(styleSheet), themeObject);
  }

  // node_modules/@antv/g2/esm/theme/index.js
  var defaultTheme = createTheme({});
  var Themes = {
    default: defaultTheme
  };
  function getTheme(theme) {
    return get_default(Themes, lower_case_default(theme), Themes.default);
  }
  function registerTheme(theme, value) {
    Themes[lower_case_default(theme)] = createTheme(value);
  }

  // node_modules/@antv/g2/esm/util/tooltip.js
  function snapEqual(v1, v2, scale4) {
    var value1 = scale4.translate(v1);
    var value2 = scale4.translate(v2);
    return isNumberEqual(value1, value2);
  }
  function getXValueByPoint(point, geometry) {
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var range = xScale.range;
    var rangeMax = range[range.length - 1];
    var rangeMin = range[0];
    var invertPoint = coordinate.invert(point);
    var xValue = invertPoint.x;
    if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {
      xValue = rangeMin;
    }
    return xScale.translate(xScale.invert(xValue));
  }
  function filterYValue(data, point, geometry) {
    var coordinate = geometry.coordinate;
    var yScale = geometry.getYScale();
    var yField = yScale.field;
    var invertPoint = coordinate.invert(point);
    var yValue = yScale.invert(invertPoint.y);
    var result = find_default(data, function(obj) {
      var originData = obj[FIELD_ORIGIN];
      return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
    });
    return result || data[data.length - 1];
  }
  var getXDistance = memoize_default(function(scale4) {
    if (scale4.isCategory) {
      return 1;
    }
    var scaleValues = scale4.values;
    var length3 = scaleValues.length;
    var min3 = scale4.translate(scaleValues[0]);
    var max3 = min3;
    for (var index = 0; index < length3; index++) {
      var value = scaleValues[index];
      var numericValue = scale4.translate(value);
      if (numericValue < min3) {
        min3 = numericValue;
      }
      if (numericValue > max3) {
        max3 = numericValue;
      }
    }
    return (max3 - min3) / (length3 - 1);
  });
  function getTooltipTitle(originData, geometry, title) {
    var positionAttr = geometry.getAttribute("position");
    var fields = positionAttr.getFields();
    var scales = geometry.scales;
    var titleField = is_function_default(title) || !title ? fields[0] : title;
    var titleScale = scales[titleField];
    var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
    return is_function_default(title) ? title(tooltipTitle, originData) : tooltipTitle;
  }
  function getAttributesForLegend(geometry) {
    var attributes = values_default(geometry.attributes);
    return filter_default(attributes, function(attribute) {
      return contains_default(GROUP_ATTRS, attribute.type);
    });
  }
  function getTooltipValueScale(geometry) {
    var attributes = getAttributesForLegend(geometry);
    var scale4;
    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
      var attribute = attributes_1[_i];
      var tmpScale = attribute.getScale(attribute.type);
      if (tmpScale && tmpScale.isLinear) {
        scale4 = tmpScale;
        break;
      }
    }
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    return scale4 || yScale || xScale;
  }
  function getTooltipValue(originData, valueScale) {
    var field = valueScale.field;
    var value = originData[field];
    if (is_array_default(value)) {
      var texts = value.map(function(eachValue) {
        return valueScale.getText(eachValue);
      });
      return texts.join("-");
    }
    return valueScale.getText(value);
  }
  function getTooltipName(originData, geometry) {
    var nameScale;
    var groupScales = geometry.getGroupScales();
    if (groupScales.length) {
      nameScale = groupScales[0];
    }
    if (nameScale) {
      var field = nameScale.field;
      return nameScale.getText(originData[field]);
    }
    var valueScale = getTooltipValueScale(geometry);
    return getName(valueScale);
  }
  function findDataByPoint(point, data, geometry) {
    if (data.length === 0) {
      return null;
    }
    var geometryType = geometry.type;
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    var xField = xScale.field;
    var yField = yScale.field;
    var rst = null;
    if (geometryType === "heatmap" || geometryType === "point") {
      var coordinate = geometry.coordinate;
      var invertPoint = coordinate.invert(point);
      var x = xScale.invert(invertPoint.x);
      var y = yScale.invert(invertPoint.y);
      var min3 = Infinity;
      for (var index = 0; index < data.length; index++) {
        var obj = data[index];
        var originData = obj[FIELD_ORIGIN];
        var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
        if (range < min3) {
          min3 = range;
          rst = obj;
        }
      }
      return rst;
    }
    var first = data[0];
    var last2 = data[data.length - 1];
    var xValue = getXValueByPoint(point, geometry);
    var firstXValue = first[FIELD_ORIGIN][xField];
    var firstYValue = first[FIELD_ORIGIN][yField];
    var lastXValue = last2[FIELD_ORIGIN][xField];
    var isYArray = yScale.isLinear && is_array_default(firstYValue);
    if (is_array_default(firstXValue)) {
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var originData = record[FIELD_ORIGIN];
        if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
          if (isYArray) {
            if (!is_array_default(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        }
      }
      if (is_array_default(rst)) {
        rst = filterYValue(rst, point, geometry);
      }
    } else {
      var next = void 0;
      if (!xScale.isLinear && xScale.type !== "timeCat") {
        for (var index = 0; index < data.length; index++) {
          var record = data[index];
          var originData = record[FIELD_ORIGIN];
          if (snapEqual(originData[xField], xValue, xScale)) {
            if (isYArray) {
              if (!is_array_default(rst)) {
                rst = [];
              }
              rst.push(record);
            } else {
              rst = record;
              break;
            }
          } else if (xScale.translate(originData[xField]) <= xValue) {
            last2 = record;
            next = data[index + 1];
          }
        }
        if (is_array_default(rst)) {
          rst = filterYValue(rst, point, geometry);
        }
      } else {
        if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
          return null;
        }
        var firstIdx = 0;
        var lastIdx = data.length - 1;
        var middleIdx = void 0;
        while (firstIdx <= lastIdx) {
          middleIdx = Math.floor((firstIdx + lastIdx) / 2);
          var item = data[middleIdx][FIELD_ORIGIN][xField];
          if (snapEqual(item, xValue, xScale)) {
            return data[middleIdx];
          }
          if (xScale.translate(item) <= xScale.translate(xValue)) {
            firstIdx = middleIdx + 1;
            last2 = data[middleIdx];
            next = data[middleIdx + 1];
          } else {
            if (lastIdx === 0) {
              last2 = data[0];
            }
            lastIdx = middleIdx - 1;
          }
        }
      }
      if (last2 && next) {
        if (Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
          last2 = next;
        }
      }
    }
    var distance8 = getXDistance(geometry.getXScale());
    if (!rst && Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) <= distance8 / 2) {
      rst = last2;
    }
    return rst;
  }
  function getTooltipItems(data, geometry, title, showNil) {
    if (title === void 0) {
      title = "";
    }
    if (showNil === void 0) {
      showNil = false;
    }
    var originData = data[FIELD_ORIGIN];
    var tooltipTitle = getTooltipTitle(originData, geometry, title);
    var tooltipOption = geometry.tooltipOption;
    var defaultColor = geometry.theme.defaultColor;
    var items = [];
    var name;
    var value;
    function addItem(itemName, itemValue) {
      if (showNil || !is_nil_default(itemValue) && itemValue !== "") {
        var item = {
          title: tooltipTitle,
          data: originData,
          mappingData: data,
          name: itemName,
          value: itemValue,
          color: data.color || defaultColor,
          marker: true
        };
        items.push(item);
      }
    }
    if (is_object_default(tooltipOption)) {
      var fields = tooltipOption.fields, callback = tooltipOption.callback;
      if (callback) {
        var callbackParams = fields.map(function(field2) {
          return data[FIELD_ORIGIN][field2];
        });
        var cfg = callback.apply(void 0, callbackParams);
        var itemCfg = __assign({ data: data[FIELD_ORIGIN], mappingData: data, title: tooltipTitle, color: data.color || defaultColor, marker: true }, cfg);
        items.push(itemCfg);
      } else {
        var scales = geometry.scales;
        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
          var field = fields_1[_i];
          if (!is_nil_default(originData[field])) {
            var scale4 = scales[field];
            name = getName(scale4);
            value = scale4.getText(originData[field]);
            addItem(name, value);
          }
        }
      }
    } else {
      var valueScale = getTooltipValueScale(geometry);
      value = getTooltipValue(originData, valueScale);
      name = getTooltipName(originData, geometry);
      addItem(name, value);
    }
    return items;
  }
  function getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {
    var showNil = tooltipCfg.showNil;
    var result = [];
    var dataArray = geometry.dataArray;
    if (!is_empty_default(dataArray)) {
      geometry.sort(dataArray);
      for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {
        var data = dataArray_1[_i];
        var record = findDataByPoint(point, data, geometry);
        if (record) {
          var elementId = geometry.getElementId(record);
          var element = geometry.elementsMap[elementId];
          if (geometry.type === "heatmap" || element.visible) {
            var items = getTooltipItems(record, geometry, title, showNil);
            if (items.length) {
              result.push(items);
            }
          }
        }
      }
    }
    return result;
  }
  function getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {
    var showNil = tooltipCfg.showNil;
    var result = [];
    var container = geometry.container;
    var shape = container.getShape(point.x, point.y);
    if (shape && shape.get("visible") && shape.get("origin")) {
      var mappingData = shape.get("origin").mappingData;
      var items = getTooltipItems(mappingData, geometry, title, showNil);
      if (items.length) {
        result.push(items);
      }
    }
    return result;
  }
  function findItemsFromView(view, point, tooltipCfg) {
    var result = [];
    var geometries = view.geometries;
    var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
    for (var _i = 0, geometries_1 = geometries; _i < geometries_1.length; _i++) {
      var geometry = geometries_1[_i];
      if (geometry.visible && geometry.tooltipOption !== false) {
        var geometryType = geometry.type;
        var tooltipItems = void 0;
        if (["point", "edge", "polygon"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
        } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
        } else {
          if (shared !== false) {
            tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
          } else {
            tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
          }
        }
        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          }
          result.push(tooltipItems);
        }
      }
    }
    return result;
  }
  function findItemsFromViewRecurisive(view, point, tooltipCfg) {
    var result = findItemsFromView(view, point, tooltipCfg);
    for (var _i = 0, _a4 = view.views; _i < _a4.length; _i++) {
      var childView = _a4[_i];
      result = result.concat(findItemsFromView(childView, point, tooltipCfg));
    }
    return result;
  }

  // node_modules/@antv/g2/esm/util/padding.js
  function isAutoPadding(padding) {
    return !is_number_default(padding) && !is_array_default(padding);
  }
  function parsePadding(padding) {
    if (padding === void 0) {
      padding = 0;
    }
    var paddingArray = is_array_default(padding) ? padding : [padding];
    switch (paddingArray.length) {
      case 0:
        paddingArray = [0, 0, 0, 0];
        break;
      case 1:
        paddingArray = new Array(4).fill(paddingArray[0]);
        break;
      case 2:
        paddingArray = __spreadArray(__spreadArray([], paddingArray, true), paddingArray, true);
        break;
      case 3:
        paddingArray = __spreadArray(__spreadArray([], paddingArray, true), [paddingArray[1]], false);
        break;
      default:
        paddingArray = paddingArray.slice(0, 4);
        break;
    }
    return paddingArray;
  }

  // node_modules/@antv/g2/esm/chart/controller/index.js
  var LOAD_COMPONENT_CONTROLLERS = {};
  function registerComponentController(name, plugin) {
    LOAD_COMPONENT_CONTROLLERS[name] = plugin;
  }
  function getComponentControllerNames() {
    return Object.keys(LOAD_COMPONENT_CONTROLLERS);
  }
  function getComponentController(name) {
    return LOAD_COMPONENT_CONTROLLERS[name];
  }

  // node_modules/@antv/g2/esm/chart/controller/coordinate.js
  var CoordinateController = function() {
    function CoordinateController2(option) {
      this.option = this.wrapperOption(option);
    }
    CoordinateController2.prototype.update = function(option) {
      this.option = this.wrapperOption(option);
      return this;
    };
    CoordinateController2.prototype.hasAction = function(actionName) {
      var actions = this.option.actions;
      return some_default(actions, function(action) {
        return action[0] === actionName;
      });
    };
    CoordinateController2.prototype.create = function(start, end) {
      var _a4 = this.option, type = _a4.type, cfg = _a4.cfg;
      var isTheta = type === "theta";
      var props = __assign({ start, end }, cfg);
      var C = getCoordinate(isTheta ? "polar" : type);
      this.coordinate = new C(props);
      this.coordinate.type = type;
      if (isTheta) {
        if (!this.hasAction("transpose")) {
          this.transpose();
        }
      }
      this.execActions();
      return this.coordinate;
    };
    CoordinateController2.prototype.adjust = function(start, end) {
      this.coordinate.update({
        start,
        end
      });
      this.coordinate.resetMatrix();
      this.execActions(["scale", "rotate", "translate"]);
      return this.coordinate;
    };
    CoordinateController2.prototype.rotate = function(angle3) {
      this.option.actions.push(["rotate", angle3]);
      return this;
    };
    CoordinateController2.prototype.reflect = function(dim) {
      this.option.actions.push(["reflect", dim]);
      return this;
    };
    CoordinateController2.prototype.scale = function(sx, sy) {
      this.option.actions.push(["scale", sx, sy]);
      return this;
    };
    CoordinateController2.prototype.transpose = function() {
      this.option.actions.push(["transpose"]);
      return this;
    };
    CoordinateController2.prototype.getOption = function() {
      return this.option;
    };
    CoordinateController2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    CoordinateController2.prototype.wrapperOption = function(option) {
      return __assign({ type: "rect", actions: [], cfg: {} }, option);
    };
    CoordinateController2.prototype.execActions = function(includeActions) {
      var _this = this;
      var actions = this.option.actions;
      each_default(actions, function(action) {
        var _a4;
        var actionName = action[0], args = action.slice(1);
        var shouldExec = is_nil_default(includeActions) ? true : includeActions.includes(actionName);
        if (shouldExec) {
          (_a4 = _this.coordinate)[actionName].apply(_a4, args);
        }
      });
    };
    return CoordinateController2;
  }();
  var coordinate_default = CoordinateController;

  // node_modules/@antv/g2/esm/chart/event.js
  var Event = function() {
    function Event2(view, gEvent, data) {
      this.view = view;
      this.gEvent = gEvent;
      this.data = data;
      this.type = gEvent.type;
    }
    Event2.fromData = function(view, type, data) {
      return new Event2(view, new graph_event_default(type, {}), data);
    };
    Object.defineProperty(Event2.prototype, "target", {
      get: function() {
        return this.gEvent.target;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "event", {
      get: function() {
        return this.gEvent.originalEvent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "x", {
      get: function() {
        return this.gEvent.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "y", {
      get: function() {
        return this.gEvent.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientX", {
      get: function() {
        return this.gEvent.clientX;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientY", {
      get: function() {
        return this.gEvent.clientY;
      },
      enumerable: false,
      configurable: true
    });
    Event2.prototype.toString = function() {
      return "[Event (type=" + this.type + ")]";
    };
    Event2.prototype.clone = function() {
      return new Event2(this.view, this.gEvent, this.data);
    };
    return Event2;
  }();
  var event_default = Event;

  // node_modules/@antv/g2/esm/chart/layout/index.js
  function defaultLayout(view) {
    var axis = view.getController("axis");
    var legend = view.getController("legend");
    var annotation = view.getController("annotation");
    var slider = view.getController("slider");
    var scrollbar = view.getController("scrollbar");
    [axis, slider, scrollbar, legend, annotation].forEach(function(controller) {
      if (controller) {
        controller.layout();
      }
    });
  }

  // node_modules/@antv/g2/esm/chart/util/scale-pool.js
  var ScalePool = function() {
    function ScalePool2() {
      this.scales = new Map();
      this.syncScales = new Map();
    }
    ScalePool2.prototype.createScale = function(field, data, scaleDef, key) {
      var finalScaleDef = scaleDef;
      var cacheScaleMeta = this.getScaleMeta(key);
      if (data.length === 0 && cacheScaleMeta) {
        var cacheScale = cacheScaleMeta.scale;
        var cacheScaleDef = {
          type: cacheScale.type
        };
        if (cacheScale.isCategory) {
          cacheScaleDef.values = cacheScale.values;
        }
        finalScaleDef = deep_mix_default(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
      }
      var scale4 = createScaleByField(field, data, finalScaleDef);
      this.cacheScale(scale4, scaleDef, key);
      return scale4;
    };
    ScalePool2.prototype.sync = function(coordinate, theme) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var min3 = Number.MAX_SAFE_INTEGER;
        var max3 = Number.MIN_SAFE_INTEGER;
        var values2 = [];
        each_default(scaleKeys, function(key) {
          var scale4 = _this.getScale(key);
          max3 = is_number_default(scale4.max) ? Math.max(max3, scale4.max) : max3;
          min3 = is_number_default(scale4.min) ? Math.min(min3, scale4.min) : min3;
          each_default(scale4.values, function(v) {
            if (!values2.includes(v)) {
              values2.push(v);
            }
          });
        });
        each_default(scaleKeys, function(key) {
          var scale4 = _this.getScale(key);
          if (scale4.isContinuous) {
            scale4.change({
              min: min3,
              max: max3,
              values: values2
            });
          } else if (scale4.isCategory) {
            var range = scale4.range;
            var cacheScaleMeta = _this.getScaleMeta(key);
            if (values2 && !get_default(cacheScaleMeta, ["scaleDef", "range"])) {
              range = getDefaultCategoryScaleRange(deep_mix_default({}, scale4, {
                values: values2
              }), coordinate, theme);
            }
            scale4.change({
              values: values2,
              range
            });
          }
        });
      });
    };
    ScalePool2.prototype.cacheScale = function(scale4, scaleDef, key) {
      var sm = this.getScaleMeta(key);
      if (sm && sm.scale.type === scale4.type) {
        syncScale(sm.scale, scale4);
        sm.scaleDef = scaleDef;
      } else {
        sm = {
          key,
          scale: scale4,
          scaleDef
        };
        this.scales.set(key, sm);
      }
      var syncKey = this.getSyncKey(sm);
      sm.syncKey = syncKey;
      this.removeFromSyncScales(key);
      if (syncKey) {
        var scaleKeys = this.syncScales.get(syncKey);
        if (!scaleKeys) {
          scaleKeys = [];
          this.syncScales.set(syncKey, scaleKeys);
        }
        scaleKeys.push(key);
      }
    };
    ScalePool2.prototype.getScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (!scaleMeta) {
        var field = last(key.split("-"));
        var scaleKeys = this.syncScales.get(field);
        if (scaleKeys && scaleKeys.length) {
          scaleMeta = this.getScaleMeta(scaleKeys[0]);
        }
      }
      return scaleMeta && scaleMeta.scale;
    };
    ScalePool2.prototype.deleteScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (scaleMeta) {
        var syncKey = scaleMeta.syncKey;
        var scaleKeys = this.syncScales.get(syncKey);
        if (scaleKeys && scaleKeys.length) {
          var idx = scaleKeys.indexOf(key);
          if (idx !== -1) {
            scaleKeys.splice(idx, 1);
          }
        }
      }
      this.scales.delete(key);
    };
    ScalePool2.prototype.clear = function() {
      this.scales.clear();
      this.syncScales.clear();
    };
    ScalePool2.prototype.removeFromSyncScales = function(key) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var idx = scaleKeys.indexOf(key);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
          if (scaleKeys.length === 0) {
            _this.syncScales.delete(syncKey);
          }
          return false;
        }
      });
    };
    ScalePool2.prototype.getSyncKey = function(sm) {
      var scale4 = sm.scale, scaleDef = sm.scaleDef;
      var field = scale4.field;
      var sync = get_default(scaleDef, ["sync"]);
      return sync === true ? field : sync === false ? void 0 : sync;
    };
    ScalePool2.prototype.getScaleMeta = function(key) {
      return this.scales.get(key);
    };
    return ScalePool2;
  }();

  // node_modules/@antv/g2/esm/chart/layout/padding-cal.js
  var PaddingCal = function() {
    function PaddingCal2(top, right, bottom, left) {
      if (top === void 0) {
        top = 0;
      }
      if (right === void 0) {
        right = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      this.top = top;
      this.right = right;
      this.bottom = bottom;
      this.left = left;
    }
    PaddingCal2.instance = function(top, right, bottom, left) {
      if (top === void 0) {
        top = 0;
      }
      if (right === void 0) {
        right = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      return new PaddingCal2(top, right, bottom, left);
    };
    PaddingCal2.prototype.max = function(padding) {
      var top = padding[0], right = padding[1], bottom = padding[2], left = padding[3];
      this.top = Math.max(this.top, top);
      this.right = Math.max(this.right, right);
      this.bottom = Math.max(this.bottom, bottom);
      this.left = Math.max(this.left, left);
      return this;
    };
    PaddingCal2.prototype.shrink = function(padding) {
      var top = padding[0], right = padding[1], bottom = padding[2], left = padding[3];
      this.top += top;
      this.right += right;
      this.bottom += bottom;
      this.left += left;
      return this;
    };
    PaddingCal2.prototype.inc = function(bbox, direction2) {
      var width = bbox.width, height = bbox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          this.top += height;
          break;
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          this.right += width;
          break;
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          this.bottom += height;
          break;
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          this.left += width;
          break;
        default:
          break;
      }
      return this;
    };
    PaddingCal2.prototype.getPadding = function() {
      return [this.top, this.right, this.bottom, this.left];
    };
    PaddingCal2.prototype.clone = function() {
      return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray([void 0], this.getPadding(), false)))();
    };
    return PaddingCal2;
  }();

  // node_modules/@antv/g2/esm/chart/layout/auto.js
  function calculatePadding(view) {
    var padding = view.padding;
    if (!isAutoPadding(padding)) {
      return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], parsePadding(padding), false)))();
    }
    var viewBBox = view.viewBBox;
    var paddingCal = new PaddingCal();
    var axisComponents = [];
    var paddingComponents = [];
    var otherComponents = [];
    each_default(view.getComponents(), function(co) {
      var type = co.type;
      if (type === COMPONENT_TYPE.AXIS) {
        axisComponents.push(co);
      } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
        paddingComponents.push(co);
      } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
        otherComponents.push(co);
      }
    });
    each_default(axisComponents, function(co) {
      var component = co.component;
      var bboxObject = component.getLayoutBBox();
      var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
      var exceed = componentBBox.exceed(viewBBox);
      paddingCal.max(exceed);
    });
    each_default(paddingComponents, function(co) {
      var component = co.component, direction2 = co.direction;
      var bboxObject = component.getLayoutBBox();
      var componentPadding = component.get("padding");
      var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
      paddingCal.inc(componentBBox, direction2);
    });
    each_default(otherComponents, function(co) {
      var component = co.component, direction2 = co.direction;
      var bboxObject = component.getLayoutBBox();
      var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
      paddingCal.inc(componentBBox, direction2);
    });
    return paddingCal;
  }

  // node_modules/@antv/g2/esm/chart/util/sync-view-padding.js
  function defaultSyncViewPadding(chart, views, PC) {
    var syncPadding = PC.instance();
    views.forEach(function(v) {
      v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
    });
  }

  // node_modules/@antv/g2/esm/chart/view.js
  var View = function(_super) {
    __extends(View2, _super);
    function View2(props) {
      var _this = _super.call(this, { visible: props.visible }) || this;
      _this.views = [];
      _this.geometries = [];
      _this.controllers = [];
      _this.interactions = {};
      _this.limitInPlot = false;
      _this.options = {
        data: [],
        animate: true
      };
      _this.usedControllers = getComponentControllerNames();
      _this.scalePool = new ScalePool();
      _this.layoutFunc = defaultLayout;
      _this.isPreMouseInPlot = false;
      _this.isDataChanged = false;
      _this.isCoordinateChanged = false;
      _this.createdScaleKeys = new Map();
      _this.onCanvasEvent = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          var e = _this.createViewEvent(evt);
          _this.doPlotEvent(e);
          _this.emit(name, e);
        }
      };
      _this.onDelegateEvents = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          return;
        }
        var e = _this.createViewEvent(evt);
        _this.emit(name, e);
      };
      var _a4 = props.id, id = _a4 === void 0 ? unique_id_default("view") : _a4, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding = props.padding, appendPadding = props.appendPadding, theme = props.theme, options = props.options, limitInPlot2 = props.limitInPlot, syncViewPadding = props.syncViewPadding;
      _this.parent = parent;
      _this.canvas = canvas;
      _this.backgroundGroup = backgroundGroup;
      _this.middleGroup = middleGroup;
      _this.foregroundGroup = foregroundGroup;
      _this.region = region;
      _this.padding = padding;
      _this.appendPadding = appendPadding;
      _this.options = __assign(__assign({}, _this.options), options);
      _this.limitInPlot = limitInPlot2;
      _this.id = id;
      _this.syncViewPadding = syncViewPadding;
      _this.themeObject = is_object_default(theme) ? deep_mix_default({}, getTheme("default"), createTheme(theme)) : getTheme(theme);
      _this.init();
      return _this;
    }
    View2.prototype.setLayout = function(layout) {
      this.layoutFunc = layout;
    };
    View2.prototype.init = function() {
      this.calculateViewBBox();
      this.initEvents();
      this.initComponentController();
      this.initOptions();
    };
    View2.prototype.render = function(isUpdate, payload) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
      this.paint(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    View2.prototype.clear = function() {
      var _this = this;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
      this.filteredData = [];
      this.coordinateInstance = void 0;
      this.isDataChanged = false;
      this.isCoordinateChanged = false;
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        geometries[i].clear();
        geometries[i].container.remove(true);
        geometries[i].labelsContainer.remove(true);
      }
      this.geometries = [];
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        if (controllers[i].name === "annotation") {
          controllers[i].clear(true);
        } else {
          controllers[i].clear();
        }
      }
      this.createdScaleKeys.forEach(function(v, k) {
        _this.getRootView().scalePool.deleteScale(k);
      });
      this.createdScaleKeys.clear();
      var views = this.views;
      for (var i = 0; i < views.length; i++) {
        views[i].clear();
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
    };
    View2.prototype.destroy = function() {
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
      var interactions = this.interactions;
      each_default(interactions, function(interaction) {
        if (interaction) {
          interaction.destroy();
        }
      });
      this.clear();
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        controller.destroy();
      }
      this.backgroundGroup.remove(true);
      this.middleGroup.remove(true);
      this.foregroundGroup.remove(true);
      _super.prototype.destroy.call(this);
    };
    View2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var geometries = this.geometries;
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry = geometries[i];
        geometry.changeVisible(visible);
      }
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        controller.changeVisible(visible);
      }
      this.foregroundGroup.set("visible", visible);
      this.middleGroup.set("visible", visible);
      this.backgroundGroup.set("visible", visible);
      this.getCanvas().draw();
      return this;
    };
    View2.prototype.data = function(data) {
      set_default(this.options, "data", data);
      this.isDataChanged = true;
      return this;
    };
    View2.prototype.source = function(data) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
      return this.data(data);
    };
    View2.prototype.filter = function(field, condition) {
      if (is_function_default(condition)) {
        set_default(this.options, ["filters", field], condition);
        return this;
      }
      if (!condition && get_default(this.options, ["filters", field])) {
        delete this.options.filters[field];
      }
      return this;
    };
    View2.prototype.axis = function(field, axisOption) {
      if (is_boolean_default(field)) {
        set_default(this.options, ["axes"], field);
      } else {
        set_default(this.options, ["axes", field], axisOption);
      }
      return this;
    };
    View2.prototype.legend = function(field, legendOption) {
      if (is_boolean_default(field)) {
        set_default(this.options, ["legends"], field);
      } else if (is_string_default(field)) {
        set_default(this.options, ["legends", field], legendOption);
        if (is_plain_object_default(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
          set_default(this.options, ["filters", field], function(name) {
            var _a4;
            return (_a4 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a4 !== void 0 ? _a4 : true;
          });
        }
      } else {
        set_default(this.options, ["legends"], field);
      }
      return this;
    };
    View2.prototype.scale = function(field, scaleOption) {
      var _this = this;
      if (is_string_default(field)) {
        set_default(this.options, ["scales", field], scaleOption);
      } else if (is_object_default(field)) {
        each_default(field, function(v, k) {
          set_default(_this.options, ["scales", k], v);
        });
      }
      return this;
    };
    View2.prototype.tooltip = function(cfg) {
      set_default(this.options, "tooltip", cfg);
      return this;
    };
    View2.prototype.annotation = function() {
      return this.getController("annotation");
    };
    View2.prototype.guide = function() {
      console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
      return this.annotation();
    };
    View2.prototype.coordinate = function(type, coordinateCfg) {
      if (is_string_default(type)) {
        set_default(this.options, "coordinate", { type, cfg: coordinateCfg });
      } else {
        set_default(this.options, "coordinate", type);
      }
      this.coordinateController.update(this.options.coordinate);
      return this.coordinateController;
    };
    View2.prototype.coord = function(type, coordinateCfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
      return this.coordinate(type, coordinateCfg);
    };
    View2.prototype.facet = function(type, cfg) {
      if (this.facetInstance) {
        this.facetInstance.destroy();
      }
      var Ctor = getFacet(type);
      if (!Ctor) {
        throw new Error("facet '" + type + "' is not exist!");
      }
      this.facetInstance = new Ctor(this, __assign(__assign({}, cfg), { type }));
      return this;
    };
    View2.prototype.animate = function(status) {
      set_default(this.options, "animate", status);
      return this;
    };
    View2.prototype.updateOptions = function(options) {
      this.clear();
      mix(this.options, options);
      this.views.forEach(function(view) {
        return view.destroy();
      });
      this.views = [];
      this.initOptions();
      this.coordinateBBox = this.viewBBox;
      return this;
    };
    View2.prototype.option = function(name, opt) {
      if (View2.prototype[name]) {
        throw new Error(`Can't use built in variable name "` + name + '", please change another one.');
      }
      set_default(this.options, name, opt);
      return this;
    };
    View2.prototype.theme = function(theme) {
      this.themeObject = is_object_default(theme) ? deep_mix_default({}, this.themeObject, createTheme(theme)) : getTheme(theme);
      return this;
    };
    View2.prototype.interaction = function(name, cfg) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
      }
      var interaction = createInteraction(name, this, cfg);
      if (interaction) {
        interaction.init();
        this.interactions[name] = interaction;
      }
      return this;
    };
    View2.prototype.removeInteraction = function(name) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
        this.interactions[name] = void 0;
      }
    };
    View2.prototype.changeData = function(data) {
      this.isDataChanged = true;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.data(data);
      this.paint(true);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.changeData(data);
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    View2.prototype.createView = function(cfg) {
      if (this.parent && this.parent.parent) {
        console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
      }
      var sharedOptions = {
        data: this.options.data,
        scales: clone_default(this.options.scales),
        axes: clone_default(this.options.axes),
        coordinate: clone_default(this.coordinateController.getOption()),
        tooltip: clone_default(this.options.tooltip),
        legends: clone_default(this.options.legends),
        animate: this.options.animate,
        visible: this.visible
      };
      var v = new View2(__assign(__assign({
        parent: this,
        canvas: this.canvas,
        backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        theme: this.themeObject,
        padding: this.padding
      }, cfg), { options: __assign(__assign({}, sharedOptions), get_default(cfg, "options", {})) }));
      this.views.push(v);
      return v;
    };
    View2.prototype.view = function(cfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
      return this.createView(cfg);
    };
    View2.prototype.removeView = function(view) {
      var removedView = remove_default(this.views, function(v) {
        return v === view;
      })[0];
      if (removedView) {
        removedView.destroy();
      }
      return removedView;
    };
    View2.prototype.getCoordinate = function() {
      return this.coordinateInstance;
    };
    View2.prototype.getTheme = function() {
      return this.themeObject;
    };
    View2.prototype.getXScale = function() {
      var g = this.geometries[0];
      return g ? g.getXScale() : null;
    };
    View2.prototype.getYScales = function() {
      var tmpMap = {};
      var yScales = [];
      this.geometries.forEach(function(g) {
        var yScale = g.getYScale();
        var field = yScale.field;
        if (!tmpMap[field]) {
          tmpMap[field] = true;
          yScales.push(yScale);
        }
      });
      return yScales;
    };
    View2.prototype.getScalesByDim = function(dimType) {
      var geometries = this.geometries;
      var scales = {};
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry = geometries[i];
        var scale4 = dimType === "x" ? geometry.getXScale() : geometry.getYScale();
        if (scale4 && !scales[scale4.field]) {
          scales[scale4.field] = scale4;
        }
      }
      return scales;
    };
    View2.prototype.getScale = function(field, key) {
      var defaultKey = key ? key : this.getScaleKey(field);
      return this.getRootView().scalePool.getScale(defaultKey);
    };
    View2.prototype.getScaleByField = function(field, key) {
      return this.getScale(field, key);
    };
    View2.prototype.getOptions = function() {
      return this.options;
    };
    View2.prototype.getData = function() {
      return this.filteredData;
    };
    View2.prototype.getOriginalData = function() {
      return this.options.data;
    };
    View2.prototype.getPadding = function() {
      return this.autoPadding.getPadding();
    };
    View2.prototype.getGeometries = function() {
      return this.geometries;
    };
    View2.prototype.getElements = function() {
      return reduce_default(this.geometries, function(elements, geometry) {
        return elements.concat(geometry.getElements());
      }, []);
    };
    View2.prototype.getElementsBy = function(condition) {
      return this.getElements().filter(function(el) {
        return condition(el);
      });
    };
    View2.prototype.getLayer = function(layer) {
      return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
    };
    View2.prototype.isPointInPlot = function(point) {
      return isPointInCoordinate(this.getCoordinate(), point);
    };
    View2.prototype.getLegendAttributes = function() {
      return flatten_default(this.geometries.map(function(g) {
        return g.getGroupAttributes();
      }));
    };
    View2.prototype.getGroupScales = function() {
      var scales = this.geometries.map(function(g) {
        return g.getGroupScales();
      });
      return uniq2(flatten_default(scales));
    };
    View2.prototype.getCanvas = function() {
      return this.getRootView().canvas;
    };
    View2.prototype.getRootView = function() {
      var v = this;
      while (true) {
        if (v.parent) {
          v = v.parent;
          continue;
        }
        break;
      }
      return v;
    };
    View2.prototype.getXY = function(data) {
      var coordinate = this.getCoordinate();
      var xScales = this.getScalesByDim("x");
      var yScales = this.getScalesByDim("y");
      var x;
      var y;
      each_default(data, function(value, key) {
        if (xScales[key]) {
          x = xScales[key].scale(value);
        }
        if (yScales[key]) {
          y = yScales[key].scale(value);
        }
      });
      if (!is_nil_default(x) && !is_nil_default(y)) {
        return coordinate.convert({ x, y });
      }
    };
    View2.prototype.getController = function(name) {
      return find_default(this.controllers, function(c) {
        return c.name === name;
      });
    };
    View2.prototype.showTooltip = function(point) {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.showTooltip(point);
      }
      return this;
    };
    View2.prototype.hideTooltip = function() {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.hideTooltip();
      }
      return this;
    };
    View2.prototype.lockTooltip = function() {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.lockTooltip();
      }
      return this;
    };
    View2.prototype.unlockTooltip = function() {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.unlockTooltip();
      }
      return this;
    };
    View2.prototype.isTooltipLocked = function() {
      var tooltip = this.getController("tooltip");
      return tooltip && tooltip.isTooltipLocked();
    };
    View2.prototype.getTooltipItems = function(point) {
      var tooltip = this.getController("tooltip");
      return tooltip ? tooltip.getTooltipItems(point) : [];
    };
    View2.prototype.getSnapRecords = function(point) {
      var geometries = this.geometries;
      var rst = [];
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geom = geometries[i];
        var dataArray = geom.dataArray;
        geom.sort(dataArray);
        var record = void 0;
        for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
          var data = dataArray[j];
          record = findDataByPoint(point, data, geom);
          if (record) {
            rst.push(record);
          }
        }
      }
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        var snapRecords = view.getSnapRecords(point);
        rst = rst.concat(snapRecords);
      }
      return rst;
    };
    View2.prototype.getComponents = function() {
      var components = [];
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        components = components.concat(controller.getComponents());
      }
      return components;
    };
    View2.prototype.filterData = function(data) {
      var filters = this.options.filters;
      if (size2(filters) === 0) {
        return data;
      }
      return filter_default(data, function(datum, idx) {
        var fields = Object.keys(filters);
        return fields.every(function(field) {
          var condition = filters[field];
          return condition(datum[field], datum, idx);
        });
      });
    };
    View2.prototype.filterFieldData = function(field, data) {
      var filters = this.options.filters;
      var condition = get_default(filters, field);
      if (is_undefined_default(condition)) {
        return data;
      }
      return data.filter(function(datum, idx) {
        return condition(datum[field], datum, idx);
      });
    };
    View2.prototype.adjustCoordinate = function() {
      var _a4 = this.getCoordinate(), curStart = _a4.start, curEnd = _a4.end;
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      if (is_equal_default(curStart, start) && is_equal_default(curEnd, end)) {
        this.isCoordinateChanged = false;
        return;
      }
      this.isCoordinateChanged = true;
      this.coordinateInstance = this.coordinateController.adjust(start, end);
    };
    View2.prototype.paint = function(isUpdate) {
      this.renderDataRecursive(isUpdate);
      this.syncScale();
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
      this.renderPaddingRecursive(isUpdate);
      this.renderLayoutRecursive(isUpdate);
      this.renderBackgroundStyleShape();
      this.renderPaintRecursive(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
      this.isDataChanged = false;
    };
    View2.prototype.renderBackgroundStyleShape = function() {
      if (this.parent) {
        return;
      }
      var background = get_default(this.themeObject, "background");
      if (background) {
        if (!this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
            attrs: {},
            zIndex: -1,
            capture: false
          });
          this.backgroundStyleRectShape.toBack();
        }
        var _a4 = this.viewBBox, x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
        this.backgroundStyleRectShape.attr({
          fill: background,
          x,
          y,
          width,
          height
        });
      } else {
        if (this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape.remove(true);
          this.backgroundStyleRectShape = void 0;
        }
      }
    };
    View2.prototype.renderPaddingRecursive = function(isUpdate) {
      this.calculateViewBBox();
      this.adjustCoordinate();
      this.initComponents(isUpdate);
      this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
      this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
      this.adjustCoordinate();
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderPaddingRecursive(isUpdate);
      }
    };
    View2.prototype.renderLayoutRecursive = function(isUpdate) {
      var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : is_function_default(this.syncViewPadding) ? this.syncViewPadding : void 0;
      if (syncViewPaddingFn) {
        syncViewPaddingFn(this, this.views, PaddingCal);
        this.views.forEach(function(v) {
          v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
          v.adjustCoordinate();
        });
      }
      this.doLayout();
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderLayoutRecursive(isUpdate);
      }
    };
    View2.prototype.renderPaintRecursive = function(isUpdate) {
      var middleGroup = this.middleGroup;
      if (this.limitInPlot) {
        var _a4 = getCoordinateClipCfg(this.coordinateInstance), type = _a4.type, attrs = _a4.attrs;
        middleGroup.setClip({
          type,
          attrs
        });
      } else {
        middleGroup.setClip(void 0);
      }
      this.paintGeometries(isUpdate);
      this.renderComponents(isUpdate);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderPaintRecursive(isUpdate);
      }
    };
    View2.prototype.createScale = function(field, data, scaleDef, key) {
      var currentScaleDef = get_default(this.options.scales, [field]);
      var mergedScaleDef = __assign(__assign({}, currentScaleDef), scaleDef);
      if (this.parent) {
        return this.parent.createScale(field, data, mergedScaleDef, key);
      }
      return this.scalePool.createScale(field, data, mergedScaleDef, key);
    };
    View2.prototype.renderDataRecursive = function(isUpdate) {
      this.doFilterData();
      this.createCoordinate();
      this.initGeometries(isUpdate);
      this.renderFacet(isUpdate);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderDataRecursive(isUpdate);
      }
    };
    View2.prototype.calculateViewBBox = function() {
      var x;
      var y;
      var width;
      var height;
      if (this.parent) {
        var bbox = this.parent.coordinateBBox;
        x = bbox.x;
        y = bbox.y;
        width = bbox.width;
        height = bbox.height;
      } else {
        x = 0;
        y = 0;
        width = this.canvas.get("width");
        height = this.canvas.get("height");
      }
      var _a4 = this.region, start = _a4.start, end = _a4.end;
      var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
        this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      }
      this.coordinateBBox = this.viewBBox;
    };
    View2.prototype.initEvents = function() {
      this.foregroundGroup.on("*", this.onDelegateEvents);
      this.middleGroup.on("*", this.onDelegateEvents);
      this.backgroundGroup.on("*", this.onDelegateEvents);
      this.canvas.on("*", this.onCanvasEvent);
    };
    View2.prototype.initComponentController = function() {
      var usedControllers = this.usedControllers;
      for (var i = 0, len3 = usedControllers.length; i < len3; i++) {
        var controllerName = usedControllers[i];
        var Ctor = getComponentController(controllerName);
        if (Ctor) {
          this.controllers.push(new Ctor(this));
        }
      }
    };
    View2.prototype.createViewEvent = function(evt) {
      var shape = evt.shape, name = evt.name;
      var data = shape ? shape.get("origin") : null;
      var e = new event_default(this, evt, data);
      e.type = name;
      return e;
    };
    View2.prototype.doPlotEvent = function(e) {
      var type = e.type, x = e.x, y = e.y;
      var point = { x, y };
      var ALL_EVENTS = [
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseleave",
        "mousewheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "click",
        "dblclick",
        "contextmenu"
      ];
      if (ALL_EVENTS.includes(type)) {
        var currentInPlot = this.isPointInPlot(point);
        var newEvent = e.clone();
        if (currentInPlot) {
          var TYPE = "plot:" + type;
          newEvent.type = TYPE;
          this.emit(TYPE, newEvent);
          if (type === "mouseleave" || type === "touchend") {
            this.isPreMouseInPlot = false;
          }
        }
        if (type === "mousemove" || type === "touchmove") {
          if (this.isPreMouseInPlot && !currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
          } else if (!this.isPreMouseInPlot && currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
              this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
            }
            newEvent.type = PLOT_EVENTS.ENTER;
            this.emit(PLOT_EVENTS.ENTER, newEvent);
          }
          this.isPreMouseInPlot = currentInPlot;
        } else if (type === "mouseleave" || type === "touchend") {
          if (this.isPreMouseInPlot) {
            if (type === "mouseleave") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
            this.isPreMouseInPlot = false;
          }
        }
      }
    };
    View2.prototype.doFilterData = function() {
      var data = this.options.data;
      this.filteredData = this.filterData(data);
    };
    View2.prototype.initGeometries = function(isUpdate) {
      this.createOrUpdateScales();
      var coordinate = this.getCoordinate();
      var scaleDefs = get_default(this.options, "scales", {});
      var geometries = this.geometries;
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry = geometries[i];
        geometry.scales = this.getGeometryScales();
        var cfg = {
          coordinate,
          scaleDefs,
          data: this.filteredData,
          theme: this.themeObject,
          isDataChanged: this.isDataChanged,
          isCoordinateChanged: this.isCoordinateChanged
        };
        if (isUpdate) {
          geometry.update(cfg);
        } else {
          geometry.init(cfg);
        }
      }
      this.adjustScales();
    };
    View2.prototype.createOrUpdateScales = function() {
      var fields = this.getScaleFields();
      var groupedFields = this.getGroupedFields();
      var _a4 = this.getOptions(), data = _a4.data, _b = _a4.scales, scales = _b === void 0 ? {} : _b;
      var filteredData = this.filteredData;
      for (var i = 0, len3 = fields.length; i < len3; i++) {
        var field = fields[i];
        var scaleDef = scales[field];
        var key = this.getScaleKey(field);
        this.createScale(field, groupedFields.includes(field) ? data : filteredData, scaleDef, key);
        this.createdScaleKeys.set(key, true);
      }
    };
    View2.prototype.syncScale = function() {
      this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
    };
    View2.prototype.getGeometryScales = function() {
      var fields = this.getScaleFields();
      var scales = {};
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        scales[field] = this.getScaleByField(field);
      }
      return scales;
    };
    View2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        var geometryScales = geometry.getScaleFields();
        uniq2(geometryScales, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.getGroupedFields = function() {
      var fields = [];
      var tmpMap = new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        var groupFields = geometry.getGroupFields();
        uniq2(groupFields, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.adjustScales = function() {
      this.adjustCategoryScaleRange();
    };
    View2.prototype.adjustCategoryScaleRange = function() {
      var _this = this;
      var xyScales = __spreadArray([this.getXScale()], this.getYScales(), true).filter(function(e) {
        return !!e;
      });
      var coordinate = this.getCoordinate();
      var scaleOptions = this.options.scales;
      each_default(xyScales, function(scale4) {
        var field = scale4.field, values2 = scale4.values, isCategory = scale4.isCategory, isIdentity = scale4.isIdentity;
        if (isCategory || isIdentity) {
          if (values2 && !get_default(scaleOptions, [field, "range"])) {
            scale4.range = getDefaultCategoryScaleRange(scale4, coordinate, _this.theme);
          }
        }
      });
    };
    View2.prototype.initComponents = function(isUpdate) {
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        if (isUpdate) {
          controller.update();
        } else {
          controller.clear();
          controller.render();
        }
      }
    };
    View2.prototype.doLayout = function() {
      this.layoutFunc(this);
    };
    View2.prototype.createCoordinate = function() {
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      this.coordinateInstance = this.coordinateController.create(start, end);
    };
    View2.prototype.paintGeometries = function(isUpdate) {
      var doAnimation = this.options.animate;
      var coordinate = this.getCoordinate();
      var canvasRegion = {
        x: this.viewBBox.x,
        y: this.viewBBox.y,
        minX: this.viewBBox.minX,
        minY: this.viewBBox.minY,
        maxX: this.viewBBox.maxX,
        maxY: this.viewBBox.maxY,
        width: this.viewBBox.width,
        height: this.viewBBox.height
      };
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        geometry.coordinate = coordinate;
        geometry.canvasRegion = canvasRegion;
        if (!doAnimation) {
          geometry.animate(false);
        }
        geometry.paint(isUpdate);
      }
    };
    View2.prototype.renderComponents = function(isUpdate) {
      for (var i = 0; i < this.getComponents().length; i++) {
        var co = this.getComponents()[i];
        co.component.render();
      }
    };
    View2.prototype.renderFacet = function(isUpdate) {
      if (this.facetInstance) {
        if (isUpdate) {
          this.facetInstance.update();
        } else {
          this.facetInstance.clear();
          this.facetInstance.init();
          this.facetInstance.render();
        }
      }
    };
    View2.prototype.initOptions = function() {
      var _this = this;
      var _a4 = this.options, _b = _a4.geometries, geometries = _b === void 0 ? [] : _b, _c = _a4.interactions, interactions = _c === void 0 ? [] : _c, _d = _a4.views, views = _d === void 0 ? [] : _d, _e = _a4.annotations, annotations = _e === void 0 ? [] : _e, coordinate = _a4.coordinate, events = _a4.events, facets = _a4.facets;
      if (this.coordinateController) {
        coordinate && this.coordinateController.update(coordinate);
      } else {
        this.coordinateController = new coordinate_default(coordinate);
      }
      for (var i = 0; i < geometries.length; i++) {
        var geometryOption = geometries[i];
        this.createGeometry(geometryOption);
      }
      for (var j = 0; j < interactions.length; j++) {
        var interactionOption = interactions[j];
        var type = interactionOption.type, cfg = interactionOption.cfg;
        this.interaction(type, cfg);
      }
      for (var k = 0; k < views.length; k++) {
        var viewOption = views[k];
        this.createView(viewOption);
      }
      var annotationComponent = this.getController("annotation");
      for (var l = 0; l < annotations.length; l++) {
        var annotationOption = annotations[l];
        annotationComponent.annotation(annotationOption);
      }
      if (events) {
        each_default(events, function(eventCallback, eventName) {
          _this.on(eventName, eventCallback);
        });
      }
      if (facets) {
        each_default(facets, function(facet) {
          var type2 = facet.type, rest = __rest(facet, ["type"]);
          _this.facet(type2, rest);
        });
      }
    };
    View2.prototype.createGeometry = function(geometryOption) {
      var type = geometryOption.type, _a4 = geometryOption.cfg, cfg = _a4 === void 0 ? {} : _a4;
      if (this[type]) {
        var geometry_1 = this[type](cfg);
        each_default(geometryOption, function(v, k) {
          if (is_function_default(geometry_1[k])) {
            geometry_1[k](v);
          }
        });
      }
    };
    View2.prototype.getScaleKey = function(field) {
      return this.id + "-" + field;
    };
    return View2;
  }(base_default);
  function registerGeometry(name, Ctor) {
    View.prototype[name.toLowerCase()] = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      var props = __assign({
        container: this.middleGroup.addGroup(),
        labelsContainer: this.foregroundGroup.addGroup()
      }, cfg);
      var geometry = new Ctor(props);
      this.geometries.push(geometry);
      return geometry;
    };
  }
  var view_default = View;

  // node_modules/@antv/g2/esm/chart/chart.js
  var Chart = function(_super) {
    __extends(Chart2, _super);
    function Chart2(props) {
      var _this = this;
      var container = props.container, width = props.width, height = props.height, _a4 = props.autoFit, autoFit = _a4 === void 0 ? false : _a4, padding = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer2 = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text"] : _f, options = props.options, limitInPlot2 = props.limitInPlot, theme = props.theme, syncViewPadding = props.syncViewPadding;
      var ele = is_string_default(container) ? document.getElementById(container) : container;
      var wrapperElement = createDom('<div style="position:relative;"></div>');
      ele.appendChild(wrapperElement);
      var size3 = getChartSize(ele, autoFit, width, height);
      var G = getEngine(renderer2);
      var canvas = new G.Canvas(__assign({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size3));
      _this = _super.call(this, {
        parent: null,
        canvas,
        backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        padding,
        appendPadding,
        visible,
        options,
        limitInPlot: limitInPlot2,
        theme,
        syncViewPadding
      }) || this;
      _this.onResize = debounce_default(function() {
        _this.forceFit();
      }, 300);
      _this.ele = ele;
      _this.canvas = canvas;
      _this.width = size3.width;
      _this.height = size3.height;
      _this.autoFit = autoFit;
      _this.localRefresh = localRefresh;
      _this.renderer = renderer2;
      _this.wrapperElement = wrapperElement;
      _this.updateCanvasStyle();
      _this.bindAutoFit();
      _this.initDefaultInteractions(defaultInteractions);
      return _this;
    }
    Chart2.prototype.initDefaultInteractions = function(interactions) {
      var _this = this;
      each_default(interactions, function(interaction) {
        _this.interaction(interaction);
      });
    };
    Chart2.prototype.aria = function(ariaOption) {
      var ATTR = "aria-label";
      if (ariaOption === false) {
        this.ele.removeAttribute(ATTR);
      } else {
        this.ele.setAttribute(ATTR, ariaOption.label);
      }
    };
    Chart2.prototype.changeSize = function(width, height) {
      if (this.width === width && this.height === height) {
        return this;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
      this.width = width;
      this.height = height;
      this.canvas.changeSize(width, height);
      this.render(true);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
      return this;
    };
    Chart2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.aria(false);
    };
    Chart2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unbindAutoFit();
      this.canvas.destroy();
      removeDom(this.wrapperElement);
      this.wrapperElement = null;
    };
    Chart2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      this.wrapperElement.style.display = visible ? "" : "none";
      return this;
    };
    Chart2.prototype.forceFit = function() {
      if (!this.destroyed) {
        var _a4 = getChartSize(this.ele, true, this.width, this.height), width = _a4.width, height = _a4.height;
        this.changeSize(width, height);
      }
    };
    Chart2.prototype.updateCanvasStyle = function() {
      modifyCSS(this.canvas.get("el"), {
        display: "inline-block",
        verticalAlign: "middle"
      });
    };
    Chart2.prototype.bindAutoFit = function() {
      if (this.autoFit) {
        window.addEventListener("resize", this.onResize);
      }
    };
    Chart2.prototype.unbindAutoFit = function() {
      if (this.autoFit) {
        window.removeEventListener("resize", this.onResize);
      }
    };
    return Chart2;
  }(view_default);
  var chart_default = Chart;

  // node_modules/@antv/g2/esm/chart/controller/base.js
  var Controller = function() {
    function Controller2(view) {
      this.visible = true;
      this.components = [];
      this.view = view;
    }
    Controller2.prototype.clear = function(includeOption) {
      each_default(this.components, function(co) {
        co.component.destroy();
      });
      this.components = [];
    };
    Controller2.prototype.destroy = function() {
      this.clear();
    };
    Controller2.prototype.getComponents = function() {
      return this.components;
    };
    Controller2.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.components.forEach(function(co) {
        if (visible) {
          co.component.show();
        } else {
          co.component.hide();
        }
      });
      this.visible = visible;
    };
    return Controller2;
  }();

  // node_modules/@antv/g2/esm/chart/controller/tooltip.js
  function uniq3(items) {
    var uniqItems = [];
    var _loop_1 = function(index2) {
      var item = items[index2];
      var result = find_default(uniqItems, function(subItem) {
        return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
      });
      if (!result) {
        uniqItems.push(item);
      }
    };
    for (var index = 0; index < items.length; index++) {
      _loop_1(index);
    }
    return uniqItems;
  }
  var Tooltip2 = function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isLocked = false;
      return _this;
    }
    Object.defineProperty(Tooltip3.prototype, "name", {
      get: function() {
        return "tooltip";
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.init = function() {
    };
    Tooltip3.prototype.isVisible = function() {
      var option = this.view.getOptions().tooltip;
      return option !== false;
    };
    Tooltip3.prototype.render = function() {
    };
    Tooltip3.prototype.showTooltip = function(point) {
      this.point = point;
      if (!this.isVisible()) {
        return;
      }
      var view = this.view;
      var items = this.getTooltipItems(point);
      if (!items.length) {
        this.hideTooltip();
        return;
      }
      var title = this.getTitle(items);
      var dataPoint = {
        x: items[0].x,
        y: items[0].y
      };
      view.emit("tooltip:show", event_default.fromData(view, "tooltip:show", __assign({ items, title }, point)));
      var cfg = this.getTooltipCfg();
      var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
      var lastItems = this.items;
      var lastTitle = this.title;
      if (!is_equal_default(lastTitle, title) || !is_equal_default(lastItems, items)) {
        view.emit("tooltip:change", event_default.fromData(view, "tooltip:change", __assign({ items, title }, point)));
        if (is_function_default(showContent) ? showContent(items) : showContent) {
          if (!this.tooltip) {
            this.renderTooltip();
          }
          this.tooltip.update(mix({}, cfg, {
            items: this.getItemsAfterProcess(items),
            title
          }, follow ? point : {}));
          this.tooltip.show();
        }
        if (showMarkers) {
          this.renderTooltipMarkers(items, marker);
        }
      } else {
        if (this.tooltip && follow) {
          this.tooltip.update(point);
          this.tooltip.show();
        }
        if (this.tooltipMarkersGroup) {
          this.tooltipMarkersGroup.show();
        }
      }
      this.items = items;
      this.title = title;
      if (showCrosshairs) {
        var isCrosshairsFollowCursor = get_default(cfg, ["crosshairs", "follow"], false);
        this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);
      }
    };
    Tooltip3.prototype.hideTooltip = function() {
      var follow = this.getTooltipCfg().follow;
      if (!follow) {
        this.point = null;
        return;
      }
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      var xCrosshair = this.xCrosshair;
      var yCrosshair = this.yCrosshair;
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
      var tooltip = this.tooltip;
      if (tooltip) {
        tooltip.hide();
      }
      this.view.emit("tooltip:hide", event_default.fromData(this.view, "tooltip:hide", {}));
      this.point = null;
    };
    Tooltip3.prototype.lockTooltip = function() {
      this.isLocked = true;
      if (this.tooltip) {
        this.tooltip.setCapture(true);
      }
    };
    Tooltip3.prototype.unlockTooltip = function() {
      this.isLocked = false;
      var cfg = this.getTooltipCfg();
      if (this.tooltip) {
        this.tooltip.setCapture(cfg.capture);
      }
    };
    Tooltip3.prototype.isTooltipLocked = function() {
      return this.isLocked;
    };
    Tooltip3.prototype.clear = function() {
      var _a4 = this, tooltip = _a4.tooltip, xCrosshair = _a4.xCrosshair, yCrosshair = _a4.yCrosshair, tooltipMarkersGroup = _a4.tooltipMarkersGroup;
      if (tooltip) {
        tooltip.hide();
        tooltip.clear();
      }
      if (xCrosshair) {
        xCrosshair.clear();
      }
      if (yCrosshair) {
        yCrosshair.clear();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.clear();
      }
      if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.get("customContent")) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
      this.title = null;
      this.items = null;
    };
    Tooltip3.prototype.destroy = function() {
      if (this.tooltip) {
        this.tooltip.destroy();
      }
      if (this.xCrosshair) {
        this.xCrosshair.destroy();
      }
      if (this.yCrosshair) {
        this.yCrosshair.destroy();
      }
      if (this.guideGroup) {
        this.guideGroup.remove(true);
      }
      this.reset();
    };
    Tooltip3.prototype.reset = function() {
      this.items = null;
      this.title = null;
      this.tooltipMarkersGroup = null;
      this.tooltipCrosshairsGroup = null;
      this.xCrosshair = null;
      this.yCrosshair = null;
      this.tooltip = null;
      this.guideGroup = null;
      this.isLocked = false;
      this.point = null;
    };
    Tooltip3.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      var _a4 = this, tooltip = _a4.tooltip, tooltipMarkersGroup = _a4.tooltipMarkersGroup, xCrosshair = _a4.xCrosshair, yCrosshair = _a4.yCrosshair;
      if (visible) {
        if (tooltip) {
          tooltip.show();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.show();
        }
        if (xCrosshair) {
          xCrosshair.show();
        }
        if (yCrosshair) {
          yCrosshair.show();
        }
      } else {
        if (tooltip) {
          tooltip.hide();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.hide();
        }
        if (xCrosshair) {
          xCrosshair.hide();
        }
        if (yCrosshair) {
          yCrosshair.hide();
        }
      }
      this.visible = visible;
    };
    Tooltip3.prototype.getTooltipItems = function(point) {
      var items = this.findItemsFromView(this.view, point);
      if (items.length) {
        items = flatten_default(items);
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
          var itemArr = items_1[_i];
          for (var _a4 = 0, itemArr_1 = itemArr; _a4 < itemArr_1.length; _a4++) {
            var item = itemArr_1[_a4];
            var _b = item.mappingData, x = _b.x, y = _b.y;
            item.x = is_array_default(x) ? x[x.length - 1] : x;
            item.y = is_array_default(y) ? y[y.length - 1] : y;
          }
        }
        var shared = this.getTooltipCfg().shared;
        if (shared === false && items.length > 1) {
          var snapItem = items[0];
          var min3 = Math.abs(point.y - snapItem[0].y);
          for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
            var aItem = items_2[_c];
            var yDistance = Math.abs(point.y - aItem[0].y);
            if (yDistance <= min3) {
              snapItem = aItem;
              min3 = yDistance;
            }
          }
          items = [snapItem];
        }
        return uniq3(flatten_default(items));
      }
      return [];
    };
    Tooltip3.prototype.layout = function() {
    };
    Tooltip3.prototype.update = function() {
      if (this.point) {
        this.showTooltip(this.point);
      }
      if (this.tooltip) {
        var canvas = this.view.getCanvas();
        this.tooltip.set("region", {
          start: { x: 0, y: 0 },
          end: { x: canvas.get("width"), y: canvas.get("height") }
        });
      }
    };
    Tooltip3.prototype.isCursorEntered = function(point) {
      if (this.tooltip) {
        var el = this.tooltip.getContainer();
        var capture = this.tooltip.get("capture");
        if (el && capture) {
          var _a4 = el.getBoundingClientRect(), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
          return new BBox(x, y, width, height).isPointIn(point);
        }
      }
      return false;
    };
    Tooltip3.prototype.getTooltipCfg = function() {
      var view = this.view;
      var option = view.getOptions().tooltip;
      var processOption = this.processCustomContent(option);
      var theme = view.getTheme();
      var defaultCfg = get_default(theme, ["components", "tooltip"], {});
      var enterable = get_default(processOption, "enterable", defaultCfg.enterable);
      return deep_mix_default({}, defaultCfg, processOption, {
        capture: enterable || this.isLocked ? true : false
      });
    };
    Tooltip3.prototype.processCustomContent = function(option) {
      if (is_boolean_default(option) || !get_default(option, "customContent")) {
        return option;
      }
      var currentCustomContent = option.customContent;
      var customContent = function(title, items) {
        var content = currentCustomContent(title, items) || "";
        return is_string_default(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
      };
      return __assign(__assign({}, option), { customContent });
    };
    Tooltip3.prototype.getTitle = function(items) {
      var title = items[0].title || items[0].name;
      this.title = title;
      return title;
    };
    Tooltip3.prototype.renderTooltip = function() {
      var canvas = this.view.getCanvas();
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var cfg = this.getTooltipCfg();
      var tooltip = new HtmlTooltip(__assign(__assign({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
      tooltip.init();
      this.tooltip = tooltip;
    };
    Tooltip3.prototype.renderTooltipMarkers = function(items, marker) {
      var tooltipMarkersGroup = this.getTooltipMarkersGroup();
      for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
        var item = items_3[_i];
        var x = item.x, y = item.y;
        var attrs = __assign(__assign({ fill: item.color, symbol: "circle", shadowColor: item.color }, marker), { x, y });
        tooltipMarkersGroup.addShape("marker", {
          attrs
        });
      }
    };
    Tooltip3.prototype.renderCrosshairs = function(point, cfg) {
      var crosshairsType = get_default(cfg, ["crosshairs", "type"], "x");
      if (crosshairsType === "x") {
        if (this.yCrosshair) {
          this.yCrosshair.hide();
        }
        this.renderXCrosshairs(point, cfg);
      } else if (crosshairsType === "y") {
        if (this.xCrosshair) {
          this.xCrosshair.hide();
        }
        this.renderYCrosshairs(point, cfg);
      } else if (crosshairsType === "xy") {
        this.renderXCrosshairs(point, cfg);
        this.renderYCrosshairs(point, cfg);
      }
    };
    Tooltip3.prototype.renderXCrosshairs = function(point, tooltipCfg) {
      var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
      if (!isPointInCoordinate(coordinate, point)) {
        return;
      }
      var start;
      var end;
      if (coordinate.isRect) {
        if (coordinate.isTransposed) {
          start = {
            x: coordinate.start.x,
            y: point.y
          };
          end = {
            x: coordinate.end.x,
            y: point.y
          };
        } else {
          start = {
            x: point.x,
            y: coordinate.end.y
          };
          end = {
            x: point.x,
            y: coordinate.start.y
          };
        }
      } else {
        var angle3 = getAngleByPoint(coordinate, point);
        var center = coordinate.getCenter();
        var radius = coordinate.getRadius();
        end = polarToCartesian(center.x, center.y, radius, angle3);
        start = center;
      }
      var cfg = deep_mix_default({
        start,
        end,
        container: this.getTooltipCrosshairsGroup()
      }, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point, tooltipCfg));
      delete cfg.type;
      var xCrosshair = this.xCrosshair;
      if (xCrosshair) {
        xCrosshair.update(cfg);
      } else {
        xCrosshair = new crosshair_exports.Line(cfg);
        xCrosshair.init();
      }
      xCrosshair.render();
      xCrosshair.show();
      this.xCrosshair = xCrosshair;
    };
    Tooltip3.prototype.renderYCrosshairs = function(point, tooltipCfg) {
      var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
      if (!isPointInCoordinate(coordinate, point)) {
        return;
      }
      var cfg;
      var type;
      if (coordinate.isRect) {
        var start = void 0;
        var end = void 0;
        if (coordinate.isTransposed) {
          start = {
            x: point.x,
            y: coordinate.end.y
          };
          end = {
            x: point.x,
            y: coordinate.start.y
          };
        } else {
          start = {
            x: coordinate.start.x,
            y: point.y
          };
          end = {
            x: coordinate.end.x,
            y: point.y
          };
        }
        cfg = {
          start,
          end
        };
        type = "Line";
      } else {
        cfg = {
          center: coordinate.getCenter(),
          radius: getDistanceToCenter(coordinate, point),
          startAngle: coordinate.startAngle,
          endAngle: coordinate.endAngle
        };
        type = "Circle";
      }
      cfg = deep_mix_default({
        container: this.getTooltipCrosshairsGroup()
      }, cfg, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point, tooltipCfg));
      delete cfg.type;
      var yCrosshair = this.yCrosshair;
      if (yCrosshair) {
        if (coordinate.isRect && yCrosshair.get("type") === "circle" || !coordinate.isRect && yCrosshair.get("type") === "line") {
          yCrosshair = new crosshair_exports[type](cfg);
          yCrosshair.init();
        } else {
          yCrosshair.update(cfg);
        }
      } else {
        yCrosshair = new crosshair_exports[type](cfg);
        yCrosshair.init();
      }
      yCrosshair.render();
      yCrosshair.show();
      this.yCrosshair = yCrosshair;
    };
    Tooltip3.prototype.getCrosshairsText = function(type, point, tooltipCfg) {
      var textCfg = get_default(tooltipCfg, ["crosshairs", "text"]);
      var follow = get_default(tooltipCfg, ["crosshairs", "follow"]);
      var items = this.items;
      if (textCfg) {
        var view = this.getViewWithGeometry(this.view);
        var firstItem = items[0];
        var xScale = view.getXScale();
        var yScale = view.getYScales()[0];
        var xValue = void 0;
        var yValue = void 0;
        if (follow) {
          var invertPoint = this.view.getCoordinate().invert(point);
          xValue = xScale.invert(invertPoint.x);
          yValue = yScale.invert(invertPoint.y);
        } else {
          xValue = firstItem.data[xScale.field];
          yValue = firstItem.data[yScale.field];
        }
        var content = type === "x" ? xValue : yValue;
        if (is_function_default(textCfg)) {
          textCfg = textCfg(type, content, items, point);
        } else {
          textCfg.content = content;
        }
        return {
          text: textCfg
        };
      }
    };
    Tooltip3.prototype.getGuideGroup = function() {
      if (!this.guideGroup) {
        var foregroundGroup = this.view.foregroundGroup;
        this.guideGroup = foregroundGroup.addGroup({
          name: "tooltipGuide",
          capture: false
        });
      }
      return this.guideGroup;
    };
    Tooltip3.prototype.getTooltipMarkersGroup = function() {
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
        tooltipMarkersGroup.clear();
        tooltipMarkersGroup.show();
      } else {
        tooltipMarkersGroup = this.getGuideGroup().addGroup({
          name: "tooltipMarkersGroup"
        });
        tooltipMarkersGroup.toFront();
        this.tooltipMarkersGroup = tooltipMarkersGroup;
      }
      return tooltipMarkersGroup;
    };
    Tooltip3.prototype.getTooltipCrosshairsGroup = function() {
      var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
      if (!tooltipCrosshairsGroup) {
        tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
          name: "tooltipCrosshairsGroup",
          capture: false
        });
        tooltipCrosshairsGroup.toBack();
        this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
      }
      return tooltipCrosshairsGroup;
    };
    Tooltip3.prototype.findItemsFromView = function(view, point) {
      if (view.getOptions().tooltip === false) {
        return [];
      }
      var tooltipCfg = this.getTooltipCfg();
      var result = findItemsFromView(view, point, tooltipCfg);
      for (var _i = 0, _a4 = view.views; _i < _a4.length; _i++) {
        var childView = _a4[_i];
        result = result.concat(this.findItemsFromView(childView, point));
      }
      return result;
    };
    Tooltip3.prototype.getViewWithGeometry = function(view) {
      var _this = this;
      if (view.geometries.length) {
        return view;
      }
      return find_default(view.views, function(childView) {
        return _this.getViewWithGeometry(childView);
      });
    };
    Tooltip3.prototype.getItemsAfterProcess = function(originalItems) {
      var customItems = this.getTooltipCfg().customItems;
      var fn = customItems ? customItems : function(v) {
        return v;
      };
      return fn(originalItems);
    };
    return Tooltip3;
  }(Controller);
  var tooltip_default = Tooltip2;

  // node_modules/@antv/g2/esm/animate/animation/index.js
  var ANIMATIONS_MAP = {};
  function getAnimation(type) {
    return ANIMATIONS_MAP[type.toLowerCase()];
  }
  function registerAnimation(type, animation) {
    ANIMATIONS_MAP[type.toLowerCase()] = animation;
  }

  // node_modules/@antv/g2/esm/animate/index.js
  var DEFAULT_ANIMATE_CFG = {
    appear: {
      duration: 450,
      easing: "easeQuadOut"
    },
    update: {
      duration: 400,
      easing: "easeQuadInOut"
    },
    enter: {
      duration: 400,
      easing: "easeQuadInOut"
    },
    leave: {
      duration: 350,
      easing: "easeQuadIn"
    }
  };
  var GEOMETRY_ANIMATE_CFG = {
    interval: function(coordinate) {
      return {
        enter: {
          animation: coordinate.isRect ? coordinate.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
        },
        update: {
          animation: coordinate.isPolar && coordinate.isTransposed ? "sector-path-update" : null
        },
        leave: {
          animation: "fade-out"
        }
      };
    },
    line: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    path: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    point: {
      appear: {
        animation: "zoom-in"
      },
      enter: {
        animation: "zoom-in"
      },
      leave: {
        animation: "zoom-out"
      }
    },
    area: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    polygon: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    schema: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    edge: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    label: {
      appear: {
        animation: "fade-in",
        delay: 450
      },
      enter: {
        animation: "fade-in"
      },
      update: {
        animation: "position-update"
      },
      leave: {
        animation: "fade-out"
      }
    }
  };
  var GEOMETRY_GROUP_APPEAR_ANIMATION = {
    line: function() {
      return {
        animation: "wave-in"
      };
    },
    area: function() {
      return {
        animation: "wave-in"
      };
    },
    path: function() {
      return {
        animation: "fade-in"
      };
    },
    interval: function(coordinate) {
      var animation;
      if (coordinate.isRect) {
        animation = coordinate.isTransposed ? "grow-in-x" : "grow-in-y";
      } else {
        animation = "grow-in-xy";
        if (coordinate.isPolar && coordinate.isTransposed) {
          animation = "wave-in";
        }
      }
      return {
        animation
      };
    },
    schema: function(coordinate) {
      var animation;
      if (coordinate.isRect) {
        animation = coordinate.isTransposed ? "grow-in-x" : "grow-in-y";
      } else {
        animation = "grow-in-xy";
      }
      return {
        animation
      };
    },
    polygon: function() {
      return {
        animation: "fade-in",
        duration: 500
      };
    },
    edge: function() {
      return {
        animation: "fade-in"
      };
    }
  };
  function parseAnimateConfig(animateCfg, data) {
    return {
      delay: is_function_default(animateCfg.delay) ? animateCfg.delay(data) : animateCfg.delay,
      easing: is_function_default(animateCfg.easing) ? animateCfg.easing(data) : animateCfg.easing,
      duration: is_function_default(animateCfg.duration) ? animateCfg.duration(data) : animateCfg.duration,
      callback: animateCfg.callback,
      repeat: animateCfg.repeat
    };
  }
  function getDefaultAnimateCfg(elementName, coordinate, animateType) {
    var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
    if (animateCfg) {
      if (is_function_default(animateCfg)) {
        animateCfg = animateCfg(coordinate);
      }
      animateCfg = deep_mix_default({}, DEFAULT_ANIMATE_CFG, animateCfg);
      if (animateType) {
        return animateCfg[animateType];
      }
    }
    return animateCfg;
  }
  function doAnimate(shape, animateCfg, cfg) {
    var data = get_default(shape.get("origin"), "data", FIELD_ORIGIN);
    var animation = animateCfg.animation;
    var parsedAnimateCfg = parseAnimateConfig(animateCfg, data);
    if (animation) {
      var animateFunction = getAnimation(animation);
      if (animateFunction) {
        animateFunction(shape, parsedAnimateCfg, cfg);
      }
    } else {
      shape.animate(cfg.toAttrs, parsedAnimateCfg);
    }
  }
  function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate, minYPoint) {
    if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
      var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate);
      var animation = getAnimation(get_default(defaultCfg, "animation", ""));
      if (animation) {
        var cfg = __assign(__assign(__assign({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
        container.stopAnimate();
        animation(container, cfg, {
          coordinate,
          minYPoint,
          toAttrs: null
        });
      }
    }
  }

  // node_modules/@antv/g2/esm/geometry/shape/constant.js
  var BACKGROUND_SHAPE = "element-background";

  // node_modules/@antv/g2/esm/geometry/element/index.js
  var Element4 = function(_super) {
    __extends(Element5, _super);
    function Element5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.states = [];
      var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a4 = cfg.visible, visible = _a4 === void 0 ? true : _a4;
      _this.shapeFactory = shapeFactory;
      _this.container = container;
      _this.offscreenGroup = offscreenGroup;
      _this.visible = visible;
      _this.elementIndex = elementIndex;
      return _this;
    }
    Element5.prototype.draw = function(model, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.model = model;
      this.data = model.data;
      this.shapeType = this.getShapeType(model);
      this.drawShape(model, isUpdate);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Element5.prototype.update = function(model) {
      var _a4 = this, shapeFactory = _a4.shapeFactory, shape = _a4.shape;
      if (!shape) {
        return;
      }
      this.model = model;
      this.data = model.data;
      this.shapeType = this.getShapeType(model);
      this.setShapeInfo(shape, model);
      var offscreenGroup = this.getOffscreenGroup();
      var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
      newShape.cfg.data = this.data;
      newShape.cfg.origin = model;
      newShape.cfg.element = this;
      this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
    };
    Element5.prototype.destroy = function() {
      var _a4 = this, shapeFactory = _a4.shapeFactory, shape = _a4.shape;
      if (shape) {
        var animateCfg = this.getAnimateCfg("leave");
        if (animateCfg) {
          doAnimate(shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign({}, shape.attr())
          });
        } else {
          shape.remove(true);
        }
      }
      this.states = [];
      this.shapeFactory = void 0;
      this.container = void 0;
      this.shape = void 0;
      this.animate = void 0;
      this.geometry = void 0;
      this.labelShape = void 0;
      this.model = void 0;
      this.data = void 0;
      this.offscreenGroup = void 0;
      this.statesStyle = void 0;
      _super.prototype.destroy.call(this);
    };
    Element5.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      if (visible) {
        if (this.shape) {
          this.shape.show();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label) {
            label.show();
          });
        }
      } else {
        if (this.shape) {
          this.shape.hide();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label) {
            label.hide();
          });
        }
      }
    };
    Element5.prototype.setState = function(stateName, stateStatus) {
      var _a4 = this, states = _a4.states, shapeFactory = _a4.shapeFactory, model = _a4.model, shape = _a4.shape, shapeType = _a4.shapeType;
      var index = states.indexOf(stateName);
      if (stateStatus) {
        if (index > -1) {
          return;
        }
        states.push(stateName);
        if (stateName === "active" || stateName === "selected") {
          shape === null || shape === void 0 ? void 0 : shape.toFront();
        }
      } else {
        if (index === -1) {
          return;
        }
        states.splice(index, 1);
        if (stateName === "active" || stateName === "selected") {
          if (this.geometry.zIndexReversed) {
            shape.setZIndex(this.geometry.elements.length - this.elementIndex);
          } else {
            shape.setZIndex(this.elementIndex);
          }
        }
      }
      var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
      if (states.length) {
        this.syncShapeStyle(shape, offscreenShape, states, null);
      } else {
        this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
      }
      offscreenShape.remove(true);
      var eventObject = {
        state: stateName,
        stateStatus,
        element: this,
        target: this.container
      };
      this.container.emit("statechange", eventObject);
      propagationDelegate(this.shape, "statechange", eventObject);
    };
    Element5.prototype.clearStates = function() {
      var _this = this;
      var states = this.states;
      each_default(states, function(state) {
        _this.setState(state, false);
      });
      this.states = [];
    };
    Element5.prototype.hasState = function(stateName) {
      return this.states.includes(stateName);
    };
    Element5.prototype.getStates = function() {
      return this.states;
    };
    Element5.prototype.getData = function() {
      return this.data;
    };
    Element5.prototype.getModel = function() {
      return this.model;
    };
    Element5.prototype.getBBox = function() {
      var _a4 = this, shape = _a4.shape, labelShape = _a4.labelShape;
      var bbox = {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
      if (shape) {
        bbox = shape.getCanvasBBox();
      }
      if (labelShape) {
        labelShape.forEach(function(label) {
          var labelBBox = label.getCanvasBBox();
          bbox.x = Math.min(labelBBox.x, bbox.x);
          bbox.y = Math.min(labelBBox.y, bbox.y);
          bbox.minX = Math.min(labelBBox.minX, bbox.minX);
          bbox.minY = Math.min(labelBBox.minY, bbox.minY);
          bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
          bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
        });
      }
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      return bbox;
    };
    Element5.prototype.getStatesStyle = function() {
      if (!this.statesStyle) {
        var _a4 = this, shapeType = _a4.shapeType, geometry = _a4.geometry, shapeFactory = _a4.shapeFactory;
        var stateOption = geometry.stateOption;
        var defaultShapeType = shapeFactory.defaultShapeType;
        var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
        this.statesStyle = deep_mix_default({}, stateTheme, stateOption);
      }
      return this.statesStyle;
    };
    Element5.prototype.getStateStyle = function(stateName, shapeKey) {
      var statesStyle = this.getStatesStyle();
      var stateCfg = get_default(statesStyle, [stateName, "style"], {});
      var shapeStyle = stateCfg[shapeKey] || stateCfg;
      if (is_function_default(shapeStyle)) {
        return shapeStyle(this);
      }
      return shapeStyle;
    };
    Element5.prototype.getAnimateCfg = function(animateType) {
      var _this = this;
      var animate = this.animate;
      if (animate) {
        var cfg_1 = animate[animateType];
        if (cfg_1) {
          return __assign(__assign({}, cfg_1), { callback: function() {
            var _a4;
            is_function_default(cfg_1.callback) && cfg_1.callback();
            (_a4 = _this.geometry) === null || _a4 === void 0 ? void 0 : _a4.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
          } });
        }
        return cfg_1;
      }
      return null;
    };
    Element5.prototype.drawShape = function(model, isUpdate) {
      var _a4;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
      this.shape = shapeFactory.drawShape(shapeType, model, container);
      if (this.shape) {
        this.setShapeInfo(this.shape, model);
        var name_1 = this.shape.cfg.name;
        if (!name_1) {
          this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
        } else if (is_string_default(name_1)) {
          this.shape.cfg.name = ["element", name_1];
        }
        var animateType = isUpdate ? "enter" : "appear";
        var animateCfg = this.getAnimateCfg(animateType);
        if (animateCfg) {
          (_a4 = this.geometry) === null || _a4 === void 0 ? void 0 : _a4.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(this.shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign({}, this.shape.attr())
          });
        }
      }
    };
    Element5.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Element5.prototype.setShapeInfo = function(shape, data) {
      var _this = this;
      shape.cfg.origin = data;
      shape.cfg.element = this;
      if (shape.isGroup()) {
        var children = shape.get("children");
        children.forEach(function(child) {
          _this.setShapeInfo(child, data);
        });
      }
    };
    Element5.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index) {
      var _this = this;
      var _a4;
      if (states === void 0) {
        states = [];
      }
      if (index === void 0) {
        index = 0;
      }
      if (!sourceShape || !targetShape) {
        return;
      }
      var clip = sourceShape.get("clipShape");
      var newClip = targetShape.get("clipShape");
      this.syncShapeStyle(clip, newClip, states, animateCfg);
      if (sourceShape.isGroup()) {
        var children = sourceShape.get("children");
        var newChildren = targetShape.get("children");
        for (var i = 0; i < children.length; i++) {
          this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
        }
      } else {
        if (!is_empty_default(states) && !is_equal_default(states, ["reset"])) {
          var name_2 = sourceShape.get("name");
          if (is_array_default(name_2)) {
            name_2 = name_2[1];
          }
          each_default(states, function(state) {
            if (targetShape.get("name") !== BACKGROUND_SHAPE) {
              var style = _this.getStateStyle(state, name_2 || index);
              targetShape.attr(style);
            }
          });
        }
        var newAttrs = getReplaceAttrs(sourceShape, targetShape);
        if (this.animate) {
          if (animateCfg) {
            (_a4 = this.geometry) === null || _a4 === void 0 ? void 0 : _a4.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
            doAnimate(sourceShape, animateCfg, {
              coordinate: this.shapeFactory.coordinate,
              toAttrs: newAttrs,
              shapeModel: this.model
            });
          } else if (!is_empty_default(states)) {
            sourceShape.stopAnimate();
            sourceShape.animate(newAttrs, {
              duration: 300
            });
          } else {
            sourceShape.attr(newAttrs);
          }
        } else {
          sourceShape.attr(newAttrs);
        }
      }
    };
    Element5.prototype.getShapeType = function(model) {
      var shape = get_default(model, "shape");
      return is_array_default(shape) ? shape[0] : shape;
    };
    return Element5;
  }(base_default);
  var element_default3 = Element4;

  // node_modules/@antv/g2/esm/geometry/label/index.js
  var GEOMETRY_LABELS_MAP = {};
  var GEOMETRY_LABELS_LAYOUT_MAP = {};
  function getGeometryLabel(type) {
    return GEOMETRY_LABELS_MAP[type.toLowerCase()];
  }
  function registerGeometryLabel(type, ctor) {
    GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
  }
  function getGeometryLabelLayout(type) {
    return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
  }
  function registerGeometryLabelLayout(type, layoutFn) {
    GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
  }

  // node_modules/@antv/g2/esm/geometry/shape/base.js
  var ShapeFactoryBase = {
    coordinate: null,
    defaultShapeType: null,
    theme: null,
    getShapePoints: function(shapeType, shapePoint) {
      var shape = this.getShape(shapeType);
      if (shape.getPoints) {
        return shape.getPoints(shapePoint);
      }
      return this.getDefaultPoints(shapePoint);
    },
    getShape: function(shapeType) {
      var shape = this[shapeType] || this[this.defaultShapeType];
      shape.coordinate = this.coordinate;
      return shape;
    },
    getDefaultPoints: function() {
      return [];
    },
    getDefaultStyle: function(geometryTheme) {
      return get_default(geometryTheme, [this.defaultShapeType, "default", "style"], {});
    },
    getMarker: function(shapeType, markerCfg) {
      var shape = this.getShape(shapeType);
      if (!shape.getMarker) {
        var defaultShapeType = this.defaultShapeType;
        shape = this.getShape(defaultShapeType);
      }
      var theme = this.theme;
      var shapeStyle = get_default(theme, [shapeType, "default"], {});
      var markerStyle = shape.getMarker(markerCfg);
      return deep_mix_default({}, shapeStyle, markerStyle);
    },
    drawShape: function(shapeType, cfg, container) {
      var shape = this.getShape(shapeType);
      return shape.draw(cfg, container);
    }
  };
  var ShapeBase = {
    coordinate: null,
    parsePath: function(path) {
      var coordinate = this.coordinate;
      var parsedPath = parsePathString2(path);
      if (coordinate.isPolar) {
        parsedPath = convertPolarPath(coordinate, parsedPath);
      } else {
        parsedPath = convertNormalPath(coordinate, parsedPath);
      }
      return parsedPath;
    },
    parsePoint: function(point) {
      var coordinate = this.coordinate;
      return coordinate.convert(point);
    },
    parsePoints: function(points) {
      var coordinate = this.coordinate;
      return points.map(function(point) {
        return coordinate.convert(point);
      });
    },
    draw: function(cfg, container) {
    }
  };
  var ShapeFactoryMap = {};
  function registerShapeFactory(factoryName, cfg) {
    var className = upper_first_default(factoryName);
    var geomObj = __assign(__assign(__assign({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
    ShapeFactoryMap[className] = geomObj;
    return geomObj;
  }
  function registerShape(factoryName, shapeType, cfg) {
    var className = upper_first_default(factoryName);
    var factory = ShapeFactoryMap[className];
    var shapeObj = __assign(__assign({}, ShapeBase), cfg);
    factory[shapeType] = shapeObj;
    return shapeObj;
  }
  function getShapeFactory(factoryName) {
    var className = upper_first_default(factoryName);
    return ShapeFactoryMap[className];
  }

  // node_modules/@antv/g2/esm/geometry/util/group-data.js
  function group(data, fields, appendConditions) {
    if (appendConditions === void 0) {
      appendConditions = {};
    }
    if (!fields) {
      return [data];
    }
    var groups = groupToMap(data, fields);
    var array = [];
    if (fields.length === 1 && appendConditions[fields[0]]) {
      var values2 = appendConditions[fields[0]];
      for (var _i = 0, values_1 = values2; _i < values_1.length; _i++) {
        var value = values_1[_i];
        var arr = groups["_" + value];
        if (arr) {
          array.push(arr);
        }
      }
    } else {
      for (var k in groups) {
        if (groups.hasOwnProperty(k)) {
          var eachGroup = groups[k];
          array.push(eachGroup);
        }
      }
    }
    return array;
  }

  // node_modules/@antv/g2/esm/geometry/util/is-model-change.js
  function isModelChange(currentModel, preModel) {
    return some_default(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key) {
      return !is_equal_default(currentModel[key], preModel[key]);
    });
  }

  // node_modules/@antv/g2/esm/geometry/util/parse-fields.js
  function parseFields(field) {
    if (is_array_default(field)) {
      return field;
    }
    return field.split("*");
  }

  // node_modules/@antv/g2/esm/geometry/util/diff.js
  function diff(keyItem, keys2) {
    var added = [];
    var updated = [];
    var removed = [];
    var keyIncluded = new Map();
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (keyItem[key])
        updated.push(key);
      else
        added.push(key);
      keyIncluded.set(key, true);
    }
    Object.keys(keyItem).forEach(function(key2) {
      if (!keyIncluded.has(key2))
        removed.push(key2);
    });
    return {
      added,
      updated,
      removed
    };
  }

  // node_modules/@antv/g2/esm/geometry/base.js
  function filterLabelsById(id, labelsMap) {
    var labels = [];
    each_default(labelsMap, function(label, labelId) {
      var elementId = labelId.split(" ")[0];
      if (elementId === id) {
        labels.push(label);
      }
    });
    return labels;
  }
  var Geometry = function(_super) {
    __extends(Geometry2, _super);
    function Geometry2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "base";
      _this.attributes = {};
      _this.elements = [];
      _this.elementsMap = {};
      _this.animateOption = true;
      _this.attributeOption = {};
      _this.lastElementsMap = {};
      _this.generatePoints = false;
      _this.beforeMappingData = null;
      _this.adjusts = {};
      _this.idFields = [];
      _this.hasSorted = false;
      _this.isCoordinateChanged = false;
      var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate = cfg.coordinate, data = cfg.data, _a4 = cfg.sortable, sortable = _a4 === void 0 ? false : _a4, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed;
      _this.container = container;
      _this.labelsContainer = labelsContainer;
      _this.coordinate = coordinate;
      _this.data = data;
      _this.sortable = sortable;
      _this.visible = visible;
      _this.userTheme = theme;
      _this.scales = scales;
      _this.scaleDefs = scaleDefs;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.roseWidthRatio = roseWidthRatio;
      _this.multiplePieWidthRatio = multiplePieWidthRatio;
      _this.zIndexReversed = zIndexReversed;
      return _this;
    }
    Geometry2.prototype.position = function(cfg) {
      var positionCfg = cfg;
      if (!is_plain_object_default(cfg)) {
        positionCfg = {
          fields: parseFields(cfg)
        };
      }
      var fields = get_default(positionCfg, "fields");
      if (fields.length === 1) {
        fields.unshift("1");
        set_default(positionCfg, "fields", fields);
      }
      set_default(this.attributeOption, "position", positionCfg);
      return this;
    };
    Geometry2.prototype.color = function(field, cfg) {
      this.createAttrOption("color", field, cfg);
      return this;
    };
    Geometry2.prototype.shape = function(field, cfg) {
      this.createAttrOption("shape", field, cfg);
      return this;
    };
    Geometry2.prototype.size = function(field, cfg) {
      this.createAttrOption("size", field, cfg);
      return this;
    };
    Geometry2.prototype.adjust = function(adjustCfg) {
      var adjusts = adjustCfg;
      if (is_string_default(adjustCfg) || is_plain_object_default(adjustCfg)) {
        adjusts = [adjustCfg];
      }
      each_default(adjusts, function(adjust, index) {
        if (!is_object_default(adjust)) {
          adjusts[index] = { type: adjust };
        }
      });
      this.adjustOption = adjusts;
      return this;
    };
    Geometry2.prototype.style = function(field, styleFunc) {
      if (is_string_default(field)) {
        var fields = parseFields(field);
        this.styleOption = {
          fields,
          callback: styleFunc
        };
      } else {
        var _a4 = field, fields = _a4.fields, callback = _a4.callback, cfg = _a4.cfg;
        if (fields || callback || cfg) {
          this.styleOption = field;
        } else {
          this.styleOption = {
            cfg: field
          };
        }
      }
      return this;
    };
    Geometry2.prototype.tooltip = function(field, cfg) {
      if (is_string_default(field)) {
        var fields = parseFields(field);
        this.tooltipOption = {
          fields,
          callback: cfg
        };
      } else {
        this.tooltipOption = field;
      }
      return this;
    };
    Geometry2.prototype.animate = function(cfg) {
      this.animateOption = cfg;
      return this;
    };
    Geometry2.prototype.label = function(field, secondParam, thirdParam) {
      if (is_string_default(field)) {
        var labelOption = {};
        var fields = parseFields(field);
        labelOption.fields = fields;
        if (is_function_default(secondParam)) {
          labelOption.callback = secondParam;
        } else if (is_plain_object_default(secondParam)) {
          labelOption.cfg = secondParam;
        }
        if (thirdParam) {
          labelOption.cfg = thirdParam;
        }
        this.labelOption = labelOption;
      } else {
        this.labelOption = field;
      }
      return this;
    };
    Geometry2.prototype.state = function(cfg) {
      this.stateOption = cfg;
      return this;
    };
    Geometry2.prototype.customInfo = function(cfg) {
      this.customOption = cfg;
      return this;
    };
    Geometry2.prototype.init = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(this.data);
      this.adjustScale();
    };
    Geometry2.prototype.update = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      var data = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
      var _a4 = this, attributeOption = _a4.attributeOption, lastAttributeOption = _a4.lastAttributeOption;
      if (!is_equal_default(attributeOption, lastAttributeOption)) {
        this.init(cfg);
      } else if (data && (isDataChanged || !is_equal_default(data, this.data))) {
        this.setCfg(cfg);
        this.initAttributes();
        this.processData(data);
      } else {
        this.setCfg(cfg);
      }
      this.adjustScale();
      this.isCoordinateChanged = isCoordinateChanged;
    };
    Geometry2.prototype.paint = function(isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      if (this.animateOption) {
        this.animateOption = deep_mix_default({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
      }
      this.defaultSize = void 0;
      this.elementsMap = {};
      this.elements = [];
      var offscreenGroup = this.getOffscreenGroup();
      offscreenGroup.clear();
      var beforeMappingData = this.beforeMappingData;
      var dataArray = this.beforeMapping(beforeMappingData);
      this.dataArray = new Array(dataArray.length);
      for (var i = 0; i < dataArray.length; i++) {
        var data = dataArray[i];
        this.dataArray[i] = this.mapping(data);
      }
      this.updateElements(this.dataArray, isUpdate);
      this.lastElementsMap = this.elementsMap;
      if (this.canDoGroupAnimation(isUpdate)) {
        var container = this.container;
        var type = this.type;
        var coordinate = this.coordinate;
        var animateCfg = get_default(this.animateOption, "appear");
        var yScale = this.getYScale();
        var yMinPoint = coordinate.convert({
          x: 0,
          y: yScale.scale(this.getYMinValue())
        });
        doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);
      }
      if (this.labelOption) {
        this.renderLabels(flatten_default(this.dataArray), isUpdate);
      }
      this.lastAttributeOption = __assign({}, this.attributeOption);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Geometry2.prototype.clear = function() {
      var _a4 = this, container = _a4.container, geometryLabel = _a4.geometryLabel, offscreenGroup = _a4.offscreenGroup;
      if (container) {
        container.clear();
      }
      if (geometryLabel) {
        geometryLabel.clear();
      }
      if (offscreenGroup) {
        offscreenGroup.clear();
      }
      this.scaleDefs = void 0;
      this.attributes = {};
      this.scales = {};
      this.elementsMap = {};
      this.lastElementsMap = {};
      this.elements = [];
      this.adjusts = {};
      this.dataArray = null;
      this.beforeMappingData = null;
      this.lastAttributeOption = void 0;
      this.defaultSize = void 0;
      this.idFields = [];
      this.groupScales = void 0;
      this.hasSorted = false;
      this.isCoordinateChanged = false;
    };
    Geometry2.prototype.destroy = function() {
      this.clear();
      var container = this.container;
      container.remove(true);
      if (this.offscreenGroup) {
        this.offscreenGroup.remove(true);
        this.offscreenGroup = null;
      }
      if (this.geometryLabel) {
        this.geometryLabel.destroy();
        this.geometryLabel = null;
      }
      this.theme = void 0;
      this.shapeFactory = void 0;
      _super.prototype.destroy.call(this);
    };
    Geometry2.prototype.getGroupScales = function() {
      return this.groupScales;
    };
    Geometry2.prototype.getAttribute = function(name) {
      return this.attributes[name];
    };
    Geometry2.prototype.getXScale = function() {
      return this.getAttribute("position").scales[0];
    };
    Geometry2.prototype.getYScale = function() {
      return this.getAttribute("position").scales[1];
    };
    Geometry2.prototype.getGroupAttributes = function() {
      var rst = [];
      each_default(this.attributes, function(attr) {
        if (GROUP_ATTRS.includes(attr.type)) {
          rst.push(attr);
        }
      });
      return rst;
    };
    Geometry2.prototype.getDefaultValue = function(attrName) {
      var value;
      var attr = this.getAttribute(attrName);
      if (attr && is_empty_default(attr.scales)) {
        value = attr.values[0];
      }
      return value;
    };
    Geometry2.prototype.getAttributeValues = function(attr, obj) {
      var params = [];
      var scales = attr.scales;
      for (var index = 0, length_1 = scales.length; index < length_1; index++) {
        var scale4 = scales[index];
        var field = scale4.field;
        if (scale4.isIdentity) {
          params.push(scale4.values);
        } else {
          params.push(obj[field]);
        }
      }
      return attr.mapping.apply(attr, params);
    };
    Geometry2.prototype.getAdjust = function(adjustType) {
      return this.adjusts[adjustType];
    };
    Geometry2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    Geometry2.prototype.getData = function() {
      return this.data;
    };
    Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
      var shapeFactory = this.getShapeFactory();
      return shapeFactory.getMarker(shapeName, cfg);
    };
    Geometry2.prototype.getElementsBy = function(condition) {
      return this.elements.filter(function(element) {
        return condition(element);
      });
    };
    Geometry2.prototype.getElements = function() {
      return this.elements;
    };
    Geometry2.prototype.getElementId = function(data) {
      data = is_array_default(data) ? data[0] : data;
      var originData = data[FIELD_ORIGIN];
      if (this.idFields.length) {
        var elementId = originData[this.idFields[0]];
        for (var index = 1; index < this.idFields.length; index++) {
          elementId += "-" + originData[this.idFields[index]];
        }
        return elementId;
      }
      var type = this.type;
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field || "x";
      var yField = yScale.field || "y";
      var yVal = originData[yField];
      var xVal;
      if (xScale.type === "identity") {
        xVal = xScale.values[0];
      } else {
        xVal = originData[xField];
      }
      var id;
      if (type === "interval" || type === "schema") {
        id = "" + xVal;
      } else if (type === "line" || type === "area" || type === "path") {
        id = type;
      } else {
        id = xVal + "-" + yVal;
      }
      var groupScales = this.groupScales;
      if (is_empty_default(groupScales)) {
        groupScales = get_default(this.getAttribute("color"), "scales", []);
      }
      for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
        var groupScale = groupScales[index];
        var field = groupScale.field;
        id = id + "-" + originData[field];
      }
      var dodgeAdjust = this.getAdjust("dodge");
      if (dodgeAdjust) {
        var dodgeBy = dodgeAdjust.dodgeBy;
        if (dodgeBy) {
          id = id + "-" + originData[dodgeBy];
        }
      }
      if (this.getAdjust("jitter")) {
        id = id + "-" + data.x + "-" + data.y;
      }
      return id;
    };
    Geometry2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = new Map();
      var _a4 = this, attributeOption = _a4.attributeOption, labelOption = _a4.labelOption, tooltipOption = _a4.tooltipOption;
      for (var attributeType in attributeOption) {
        if (attributeOption.hasOwnProperty(attributeType)) {
          var eachOpt = attributeOption[attributeType];
          if (eachOpt.fields) {
            uniq2(eachOpt.fields, fields, tmpMap);
          } else if (eachOpt.values) {
            uniq2(eachOpt.values, fields, tmpMap);
          }
        }
      }
      if (labelOption && labelOption.fields) {
        uniq2(labelOption.fields, fields, tmpMap);
      }
      if (is_object_default(tooltipOption) && tooltipOption.fields) {
        uniq2(tooltipOption.fields, fields, tmpMap);
      }
      return fields;
    };
    Geometry2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var elements = this.elements;
      for (var index = 0, length_3 = elements.length; index < length_3; index++) {
        var element = elements[index];
        element.changeVisible(visible);
      }
      if (visible) {
        if (this.container) {
          this.container.show();
        }
        if (this.labelsContainer) {
          this.labelsContainer.show();
        }
      } else {
        if (this.container) {
          this.container.hide();
        }
        if (this.labelsContainer) {
          this.labelsContainer.hide();
        }
      }
    };
    Geometry2.prototype.getFields = function() {
      var uniqMap = new Map();
      var fields = [];
      Object.values(this.attributeOption).forEach(function(cfg) {
        var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
        fs.forEach(function(f) {
          if (!uniqMap.has(f)) {
            fields.push(f);
          }
          uniqMap.set(f, true);
        });
      }, []);
      return fields;
    };
    Geometry2.prototype.getGroupFields = function() {
      var groupFields = [];
      var tmpMap = new Map();
      for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {
        var attributeName = GROUP_ATTRS[index];
        var cfg = this.attributeOption[attributeName];
        if (cfg && cfg.fields) {
          uniq2(cfg.fields, groupFields, tmpMap);
        }
      }
      return groupFields;
    };
    Geometry2.prototype.getXYFields = function() {
      var _a4 = this.attributeOption.position.fields, x = _a4[0], y = _a4[1];
      return [x, y];
    };
    Geometry2.prototype.getXField = function() {
      return get_default(this.getXYFields(), [0]);
    };
    Geometry2.prototype.getYField = function() {
      return get_default(this.getXYFields(), [1]);
    };
    Geometry2.prototype.getShapes = function() {
      return this.elements.map(function(element) {
        return element.shape;
      });
    };
    Geometry2.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Geometry2.prototype.sort = function(mappingArray) {
      if (!this.hasSorted) {
        var xScale_1 = this.getXScale();
        var xField_1 = xScale_1.field;
        for (var index = 0; index < mappingArray.length; index++) {
          var itemArr = mappingArray[index];
          itemArr.sort(function(obj1, obj2) {
            return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
          });
        }
      }
      this.hasSorted = true;
    };
    Geometry2.prototype.adjustScale = function() {
      var yScale = this.getYScale();
      if (yScale && this.getAdjust("stack")) {
        this.updateStackRange(yScale, this.beforeMappingData);
      }
    };
    Geometry2.prototype.getShapeFactory = function() {
      var shapeType = this.shapeType;
      if (!getShapeFactory(shapeType)) {
        return;
      }
      if (!this.shapeFactory) {
        this.shapeFactory = clone_default(getShapeFactory(shapeType));
      }
      this.shapeFactory.coordinate = this.coordinate;
      this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
      return this.shapeFactory;
    };
    Geometry2.prototype.createShapePointsCfg = function(obj) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var x = this.normalizeValues(obj[xScale.field], xScale);
      var y;
      if (yScale) {
        y = this.normalizeValues(obj[yScale.field], yScale);
      } else {
        y = obj.y ? obj.y : 0.1;
      }
      return {
        x,
        y,
        y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
      };
    };
    Geometry2.prototype.createElement = function(mappingDatum, index, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var container = this.container;
      var shapeCfg = this.getDrawCfg(mappingDatum);
      var shapeFactory = this.getShapeFactory();
      var element = new element_default3({
        shapeFactory,
        container,
        offscreenGroup: this.getOffscreenGroup(),
        elementIndex: index
      });
      element.animate = this.animateOption;
      element.geometry = this;
      element.draw(shapeCfg, isUpdate);
      return element;
    };
    Geometry2.prototype.getDrawCfg = function(mappingDatum) {
      var originData = mappingDatum[FIELD_ORIGIN];
      var cfg = {
        mappingData: mappingDatum,
        data: originData,
        x: mappingDatum.x,
        y: mappingDatum.y,
        color: mappingDatum.color,
        size: mappingDatum.size,
        isInCircle: this.coordinate.isPolar,
        customInfo: this.customOption
      };
      var shapeName = mappingDatum.shape;
      if (!shapeName && this.getShapeFactory()) {
        shapeName = this.getShapeFactory().defaultShapeType;
      }
      cfg.shape = shapeName;
      var theme = this.theme.geometries[this.shapeType];
      cfg.defaultStyle = get_default(theme, [shapeName, "default"], {}).style;
      if (!cfg.defaultStyle && this.getShapeFactory()) {
        cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);
      }
      var styleOption = this.styleOption;
      if (styleOption) {
        cfg.style = this.getStyleCfg(styleOption, originData);
      }
      if (this.generatePoints) {
        cfg.points = mappingDatum.points;
        cfg.nextPoints = mappingDatum.nextPoints;
      }
      return cfg;
    };
    Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyDatum = new Map();
      var keys2 = [];
      var keyIndex = new Map();
      var index = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        for (var j = 0; j < mappingData.length; j++) {
          var mappingDatum = mappingData[j];
          var key = this.getElementId(mappingDatum);
          var finalKey = keyDatum.has(key) ? key + "-" + i + "-" + j : key;
          keys2.push(finalKey);
          keyDatum.set(finalKey, mappingDatum);
          keyIndex.set(finalKey, index);
          index++;
        }
      }
      this.elements = new Array(index);
      var _a4 = diff(this.lastElementsMap, keys2), added = _a4.added, updated = _a4.updated, removed = _a4.removed;
      for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
        var key = added_1[_i];
        var mappingDatum = keyDatum.get(key);
        var i = keyIndex.get(key);
        var element = this.createElement(mappingDatum, i, isUpdate);
        this.elements[i] = element;
        this.elementsMap[key] = element;
        if (element.shape) {
          element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
        }
      }
      for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
        var key = updated_1[_b];
        var element = this.lastElementsMap[key];
        var mappingDatum = keyDatum.get(key);
        var currentShapeCfg = this.getDrawCfg(mappingDatum);
        var preShapeCfg = element.getModel();
        var i = keyIndex.get(key);
        if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
          element.animate = this.animateOption;
          element.update(currentShapeCfg);
        }
        this.elements[i] = element;
        this.elementsMap[key] = element;
        if (element.shape) {
          element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
        }
      }
      for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
        var key = removed_1[_c];
        var element = this.lastElementsMap[key];
        element.animate = this.animateOption;
        element.destroy();
      }
    };
    Geometry2.prototype.getLabelType = function() {
      var _a4 = this, labelOption = _a4.labelOption, coordinate = _a4.coordinate, type = _a4.type;
      var coordinateType = coordinate.type, isTransposed = coordinate.isTransposed;
      var labelType = get_default(labelOption, ["cfg", "type"]);
      if (!labelType) {
        if (coordinateType === "polar") {
          labelType = isTransposed ? "pie" : "polar";
        } else if (coordinateType === "theta") {
          labelType = "pie";
        } else if (type === "interval" || type === "polygon") {
          labelType = "interval";
        } else {
          labelType = "base";
        }
      }
      return labelType;
    };
    Geometry2.prototype.getYMinValue = function() {
      var yScale = this.getYScale();
      var min3 = yScale.min, max3 = yScale.max;
      var value;
      if (min3 >= 0) {
        value = min3;
      } else if (max3 <= 0) {
        value = max3;
      } else {
        value = 0;
      }
      return value;
    };
    Geometry2.prototype.createAttrOption = function(attrName, field, cfg) {
      if (is_nil_default(field) || is_object_default(field)) {
        if (is_object_default(field) && is_equal_default(Object.keys(field), ["values"])) {
          set_default(this.attributeOption, attrName, {
            fields: field.values
          });
        } else {
          set_default(this.attributeOption, attrName, field);
        }
      } else {
        var attrCfg = {};
        if (is_number_default(field)) {
          attrCfg.values = [field];
        } else {
          attrCfg.fields = parseFields(field);
        }
        if (cfg) {
          if (is_function_default(cfg)) {
            attrCfg.callback = cfg;
          } else {
            attrCfg.values = cfg;
          }
        }
        set_default(this.attributeOption, attrName, attrCfg);
      }
    };
    Geometry2.prototype.initAttributes = function() {
      var _this = this;
      var _a4 = this, attributes = _a4.attributes, attributeOption = _a4.attributeOption, theme = _a4.theme, shapeType = _a4.shapeType;
      this.groupScales = [];
      var tmpMap = {};
      var _loop_1 = function(attrType2) {
        if (attributeOption.hasOwnProperty(attrType2)) {
          var option = attributeOption[attrType2];
          if (!option) {
            return { value: void 0 };
          }
          var attrCfg = __assign({}, option);
          var callback = attrCfg.callback, values2 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
          var scales = fields.map(function(field) {
            var scale4 = _this.scales[field];
            if (scale4.isCategory && !tmpMap[field] && GROUP_ATTRS.includes(attrType2)) {
              _this.groupScales.push(scale4);
              tmpMap[field] = true;
            }
            return scale4;
          });
          attrCfg.scales = scales;
          if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
            attrCfg.values = scales[0].values;
          } else if (!callback && !values2) {
            if (attrType2 === "size") {
              attrCfg.values = theme.sizes;
            } else if (attrType2 === "shape") {
              attrCfg.values = theme.shapes[shapeType] || [];
            } else if (attrType2 === "color") {
              if (scales.length) {
                attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;
              } else {
                attrCfg.values = theme.colors10;
              }
            }
          }
          var AttributeCtor = getAttribute(attrType2);
          attributes[attrType2] = new AttributeCtor(attrCfg);
        }
      };
      for (var attrType in attributeOption) {
        var state_1 = _loop_1(attrType);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    };
    Geometry2.prototype.processData = function(data) {
      this.hasSorted = false;
      var scales = this.getAttribute("position").scales;
      var categoryScales = scales.filter(function(scale5) {
        return scale5.isCategory;
      });
      var groupedArray = this.groupData(data);
      var beforeAdjust = [];
      for (var i = 0, len3 = groupedArray.length; i < len3; i++) {
        var subData = groupedArray[i];
        var arr = [];
        for (var j = 0, subLen = subData.length; j < subLen; j++) {
          var originData = subData[j];
          var item = {};
          for (var k in originData) {
            item[k] = originData[k];
          }
          item[FIELD_ORIGIN] = originData;
          for (var _i = 0, categoryScales_1 = categoryScales; _i < categoryScales_1.length; _i++) {
            var scale4 = categoryScales_1[_i];
            var field = scale4.field;
            item[field] = scale4.translate(item[field]);
          }
          arr.push(item);
        }
        beforeAdjust.push(arr);
      }
      var dataArray = this.adjustData(beforeAdjust);
      this.beforeMappingData = dataArray;
      return dataArray;
    };
    Geometry2.prototype.adjustData = function(dataArray) {
      var adjustOption = this.adjustOption;
      var _a4 = this, intervalPadding = _a4.intervalPadding, dodgePadding = _a4.dodgePadding, theme = _a4.theme;
      var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;
      var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;
      var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;
      var result = dataArray;
      if (adjustOption) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xField = xScale.field;
        var yField = yScale ? yScale.field : null;
        var xDimensionLength = getXDimensionLength(this.coordinate);
        var groupNum = xScale.values.length;
        var sizeAttr = this.getAttribute("size");
        var defaultSize = void 0;
        if (sizeAttr) {
          defaultSize = sizeAttr.values[0];
        }
        for (var i = 0, len3 = adjustOption.length; i < len3; i++) {
          var adjust = adjustOption[i];
          var adjustCfg = __assign({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust);
          var type = adjust.type;
          if (type === "dodge") {
            var adjustNames = [];
            if (xScale.isCategory || xScale.type === "identity") {
              adjustNames.push("x");
            } else if (!yScale) {
              adjustNames.push("y");
            } else {
              throw new Error("dodge is not support linear attribute, please use category attribute!");
            }
            adjustCfg.adjustNames = adjustNames;
            adjustCfg.dodgeRatio = columnWidthRatio;
          } else if (type === "stack") {
            var coordinate = this.coordinate;
            if (!yScale) {
              adjustCfg.height = coordinate.getHeight();
              var size3 = this.getDefaultValue("size") || 3;
              adjustCfg.size = size3;
            }
            if (!coordinate.isTransposed && is_nil_default(adjustCfg.reverseOrder)) {
              adjustCfg.reverseOrder = true;
            }
          }
          var adjustCtor = getAdjust(type);
          var adjustInstance = new adjustCtor(adjustCfg);
          result = adjustInstance.process(result);
          this.adjusts[type] = adjustInstance;
        }
      }
      return result;
    };
    Geometry2.prototype.groupData = function(data) {
      var groupScales = this.getGroupScales();
      var scaleDefs = this.scaleDefs;
      var appendConditions = {};
      var groupFields = [];
      for (var index = 0; index < groupScales.length; index++) {
        var scale4 = groupScales[index];
        var field = scale4.field;
        groupFields.push(field);
        if (get_default(scaleDefs, [field, "values"])) {
          appendConditions[field] = scaleDefs[field].values;
        }
      }
      return group(data, groupFields, appendConditions);
    };
    Geometry2.prototype.updateStackRange = function(scale4, dataArray) {
      var mergeArray = flatten_default(dataArray);
      var field = scale4.field;
      var min3 = scale4.min;
      var max3 = scale4.max;
      for (var index = 0; index < mergeArray.length; index++) {
        var obj = mergeArray[index];
        var tmpMin = Math.min.apply(null, obj[field]);
        var tmpMax = Math.max.apply(null, obj[field]);
        if (tmpMin < min3) {
          min3 = tmpMin;
        }
        if (tmpMax > max3) {
          max3 = tmpMax;
        }
      }
      var scaleDefs = this.scaleDefs;
      var cfg = {};
      if (min3 < scale4.min && !get_default(scaleDefs, [field, "min"])) {
        cfg.min = min3;
      }
      if (max3 > scale4.max && !get_default(scaleDefs, [field, "max"])) {
        cfg.max = max3;
      }
      scale4.change(cfg);
    };
    Geometry2.prototype.beforeMapping = function(beforeMappingData) {
      var source = beforeMappingData;
      if (this.sortable) {
        this.sort(source);
      }
      if (this.generatePoints) {
        for (var index = 0, length_5 = source.length; index < length_5; index++) {
          var currentData = source[index];
          this.generateShapePoints(currentData);
          var nextData = source[index + 1];
          if (nextData) {
            this.generateShapePoints(nextData);
            currentData[0].nextPoints = nextData[0].points;
          }
        }
      }
      return source;
    };
    Geometry2.prototype.generateShapePoints = function(data) {
      var shapeFactory = this.getShapeFactory();
      var shapeAttr = this.getAttribute("shape");
      for (var index = 0; index < data.length; index++) {
        var obj = data[index];
        var cfg = this.createShapePointsCfg(obj);
        var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
        var points = shapeFactory.getShapePoints(shape, cfg);
        obj.points = points;
      }
    };
    Geometry2.prototype.normalizeValues = function(values2, scale4) {
      var rst = [];
      if (is_array_default(values2)) {
        for (var index = 0; index < values2.length; index++) {
          var value = values2[index];
          rst.push(scale4.scale(value));
        }
      } else {
        rst = scale4.scale(values2);
      }
      return rst;
    };
    Geometry2.prototype.mapping = function(data) {
      var attributes = this.attributes;
      var mappingData = [];
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var newRecord = {
          _origin: record[FIELD_ORIGIN],
          points: record.points,
          nextPoints: record.nextPoints
        };
        for (var k in attributes) {
          if (attributes.hasOwnProperty(k)) {
            var attr = attributes[k];
            var names = attr.names;
            var values2 = this.getAttributeValues(attr, record);
            if (names.length > 1) {
              for (var j = 0; j < values2.length; j += 1) {
                var val = values2[j];
                var name_1 = names[j];
                newRecord[name_1] = is_array_default(val) && val.length === 1 ? val[0] : val;
              }
            } else {
              newRecord[names[0]] = values2.length === 1 ? values2[0] : values2;
            }
          }
        }
        this.convertPoint(newRecord);
        mappingData.push(newRecord);
      }
      return mappingData;
    };
    Geometry2.prototype.convertPoint = function(mappingRecord) {
      var x = mappingRecord.x, y = mappingRecord.y;
      var rstX;
      var rstY;
      var obj;
      var coordinate = this.coordinate;
      if (is_array_default(x) && is_array_default(y)) {
        rstX = [];
        rstY = [];
        for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
          obj = coordinate.convert({
            x: x[i],
            y: y[j]
          });
          rstX.push(obj.x);
          rstY.push(obj.y);
        }
      } else if (is_array_default(y)) {
        rstY = [];
        for (var index = 0; index < y.length; index++) {
          var yVal = y[index];
          obj = coordinate.convert({
            x,
            y: yVal
          });
          if (rstX && rstX !== obj.x) {
            if (!is_array_default(rstX)) {
              rstX = [rstX];
            }
            rstX.push(obj.x);
          } else {
            rstX = obj.x;
          }
          rstY.push(obj.y);
        }
      } else if (is_array_default(x)) {
        rstX = [];
        for (var index = 0; index < x.length; index++) {
          var xVal = x[index];
          obj = coordinate.convert({
            x: xVal,
            y
          });
          if (rstY && rstY !== obj.y) {
            if (!is_array_default(rstY)) {
              rstY = [rstY];
            }
            rstY.push(obj.y);
          } else {
            rstY = obj.y;
          }
          rstX.push(obj.x);
        }
      } else {
        var point = coordinate.convert({
          x,
          y
        });
        rstX = point.x;
        rstY = point.y;
      }
      mappingRecord.x = rstX;
      mappingRecord.y = rstY;
    };
    Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
      var _a4 = styleOption.fields, fields = _a4 === void 0 ? [] : _a4, callback = styleOption.callback, cfg = styleOption.cfg;
      if (cfg) {
        return cfg;
      }
      var params = fields.map(function(field) {
        return originData[field];
      });
      return callback.apply(void 0, params);
    };
    Geometry2.prototype.setCfg = function(cfg) {
      var _this = this;
      var coordinate = cfg.coordinate, data = cfg.data, theme = cfg.theme, scaleDefs = cfg.scaleDefs;
      if (coordinate) {
        this.coordinate = coordinate;
      }
      if (data) {
        this.data = data;
      }
      if (scaleDefs) {
        this.scaleDefs = scaleDefs;
        this.idFields = [];
        each_default(scaleDefs, function(scaleDef, field) {
          if (scaleDef && scaleDef.key) {
            _this.idFields.push(field);
          }
        });
      }
      if (theme) {
        this.theme = this.userTheme ? deep_mix_default({}, theme, this.userTheme) : theme;
      }
    };
    Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var geometryLabel = this.geometryLabel;
      if (!geometryLabel) {
        var labelType = this.getLabelType();
        var GeometryLabelsCtor = getGeometryLabel(labelType);
        geometryLabel = new GeometryLabelsCtor(this);
        this.geometryLabel = geometryLabel;
      }
      geometryLabel.render(mappingArray, isUpdate);
      var labelsMap = geometryLabel.labelsRenderer.shapesMap;
      each_default(this.elementsMap, function(element, id) {
        var labels = filterLabelsById(id, labelsMap);
        if (labels.length) {
          element.labelShape = labels;
          for (var i = 0; i < labels.length; i++) {
            var label = labels[i];
            var labelChildren = label.getChildren();
            for (var j = 0; j < labelChildren.length; j++) {
              var child = labelChildren[j];
              child.cfg.name = ["element", "label"];
              child.cfg.element = element;
            }
          }
        }
      });
    };
    Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
      return !isUpdate && this.animateOption && (get_default(this.animateOption, "appear") === void 0 || get_default(this.animateOption, "appear") && get_default(this.animateOption, ["appear", "animation"]) === void 0);
    };
    return Geometry2;
  }(base_default);
  var base_default14 = Geometry;

  // node_modules/@antv/g2/esm/util/transform.js
  var transform4 = ext_exports.transform;
  function translate2(element, x, y) {
    var matrix = transform4(element.getMatrix(), [["t", x, y]]);
    element.setMatrix(matrix);
  }
  function getRotateMatrix(element, rotateRadian) {
    var _a4 = element.attr(), x = _a4.x, y = _a4.y;
    var matrix = transform4(element.getMatrix(), [
      ["t", -x, -y],
      ["r", rotateRadian],
      ["t", x, y]
    ]);
    return matrix;
  }
  function rotate4(element, rotateRadian) {
    var matrix = getRotateMatrix(element, rotateRadian);
    element.setMatrix(matrix);
  }

  // node_modules/@antv/g2/esm/geometry/label/util/index.js
  function findLabelTextShape(label) {
    return label.find(function(el) {
      return el.get("type") === "text";
    });
  }
  function getlLabelBackgroundInfo(labelGroup, labelItem, padding) {
    if (padding === void 0) {
      padding = [0, 0, 0, 0];
    }
    var content = labelGroup.getChildren()[0];
    if (content) {
      var labelShape = content.clone();
      if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
        rotate4(labelShape, -labelItem.rotate);
      }
      var _a4 = labelShape.getCanvasBBox(), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
      labelShape.destroy();
      var boxPadding = padding;
      if (is_nil_default(boxPadding)) {
        boxPadding = [2, 2, 2, 2];
      } else if (is_number_default(boxPadding)) {
        boxPadding = new Array(4).fill(boxPadding);
      }
      return {
        x: x - boxPadding[3],
        y: y - boxPadding[0],
        width: width + boxPadding[1] + boxPadding[3],
        height: height + boxPadding[0] + boxPadding[2],
        rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
      };
    }
  }
  function getOverlapArea(a, b, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
  }
  function checkShapeOverlap(cur, dones) {
    var box2 = cur.getBBox();
    return some_default(dones, function(done) {
      var target = done.getBBox();
      return getOverlapArea(box2, target, 2) > 0;
    });
  }

  // node_modules/@antv/g2/esm/component/update-label.js
  function updateLabel(fromShape, toShape, cfg) {
    var data = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate = cfg.coordinate;
    var updateAnimateCfg = get_default(animateCfg, "update");
    fromShape.set("data", data);
    fromShape.set("origin", origin);
    fromShape.set("animateCfg", animateCfg);
    fromShape.set("coordinate", coordinate);
    fromShape.set("visible", toShape.get("visible"));
    fromShape.getChildren().forEach(function(fromChild, idx) {
      var toChild = toShape.getChildByIndex(idx);
      if (!toChild) {
        fromShape.removeChild(fromChild);
        fromChild.remove(true);
      } else {
        fromChild.set("data", data);
        fromChild.set("origin", origin);
        fromChild.set("animateCfg", animateCfg);
        fromChild.set("coordinate", coordinate);
        var newAttrs = getReplaceAttrs(fromChild, toChild);
        if (updateAnimateCfg) {
          doAnimate(fromChild, updateAnimateCfg, {
            toAttrs: newAttrs,
            coordinate
          });
        } else {
          fromChild.attr(newAttrs);
        }
        if (toChild.isGroup()) {
          updateLabel(fromChild, toChild, cfg);
        }
      }
    });
    each_default(toShape.getChildren(), function(child, idx) {
      if (idx >= fromShape.getCount()) {
        if (!child.destroyed) {
          fromShape.add(child);
        }
      }
    });
  }

  // node_modules/@antv/g2/esm/component/labels.js
  var Labels = function() {
    function Labels2(cfg) {
      this.shapesMap = {};
      this.lastShapesMap = {};
      var layout = cfg.layout, container = cfg.container;
      this.layout = layout;
      this.container = container;
    }
    Labels2.prototype.render = function(items, shapes, isUpdate) {
      var _this = this;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.shapesMap = {};
      var container = this.container;
      var offscreenGroup = this.createOffscreenGroup();
      if (items.length) {
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
          var item = items_1[_i];
          if (item) {
            this.renderLabel(item, offscreenGroup);
          }
        }
        this.doLayout(items, shapes);
        this.renderLabelLine(items);
        this.renderLabelBackground(items);
        this.adjustLabel(items);
      }
      var lastShapesMap = this.lastShapesMap;
      var shapesMap = this.shapesMap;
      each_default(shapesMap, function(shape, id) {
        if (shape.destroyed) {
          delete shapesMap[id];
        } else {
          if (lastShapesMap[id]) {
            var data = shape.get("data");
            var origin_1 = shape.get("origin");
            var coordinate = shape.get("coordinate");
            var currentAnimateCfg = shape.get("animateCfg");
            var currentShape = lastShapesMap[id];
            updateLabel(currentShape, shapesMap[id], {
              data,
              origin: origin_1,
              animateCfg: currentAnimateCfg,
              coordinate
            });
            _this.shapesMap[id] = currentShape;
          } else {
            container.add(shape);
            var animateCfg = get_default(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
            if (animateCfg) {
              doAnimate(shape, animateCfg, {
                toAttrs: __assign({}, shape.attr()),
                coordinate: shape.get("coordinate")
              });
            }
          }
          delete lastShapesMap[id];
        }
      });
      each_default(lastShapesMap, function(deleteShape) {
        var animateCfg = get_default(deleteShape.get("animateCfg"), "leave");
        if (animateCfg) {
          doAnimate(deleteShape, animateCfg, {
            toAttrs: null,
            coordinate: deleteShape.get("coordinate")
          });
        } else {
          deleteShape.remove(true);
        }
      });
      this.lastShapesMap = shapesMap;
      offscreenGroup.destroy();
    };
    Labels2.prototype.clear = function() {
      this.container.clear();
      this.shapesMap = {};
      this.lastShapesMap = {};
    };
    Labels2.prototype.destroy = function() {
      this.container.destroy();
      this.shapesMap = null;
      this.lastShapesMap = null;
    };
    Labels2.prototype.renderLabel = function(cfg, container) {
      var id = cfg.id, elementId = cfg.elementId, data = cfg.data, mappingData = cfg.mappingData, coordinate = cfg.coordinate, animate = cfg.animate, content = cfg.content;
      var shapeAppendCfg = {
        id,
        elementId,
        data,
        origin: __assign(__assign({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
        coordinate
      };
      var labelGroup = container.addGroup(__assign({
        name: "label",
        animateCfg: this.animate === false || animate === null || animate === false ? false : deep_mix_default({}, this.animate, animate)
      }, shapeAppendCfg));
      var labelShape;
      if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
        var _a4 = content.getCanvasBBox(), width = _a4.width, height = _a4.height;
        var textAlign = get_default(cfg, "textAlign", "left");
        var x = cfg.x;
        var y = cfg.y - height / 2;
        if (textAlign === "center") {
          x = x - width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          x = x - width;
        }
        translate2(content, x, y);
        labelShape = content;
        labelGroup.add(content);
      } else {
        var fill = get_default(cfg, ["style", "fill"]);
        labelShape = labelGroup.addShape("text", __assign({ attrs: __assign(__assign({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get_default(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: is_null_default(fill) ? cfg.color : fill }) }, shapeAppendCfg));
      }
      if (cfg.rotate) {
        rotate4(labelShape, cfg.rotate);
      }
      this.shapesMap[id] = labelGroup;
    };
    Labels2.prototype.doLayout = function(items, shapes) {
      var _this = this;
      if (this.layout) {
        var layouts = is_array_default(this.layout) ? this.layout : [this.layout];
        each_default(layouts, function(layout) {
          var layoutFn = getGeometryLabelLayout(get_default(layout, "type", ""));
          if (layoutFn) {
            var labelShapes_1 = [];
            var geometryShapes_1 = [];
            each_default(_this.shapesMap, function(labelShape, id) {
              labelShapes_1.push(labelShape);
              geometryShapes_1.push(shapes[labelShape.get("elementId")]);
            });
            layoutFn(items, labelShapes_1, geometryShapes_1, _this.region, layout.cfg);
          }
        });
      }
    };
    Labels2.prototype.renderLabelLine = function(labelItems) {
      var _this = this;
      each_default(labelItems, function(labelItem) {
        var coordinate = get_default(labelItem, "coordinate");
        if (!labelItem || !coordinate) {
          return;
        }
        var center = coordinate.getCenter();
        var radius = coordinate.getRadius();
        if (!labelItem.labelLine) {
          return;
        }
        var labelLineCfg = get_default(labelItem, "labelLine", {});
        var id = labelItem.id;
        var path = labelLineCfg.path;
        if (!path) {
          var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);
          path = [
            ["M", start.x, start.y],
            ["L", labelItem.x, labelItem.y]
          ];
        }
        var labelGroup = _this.shapesMap[id];
        if (!labelGroup.destroyed) {
          labelGroup.addShape("path", {
            capture: false,
            attrs: __assign({ path, stroke: labelItem.color ? labelItem.color : get_default(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
            id,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
        }
      });
    };
    Labels2.prototype.renderLabelBackground = function(labelItems) {
      var _this = this;
      each_default(labelItems, function(labelItem) {
        var coordinate = get_default(labelItem, "coordinate");
        var background = get_default(labelItem, "background");
        if (!background || !coordinate) {
          return;
        }
        var id = labelItem.id;
        var labelGroup = _this.shapesMap[id];
        if (!labelGroup.destroyed) {
          var labelContentShape = labelGroup.getChildren()[0];
          if (labelContentShape) {
            var _a4 = getlLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a4.rotation, box2 = __rest(_a4, ["rotation"]);
            var backgroundShape = labelGroup.addShape("rect", {
              attrs: __assign(__assign({}, box2), background.style || {}),
              id,
              origin: labelItem.mappingData,
              data: labelItem.data,
              coordinate: labelItem.coordinate
            });
            backgroundShape.setZIndex(-1);
            if (rotation) {
              var matrix = labelContentShape.getMatrix();
              backgroundShape.setMatrix(matrix);
            }
          }
        }
      });
    };
    Labels2.prototype.createOffscreenGroup = function() {
      var container = this.container;
      var GroupClass = container.getGroupBase();
      var newGroup = new GroupClass({});
      return newGroup;
    };
    Labels2.prototype.adjustLabel = function(items) {
      var _this = this;
      each_default(items, function(item) {
        if (item) {
          var id = item.id;
          var labelGroup = _this.shapesMap[id];
          if (!labelGroup.destroyed) {
            var labelShapes = labelGroup.findAll(function(ele) {
              return ele.get("type") !== "path";
            });
            each_default(labelShapes, function(labelShape) {
              if (labelShape) {
                if (item.offsetX) {
                  labelShape.attr("x", labelShape.attr("x") + item.offsetX);
                }
                if (item.offsetY) {
                  labelShape.attr("y", labelShape.attr("y") + item.offsetY);
                }
              }
            });
          }
        }
      });
    };
    return Labels2;
  }();
  var labels_default = Labels;

  // node_modules/@antv/g2/esm/geometry/label/base.js
  function avg(arr) {
    var sum = 0;
    each_default(arr, function(value) {
      sum += value;
    });
    return sum / arr.length;
  }
  var GeometryLabel = function() {
    function GeometryLabel2(geometry) {
      this.geometry = geometry;
    }
    GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
      var _this = this;
      var items = [];
      var labelCfgs = this.getLabelCfgs(mapppingArray);
      each_default(mapppingArray, function(mappingData, index) {
        var labelCfg = labelCfgs[index];
        if (!labelCfg || is_nil_default(mappingData.x) || is_nil_default(mappingData.y)) {
          items.push(null);
          return;
        }
        var labelContent = !is_array_default(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
        labelCfg.content = labelContent;
        var total = labelContent.length;
        each_default(labelContent, function(content, subIndex) {
          if (is_nil_default(content) || content === "") {
            items.push(null);
            return;
          }
          var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
          if (!item.textAlign) {
            item.textAlign = _this.getLabelAlign(item, subIndex, total);
          }
          if (item.offset <= 0) {
            item.labelLine = null;
          }
          items.push(item);
        });
      });
      return items;
    };
    GeometryLabel2.prototype.render = function(mapppingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var labelItems = this.getLabelItems(mapppingArray);
      var labelsRenderer = this.getLabelsRenderer();
      var shapes = this.getGeometryShapes();
      labelsRenderer.render(labelItems, shapes, isUpdate);
    };
    GeometryLabel2.prototype.clear = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.clear();
      }
    };
    GeometryLabel2.prototype.destroy = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.destroy();
      }
      this.labelsRenderer = null;
    };
    GeometryLabel2.prototype.getCoordinate = function() {
      return this.geometry.coordinate;
    };
    GeometryLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var geometry = this.geometry;
      var type = geometry.type, theme = geometry.theme;
      if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && !["line", "point", "path"].includes(type)) {
        return get_default(theme, "innerLabels", {});
      }
      return get_default(theme, "labels", {});
    };
    GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var type = geometry.type, theme = geometry.theme;
      var themedLabelCfg;
      if (type === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type)) {
        themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme.innerLabels, labelCfg);
      } else {
        themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme.labels, labelCfg);
      }
      return themedLabelCfg;
    };
    GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
    };
    GeometryLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate = this.getCoordinate();
      var vector = this.getOffsetVector(offset);
      return coordinate.isTransposed ? vector[0] : vector[1];
    };
    GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total) {
      var offset = labelCfg.offset;
      var coordinate = this.getCoordinate();
      var transposed = coordinate.isTransposed;
      var dim = transposed ? "x" : "y";
      var factor = transposed ? 1 : -1;
      var offsetPoint = {
        x: 0,
        y: 0
      };
      if (index > 0 || total === 1) {
        offsetPoint[dim] = offset * factor;
      } else {
        offsetPoint[dim] = offset * factor * -1;
      }
      return offsetPoint;
    };
    GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var coordinate = this.getCoordinate();
      var total = labelCfg.content.length;
      function getDimValue(value, idx, isAvg) {
        if (isAvg === void 0) {
          isAvg = false;
        }
        var v = value;
        if (is_array_default(v)) {
          if (labelCfg.content.length === 1) {
            if (isAvg) {
              v = avg(v);
            } else {
              if (v.length <= 2) {
                v = v[value.length - 1];
              } else {
                v = avg(v);
              }
            }
          } else {
            v = v[idx];
          }
        }
        return v;
      }
      var label = {
        content: labelCfg.content[index],
        x: 0,
        y: 0,
        start: { x: 0, y: 0 },
        color: "#fff"
      };
      var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      var isFunnel = shape === "funnel" || shape === "pyramid";
      if (this.geometry.type === "polygon") {
        var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
        label.x = centroid[0];
        label.y = centroid[1];
      } else if (this.geometry.type === "interval" && !isFunnel) {
        label.x = getDimValue(mappingData.x, index, true);
        label.y = getDimValue(mappingData.y, index);
      } else {
        label.x = getDimValue(mappingData.x, index);
        label.y = getDimValue(mappingData.y, index);
      }
      if (isFunnel) {
        var nextPoints = get_default(mappingData, "nextPoints");
        var points = get_default(mappingData, "points");
        if (nextPoints) {
          var point1 = coordinate.convert(points[1]);
          var point2 = coordinate.convert(nextPoints[1]);
          label.x = (point1.x + point2.x) / 2;
          label.y = (point1.y + point2.y) / 2;
        } else if (shape === "pyramid") {
          var point1 = coordinate.convert(points[1]);
          var point2 = coordinate.convert(points[2]);
          label.x = (point1.x + point2.x) / 2;
          label.y = (point1.y + point2.y) / 2;
        }
      }
      if (labelCfg.position) {
        this.setLabelPosition(label, mappingData, index, labelCfg.position);
      }
      var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
      label.start = { x: label.x, y: label.y };
      label.x += offsetPoint.x;
      label.y += offsetPoint.y;
      label.color = mappingData.color;
      return label;
    };
    GeometryLabel2.prototype.getLabelAlign = function(item, index, total) {
      var align = "center";
      var coordinate = this.getCoordinate();
      if (coordinate.isTransposed) {
        var offset = item.offset;
        if (offset < 0) {
          align = "right";
        } else if (offset === 0) {
          align = "center";
        } else {
          align = "left";
        }
        if (total > 1 && index === 0) {
          if (align === "right") {
            align = "left";
          } else if (align === "left") {
            align = "right";
          }
        }
      }
      return align;
    };
    GeometryLabel2.prototype.getLabelId = function(mappingData) {
      var geometry = this.geometry;
      var type = geometry.type;
      var xScale = geometry.getXScale();
      var yScale = geometry.getYScale();
      var origin = mappingData[FIELD_ORIGIN];
      var labelId = geometry.getElementId(mappingData);
      if (type === "line" || type === "area") {
        labelId += " " + origin[xScale.field];
      } else if (type === "path") {
        labelId += " " + origin[xScale.field] + "-" + origin[yScale.field];
      }
      return labelId;
    };
    GeometryLabel2.prototype.getLabelsRenderer = function() {
      var _a4 = this.geometry, labelsContainer = _a4.labelsContainer, labelOption = _a4.labelOption, canvasRegion = _a4.canvasRegion, animateOption = _a4.animateOption;
      var coordinate = this.geometry.coordinate;
      var labelsRenderer = this.labelsRenderer;
      if (!labelsRenderer) {
        labelsRenderer = new labels_default({
          container: labelsContainer,
          layout: get_default(labelOption, ["cfg", "layout"], {
            type: this.defaultLayout
          })
        });
        this.labelsRenderer = labelsRenderer;
      }
      labelsRenderer.region = canvasRegion;
      labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate) : false;
      return labelsRenderer;
    };
    GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
      var _this = this;
      var geometry = this.geometry;
      var labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;
      var _a4 = labelOption, fields = _a4.fields, callback = _a4.callback, cfg = _a4.cfg;
      var labelScales = fields.map(function(field) {
        return scales[field];
      });
      var labelCfgs = [];
      each_default(mapppingArray, function(mappingData, index) {
        var origin = mappingData[FIELD_ORIGIN];
        var originText = _this.getLabelText(origin, labelScales);
        var callbackCfg;
        if (callback) {
          var originValues = fields.map(function(field) {
            return origin[field];
          });
          callbackCfg = callback.apply(void 0, originValues);
          if (is_nil_default(callbackCfg)) {
            labelCfgs.push(null);
            return;
          }
        }
        var labelCfg = __assign(__assign({
          id: _this.getLabelId(mappingData),
          elementId: _this.geometry.getElementId(mappingData),
          data: origin,
          mappingData,
          coordinate
        }, cfg), callbackCfg);
        if (is_function_default(labelCfg.position)) {
          labelCfg.position = labelCfg.position(origin, mappingData, index);
        }
        var offset = _this.getLabelOffset(labelCfg.offset || 0);
        var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
        labelCfg = deep_mix_default({}, defaultLabelCfg, labelCfg);
        labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
        var content = labelCfg.content;
        if (is_function_default(content)) {
          labelCfg.content = content(origin, mappingData, index);
        } else if (is_undefined_default(content)) {
          labelCfg.content = originText[0];
        }
        labelCfgs.push(labelCfg);
      });
      return labelCfgs;
    };
    GeometryLabel2.prototype.getLabelText = function(origin, scales) {
      var labelTexts = [];
      each_default(scales, function(scale4) {
        var value = origin[scale4.field];
        if (is_array_default(value)) {
          value = value.map(function(subVal) {
            return scale4.getText(subVal);
          });
        } else {
          value = scale4.getText(value);
        }
        if (is_nil_default(value) || value === "") {
          labelTexts.push(null);
        } else {
          labelTexts.push(value);
        }
      });
      return labelTexts;
    };
    GeometryLabel2.prototype.getOffsetVector = function(offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var coordinate = this.getCoordinate();
      var actualOffset = 0;
      if (is_number_default(offset)) {
        actualOffset = offset;
      }
      return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);
    };
    GeometryLabel2.prototype.getGeometryShapes = function() {
      var geometry = this.geometry;
      var shapes = {};
      each_default(geometry.elementsMap, function(element, id) {
        shapes[id] = element.shape;
      });
      each_default(geometry.getOffscreenGroup().getChildren(), function(child) {
        var id = geometry.getElementId(child.get("origin").mappingData);
        shapes[id] = child;
      });
      return shapes;
    };
    return GeometryLabel2;
  }();
  var base_default15 = GeometryLabel;

  // node_modules/@antv/g2/esm/util/attr.js
  function getMappingValue(attr, value, def2) {
    if (!attr) {
      return def2;
    }
    var r;
    if (attr.callback && attr.callback.length > 1) {
      var restArgs = Array(attr.callback.length - 1).fill("");
      r = attr.mapping.apply(attr, __spreadArray([value], restArgs, false)).join("");
    } else {
      r = attr.mapping(value).join("");
    }
    return r || def2;
  }

  // node_modules/@antv/g2/esm/util/marker.js
  var MarkerSymbols = {
    hexagon: function(x, y, r) {
      var diffX = r / 2 * Math.sqrt(3);
      return [
        ["M", x, y - r],
        ["L", x + diffX, y - r / 2],
        ["L", x + diffX, y + r / 2],
        ["L", x, y + r],
        ["L", x - diffX, y + r / 2],
        ["L", x - diffX, y - r / 2],
        ["Z"]
      ];
    },
    bowtie: function(x, y, r) {
      var diffY = r - 1.5;
      return [["M", x - r, y - diffY], ["L", x + r, y + diffY], ["L", x + r, y - diffY], ["L", x - r, y + diffY], ["Z"]];
    },
    cross: function(x, y, r) {
      return [
        ["M", x - r, y - r],
        ["L", x + r, y + r],
        ["M", x + r, y - r],
        ["L", x - r, y + r]
      ];
    },
    tick: function(x, y, r) {
      return [
        ["M", x - r / 2, y - r],
        ["L", x + r / 2, y - r],
        ["M", x, y - r],
        ["L", x, y + r],
        ["M", x - r / 2, y + r],
        ["L", x + r / 2, y + r]
      ];
    },
    plus: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y],
        ["M", x, y - r],
        ["L", x, y + r]
      ];
    },
    hyphen: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    line: function(x, y, r) {
      return [
        ["M", x, y - r],
        ["L", x, y + r]
      ];
    }
  };

  // node_modules/@antv/g2/esm/util/legend.js
  var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
  function handleUserMarkerStyle(markerStyle, style) {
    if (is_function_default(style)) {
      return style(markerStyle);
    }
    return deep_mix_default({}, markerStyle, style);
  }
  function adpatorMarkerStyle(marker, color2) {
    var symbol = marker.symbol;
    if (is_string_default(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
      var markerStyle = get_default(marker, "style", {});
      var lineWidth = get_default(markerStyle, "lineWidth", 1);
      var stroke = markerStyle.stroke || markerStyle.fill || color2;
      marker.style = deep_mix_default({}, marker.style, { lineWidth, stroke, fill: null });
    }
  }
  function setMarkerSymbol(marker) {
    var symbol = marker.symbol;
    if (is_string_default(symbol) && MarkerSymbols[symbol]) {
      marker.symbol = MarkerSymbols[symbol];
    }
  }
  function getLegendLayout(direction2) {
    return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
  }
  function getLegendItems(view, geometry, attr, themeMarker, userMarker) {
    var scale4 = attr.getScale(attr.type);
    if (scale4.isCategory) {
      var field_1 = scale4.field;
      var colorAttr_1 = geometry.getAttribute("color");
      var shapeAttr_1 = geometry.getAttribute("shape");
      var defaultColor_1 = view.getTheme().defaultColor;
      var isInPolar_1 = geometry.coordinate.isPolar;
      return scale4.getTicks().map(function(tick2, index) {
        var _a4;
        var text = tick2.text, scaleValue = tick2.value;
        var name = text;
        var value = scale4.invert(scaleValue);
        var unchecked = view.filterFieldData(field_1, [(_a4 = {}, _a4[field_1] = value, _a4)]).length === 0;
        each_default(view.views, function(subView) {
          var _a5;
          if (!subView.filterFieldData(field_1, [(_a5 = {}, _a5[field_1] = value, _a5)]).length) {
            unchecked = true;
          }
        });
        var color2 = getMappingValue(colorAttr_1, value, defaultColor_1);
        var shape = getMappingValue(shapeAttr_1, value, "point");
        var marker = geometry.getShapeMarker(shape, {
          color: color2,
          isInPolar: isInPolar_1
        });
        var markerCfg = userMarker;
        if (is_function_default(markerCfg)) {
          markerCfg = markerCfg(name, index, __assign({ name, value }, deep_mix_default({}, themeMarker, marker)));
        }
        marker = deep_mix_default({}, themeMarker, marker, omit(__assign({}, markerCfg), ["style"]));
        adpatorMarkerStyle(marker, color2);
        if (markerCfg && markerCfg.style) {
          marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
        }
        setMarkerSymbol(marker);
        return { id: value, name, value, marker, unchecked };
      });
    }
    return [];
  }
  function getCustomLegendItems(themeMarker, userMarker, customItems) {
    return customItems.map(function(item, index) {
      var markerCfg = userMarker;
      if (is_function_default(markerCfg)) {
        markerCfg = markerCfg(item.name, index, deep_mix_default({}, themeMarker, item));
      }
      var itemMarker = is_function_default(item.marker) ? item.marker(item.name, index, deep_mix_default({}, themeMarker, item)) : item.marker;
      var marker = deep_mix_default({}, themeMarker, markerCfg, itemMarker);
      setMarkerSymbol(marker);
      item.marker = marker;
      return item;
    });
  }
  function getLegendThemeCfg(theme, direction2) {
    var legendTheme = get_default(theme, ["components", "legend"], {});
    return deep_mix_default({}, get_default(legendTheme, ["common"], {}), deep_mix_default({}, get_default(legendTheme, [direction2], {})));
  }

  // node_modules/@antv/g2/esm/theme/style-sheet/dark.js
  var WHITE_COLORS2 = {
    100: "#000",
    95: "#0D0D0D",
    85: "#262626",
    65: "#595959",
    45: "#8C8C8C",
    25: "#BFBFBF",
    15: "#D9D9D9",
    6: "#F0F0F0"
  };
  var BLACK_COLORS2 = {
    100: "#FFFFFF",
    95: "#F2F2F2",
    85: "#D9D9D9",
    65: "#A6A6A6",
    45: "#737373",
    25: "#404040",
    15: "#262626",
    6: "#0F0F0F"
  };
  var QUALITATIVE_102 = [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#E86452",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
  var QUALITATIVE_202 = [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#E86452",
    "#F8D0CB",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
  var SINGLE_SEQUENCE2 = [
    "#B8E1FF",
    "#9AC5FF",
    "#7DAAFF",
    "#5B8FF9",
    "#3D76DD",
    "#085EC0",
    "#0047A5",
    "#00318A",
    "#001D70"
  ];
  var createDarkStyleSheet = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var _a4 = cfg.backgroundColor, backgroundColor = _a4 === void 0 ? "#141414" : _a4, _b = cfg.subColor, subColor = _b === void 0 ? "rgba(255,255,255,0.05)" : _b, _c = cfg.paletteQualitative10, paletteQualitative10 = _c === void 0 ? QUALITATIVE_102 : _c, _d = cfg.paletteQualitative20, paletteQualitative20 = _d === void 0 ? QUALITATIVE_202 : _d, _e = cfg.paletteSemanticRed, paletteSemanticRed = _e === void 0 ? "#F4664A" : _e, _f = cfg.paletteSemanticGreen, paletteSemanticGreen = _f === void 0 ? "#30BF78" : _f, _g = cfg.paletteSemanticYellow, paletteSemanticYellow = _g === void 0 ? "#FAAD14" : _g, _h = cfg.paletteSequence, paletteSequence = _h === void 0 ? SINGLE_SEQUENCE2 : _h, _j = cfg.fontFamily, fontFamily = _j === void 0 ? '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : _j;
    var _k = cfg.brandColor, brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
    return {
      backgroundColor,
      brandColor,
      subColor,
      paletteQualitative10,
      paletteQualitative20,
      paletteSemanticRed,
      paletteSemanticGreen,
      paletteSemanticYellow,
      paletteSequence,
      fontFamily,
      axisLineBorderColor: BLACK_COLORS2[25],
      axisLineBorder: 1,
      axisLineDash: null,
      axisTitleTextFillColor: BLACK_COLORS2[65],
      axisTitleTextFontSize: 12,
      axisTitleTextLineHeight: 12,
      axisTitleTextFontWeight: "normal",
      axisTitleSpacing: 12,
      axisTickLineBorderColor: BLACK_COLORS2[25],
      axisTickLineLength: 4,
      axisTickLineBorder: 1,
      axisSubTickLineBorderColor: BLACK_COLORS2[15],
      axisSubTickLineLength: 2,
      axisSubTickLineBorder: 1,
      axisLabelFillColor: BLACK_COLORS2[45],
      axisLabelFontSize: 12,
      axisLabelLineHeight: 12,
      axisLabelFontWeight: "normal",
      axisLabelOffset: 8,
      axisGridBorderColor: BLACK_COLORS2[15],
      axisGridBorder: 1,
      axisGridLineDash: null,
      legendTitleTextFillColor: BLACK_COLORS2[45],
      legendTitleTextFontSize: 12,
      legendTitleTextLineHeight: 21,
      legendTitleTextFontWeight: "normal",
      legendMarkerColor: QUALITATIVE_102[0],
      legendMarkerSpacing: 8,
      legendMarkerSize: 4,
      legendCircleMarkerSize: 4,
      legendSquareMarkerSize: 4,
      legendLineMarkerSize: 5,
      legendItemNameFillColor: BLACK_COLORS2[65],
      legendItemNameFontSize: 12,
      legendItemNameLineHeight: 12,
      legendItemNameFontWeight: "normal",
      legendItemSpacing: 24,
      legendItemMarginBottom: 12,
      legendSpacing: 16,
      legendPadding: [8, 8, 8, 8],
      legendHorizontalPadding: [8, 0, 8, 0],
      legendVerticalPadding: [0, 8, 0, 8],
      legendPageNavigatorMarkerSize: 12,
      legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS2[45],
      legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
      legendPageNavigatorMarkerFillColor: BLACK_COLORS2[45],
      legendPageNavigatorMarkerFillOpacity: 1,
      legendPageNavigatorTextFillColor: BLACK_COLORS2[65],
      legendPageNavigatorTextFontSize: 12,
      sliderRailFillColor: BLACK_COLORS2[15],
      sliderRailBorder: 0,
      sliderRailBorderColor: null,
      sliderRailWidth: 100,
      sliderRailHeight: 12,
      sliderLabelTextFillColor: BLACK_COLORS2[45],
      sliderLabelTextFontSize: 12,
      sliderLabelTextLineHeight: 12,
      sliderLabelTextFontWeight: "normal",
      sliderHandlerFillColor: WHITE_COLORS2[6],
      sliderHandlerWidth: 10,
      sliderHandlerHeight: 14,
      sliderHandlerBorder: 1,
      sliderHandlerBorderColor: WHITE_COLORS2[25],
      annotationArcBorderColor: BLACK_COLORS2[15],
      annotationArcBorder: 1,
      annotationLineBorderColor: BLACK_COLORS2[25],
      annotationLineBorder: 1,
      annotationLineDash: null,
      annotationTextFillColor: BLACK_COLORS2[65],
      annotationTextFontSize: 12,
      annotationTextLineHeight: 12,
      annotationTextFontWeight: "normal",
      annotationTextBorderColor: null,
      annotationTextBorder: 0,
      annotationRegionFillColor: BLACK_COLORS2[100],
      annotationRegionFillOpacity: 0.06,
      annotationRegionBorder: 0,
      annotationRegionBorderColor: null,
      annotationDataMarkerLineLength: 16,
      tooltipCrosshairsBorderColor: BLACK_COLORS2[25],
      tooltipCrosshairsBorder: 1,
      tooltipCrosshairsLineDash: null,
      tooltipContainerFillColor: "#1f1f1f",
      tooltipContainerFillOpacity: 0.95,
      tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
      tooltipContainerBorderRadius: 3,
      tooltipTextFillColor: BLACK_COLORS2[65],
      tooltipTextFontSize: 12,
      tooltipTextLineHeight: 12,
      tooltipTextFontWeight: "bold",
      labelFillColor: BLACK_COLORS2[65],
      labelFillColorDark: "#2c3542",
      labelFillColorLight: "#ffffff",
      labelFontSize: 12,
      labelLineHeight: 12,
      labelFontWeight: "normal",
      labelBorderColor: null,
      labelBorder: 0,
      innerLabelFillColor: WHITE_COLORS2[100],
      innerLabelFontSize: 12,
      innerLabelLineHeight: 12,
      innerLabelFontWeight: "normal",
      innerLabelBorderColor: null,
      innerLabelBorder: 0,
      overflowLabelFillColor: BLACK_COLORS2[65],
      overflowLabelFillColorDark: "#2c3542",
      overflowLabelFillColorLight: "#ffffff",
      overflowLabelFontSize: 12,
      overflowLabelLineHeight: 12,
      overflowLabelFontWeight: "normal",
      overflowLabelBorderColor: WHITE_COLORS2[100],
      overflowLabelBorder: 1,
      labelLineBorder: 1,
      labelLineBorderColor: BLACK_COLORS2[25],
      cSliderRailHieght: 16,
      cSliderBackgroundFillColor: "#416180",
      cSliderBackgroundFillOpacity: 0.05,
      cSliderForegroundFillColor: "#5B8FF9",
      cSliderForegroundFillOpacity: 0.15,
      cSliderHandlerHeight: 24,
      cSliderHandlerWidth: 10,
      cSliderHandlerFillColor: "#F7F7F7",
      cSliderHandlerFillOpacity: 1,
      cSliderHandlerHighlightFillColor: "#FFF",
      cSliderHandlerBorderColor: "#BFBFBF",
      cSliderHandlerBorder: 1,
      cSliderHandlerBorderRadius: 2,
      cSliderTextFillColor: "#fff",
      cSliderTextFillOpacity: 0.45,
      cSliderTextFontSize: 12,
      cSliderTextLineHeight: 12,
      cSliderTextFontWeight: "normal",
      cSliderTextBorderColor: null,
      cSliderTextBorder: 0,
      scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
      scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
      scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
      pointFillColor: QUALITATIVE_102[0],
      pointFillOpacity: 0.95,
      pointSize: 4,
      pointBorder: 1,
      pointBorderColor: WHITE_COLORS2[100],
      pointBorderOpacity: 1,
      pointActiveBorderColor: BLACK_COLORS2[100],
      pointSelectedBorder: 2,
      pointSelectedBorderColor: BLACK_COLORS2[100],
      pointInactiveFillOpacity: 0.3,
      pointInactiveBorderOpacity: 0.3,
      hollowPointSize: 4,
      hollowPointBorder: 1,
      hollowPointBorderColor: QUALITATIVE_102[0],
      hollowPointBorderOpacity: 0.95,
      hollowPointFillColor: WHITE_COLORS2[100],
      hollowPointActiveBorder: 1,
      hollowPointActiveBorderColor: BLACK_COLORS2[100],
      hollowPointActiveBorderOpacity: 1,
      hollowPointSelectedBorder: 2,
      hollowPointSelectedBorderColor: BLACK_COLORS2[100],
      hollowPointSelectedBorderOpacity: 1,
      hollowPointInactiveBorderOpacity: 0.3,
      lineBorder: 2,
      lineBorderColor: QUALITATIVE_102[0],
      lineBorderOpacity: 1,
      lineActiveBorder: 3,
      lineSelectedBorder: 3,
      lineInactiveBorderOpacity: 0.3,
      areaFillColor: QUALITATIVE_102[0],
      areaFillOpacity: 0.25,
      areaActiveFillColor: QUALITATIVE_102[0],
      areaActiveFillOpacity: 0.5,
      areaSelectedFillColor: QUALITATIVE_102[0],
      areaSelectedFillOpacity: 0.5,
      areaInactiveFillOpacity: 0.3,
      hollowAreaBorderColor: QUALITATIVE_102[0],
      hollowAreaBorder: 2,
      hollowAreaBorderOpacity: 1,
      hollowAreaActiveBorder: 3,
      hollowAreaActiveBorderColor: BLACK_COLORS2[100],
      hollowAreaSelectedBorder: 3,
      hollowAreaSelectedBorderColor: BLACK_COLORS2[100],
      hollowAreaInactiveBorderOpacity: 0.3,
      intervalFillColor: QUALITATIVE_102[0],
      intervalFillOpacity: 0.95,
      intervalActiveBorder: 1,
      intervalActiveBorderColor: BLACK_COLORS2[100],
      intervalActiveBorderOpacity: 1,
      intervalSelectedBorder: 2,
      intervalSelectedBorderColor: BLACK_COLORS2[100],
      intervalSelectedBorderOpacity: 1,
      intervalInactiveBorderOpacity: 0.3,
      intervalInactiveFillOpacity: 0.3,
      hollowIntervalBorder: 2,
      hollowIntervalBorderColor: QUALITATIVE_102[0],
      hollowIntervalBorderOpacity: 1,
      hollowIntervalFillColor: WHITE_COLORS2[100],
      hollowIntervalActiveBorder: 2,
      hollowIntervalActiveBorderColor: BLACK_COLORS2[100],
      hollowIntervalSelectedBorder: 3,
      hollowIntervalSelectedBorderColor: BLACK_COLORS2[100],
      hollowIntervalSelectedBorderOpacity: 1,
      hollowIntervalInactiveBorderOpacity: 0.3
    };
  };
  var antvDark = createDarkStyleSheet();

  // node_modules/@antv/g-canvas/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    AbstractCanvas: () => canvas_default,
    AbstractGroup: () => group_default2,
    AbstractShape: () => shape_default,
    Base: () => base_default2,
    Canvas: () => canvas_default3,
    Event: () => graph_event_default,
    Group: () => group_default4,
    PathUtil: () => path_exports,
    Shape: () => shape_exports,
    assembleFont: () => assembleFont,
    getArcParams: () => getArcParams2,
    getBBoxMethod: () => getMethod,
    getOffScreenContext: () => getOffScreenContext,
    getTextHeight: () => getTextHeight,
    invert: () => invert2,
    isAllowCapture: () => isAllowCapture,
    multiplyVec2: () => multiplyVec2,
    version: () => version2
  });

  // node_modules/@antv/g-canvas/esm/shape/index.js
  var shape_exports = {};
  __export(shape_exports, {
    Base: () => base_default16,
    Circle: () => circle_default6,
    Ellipse: () => ellipse_default4,
    Image: () => image_default2,
    Line: () => line_default8,
    Marker: () => marker_default,
    Path: () => path_default3,
    Polygon: () => polygon_default4,
    Polyline: () => polyline_default4,
    Rect: () => rect_default3,
    Text: () => text_default4
  });

  // node_modules/@antv/g-canvas/node_modules/tslib/modules/index.js
  var import_tslib99 = __toModule(require_tslib8());
  var {
    __extends: __extends8,
    __assign: __assign8,
    __rest: __rest8,
    __decorate: __decorate8,
    __param: __param8,
    __metadata: __metadata8,
    __awaiter: __awaiter8,
    __generator: __generator8,
    __exportStar: __exportStar8,
    __createBinding: __createBinding8,
    __values: __values8,
    __read: __read8,
    __spread: __spread8,
    __spreadArrays: __spreadArrays8,
    __spreadArray: __spreadArray7,
    __await: __await8,
    __asyncGenerator: __asyncGenerator8,
    __asyncDelegator: __asyncDelegator8,
    __asyncValues: __asyncValues8,
    __makeTemplateObject: __makeTemplateObject8,
    __importStar: __importStar8,
    __importDefault: __importDefault8,
    __classPrivateFieldGet: __classPrivateFieldGet8,
    __classPrivateFieldSet: __classPrivateFieldSet8
  } = import_tslib99.default;

  // node_modules/@antv/g-canvas/esm/util/util.js
  function getPixelRatio() {
    return window ? window.devicePixelRatio : 1;
  }
  function distance7(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function inBox(minX, minY, width, height, x, y) {
    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
  }
  function intersectRect2(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
  }
  function mergeRegion(region1, region2) {
    if (!region1 || !region2) {
      return region1 || region2;
    }
    return {
      minX: Math.min(region1.minX, region2.minX),
      minY: Math.min(region1.minY, region2.minY),
      maxX: Math.max(region1.maxX, region2.maxX),
      maxY: Math.max(region1.maxY, region2.maxY)
    };
  }
  function isSamePoint2(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
  }

  // node_modules/@antv/g-canvas/esm/util/parse.js
  var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var regexColorStop2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  function addStop(steps, gradient2) {
    var arr = steps.match(regexColorStop2);
    each_default(arr, function(item) {
      var itemArr = item.split(":");
      gradient2.addColorStop(itemArr[0], itemArr[1]);
    });
  }
  function parseLineGradient(context, element, gradientStr) {
    var arr = regexLG2.exec(gradientStr);
    var angle3 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
    var steps = arr[2];
    var box2 = element.getBBox();
    var start;
    var end;
    if (angle3 >= 0 && angle3 < 1 / 2 * Math.PI) {
      start = {
        x: box2.minX,
        y: box2.minY
      };
      end = {
        x: box2.maxX,
        y: box2.maxY
      };
    } else if (1 / 2 * Math.PI <= angle3 && angle3 < Math.PI) {
      start = {
        x: box2.maxX,
        y: box2.minY
      };
      end = {
        x: box2.minX,
        y: box2.maxY
      };
    } else if (Math.PI <= angle3 && angle3 < 3 / 2 * Math.PI) {
      start = {
        x: box2.maxX,
        y: box2.maxY
      };
      end = {
        x: box2.minX,
        y: box2.minY
      };
    } else {
      start = {
        x: box2.minX,
        y: box2.maxY
      };
      end = {
        x: box2.maxX,
        y: box2.minY
      };
    }
    var tanTheta = Math.tan(angle3);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
    var gradient2 = context.createLinearGradient(start.x, start.y, x, y);
    addStop(steps, gradient2);
    return gradient2;
  }
  function parseRadialGradient(context, element, gradientStr) {
    var arr = regexRG2.exec(gradientStr);
    var fx = parseFloat(arr[1]);
    var fy = parseFloat(arr[2]);
    var fr = parseFloat(arr[3]);
    var steps = arr[4];
    if (fr === 0) {
      var colors = steps.match(regexColorStop2);
      return colors[colors.length - 1].split(":")[1];
    }
    var box2 = element.getBBox();
    var width = box2.maxX - box2.minX;
    var height = box2.maxY - box2.minY;
    var r = Math.sqrt(width * width + height * height) / 2;
    var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
    addStop(steps, gradient2);
    return gradient2;
  }
  function parsePattern(context, element, patternStr) {
    if (element.get("patternSource") && element.get("patternSource") === patternStr) {
      return element.get("pattern");
    }
    var pattern;
    var img;
    var arr = regexPR.exec(patternStr);
    var repeat = arr[1];
    var source = arr[2];
    function onload() {
      pattern = context.createPattern(img, repeat);
      element.set("pattern", pattern);
      element.set("patternSource", patternStr);
    }
    switch (repeat) {
      case "a":
        repeat = "repeat";
        break;
      case "x":
        repeat = "repeat-x";
        break;
      case "y":
        repeat = "repeat-y";
        break;
      case "n":
        repeat = "no-repeat";
        break;
      default:
        repeat = "no-repeat";
    }
    img = new Image();
    if (!source.match(/^data:/i)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = source;
    if (img.complete) {
      onload();
    } else {
      img.onload = onload;
      img.src = img.src;
    }
    return pattern;
  }
  function parseStyle(context, element, color2) {
    var bbox = element.getBBox();
    if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
      return color2;
    }
    if (is_string_default(color2)) {
      if (color2[1] === "(" || color2[2] === "(") {
        if (color2[0] === "l") {
          return parseLineGradient(context, element, color2);
        }
        if (color2[0] === "r") {
          return parseRadialGradient(context, element, color2);
        }
        if (color2[0] === "p") {
          return parsePattern(context, element, color2);
        }
      }
      return color2;
    }
    if (color2 instanceof CanvasPattern) {
      return color2;
    }
  }
  function parseRadius(radius) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }
    return [r1, r2, r3, r4];
  }

  // node_modules/@antv/g-canvas/esm/util/arc-params.js
  function vMag2(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio2(u, v) {
    return vMag2(u) * vMag2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag2(u) * vMag2(v)) : 1;
  }
  function vAngle2(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio2(u, v));
  }
  function getArcParams2(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    var x2 = params[6];
    var y2 = params[7];
    var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
    var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle2([1, 0], u);
    var dTheta = vAngle2(u, v);
    if (vRatio2(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio2(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return {
      cx,
      cy,
      rx: isSamePoint2(startPoint, [x2, y2]) ? 0 : rx,
      ry: isSamePoint2(startPoint, [x2, y2]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }

  // node_modules/@antv/g-canvas/esm/util/arrow.js
  var sin = Math.sin;
  var cos = Math.cos;
  var atan2 = Math.atan2;
  var PI = Math.PI;
  function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
    var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
    var x = x1 - x2;
    var y = y1 - y2;
    var rad = atan2(y, x);
    var arrowShape = new path_default3({
      type: "path",
      canvas: shape.get("canvas"),
      isArrowShape: true,
      attrs: {
        path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
        stroke,
        lineWidth
      }
    });
    arrowShape.translate(x2, y2);
    arrowShape.rotateAtPoint(x2, y2, rad);
    shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
  }
  function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
    var arrowAttrs = isStart ? startArrow : endArrow;
    var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest8(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
    var x = x1 - x2;
    var y = y1 - y2;
    var rad = atan2(y, x);
    if (d) {
      x2 = x2 - cos(rad) * d;
      y2 = y2 - sin(rad) * d;
    }
    var arrowShape = new path_default3({
      type: "path",
      canvas: shape.get("canvas"),
      isArrowShape: true,
      attrs: __assign8(__assign8({}, restAttrs), {
        stroke: arrowStroke || stroke,
        lineWidth: arrowLineWidth || lineWidth,
        fill: arrowFill
      })
    });
    arrowShape.translate(x2, y2);
    arrowShape.rotateAtPoint(x2, y2, rad);
    shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
  }
  function getShortenOffset(x1, y1, x2, y2, d) {
    var rad = atan2(y2 - y1, x2 - x1);
    return {
      dx: cos(rad) * d,
      dy: sin(rad) * d
    };
  }
  function addStartArrow(shape, attrs, x1, y1, x2, y2) {
    if (typeof attrs.startArrow === "object") {
      _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
    } else if (attrs.startArrow) {
      _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
    } else {
      shape.set("startArrowShape", null);
    }
  }
  function addEndArrow(shape, attrs, x1, y1, x2, y2) {
    if (typeof attrs.endArrow === "object") {
      _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
    } else if (attrs.endArrow) {
      _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
    } else {
      shape.set("startArrowShape", null);
    }
  }

  // node_modules/@antv/g-canvas/esm/util/draw.js
  var SHAPE_ATTRS_MAP = {
    fill: "fillStyle",
    stroke: "strokeStyle",
    opacity: "globalAlpha"
  };
  function applyAttrsToContext(context, element) {
    var attrs = element.attr();
    for (var k in attrs) {
      var v = attrs[k];
      var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
      if (name_1 === "matrix" && v) {
        context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
      } else if (name_1 === "lineDash" && context.setLineDash) {
        is_array_default(v) && context.setLineDash(v);
      } else {
        if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
          v = parseStyle(context, element, v);
        } else if (name_1 === "globalAlpha") {
          v = v * context.globalAlpha;
        }
        context[name_1] = v;
      }
    }
  }
  function drawChildren(context, children, region) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.cfg.visible) {
        child.draw(context, region);
      } else {
        child.skipDraw();
      }
    }
  }
  function checkRefresh(canvas, children, region) {
    var refreshElements = canvas.get("refreshElements");
    each_default(refreshElements, function(el) {
      if (el !== canvas) {
        var parent_1 = el.cfg.parent;
        while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
          parent_1.cfg.refresh = true;
          parent_1 = parent_1.cfg.parent;
        }
      }
    });
    if (refreshElements[0] === canvas) {
      setChildrenRefresh(children, region);
    } else {
      checkChildrenRefresh(children, region);
    }
  }
  function checkChildrenRefresh(children, region) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.cfg.visible) {
        if (child.cfg.hasChanged) {
          child.cfg.refresh = true;
          if (child.isGroup()) {
            setChildrenRefresh(child.cfg.children, region);
          }
        } else if (child.cfg.refresh) {
          if (child.isGroup()) {
            checkChildrenRefresh(child.cfg.children, region);
          }
        } else {
          var refresh = checkElementRefresh(child, region);
          child.cfg.refresh = refresh;
          if (refresh && child.isGroup()) {
            checkChildrenRefresh(child.cfg.children, region);
          }
        }
      }
    }
  }
  function clearChanged(elements) {
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      el.cfg.hasChanged = false;
      if (el.isGroup() && !el.destroyed) {
        clearChanged(el.cfg.children);
      }
    }
  }
  function setChildrenRefresh(children, region) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      child.cfg.refresh = true;
      if (child.isGroup()) {
        setChildrenRefresh(child.get("children"), region);
      }
    }
  }
  function checkElementRefresh(shape, region) {
    var bbox = shape.cfg.cacheCanvasBBox;
    var isAllow = shape.cfg.isInView && bbox && intersectRect2(bbox, region);
    return isAllow;
  }
  function drawPath(shape, context, attrs, arcParamsCache) {
    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (!path) {
      return;
    }
    var currentPoint = [0, 0];
    var startMovePoint = [0, 0];
    var distance8 = {
      dx: 0,
      dy: 0
    };
    context.beginPath();
    for (var i = 0; i < path.length; i++) {
      var params = path[i];
      var command = params[0];
      if (i === 0 && startArrow && startArrow.d) {
        var tangent = shape.getStartTangent();
        distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
      } else if (i === path.length - 2 && path[i + 1][0] === "Z" && endArrow && endArrow.d) {
        var lastPath = path[i + 1];
        if (lastPath[0] === "Z") {
          var tangent = shape.getEndTangent();
          distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
        }
      } else if (i === path.length - 1 && endArrow && endArrow.d) {
        if (path[0] !== "Z") {
          var tangent = shape.getEndTangent();
          distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
        }
      }
      var dx = distance8.dx, dy = distance8.dy;
      switch (command) {
        case "M":
          context.moveTo(params[1] - dx, params[2] - dy);
          startMovePoint = [params[1], params[2]];
          break;
        case "L":
          context.lineTo(params[1] - dx, params[2] - dy);
          break;
        case "Q":
          context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
          break;
        case "C":
          context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
          break;
        case "A": {
          var arcParams = void 0;
          if (arcParamsCache) {
            arcParams = arcParamsCache[i];
            if (!arcParams) {
              arcParams = getArcParams2(currentPoint, params);
              arcParamsCache[i] = arcParams;
            }
          } else {
            arcParams = getArcParams2(currentPoint, params);
          }
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          break;
        }
        case "Z":
          context.closePath();
          break;
        default:
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
      } else {
        var len3 = params.length;
        currentPoint = [params[len3 - 2], params[len3 - 1]];
      }
    }
  }
  function refreshElement(element, changeType) {
    var canvas = element.get("canvas");
    if (canvas) {
      if (changeType === "remove") {
        element._cacheCanvasBBox = element.get("cacheCanvasBBox");
      }
      if (!element.get("hasChanged")) {
        element.set("hasChanged", true);
        if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
          canvas.refreshElement(element, changeType, canvas);
          if (canvas.get("autoDraw")) {
            canvas.draw();
          }
        }
      }
    }
  }
  function getRefreshRegion(element) {
    var region;
    if (!element.destroyed) {
      var cacheBox = element.get("cacheCanvasBBox");
      var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
      var bbox = element.getCanvasBBox();
      var validBBox = bbox && !!(bbox.width && bbox.height);
      if (validCache && validBBox) {
        region = mergeRegion(cacheBox, bbox);
      } else if (validCache) {
        region = cacheBox;
      } else if (validBBox) {
        region = bbox;
      }
    } else {
      region = element["_cacheCanvasBBox"];
    }
    return region;
  }
  function getMergedRegion(elements) {
    if (!elements.length) {
      return null;
    }
    var minXArr = [];
    var minYArr = [];
    var maxXArr = [];
    var maxYArr = [];
    each_default(elements, function(el) {
      var region = getRefreshRegion(el);
      if (region) {
        minXArr.push(region.minX);
        minYArr.push(region.minY);
        maxXArr.push(region.maxX);
        maxYArr.push(region.maxY);
      }
    });
    return {
      minX: min_default(minXArr),
      minY: min_default(minYArr),
      maxX: max_default(maxXArr),
      maxY: max_default(maxYArr)
    };
  }
  function mergeView(region, viewRegion) {
    if (!region || !viewRegion) {
      return null;
    }
    if (!intersectRect2(region, viewRegion)) {
      return null;
    }
    return {
      minX: Math.max(region.minX, viewRegion.minX),
      minY: Math.max(region.minY, viewRegion.minY),
      maxX: Math.min(region.maxX, viewRegion.maxX),
      maxY: Math.min(region.maxY, viewRegion.maxY)
    };
  }

  // node_modules/@antv/g-canvas/esm/group.js
  var Group = function(_super) {
    __extends8(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    Group3.prototype.cacheCanvasBBox = function() {
      var children = this.cfg.children;
      var xArr = [];
      var yArr = [];
      each_default(children, function(child) {
        var bbox2 = child.cfg.cacheCanvasBBox;
        if (bbox2 && child.cfg.isInView) {
          xArr.push(bbox2.minX, bbox2.maxX);
          yArr.push(bbox2.minY, bbox2.maxY);
        }
      });
      var bbox = null;
      if (xArr.length) {
        var minX = min_default(xArr);
        var maxX = max_default(xArr);
        var minY = min_default(yArr);
        var maxY = max_default(yArr);
        bbox = {
          minX,
          minY,
          x: minX,
          y: minY,
          maxX,
          maxY,
          width: maxX - minX,
          height: maxY - minY
        };
        var canvas = this.cfg.canvas;
        if (canvas) {
          var viewRange = canvas.getViewRange();
          this.set("isInView", intersectRect2(bbox, viewRange));
        }
      } else {
        this.set("isInView", false);
      }
      this.set("cacheCanvasBBox", bbox);
    };
    Group3.prototype.draw = function(context, region) {
      var children = this.cfg.children;
      var allowDraw = region ? this.cfg.refresh : true;
      if (children.length && allowDraw) {
        context.save();
        applyAttrsToContext(context, this);
        this._applyClip(context, this.getClip());
        drawChildren(context, children, region);
        context.restore();
        this.cacheCanvasBBox();
      }
      this.cfg.refresh = null;
      this.set("hasChanged", false);
    };
    Group3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("hasChanged", false);
    };
    return Group3;
  }(group_default2);
  var group_default4 = Group;

  // node_modules/@antv/g-canvas/esm/shape/base.js
  var ShapeBase2 = function(_super) {
    __extends8(ShapeBase4, _super);
    function ShapeBase4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    ShapeBase4.prototype.getGroupBase = function() {
      return group_default4;
    };
    ShapeBase4.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase4.prototype.calculateBBox = function() {
      var type = this.get("type");
      var lineWidth = this.getHitLineWidth();
      var bboxMethod = getMethod(type);
      var box2 = bboxMethod(this);
      var halfLineWidth = lineWidth / 2;
      var minX = box2.x - halfLineWidth;
      var minY = box2.y - halfLineWidth;
      var maxX = box2.x + box2.width + halfLineWidth;
      var maxY = box2.y + box2.height + halfLineWidth;
      return {
        x: minX,
        minX,
        y: minY,
        minY,
        width: box2.width + lineWidth,
        height: box2.height + lineWidth,
        maxX,
        maxY
      };
    };
    ShapeBase4.prototype.isFill = function() {
      return !!this.attrs["fill"] || this.isClipShape();
    };
    ShapeBase4.prototype.isStroke = function() {
      return !!this.attrs["stroke"];
    };
    ShapeBase4.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    ShapeBase4.prototype.draw = function(context, region) {
      var clip = this.cfg.clipShape;
      if (region) {
        if (this.cfg.refresh === false) {
          this.set("hasChanged", false);
          return;
        }
        var bbox = this.getCanvasBBox();
        if (!intersectRect2(region, bbox)) {
          this.set("hasChanged", false);
          if (this.cfg.isInView) {
            this._afterDraw();
          }
          return;
        }
      }
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, clip);
      this.drawPath(context);
      context.restore();
      this._afterDraw();
    };
    ShapeBase4.prototype.getCanvasViewBox = function() {
      var canvas = this.cfg.canvas;
      if (canvas) {
        return canvas.getViewRange();
      }
      return null;
    };
    ShapeBase4.prototype.cacheCanvasBBox = function() {
      var canvasBBox = this.getCanvasViewBox();
      if (canvasBBox) {
        var bbox = this.getCanvasBBox();
        var isInView = intersectRect2(bbox, canvasBBox);
        this.set("isInView", isInView);
        if (isInView) {
          this.set("cacheCanvasBBox", bbox);
        } else {
          this.set("cacheCanvasBBox", null);
        }
      }
    };
    ShapeBase4.prototype._afterDraw = function() {
      this.cacheCanvasBBox();
      this.set("hasChanged", false);
      this.set("refresh", null);
    };
    ShapeBase4.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("isInView", null);
      this.set("hasChanged", false);
    };
    ShapeBase4.prototype.drawPath = function(context) {
      this.createPath(context);
      this.strokeAndFill(context);
      this.afterDrawPath(context);
    };
    ShapeBase4.prototype.fill = function(context) {
      context.fill();
    };
    ShapeBase4.prototype.stroke = function(context) {
      context.stroke();
    };
    ShapeBase4.prototype.strokeAndFill = function(context) {
      var _a4 = this.attrs, lineWidth = _a4.lineWidth, opacity = _a4.opacity, strokeOpacity = _a4.strokeOpacity, fillOpacity = _a4.fillOpacity;
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = strokeOpacity;
          }
          this.stroke(context);
        }
      }
      this.afterDrawPath(context);
    };
    ShapeBase4.prototype.createPath = function(context) {
    };
    ShapeBase4.prototype.afterDrawPath = function(context) {
    };
    ShapeBase4.prototype.isInShape = function(refX, refY) {
      var isStroke = this.isStroke();
      var isFill = this.isFill();
      var lineWidth = this.getHitLineWidth();
      return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    ShapeBase4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      return false;
    };
    ShapeBase4.prototype.getHitLineWidth = function() {
      if (!this.isStroke()) {
        return 0;
      }
      var attrs = this.attrs;
      return attrs["lineWidth"] + attrs["lineAppendWidth"];
    };
    return ShapeBase4;
  }(shape_default);
  var base_default16 = ShapeBase2;

  // node_modules/@antv/g-canvas/esm/shape/circle.js
  var Circle3 = function(_super) {
    __extends8(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      var halfLineWidth = lineWidth / 2;
      var absDistance = distance7(cx, cy, x, y);
      if (isFill && isStroke) {
        return absDistance <= r + halfLineWidth;
      }
      if (isFill) {
        return absDistance <= r;
      }
      if (isStroke) {
        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
      }
      return false;
    };
    Circle6.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      context.beginPath();
      context.arc(cx, cy, r, 0, Math.PI * 2, false);
      context.closePath();
    };
    return Circle6;
  }(base_default16);
  var circle_default6 = Circle3;

  // node_modules/@antv/g-canvas/esm/shape/ellipse.js
  function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
  }
  var Ellipse = function(_super) {
    __extends8(Ellipse3, _super);
    function Ellipse3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var halfLineWith = lineWidth / 2;
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx, ry = attrs.ry;
      var squareX = (x - cx) * (x - cx);
      var squareY = (y - cy) * (y - cy);
      if (isFill && isStroke) {
        return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      if (isFill) {
        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
      }
      if (isStroke) {
        return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      return false;
    };
    Ellipse3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx;
      var ry = attrs.ry;
      context.beginPath();
      if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
      } else {
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.translate(cx, cy);
        context.scale(scaleX, scaleY);
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.restore();
        context.closePath();
      }
    };
    return Ellipse3;
  }(base_default16);
  var ellipse_default4 = Ellipse;

  // node_modules/@antv/g-canvas/esm/shape/image.js
  function isCanvas(dom) {
    return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
  }
  var ImageShape = function(_super) {
    __extends8(ImageShape2, _super);
    function ImageShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape2.prototype.initAttrs = function(attrs) {
      this._setImage(attrs.img);
    };
    ImageShape2.prototype.isStroke = function() {
      return false;
    };
    ImageShape2.prototype.isOnlyHitBox = function() {
      return true;
    };
    ImageShape2.prototype._afterLoading = function() {
      if (this.get("toDraw") === true) {
        var canvas = this.get("canvas");
        if (canvas) {
          canvas.draw();
        } else {
          this.createPath(this.get("context"));
        }
      }
    };
    ImageShape2.prototype._setImage = function(img) {
      var _this = this;
      var attrs = this.attrs;
      if (is_string_default(img)) {
        var image_1 = new Image();
        image_1.onload = function() {
          if (_this.destroyed) {
            return false;
          }
          _this.attr("img", image_1);
          _this.set("loading", false);
          _this._afterLoading();
          var callback = _this.get("callback");
          if (callback) {
            callback.call(_this);
          }
        };
        image_1.crossOrigin = "Anonymous";
        image_1.src = img;
        this.set("loading", true);
      } else if (img instanceof Image) {
        if (!attrs.width) {
          attrs.width = img.width;
        }
        if (!attrs.height) {
          attrs.height = img.height;
        }
      } else if (isCanvas(img)) {
        if (!attrs.width) {
          attrs.width = Number(img.getAttribute("width"));
        }
        if (!attrs.height) {
          attrs.height, Number(img.getAttribute("height"));
        }
      }
    };
    ImageShape2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "img") {
        this._setImage(value);
      }
    };
    ImageShape2.prototype.createPath = function(context) {
      if (this.get("loading")) {
        this.set("toDraw", true);
        this.set("context", context);
        return;
      }
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
      var img = attrs.img;
      if (img instanceof Image || isCanvas(img)) {
        if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
          context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
        } else {
          context.drawImage(img, x, y, width, height);
        }
      }
    };
    return ImageShape2;
  }(base_default16);
  var image_default2 = ImageShape;

  // node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
  function inLine(x1, y1, x2, y2, lineWidth, x, y) {
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var halfWidth = lineWidth / 2;
    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
      return false;
    }
    return line_default.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
  }

  // node_modules/@antv/g-canvas/esm/shape/line.js
  var Line3 = function(_super) {
    __extends8(Line6, _super);
    function Line6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line6.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    Line6.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
    };
    Line6.prototype.setArrow = function() {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        addStartArrow(this, attrs, x2, y2, x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, x1, y1, x2, y2);
      }
    };
    Line6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return inLine(x1, y1, x2, y2, lineWidth, x, y);
    };
    Line6.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      var startArrowDistance = {
        dx: 0,
        dy: 0
      };
      var endArrowDistance = {
        dx: 0,
        dy: 0
      };
      if (startArrow && startArrow.d) {
        startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
      }
      if (endArrow && endArrow.d) {
        endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
      }
      context.beginPath();
      context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
      context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
    };
    Line6.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Line6.prototype.getTotalLength = function() {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line6.prototype.getPoint = function(ratio) {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line6;
  }(base_default16);
  var line_default8 = Line3;

  // node_modules/@antv/g-canvas/esm/shape/marker.js
  var Symbols = {
    circle: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["A", r, r, 0, 1, 0, x + r, y],
        ["A", r, r, 0, 1, 0, x - r, y]
      ];
    },
    square: function(x, y, r) {
      return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
    },
    diamond: function(x, y, r) {
      return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
    },
    triangle: function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
    },
    "triangle-down": function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
    }
  };
  var Marker = function(_super) {
    __extends8(Marker3, _super);
    function Marker3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker3.prototype.initAttrs = function(attrs) {
      this._resetParamsCache();
    };
    Marker3.prototype._resetParamsCache = function() {
      this.set("paramsCache", {});
    };
    Marker3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
        this._resetParamsCache();
      }
    };
    Marker3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Marker3.prototype._getR = function(attrs) {
      return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var symbol = attrs.symbol || "circle";
      var r = this._getR(attrs);
      var method;
      var path;
      if (is_function_default(symbol)) {
        method = symbol;
        path = method(x, y, r);
        path = pathToAbsolute2(path);
      } else {
        method = Marker3.Symbols[symbol];
        if (!method) {
          console.warn(symbol + " marker is not supported.");
          return null;
        }
        path = method(x, y, r);
      }
      return path;
    };
    Marker3.prototype.createPath = function(context) {
      var path = this._getPath();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, { path }, paramsCache);
    };
    Marker3.Symbols = Symbols;
    return Marker3;
  }(base_default16);
  var marker_default = Marker;

  // node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
  function isPointInPath(shape, x, y) {
    var ctx3 = getOffScreenContext();
    shape.createPath(ctx3);
    return ctx3.isPointInPath(x, y);
  }

  // node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
  var tolerance2 = 1e-6;
  function dcmp2(x) {
    if (Math.abs(x) < tolerance2) {
      return 0;
    }
    return x < 0 ? -1 : 1;
  }
  function onSegment2(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
      return true;
    }
    return false;
  }
  function isInPolygon2(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
      return false;
    }
    for (var i = 0; i < n; i++) {
      var p1 = points[i];
      var p2 = points[(i + 1) % n];
      if (onSegment2(p1, p2, [x, y])) {
        return true;
      }
      if (dcmp2(p1[1] - y) > 0 !== dcmp2(p2[1] - y) > 0 && dcmp2(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }

  // node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
  function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
    var angle3 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
    if (angle3 < startAngle || angle3 > endAngle) {
      return false;
    }
    var point = {
      x: cx + r * Math.cos(angle3),
      y: cy + r * Math.sin(angle3)
    };
    return distance7(point.x, point.y, x, y) <= lineWidth / 2;
  }

  // node_modules/@antv/g-canvas/esm/util/path.js
  var transform5 = ext_exports.transform;
  function hasArc(path) {
    var hasArc2 = false;
    var count = path.length;
    for (var i = 0; i < count; i++) {
      var params = path[i];
      var cmd = params[0];
      if (cmd === "C" || cmd === "A" || cmd === "Q") {
        hasArc2 = true;
        break;
      }
    }
    return hasArc2;
  }
  function isPointInStroke(segments, lineWidth, x, y, length3) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
      if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
        continue;
      }
      switch (segment.command) {
        case "L":
        case "Z":
          isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
          break;
        case "Q":
          var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
          isHit = qDistance <= lineWidth / 2;
          break;
        case "C":
          var cDistance = cubic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], x, y, length3);
          isHit = cDistance <= lineWidth / 2;
          break;
        case "A":
          var arcParams = segment.arcParams;
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
          var p2 = [x, y, 1];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var m = transform5(null, [
            ["t", -cx, -cy],
            ["r", -xRotation],
            ["s", 1 / scaleX, 1 / scaleY]
          ]);
          transformMat3(p2, p2, m);
          isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p2[0], p2[1]);
          break;
        default:
          break;
      }
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  function extractPolygons(path) {
    var count = path.length;
    var polygons = [];
    var polylines = [];
    var points = [];
    for (var i = 0; i < count; i++) {
      var params = path[i];
      var cmd = params[0];
      if (cmd === "M") {
        if (points.length) {
          polylines.push(points);
          points = [];
        }
        points.push([params[1], params[2]]);
      } else if (cmd === "Z") {
        if (points.length) {
          polygons.push(points);
          points = [];
        }
      } else {
        points.push([params[1], params[2]]);
      }
    }
    if (points.length > 0) {
      polylines.push(points);
    }
    return {
      polygons,
      polylines
    };
  }
  var path_default4 = __assign8({ hasArc, extractPolygons, isPointInStroke }, path_exports);

  // node_modules/@antv/g-canvas/esm/shape/path.js
  function isInPolygons(polygons, x, y) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i];
      isHit = isInPolygon2(points, x, y);
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  var Path = function(_super) {
    __extends8(Path4, _super);
    function Path4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Path4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { startArrow: false, endArrow: false });
    };
    Path4.prototype.initAttrs = function(attrs) {
      this._setPathArr(attrs.path);
      this.setArrow();
    };
    Path4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "path") {
        this._setPathArr(value);
      }
      this.setArrow();
    };
    Path4.prototype._setPathArr = function(path) {
      this.attrs.path = pathToAbsolute2(path);
      var hasArc2 = path_default4.hasArc(path);
      this.set("hasArc", hasArc2);
      this.set("paramsCache", {});
      this.set("segments", null);
      this.set("curve", null);
      this.set("tCache", null);
      this.set("totalLength", null);
    };
    Path4.prototype.getSegments = function() {
      var segments = this.get("segements");
      if (!segments) {
        segments = getSegments(this.attr("path"));
        this.set("segments", segments);
      }
      return segments;
    };
    Path4.prototype.setArrow = function() {
      var attrs = this.attr();
      var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        var tangent = this.getStartTangent();
        addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
      if (endArrow) {
        var tangent = this.getEndTangent();
        addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
    };
    Path4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var segments = this.getSegments();
      var hasArc2 = this.get("hasArc");
      var isHit = false;
      if (isStroke) {
        var length_1 = this.getTotalLength();
        isHit = path_default4.isPointInStroke(segments, lineWidth, x, y, length_1);
      }
      if (!isHit && isFill) {
        if (hasArc2) {
          isHit = isPointInPath(this, x, y);
        } else {
          var path = this.attr("path");
          var extractResutl = path_default4.extractPolygons(path);
          isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
        }
      }
      return isHit;
    };
    Path4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, attrs, paramsCache);
    };
    Path4.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Path4.prototype.getTotalLength = function() {
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this._calculateCurve();
      this._setTcache();
      return this.get("totalLength");
    };
    Path4.prototype.getPoint = function(ratio) {
      var tCache = this.get("tCache");
      if (!tCache) {
        this._calculateCurve();
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      var curve = this.get("curve");
      if (!tCache || tCache.length === 0) {
        if (curve) {
          return {
            x: curve[0][1],
            y: curve[0][2]
          };
        }
        return null;
      }
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      var seg = curve[index];
      if (is_nil_default(seg) || is_nil_default(index)) {
        return null;
      }
      var l = seg.length;
      var nextSeg = curve[index + 1];
      return cubic_default.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path4.prototype._calculateCurve = function() {
      var path = this.attr().path;
      this.set("curve", path_default4.pathToCurve(path));
    };
    Path4.prototype._setTcache = function() {
      var totalLength = 0;
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      var segmentN;
      var l;
      var curve = this.get("curve");
      if (!curve) {
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          totalLength += cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
        }
      });
      this.set("totalLength", totalLength);
      if (totalLength === 0) {
        this.set("tCache", []);
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
          tempLength += segmentL || 0;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Path4.prototype.getStartTangent = function() {
      var segments = this.getSegments();
      var result;
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    };
    Path4.prototype.getEndTangent = function() {
      var segments = this.getSegments();
      var length3 = segments.length;
      var result;
      if (length3 > 1) {
        var startPoint = segments[length3 - 2].currentPoint;
        var endPoint = segments[length3 - 1].currentPoint;
        var tangent = segments[length3 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    };
    return Path4;
  }(base_default16);
  var path_default3 = Path;

  // node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
  function inPolyline(points, lineWidth, x, y, isClose) {
    var count = points.length;
    if (count < 2) {
      return false;
    }
    for (var i = 0; i < count - 1; i++) {
      var x1 = points[i][0];
      var y1 = points[i][1];
      var x2 = points[i + 1][0];
      var y2 = points[i + 1][1];
      if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
        return true;
      }
    }
    if (isClose) {
      var first = points[0];
      var last2 = points[count - 1];
      if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
        return true;
      }
    }
    return false;
  }

  // node_modules/@antv/g-canvas/esm/shape/polygon.js
  var Polygon = function(_super) {
    __extends8(Polygon4, _super);
    function Polygon4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var points = this.attr().points;
      var isHit = false;
      if (isStroke) {
        isHit = inPolyline(points, lineWidth, x, y, true);
      }
      if (!isHit && isFill) {
        isHit = isInPolygon2(points, x, y);
      }
      return isHit;
    };
    Polygon4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var points = attrs.points;
      if (points.length < 2) {
        return;
      }
      context.beginPath();
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        if (i === 0) {
          context.moveTo(point[0], point[1]);
        } else {
          context.lineTo(point[0], point[1]);
        }
      }
      context.closePath();
    };
    return Polygon4;
  }(base_default16);
  var polygon_default4 = Polygon;

  // node_modules/@antv/g-canvas/esm/shape/polyline.js
  var PolyLine = function(_super) {
    __extends8(PolyLine2, _super);
    function PolyLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    PolyLine2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    PolyLine2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    PolyLine2.prototype.setArrow = function() {
      var attrs = this.attr();
      var _a4 = this.attrs, points = _a4.points, startArrow = _a4.startArrow, endArrow = _a4.endArrow;
      var length3 = points.length;
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x2 = points[length3 - 1][0];
      var y2 = points[length3 - 1][1];
      if (startArrow) {
        addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, points[length3 - 2][0], points[length3 - 2][1], x2, y2);
      }
    };
    PolyLine2.prototype.isFill = function() {
      return false;
    };
    PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var points = this.attr().points;
      return inPolyline(points, lineWidth, x, y, false);
    };
    PolyLine2.prototype.isStroke = function() {
      return true;
    };
    PolyLine2.prototype.createPath = function(context) {
      var _a4 = this.attr(), points = _a4.points, startArrow = _a4.startArrow, endArrow = _a4.endArrow;
      var length3 = points.length;
      if (points.length < 2) {
        return;
      }
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x2 = points[length3 - 1][0];
      var y2 = points[length3 - 1][1];
      if (startArrow && startArrow.d) {
        var distance8 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
        x1 += distance8.dx;
        y1 += distance8.dy;
      }
      if (endArrow && endArrow.d) {
        var distance8 = getShortenOffset(points[length3 - 2][0], points[length3 - 2][1], x2, y2, endArrow.d);
        x2 -= distance8.dx;
        y2 -= distance8.dy;
      }
      context.beginPath();
      context.moveTo(x1, y1);
      for (var i = 0; i < length3 - 1; i++) {
        var point = points[i];
        context.lineTo(point[0], point[1]);
      }
      context.lineTo(x2, y2);
    };
    PolyLine2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    PolyLine2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    PolyLine2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    PolyLine2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p2, i) {
        if (points[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p2[0], p2[1], points[i + 1][0], points[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    PolyLine2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    PolyLine2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return PolyLine2;
  }(base_default16);
  var polyline_default4 = PolyLine;

  // node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
  function inRect(minX, minY, width, height, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
  }

  // node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
  function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
  }

  // node_modules/@antv/g-canvas/esm/shape/rect.js
  var Rect = function(_super) {
    __extends8(Rect4, _super);
    function Rect4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var minX = attrs.x;
      var minY = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        var halfWidth = lineWidth / 2;
        if (isFill && isStroke) {
          return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
        }
        if (isFill) {
          return inBox(minX, minY, width, height, x, y);
        }
        if (isStroke) {
          return inRect(minX, minY, width, height, lineWidth, x, y);
        }
      } else {
        var isHit = false;
        if (isStroke) {
          isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
        }
        if (!isHit && isFill) {
          isHit = isPointInPath(this, x, y);
        }
        return isHit;
      }
    };
    Rect4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      context.beginPath();
      if (radius === 0) {
        context.rect(x, y, width, height);
      } else {
        var _a4 = parseRadius(radius), r1 = _a4[0], r2 = _a4[1], r3 = _a4[2], r4 = _a4[3];
        context.moveTo(x + r1, y);
        context.lineTo(x + width - r2, y);
        r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
        context.lineTo(x + width, y + height - r3);
        r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
        context.lineTo(x + r4, y + height);
        r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
        context.lineTo(x, y + r1);
        r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
        context.closePath();
      }
    };
    return Rect4;
  }(base_default16);
  var rect_default3 = Rect;

  // node_modules/@antv/g-canvas/esm/shape/text.js
  var Text2 = function(_super) {
    __extends8(Text4, _super);
    function Text4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Text4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text4.prototype.isOnlyHitBox = function() {
      return true;
    };
    Text4.prototype.initAttrs = function(attrs) {
      this._assembleFont();
      if (attrs.text) {
        this._setText(attrs.text);
      }
    };
    Text4.prototype._assembleFont = function() {
      var attrs = this.attrs;
      attrs.font = assembleFont(attrs);
    };
    Text4.prototype._setText = function(text) {
      var textArr = null;
      if (is_string_default(text) && text.indexOf("\n") !== -1) {
        textArr = text.split("\n");
      }
      this.set("textArr", textArr);
    };
    Text4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name.startsWith("font")) {
        this._assembleFont();
      }
      if (name === "text") {
        this._setText(value);
      }
    };
    Text4.prototype._getSpaceingY = function() {
      var attrs = this.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    Text4.prototype._drawTextArr = function(context, textArr, isFill) {
      var attrs = this.attrs;
      var textBaseline = attrs.textBaseline;
      var x = attrs.x;
      var y = attrs.y;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
      var subY;
      each_default(textArr, function(subText, index) {
        subY = y + index * (spaceingY + fontSize) - height + fontSize;
        if (textBaseline === "middle")
          subY += height - fontSize - (height - fontSize) / 2;
        if (textBaseline === "top")
          subY += height - fontSize;
        if (!is_nil_default(subText)) {
          if (isFill) {
            context.fillText(subText, x, subY);
          } else {
            context.strokeText(subText, x, subY);
          }
        }
      });
    };
    Text4.prototype._drawText = function(context, isFill) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var textArr = this.get("textArr");
      if (textArr) {
        this._drawTextArr(context, textArr, isFill);
      } else {
        var text = attrs.text;
        if (!is_nil_default(text)) {
          if (isFill) {
            context.fillText(text, x, y);
          } else {
            context.strokeText(text, x, y);
          }
        }
      }
    };
    Text4.prototype.strokeAndFill = function(context) {
      var _a4 = this.attrs, lineWidth = _a4.lineWidth, opacity = _a4.opacity, strokeOpacity = _a4.strokeOpacity, fillOpacity = _a4.fillOpacity;
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = opacity;
          }
          this.stroke(context);
        }
      }
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      this.afterDrawPath(context);
    };
    Text4.prototype.fill = function(context) {
      this._drawText(context, true);
    };
    Text4.prototype.stroke = function(context) {
      this._drawText(context, false);
    };
    return Text4;
  }(base_default16);
  var text_default4 = Text2;

  // node_modules/@antv/g-canvas/esm/util/hit.js
  function invertFromMatrix(v, matrix) {
    if (matrix) {
      var invertMatrix = invert2(matrix);
      return multiplyVec2(invertMatrix, v);
    }
    return v;
  }
  function getRefXY(element, x, y) {
    var totalMatrix = element.getTotalMatrix();
    if (totalMatrix) {
      var _a4 = invertFromMatrix([x, y, 1], totalMatrix), refX = _a4[0], refY = _a4[1];
      return [refX, refY];
    }
    return [x, y];
  }
  function preTest(element, x, y) {
    if (element.isCanvas && element.isCanvas()) {
      return true;
    }
    if (!isAllowCapture(element) || element.cfg.isInView === false) {
      return false;
    }
    if (element.cfg.clipShape) {
      var _a4 = getRefXY(element, x, y), refX = _a4[0], refY = _a4[1];
      if (element.isClipped(refX, refY)) {
        return false;
      }
    }
    var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
    if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
      return false;
    }
    return true;
  }
  function getShape(container, x, y) {
    if (!preTest(container, x, y)) {
      return null;
    }
    var shape = null;
    var children = container.getChildren();
    var count = children.length;
    for (var i = count - 1; i >= 0; i--) {
      var child = children[i];
      if (child.isGroup()) {
        shape = getShape(child, x, y);
      } else if (preTest(child, x, y)) {
        var curShape = child;
        var _a4 = getRefXY(child, x, y), refX = _a4[0], refY = _a4[1];
        if (curShape.isInShape(refX, refY)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  }

  // node_modules/@antv/g-canvas/esm/canvas.js
  var Canvas3 = function(_super) {
    __extends8(Canvas5, _super);
    function Canvas5() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas5.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["renderer"] = "canvas";
      cfg["autoDraw"] = true;
      cfg["localRefresh"] = true;
      cfg["refreshElements"] = [];
      cfg["clipView"] = true;
      cfg["quickHit"] = false;
      return cfg;
    };
    Canvas5.prototype.onCanvasChange = function(changeType) {
      if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
        this.set("refreshElements", [this]);
        this.draw();
      }
    };
    Canvas5.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Canvas5.prototype.getGroupBase = function() {
      return group_default4;
    };
    Canvas5.prototype.getPixelRatio = function() {
      var pixelRatio = this.get("pixelRatio") || getPixelRatio();
      return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas5.prototype.getViewRange = function() {
      return {
        minX: 0,
        minY: 0,
        maxX: this.cfg.width,
        maxY: this.cfg.height
      };
    };
    Canvas5.prototype.createDom = function() {
      var element = document.createElement("canvas");
      var context = element.getContext("2d");
      this.set("context", context);
      return element;
    };
    Canvas5.prototype.setDOMSize = function(width, height) {
      _super.prototype.setDOMSize.call(this, width, height);
      var context = this.get("context");
      var el = this.get("el");
      var pixelRatio = this.getPixelRatio();
      el.width = pixelRatio * width;
      el.height = pixelRatio * height;
      if (pixelRatio > 1) {
        context.scale(pixelRatio, pixelRatio);
      }
    };
    Canvas5.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this._clearFrame();
      var context = this.get("context");
      var element = this.get("el");
      context.clearRect(0, 0, element.width, element.height);
    };
    Canvas5.prototype.getShape = function(x, y) {
      var shape;
      if (this.get("quickHit")) {
        shape = getShape(this, x, y);
      } else {
        shape = _super.prototype.getShape.call(this, x, y, null);
      }
      return shape;
    };
    Canvas5.prototype._getRefreshRegion = function() {
      var elements = this.get("refreshElements");
      var viewRegion = this.getViewRange();
      var region;
      if (elements.length && elements[0] === this) {
        region = viewRegion;
      } else {
        region = getMergedRegion(elements);
        if (region) {
          region.minX = Math.floor(region.minX);
          region.minY = Math.floor(region.minY);
          region.maxX = Math.ceil(region.maxX);
          region.maxY = Math.ceil(region.maxY);
          region.maxY += 1;
          var clipView = this.get("clipView");
          if (clipView) {
            region = mergeView(region, viewRegion);
          }
        }
      }
      return region;
    };
    Canvas5.prototype.refreshElement = function(element) {
      var refreshElements = this.get("refreshElements");
      refreshElements.push(element);
    };
    Canvas5.prototype._clearFrame = function() {
      var drawFrame = this.get("drawFrame");
      if (drawFrame) {
        cancelAnimationFrame(drawFrame);
        this.set("drawFrame", null);
        this.set("refreshElements", []);
      }
    };
    Canvas5.prototype.draw = function() {
      var drawFrame = this.get("drawFrame");
      if (this.get("autoDraw") && drawFrame) {
        return;
      }
      this._startDraw();
    };
    Canvas5.prototype._drawAll = function() {
      var context = this.get("context");
      var element = this.get("el");
      var children = this.getChildren();
      context.clearRect(0, 0, element.width, element.height);
      applyAttrsToContext(context, this);
      drawChildren(context, children);
      this.set("refreshElements", []);
    };
    Canvas5.prototype._drawRegion = function() {
      var context = this.get("context");
      var refreshElements = this.get("refreshElements");
      var children = this.getChildren();
      var region = this._getRefreshRegion();
      if (region) {
        context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.save();
        context.beginPath();
        context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.clip();
        applyAttrsToContext(context, this);
        checkRefresh(this, children, region);
        drawChildren(context, children, region);
        context.restore();
      } else if (refreshElements.length) {
        clearChanged(refreshElements);
      }
      each_default(refreshElements, function(element) {
        if (element.get("hasChanged")) {
          element.set("hasChanged", false);
        }
      });
      this.set("refreshElements", []);
    };
    Canvas5.prototype._startDraw = function() {
      var _this = this;
      var drawFrame = this.get("drawFrame");
      if (!drawFrame) {
        drawFrame = requestAnimationFrame2(function() {
          if (_this.get("localRefresh")) {
            _this._drawRegion();
          } else {
            _this._drawAll();
          }
          _this.set("drawFrame", null);
        });
        this.set("drawFrame", drawFrame);
      }
    };
    Canvas5.prototype.skipDraw = function() {
    };
    Canvas5.prototype.removeDom = function() {
      var el = this.get("el");
      el.width = 0;
      el.height = 0;
      el.parentNode.removeChild(el);
    };
    return Canvas5;
  }(canvas_default);
  var canvas_default3 = Canvas3;

  // node_modules/@antv/g-canvas/esm/index.js
  var version2 = "0.5.12";

  // node_modules/@antv/g-svg/esm/index.js
  var esm_exports2 = {};
  __export(esm_exports2, {
    AbstractCanvas: () => canvas_default,
    AbstractGroup: () => group_default2,
    AbstractShape: () => shape_default,
    Base: () => base_default2,
    Canvas: () => canvas_default4,
    Event: () => graph_event_default,
    Group: () => group_default5,
    PathUtil: () => path_exports,
    Shape: () => shape_exports2,
    assembleFont: () => assembleFont,
    getBBoxMethod: () => getMethod,
    getOffScreenContext: () => getOffScreenContext,
    getTextHeight: () => getTextHeight,
    invert: () => invert2,
    isAllowCapture: () => isAllowCapture,
    multiplyVec2: () => multiplyVec2,
    version: () => version3
  });

  // node_modules/@antv/g-svg/esm/shape/index.js
  var shape_exports2 = {};
  __export(shape_exports2, {
    Base: () => base_default17,
    Circle: () => circle_default7,
    Dom: () => dom_default,
    Ellipse: () => ellipse_default5,
    Image: () => image_default3,
    Line: () => line_default9,
    Marker: () => marker_default2,
    Path: () => path_default5,
    Polygon: () => polygon_default5,
    Polyline: () => polyline_default5,
    Rect: () => rect_default4,
    Text: () => text_default5
  });

  // node_modules/@antv/g-svg/node_modules/tslib/modules/index.js
  var import_tslib115 = __toModule(require_tslib9());
  var {
    __extends: __extends9,
    __assign: __assign9,
    __rest: __rest9,
    __decorate: __decorate9,
    __param: __param9,
    __metadata: __metadata9,
    __awaiter: __awaiter9,
    __generator: __generator9,
    __exportStar: __exportStar9,
    __createBinding: __createBinding9,
    __values: __values9,
    __read: __read9,
    __spread: __spread9,
    __spreadArrays: __spreadArrays9,
    __spreadArray: __spreadArray8,
    __await: __await9,
    __asyncGenerator: __asyncGenerator9,
    __asyncDelegator: __asyncDelegator9,
    __asyncValues: __asyncValues9,
    __makeTemplateObject: __makeTemplateObject9,
    __importStar: __importStar9,
    __importDefault: __importDefault9,
    __classPrivateFieldGet: __classPrivateFieldGet9,
    __classPrivateFieldSet: __classPrivateFieldSet9
  } = import_tslib115.default;

  // node_modules/@antv/g-svg/esm/constant.js
  var SHAPE_TO_TAGS = {
    rect: "path",
    circle: "circle",
    line: "line",
    path: "path",
    marker: "path",
    text: "text",
    polyline: "polyline",
    polygon: "polygon",
    image: "image",
    ellipse: "ellipse",
    dom: "foreignObject"
  };
  var SVG_ATTR_MAP = {
    opacity: "opacity",
    fillStyle: "fill",
    fill: "fill",
    fillOpacity: "fill-opacity",
    strokeStyle: "stroke",
    strokeOpacity: "stroke-opacity",
    stroke: "stroke",
    x: "x",
    y: "y",
    r: "r",
    rx: "rx",
    ry: "ry",
    width: "width",
    height: "height",
    x1: "x1",
    x2: "x2",
    y1: "y1",
    y2: "y2",
    lineCap: "stroke-linecap",
    lineJoin: "stroke-linejoin",
    lineWidth: "stroke-width",
    lineDash: "stroke-dasharray",
    lineDashOffset: "stroke-dashoffset",
    miterLimit: "stroke-miterlimit",
    font: "font",
    fontSize: "font-size",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    fontFamily: "font-family",
    startArrow: "marker-start",
    endArrow: "marker-end",
    path: "d",
    class: "class",
    id: "id",
    style: "style",
    preserveAspectRatio: "preserveAspectRatio"
  };

  // node_modules/@antv/g-svg/esm/util/dom.js
  function createSVGElement(type) {
    return document.createElementNS("http://www.w3.org/2000/svg", type);
  }
  function createDom2(shape) {
    var type = SHAPE_TO_TAGS[shape.type];
    var parent = shape.getParent();
    if (!type) {
      throw new Error("the type " + shape.type + " is not supported by svg");
    }
    var element = createSVGElement(type);
    if (shape.get("id")) {
      element.id = shape.get("id");
    }
    shape.set("el", element);
    shape.set("attrs", {});
    if (parent) {
      var parentNode = parent.get("el");
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        parentNode = parent.createDom();
        parent.set("el", parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  }
  function sortDom(element, sorter) {
    var el = element.get("el");
    var childList = to_array_default(el.children).sort(sorter);
    var fragment = document.createDocumentFragment();
    childList.forEach(function(child) {
      fragment.appendChild(child);
    });
    el.appendChild(fragment);
  }
  function moveTo(element, targetIndex) {
    var parentNode = element.parentNode;
    var siblings = Array.from(parentNode.childNodes).filter(function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    });
    var target = siblings[targetIndex];
    var currentIndex = siblings.indexOf(element);
    if (target) {
      if (currentIndex > targetIndex) {
        parentNode.insertBefore(element, target);
      } else if (currentIndex < targetIndex) {
        var targetNext = siblings[targetIndex + 1];
        if (targetNext) {
          parentNode.insertBefore(element, targetNext);
        } else {
          parentNode.appendChild(element);
        }
      }
    } else {
      parentNode.appendChild(element);
    }
  }

  // node_modules/@antv/g-svg/esm/util/svg.js
  function setShadow(model, context) {
    var el = model.cfg.el;
    var attrs = model.attr();
    var cfg = {
      dx: attrs.shadowOffsetX,
      dy: attrs.shadowOffsetY,
      blur: attrs.shadowBlur,
      color: attrs.shadowColor
    };
    if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
      el.removeAttribute("filter");
    } else {
      var id = context.find("filter", cfg);
      if (!id) {
        id = context.addShadow(cfg);
      }
      el.setAttribute("filter", "url(#" + id + ")");
    }
  }
  function setTransform(model) {
    var matrix = model.attr().matrix;
    if (matrix) {
      var el = model.cfg.el;
      var transform6 = [];
      for (var i = 0; i < 9; i += 3) {
        transform6.push(matrix[i] + "," + matrix[i + 1]);
      }
      transform6 = transform6.join(",");
      if (transform6.indexOf("NaN") === -1) {
        el.setAttribute("transform", "matrix(" + transform6 + ")");
      } else {
        console.warn("invalid matrix:", matrix);
      }
    }
  }
  function setClip(model, context) {
    var clip = model.getClip();
    var el = model.get("el");
    if (!clip) {
      el.removeAttribute("clip-path");
    } else if (clip && !el.hasAttribute("clip-path")) {
      createDom2(clip);
      clip.createPath(context);
      var id = context.addClip(clip);
      el.setAttribute("clip-path", "url(#" + id + ")");
    }
  }

  // node_modules/@antv/g-svg/esm/util/draw.js
  function drawChildren2(context, children) {
    children.forEach(function(child) {
      child.draw(context);
    });
  }
  function refreshElement2(element, changeType) {
    var canvas = element.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      var parent_1 = element.getParent();
      var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
      var el = element.get("el");
      if (changeType === "remove") {
        var isClipShape = element.get("isClipShape");
        if (isClipShape) {
          var clipPathEl = el && el.parentNode;
          var defsEl = clipPathEl && clipPathEl.parentNode;
          if (clipPathEl && defsEl) {
            defsEl.removeChild(clipPathEl);
          }
        } else if (el && el.parentNode) {
          el.parentNode.removeChild(el);
        }
      } else if (changeType === "show") {
        el.setAttribute("visibility", "visible");
      } else if (changeType === "hide") {
        el.setAttribute("visibility", "hidden");
      } else if (changeType === "zIndex") {
        moveTo(el, parentChildren.indexOf(element));
      } else if (changeType === "sort") {
        var children_1 = element.get("children");
        if (children_1 && children_1.length) {
          sortDom(element, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
        }
      } else if (changeType === "matrix") {
        setTransform(element);
      } else if (changeType === "clip") {
        setClip(element, context);
      } else if (changeType === "attr") {
      } else if (changeType === "add") {
        element.draw(context);
      }
    }
  }

  // node_modules/@antv/g-svg/esm/group.js
  var Group2 = function(_super) {
    __extends9(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.isEntityGroup = function() {
      return true;
    };
    Group3.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent = this.getParent();
      if (parent) {
        var parentNode = parent.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent.createDom();
          parent.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren2(context, children);
        }
      }
    };
    Group3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      setTransform(this);
    };
    return Group3;
  }(group_default2);
  var group_default5 = Group2;

  // node_modules/@antv/g-svg/esm/shape/base.js
  var ShapeBase3 = function(_super) {
    __extends9(ShapeBase4, _super);
    function ShapeBase4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase4.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase4.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    ShapeBase4.prototype.getGroupBase = function() {
      return group_default5;
    };
    ShapeBase4.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    ShapeBase4.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x - halfWidth;
        var minY = y - halfWidth;
        var maxX = x + width + halfWidth;
        var maxY = y + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY,
          width: width + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase4.prototype.isFill = function() {
      var _a4 = this.attr(), fill = _a4.fill, fillStyle = _a4.fillStyle;
      return (fill || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase4.prototype.isStroke = function() {
      var _a4 = this.attr(), stroke = _a4.stroke, strokeStyle = _a4.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase4.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom2(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase4.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase4.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase4.prototype._setColor = function(context, attr, value) {
      var el = this.get("el");
      if (!value) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value = value.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
        var id = context.find("gradient", value);
        if (!id) {
          id = context.addGradient(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
        var id = context.find("pattern", value);
        if (!id) {
          id = context.addPattern(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    };
    ShapeBase4.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a4 = targetAttrs || attrs, shadowOffsetX = _a4.shadowOffsetX, shadowOffsetY = _a4.shadowOffsetY, shadowBlur = _a4.shadowBlur, shadowColor = _a4.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase4.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase4.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase4.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase4.prototype.getHitLineWidth = function() {
      var _a4 = this.attrs, lineWidth = _a4.lineWidth, lineAppendWidth = _a4.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase4;
  }(shape_default);
  var base_default17 = ShapeBase3;

  // node_modules/@antv/g-svg/esm/shape/circle.js
  var Circle4 = function(_super) {
    __extends9(Circle6, _super);
    function Circle6() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle6.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Circle6;
  }(base_default17);
  var circle_default7 = Circle4;

  // node_modules/@antv/g-svg/esm/shape/dom.js
  var Dom = function(_super) {
    __extends9(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i = children.length - 1; i >= 0; i--) {
            el.removeChild(children[i]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(base_default17);
  var dom_default = Dom;

  // node_modules/@antv/g-svg/esm/shape/ellipse.js
  var Ellipse2 = function(_super) {
    __extends9(Ellipse3, _super);
    function Ellipse3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Ellipse3;
  }(base_default17);
  var ellipse_default5 = Ellipse2;

  // node_modules/@antv/g-svg/esm/shape/image.js
  var Image2 = function(_super) {
    __extends9(Image3, _super);
    function Image3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Image3.prototype.setAttr = function(name, value) {
      this.attrs[name] = value;
      if (name === "img") {
        this._setImage(value);
      }
    };
    Image3.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (is_string_default(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image3;
  }(base_default17);
  var image_default3 = Image2;

  // node_modules/@antv/g-svg/esm/shape/line.js
  var Line4 = function(_super) {
    __extends9(Line6, _super);
    function Line6() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line6.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Line6.prototype.getTotalLength = function() {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line6.prototype.getPoint = function(ratio) {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line6;
  }(base_default17);
  var line_default9 = Line4;

  // node_modules/@antv/g-svg/esm/shape/marker/symbols.js
  var Symbols2 = {
    circle: function(x, y, r) {
      return [
        ["M", x, y],
        ["m", -r, 0],
        ["a", r, r, 0, 1, 0, r * 2, 0],
        ["a", r, r, 0, 1, 0, -r * 2, 0]
      ];
    },
    square: function(x, y, r) {
      return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
    },
    diamond: function(x, y, r) {
      return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
    },
    triangle: function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
    },
    triangleDown: function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
    }
  };
  var symbols_default = {
    get: function(type) {
      return Symbols2[type];
    },
    register: function(type, func) {
      Symbols2[type] = func;
    },
    remove: function(type) {
      delete Symbols2[type];
    },
    getAll: function() {
      return Symbols2;
    }
  };

  // node_modules/@antv/g-svg/esm/shape/marker/index.js
  var Marker2 = function(_super) {
    __extends9(Marker3, _super);
    function Marker3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker3.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker3.prototype._assembleMarker = function() {
      var d = this._getPath();
      if (is_array_default(d)) {
        return d.map(function(path) {
          return path.join(" ");
        }).join("");
      }
      return d;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var r = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method;
      if (is_function_default(symbol)) {
        method = symbol;
      } else {
        method = symbols_default.get(symbol);
      }
      if (!method) {
        console.warn(method + " symbol is not exist.");
        return null;
      }
      return method(x, y, r);
    };
    Marker3.symbolsFactory = symbols_default;
    return Marker3;
  }(base_default17);
  var marker_default2 = Marker2;

  // node_modules/@antv/g-svg/esm/shape/path.js
  var Path2 = function(_super) {
    __extends9(Path4, _super);
    function Path4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { startArrow: false, endArrow: false });
    };
    Path4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "path" && is_array_default(value)) {
          el.setAttribute("d", _this._formatPath(value));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Path4.prototype._formatPath = function(value) {
      var newValue = value.map(function(path) {
        return path.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path4.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path4.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point ? {
        x: point.x,
        y: point.y
      } : null;
    };
    return Path4;
  }(base_default17);
  var path_default5 = Path2;

  // node_modules/@antv/g-svg/esm/shape/polygon.js
  var Polygon2 = function(_super) {
    __extends9(Polygon4, _super);
    function Polygon4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon4.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Polygon4;
  }(base_default17);
  var polygon_default5 = Polygon2;

  // node_modules/@antv/g-svg/esm/shape/polyline.js
  var Polyline = function(_super) {
    __extends9(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p2, i) {
        if (points[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p2[0], p2[1], points[i + 1][0], points[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return Polyline2;
  }(base_default17);
  var polyline_default5 = Polyline;

  // node_modules/@antv/g-svg/esm/util/format.js
  function parseRadius2(radius) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }
    return {
      r1,
      r2,
      r3,
      r4
    };
  }

  // node_modules/@antv/g-svg/esm/shape/rect.js
  var Rect2 = function(_super) {
    __extends9(Rect4, _super);
    function Rect4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each_default(targetAttrs || attrs, function(value, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Rect4.prototype._assembleRect = function(attrs) {
      var x = attrs.x;
      var y = attrs.y;
      var w = attrs.width;
      var h2 = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x + "," + y + " l " + w + ",0 l 0," + h2 + " l" + -w + " 0 z";
      }
      var r = parseRadius2(radius);
      if (is_array_default(radius)) {
        if (radius.length === 1) {
          r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
        } else if (radius.length === 2) {
          r.r1 = r.r3 = radius[0];
          r.r2 = r.r4 = radius[1];
        } else if (radius.length === 3) {
          r.r1 = radius[0];
          r.r2 = r.r4 = radius[1];
          r.r3 = radius[2];
        } else {
          r.r1 = radius[0];
          r.r2 = radius[1];
          r.r3 = radius[2];
          r.r4 = radius[3];
        }
      } else {
        r.r1 = r.r2 = r.r3 = r.r4 = radius;
      }
      var d = [
        ["M " + (x + r.r1) + "," + y],
        ["l " + (w - r.r1 - r.r2) + ",0"],
        ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
        ["l 0," + (h2 - r.r2 - r.r3)],
        ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
        ["l " + (r.r3 + r.r4 - w) + ",0"],
        ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
        ["l 0," + (r.r4 + r.r1 - h2)],
        ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
        ["z"]
      ];
      return d.join(" ");
    };
    return Rect4;
  }(base_default17);
  var rect_default4 = Rect2;

  // node_modules/@antv/g-svg/esm/shape/text.js
  var LETTER_SPACING = 0.3;
  var BASELINE_MAP = {
    top: "before-edge",
    middle: "central",
    bottom: "after-edge",
    alphabetic: "baseline",
    hanging: "hanging"
  };
  var BASELINE_MAP_FOR_FIREFOX = {
    top: "text-before-edge",
    middle: "central",
    bottom: "text-after-edge",
    alphabetic: "alphabetic",
    hanging: "hanging"
  };
  var ANCHOR_MAP = {
    left: "left",
    start: "left",
    center: "middle",
    right: "end",
    end: "end"
  };
  var Text3 = function(_super) {
    __extends9(Text4, _super);
    function Text4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "text") {
          _this._setText("" + value);
        } else if (attr === "matrix" && value) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text4.prototype._setFont = function() {
      var el = this.get("el");
      var _a4 = this.attr(), textBaseline = _a4.textBaseline, textAlign = _a4.textAlign;
      var browser3 = detect();
      if (browser3 && browser3.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text4.prototype._setText = function(text) {
      var el = this.get("el");
      var _a4 = this.attr(), x = _a4.x, _b = _a4.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text) {
        el.innerHTML = "";
      } else if (~text.indexOf("\n")) {
        var textArr = text.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each_default(textArr, function(segment, i) {
          if (i === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text;
      }
    };
    return Text4;
  }(base_default17);
  var text_default5 = Text3;

  // node_modules/@antv/g-svg/esm/defs/gradient.js
  var regexLG3 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG3 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexColorStop3 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
  function addStop2(steps) {
    var arr = steps.match(regexColorStop3);
    if (!arr) {
      return "";
    }
    var stops = "";
    arr.sort(function(a, b) {
      a = a.split(":");
      b = b.split(":");
      return Number(a[0]) - Number(b[0]);
    });
    each_default(arr, function(item) {
      item = item.split(":");
      stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
    });
    return stops;
  }
  function parseLineGradient2(color2, el) {
    var arr = regexLG3.exec(color2);
    var angle3 = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
    var steps = arr[2];
    var start;
    var end;
    if (angle3 >= 0 && angle3 < 0.5 * Math.PI) {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 1
      };
    } else if (0.5 * Math.PI <= angle3 && angle3 < Math.PI) {
      start = {
        x: 1,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
    } else if (Math.PI <= angle3 && angle3 < 1.5 * Math.PI) {
      start = {
        x: 1,
        y: 1
      };
      end = {
        x: 0,
        y: 0
      };
    } else {
      start = {
        x: 0,
        y: 1
      };
      end = {
        x: 1,
        y: 0
      };
    }
    var tanTheta = Math.tan(angle3);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
    el.setAttribute("x1", start.x);
    el.setAttribute("y1", start.y);
    el.setAttribute("x2", x);
    el.setAttribute("y2", y);
    el.innerHTML = addStop2(steps);
  }
  function parseRadialGradient2(color2, self2) {
    var arr = regexRG3.exec(color2);
    var cx = parseFloat(arr[1]);
    var cy = parseFloat(arr[2]);
    var r = parseFloat(arr[3]);
    var steps = arr[4];
    self2.setAttribute("cx", cx);
    self2.setAttribute("cy", cy);
    self2.setAttribute("r", r);
    self2.innerHTML = addStop2(steps);
  }
  var Gradient = function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id = unique_id_default("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient2(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient2(cfg, el);
      }
      el.setAttribute("id", id);
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }();
  var gradient_default = Gradient;

  // node_modules/@antv/g-svg/esm/defs/shadow.js
  var ATTR_MAP = {
    shadowColor: "color",
    shadowOpacity: "opacity",
    shadowBlur: "blur",
    shadowOffsetX: "dx",
    shadowOffsetY: "dy"
  };
  var SHADOW_DIMENSION = {
    x: "-40%",
    y: "-40%",
    width: "200%",
    height: "200%"
  };
  var Shadow = function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each_default(SHADOW_DIMENSION, function(v, k) {
        el.setAttribute(k, v);
      });
      this.el = el;
      this.id = unique_id_default("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config = this.cfg;
      each_default(Object.keys(config), function(attr) {
        if (config[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value) {
      var config = this.cfg;
      config[ATTR_MAP[name]] = value;
      this._parseShadow(config, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config, el) {
      var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }();
  var shadow_default = Shadow;

  // node_modules/@antv/g-svg/esm/defs/arrow.js
  var Arrow = function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id = unique_id_default("marker_");
      el.setAttribute("id", id);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent.setAttribute("refY", "" + 5);
    };
    Arrow2.prototype._setMarker = function(r, el) {
      var parent = this.el;
      var path = this.cfg.path;
      var d = this.cfg.d;
      if (is_array_default(path)) {
        path = path.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path);
      parent.appendChild(el);
      if (d) {
        parent.setAttribute("refX", "" + d / r);
      }
    };
    Arrow2.prototype.update = function(fill) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill);
      } else {
        child.setAttribute("fill", fill);
      }
    };
    return Arrow2;
  }();
  var arrow_default = Arrow;

  // node_modules/@antv/g-svg/esm/defs/clip.js
  var Clip = function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = unique_id_default("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }();
  var clip_default = Clip;

  // node_modules/@antv/g-svg/esm/defs/pattern.js
  var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var Pattern = function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id = unique_id_default("pattern_");
      el.id = id;
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      var arr = regexPR2.exec(cfg);
      var source = arr[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }();
  var pattern_default = Pattern;

  // node_modules/@antv/g-svg/esm/defs/index.js
  var Defs = function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id = unique_id_default("defs_");
      el.id = id;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].match(type, attr)) {
          result = children[i].id;
          break;
        }
      }
      return result;
    };
    Defs2.prototype.findById = function(id) {
      var children = this.children;
      var flag = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].id === id) {
          flag = children[i];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new arrow_default(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient2 = new gradient_default(cfg);
      this.el.appendChild(gradient2.el);
      this.add(gradient2);
      return gradient2.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new arrow_default(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new shadow_default(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern = new pattern_default(cfg);
      this.el.appendChild(pattern.el);
      this.add(pattern);
      return pattern.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip = new clip_default(cfg);
      this.el.appendChild(clip.el);
      this.add(clip);
      return clip.id;
    };
    return Defs2;
  }();
  var defs_default = Defs;

  // node_modules/@antv/g-svg/esm/canvas.js
  var Canvas4 = function(_super) {
    __extends9(Canvas5, _super);
    function Canvas5(cfg) {
      return _super.call(this, __assign9(__assign9({}, cfg), {
        autoDraw: true,
        renderer: "svg"
      })) || this;
    }
    Canvas5.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Canvas5.prototype.getGroupBase = function() {
      return group_default5;
    };
    Canvas5.prototype.getShape = function(x, y, ev) {
      var target = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target.tagName]) {
        var parent_1 = target.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target;
      });
    };
    Canvas5.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new defs_default(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas5.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas5.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren2(context, children);
      }
    };
    return Canvas5;
  }(canvas_default);
  var canvas_default4 = Canvas4;

  // node_modules/@antv/g-svg/esm/index.js
  var version3 = "0.5.6";

  // node_modules/@antv/g2/esm/geometry/shape/util/get-path-points.js
  function isValueEmpty(value) {
    if (value) {
      return false;
    }
    return value === null || value === void 0 || isNaN(value);
  }
  function isYNil(point) {
    if (is_array_default(point)) {
      return isValueEmpty(point[1].y);
    }
    var value = point.y;
    return is_array_default(value) ? isValueEmpty(value[0]) : isValueEmpty(value);
  }
  function getPathPoints(points, connectNulls, showSinglePoint) {
    if (connectNulls === void 0) {
      connectNulls = false;
    }
    if (showSinglePoint === void 0) {
      showSinglePoint = true;
    }
    if (!points.length || points.length === 1 && !showSinglePoint) {
      return [];
    }
    if (connectNulls) {
      var filtered = [];
      for (var i = 0, len3 = points.length; i < len3; i++) {
        var point = points[i];
        if (!isYNil(point)) {
          filtered.push(point);
        }
      }
      return [filtered];
    }
    var result = [];
    var tmp = [];
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (isYNil(point)) {
        if (tmp.length) {
          if (!(tmp.length === 1 && !showSinglePoint)) {
            result.push(tmp);
          }
          tmp = [];
        }
      } else {
        tmp.push(point);
      }
    }
    if (tmp.length) {
      result.push(tmp);
    }
    return result;
  }
  function getViolinPath(points) {
    var path = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      if (point) {
        var action = i === 0 ? "M" : "L";
        path.push([action, point.x, point.y]);
      }
    }
    var first = points[0];
    if (first) {
      path.push(["L", first.x, first.y]);
      path.push(["z"]);
    }
    return path;
  }
  function getSmoothViolinPath(points) {
    var half = points.length / 2;
    var leftPoints = [];
    var rightPoints = [];
    for (var i = 0; i < points.length; i++) {
      if (i < half) {
        leftPoints.push(points[i]);
      } else {
        rightPoints.push(points[i]);
      }
    }
    var leftPath = getSplinePath(leftPoints, false);
    var rightPath = getSplinePath(rightPoints, false);
    if (rightPoints.length) {
      leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
    }
    rightPath.shift();
    var path = leftPath.concat(rightPath);
    if (leftPoints.length) {
      path.push(["L", leftPoints[0].x, leftPoints[0].y]);
    }
    path.push(["z"]);
    return path;
  }

  // node_modules/@antv/g2/esm/geometry/shape/util/get-style.js
  function getStyle2(cfg, isStroke, isFill, sizeName) {
    if (sizeName === void 0) {
      sizeName = "";
    }
    var _a4 = cfg.style, style = _a4 === void 0 ? {} : _a4, defaultStyle = cfg.defaultStyle, color2 = cfg.color, size3 = cfg.size;
    var attrs = __assign(__assign({}, defaultStyle), style);
    if (color2) {
      if (isStroke) {
        if (!style.stroke) {
          attrs.stroke = color2;
        }
      }
      if (isFill) {
        if (!style.fill) {
          attrs.fill = color2;
        }
      }
    }
    if (sizeName && is_nil_default(style[sizeName]) && !is_nil_default(size3)) {
      attrs[sizeName] = size3;
    }
    return attrs;
  }
  function getBackgroundRectStyle(cfg) {
    return deep_mix_default({}, {
      fill: "#CCD6EC",
      fillOpacity: 0.3
    }, get_default(cfg, ["background", "style"]));
  }

  // node_modules/@antv/g2/esm/geometry/shape/util/split-points.js
  function splitPoints(obj) {
    var x = obj.x;
    var y = is_array_default(obj.y) ? obj.y : [obj.y];
    return y.map(function(eachY, index) {
      return {
        x: is_array_default(x) ? x[index] : x,
        y: eachY
      };
    });
  }

  // node_modules/@antv/g2/esm/geometry/shape/line/util.js
  var LineSymbols = {
    line: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    dot: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    dash: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    smooth: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["A", r / 2, r / 2, 0, 1, 1, x, y],
        ["A", r / 2, r / 2, 0, 1, 0, x + r, y]
      ];
    },
    hv: function(x, y, r) {
      return [
        ["M", x - r - 1, y - 2.5],
        ["L", x, y - 2.5],
        ["L", x, y + 2.5],
        ["L", x + r + 1, y + 2.5]
      ];
    },
    vh: function(x, y, r) {
      return [
        ["M", x - r - 1, y + 2.5],
        ["L", x, y + 2.5],
        ["L", x, y - 2.5],
        ["L", x + r + 1, y - 2.5]
      ];
    },
    hvh: function(x, y, r) {
      return [
        ["M", x - (r + 1), y + 2.5],
        ["L", x - r / 2, y + 2.5],
        ["L", x - r / 2, y - 2.5],
        ["L", x + r / 2, y - 2.5],
        ["L", x + r / 2, y + 2.5],
        ["L", x + r + 1, y + 2.5]
      ];
    },
    vhv: function(x, y) {
      return [
        ["M", x - 5, y + 2.5],
        ["L", x - 5, y],
        ["L", x, y],
        ["L", x, y - 3],
        ["L", x, y + 3],
        ["L", x + 6.5, y + 3]
      ];
    }
  };
  function getLineMarker(markerCfg, shapeType) {
    var color2 = markerCfg.color;
    return {
      symbol: LineSymbols[shapeType],
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color2
      }
    };
  }

  // node_modules/@antv/g2/esm/geometry/shape/line/index.js
  function getShapeAttrs(cfg, smooth, constraint) {
    var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
    var shapeAttrs = getStyle2(cfg, true, false, "lineWidth");
    var points = getPathPoints(cfg.points, connectNulls, showSinglePoint);
    var path = [];
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var eachLinePoints = points[i];
      path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
    }
    shapeAttrs.path = path;
    return shapeAttrs;
  }
  function getSinglePath(points, isInCircle, smooth, constraint, style) {
    if (points.length === 1) {
      return [
        ["M", points[0].x, points[0].y - style.lineWidth / 2],
        ["L", points[0].x, points[0].y],
        ["L", points[0].x, points[0].y + style.lineWidth / 2]
      ];
    }
    var path;
    if (!smooth) {
      path = getLinePath2(points, false);
      if (isInCircle) {
        path.push(["Z"]);
      }
    } else {
      if (isInCircle && points.length) {
        points.push({ x: points[0].x, y: points[0].y });
      }
      path = getSplinePath(points, false, constraint);
    }
    return path;
  }
  function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
    var topPoints = [];
    var bottomPoints = [];
    each_default(points, function(point) {
      var result = splitPoints(point);
      topPoints.push(result[1]);
      bottomPoints.push(result[0]);
    });
    var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
    var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
    if (isStack) {
      return topPath;
    }
    return topPath.concat(bottomPath);
  }
  function getPath(points, isInCircle, isStack, smooth, constraint, style) {
    if (points.length) {
      var first = points[0];
      return is_array_default(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
    }
    return [];
  }
  var LineShapeFactory = registerShapeFactory("line", {
    defaultShapeType: "line"
  });
  each_default(["line", "dot", "dash", "smooth"], function(shapeType) {
    registerShape("line", shapeType, {
      draw: function(cfg, container) {
        var smooth = shapeType === "smooth";
        var constraint;
        if (smooth) {
          var _a4 = this.coordinate, start = _a4.start, end = _a4.end;
          constraint = [
            [start.x, end.y],
            [end.x, start.y]
          ];
        }
        var attrs = getShapeAttrs(cfg, smooth, constraint);
        var shape = container.addShape({
          type: "path",
          attrs,
          name: "line",
          capture: !smooth
        });
        return shape;
      },
      getMarker: function(markerCfg) {
        return getLineMarker(markerCfg, shapeType);
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/path.js
  var Path3 = function(_super) {
    __extends(Path4, _super);
    function Path4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "path";
      _this.shapeType = "line";
      var _a4 = cfg.connectNulls, connectNulls = _a4 === void 0 ? false : _a4, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
      _this.connectNulls = connectNulls;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Path4.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyData = new Map();
      var keyIndex = new Map();
      var keys2 = [];
      var index = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var key = this.getElementId(mappingData);
        keys2.push(key);
        keyData.set(key, mappingData);
        keyIndex.set(key, index);
        index++;
      }
      this.elements = new Array(index);
      var _a4 = diff(this.lastElementsMap, keys2), added = _a4.added, updated = _a4.updated, removed = _a4.removed;
      for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
        var key = added_1[_i];
        var mappingData = keyData.get(key);
        var shapeFactory = this.getShapeFactory();
        var shapeCfg = this.getShapeInfo(mappingData);
        var i = keyIndex.get(key);
        var element = new element_default3({
          shapeFactory,
          container: this.container,
          offscreenGroup: this.getOffscreenGroup(),
          elementIndex: i
        });
        element.geometry = this;
        element.animate = this.animateOption;
        element.draw(shapeCfg, isUpdate);
        this.elementsMap[key] = element;
        this.elements[i] = element;
      }
      for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
        var key = updated_1[_b];
        var mappingData = keyData.get(key);
        var element = this.lastElementsMap[key];
        var i = keyIndex.get(key);
        var shapeCfg = this.getShapeInfo(mappingData);
        var preShapeCfg = element.getModel();
        if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
          element.animate = this.animateOption;
          element.update(shapeCfg);
        }
        this.elementsMap[key] = element;
        this.elements[i] = element;
      }
      for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
        var key = removed_1[_c];
        var element = this.lastElementsMap[key];
        element.animate = this.animateOption;
        element.destroy();
      }
    };
    Path4.prototype.getPointsAndData = function(mappingData) {
      var points = [];
      var data = [];
      for (var i = 0, len3 = mappingData.length; i < len3; i++) {
        var obj = mappingData[i];
        points.push({
          x: obj.x,
          y: obj.y
        });
        data.push(obj[FIELD_ORIGIN]);
      }
      return {
        points,
        data
      };
    };
    Path4.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var _a4 = this.getPointsAndData(mappingData), points = _a4.points, data = _a4.data;
      shapeCfg.mappingData = mappingData;
      shapeCfg.data = data;
      shapeCfg.isStack = !!this.getAdjust("stack");
      shapeCfg.points = points;
      shapeCfg.connectNulls = this.connectNulls;
      shapeCfg.showSinglePoint = this.showSinglePoint;
      return shapeCfg;
    };
    return Path4;
  }(base_default14);
  var path_default6 = Path3;

  // node_modules/@antv/g2/esm/geometry/shape/area/util.js
  function getPath2(points, isInCircle, smooth, registeredShape, constraint) {
    var path = [];
    if (points.length) {
      var topLinePoints_1 = [];
      var bottomLinePoints_1 = [];
      for (var i = 0, len3 = points.length; i < len3; i++) {
        var point = points[i];
        topLinePoints_1.push(point[1]);
        bottomLinePoints_1.push(point[0]);
      }
      bottomLinePoints_1 = bottomLinePoints_1.reverse();
      each_default([topLinePoints_1, bottomLinePoints_1], function(pointsData, index) {
        var subPath = [];
        var parsedPoints = registeredShape.parsePoints(pointsData);
        var p1 = parsedPoints[0];
        if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
          subPath = index === 0 ? [
            ["M", p1.x - 0.5, p1.y],
            ["L", p1.x + 0.5, p1.y]
          ] : [
            ["L", p1.x + 0.5, p1.y],
            ["L", p1.x - 0.5, p1.y]
          ];
        } else {
          if (isInCircle) {
            parsedPoints.push({ x: p1.x, y: p1.y });
          }
          if (smooth) {
            subPath = getSplinePath(parsedPoints, false, constraint);
          } else {
            subPath = getLinePath2(parsedPoints, false);
          }
          if (index > 0) {
            subPath[0][0] = "L";
          }
        }
        path = path.concat(subPath);
      });
      path.push(["Z"]);
    }
    return path;
  }
  function getShapeAttrs2(cfg, isStroke, smooth, registeredShape, constraint) {
    var attrs = getStyle2(cfg, isStroke, !isStroke, "lineWidth");
    var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;
    var pathPoints = getPathPoints(points, connectNulls, showSinglePoint);
    var path = [];
    for (var i = 0, len3 = pathPoints.length; i < len3; i++) {
      var eachPoints = pathPoints[i];
      path = path.concat(getPath2(eachPoints, isInCircle, smooth, registeredShape, constraint));
    }
    attrs.path = path;
    return attrs;
  }
  function getConstraint(coordinate) {
    var start = coordinate.start, end = coordinate.end;
    return [
      [start.x, end.y],
      [end.x, start.y]
    ];
  }

  // node_modules/@antv/g2/esm/geometry/shape/area/index.js
  var AreaShapeFactory = registerShapeFactory("area", {
    defaultShapeType: "area",
    getDefaultPoints: function(pointInfo) {
      var x = pointInfo.x, y0 = pointInfo.y0;
      var y = is_array_default(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
      return y.map(function(yItem) {
        return {
          x,
          y: yItem
        };
      });
    }
  });
  registerShape("area", "area", {
    draw: function(cfg, container) {
      var attrs = getShapeAttrs2(cfg, false, false, this);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/area.js
  var Area = function(_super) {
    __extends(Area2, _super);
    function Area2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "area";
      _this.shapeType = "area";
      _this.generatePoints = true;
      _this.startOnZero = true;
      var _a4 = cfg.startOnZero, startOnZero = _a4 === void 0 ? true : _a4, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
      _this.startOnZero = startOnZero;
      _this.sortable = sortable;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Area2.prototype.getPointsAndData = function(mappingData) {
      var points = [];
      var data = [];
      for (var i = 0, len3 = mappingData.length; i < len3; i++) {
        var obj = mappingData[i];
        points.push(obj.points);
        data.push(obj[FIELD_ORIGIN]);
      }
      return {
        points,
        data
      };
    };
    Area2.prototype.getYMinValue = function() {
      if (this.startOnZero) {
        return _super.prototype.getYMinValue.call(this);
      }
      var yScale = this.getYScale();
      return yScale.min;
    };
    return Area2;
  }(path_default6);
  var area_default = Area;

  // node_modules/@antv/g2/esm/geometry/shape/edge/index.js
  var EdgeShapeFactory = registerShapeFactory("edge", {
    defaultShapeType: "line",
    getDefaultPoints: function(pointInfo) {
      return splitPoints(pointInfo);
    }
  });
  registerShape("edge", "line", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var path = getLinePath2(this.parsePoints(cfg.points), this.coordinate.isPolar);
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/edge.js
  var Edge = function(_super) {
    __extends(Edge2, _super);
    function Edge2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "edge";
      _this.shapeType = "edge";
      _this.generatePoints = true;
      return _this;
    }
    return Edge2;
  }(base_default14);
  var edge_default = Edge;

  // node_modules/@antv/g2/esm/geometry/heatmap.js
  var Heatmap = function(_super) {
    __extends(Heatmap2, _super);
    function Heatmap2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      _this.paletteCache = {};
      return _this;
    }
    Heatmap2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var range = this.prepareRange(mappingData);
        var radius = this.prepareSize();
        var blur_1 = get_default(this.styleOption, ["cfg", "shadowBlur"]);
        if (!is_number_default(blur_1)) {
          blur_1 = radius / 2;
        }
        this.prepareGreyScaleBlurredCircle(radius, blur_1);
        this.drawWithRange(mappingData, range, radius, blur_1);
      }
    };
    Heatmap2.prototype.color = function(field, cfg) {
      this.createAttrOption("color", field, typeof cfg !== "function" ? cfg : "");
      return this;
    };
    Heatmap2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.clearShadowCanvasCtx();
      this.paletteCache = {};
    };
    Heatmap2.prototype.prepareRange = function(data) {
      var colorAttr = this.getAttribute("color");
      var colorField = colorAttr.getFields()[0];
      var min3 = Infinity;
      var max3 = -Infinity;
      data.forEach(function(row) {
        var value = row[FIELD_ORIGIN][colorField];
        if (value > max3) {
          max3 = value;
        }
        if (value < min3) {
          min3 = value;
        }
      });
      if (min3 === max3) {
        min3 = max3 - 1;
      }
      return [min3, max3];
    };
    Heatmap2.prototype.prepareSize = function() {
      var radius = this.getDefaultValue("size");
      if (!is_number_default(radius)) {
        radius = this.getDefaultSize();
      }
      return radius;
    };
    Heatmap2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      var r2 = radius + blur;
      var ctx3 = grayScaleBlurredCanvas.getContext("2d");
      grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
      ctx3.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
      ctx3.shadowOffsetX = ctx3.shadowOffsetY = r2 * 2;
      ctx3.shadowBlur = blur;
      ctx3.shadowColor = "black";
      ctx3.beginPath();
      ctx3.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
      ctx3.closePath();
      ctx3.fill();
    };
    Heatmap2.prototype.drawWithRange = function(data, range, radius, blur) {
      var _a4 = this.coordinate, start = _a4.start, end = _a4.end;
      var width = this.coordinate.getWidth();
      var height = this.coordinate.getHeight();
      var colorAttr = this.getAttribute("color");
      var valueField = colorAttr.getFields()[0];
      this.clearShadowCanvasCtx();
      var ctx3 = this.getShadowCanvasCtx();
      if (range) {
        data = data.filter(function(row) {
          return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];
        });
      }
      var scale4 = this.scales[valueField];
      for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
        var obj = data_1[_i];
        var _b = this.getDrawCfg(obj), x = _b.x, y = _b.y;
        var alpha = scale4.scale(obj[FIELD_ORIGIN][valueField]);
        this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx3);
      }
      var colored = ctx3.getImageData(0, 0, width, height);
      this.clearShadowCanvasCtx();
      this.colorize(colored);
      ctx3.putImageData(colored, 0, 0);
      var imageShape = this.getImageShape();
      imageShape.attr("x", start.x);
      imageShape.attr("y", end.y);
      imageShape.attr("width", width);
      imageShape.attr("height", height);
      imageShape.attr("img", ctx3.canvas);
      imageShape.set("origin", this.getShapeInfo(data));
    };
    Heatmap2.prototype.getDefaultSize = function() {
      var position = this.getAttribute("position");
      var coordinate = this.coordinate;
      return Math.min(coordinate.getWidth() / (position.scales[0].ticks.length * 4), coordinate.getHeight() / (position.scales[1].ticks.length * 4));
    };
    Heatmap2.prototype.clearShadowCanvasCtx = function() {
      var ctx3 = this.getShadowCanvasCtx();
      ctx3.clearRect(0, 0, ctx3.canvas.width, ctx3.canvas.height);
    };
    Heatmap2.prototype.getShadowCanvasCtx = function() {
      var canvas = this.shadowCanvas;
      if (!canvas) {
        canvas = document.createElement("canvas");
        this.shadowCanvas = canvas;
      }
      canvas.width = this.coordinate.getWidth();
      canvas.height = this.coordinate.getHeight();
      return canvas.getContext("2d");
    };
    Heatmap2.prototype.getGrayScaleBlurredCanvas = function() {
      if (!this.grayScaleBlurredCanvas) {
        this.grayScaleBlurredCanvas = document.createElement("canvas");
      }
      return this.grayScaleBlurredCanvas;
    };
    Heatmap2.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx3) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      ctx3.globalAlpha = alpha;
      ctx3.drawImage(grayScaleBlurredCanvas, x - r, y - r);
    };
    Heatmap2.prototype.colorize = function(img) {
      var colorAttr = this.getAttribute("color");
      var pixels = img.data;
      var paletteCache = this.paletteCache;
      for (var i = 3; i < pixels.length; i += 4) {
        var alpha = pixels[i];
        if (is_number_default(alpha)) {
          var palette = paletteCache[alpha] ? paletteCache[alpha] : esm_default2.rgb2arr(colorAttr.gradient(alpha / 256));
          pixels[i - 3] = palette[0];
          pixels[i - 2] = palette[1];
          pixels[i - 1] = palette[2];
          pixels[i] = alpha;
        }
      }
    };
    Heatmap2.prototype.getImageShape = function() {
      var imageShape = this.imageShape;
      if (imageShape) {
        return imageShape;
      }
      var container = this.container;
      imageShape = container.addShape({
        type: "image",
        attrs: {}
      });
      this.imageShape = imageShape;
      return imageShape;
    };
    Heatmap2.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var data = mappingData.map(function(obj) {
        return obj[FIELD_ORIGIN];
      });
      return __assign(__assign({}, shapeCfg), { mappingData, data });
    };
    return Heatmap2;
  }(base_default14);
  var heatmap_default = Heatmap;

  // node_modules/@antv/g2/esm/geometry/shape/interval/util.js
  function getRectPoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
    var yMin;
    var yMax;
    if (is_array_default(y)) {
      yMin = y[0], yMax = y[1];
    } else {
      yMin = y0;
      yMax = y;
    }
    var xMin;
    var xMax;
    if (is_array_default(x)) {
      xMin = x[0], xMax = x[1];
    } else {
      xMin = x - size3 / 2;
      xMax = x + size3 / 2;
    }
    var points = [
      { x: xMin, y: yMin },
      { x: xMin, y: yMax }
    ];
    points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
    return points;
  }
  function getRectPath(points, isClosed) {
    if (isClosed === void 0) {
      isClosed = true;
    }
    var path = [];
    var firstPoint = points[0];
    path.push(["M", firstPoint.x, firstPoint.y]);
    for (var i = 1, len3 = points.length; i < len3; i++) {
      path.push(["L", points[i].x, points[i].y]);
    }
    if (isClosed) {
      path.push(["L", firstPoint.x, firstPoint.y]);
      path.push(["z"]);
    }
    return path;
  }
  function parseRadius3(radius, minLength) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }
    if (r1 + r2 > minLength) {
      r1 = r1 ? minLength / (1 + r2 / r1) : 0;
      r2 = minLength - r1;
    }
    if (r3 + r4 > minLength) {
      r3 = r3 ? minLength / (1 + r4 / r3) : 0;
      r4 = minLength - r3;
    }
    return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
  }
  function getBackgroundRectPath(cfg, points, coordinate) {
    var path = [];
    if (coordinate.isRect) {
      var p0 = coordinate.isTransposed ? { x: coordinate.start.x, y: points[0].y } : { x: points[0].x, y: coordinate.start.y };
      var p1 = coordinate.isTransposed ? { x: coordinate.end.x, y: points[2].y } : { x: points[3].x, y: coordinate.end.y };
      var radius = get_default(cfg, ["background", "style", "radius"]);
      if (radius) {
        var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
        var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();
        var _a4 = parseRadius3(radius, Math.min(width, height)), r1 = _a4[0], r2 = _a4[1], r3 = _a4[2], r4 = _a4[3];
        path.push(["M", p0.x, p1.y + r1]);
        r1 !== 0 && path.push(["A", r1, r1, 0, 0, 1, p0.x + r1, p1.y]);
        path.push(["L", p1.x - r2, p1.y]);
        r2 !== 0 && path.push(["A", r2, r2, 0, 0, 1, p1.x, p1.y + r2]);
        path.push(["L", p1.x, p0.y - r3]);
        r3 !== 0 && path.push(["A", r3, r3, 0, 0, 1, p1.x - r3, p0.y]);
        path.push(["L", p0.x + r4, p0.y]);
        r4 !== 0 && path.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
      } else {
        path.push(["M", p0.x, p0.y]);
        path.push(["L", p1.x, p0.y]);
        path.push(["L", p1.x, p1.y]);
        path.push(["L", p0.x, p1.y]);
        path.push(["L", p0.x, p0.y]);
      }
      path.push(["z"]);
    }
    if (coordinate.isPolar) {
      var center = coordinate.getCenter();
      var _b = getAngle2(cfg, coordinate), startAngle = _b.startAngle, endAngle = _b.endAngle;
      if (coordinate.type !== "theta" && !coordinate.isTransposed) {
        path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);
      } else {
        var pow = function(v) {
          return Math.pow(v, 2);
        };
        var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));
        var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y));
        path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);
      }
    }
    return path;
  }
  function getIntervalRectPath(points, lineCap, coor) {
    var width = coor.getWidth();
    var height = coor.getHeight();
    var isRect = coor.type === "rect";
    var path = [];
    var r = (points[2].x - points[1].x) / 2;
    var ry = coor.isTransposed ? r * height / width : r * width / height;
    if (lineCap === "round") {
      if (isRect) {
        path.push(["M", points[0].x, points[0].y + ry]);
        path.push(["L", points[1].x, points[1].y - ry]);
        path.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
        path.push(["L", points[3].x, points[3].y + ry]);
        path.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
      } else {
        path.push(["M", points[0].x, points[0].y]);
        path.push(["L", points[1].x, points[1].y]);
        path.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y]);
        path.push(["L", points[3].x, points[3].y]);
        path.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y]);
      }
      path.push(["z"]);
    } else {
      path = getRectPath(points);
    }
    return path;
  }
  function getFunnelPath(points, nextPoints, isPyramid) {
    var path = [];
    if (!is_nil_default(nextPoints)) {
      path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
    } else if (isPyramid) {
      path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ["Z"]);
    } else {
      path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", points[2].x, points[2].y], ["L", points[3].x, points[3].y], ["Z"]);
    }
    return path;
  }
  function getRectWithCornerRadius(points, coordinate, radius) {
    var _a4, _b, _c, _d;
    var p0 = points[0], p1 = points[1], p2 = points[2], p3 = points[3];
    var _e = [0, 0, 0, 0], r1 = _e[0], r2 = _e[1], r3 = _e[2], r4 = _e[3];
    if (p0.y < p1.y) {
      p1 = points[0], p0 = points[1], p3 = points[2], p2 = points[3];
      _a4 = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r4 = _a4[0], r3 = _a4[1], r2 = _a4[2], r1 = _a4[3];
    } else {
      _b = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _b[0], r2 = _b[1], r3 = _b[2], r4 = _b[3];
    }
    if (coordinate.isTransposed) {
      p0 = points[0], p3 = points[1], p2 = points[2], p1 = points[3];
      if (points[0].x > points[1].x) {
        p3 = points[0], p0 = points[1], p1 = points[2], p2 = points[3];
        _c = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _c[0], r4 = _c[1], r3 = _c[2], r2 = _c[3];
      } else {
        _d = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r2 = _d[0], r3 = _d[1], r4 = _d[2], r1 = _d[3];
      }
    }
    var path = [];
    path.push(["M", p1.x, p1.y + r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
    path.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
    path.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
    path.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    path.push(["L", p1.x, p1.y + r1]);
    path.push(["z"]);
    return path;
  }

  // node_modules/@antv/g2/esm/geometry/shape/interval/index.js
  var IntervalShapeFactory = registerShapeFactory("interval", {
    defaultShapeType: "rect",
    getDefaultPoints: function(pointInfo) {
      return getRectPoints(pointInfo);
    }
  });
  registerShape("interval", "rect", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, false, true);
      var group2 = container;
      var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
      if (backgroundCfg) {
        group2 = container.addGroup();
        var backgroundStyle = getBackgroundRectStyle(cfg);
        var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
        group2.addShape("path", {
          attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
          zIndex: -1,
          name: BACKGROUND_SHAPE
        });
      }
      var path;
      if (style.radius && this.coordinate.isRect) {
        path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
      } else {
        path = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
      }
      var shape = group2.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return backgroundCfg ? group2 : shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
      if (isInPolar) {
        return {
          symbol: "circle",
          style: {
            r: 4.5,
            fill: color2
          }
        };
      }
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/util/shape-size.js
  function findMinDistance(arr, scale4) {
    var count = arr.length;
    var sourceArr = arr;
    if (is_string_default(sourceArr[0])) {
      sourceArr = arr.map(function(v) {
        return scale4.translate(v);
      });
    }
    var distance8 = sourceArr[1] - sourceArr[0];
    for (var i = 2; i < count; i++) {
      var tmp = sourceArr[i] - sourceArr[i - 1];
      if (distance8 > tmp) {
        distance8 = tmp;
      }
    }
    return distance8;
  }
  function getDodgeCount(dataArray, dodgeBy) {
    if (dodgeBy) {
      var mergeData = flatten_default(dataArray);
      var values2 = values_of_key_default(mergeData, dodgeBy);
      return values2.length;
    }
    return dataArray.length;
  }
  function getDefaultSize(geometry) {
    var theme = geometry.theme;
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var xValues = xScale.values;
    var dataArray = geometry.beforeMappingData;
    var count = xValues.length;
    var xDimensionLength = getXDimensionLength(geometry.coordinate);
    var intervalPadding = geometry.intervalPadding, dodgePadding = geometry.dodgePadding;
    var maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;
    var minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;
    var columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;
    var multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;
    var roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio;
    if (xScale.isLinear && xValues.length > 1) {
      xValues.sort();
      var interval2 = findMinDistance(xValues, xScale);
      count = (xScale.max - xScale.min) / interval2;
      if (xValues.length > count) {
        count = xValues.length;
      }
    }
    var range = xScale.range;
    var normalizedSize = 1 / count;
    var wr = 1;
    if (coordinate.isPolar) {
      if (coordinate.isTransposed && count > 1) {
        wr = multiplePieWidthRatio;
      } else {
        wr = roseWidthRatio;
      }
    } else {
      if (xScale.isLinear) {
        normalizedSize *= range[1] - range[0];
      }
      wr = columnWidthRatio;
    }
    if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
      var normalizedIntervalPadding = intervalPadding / xDimensionLength;
      normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;
    } else {
      normalizedSize *= wr;
    }
    if (geometry.getAdjust("dodge")) {
      var dodgeAdjust = geometry.getAdjust("dodge");
      var dodgeBy = dodgeAdjust.dodgeBy;
      var dodgeCount = getDodgeCount(dataArray, dodgeBy);
      if (!is_nil_default(dodgePadding) && dodgePadding >= 0) {
        var normalizedDodgePadding = dodgePadding / xDimensionLength;
        normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
      } else if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
        normalizedSize *= wr;
        normalizedSize = normalizedSize / dodgeCount;
      } else {
        normalizedSize = normalizedSize / dodgeCount;
      }
      normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
    }
    if (!is_nil_default(maxColumnWidth) && maxColumnWidth >= 0) {
      var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
      if (normalizedSize > normalizedMaxColumnWidth) {
        normalizedSize = normalizedMaxColumnWidth;
      }
    }
    if (!is_nil_default(minColumnWidth) && minColumnWidth >= 0) {
      var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
      if (normalizedSize < normalizedMinColumnWidth) {
        normalizedSize = normalizedMinColumnWidth;
      }
    }
    return normalizedSize;
  }

  // node_modules/@antv/g2/esm/geometry/interval.js
  var Interval = function(_super) {
    __extends(Interval2, _super);
    function Interval2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "interval";
      _this.shapeType = "interval";
      _this.generatePoints = true;
      var background = cfg.background;
      _this.background = background;
      return _this;
    }
    Interval2.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, obj)[0];
        var coordinate = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      return cfg;
    };
    Interval2.prototype.adjustScale = function() {
      _super.prototype.adjustScale.call(this);
      var yScale = this.getYScale();
      if (this.coordinate.type === "theta") {
        yScale.change({
          nice: false,
          min: 0,
          max: getMaxScale(yScale)
        });
      } else {
        var scaleDefs = this.scaleDefs;
        var field = yScale.field, min3 = yScale.min, max3 = yScale.max, type = yScale.type;
        if (type !== "time") {
          if (min3 > 0 && !get_default(scaleDefs, [field, "min"])) {
            yScale.change({
              min: 0
            });
          }
          if (max3 <= 0 && !get_default(scaleDefs, [field, "max"])) {
            yScale.change({
              max: 0
            });
          }
        }
      }
    };
    Interval2.prototype.getDrawCfg = function(mappingData) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
      shapeCfg.background = this.background;
      return shapeCfg;
    };
    return Interval2;
  }(base_default14);
  var interval_default = Interval;

  // node_modules/@antv/g2/esm/geometry/line.js
  var Line5 = function(_super) {
    __extends(Line6, _super);
    function Line6(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "line";
      var _a4 = cfg.sortable, sortable = _a4 === void 0 ? false : _a4;
      _this.sortable = sortable;
      return _this;
    }
    return Line6;
  }(path_default6);
  var line_default10 = Line5;

  // node_modules/@antv/g2/esm/geometry/shape/point/util.js
  var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
  var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
  function drawPoints(shape, cfg, container, shapeName, isStroke) {
    var style = getStyle2(cfg, isStroke, !isStroke, "r");
    var points = shape.parsePoints(cfg.points);
    var pointPosition = points[0];
    if (cfg.isStack) {
      pointPosition = points[1];
    } else if (points.length > 1) {
      var group2 = container.addGroup();
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        group2.addShape({
          type: "marker",
          attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point)
        });
      }
      return group2;
    }
    return container.addShape({
      type: "marker",
      attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
    });
  }

  // node_modules/@antv/g2/esm/geometry/shape/point/index.js
  var PointShapeFactory = registerShapeFactory("point", {
    defaultShapeType: "hollow-circle",
    getDefaultPoints: function(pointInfo) {
      return splitPoints(pointInfo);
    }
  });
  each_default(SHAPES, function(shapeName) {
    registerShape("point", "hollow-" + shapeName, {
      draw: function(cfg, container) {
        return drawPoints(this, cfg, container, shapeName, true);
      },
      getMarker: function(markerCfg) {
        var color2 = markerCfg.color;
        return {
          symbol: MarkerSymbols[shapeName] || shapeName,
          style: {
            r: 4.5,
            stroke: color2,
            fill: null
          }
        };
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/point.js
  var Point = function(_super) {
    __extends(Point2, _super);
    function Point2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "point";
      _this.shapeType = "point";
      _this.generatePoints = true;
      return _this;
    }
    Point2.prototype.getDrawCfg = function(mappingDatum) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
      return __assign(__assign({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
    };
    return Point2;
  }(base_default14);
  var point_default = Point;

  // node_modules/@antv/g2/esm/geometry/shape/polygon/index.js
  function getPath3(points) {
    var flag = points[0];
    var i = 1;
    var path = [["M", flag.x, flag.y]];
    while (i < points.length) {
      var c = points[i];
      if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
        path.push(["L", c.x, c.y]);
        if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
          flag = points[i + 1];
          path.push(["Z"]);
          path.push(["M", flag.x, flag.y]);
          i++;
        }
      }
      i++;
    }
    if (!is_equal_default(last(path), flag)) {
      path.push(["L", flag.x, flag.y]);
    }
    path.push(["Z"]);
    return path;
  }
  var PolygonShapeFactory = registerShapeFactory("polygon", {
    defaultShapeType: "polygon",
    getDefaultPoints: function(pointInfo) {
      var points = [];
      each_default(pointInfo.x, function(subX, index) {
        var subY = pointInfo.y[index];
        points.push({
          x: subX,
          y: subY
        });
      });
      return points;
    }
  });
  registerShape("polygon", "polygon", {
    draw: function(cfg, container) {
      if (!is_empty_default(cfg.points)) {
        var shapeAttrs = getStyle2(cfg, true, true);
        var path = this.parsePath(getPath3(cfg.points));
        return container.addShape("path", {
          attrs: __assign(__assign({}, shapeAttrs), { path }),
          name: "polygon"
        });
      }
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/polygon.js
  var Polygon3 = function(_super) {
    __extends(Polygon4, _super);
    function Polygon4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.shapeType = "polygon";
      _this.generatePoints = true;
      return _this;
    }
    Polygon4.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var x = cfg.x;
      var y = cfg.y;
      var temp;
      if (!(is_array_default(x) && is_array_default(y))) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xCount = xScale.values.length;
        var yCount = yScale.values.length;
        var xOffset = 0.5 * 1 / xCount;
        var yOffset = 0.5 * 1 / yCount;
        if (xScale.isCategory && yScale.isCategory) {
          x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
          y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
        } else if (is_array_default(x)) {
          temp = x;
          x = [temp[0], temp[0], temp[1], temp[1]];
          y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
        } else if (is_array_default(y)) {
          temp = y;
          y = [temp[0], temp[1], temp[1], temp[0]];
          x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
        }
        cfg.x = x;
        cfg.y = y;
      }
      return cfg;
    };
    return Polygon4;
  }(base_default14);
  var polygon_default6 = Polygon3;

  // node_modules/@antv/g2/esm/geometry/shape/schema/index.js
  var SchemaShapeFactory = registerShapeFactory("schema", {
    defaultShapeType: ""
  });

  // node_modules/@antv/g2/esm/geometry/schema.js
  var Schema = function(_super) {
    __extends(Schema2, _super);
    function Schema2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "schema";
      _this.shapeType = "schema";
      _this.generatePoints = true;
      return _this;
    }
    Schema2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      return cfg;
    };
    return Schema2;
  }(base_default14);
  var schema_default = Schema;

  // node_modules/@antv/g2/esm/geometry/shape/violin/index.js
  function normalizeSize(arr) {
    if (!is_array_default(arr)) {
      return [];
    }
    var maxValue = max_default(arr);
    return map_default(arr, function(num) {
      return num / maxValue;
    });
  }
  var ViolinShapeFactory = registerShapeFactory("violin", {
    defaultShapeType: "violin",
    getDefaultPoints: function(pointInfo) {
      var radius = pointInfo.size / 2;
      var points = [];
      var sizeArr = normalizeSize(pointInfo._size);
      each_default(pointInfo.y, function(y, index) {
        var offset = sizeArr[index] * radius;
        var isMin = index === 0;
        var isMax = index === pointInfo.y.length - 1;
        points.push({
          isMin,
          isMax,
          x: pointInfo.x - offset,
          y
        });
        points.unshift({
          isMin,
          isMax,
          x: pointInfo.x + offset,
          y
        });
      });
      return points;
    }
  });
  registerShape("violin", "violin", {
    draw: function(cfg, container) {
      var shapeAttrs = getStyle2(cfg, true, true);
      var path = this.parsePath(getViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, shapeAttrs), { path }),
        name: "violin"
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/violin.js
  var Violin = function(_super) {
    __extends(Violin2, _super);
    function Violin2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      _this.shapeType = "violin";
      _this.generatePoints = true;
      return _this;
    }
    Violin2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      cfg._size = get_default(record[FIELD_ORIGIN], [this._sizeField]);
      return cfg;
    };
    Violin2.prototype.initAttributes = function() {
      var attributeOption = this.attributeOption;
      var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
      this._sizeField = sizeField;
      delete attributeOption.size;
      _super.prototype.initAttributes.call(this);
    };
    return Violin2;
  }(base_default14);
  var violin_default = Violin;

  // node_modules/@antv/g2/esm/geometry/shape/area/line.js
  registerShape("area", "line", {
    draw: function(cfg, container) {
      var attrs = getShapeAttrs2(cfg, true, false, this);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          stroke: color2,
          fill: null
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/area/smooth.js
  registerShape("area", "smooth", {
    draw: function(cfg, container) {
      var coordinate = this.coordinate;
      var attrs = getShapeAttrs2(cfg, false, true, this, getConstraint(coordinate));
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/area/smooth-line.js
  registerShape("area", "smooth-line", {
    draw: function(cfg, container) {
      var coordinate = this.coordinate;
      var attrs = getShapeAttrs2(cfg, true, true, this, getConstraint(coordinate));
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          stroke: color2,
          fill: null
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/edge/util.js
  function getCPath(from, to) {
    return [
      "C",
      from.x * 1 / 2 + to.x * 1 / 2,
      from.y,
      from.x * 1 / 2 + to.x * 1 / 2,
      to.y,
      to.x,
      to.y
    ];
  }
  function getQPath(to, center) {
    var points = [];
    points.push({
      x: center.x,
      y: center.y
    });
    points.push(to);
    var sub4 = ["Q"];
    each_default(points, function(point) {
      sub4.push(point.x, point.y);
    });
    return sub4;
  }

  // node_modules/@antv/g2/esm/geometry/shape/edge/arc.js
  function getArcShapePath(from, to, center) {
    var sub4 = getQPath(to, center);
    var path = [["M", from.x, from.y]];
    path.push(sub4);
    return path;
  }
  function getArcShapeWeightPath(points, center) {
    var arc1 = getQPath(points[1], center);
    var arc2 = getQPath(points[3], center);
    var path = [["M", points[0].x, points[0].y]];
    path.push(arc2);
    path.push(["L", points[3].x, points[3].y]);
    path.push(["L", points[2].x, points[2].y]);
    path.push(arc1);
    path.push(["L", points[1].x, points[1].y]);
    path.push(["L", points[0].x, points[0].y]);
    path.push(["Z"]);
    return path;
  }
  registerShape("edge", "arc", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var points = cfg.points;
      var type = points.length > 2 ? "weight" : "normal";
      var path;
      if (cfg.isInCircle) {
        var center = { x: 0, y: 1 };
        if (type === "normal") {
          path = getArcShapePath(points[0], points[1], center);
        } else {
          style.fill = style.stroke;
          path = getArcShapeWeightPath(points, center);
        }
        path = this.parsePath(path);
        return container.addShape("path", {
          attrs: __assign(__assign({}, style), { path })
        });
      } else {
        if (type === "normal") {
          points = this.parsePoints(points);
          path = getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
          return container.addShape("path", {
            attrs: __assign(__assign({}, style), { path })
          });
        } else {
          var c1 = getCPath(points[1], points[3]);
          var c2 = getCPath(points[2], points[0]);
          path = [
            ["M", points[0].x, points[0].y],
            ["L", points[1].x, points[1].y],
            c1,
            ["L", points[3].x, points[3].y],
            ["L", points[2].x, points[2].y],
            c2,
            ["Z"]
          ];
          path = this.parsePath(path);
          style.fill = style.stroke;
          return container.addShape("path", {
            attrs: __assign(__assign({}, style), { path })
          });
        }
      }
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/edge/smooth.js
  function getSmoothPath(from, to) {
    var sub4 = getCPath(from, to);
    var path = [["M", from.x, from.y]];
    path.push(sub4);
    return path;
  }
  registerShape("edge", "smooth", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var points = cfg.points;
      var path = this.parsePath(getSmoothPath(points[0], points[1]));
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/edge/vhv.js
  var CORNER_PERCENT = 1 / 3;
  function getVHVPath(from, to) {
    var points = [];
    points.push({
      x: from.x,
      y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
    });
    points.push({
      x: to.x,
      y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
    });
    points.push(to);
    var path = [["M", from.x, from.y]];
    each_default(points, function(point) {
      path.push(["L", point.x, point.y]);
    });
    return path;
  }
  registerShape("edge", "vhv", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var points = cfg.points;
      var path = this.parsePath(getVHVPath(points[0], points[1]));
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/funnel.js
  registerShape("interval", "funnel", {
    getPoints: function(shapePoint) {
      shapePoint.size = shapePoint.size * 2;
      return getRectPoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, false, true);
      var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/hollow-rect.js
  registerShape("interval", "hollow-rect", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false);
      var group2 = container;
      var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
      if (backgroundCfg) {
        group2 = container.addGroup();
        var backgroundStyle = getBackgroundRectStyle(cfg);
        var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
        group2.addShape("path", {
          attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
          zIndex: -1,
          name: BACKGROUND_SHAPE
        });
      }
      var path = this.parsePath(getRectPath(cfg.points));
      var shape = group2.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return backgroundCfg ? group2 : shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
      if (isInPolar) {
        return {
          symbol: "circle",
          style: {
            r: 4.5,
            stroke: color2,
            fill: null
          }
        };
      }
      return {
        symbol: "square",
        style: {
          r: 4,
          stroke: color2,
          fill: null
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/line.js
  function getLinePoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
    if (is_array_default(y)) {
      return y.map(function(yItem, idx) {
        return {
          x: is_array_default(x) ? x[idx] : x,
          y: yItem
        };
      });
    }
    return [
      { x, y: y0 },
      { x, y }
    ];
  }
  registerShape("interval", "line", {
    getPoints: function(shapePoint) {
      return getLinePoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var newStyle = omit(__assign({}, style), ["fill"]);
      var path = this.parsePath(getRectPath(cfg.points, false));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, newStyle), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          return [
            ["M", x, y - r],
            ["L", x, y + r]
          ];
        },
        style: {
          r: 5,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/pyramid.js
  registerShape("interval", "pyramid", {
    getPoints: function(shapePoint) {
      shapePoint.size = shapePoint.size * 2;
      return getRectPoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, false, true);
      var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/tick.js
  function getTickPoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
    var yMin;
    var yMax;
    if (is_array_default(y)) {
      yMin = y[0], yMax = y[1];
    } else {
      yMin = y0;
      yMax = y;
    }
    var xMax = x + size3 / 2;
    var xMin = x - size3 / 2;
    return [
      { x, y: yMin },
      { x, y: yMax },
      { x: xMin, y: yMin },
      { x: xMax, y: yMin },
      { x: xMin, y: yMax },
      { x: xMax, y: yMax }
    ];
  }
  function getTickPath(points) {
    return [
      ["M", points[0].x, points[0].y],
      ["L", points[1].x, points[1].y],
      ["M", points[2].x, points[2].y],
      ["L", points[3].x, points[3].y],
      ["M", points[4].x, points[4].y],
      ["L", points[5].x, points[5].y]
    ];
  }
  registerShape("interval", "tick", {
    getPoints: function(shapePoint) {
      return getTickPoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false);
      var path = this.parsePath(getTickPath(cfg.points));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          return [
            ["M", x - r / 2, y - r],
            ["L", x + r / 2, y - r],
            ["M", x, y - r],
            ["L", x, y + r],
            ["M", x - r / 2, y + r],
            ["L", x + r / 2, y + r]
          ];
        },
        style: {
          r: 5,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/line/step.js
  var interpolateCallback = function(point, nextPoint, shapeType) {
    var x = point.x;
    var y = point.y;
    var nextX = nextPoint.x;
    var nextY = nextPoint.y;
    var result;
    switch (shapeType) {
      case "hv":
        result = [{ x: nextX, y }];
        break;
      case "vh":
        result = [{ x, y: nextY }];
        break;
      case "hvh":
        var middleX = (nextX + x) / 2;
        result = [
          { x: middleX, y },
          { x: middleX, y: nextY }
        ];
        break;
      case "vhv":
        var middleY = (y + nextY) / 2;
        result = [
          { x, y: middleY },
          { x: nextX, y: middleY }
        ];
        break;
      default:
        break;
    }
    return result;
  };
  function getInterpolatePoints(points, shapeType) {
    var result = [];
    each_default(points, function(point, index) {
      var nextPoint = points[index + 1];
      result.push(point);
      if (nextPoint) {
        var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);
        result = result.concat(interpolatePoint);
      }
    });
    return result;
  }
  function getInterpolatePath(points) {
    return points.map(function(point, index) {
      return index === 0 ? ["M", point.x, point.y] : ["L", point.x, point.y];
    });
  }
  function getInterpolateShapeAttrs(cfg, shapeType) {
    var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
    var path = [];
    each_default(points, function(eachLinePoints) {
      var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
      path = path.concat(getInterpolatePath(interpolatePoints));
    });
    return __assign(__assign({}, getStyle2(cfg, true, false, "lineWidth")), { path });
  }
  each_default(["hv", "vh", "hvh", "vhv"], function(shapeType) {
    registerShape("line", shapeType, {
      draw: function(cfg, container) {
        var attrs = getInterpolateShapeAttrs(cfg, shapeType);
        var shape = container.addShape({
          type: "path",
          attrs,
          name: "line"
        });
        return shape;
      },
      getMarker: function(markerCfg) {
        return getLineMarker(markerCfg, shapeType);
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/shape/point/hollow.js
  each_default(HOLLOW_SHAPES, function(shapeName) {
    registerShape("point", shapeName, {
      draw: function(cfg, container) {
        return drawPoints(this, cfg, container, shapeName, true);
      },
      getMarker: function(markerCfg) {
        var color2 = markerCfg.color;
        return {
          symbol: MarkerSymbols[shapeName],
          style: {
            r: 4.5,
            stroke: color2,
            fill: null
          }
        };
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/shape/point/image.js
  registerShape("point", "image", {
    draw: function(cfg, container) {
      var size3 = getStyle2(cfg, false, false, "r").r;
      var points = this.parsePoints(cfg.points);
      var pointPosition = points[0];
      if (cfg.isStack) {
        pointPosition = points[1];
      } else if (points.length > 1) {
        var group2 = container.addGroup();
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
          var point = points_1[_i];
          group2.addShape("image", {
            attrs: {
              x: point.x - size3 / 2,
              y: point.y - size3,
              width: size3,
              height: size3,
              img: cfg.shape[1]
            }
          });
        }
        return group2;
      }
      return container.addShape("image", {
        attrs: {
          x: pointPosition.x - size3 / 2,
          y: pointPosition.y - size3,
          width: size3,
          height: size3,
          img: cfg.shape[1]
        }
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/point/solid.js
  each_default(SHAPES, function(shapeName) {
    registerShape("point", shapeName, {
      draw: function(cfg, container) {
        return drawPoints(this, cfg, container, shapeName, false);
      },
      getMarker: function(markerCfg) {
        var color2 = markerCfg.color;
        return {
          symbol: MarkerSymbols[shapeName] || shapeName,
          style: {
            r: 4.5,
            fill: color2
          }
        };
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/shape/schema/box.js
  function parseValue(value) {
    var array = !is_array_default(value) ? [value] : value;
    var min3 = array[0];
    var max3 = array[array.length - 1];
    var min1 = array.length > 1 ? array[1] : min3;
    var max1 = array.length > 3 ? array[3] : max3;
    var median = array.length > 2 ? array[2] : min1;
    return {
      min: min3,
      max: max3,
      min1,
      max1,
      median
    };
  }
  function getBoxPoints(x, y, size3) {
    var halfSize = size3 / 2;
    var pointsArray;
    if (is_array_default(y)) {
      var _a4 = parseValue(y), min3 = _a4.min, max3 = _a4.max, median = _a4.median, min1 = _a4.min1, max1 = _a4.max1;
      var minX = x - halfSize;
      var maxX = x + halfSize;
      pointsArray = [
        [minX, max3],
        [maxX, max3],
        [x, max3],
        [x, max1],
        [minX, min1],
        [minX, max1],
        [maxX, max1],
        [maxX, min1],
        [x, min1],
        [x, min3],
        [minX, min3],
        [maxX, min3],
        [minX, median],
        [maxX, median]
      ];
    } else {
      y = is_nil_default(y) ? 0.5 : y;
      var _b = parseValue(x), min3 = _b.min, max3 = _b.max, median = _b.median, min1 = _b.min1, max1 = _b.max1;
      var minY = y - halfSize;
      var maxY = y + halfSize;
      pointsArray = [
        [min3, minY],
        [min3, maxY],
        [min3, y],
        [min1, y],
        [min1, minY],
        [min1, maxY],
        [max1, maxY],
        [max1, minY],
        [max1, y],
        [max3, y],
        [max3, minY],
        [max3, maxY],
        [median, minY],
        [median, maxY]
      ];
    }
    return pointsArray.map(function(arr) {
      return {
        x: arr[0],
        y: arr[1]
      };
    });
  }
  function getBoxPath(points) {
    return [
      ["M", points[0].x, points[0].y],
      ["L", points[1].x, points[1].y],
      ["M", points[2].x, points[2].y],
      ["L", points[3].x, points[3].y],
      ["M", points[4].x, points[4].y],
      ["L", points[5].x, points[5].y],
      ["L", points[6].x, points[6].y],
      ["L", points[7].x, points[7].y],
      ["L", points[4].x, points[4].y],
      ["Z"],
      ["M", points[8].x, points[8].y],
      ["L", points[9].x, points[9].y],
      ["M", points[10].x, points[10].y],
      ["L", points[11].x, points[11].y],
      ["M", points[12].x, points[12].y],
      ["L", points[13].x, points[13].y]
    ];
  }
  registerShape("schema", "box", {
    getPoints: function(shapePoint) {
      var x = shapePoint.x, y = shapePoint.y, size3 = shapePoint.size;
      return getBoxPoints(x, y, size3);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false);
      var path = this.parsePath(getBoxPath(cfg.points));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path, name: "schema" })
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          var yValues = [y - 6, y - 3, y, y + 3, y + 6];
          var points = getBoxPoints(x, yValues, r);
          return [
            ["M", points[0].x + 1, points[0].y],
            ["L", points[1].x - 1, points[1].y],
            ["M", points[2].x, points[2].y],
            ["L", points[3].x, points[3].y],
            ["M", points[4].x, points[4].y],
            ["L", points[5].x, points[5].y],
            ["L", points[6].x, points[6].y],
            ["L", points[7].x, points[7].y],
            ["L", points[4].x, points[4].y],
            ["Z"],
            ["M", points[8].x, points[8].y],
            ["L", points[9].x, points[9].y],
            ["M", points[10].x + 1, points[10].y],
            ["L", points[11].x - 1, points[11].y],
            ["M", points[12].x, points[12].y],
            ["L", points[13].x, points[13].y]
          ];
        },
        style: {
          r: 6,
          lineWidth: 1,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/schema/candle.js
  function getCandleYValues(value) {
    var array = !is_array_default(value) ? [value] : value;
    var sorted = array.sort(function(a, b) {
      return b - a;
    });
    return padEnd(sorted, 4, sorted[sorted.length - 1]);
  }
  function getCandlePoints(x, y, size3) {
    var yValues = getCandleYValues(y);
    return [
      { x, y: yValues[0] },
      { x, y: yValues[1] },
      { x: x - size3 / 2, y: yValues[2] },
      { x: x - size3 / 2, y: yValues[1] },
      { x: x + size3 / 2, y: yValues[1] },
      { x: x + size3 / 2, y: yValues[2] },
      { x, y: yValues[2] },
      { x, y: yValues[3] }
    ];
  }
  function getCandlePath(points) {
    return [
      ["M", points[0].x, points[0].y],
      ["L", points[1].x, points[1].y],
      ["M", points[2].x, points[2].y],
      ["L", points[3].x, points[3].y],
      ["L", points[4].x, points[4].y],
      ["L", points[5].x, points[5].y],
      ["Z"],
      ["M", points[6].x, points[6].y],
      ["L", points[7].x, points[7].y]
    ];
  }
  registerShape("schema", "candle", {
    getPoints: function(shapePoint) {
      var x = shapePoint.x, y = shapePoint.y, size3 = shapePoint.size;
      return getCandlePoints(x, y, size3);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, true);
      var path = this.parsePath(getCandlePath(cfg.points));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path, name: "schema" })
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
          var points = getCandlePoints(x, yValues, r);
          return [
            ["M", points[0].x, points[0].y],
            ["L", points[1].x, points[1].y],
            ["M", points[2].x, points[2].y],
            ["L", points[3].x, points[3].y],
            ["L", points[4].x, points[4].y],
            ["L", points[5].x, points[5].y],
            ["Z"],
            ["M", points[6].x, points[6].y],
            ["L", points[7].x, points[7].y]
          ];
        },
        style: {
          lineWidth: 1,
          stroke: color2,
          fill: color2,
          r: 6
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/polygon/square.js
  function getRectAttrs(points, size3) {
    var width = Math.abs(points[0].x - points[2].x);
    var height = Math.abs(points[0].y - points[2].y);
    var len3 = Math.min(width, height);
    if (size3) {
      len3 = clamp_default(size3, 0, Math.min(width, height));
    }
    len3 = len3 / 2;
    var centerX = (points[0].x + points[2].x) / 2;
    var centerY = (points[0].y + points[2].y) / 2;
    return {
      x: centerX - len3,
      y: centerY - len3,
      width: len3 * 2,
      height: len3 * 2
    };
  }
  registerShape("polygon", "square", {
    draw: function(cfg, container) {
      if (!is_empty_default(cfg.points)) {
        var shapeAttrs = getStyle2(cfg, true, true);
        var points = this.parsePoints(cfg.points);
        return container.addShape("rect", {
          attrs: __assign(__assign({}, shapeAttrs), getRectAttrs(points, cfg.size)),
          name: "polygon"
        });
      }
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/violin/smooth.js
  registerShape("violin", "smooth", {
    draw: function(cfg, container) {
      var attrs = getStyle2(cfg, true, true);
      var path = this.parsePath(getSmoothViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, attrs), { path })
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          stroke: null,
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/violin/hollow.js
  registerShape("violin", "hollow", {
    draw: function(cfg, container) {
      var attrs = getStyle2(cfg, true, false);
      var path = this.parsePath(getViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, attrs), { path })
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4,
          fill: null,
          stroke: color2
        }
      };
    }
  });
  registerShape("violin", "hollow-smooth", {
    draw: function(cfg, container) {
      var attrs = getStyle2(cfg, true, false);
      var path = this.parsePath(getSmoothViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, attrs), { path })
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4,
          fill: null,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/label/interval.js
  var IntervalLabel = function(_super) {
    __extends(IntervalLabel2, _super);
    function IntervalLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
      var dim = "y";
      var points = mappingData.points;
      return points[0][dim] <= points[2][dim] ? 1 : -1;
    };
    IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total, position) {
      var _a4;
      var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
      var coordinate = this.getCoordinate();
      var transposed = coordinate.isTransposed;
      var dim = transposed ? "x" : "y";
      var dir = this.getLabelValueDir(labelCfg.mappingData);
      point = __assign(__assign({}, point), (_a4 = {}, _a4[dim] = point[dim] * dir, _a4));
      if (coordinate.isReflect("x")) {
        point = __assign(__assign({}, point), { x: point.x * -1 });
      }
      if (coordinate.isReflect("y")) {
        point = __assign(__assign({}, point), { y: point.y * -1 });
      }
      return point;
    };
    IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var theme = geometry.theme;
      return deep_mix_default({}, defaultLabelCfg, theme.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
    };
    IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
      var coordinate = this.getCoordinate();
      var transposed = coordinate.isTransposed;
      var shapePoints = mappingData.points;
      var point0 = coordinate.convert(shapePoints[0]);
      var point2 = coordinate.convert(shapePoints[2]);
      var dir = this.getLabelValueDir(mappingData);
      var top;
      var right;
      var bottom;
      var left;
      var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      if (shape === "funnel" || shape === "pyramid") {
        var nextPoints = get_default(mappingData, "nextPoints");
        var points = get_default(mappingData, "points");
        if (nextPoints) {
          var p0 = coordinate.convert(points[0]);
          var p1 = coordinate.convert(points[1]);
          var nextP0 = coordinate.convert(nextPoints[0]);
          var nextP1 = coordinate.convert(nextPoints[1]);
          if (transposed) {
            top = Math.min(nextP0.y, p0.y);
            bottom = Math.max(nextP0.y, p0.y);
            right = (p1.x + nextP1.x) / 2;
            left = (p0.x + nextP0.x) / 2;
          } else {
            top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            right = nextP1.x;
            left = p0.x;
          }
        } else {
          top = Math.min(point2.y, point0.y);
          bottom = Math.max(point2.y, point0.y);
          right = point2.x;
          left = point0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right = point2.x;
        left = point0.x;
      }
      switch (position) {
        case "right":
          labelPointCfg.x = right;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "left":
          labelPointCfg.x = left;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "bottom":
          if (transposed) {
            labelPointCfg.x = (right + left) / 2;
          }
          labelPointCfg.y = bottom;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        case "middle":
          if (transposed) {
            labelPointCfg.x = (right + left) / 2;
          }
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", "middle");
          break;
        case "top":
          if (transposed) {
            labelPointCfg.x = (right + left) / 2;
          }
          labelPointCfg.y = top;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        default:
          break;
      }
    };
    return IntervalLabel2;
  }(base_default15);
  var interval_default2 = IntervalLabel;

  // node_modules/@antv/g2/esm/geometry/label/polar.js
  var HALF_PI = Math.PI / 2;
  var PolarLabel = function(_super) {
    __extends(PolarLabel2, _super);
    function PolarLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate = this.getCoordinate();
      var actualOffset = 0;
      if (is_number_default(offset)) {
        actualOffset = offset;
      } else if (is_string_default(offset) && offset.indexOf("%") !== -1) {
        var r = coordinate.getRadius();
        if (coordinate.innerRadius > 0) {
          r = r * (1 - coordinate.innerRadius);
        }
        actualOffset = parseFloat(offset) * 0.01 * r;
      }
      return actualOffset;
    };
    PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
      var items = _super.prototype.getLabelItems.call(this, mapppingArray);
      var yScale = this.geometry.getYScale();
      return map_default(items, function(item) {
        if (item && yScale) {
          var percent = yScale.scale(get_default(item.data, yScale.field));
          return __assign(__assign({}, item), { percent });
        }
        return item;
      });
    };
    PolarLabel2.prototype.getLabelAlign = function(point) {
      var coordinate = this.getCoordinate();
      var align;
      if (point.labelEmit) {
        align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? "left" : "right";
      } else if (!coordinate.isTransposed) {
        align = "center";
      } else {
        var center = coordinate.getCenter();
        var offset = point.offset;
        if (Math.abs(point.x - center.x) < 1) {
          align = "center";
        } else if (point.angle > Math.PI || point.angle <= 0) {
          align = offset > 0 ? "left" : "right";
        } else {
          align = offset > 0 ? "right" : "left";
        }
      }
      return align;
    };
    PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var factor = 1;
      var arcPoint;
      var content = labelCfg.content[index];
      if (this.isToMiddle(mappingData)) {
        arcPoint = this.getMiddlePoint(mappingData.points);
      } else {
        if (labelCfg.content.length === 1 && index === 0) {
          index = 1;
        } else if (index === 0) {
          factor = -1;
        }
        arcPoint = this.getArcPoint(mappingData, index);
      }
      var offset = labelCfg.offset * factor;
      var middleAngle = this.getPointAngle(arcPoint);
      var isLabelEmit = labelCfg.labelEmit;
      var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
      if (labelPositionCfg.r === 0) {
        labelPositionCfg.content = "";
      } else {
        labelPositionCfg.content = content;
        labelPositionCfg.angle = middleAngle;
        labelPositionCfg.color = mappingData.color;
      }
      labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
      labelPositionCfg.start = {
        x: arcPoint.x,
        y: arcPoint.y
      };
      return labelPositionCfg;
    };
    PolarLabel2.prototype.getArcPoint = function(mappingData, index) {
      if (index === void 0) {
        index = 0;
      }
      if (!is_array_default(mappingData.x) && !is_array_default(mappingData.y)) {
        return {
          x: mappingData.x,
          y: mappingData.y
        };
      }
      return {
        x: is_array_default(mappingData.x) ? mappingData.x[index] : mappingData.x,
        y: is_array_default(mappingData.y) ? mappingData.y[index] : mappingData.y
      };
    };
    PolarLabel2.prototype.getPointAngle = function(point) {
      return getAngleByPoint(this.getCoordinate(), point);
    };
    PolarLabel2.prototype.getCirclePoint = function(angle3, offset, point, isLabelEmit) {
      var coordinate = this.getCoordinate();
      var center = coordinate.getCenter();
      var r = getDistanceToCenter(coordinate, point);
      if (r === 0) {
        return __assign(__assign({}, center), { r });
      }
      var labelAngle = angle3;
      if (coordinate.isTransposed && r > offset && !isLabelEmit) {
        var appendAngle = Math.asin(offset / (2 * r));
        labelAngle = angle3 + appendAngle * 2;
      } else {
        r = r + offset;
      }
      return {
        x: center.x + r * Math.cos(labelAngle),
        y: center.y + r * Math.sin(labelAngle),
        r
      };
    };
    PolarLabel2.prototype.getLabelRotate = function(angle3, offset, isLabelEmit) {
      var rotate5 = angle3 + HALF_PI;
      if (isLabelEmit) {
        rotate5 -= HALF_PI;
      }
      if (rotate5) {
        if (rotate5 > HALF_PI) {
          rotate5 = rotate5 - Math.PI;
        } else if (rotate5 < -HALF_PI) {
          rotate5 = rotate5 + Math.PI;
        }
      }
      return rotate5;
    };
    PolarLabel2.prototype.getMiddlePoint = function(points) {
      var coordinate = this.getCoordinate();
      var count = points.length;
      var middlePoint = {
        x: 0,
        y: 0
      };
      each_default(points, function(point) {
        middlePoint.x += point.x;
        middlePoint.y += point.y;
      });
      middlePoint.x /= count;
      middlePoint.y /= count;
      middlePoint = coordinate.convert(middlePoint);
      return middlePoint;
    };
    PolarLabel2.prototype.isToMiddle = function(mappingData) {
      return mappingData.x.length > 2;
    };
    return PolarLabel2;
  }(base_default15);
  var polar_default2 = PolarLabel;

  // node_modules/@antv/g2/esm/geometry/label/pie.js
  var PieLabel = function(_super) {
    __extends(PieLabel2, _super);
    function PieLabel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.defaultLayout = "distribute";
      return _this;
    }
    PieLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
      return deep_mix_default({}, cfg, get_default(this.geometry.theme, "pieLabels", {}));
    };
    PieLabel2.prototype.getLabelOffset = function(offset) {
      return _super.prototype.getLabelOffset.call(this, offset) || 0;
    };
    PieLabel2.prototype.getLabelRotate = function(angle3, offset, isLabelLimit) {
      var rotate5;
      if (offset < 0) {
        rotate5 = angle3;
        if (rotate5 > Math.PI / 2) {
          rotate5 = rotate5 - Math.PI;
        }
        if (rotate5 < -Math.PI / 2) {
          rotate5 = rotate5 + Math.PI;
        }
      }
      return rotate5;
    };
    PieLabel2.prototype.getLabelAlign = function(point) {
      var coordinate = this.getCoordinate();
      var center = coordinate.getCenter();
      var align;
      if (point.angle <= Math.PI / 2 && point.x >= center.x) {
        align = "left";
      } else {
        align = "right";
      }
      if (point.offset <= 0) {
        if (align === "right") {
          align = "left";
        } else {
          align = "right";
        }
      }
      return align;
    };
    PieLabel2.prototype.getArcPoint = function(point) {
      return point;
    };
    PieLabel2.prototype.getPointAngle = function(point) {
      var coordinate = this.getCoordinate();
      var startPoint = {
        x: is_array_default(point.x) ? point.x[0] : point.x,
        y: point.y[0]
      };
      var endPoint = {
        x: is_array_default(point.x) ? point.x[1] : point.x,
        y: point.y[1]
      };
      var angle3;
      var startAngle = getAngleByPoint(coordinate, startPoint);
      if (point.points && point.points[0].y === point.points[1].y) {
        angle3 = startAngle;
      } else {
        var endAngle = getAngleByPoint(coordinate, endPoint);
        if (startAngle >= endAngle) {
          endAngle = endAngle + Math.PI * 2;
        }
        angle3 = startAngle + (endAngle - startAngle) / 2;
      }
      return angle3;
    };
    PieLabel2.prototype.getCirclePoint = function(angle3, offset) {
      var coordinate = this.getCoordinate();
      var center = coordinate.getCenter();
      var r = coordinate.getRadius() + offset;
      return __assign(__assign({}, polarToCartesian(center.x, center.y, r, angle3)), { angle: angle3, r });
    };
    return PieLabel2;
  }(polar_default2);
  var pie_default = PieLabel;

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js
  var MARGIN = 4;
  function antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {
    var overlapping = true;
    var start = plotRange.start;
    var end = plotRange.end;
    var startY = Math.min(start.y, end.y);
    var totalHeight = Math.abs(start.y - end.y);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function(label) {
      if (label.y > maxY) {
        maxY = label.y;
      }
      if (label.y < minY) {
        minY = label.y;
      }
      return {
        size: lineHeight,
        targets: [label.y - startY]
      };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
      totalHeight = maxY - startY;
    }
    while (overlapping) {
      boxes.forEach(function(box3) {
        var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
        box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
      });
      overlapping = false;
      i = boxes.length;
      while (i--) {
        if (i > 0) {
          var previousBox = boxes[i - 1];
          var box2 = boxes[i];
          if (previousBox.pos + previousBox.size > box2.pos) {
            previousBox.size += box2.size;
            previousBox.targets = previousBox.targets.concat(box2.targets);
            if (previousBox.pos + previousBox.size > totalHeight) {
              previousBox.pos = totalHeight - previousBox.size;
            }
            boxes.splice(i, 1);
            overlapping = true;
          }
        }
      }
    }
    i = 0;
    boxes.forEach(function(b) {
      var posInCompositeBox = startY + lineHeight / 2;
      b.targets.forEach(function() {
        labels[i].y = b.pos + posInCompositeBox;
        posInCompositeBox += lineHeight;
        i++;
      });
    });
    var labelsMap = {};
    for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {
      var labelShape = labelShapes_1[_i];
      labelsMap[labelShape.get("id")] = labelShape;
    }
    labels.forEach(function(label) {
      var rPow2 = label.r * label.r;
      var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
      if (rPow2 < dyPow2) {
        label.x = center.x;
      } else {
        var dx = Math.sqrt(rPow2 - dyPow2);
        if (!isRight) {
          label.x = center.x - dx;
        } else {
          label.x = center.x + dx;
        }
      }
      var labelShape2 = labelsMap[label.id];
      labelShape2.attr("x", label.x);
      labelShape2.attr("y", label.y);
      var textShape = find_default(labelShape2.getChildren(), function(ele) {
        return ele.get("type") === "text";
      });
      if (textShape) {
        textShape.attr("y", label.y);
        textShape.attr("x", label.x);
      }
    });
  }
  function distribute(items, labels, shapes, region) {
    if (!items.length || !labels.length) {
      return;
    }
    var offset = items[0] ? items[0].offset : 0;
    var coordinate = labels[0].get("coordinate");
    var radius = coordinate.getRadius();
    var center = coordinate.getCenter();
    if (offset > 0) {
      var lineHeight_1 = 14;
      var totalR = radius + offset;
      var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
      var plotRange_1 = {
        start: coordinate.start,
        end: coordinate.end
      };
      var halves_1 = [
        [],
        []
      ];
      items.forEach(function(labelItem) {
        if (!labelItem) {
          return;
        }
        if (labelItem.textAlign === "right") {
          halves_1[0].push(labelItem);
        } else {
          halves_1[1].push(labelItem);
        }
      });
      halves_1.forEach(function(half, index) {
        var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
        if (half.length > maxLabelsCountForOneSide) {
          half.sort(function(a, b) {
            return b["..percent"] - a["..percent"];
          });
          half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
        }
        half.sort(function(a, b) {
          return a.y - b.y;
        });
        antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);
      });
    }
    each_default(items, function(item) {
      if (item && item.labelLine) {
        var distance8 = item.offset;
        var angle3 = item.angle;
        var startPoint = polarToCartesian(center.x, center.y, radius, angle3);
        var innerPoint = polarToCartesian(center.x, center.y, radius + distance8 / 2, angle3);
        var itemX = item.x + get_default(item, "offsetX", 0);
        var itemY = item.y + get_default(item, "offsetY", 0);
        var endPoint = {
          x: itemX - Math.cos(angle3) * MARGIN,
          y: itemY - Math.sin(angle3) * MARGIN
        };
        if (!is_object_default(item.labelLine)) {
          item.labelLine = {};
        }
        item.labelLine.path = [
          "M " + startPoint.x,
          startPoint.y + " Q" + innerPoint.x,
          innerPoint.y + " " + endPoint.x,
          endPoint.y
        ].join(",");
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js
  function antiCollision2(items, labelHeight, plotRange) {
    var labels = items.filter(function(item) {
      return !item.invisible;
    });
    labels.sort(function(a, b) {
      return a.y - b.y;
    });
    var overlapping = true;
    var startY = plotRange.minY;
    var endY = plotRange.maxY;
    var totalHeight = Math.abs(startY - endY);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function(label) {
      if (label.y > maxY) {
        maxY = label.y;
      }
      if (label.y < minY) {
        minY = label.y;
      }
      return {
        content: label.content,
        size: labelHeight,
        targets: [label.y - startY],
        pos: null
      };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
      totalHeight = maxY - startY;
    }
    while (overlapping) {
      boxes.forEach(function(box3) {
        var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
        box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
        box3.pos = Math.max(0, box3.pos);
      });
      overlapping = false;
      i = boxes.length;
      while (i--) {
        if (i > 0) {
          var previousBox = boxes[i - 1];
          var box2 = boxes[i];
          if (previousBox.pos + previousBox.size > box2.pos) {
            previousBox.size += box2.size;
            previousBox.targets = previousBox.targets.concat(box2.targets);
            if (previousBox.pos + previousBox.size > totalHeight) {
              previousBox.pos = totalHeight - previousBox.size;
            }
            boxes.splice(i, 1);
            overlapping = true;
          }
        }
      }
    }
    i = 0;
    boxes.forEach(function(b) {
      var posInCompositeBox = startY + labelHeight / 2;
      b.targets.forEach(function() {
        labels[i].y = b.pos + posInCompositeBox;
        posInCompositeBox += labelHeight;
        i++;
      });
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/outer.js
  var MARGIN2 = 4;
  function drawLabelline(item, coordinate) {
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    if (item && item.labelLine) {
      var angle3 = item.angle, labelOffset = item.offset;
      var startPoint = polarToCartesian(center.x, center.y, radius, angle3);
      var itemX = item.x + get_default(item, "offsetX", 0) * (Math.cos(angle3) > 0 ? 1 : -1);
      var itemY = item.y + get_default(item, "offsetY", 0) * (Math.sin(angle3) > 0 ? 1 : -1);
      var endPoint = {
        x: itemX - Math.cos(angle3) * MARGIN2,
        y: itemY - Math.sin(angle3) * MARGIN2
      };
      var smoothConnector = item.labelLine.smooth;
      var path = [];
      var dx = endPoint.x - center.x;
      var dy = endPoint.y - center.y;
      var endAngle = Math.atan(dy / dx);
      if (dx < 0) {
        endAngle += Math.PI;
      }
      if (smoothConnector === false) {
        if (!is_object_default(item.labelLine)) {
          item.labelLine = {};
        }
        var sweepFlag = 0;
        if (angle3 < 0 && angle3 > -Math.PI / 2 || angle3 > Math.PI * 1.5) {
          if (endPoint.y > startPoint.y) {
            sweepFlag = 1;
          }
        }
        if (angle3 >= 0 && angle3 < Math.PI / 2) {
          if (endPoint.y > startPoint.y) {
            sweepFlag = 1;
          }
        }
        if (angle3 >= Math.PI / 2 && angle3 < Math.PI) {
          if (startPoint.y > endPoint.y) {
            sweepFlag = 1;
          }
        }
        if (angle3 < -Math.PI / 2 || angle3 >= Math.PI && angle3 < Math.PI * 1.5) {
          if (startPoint.y > endPoint.y) {
            sweepFlag = 1;
          }
        }
        var distance8 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
        var breakPoint = polarToCartesian(center.x, center.y, radius + distance8, angle3);
        var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);
        var largeArcFlag = 0;
        path.push("M " + startPoint.x + " " + startPoint.y);
        path.push("L " + breakPoint.x + " " + breakPoint.y);
        path.push("A " + center.x + " " + center.y + " 0 " + largeArcFlag + " " + sweepFlag + " " + breakPoint3.x + " " + breakPoint3.y);
        path.push("L " + endPoint.x + " " + endPoint.y);
      } else {
        var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle3);
        var xSign = startPoint.x < center.x ? 1 : -1;
        path.push("M " + endPoint.x + " " + endPoint.y);
        var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);
        var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);
        if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
          path.push.apply(path, [
            "C",
            endPoint.x + xSign * 4,
            endPoint.y,
            2 * breakPoint.x - startPoint.x,
            2 * breakPoint.y - startPoint.y,
            startPoint.x,
            startPoint.y
          ]);
        }
        path.push("L " + startPoint.x + " " + startPoint.y);
      }
      item.labelLine.path = path.join(" ");
    }
  }
  function pieOuterLabelLayout(originalItems, labels, shapes, region) {
    var items = filter_default(originalItems, function(item) {
      return !is_nil_default(item);
    });
    var coordinate = labels[0] && labels[0].get("coordinate");
    if (!coordinate) {
      return;
    }
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    var labelsMap = {};
    for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
      var labelShape = labels_1[_i];
      labelsMap[labelShape.get("id")] = labelShape;
    }
    var labelHeight = get_default(items[0], "labelHeight", 14);
    var labelOffset = get_default(items[0], "offset", 0);
    if (labelOffset <= 0) {
      return;
    }
    var LEFT_HALF_KEY = "left";
    var RIGHT_HALF_KEY = "right";
    var separateLabels = group_by_default(items, function(item) {
      return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
    });
    var start = coordinate.start, end = coordinate.end;
    var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());
    var totalR = totalHeight / 2;
    var labelsContainerRange = {
      minX: start.x,
      maxX: end.x,
      minY: center.y - totalR,
      maxY: center.y + totalR
    };
    each_default(separateLabels, function(half, key) {
      var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b.percent - a.percent;
        });
        each_default(half, function(labelItem, idx) {
          if (idx + 1 > maxLabelsCountForOneSide) {
            labelsMap[labelItem.id].set("visible", false);
            labelItem.invisible = true;
          }
        });
      }
      antiCollision2(half, labelHeight, labelsContainerRange);
    });
    each_default(separateLabels, function(half, key) {
      each_default(half, function(item) {
        var isRight = key === RIGHT_HALF_KEY;
        var labelShape2 = labelsMap[item.id];
        var content = labelShape2.getChildByIndex(0);
        if (content) {
          var r = radius + labelOffset;
          var dy = item.y - center.y;
          var rPow2 = Math.pow(r, 2);
          var dyPow2 = Math.pow(dy, 2);
          var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
          var dx = Math.sqrt(dxPow2);
          var dx_offset = Math.abs(Math.cos(item.angle) * r);
          if (!isRight) {
            item.x = center.x - Math.max(dx, dx_offset);
          } else {
            item.x = center.x + Math.max(dx, dx_offset);
          }
        }
        if (content) {
          content.attr("y", item.y);
          content.attr("x", item.x);
        }
        drawLabelline(item, coordinate);
      });
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/spider.js
  var INFLECTION_OFFSET = 4;
  var LABEL_OFFSET_X = 4;
  var LABEL_TEXT_LINE_OFFSET = 4;
  function drawLabelline2(item, coordinate, inRight) {
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    var startPoint = {
      x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
      y: item.y
    };
    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
    var p1 = { x: startPoint.x, y: startPoint.y };
    var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
    var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);
    var path = "";
    if (startPoint.y !== inflectionPoint.y) {
      var offset = inRight ? 4 : -4;
      p1.y = startPoint.y;
      if (item.angle < 0 && item.angle >= -Math.PI / 2) {
        p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y < inflectionPoint.y) {
          p2.y = p1.y;
        } else {
          p2.y = inflectionPoint.y;
          p2.x = Math.max(p2.x, p1.x - offset);
        }
      }
      if (item.angle > 0 && item.angle < Math.PI / 2) {
        p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y > inflectionPoint.y) {
          p2.y = p1.y;
        } else {
          p2.y = inflectionPoint.y;
          p2.x = Math.max(p2.x, p1.x - offset);
        }
      }
      if (item.angle > Math.PI / 2) {
        p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y > inflectionPoint.y) {
          p2.y = p1.y;
        } else {
          p2.y = inflectionPoint.y;
          p2.x = Math.min(p2.x, p1.x - offset);
        }
      }
      if (item.angle < -Math.PI / 2) {
        p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y < inflectionPoint.y) {
          p2.y = p1.y;
        } else {
          p2.y = inflectionPoint.y;
          p2.x = Math.min(p2.x, p1.x - offset);
        }
      }
    }
    path = [
      "M " + startPoint.x + "," + startPoint.y,
      "L " + p1.x + "," + p1.y,
      "L " + p2.x + "," + p2.y,
      "L " + inflectionPoint.x + "," + inflectionPoint.y,
      "L " + endPoint.x + "," + endPoint.y
    ].join(" ");
    item.labelLine = deep_mix_default({}, item.labelLine, { path });
  }
  function pieSpiderLabelLayout(items, labels, shapes, region) {
    var coordinate = labels[0] && labels[0].get("coordinate");
    if (!coordinate) {
      return;
    }
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    var labelsMap = {};
    for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
      var labelShape = labels_1[_i];
      labelsMap[labelShape.get("id")] = labelShape;
    }
    var labelHeight = get_default(items[0], "labelHeight", 14);
    var labelOffset = Math.max(get_default(items[0], "offset", 0), INFLECTION_OFFSET);
    each_default(items, function(item) {
      var label = get_default(labelsMap, [item.id]);
      if (!label) {
        return;
      }
      var inRight = item.x > center.x || item.x === center.x && item.y > center.y;
      var offsetX = !is_nil_default(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
      var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
      var totalOffset = labelOffset + offsetX;
      item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);
      item.y = inflectionPoint.y;
    });
    var start = coordinate.start, end = coordinate.end;
    var LEFT_HALF_KEY = "left";
    var RIGHT_HALF_KEY = "right";
    var seperateLabels = group_by_default(items, function(item) {
      return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
    });
    var totalHeight = (radius + labelOffset) * 2 + labelHeight;
    each_default(seperateLabels, function(half) {
      var halfHeight = half.length * labelHeight;
      if (halfHeight > totalHeight) {
        totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
      }
    });
    var labelsContainerRange = {
      minX: start.x,
      maxX: end.x,
      minY: center.y - totalHeight / 2,
      maxY: center.y + totalHeight / 2
    };
    each_default(seperateLabels, function(half, key) {
      var maxLabelsCountForOneSide = totalHeight / labelHeight;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b.percent - a.percent;
        });
        each_default(half, function(labelItem, idx) {
          if (idx > maxLabelsCountForOneSide) {
            labelsMap[labelItem.id].set("visible", false);
            labelItem.invisible = true;
          }
        });
      }
      antiCollision2(half, labelHeight, labelsContainerRange);
    });
    var startY = labelsContainerRange.minY;
    var endY = labelsContainerRange.maxY;
    each_default(seperateLabels, function(half, key) {
      var inRight = key === RIGHT_HALF_KEY;
      each_default(half, function(item) {
        var label = get_default(labelsMap, item && [item.id]);
        if (!label) {
          return;
        }
        if (item.y < startY || item.y > endY) {
          label.set("visible", false);
          return;
        }
        var labelContent = label.getChildByIndex(0);
        var box2 = labelContent.getCanvasBBox();
        var originalPos = { x: inRight ? box2.x : box2.maxX, y: box2.y + box2.height / 2 };
        translate2(labelContent, item.x - originalPos.x, item.y - originalPos.y);
        if (item.labelLine) {
          drawLabelline2(item, coordinate, inRight);
        }
      });
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/limit-in-canvas.js
  function limitInCanvas(items, labels, shapes, region) {
    each_default(labels, function(label) {
      var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
      var _a4 = label.getCanvasBBox(), minX = _a4.minX, minY = _a4.minY, maxX = _a4.maxX, maxY = _a4.maxY, x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
      var finalX = x;
      var finalY = y;
      if (minX < regionMinX || maxX < regionMinX) {
        finalX = regionMinX;
      }
      if (minY < regionMinY || maxY < regionMinY) {
        finalY = regionMinY;
      }
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY > regionMaxY) {
        finalY = finalY - (maxY - regionMaxY);
      }
      if (finalX !== x || finalY !== y) {
        translate2(label, finalX - x, finalY - y);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/limit-in-shape.js
  function limitInShape(items, labels, shapes, region) {
    each_default(labels, function(label, index) {
      var labelBBox = label.getCanvasBBox();
      var shapeBBox = shapes[index].getBBox();
      if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
        label.remove(true);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/overlap.js
  var MAX_TIMES = 100;
  var Greedy = function() {
    function Greedy2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.bitmap = {};
      var _a4 = cfg.xGap, xGap = _a4 === void 0 ? 1 : _a4, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
      this.xGap = xGap;
      this.yGap = yGap;
    }
    Greedy2.prototype.hasGap = function(bbox) {
      var hasGap = true;
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
          continue;
        }
        if (i === minX || i === maxX) {
          for (var j = minY; j <= maxY; j++) {
            if (bitmap[i][j]) {
              hasGap = false;
              break;
            }
          }
        } else {
          if (bitmap[i][minY] || bitmap[i][maxY]) {
            hasGap = false;
            break;
          }
        }
      }
      return hasGap;
    };
    Greedy2.prototype.fillGap = function(bbox) {
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
        }
      }
      for (var i = minX; i <= maxX; i += this.xGap) {
        for (var j = minY; j <= maxY; j += this.yGap) {
          bitmap[i][j] = true;
        }
        bitmap[i][maxY] = true;
      }
      if (this.yGap !== 1) {
        for (var i = minY; i <= maxY; i += 1) {
          bitmap[minX][i] = true;
          bitmap[maxX][i] = true;
        }
      }
      if (this.xGap !== 1) {
        for (var i = minX; i <= maxX; i += 1) {
          bitmap[i][minY] = true;
          bitmap[i][maxY] = true;
        }
      }
    };
    Greedy2.prototype.destroy = function() {
      this.bitmap = {};
    };
    return Greedy2;
  }();
  function spiralFill(label, greedy, maxTimes) {
    if (maxTimes === void 0) {
      maxTimes = MAX_TIMES;
    }
    var dt = -1;
    var _a4 = label.attr(), x = _a4.x, y = _a4.y;
    var bbox = label.getCanvasBBox();
    var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
    var dxdy;
    var t = -dt;
    var dx = 0;
    var dy = 0;
    var f = function(param) {
      var nt = param * 0.1;
      return [nt * Math.cos(nt), nt * Math.sin(nt)];
    };
    if (greedy.hasGap(bbox)) {
      greedy.fillGap(bbox);
      return true;
    }
    var canFill = false;
    var times = 0;
    var accessedCache = {};
    while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
      dxdy = f(t += dt);
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (!dx && !dy || accessedCache[dx + "-" + dy]) {
        continue;
      }
      label.attr({ x: x + dx, y: y + dy });
      if (dx + dy < 0) {
        label.attr("textAlign", "right");
      }
      times++;
      if (greedy.hasGap(label.getCanvasBBox())) {
        greedy.fillGap(label.getCanvasBBox());
        canFill = true;
        accessedCache[dx + "-" + dy] = true;
        break;
      }
    }
    return canFill;
  }
  function adjustLabelPosition(label, x, y, index) {
    var _a4 = label.getCanvasBBox(), width = _a4.width, height = _a4.height;
    var attrs = {
      x,
      y,
      textAlign: "center"
    };
    switch (index) {
      case 0:
        attrs.y -= height + 1;
        attrs.x += 1;
        attrs.textAlign = "left";
        break;
      case 1:
        attrs.y -= height + 1;
        attrs.x -= 1;
        attrs.textAlign = "right";
        break;
      case 2:
        attrs.y += height + 1;
        attrs.x -= 1;
        attrs.textAlign = "right";
        break;
      case 3:
        attrs.y += height + 1;
        attrs.x += 1;
        attrs.textAlign = "left";
        break;
      case 5:
        attrs.y -= height * 2 + 2;
        break;
      case 6:
        attrs.y += height * 2 + 2;
        break;
      case 7:
        attrs.x += width + 1;
        attrs.textAlign = "left";
        break;
      case 8:
        attrs.x -= width + 1;
        attrs.textAlign = "right";
        break;
      default:
        break;
    }
    label.attr(attrs);
    return label.getCanvasBBox();
  }
  function fixedOverlap(items, labels, shapes, region) {
    var greedy = new Greedy();
    each_default(labels, function(label) {
      var labelShape = label.find(function(shape) {
        return shape.get("type") === "text";
      });
      if (!spiralFill(labelShape, greedy)) {
        label.remove(true);
      }
    });
    greedy.destroy();
  }
  function overlap(items, labels, shapes, region) {
    var greedy = new Greedy();
    each_default(labels, function(label) {
      var labelShape = label.find(function(shape) {
        return shape.get("type") === "text";
      });
      var _a4 = labelShape.attr(), x = _a4.x, y = _a4.y;
      var canFill = false;
      for (var i = 0; i <= 8; i++) {
        var bbox = adjustLabelPosition(labelShape, x, y, i);
        if (greedy.hasGap(bbox)) {
          greedy.fillGap(bbox);
          canFill = true;
          break;
        }
      }
      if (!canFill) {
        label.remove(true);
      }
    });
    greedy.destroy();
  }

  // node_modules/@antv/g2/esm/util/collision-detect.js
  var dot3 = vec2_exports.dot;
  function getAxes(points) {
    if (points.length > 4) {
      return [];
    }
    var vector = function(start, end) {
      return [end.x - start.x, end.y - start.y];
    };
    var AB = vector(points[0], points[1]);
    var BC = vector(points[1], points[2]);
    return [AB, BC];
  }
  function rotateAtPoint(point, deg, origin) {
    if (deg === void 0) {
      deg = 0;
    }
    if (origin === void 0) {
      origin = { x: 0, y: 0 };
    }
    var x = point.x, y = point.y;
    return {
      x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
      y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
    };
  }
  function getRectPoints2(box2) {
    var points = [
      { x: box2.x, y: box2.y },
      { x: box2.x + box2.width, y: box2.y },
      { x: box2.x + box2.width, y: box2.y + box2.height },
      { x: box2.x, y: box2.y + box2.height }
    ];
    var rotation = box2.rotation;
    if (rotation) {
      return [
        rotateAtPoint(points[0], rotation, points[0]),
        rotateAtPoint(points[1], rotation, points[0]),
        rotateAtPoint(points[2], rotation, points[0]),
        rotateAtPoint(points[3], rotation, points[0])
      ];
    }
    return points;
  }
  function getProjection(points, axis) {
    if (points.length > 4) {
      return { min: 0, max: 0 };
    }
    var scalars = [];
    points.forEach(function(point) {
      scalars.push(dot3([point.x, point.y], axis));
    });
    return { min: Math.min.apply(Math, scalars), max: Math.max.apply(Math, scalars) };
  }
  function isProjectionOverlap(projection1, projection2) {
    return projection1.max > projection2.min && projection1.min < projection2.max;
  }
  function isValidNumber(d) {
    return is_number_default(d) && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
  }
  function isValidBox(box2) {
    return Object.values(box2).every(isValidNumber);
  }
  function isIntersectRect(box1, box2, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
  }
  function isIntersect(box1, box2) {
    if (!isValidBox(box1) || !isValidBox(box2))
      return false;
    if (!box1.rotation && !box2.rotation) {
      return isIntersectRect(box1, box2);
    }
    var rect1Points = getRectPoints2(box1);
    var rect2Points = getRectPoints2(box2);
    var axes = __spreadArray(__spreadArray([], getAxes(rect1Points), true), getAxes(rect2Points), true);
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var projection1 = getProjection(rect1Points, axis);
      var projection2 = getProjection(rect2Points, axis);
      if (!isProjectionOverlap(projection1, projection2))
        return false;
    }
    return true;
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/hide-overlap.js
  function hideOverlap(items, labels, shapes, region) {
    for (var i = 0; i < labels.length; i++) {
      var label1 = labels[i];
      if (labels[i].get("visible")) {
        for (var j = i + 1; j < labels.length; j++) {
          var label2 = labels[j];
          if (label1 && label2 && label1 !== label2 && label2.get("visible")) {
            var box1 = getlLabelBackgroundInfo(label1, items[i], get_default(items[i], "background.padding"));
            var box2 = getlLabelBackgroundInfo(label2, items[j], get_default(items[j], "background.padding"));
            if (isIntersect(box1, box2)) {
              labels[j].set("visible", false);
            }
          }
        }
      }
    }
  }

  // node_modules/@antv/g2/esm/util/color.js
  var preset = {
    "#5B8FF9": true
  };
  var isContrastColorWhite = function(color2) {
    var rgb2 = esm_default2.toRGB(color2).toUpperCase();
    if (preset[rgb2]) {
      return preset[rgb2];
    }
    var _a4 = esm_default2.rgb2arr(rgb2), r = _a4[0], g = _a4[1], b = _a4[2];
    var isDark = (r * 299 + g * 587 + b * 114) / 1e3 < 128;
    return isDark;
  };

  // node_modules/@antv/g2/esm/geometry/label/layout/adjust-color.js
  function adjustColor(items, labels, shapes) {
    if (shapes.length === 0) {
      return;
    }
    var element = shapes[0].get("element");
    var theme = element.geometry.theme;
    var _a4 = theme.labels || {}, fillColorLight = _a4.fillColorLight, fillColorDark = _a4.fillColorDark;
    shapes.forEach(function(shape, index) {
      var label = labels[index];
      var textShape = label.find(function(el) {
        return el.get("type") === "text";
      });
      var shapeBBox = BBox.fromObject(shape.getBBox());
      var textBBox = BBox.fromObject(textShape.getCanvasBBox());
      var overflow = !shapeBBox.contains(textBBox);
      var bgColor = shape.attr("fill");
      var fillWhite = isContrastColorWhite(bgColor);
      if (!overflow) {
        if (fillWhite) {
          if (fillColorLight) {
            textShape.attr("fill", fillColorLight);
          }
        } else {
          if (fillColorDark) {
            textShape.attr("fill", fillColorDark);
          }
        }
      } else {
        textShape.attr(theme.overflowLabels.style);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/interval/adjust-position.js
  function shouldInShapeSingle(geometry, label, shape) {
    var coordinate = geometry.coordinate;
    var textShape = findLabelTextShape(label);
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var shapeBBox = BBox.fromObject(shape.getBBox());
    return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
  }
  function shouldInShape(geometry, labels, shapes) {
    var isStack = !!geometry.getAdjust("stack");
    return isStack || labels.every(function(label, index) {
      var shape = shapes[index];
      return shouldInShapeSingle(geometry, label, shape);
    });
  }
  function moveInShape(geometry, label, shape) {
    var coordinate = geometry.coordinate;
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textShape = findLabelTextShape(label);
    if (coordinate.isTransposed) {
      textShape.attr({
        x: shapeBBox.minX + shapeBBox.width / 2,
        textAlign: "center"
      });
    } else {
      textShape.attr({
        y: shapeBBox.minY + shapeBBox.height / 2,
        textBaseline: "middle"
      });
    }
  }
  function intervalAdjustPosition(items, labels, shapes) {
    var _a4;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== "interval") {
      return;
    }
    var inShape = shouldInShape(geometry, labels, shapes);
    if (inShape) {
      shapes.forEach(function(shape, index) {
        var label = labels[index];
        moveInShape(geometry, label, shape);
      });
    }
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/interval/hide-overlap.js
  function filterLabel(labels) {
    var MAX_CNT = 500;
    var filteredLabels = [];
    var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
    each_default(labels, function(label, idx) {
      if (idx % pages === 0) {
        filteredLabels.push(label);
      } else {
        label.set("visible", false);
      }
    });
    return filteredLabels;
  }
  function intervalHideOverlap(items, labels, shapes) {
    var _a4;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== "interval") {
      return;
    }
    var filteredLabels = filterLabel(labels);
    var xField = geometry.getXYFields()[0];
    var dones = [];
    var todo = [];
    var groupedLabels = group_by_default(filteredLabels, function(label) {
      return label.get("data")[xField];
    });
    var xValues = uniq(map_default(filteredLabels, function(label) {
      return label.get("data")[xField];
    }));
    var xValue;
    filteredLabels.forEach(function(label) {
      label.set("visible", true);
    });
    var addCurrentGroup = function(curItems) {
      if (curItems) {
        if (curItems.length) {
          todo.push(curItems.pop());
        }
        todo.push.apply(todo, curItems);
      }
    };
    if (size2(xValues) > 0) {
      xValue = xValues.shift();
      addCurrentGroup(groupedLabels[xValue]);
    }
    if (size2(xValues) > 0) {
      xValue = xValues.pop();
      addCurrentGroup(groupedLabels[xValue]);
    }
    each_default(xValues.reverse(), function(val) {
      addCurrentGroup(groupedLabels[val]);
    });
    while (todo.length > 0) {
      var cur = todo.shift();
      if (cur.get("visible")) {
        if (checkShapeOverlap(cur, dones)) {
          cur.set("visible", false);
        } else {
          dones.push(cur);
        }
      }
    }
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js
  function sortLabels(geometry, labels) {
    var yField = geometry.getXYFields()[1];
    var result = [];
    var sortedLabels = labels.sort(function(left, right) {
      return left.get("data")[yField] - left.get("data")[yField];
    });
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.shift());
    }
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.pop());
    }
    result.push.apply(result, sortedLabels);
    return result;
  }
  function hasSome(dones, current, compare) {
    return dones.some(function(done) {
      return compare(done, current);
    });
  }
  function getOverlapArea2(a, b, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
  }
  function checkShapeOverlap2(dones, current) {
    return hasSome(dones, current, function(left, right) {
      var leftText = findLabelTextShape(left);
      var rightText = findLabelTextShape(right);
      return getOverlapArea2(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
    });
  }
  function pointAdjustPosition(items, labels, shapes, region, cfg) {
    var _a4, _b;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== "point") {
      return;
    }
    var _c = geometry.getXYFields(), xField = _c[0], yField = _c[1];
    var groupedLabels = group_by_default(labels, function(label) {
      return label.get("data")[xField];
    });
    var dones = [];
    var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
    map_default(keys_default(groupedLabels).reverse(), function(xValue) {
      var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);
      while (sortedCollections.length) {
        var current = sortedCollections.shift();
        var textShape = findLabelTextShape(current);
        if (hasSome(dones, current, function(left, right) {
          return left.get("data")[xField] === right.get("data")[xField] && left.get("data")[yField] === right.get("data")[yField];
        })) {
          textShape.set("visible", false);
          continue;
        }
        var upFail = checkShapeOverlap2(dones, current);
        var downFail = false;
        if (upFail) {
          textShape.attr("y", textShape.attr("y") + 2 * offset);
          downFail = checkShapeOverlap2(dones, current);
        }
        if (downFail) {
          textShape.set("visible", false);
          continue;
        }
        dones.push(current);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/path/adjust-position.js
  function sortLabels2(geometry, labels) {
    var yField = geometry.getXYFields()[1];
    var result = [];
    var sortedLabels = labels.sort(function(left, right) {
      return left.get("data")[yField] - left.get("data")[yField];
    });
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.shift());
    }
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.pop());
    }
    result.push.apply(result, sortedLabels);
    return result;
  }
  function hasSome2(dones, current, compare) {
    return dones.some(function(done) {
      return compare(done, current);
    });
  }
  function getOverlapArea3(a, b, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
  }
  function checkShapeOverlap3(dones, current) {
    return hasSome2(dones, current, function(left, right) {
      var leftText = findLabelTextShape(left);
      var rightText = findLabelTextShape(right);
      return getOverlapArea3(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
    });
  }
  function pathAdjustPosition(items, labels, shapes, region, cfg) {
    var _a4, _b;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || ["path", "line", "area"].indexOf(geometry.type) < 0) {
      return;
    }
    var _c = geometry.getXYFields(), xField = _c[0], yField = _c[1];
    var groupedLabels = group_by_default(labels, function(label) {
      return label.get("data")[xField];
    });
    var dones = [];
    var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
    map_default(keys_default(groupedLabels).reverse(), function(xValue) {
      var sortedCollections = sortLabels2(geometry, groupedLabels[xValue]);
      while (sortedCollections.length) {
        var current = sortedCollections.shift();
        var textShape = findLabelTextShape(current);
        if (hasSome2(dones, current, function(left, right) {
          return left.get("data")[xField] === right.get("data")[xField] && left.get("data")[yField] === right.get("data")[yField];
        })) {
          textShape.set("visible", false);
          continue;
        }
        var upFail = checkShapeOverlap3(dones, current);
        var downFail = false;
        if (upFail) {
          textShape.attr("y", textShape.attr("y") + 2 * offset);
          downFail = checkShapeOverlap3(dones, current);
        }
        if (downFail) {
          textShape.set("visible", false);
          continue;
        }
        dones.push(current);
      }
    });
  }

  // node_modules/@antv/g2/esm/util/context.js
  var ctx2;
  function getCanvasContext() {
    if (!ctx2) {
      ctx2 = document.createElement("canvas").getContext("2d");
    }
    return ctx2;
  }

  // node_modules/@antv/g2/esm/util/text.js
  var measureTextWidth = memoize_default(function(text, font) {
    if (font === void 0) {
      font = {};
    }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    var ctx3 = getCanvasContext();
    ctx3.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
    return ctx3.measureText(is_string_default(text) ? text : "").width;
  }, function(text, font) {
    if (font === void 0) {
      font = {};
    }
    return __spreadArray([text], values_default(font), true).join("");
  });
  var getEllipsisText = function(text, maxWidth, font) {
    var STEP = 16;
    var DOT_WIDTH = measureTextWidth("...", font);
    var leftText;
    if (!is_string_default(text)) {
      leftText = to_string_default(text);
    } else {
      leftText = text;
    }
    var leftWidth = maxWidth;
    var r = [];
    var currentText;
    var currentWidth;
    if (measureTextWidth(text, font) <= maxWidth) {
      return text;
    }
    while (true) {
      currentText = leftText.substr(0, STEP);
      currentWidth = measureTextWidth(currentText, font);
      if (currentWidth + DOT_WIDTH > leftWidth) {
        if (currentWidth > leftWidth) {
          break;
        }
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(STEP);
      if (!leftText) {
        return r.join("");
      }
    }
    while (true) {
      currentText = leftText.substr(0, 1);
      currentWidth = measureTextWidth(currentText, font);
      if (currentWidth + DOT_WIDTH > leftWidth) {
        break;
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(1);
      if (!leftText) {
        return r.join("");
      }
    }
    return r.join("") + "...";
  };

  // node_modules/@antv/g2/esm/geometry/label/layout/limit-in-plot.js
  function limitInPlot(items, labels, shapes, region, cfg) {
    if (labels.length <= 0) {
      return;
    }
    var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
    var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
    var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
    var coordinate = labels[0].get("coordinate");
    if (!coordinate) {
      return;
    }
    var _a4 = getCoordinateBBox(coordinate, margin), regionMinX = _a4.minX, regionMinY = _a4.minY, regionMaxX = _a4.maxX, regionMaxY = _a4.maxY;
    each_default(labels, function(label) {
      var _a5 = label.getCanvasBBox(), minX = _a5.minX, minY = _a5.minY, maxX = _a5.maxX, maxY = _a5.maxY, x = _a5.x, y = _a5.y, width = _a5.width, height = _a5.height;
      var finalX = x;
      var finalY = y;
      if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
        finalX = regionMinX;
      }
      if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY < regionMinY)) {
        finalY = regionMinY;
      }
      if (direction2.indexOf("right") >= 0) {
        if (minX > regionMaxX) {
          finalX = regionMaxX - width;
        } else if (maxX > regionMaxX) {
          finalX = finalX - (maxX - regionMaxX);
        }
      }
      if (direction2.indexOf("bottom") >= 0) {
        if (minY > regionMaxY) {
          finalY = regionMaxY - height;
        } else if (maxY > regionMaxY) {
          finalY = finalY - (maxY - regionMaxY);
        }
      }
      if (finalX !== x || finalY !== y) {
        var translateX_1 = finalX - x;
        if (action === "translate") {
          translate2(label, translateX_1, finalY - y);
        } else if (action === "ellipsis") {
          var textShapes = label.findAll(function(shape) {
            return shape.get("type") === "text";
          });
          textShapes.forEach(function(textShape) {
            var style = pick_default(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
            var textBox = textShape.getCanvasBBox();
            var text = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
            textShape.attr("text", text);
          });
        } else {
          label.hide();
        }
      }
    });
  }

  // node_modules/@antv/g2/esm/animate/animation/fade.js
  function fadeIn(shape, animateCfg, cfg) {
    var endState = {
      fillOpacity: is_nil_default(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
      strokeOpacity: is_nil_default(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
      opacity: is_nil_default(shape.attr("opacity")) ? 1 : shape.attr("opacity")
    };
    shape.attr({
      fillOpacity: 0,
      strokeOpacity: 0,
      opacity: 0
    });
    shape.animate(endState, animateCfg);
  }
  function fadeOut(shape, animateCfg, cfg) {
    var endState = {
      fillOpacity: 0,
      strokeOpacity: 0,
      opacity: 0
    };
    var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
    shape.animate(endState, duration, easing, function() {
      shape.remove(true);
    }, delay);
  }

  // node_modules/@antv/g2/esm/animate/animation/util.js
  function transformShape(shape, vector, direct) {
    var scaledMatrix;
    var x = vector[0], y = vector[1];
    shape.applyToMatrix([x, y, 1]);
    if (direct === "x") {
      shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 1],
        ["t", x, y]
      ]));
      scaledMatrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 100, 1],
        ["t", x, y]
      ]);
    } else if (direct === "y") {
      shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 1, 0.01],
        ["t", x, y]
      ]));
      scaledMatrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 1, 100],
        ["t", x, y]
      ]);
    } else if (direct === "xy") {
      shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 0.01],
        ["t", x, y]
      ]));
      scaledMatrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 100, 100],
        ["t", x, y]
      ]);
    }
    return scaledMatrix;
  }
  function doScaleAnimate(element, animateCfg, coordinate, yMinPoint, type) {
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var x;
    var y;
    if (type === "y") {
      x = start.x + width / 2;
      y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
    } else if (type === "x") {
      x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
      y = start.y + height / 2;
    } else if (type === "xy") {
      if (coordinate.isPolar) {
        x = coordinate.getCenter().x;
        y = coordinate.getCenter().y;
      } else {
        x = (start.x + end.x) / 2;
        y = (start.y + end.y) / 2;
      }
    }
    var endMatrix = transformShape(element, [x, y], type);
    element.animate({
      matrix: endMatrix
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/grow-in.js
  function growInX(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, "x");
  }
  function growInY(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, "y");
  }
  function growInXY(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, "xy");
  }

  // node_modules/@antv/g2/esm/animate/animation/path-in.js
  function pathIn(element, animateCfg, cfg) {
    var length3 = element.getTotalLength();
    element.attr("lineDash", [length3]);
    element.animate(function(ratio) {
      return {
        lineDashOffset: (1 - ratio) * length3
      };
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/position-update.js
  function positionUpdate(shape, animateCfg, cfg) {
    var toAttrs = cfg.toAttrs;
    var x = toAttrs.x;
    var y = toAttrs.y;
    delete toAttrs.x;
    delete toAttrs.y;
    shape.attr(toAttrs);
    shape.animate({
      x,
      y
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/scale-in.js
  function scaleInX(shape, animateCfg, cfg) {
    var box2 = shape.getBBox();
    var mappingData = shape.get("origin").mappingData;
    var points = mappingData.points;
    var x = points[0].y - points[1].y > 0 ? box2.maxX : box2.minX;
    var y = (box2.minY + box2.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    var matrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 1],
      ["t", x, y]
    ]);
    shape.setMatrix(matrix);
    shape.animate({
      matrix: ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 100, 1],
        ["t", x, y]
      ])
    }, animateCfg);
  }
  function scaleInY(shape, animateCfg, cfg) {
    var box2 = shape.getBBox();
    var mappingData = shape.get("origin").mappingData;
    var x = (box2.minX + box2.maxX) / 2;
    var points = mappingData.points;
    var y = points[0].y - points[1].y <= 0 ? box2.maxY : box2.minY;
    shape.applyToMatrix([x, y, 1]);
    var matrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 0.01],
      ["t", x, y]
    ]);
    shape.setMatrix(matrix);
    shape.animate({
      matrix: ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 1, 100],
        ["t", x, y]
      ])
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/sector-path-update.js
  function getAngle3(startPoint, arcPath) {
    var _a4;
    var _b = getArcParams2(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
      startAngle += Math.PI * 2;
    }
    if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
      endAngle += Math.PI * 2;
    }
    if (arcPath[5] === 0) {
      _a4 = [endAngle, startAngle], startAngle = _a4[0], endAngle = _a4[1];
    }
    if (isNumberEqual(startAngle, Math.PI * 1.5)) {
      startAngle = Math.PI * -0.5;
    }
    if (isNumberEqual(endAngle, Math.PI * -0.5)) {
      endAngle = Math.PI * 1.5;
    }
    return {
      startAngle,
      endAngle
    };
  }
  function getArcStartPoint(path) {
    var startPoint;
    if (path[0] === "M" || path[0] === "L") {
      startPoint = [path[1], path[2]];
    } else if (path[0] === "a" || path[0] === "A" || path[0] === "C") {
      startPoint = [path[path.length - 2], path[path.length - 1]];
    }
    return startPoint;
  }
  function getArcInfo(path) {
    var _a4;
    var startAngle;
    var endAngle;
    var arcPaths = path.filter(function(command) {
      return command[0] === "A" || command[0] === "a";
    });
    if (arcPaths.length === 0) {
      return {
        startAngle: 0,
        endAngle: 0,
        radius: 0,
        innerRadius: 0
      };
    }
    var firstArcPathCommand = arcPaths[0];
    var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
    var firstIndex = path.indexOf(firstArcPathCommand);
    var lastIndex = path.indexOf(lastArcPathCommand);
    var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
    var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
    var _b = getAngle3(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
    var _c = getAngle3(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
    if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {
      startAngle = firstStartAngle;
      endAngle = firstEndAngle;
    } else {
      startAngle = Math.min(firstStartAngle, lastStartAngle);
      endAngle = Math.max(firstEndAngle, lastEndAngle);
    }
    var radius = firstArcPathCommand[1];
    var innerRadius = arcPaths[arcPaths.length - 1][1];
    if (radius < innerRadius) {
      _a4 = [innerRadius, radius], radius = _a4[0], innerRadius = _a4[1];
    } else if (radius === innerRadius) {
      innerRadius = 0;
    }
    return {
      startAngle,
      endAngle,
      radius,
      innerRadius
    };
  }
  function sectorPathUpdate(shape, animateCfg, cfg) {
    var toAttrs = cfg.toAttrs, coordinate = cfg.coordinate;
    var path = toAttrs.path || [];
    var pathCommands = path.map(function(command) {
      return command[0];
    });
    if (path.length < 1)
      return;
    var _a4 = getArcInfo(path), curStartAngle = _a4.startAngle, curEndAngle = _a4.endAngle, radius = _a4.radius, innerRadius = _a4.innerRadius;
    var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
    var center = coordinate.getCenter();
    var diffStartAngle = curStartAngle - preStartAngle;
    var diffEndAngle = curEndAngle - preEndAngle;
    if (diffStartAngle === 0 && diffEndAngle === 0) {
      shape.attr("path", path);
      return;
    }
    shape.animate(function(ratio) {
      var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
      var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
      return __assign(__assign({}, toAttrs), { path: is_equal_default(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
    }, __assign(__assign({}, animateCfg), { callback: function() {
      shape.attr("path", path);
    } }));
  }

  // node_modules/@antv/g2/esm/animate/animation/wave-in.js
  function waveIn(element, animateCfg, cfg) {
    var _a4 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a4.type, startState = _a4.startState, endState = _a4.endState;
    var clipShape = element.setClip({
      type,
      attrs: startState
    });
    clipShape.animate(endState, __assign(__assign({}, animateCfg), { callback: function() {
      if (element && !element.get("destroyed")) {
        element.set("clipShape", null);
      }
      clipShape.remove(true);
    } }));
  }

  // node_modules/@antv/g2/esm/animate/animation/zoom.js
  function doShapeZoom(shape, animateCfg, type) {
    if (shape.isGroup()) {
      each_default(shape.getChildren(), function(child) {
        doShapeZoom(child, animateCfg, type);
      });
    } else {
      var bbox = shape.getBBox();
      var x = (bbox.minX + bbox.maxX) / 2;
      var y = (bbox.minY + bbox.maxY) / 2;
      shape.applyToMatrix([x, y, 1]);
      if (type === "zoomIn") {
        var matrix = ext_exports.transform(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 0.01, 0.01],
          ["t", x, y]
        ]);
        shape.setMatrix(matrix);
        shape.animate({
          matrix: ext_exports.transform(shape.getMatrix(), [
            ["t", -x, -y],
            ["s", 100, 100],
            ["t", x, y]
          ])
        }, animateCfg);
      } else {
        shape.animate({
          matrix: ext_exports.transform(shape.getMatrix(), [
            ["t", -x, -y],
            ["s", 0.01, 0.01],
            ["t", x, y]
          ])
        }, __assign(__assign({}, animateCfg), { callback: function() {
          shape.remove(true);
        } }));
      }
    }
  }
  function zoomIn(shape, animateCfg, cfg) {
    doShapeZoom(shape, animateCfg, "zoomIn");
  }
  function zoomOut(shape, animateCfg, cfg) {
    doShapeZoom(shape, animateCfg, "zoomOut");
  }

  // node_modules/@antv/g2/esm/util/facet.js
  function getFactTitleConfig(direction2) {
    if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
      return {
        offsetX: 0,
        offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
        style: {
          textAlign: "center",
          textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
        }
      };
    }
    if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
      return {
        offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
        offsetY: 0,
        style: {
          textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
          textBaseline: "middle",
          rotate: Math.PI / 2
        }
      };
    }
    return {};
  }
  function getAnglePoint(center, r, angle3) {
    return {
      x: center.x + r * Math.cos(angle3),
      y: center.y + r * Math.sin(angle3)
    };
  }

  // node_modules/@antv/g2/esm/facet/circle.js
  var Circle5 = function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "circle",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Circle6.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Circle6.prototype.getRegion = function(count, index) {
      var r = 1 / 2;
      var center = { x: 0.5, y: 0.5 };
      var avgAngle = Math.PI * 2 / count;
      var angle3 = -1 * Math.PI / 2 + avgAngle * index;
      var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
      var middle = getAnglePoint(center, r - facetR, angle3);
      var startAngle = Math.PI * 5 / 4;
      var endAngle = Math.PI * 1 / 4;
      return {
        start: getAnglePoint(middle, facetR, startAngle),
        end: getAnglePoint(middle, facetR, endAngle)
      };
    };
    Circle6.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Circle6.prototype.beforeEachView = function(view, facet) {
    };
    Circle6.prototype.generateFacets = function(data) {
      var _this = this;
      var _a4 = this.cfg, fields = _a4.fields, type = _a4.type;
      var field = fields[0];
      if (!field) {
        throw new Error("No `fields` specified!");
      }
      var values2 = this.getFieldValues(data, field);
      var count = values2.length;
      var rst = [];
      values2.forEach(function(value, index) {
        var conditions = [{ field, value, values: values2 }];
        var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type,
          data: facetData,
          region: _this.getRegion(count, index),
          columnValue: value,
          columnField: field,
          columnIndex: index,
          columnValuesLength: count,
          rowValue: null,
          rowField: null,
          rowIndex: 0,
          rowValuesLength: 1
        };
        rst.push(facet);
      });
      return rst;
    };
    Circle6.prototype.getXAxisOption = function(x, axes, option, facet) {
      return option;
    };
    Circle6.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Circle6.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    return Circle6;
  }(Facet);
  var circle_default8 = Circle5;

  // node_modules/@antv/g2/esm/facet/list.js
  var List = function(_super) {
    __extends(List2, _super);
    function List2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    List2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "list",
        cols: null,
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    List2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    List2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    List2.prototype.beforeEachView = function(view, facet) {
    };
    List2.prototype.generateFacets = function(data) {
      var _this = this;
      var fields = this.cfg.fields;
      var cols = this.cfg.cols;
      var columnField = fields[0];
      if (!columnField) {
        throw new Error("No `fields` specified!");
      }
      var colValues = this.getFieldValues(data, columnField);
      var count = colValues.length;
      cols = cols || count;
      var rows = this.getPageCount(count, cols);
      var rst = [];
      colValues.forEach(function(val, index) {
        var _a4 = _this.getRowCol(index, cols), row = _a4.row, col = _a4.col;
        var conditions = [{ field: columnField, value: val, values: colValues }];
        var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rows, cols, col, row),
          columnValue: val,
          rowValue: val,
          columnField,
          rowField: null,
          columnIndex: col,
          rowIndex: row,
          columnValuesLength: cols,
          rowValuesLength: rows,
          total: count
        };
        rst.push(facet);
      });
      return rst;
    };
    List2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    List2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    List2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    List2.prototype.getPageCount = function(total, pageSize) {
      return Math.floor((total + pageSize - 1) / pageSize);
    };
    List2.prototype.getRowCol = function(index, pageSize) {
      var row = Math.floor(index / pageSize);
      var col = index % pageSize;
      return { row, col };
    };
    return List2;
  }(Facet);
  var list_default = List;

  // node_modules/@antv/g2/esm/facet/matrix.js
  var Matrix = function(_super) {
    __extends(Matrix2, _super);
    function Matrix2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Matrix2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "matrix",
        showTitle: false,
        columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Matrix2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Matrix2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Matrix2.prototype.beforeEachView = function(view, facet) {
    };
    Matrix2.prototype.generateFacets = function(data) {
      var _a4 = this.cfg, fields = _a4.fields, type = _a4.type;
      var rowValuesLength = fields.length;
      var columnValuesLength = rowValuesLength;
      var rst = [];
      for (var i = 0; i < columnValuesLength; i++) {
        var columnField = fields[i];
        for (var j = 0; j < rowValuesLength; j++) {
          var rowField = fields[j];
          var facet = {
            type,
            data,
            region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
            columnValue: columnField,
            rowValue: rowField,
            columnField,
            rowField,
            columnIndex: i,
            rowIndex: j,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        }
      }
      return rst;
    };
    Matrix2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    Matrix2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    Matrix2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, rowValuesLength = facet.rowValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get_default(_this.cfg.columnTitle, "formatter");
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get_default(_this.cfg.rowTitle, "formatter");
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    return Matrix2;
  }(Facet);
  var matrix_default = Matrix;

  // node_modules/@antv/g2/esm/facet/mirror.js
  var Mirror = function(_super) {
    __extends(Mirror2, _super);
    function Mirror2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Mirror2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "mirror",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this),
        transpose: false
      });
    };
    Mirror2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Mirror2.prototype.beforeEachView = function(view, facet) {
      if (this.cfg.transpose) {
        if (facet.columnIndex % 2 === 0) {
          view.coordinate().transpose().reflect("x");
        } else {
          view.coordinate().transpose();
        }
      } else {
        if (facet.rowIndex % 2 !== 0) {
          view.coordinate().reflect("y");
        }
      }
    };
    Mirror2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Mirror2.prototype.generateFacets = function(data) {
      var _this = this;
      var f = this.cfg.fields[0];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      var columnField;
      var rowField;
      if (this.cfg.transpose) {
        columnField = f;
        columnValues = this.getFieldValues(data, columnField).slice(0, 2);
        columnValuesLength = columnValues.length;
      } else {
        rowField = f;
        rowValues = this.getFieldValues(data, rowField).slice(0, 2);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Mirror2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.columnIndex === 1 || facet.rowIndex === 1) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    Mirror2.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Mirror2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        if (_this.cfg.transpose) {
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
          view.annotation().text(config);
        } else {
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
          view.annotation().text(config);
        }
      });
    };
    return Mirror2;
  }(Facet);
  var mirror_default = Mirror;

  // node_modules/@antv/g2/esm/facet/rect.js
  var Rect3 = function(_super) {
    __extends(Rect4, _super);
    function Rect4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect4.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Rect4.prototype.beforeEachView = function(view, facet) {
    };
    Rect4.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "rect",
        columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Rect4.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Rect4.prototype.generateFacets = function(data) {
      var _this = this;
      var _a4 = this.cfg.fields, columnField = _a4[0], rowField = _a4[1];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      if (columnField) {
        columnValues = this.getFieldValues(data, columnField);
        columnValuesLength = columnValues.length;
      }
      if (rowField) {
        rowValues = this.getFieldValues(data, rowField);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Rect4.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get_default(_this.cfg.columnTitle, "formatter");
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get_default(_this.cfg.rowTitle, "formatter");
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    Rect4.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { title: null, label: null });
      } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
        return __assign(__assign({}, option), { title: null });
      }
      return option;
    };
    Rect4.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
        return __assign(__assign({}, option), { title: null });
      }
      return option;
    };
    return Rect4;
  }(Facet);
  var rect_default5 = Rect3;

  // node_modules/@antv/g2/esm/facet/tree.js
  var Tree = function(_super) {
    __extends(Tree2, _super);
    function Tree2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.afterChartRender = function() {
        if (_this.facets && _this.cfg.line) {
          _this.container.clear();
          _this.drawLines(_this.facets);
        }
      };
      return _this;
    }
    Tree2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Tree2.prototype.beforeEachView = function(view, facet) {
    };
    Tree2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
    };
    Tree2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "tree",
        line: {
          style: {
            lineWidth: 1,
            stroke: "#ddd"
          },
          smooth: false
        },
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Tree2.prototype.generateFacets = function(data) {
      var fields = this.cfg.fields;
      if (!fields.length) {
        throw new Error("Please specify for the fields for rootFacet!");
      }
      var rst = [];
      var rootFacet = {
        type: this.cfg.type,
        data,
        region: null,
        rowValuesLength: this.getRows(),
        columnValuesLength: 1,
        rowIndex: 0,
        columnIndex: 0,
        rowField: "",
        columnField: "",
        rowValue: "",
        columnValue: ""
      };
      rst.push(rootFacet);
      rootFacet.children = this.getChildFacets(data, 1, rst);
      this.setRegion(rst);
      return rst;
    };
    Tree2.prototype.setRegion = function(facets) {
      var _this = this;
      this.forceColIndex(facets);
      facets.forEach(function(facet) {
        facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
      });
    };
    Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var xWidth = 1 / cols;
      var yWidth = 1 / rows;
      var start = {
        x: xWidth * xIndex,
        y: yWidth * yIndex
      };
      var end = {
        x: start.x + xWidth,
        y: start.y + yWidth * 2 / 3
      };
      return {
        start,
        end
      };
    };
    Tree2.prototype.forceColIndex = function(facets) {
      var _this = this;
      var leafs = [];
      var index = 0;
      facets.forEach(function(facet2) {
        if (_this.isLeaf(facet2)) {
          leafs.push(facet2);
          facet2.columnIndex = index;
          index++;
        }
      });
      leafs.forEach(function(facet2) {
        facet2.columnValuesLength = leafs.length;
      });
      var maxLevel = this.cfg.fields.length;
      for (var i = maxLevel - 1; i >= 0; i--) {
        var levelFacets = this.getFacetsByLevel(facets, i);
        for (var _i = 0, levelFacets_1 = levelFacets; _i < levelFacets_1.length; _i++) {
          var facet = levelFacets_1[_i];
          if (!this.isLeaf(facet)) {
            facet.originColIndex = facet.columnIndex;
            facet.columnIndex = this.getRegionIndex(facet.children);
            facet.columnValuesLength = leafs.length;
          }
        }
      }
    };
    Tree2.prototype.getFacetsByLevel = function(facets, level) {
      var rst = [];
      facets.forEach(function(facet) {
        if (facet.rowIndex === level) {
          rst.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.getRegionIndex = function(children) {
      var first = children[0];
      var last2 = children[children.length - 1];
      return (last2.columnIndex - first.columnIndex) / 2 + first.columnIndex;
    };
    Tree2.prototype.isLeaf = function(facet) {
      return !facet.children || !facet.children.length;
    };
    Tree2.prototype.getRows = function() {
      return this.cfg.fields.length + 1;
    };
    Tree2.prototype.getChildFacets = function(data, level, arr) {
      var _this = this;
      var fields = this.cfg.fields;
      var length3 = fields.length;
      if (length3 < level) {
        return;
      }
      var rst = [];
      var field = fields[level - 1];
      var values2 = this.getFieldValues(data, field);
      values2.forEach(function(value, index) {
        var conditions = [{ field, value, values: values2 }];
        var subData = data.filter(_this.getFacetDataFilter(conditions));
        if (subData.length) {
          var facet = {
            type: _this.cfg.type,
            data: subData,
            region: null,
            columnValue: value,
            rowValue: "",
            columnField: field,
            rowField: "",
            columnIndex: index,
            rowValuesLength: _this.getRows(),
            columnValuesLength: 1,
            rowIndex: level,
            children: _this.getChildFacets(subData, level + 1, arr)
          };
          rst.push(facet);
          arr.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Tree2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    Tree2.prototype.drawLines = function(facets) {
      var _this = this;
      facets.forEach(function(facet) {
        if (!_this.isLeaf(facet)) {
          var children = facet.children;
          _this.addFacetLines(facet, children);
        }
      });
    };
    Tree2.prototype.addFacetLines = function(facet, children) {
      var _this = this;
      var view = facet.view;
      var region = view.coordinateBBox;
      var start = {
        x: region.x + region.width / 2,
        y: region.y + region.height
      };
      children.forEach(function(subFacet) {
        var subRegion = subFacet.view.coordinateBBox;
        var end = {
          x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
          y: subRegion.tr.y
        };
        var middle1 = {
          x: start.x,
          y: start.y + (end.y - start.y) / 2
        };
        var middle2 = {
          x: end.x,
          y: middle1.y
        };
        _this.drawLine([start, middle1, middle2, end]);
      });
    };
    Tree2.prototype.getPath = function(points) {
      var path = [];
      var smooth = this.cfg.line.smooth;
      if (smooth) {
        path.push(["M", points[0].x, points[0].y]);
        path.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
      } else {
        points.forEach(function(point, index) {
          if (index === 0) {
            path.push(["M", point.x, point.y]);
          } else {
            path.push(["L", point.x, point.y]);
          }
        });
      }
      return path;
    };
    Tree2.prototype.drawLine = function(points) {
      var path = this.getPath(points);
      var line = this.cfg.line.style;
      this.container.addShape("path", {
        attrs: mix({
          path
        }, line)
      });
    };
    Tree2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    Tree2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    return Tree2;
  }(Facet);
  var tree_default = Tree;

  // node_modules/@antv/g2/esm/util/stat.js
  function getMedian(array) {
    var arr = __spreadArray([], array, true);
    arr.sort(function(a, b) {
      return a - b;
    });
    var len3 = arr.length;
    if (len3 === 0) {
      return 0;
    }
    if (len3 % 2 === 1) {
      return arr[(len3 - 1) / 2];
    }
    return (arr[len3 / 2] + arr[len3 / 2 - 1]) / 2;
  }
  function getMean(array) {
    var sum = reduce_default(array, function(r, num) {
      return r += isNaN(num) || !is_number_default(num) ? 0 : num;
    }, 0);
    return array.length === 0 ? 0 : sum / array.length;
  }

  // node_modules/@antv/g2/esm/util/annotation.js
  function getNormalizedValue(val, scale4) {
    if (!scale4) {
      return null;
    }
    var scaled;
    switch (val) {
      case "start":
        return 0;
      case "center":
        return 0.5;
      case "end":
        return 1;
      case "median": {
        scaled = scale4.isCategory ? getMedian(scale4.values.map(function(_6, idx) {
          return idx;
        })) : getMedian(scale4.values);
        break;
      }
      case "mean": {
        scaled = scale4.isCategory ? (scale4.values.length - 1) / 2 : getMean(scale4.values);
        break;
      }
      case "min":
        scaled = scale4.isCategory ? 0 : scale4[val];
        break;
      case "max":
        scaled = scale4.isCategory ? scale4.values.length - 1 : scale4[val];
        break;
      default:
        scaled = val;
        break;
    }
    return scale4.scale(scaled);
  }

  // node_modules/@antv/g2/esm/chart/controller/annotation.js
  var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
  var Annotation = function(_super) {
    __extends(Annotation2, _super);
    function Annotation2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = new Map();
      _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.option = [];
      return _this;
    }
    Object.defineProperty(Annotation2.prototype, "name", {
      get: function() {
        return "annotation";
      },
      enumerable: false,
      configurable: true
    });
    Annotation2.prototype.init = function() {
    };
    Annotation2.prototype.layout = function() {
      this.update();
    };
    Annotation2.prototype.render = function() {
    };
    Annotation2.prototype.update = function() {
      var _this = this;
      this.onAfterRender(function() {
        var updated = new Map();
        each_default(_this.option, function(option) {
          if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
            var co = _this.updateOrCreate(option);
            if (co) {
              updated.set(_this.getCacheKey(option), co);
            }
          }
        });
        _this.cache = _this.syncCache(updated);
      });
      var updateCache = new Map();
      each_default(this.option, function(option) {
        if (!contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updateCache.set(_this.getCacheKey(option), co);
          }
        }
      });
      this.cache = this.syncCache(updateCache);
    };
    Annotation2.prototype.clear = function(includeOption) {
      if (includeOption === void 0) {
        includeOption = false;
      }
      _super.prototype.clear.call(this);
      this.clearComponents();
      this.foregroundContainer.clear();
      this.backgroundContainer.clear();
      if (includeOption) {
        this.option = [];
      }
    };
    Annotation2.prototype.destroy = function() {
      this.clear(true);
      this.foregroundContainer.remove(true);
      this.backgroundContainer.remove(true);
    };
    Annotation2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value) {
        co.push(value);
      });
      return co;
    };
    Annotation2.prototype.clearComponents = function() {
      this.getComponents().forEach(function(co) {
        co.component.destroy();
      });
      this.cache.clear();
    };
    Annotation2.prototype.onAfterRender = function(doWhat) {
      if (this.view.getOptions().animate) {
        this.view.geometries.forEach(function(g) {
          if (g.animateOption) {
            g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
              doWhat();
            });
          }
        });
      } else {
        this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
          doWhat();
        });
      }
    };
    Annotation2.prototype.createAnnotation = function(option) {
      var type = option.type;
      var Ctor = annotation_exports[upper_first_default(type)];
      if (Ctor) {
        var theme = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme);
        var annotation = new Ctor(cfg);
        return {
          component: annotation,
          layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.ANNOTATION,
          extra: option
        };
      }
    };
    Annotation2.prototype.annotation = function(option) {
      this.option.push(option);
    };
    Annotation2.prototype.arc = function(option) {
      this.annotation(__assign({ type: "arc" }, option));
      return this;
    };
    Annotation2.prototype.image = function(option) {
      this.annotation(__assign({ type: "image" }, option));
      return this;
    };
    Annotation2.prototype.line = function(option) {
      this.annotation(__assign({ type: "line" }, option));
      return this;
    };
    Annotation2.prototype.region = function(option) {
      this.annotation(__assign({ type: "region" }, option));
      return this;
    };
    Annotation2.prototype.text = function(option) {
      this.annotation(__assign({ type: "text" }, option));
      return this;
    };
    Annotation2.prototype.dataMarker = function(option) {
      this.annotation(__assign({ type: "dataMarker" }, option));
      return this;
    };
    Annotation2.prototype.dataRegion = function(option) {
      this.annotation(__assign({ type: "dataRegion" }, option));
    };
    Annotation2.prototype.regionFilter = function(option) {
      this.annotation(__assign({ type: "regionFilter" }, option));
    };
    Annotation2.prototype.shape = function(option) {
      this.annotation(__assign({ type: "shape" }, option));
    };
    Annotation2.prototype.html = function(option) {
      this.annotation(__assign({ type: "html" }, option));
    };
    Annotation2.prototype.parsePosition = function(p2) {
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var position = is_function_default(p2) ? p2.call(null, xScale, yScales) : p2;
      var x = 0;
      var y = 0;
      if (is_array_default(position)) {
        var xPos = position[0], yPos = position[1];
        if (is_string_default(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
          return this.parsePercentPosition(position);
        }
        x = getNormalizedValue(xPos, xScale);
        y = getNormalizedValue(yPos, Object.values(yScales)[0]);
      } else if (!is_nil_default(position)) {
        for (var _i = 0, _a4 = keys_default(position); _i < _a4.length; _i++) {
          var key = _a4[_i];
          var value = position[key];
          if (key === xScale.field) {
            x = getNormalizedValue(value, xScale);
          }
          if (yScales[key]) {
            y = getNormalizedValue(value, yScales[key]);
          }
        }
      }
      return this.view.getCoordinate().convert({ x, y });
    };
    Annotation2.prototype.getRegionPoints = function(start, end) {
      var _this = this;
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var yScale = Object.values(yScales)[0];
      var xField = xScale.field;
      var viewData = this.view.getData();
      var startXValue = is_array_default(start) ? start[0] : start[xField];
      var endXValue = is_array_default(end) ? end[0] : end[xField];
      var arr = [];
      var startIndex;
      each_default(viewData, function(item, idx) {
        if (item[xField] === startXValue) {
          startIndex = idx;
        }
        if (idx >= startIndex) {
          var point = _this.parsePosition([item[xField], item[yScale.field]]);
          if (point) {
            arr.push(point);
          }
        }
        if (item[xField] === endXValue) {
          return false;
        }
      });
      return arr;
    };
    Annotation2.prototype.parsePercentPosition = function(position) {
      var xPercent = parseFloat(position[0]) / 100;
      var yPercent = parseFloat(position[1]) / 100;
      var coordinate = this.view.getCoordinate();
      var start = coordinate.start, end = coordinate.end;
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      var x = coordinate.getWidth() * xPercent + topLeft.x;
      var y = coordinate.getHeight() * yPercent + topLeft.y;
      return { x, y };
    };
    Annotation2.prototype.getCoordinateBBox = function() {
      var coordinate = this.view.getCoordinate();
      var start = coordinate.start, end = coordinate.end;
      var width = coordinate.getWidth();
      var height = coordinate.getHeight();
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      return {
        x: topLeft.x,
        y: topLeft.y,
        minX: topLeft.x,
        minY: topLeft.y,
        maxX: topLeft.x + width,
        maxY: topLeft.y + height,
        width,
        height
      };
    };
    Annotation2.prototype.getAnnotationCfg = function(type, option, theme) {
      var _this = this;
      var coordinate = this.view.getCoordinate();
      var canvas = this.view.getCanvas();
      var o = {};
      if (is_nil_default(option)) {
        return null;
      }
      if (type === "arc") {
        var _a4 = option, start = _a4.start, end = _a4.end, rest = __rest(_a4, ["start", "end"]);
        var sp = this.parsePosition(start);
        var ep = this.parsePosition(end);
        var startAngle = getAngleByPoint(coordinate, sp);
        var endAngle = getAngleByPoint(coordinate, ep);
        if (startAngle > endAngle) {
          endAngle = Math.PI * 2 + endAngle;
        }
        o = __assign(__assign({}, rest), { center: coordinate.getCenter(), radius: getDistanceToCenter(coordinate, sp), startAngle, endAngle });
      } else if (type === "image") {
        var _b = option, start = _b.start, end = _b.end, rest = __rest(_b, ["start", "end"]);
        o = __assign(__assign({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end), src: option.src });
      } else if (type === "line") {
        var _c = option, start = _c.start, end = _c.end, rest = __rest(_c, ["start", "end"]);
        o = __assign(__assign({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end), text: get_default(option, "text", null) });
      } else if (type === "region") {
        var _d = option, start = _d.start, end = _d.end, rest = __rest(_d, ["start", "end"]);
        o = __assign(__assign({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end) });
      } else if (type === "text") {
        var filteredData = this.view.getData();
        var _e = option, position = _e.position, content = _e.content, rest = __rest(_e, ["position", "content"]);
        var textContent = content;
        if (is_function_default(content)) {
          textContent = content(filteredData);
        }
        o = __assign(__assign(__assign({}, this.parsePosition(position)), rest), { content: textContent });
      } else if (type === "dataMarker") {
        var _f = option, position = _f.position, point = _f.point, line = _f.line, text = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest = __rest(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
        o = __assign(__assign(__assign({}, rest), this.parsePosition(position)), { coordinateBBox: this.getCoordinateBBox(), point, line, text, autoAdjust, direction: direction2 });
      } else if (type === "dataRegion") {
        var _g = option, start = _g.start, end = _g.end, region = _g.region, text = _g.text, lineLength = _g.lineLength, rest = __rest(_g, ["start", "end", "region", "text", "lineLength"]);
        o = __assign(__assign({}, rest), { points: this.getRegionPoints(start, end), region, text, lineLength });
      } else if (type === "regionFilter") {
        var _h = option, start = _h.start, end = _h.end, apply_1 = _h.apply, color2 = _h.color, rest = __rest(_h, ["start", "end", "apply", "color"]);
        var geometries = this.view.geometries;
        var shapes_1 = [];
        var addShapes_1 = function(item) {
          if (!item) {
            return;
          }
          if (item.isGroup()) {
            item.getChildren().forEach(function(child) {
              return addShapes_1(child);
            });
          } else {
            shapes_1.push(item);
          }
        };
        each_default(geometries, function(geom) {
          if (apply_1) {
            if (contains_default(apply_1, geom.type)) {
              each_default(geom.elements, function(elem) {
                addShapes_1(elem.shape);
              });
            }
          } else {
            each_default(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        });
        o = __assign(__assign({}, rest), { color: color2, shapes: shapes_1, start: this.parsePosition(start), end: this.parsePosition(end) });
      } else if (type === "shape") {
        var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
        var wrappedRender = function(container) {
          if (is_function_default(option.render)) {
            return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
          }
        };
        o = __assign(__assign({}, restOptions), { render: wrappedRender });
      } else if (type === "html") {
        var _k = option, html_1 = _k.html, position = _k.position, restOptions = __rest(_k, ["html", "position"]);
        var wrappedHtml = function(container) {
          if (is_function_default(html_1)) {
            return html_1(container, _this.view);
          }
          return html_1;
        };
        o = __assign(__assign(__assign({}, restOptions), this.parsePosition(position)), {
          parent: canvas.get("el").parentNode,
          html: wrappedHtml
        });
      }
      var cfg = deep_mix_default({}, theme, __assign(__assign({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
      if (type !== "html") {
        cfg.container = this.getComponentContainer(cfg);
      }
      cfg.animate = this.view.getOptions().animate && cfg.animate && get_default(option, "animate", cfg.animate);
      cfg.animateOption = deep_mix_default({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
      return cfg;
    };
    Annotation2.prototype.isTop = function(option) {
      return get_default(option, "top", true);
    };
    Annotation2.prototype.getComponentContainer = function(option) {
      return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
    };
    Annotation2.prototype.getAnnotationTheme = function(type) {
      return get_default(this.view.getTheme(), ["components", "annotation", type], {});
    };
    Annotation2.prototype.updateOrCreate = function(option) {
      var co = this.cache.get(this.getCacheKey(option));
      if (co) {
        var type = option.type;
        var theme = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme);
        omit(cfg, ["container"]);
        co.component.update(cfg);
        if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      } else {
        co = this.createAnnotation(option);
        if (co) {
          co.component.init();
          if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
            co.component.render();
          }
        }
      }
      return co;
    };
    Annotation2.prototype.syncCache = function(updated) {
      var _this = this;
      var newCache = new Map(this.cache);
      updated.forEach(function(co, key) {
        newCache.set(key, co);
      });
      newCache.forEach(function(co, key) {
        if (!find_default(_this.option, function(option) {
          return key === _this.getCacheKey(option);
        })) {
          co.component.destroy();
          newCache.delete(key);
        }
      });
      return newCache;
    };
    Annotation2.prototype.getCacheKey = function(option) {
      return option;
    };
    return Annotation2;
  }(Controller);
  var annotation_default = Annotation;

  // node_modules/@antv/g2/esm/util/grid.js
  function getGridThemeCfg(theme, direction2) {
    var axisTheme = deep_mix_default({}, get_default(theme, ["components", "axis", "common"]), get_default(theme, ["components", "axis", direction2]));
    return get_default(axisTheme, ["grid"], {});
  }
  function getLineGridItems(coordinate, scale4, dim, alignTick) {
    var items = [];
    var ticks = scale4.getTicks();
    if (coordinate.isPolar) {
      ticks.push({
        value: 1,
        text: "",
        tickValue: ""
      });
    }
    ticks.reduce(function(preTick, currentTick, currentIndex) {
      var currentValue = currentTick.value;
      if (alignTick) {
        items.push({
          points: [
            coordinate.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
            coordinate.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
          ]
        });
      } else {
        if (currentIndex) {
          var preValue = preTick.value;
          var middleValue = (preValue + currentValue) / 2;
          items.push({
            points: [
              coordinate.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
              coordinate.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
            ]
          });
        }
      }
      return currentTick;
    }, ticks[0]);
    return items;
  }
  function getCircleGridItems(coordinate, xScale, yScale, alignTick, dim) {
    var count = xScale.values.length;
    var items = [];
    var ticks = yScale.getTicks();
    ticks.reduce(function(preTick, currentTick) {
      var preValue = preTick ? preTick.value : currentTick.value;
      var currentValue = currentTick.value;
      var middleValue = (preValue + currentValue) / 2;
      if (dim === "x") {
        items.push({
          points: [
            coordinate.convert({
              x: alignTick ? currentValue : middleValue,
              y: 0
            }),
            coordinate.convert({
              x: alignTick ? currentValue : middleValue,
              y: 1
            })
          ]
        });
      } else {
        items.push({
          points: map_default(Array(count + 1), function(__, idx) {
            return coordinate.convert({
              x: idx / count,
              y: alignTick ? currentValue : middleValue
            });
          })
        });
      }
      return currentTick;
    }, ticks[0]);
    return items;
  }
  function showGrid(axisTheme, axisOption) {
    var userGrid = get_default(axisOption, "grid");
    if (userGrid === null) {
      return false;
    }
    var themeGrid = get_default(axisTheme, "grid");
    return !(userGrid === void 0 && themeGrid === null);
  }

  // node_modules/@antv/g2/esm/chart/controller/axis.js
  var OMIT_CFG = ["container"];
  var AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), { appear: null });
  var Axis = function(_super) {
    __extends(Axis2, _super);
    function Axis2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = new Map();
      _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Axis2.prototype, "name", {
      get: function() {
        return "axis";
      },
      enumerable: false,
      configurable: true
    });
    Axis2.prototype.init = function() {
    };
    Axis2.prototype.render = function() {
      this.update();
    };
    Axis2.prototype.layout = function() {
      var _this = this;
      var coordinate = this.view.getCoordinate();
      each_default(this.getComponents(), function(co) {
        var component = co.component, direction2 = co.direction, type = co.type, extra = co.extra;
        var dim = extra.dim, scale4 = extra.scale, alignTick = extra.alignTick;
        var updated;
        if (type === COMPONENT_TYPE.AXIS) {
          if (coordinate.isPolar) {
            if (dim === "x") {
              updated = coordinate.isTransposed ? getAxisRegion(coordinate, direction2) : getCircleAxisCenterRadius(coordinate);
            } else if (dim === "y") {
              updated = coordinate.isTransposed ? getCircleAxisCenterRadius(coordinate) : getAxisRegion(coordinate, direction2);
            }
          } else {
            updated = getAxisRegion(coordinate, direction2);
          }
        } else if (type === COMPONENT_TYPE.GRID) {
          if (coordinate.isPolar) {
            var items = void 0;
            if (coordinate.isTransposed) {
              items = dim === "x" ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale4, alignTick, dim) : getLineGridItems(coordinate, scale4, dim, alignTick);
            } else {
              items = dim === "x" ? getLineGridItems(coordinate, scale4, dim, alignTick) : getCircleGridItems(coordinate, _this.view.getXScale(), scale4, alignTick, dim);
            }
            updated = {
              items,
              center: _this.view.getCoordinate().getCenter()
            };
          } else {
            updated = { items: getLineGridItems(coordinate, scale4, dim, alignTick) };
          }
        }
        component.update(updated);
      });
    };
    Axis2.prototype.update = function() {
      this.option = this.view.getOptions().axes;
      var updatedCache = new Map();
      this.updateXAxes(updatedCache);
      this.updateYAxes(updatedCache);
      var newCache = new Map();
      this.cache.forEach(function(co, key) {
        if (updatedCache.has(key)) {
          newCache.set(key, co);
        } else {
          co.component.destroy();
        }
      });
      this.cache = newCache;
    };
    Axis2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.cache.clear();
      this.gridContainer.clear();
      this.gridForeContainer.clear();
      this.axisContainer.clear();
      this.axisForeContainer.clear();
    };
    Axis2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.gridContainer.remove(true);
      this.gridForeContainer.remove(true);
      this.axisContainer.remove(true);
      this.axisForeContainer.remove(true);
    };
    Axis2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value) {
        co.push(value);
      });
      return co;
    };
    Axis2.prototype.updateXAxes = function(updatedCache) {
      var scale4 = this.view.getXScale();
      if (!scale4 || scale4.isIdentity) {
        return;
      }
      var xAxisOption = getAxisOption(this.option, scale4.field);
      if (xAxisOption === false) {
        return;
      }
      var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
      var layer = LAYER.BG;
      var dim = "x";
      var coordinate = this.view.getCoordinate();
      var axisId = this.getId("axis", scale4.field);
      var gridId = this.getId("grid", scale4.field);
      if (coordinate.isRect) {
        var axis = this.cache.get(axisId);
        if (axis) {
          var cfg = this.getLineAxisCfg(scale4, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis.component.update(cfg);
          updatedCache.set(axisId, axis);
        } else {
          axis = this.createLineAxis(scale4, xAxisOption, layer, direction2, dim);
          this.cache.set(axisId, axis);
          updatedCache.set(axisId, axis);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = this.getLineGridCfg(scale4, xAxisOption, direction2, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          grid = this.createLineGrid(scale4, xAxisOption, layer, direction2, dim);
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else if (coordinate.isPolar) {
        var axis = this.cache.get(axisId);
        if (axis) {
          var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale4, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale4, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis.component.update(cfg);
          updatedCache.set(axisId, axis);
        } else {
          if (coordinate.isTransposed) {
            if (is_undefined_default(xAxisOption)) {
              return;
            } else {
              axis = this.createLineAxis(scale4, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            axis = this.createCircleAxis(scale4, xAxisOption, layer, direction2, dim);
          }
          this.cache.set(axisId, axis);
          updatedCache.set(axisId, axis);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale4, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale4, xAxisOption, DIRECTION.CIRCLE, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          if (coordinate.isTransposed) {
            if (is_undefined_default(xAxisOption)) {
              return;
            } else {
              grid = this.createCircleGrid(scale4, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            grid = this.createLineGrid(scale4, xAxisOption, layer, DIRECTION.CIRCLE, dim);
          }
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else {
      }
    };
    Axis2.prototype.updateYAxes = function(updatedCache) {
      var _this = this;
      var yScales = this.view.getYScales();
      each_default(yScales, function(scale4, idx) {
        if (!scale4 || scale4.isIdentity) {
          return;
        }
        var field = scale4.field;
        var yAxisOption = getAxisOption(_this.option, field);
        if (yAxisOption !== false) {
          var layer = LAYER.BG;
          var dim = "y";
          var axisId = _this.getId("axis", field);
          var gridId = _this.getId("grid", field);
          var coordinate = _this.view.getCoordinate();
          if (coordinate.isRect) {
            var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
            var axis = _this.cache.get(axisId);
            if (axis) {
              var cfg = _this.getLineAxisCfg(scale4, yAxisOption, direction2);
              omit(cfg, OMIT_CFG);
              axis.component.update(cfg);
              updatedCache.set(axisId, axis);
            } else {
              axis = _this.createLineAxis(scale4, yAxisOption, layer, direction2, dim);
              _this.cache.set(axisId, axis);
              updatedCache.set(axisId, axis);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = _this.getLineGridCfg(scale4, yAxisOption, direction2, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              grid = _this.createLineGrid(scale4, yAxisOption, layer, direction2, dim);
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else if (coordinate.isPolar) {
            var axis = _this.cache.get(axisId);
            if (axis) {
              var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale4, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale4, yAxisOption, DIRECTION.RADIUS);
              omit(cfg, OMIT_CFG);
              axis.component.update(cfg);
              updatedCache.set(axisId, axis);
            } else {
              if (coordinate.isTransposed) {
                if (is_undefined_default(yAxisOption)) {
                  return;
                } else {
                  axis = _this.createCircleAxis(scale4, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                axis = _this.createLineAxis(scale4, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              _this.cache.set(axisId, axis);
              updatedCache.set(axisId, axis);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale4, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale4, yAxisOption, DIRECTION.RADIUS, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              if (coordinate.isTransposed) {
                if (is_undefined_default(yAxisOption)) {
                  return;
                } else {
                  grid = _this.createLineGrid(scale4, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                grid = _this.createCircleGrid(scale4, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else {
          }
        }
      });
    };
    Axis2.prototype.createLineAxis = function(scale4, option, layer, direction2, dim) {
      var axis = {
        component: new LineAxis(this.getLineAxisCfg(scale4, option, direction2)),
        layer,
        direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale4 }
      };
      axis.component.set("field", scale4.field);
      axis.component.init();
      return axis;
    };
    Axis2.prototype.createLineGrid = function(scale4, option, layer, direction2, dim) {
      var cfg = this.getLineGridCfg(scale4, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new LineGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale4,
            alignTick: get_default(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.createCircleAxis = function(scale4, option, layer, direction2, dim) {
      var axis = {
        component: new CircleAxis(this.getCircleAxisCfg(scale4, option, direction2)),
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale4 }
      };
      axis.component.set("field", scale4.field);
      axis.component.init();
      return axis;
    };
    Axis2.prototype.createCircleGrid = function(scale4, option, layer, direction2, dim) {
      var cfg = this.getCircleGridCfg(scale4, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new CircleGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale4,
            alignTick: get_default(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.getLineAxisCfg = function(scale4, axisOption, direction2) {
      var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate = this.view.getCoordinate();
      var region = getAxisRegion(coordinate, direction2);
      var titleText = getAxisTitleText(scale4, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
      var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deep_mix_default(__assign(__assign({ container }, region), { ticks: scale4.getTicks().map(function(tick2) {
        return { id: "" + tick2.tickValue, name: tick2.text, value: tick2.value };
      }), verticalFactor: coordinate.isPolar ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a4 = this.getAnimateCfg(cfg), animate = _a4.animate, animateOption = _a4.animateOption;
      cfg.animateOption = animateOption;
      cfg.animate = animate;
      var isAxisVertical = isVertical(region);
      var verticalLimitLength = get_default(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
      if (verticalLimitLength <= 1) {
        var canvasWidth = this.view.getCanvas().get("width");
        var canvasHeight = this.view.getCanvas().get("height");
        cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
      }
      return cfg;
    };
    Axis2.prototype.getLineGridCfg = function(scale4, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
      var gridCfg = deep_mix_default({
        container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
      }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
      gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale4, dim, get_default(gridCfg, "alignTick", true));
      return gridCfg;
    };
    Axis2.prototype.getCircleAxisCfg = function(scale4, axisOption, direction2) {
      var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate = this.view.getCoordinate();
      var ticks = scale4.getTicks().map(function(tick2) {
        return { id: "" + tick2.tickValue, name: tick2.text, value: tick2.value };
      });
      if (!scale4.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
        ticks.pop();
      }
      var titleText = getAxisTitleText(scale4, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
      var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deep_mix_default(__assign(__assign({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a4 = this.getAnimateCfg(cfg), animate = _a4.animate, animateOption = _a4.animateOption;
      cfg.animate = animate;
      cfg.animateOption = animateOption;
      return cfg;
    };
    Axis2.prototype.getCircleGridCfg = function(scale4, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
      var gridCfg = deep_mix_default({
        container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
        center: this.view.getCoordinate().getCenter()
      }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
      var alignTick = get_default(gridCfg, "alignTick", true);
      var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
      gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale4, alignTick, dim);
      return gridCfg;
    };
    Axis2.prototype.getId = function(name, key) {
      var coordinate = this.view.getCoordinate();
      return name + "-" + key + "-" + coordinate.type;
    };
    Axis2.prototype.getAnimateCfg = function(cfg) {
      return {
        animate: this.view.getOptions().animate && get_default(cfg, "animate"),
        animateOption: cfg && cfg.animateOption ? deep_mix_default({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
      };
    };
    return Axis2;
  }(Controller);
  var axis_default = Axis;

  // node_modules/@antv/g2/esm/util/direction.js
  function directionToPosition(parentBBox, bbox, direction2) {
    if (direction2 === DIRECTION.TOP) {
      return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
    }
    if (direction2 === DIRECTION.BOTTOM) {
      return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
    }
    if (direction2 === DIRECTION.LEFT) {
      return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
    }
    if (direction2 === DIRECTION.RIGHT) {
      return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
    }
    if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
      return [parentBBox.tl.x, parentBBox.tl.y];
    }
    if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
      return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
    }
    if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
      return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
    }
    if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
      return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
    }
    return [0, 0];
  }

  // node_modules/@antv/g2/esm/chart/controller/legend.js
  function getLegendOption(legends, field) {
    if (is_boolean_default(legends)) {
      return legends === false ? false : {};
    }
    return get_default(legends, [field], legends);
  }
  function getDirection(legendOption) {
    return get_default(legendOption, "position", DIRECTION.BOTTOM);
  }
  var Legend = function(_super) {
    __extends(Legend2, _super);
    function Legend2(view) {
      var _this = _super.call(this, view) || this;
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Legend2.prototype, "name", {
      get: function() {
        return "legend";
      },
      enumerable: false,
      configurable: true
    });
    Legend2.prototype.init = function() {
    };
    Legend2.prototype.render = function() {
      this.update();
    };
    Legend2.prototype.layout = function() {
      var _this = this;
      this.layoutBBox = this.view.viewBBox;
      each_default(this.components, function(co) {
        var component = co.component, direction2 = co.direction;
        var layout = getLegendLayout(direction2);
        var maxWidthRatio = component.get("maxWidthRatio");
        var maxHeightRatio = component.get("maxHeightRatio");
        var maxSize = _this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
        var maxWidth = component.get("maxWidth");
        var maxHeight = component.get("maxHeight");
        component.update({
          maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
          maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
        });
        var padding = component.get("padding");
        var bboxObject = component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);
        var _a4 = directionToPosition(_this.view.viewBBox, bbox, direction2), x1 = _a4[0], y1 = _a4[1];
        var _b = directionToPosition(_this.layoutBBox, bbox, direction2), x2 = _b[0], y2 = _b[1];
        var x = 0;
        var y = 0;
        if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
          x = x1;
          y = y2;
        } else {
          x = x2;
          y = y1;
        }
        component.setLocation({ x: x + padding[3], y: y + padding[0] });
        _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
      });
    };
    Legend2.prototype.update = function() {
      var _this = this;
      this.option = this.view.getOptions().legends;
      var updated = {};
      var eachLegend = function(geometry, attr, scale4) {
        var id2 = _this.getId(scale4.field);
        var existCo2 = _this.getComponentById(id2);
        if (existCo2) {
          var cfg = void 0;
          var legendOption = getLegendOption(_this.option, scale4.field);
          if (legendOption !== false) {
            if (get_default(legendOption, "custom")) {
              cfg = _this.getCategoryCfg(geometry, attr, scale4, legendOption, true);
            } else {
              if (scale4.isLinear) {
                cfg = _this.getContinuousCfg(geometry, attr, scale4, legendOption);
              } else if (scale4.isCategory) {
                cfg = _this.getCategoryCfg(geometry, attr, scale4, legendOption);
              }
            }
          }
          if (cfg) {
            omit(cfg, ["container"]);
            existCo2.direction = getDirection(legendOption);
            existCo2.component.update(cfg);
            updated[id2] = true;
          }
        } else {
          var legend = _this.createFieldLegend(geometry, attr, scale4);
          if (legend) {
            legend.component.init();
            _this.components.push(legend);
            updated[id2] = true;
          }
        }
      };
      if (get_default(this.option, "custom")) {
        var id = "global-custom";
        var existCo = this.getComponentById(id);
        if (existCo) {
          var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
          omit(customCfg, ["container"]);
          existCo.component.update(customCfg);
          updated[id] = true;
        } else {
          var component = this.createCustomLegend(void 0, void 0, void 0, this.option);
          if (component) {
            component.init();
            var layer = LAYER.FORE;
            var direction2 = getDirection(this.option);
            this.components.push({
              id,
              component,
              layer,
              direction: direction2,
              type: COMPONENT_TYPE.LEGEND,
              extra: void 0
            });
            updated[id] = true;
          }
        }
      } else {
        this.loopLegends(eachLegend);
      }
      var components = [];
      each_default(this.getComponents(), function(co) {
        if (updated[co.id]) {
          components.push(co);
        } else {
          co.component.destroy();
        }
      });
      this.components = components;
    };
    Legend2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.container.clear();
    };
    Legend2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.container.remove(true);
    };
    Legend2.prototype.getGeometries = function(view) {
      var _this = this;
      var geometries = view.geometries;
      each_default(view.views, function(v) {
        geometries = geometries.concat(_this.getGeometries(v));
      });
      return geometries;
    };
    Legend2.prototype.loopLegends = function(doEach) {
      var isRootView = this.view.getRootView() === this.view;
      if (!isRootView) {
        return;
      }
      var geometries = this.getGeometries(this.view);
      var looped = {};
      each_default(geometries, function(geometry) {
        var attributes = geometry.getGroupAttributes();
        each_default(attributes, function(attr) {
          var scale4 = attr.getScale(attr.type);
          if (!scale4 || scale4.type === "identity" || looped[scale4.field]) {
            return;
          }
          doEach(geometry, attr, scale4);
          looped[scale4.field] = true;
        });
      });
    };
    Legend2.prototype.createFieldLegend = function(geometry, attr, scale4) {
      var component;
      var legendOption = getLegendOption(this.option, scale4.field);
      var layer = LAYER.FORE;
      var direction2 = getDirection(legendOption);
      if (legendOption !== false) {
        if (get_default(legendOption, "custom")) {
          component = this.createCustomLegend(geometry, attr, scale4, legendOption);
        } else {
          if (scale4.isLinear) {
            component = this.createContinuousLegend(geometry, attr, scale4, legendOption);
          } else if (scale4.isCategory) {
            component = this.createCategoryLegend(geometry, attr, scale4, legendOption);
          }
        }
      }
      if (component) {
        component.set("field", scale4.field);
        return {
          id: this.getId(scale4.field),
          component,
          layer,
          direction: direction2,
          type: COMPONENT_TYPE.LEGEND,
          extra: { scale: scale4 }
        };
      }
    };
    Legend2.prototype.createCustomLegend = function(geometry, attr, scale4, legendOption) {
      var cfg = this.getCategoryCfg(geometry, attr, scale4, legendOption, true);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.createContinuousLegend = function(geometry, attr, scale4, legendOption) {
      var cfg = this.getContinuousCfg(geometry, attr, scale4, omit(legendOption, ["value"]));
      return new ContinuousLegend(cfg);
    };
    Legend2.prototype.createCategoryLegend = function(geometry, attr, scale4, legendOption) {
      var cfg = this.getCategoryCfg(geometry, attr, scale4, legendOption);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.getContinuousCfg = function(geometry, attr, scale4, legendOption) {
      var ticks = scale4.getTicks();
      var containMin = find_default(ticks, function(tick2) {
        return tick2.value === 0;
      });
      var containMax = find_default(ticks, function(tick2) {
        return tick2.value === 1;
      });
      var items = ticks.map(function(tick2) {
        var value = tick2.value, tickValue = tick2.tickValue;
        var attrValue = attr.mapping(scale4.invert(value)).join("");
        return {
          value: tickValue,
          attrValue,
          color: attrValue,
          scaleValue: value
        };
      });
      if (!containMin) {
        items.push({
          value: scale4.min,
          attrValue: attr.mapping(scale4.invert(0)).join(""),
          color: attr.mapping(scale4.invert(0)).join(""),
          scaleValue: 0
        });
      }
      if (!containMax) {
        items.push({
          value: scale4.max,
          attrValue: attr.mapping(scale4.invert(1)).join(""),
          color: attr.mapping(scale4.invert(1)).join(""),
          scaleValue: 1
        });
      }
      items.sort(function(a, b) {
        return a.value - b.value;
      });
      var attrLegendCfg = {
        min: head(items).value,
        max: last(items).value,
        colors: [],
        rail: {
          type: attr.type
        },
        track: {}
      };
      if (attr.type === "size") {
        attrLegendCfg.track = {
          style: {
            fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
          }
        };
      }
      if (attr.type === "color") {
        attrLegendCfg.colors = items.map(function(item) {
          return item.attrValue;
        });
      }
      var container = this.container;
      var direction2 = getDirection(legendOption);
      var layout = getLegendLayout(direction2);
      var title = get_default(legendOption, "title");
      if (title) {
        title = deep_mix_default({
          text: getName(scale4)
        }, title);
      }
      attrLegendCfg.container = container;
      attrLegendCfg.layout = layout;
      attrLegendCfg.title = title;
      attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
      return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
    };
    Legend2.prototype.getCategoryCfg = function(geometry, attr, scale4, legendOption, custom10) {
      var container = this.container;
      var direction2 = get_default(legendOption, "position", DIRECTION.BOTTOM);
      var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
      var themeMarker = get_default(legendTheme, ["marker"]);
      var userMarker = get_default(legendOption, "marker");
      var layout = getLegendLayout(direction2);
      var themePageNavigator = get_default(legendTheme, ["pageNavigator"]);
      var userPageNavigator = get_default(legendOption, "pageNavigator");
      var items = custom10 ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);
      var title = get_default(legendOption, "title");
      if (title) {
        title = deep_mix_default({
          text: scale4 ? getName(scale4) : ""
        }, title);
      }
      var maxWidthRatio = get_default(legendOption, "maxWidthRatio");
      var maxHeightRatio = get_default(legendOption, "maxHeightRatio");
      var baseCfg = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
      baseCfg.container = container;
      baseCfg.layout = layout;
      baseCfg.items = items;
      baseCfg.title = title;
      baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
      baseCfg.pageNavigator = deep_mix_default({}, themePageNavigator, userPageNavigator);
      var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
      if (categoryCfg.reversed) {
        categoryCfg.items.reverse();
      }
      var maxItemWidth = get_default(categoryCfg, "maxItemWidth");
      if (maxItemWidth && maxItemWidth <= 1) {
        categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
      }
      return categoryCfg;
    };
    Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
      var position = direction2.split("-")[0];
      var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
      return deep_mix_default({}, themeObject, baseCfg, legendOption);
    };
    Legend2.prototype.getId = function(key) {
      return this.name + "-" + key;
    };
    Legend2.prototype.getComponentById = function(id) {
      return find_default(this.components, function(co) {
        return co.id === id;
      });
    };
    Legend2.prototype.getCategoryLegendSizeCfg = function(layout, maxWidthRatio, maxHeightRatio) {
      if (maxWidthRatio === void 0) {
        maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      if (maxHeightRatio === void 0) {
        maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      var _a4 = this.view.viewBBox, vw = _a4.width, vh = _a4.height;
      return layout === "vertical" ? {
        maxWidth: vw * maxWidthRatio,
        maxHeight: vh
      } : {
        maxWidth: vw,
        maxHeight: vh * maxHeightRatio
      };
    };
    return Legend2;
  }(Controller);
  var legend_default = Legend;

  // node_modules/@antv/g2/esm/chart/controller/slider.js
  var Slider2 = function(_super) {
    __extends(Slider3, _super);
    function Slider3(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop_default;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(v) {
        var min3 = v[0], max3 = v[1];
        _this.start = min3;
        _this.end = max3;
        _this.changeViewData(min3, max3);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
        leading: true
      });
      _this.width = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Slider3.prototype, "name", {
      get: function() {
        return "slider";
      },
      enumerable: false,
      configurable: true
    });
    Slider3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Slider3.prototype.init = function() {
    };
    Slider3.prototype.render = function() {
      this.option = this.view.getOptions().slider;
      var _a4 = this.getSliderCfg(), start = _a4.start, end = _a4.end;
      if (is_nil_default(this.start)) {
        this.start = start;
        this.end = end;
      }
      var viewData = this.view.getOptions().data;
      if (this.option && !is_empty_default(viewData)) {
        if (this.slider) {
          this.slider = this.updateSlider();
        } else {
          this.slider = this.createSlider();
          this.slider.component.on("sliderchange", this.onChangeFn);
        }
      } else {
        if (this.slider) {
          this.slider.component.destroy();
          this.slider = void 0;
        } else {
        }
      }
    };
    Slider3.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.width) {
        this.measureSlider();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.start, _this.end);
          }
        }, 0);
      }
      if (this.slider) {
        var width = this.view.coordinateBBox.width;
        var padding = this.slider.component.get("padding");
        var paddingTop = padding[0], paddingRight = padding[1], paddingBottom = padding[2], paddingLeft = padding[3];
        var bboxObject = this.slider.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
        var _a4 = this.getMinMaxText(this.start, this.end), minText = _a4.minText, maxText = _a4.maxText;
        var _b = directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), x1 = _b[0], y1 = _b[1];
        var _c = directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), x2 = _c[0], y2 = _c[1];
        this.slider.component.update(__assign(__assign({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
        this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
      }
    };
    Slider3.prototype.update = function() {
      this.render();
    };
    Slider3.prototype.createSlider = function() {
      var cfg = this.getSliderCfg();
      var component = new Slider(__assign({ container: this.container }, cfg));
      component.init();
      return {
        component,
        layer: LAYER.FORE,
        direction: DIRECTION.BOTTOM,
        type: COMPONENT_TYPE.SLIDER
      };
    };
    Slider3.prototype.updateSlider = function() {
      var cfg = this.getSliderCfg();
      if (this.width) {
        var _a4 = this.getMinMaxText(this.start, this.end), minText = _a4.minText, maxText = _a4.maxText;
        cfg = __assign(__assign({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
      }
      this.slider.component.update(cfg);
      return this.slider;
    };
    Slider3.prototype.measureSlider = function() {
      var width = this.getSliderCfg().width;
      this.width = width;
    };
    Slider3.prototype.getSliderCfg = function() {
      var cfg = {
        height: 16,
        start: 0,
        end: 1,
        minText: "",
        maxText: "",
        x: 0,
        y: 0,
        width: this.view.coordinateBBox.width
      };
      if (is_object_default(this.option)) {
        var trendCfg = __assign({ data: this.getData() }, get_default(this.option, "trendCfg", {}));
        cfg = deep_mix_default({}, cfg, this.getThemeOptions(), this.option);
        cfg = __assign(__assign({}, cfg), { trendCfg });
      }
      cfg.start = clamp_default(Math.min(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
      cfg.end = clamp_default(Math.max(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
      return cfg;
    };
    Slider3.prototype.getData = function() {
      var data = this.view.getOptions().data;
      var yScale = this.view.getYScales()[0];
      var groupScales = this.view.getGroupScales();
      if (groupScales.length) {
        var _a4 = groupScales[0], field_1 = _a4.field, ticks_1 = _a4.ticks;
        return data.reduce(function(pre, cur) {
          if (cur[field_1] === ticks_1[0]) {
            pre.push(cur[yScale.field]);
          }
          return pre;
        }, []);
      }
      return data.map(function(datum) {
        return datum[yScale.field] || 0;
      });
    };
    Slider3.prototype.getThemeOptions = function() {
      var theme = this.view.getTheme();
      return get_default(theme, ["components", "slider", "common"], {});
    };
    Slider3.prototype.getMinMaxText = function(min3, max3) {
      var data = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var isHorizontal = true;
      var values2 = values_of_key_default(data, xScale.field);
      var xValues = isHorizontal ? values2 : values2.reverse();
      var dataSize = size2(data);
      if (!xScale || !dataSize) {
        return {};
      }
      var xTickCount = size2(xValues);
      var minIndex = Math.floor(min3 * (xTickCount - 1));
      var maxIndex = Math.floor(max3 * (xTickCount - 1));
      var minText = get_default(xValues, [minIndex]);
      var maxText = get_default(xValues, [maxIndex]);
      var formatter = this.getSliderCfg().formatter;
      if (formatter) {
        minText = formatter(minText, data[minIndex], minIndex);
        maxText = formatter(maxText, data[maxIndex], maxIndex);
      }
      return {
        minText,
        maxText
      };
    };
    Slider3.prototype.changeViewData = function(min3, max3) {
      var data = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var dataSize = size2(data);
      if (!xScale || !dataSize) {
        return;
      }
      var isHorizontal = true;
      var values2 = values_of_key_default(data, xScale.field);
      var xValues = isHorizontal ? values2 : values2.reverse();
      var xTickCount = size2(xValues);
      var minIndex = Math.floor(min3 * (xTickCount - 1));
      var maxIndex = Math.floor(max3 * (xTickCount - 1));
      this.view.filter(xScale.field, function(value, datum) {
        var idx = xValues.indexOf(value);
        return idx > -1 ? isBetween2(idx, minIndex, maxIndex) : true;
      });
      this.view.render(true);
    };
    Slider3.prototype.getComponents = function() {
      return this.slider ? [this.slider] : [];
    };
    Slider3.prototype.clear = function() {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      }
      this.width = 0;
      this.start = void 0;
      this.end = void 0;
    };
    return Slider3;
  }(Controller);
  var slider_default = Slider2;

  // node_modules/@antv/g2/esm/chart/controller/scrollbar.js
  var DEFAULT_PADDING = 0;
  var DEFAULT_SIZE = 8;
  var DEFAULT_CATEGORY_SIZE = 32;
  var MIN_THUMB_LENGTH = 20;
  var Scrollbar2 = function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop_default;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(_a4) {
        var ratio = _a4.ratio;
        var animate = _this.getValidScrollbarCfg().animate;
        _this.ratio = clamp_default(ratio, 0, 1);
        var originalAnimate = _this.view.getOptions().animate;
        if (!animate) {
          _this.view.animate(false);
        }
        _this.changeViewData(_this.getScrollRange(), true);
        _this.view.animate(originalAnimate);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
        leading: true
      });
      _this.trackLen = 0;
      _this.thumbLen = 0;
      _this.ratio = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Scrollbar3.prototype, "name", {
      get: function() {
        return "scrollbar";
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Scrollbar3.prototype.init = function() {
    };
    Scrollbar3.prototype.render = function() {
      this.option = this.view.getOptions().scrollbar;
      if (this.option) {
        if (this.scrollbar) {
          this.scrollbar = this.updateScrollbar();
        } else {
          this.scrollbar = this.createScrollbar();
          this.scrollbar.component.on("scrollchange", this.onChangeFn);
        }
      } else {
        if (this.scrollbar) {
          this.scrollbar.component.destroy();
          this.scrollbar = void 0;
        }
      }
    };
    Scrollbar3.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.trackLen) {
        this.measureScrollbar();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.getScrollRange(), true);
          }
        });
      }
      if (this.scrollbar) {
        var width = this.view.coordinateBBox.width;
        var padding = this.scrollbar.component.get("padding");
        var bboxObject = this.scrollbar.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
        var cfg = this.getScrollbarComponentCfg();
        var x = void 0;
        var y = void 0;
        if (cfg.isHorizontal) {
          var _a4 = directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), x1 = _a4[0], y1 = _a4[1];
          var _b = directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), x2 = _b[0], y2 = _b[1];
          x = x2;
          y = y1;
        } else {
          var _c = directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), x1 = _c[0], y1 = _c[1];
          var _d = directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), x2 = _d[0], y2 = _d[1];
          x = x2;
          y = y1;
        }
        x += padding[3];
        y += padding[0];
        if (this.trackLen) {
          this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
        } else {
          this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y }));
        }
        this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
      }
    };
    Scrollbar3.prototype.update = function() {
      this.render();
    };
    Scrollbar3.prototype.getComponents = function() {
      return this.scrollbar ? [this.scrollbar] : [];
    };
    Scrollbar3.prototype.clear = function() {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
      this.trackLen = 0;
      this.thumbLen = 0;
      this.ratio = 0;
      this.cnt = 0;
      this.step = 0;
      this.data = void 0;
      this.xScaleCfg = void 0;
      this.yScalesCfg = [];
    };
    Scrollbar3.prototype.setValue = function(ratio) {
      this.onValueChange({ ratio });
    };
    Scrollbar3.prototype.getValue = function() {
      return this.ratio;
    };
    Scrollbar3.prototype.getThemeOptions = function() {
      var theme = this.view.getTheme();
      return get_default(theme, ["components", "scrollbar", "common"], {});
    };
    Scrollbar3.prototype.getScrollbarTheme = function(style) {
      var theme = get_default(this.view.getTheme(), ["components", "scrollbar"]);
      var _a4 = style || {}, thumbHighlightColor = _a4.thumbHighlightColor, restStyles = __rest(_a4, ["thumbHighlightColor"]);
      return {
        default: deep_mix_default({}, get_default(theme, ["default", "style"], {}), restStyles),
        hover: deep_mix_default({}, get_default(theme, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
      };
    };
    Scrollbar3.prototype.measureScrollbar = function() {
      var xScale = this.view.getXScale();
      var yScales = this.view.getYScales().slice();
      this.data = this.getScrollbarData();
      this.step = this.getStep();
      this.cnt = this.getCnt();
      var _a4 = this.getScrollbarComponentCfg(), trackLen = _a4.trackLen, thumbLen = _a4.thumbLen;
      this.trackLen = trackLen;
      this.thumbLen = thumbLen;
      this.xScaleCfg = {
        field: xScale.field,
        values: xScale.values || []
      };
      this.yScalesCfg = yScales;
    };
    Scrollbar3.prototype.getScrollRange = function() {
      var startIdx = Math.floor((this.cnt - this.step) * clamp_default(this.ratio, 0, 1));
      var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
      return [startIdx, endIdx];
    };
    Scrollbar3.prototype.changeViewData = function(_a4, render) {
      var _this = this;
      var startIdx = _a4[0], endIdx = _a4[1];
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal = type !== "vertical";
      var values2 = values_of_key_default(this.data, this.xScaleCfg.field);
      var xValues = isHorizontal ? values2 : values2.reverse();
      this.yScalesCfg.forEach(function(cfg) {
        _this.view.scale(cfg.field, {
          formatter: cfg.formatter,
          type: cfg.type,
          min: cfg.min,
          max: cfg.max
        });
      });
      this.view.filter(this.xScaleCfg.field, function(val) {
        var idx = xValues.indexOf(val);
        return idx > -1 ? isBetween2(idx, startIdx, endIdx) : true;
      });
      this.view.render(true);
    };
    Scrollbar3.prototype.createScrollbar = function() {
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal = type !== "vertical";
      var component = new Scrollbar(__assign(__assign({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
      component.init();
      return {
        component,
        layer: LAYER.FORE,
        direction: isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
        type: COMPONENT_TYPE.SCROLLBAR
      };
    };
    Scrollbar3.prototype.updateScrollbar = function() {
      var config = this.getScrollbarComponentCfg();
      var realConfig = this.trackLen ? __assign(__assign({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign({}, config);
      this.scrollbar.component.update(realConfig);
      return this.scrollbar;
    };
    Scrollbar3.prototype.getStep = function() {
      if (this.step) {
        return this.step;
      }
      var coordinateBBox = this.view.coordinateBBox;
      var _a4 = this.getValidScrollbarCfg(), type = _a4.type, categorySize = _a4.categorySize;
      var isHorizontal = type !== "vertical";
      return Math.floor((isHorizontal ? coordinateBBox.width : coordinateBBox.height) / categorySize);
    };
    Scrollbar3.prototype.getCnt = function() {
      if (this.cnt) {
        return this.cnt;
      }
      var xScale = this.view.getXScale();
      var data = this.getScrollbarData();
      var values2 = values_of_key_default(data, xScale.field);
      return size2(values2);
    };
    Scrollbar3.prototype.getScrollbarComponentCfg = function() {
      var _a4 = this.view, coordinateBBox = _a4.coordinateBBox, viewBBox = _a4.viewBBox;
      var _b = this.getValidScrollbarCfg(), type = _b.type, padding = _b.padding, width = _b.width, height = _b.height, style = _b.style;
      var isHorizontal = type !== "vertical";
      var paddingTop = padding[0], paddingRight = padding[1], paddingBottom = padding[2], paddingLeft = padding[3];
      var position = isHorizontal ? {
        x: coordinateBBox.minX + paddingLeft,
        y: viewBBox.maxY - height - paddingBottom
      } : {
        x: viewBBox.maxX - width - paddingRight,
        y: coordinateBBox.minY + paddingTop
      };
      var step = this.getStep();
      var cnt = this.getCnt();
      var trackLen = isHorizontal ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
      var thumbLen = Math.max(trackLen * clamp_default(step / cnt, 0, 1), MIN_THUMB_LENGTH);
      return __assign(__assign({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal ? height : width, isHorizontal, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
    };
    Scrollbar3.prototype.getValidScrollbarCfg = function() {
      var cfg = {
        type: "horizontal",
        categorySize: DEFAULT_CATEGORY_SIZE,
        width: DEFAULT_SIZE,
        height: DEFAULT_SIZE,
        padding: [0, 0, 0, 0],
        animate: true,
        style: {}
      };
      if (is_object_default(this.option)) {
        cfg = __assign(__assign({}, cfg), this.option);
      }
      if (!is_object_default(this.option) || !this.option.padding) {
        cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
      }
      return cfg;
    };
    Scrollbar3.prototype.getScrollbarData = function() {
      var coordinate = this.view.getCoordinate();
      var cfg = this.getValidScrollbarCfg();
      var data = this.view.getOptions().data || [];
      if (coordinate.isReflect("y") && cfg.type === "vertical") {
        data = __spreadArray([], data, true).reverse();
      }
      return data;
    };
    return Scrollbar3;
  }(Controller);
  var scrollbar_default = Scrollbar2;

  // node_modules/@antv/g2/esm/interaction/action/active-region.js
  var DEFAULT_REGION_PATH_STYLE = {
    fill: "#CCD6EC",
    opacity: 0.3
  };
  function getItemsOfView(view, point, tooltipCfg) {
    var items = findItemsFromViewRecurisive(view, point, tooltipCfg);
    if (items.length) {
      items = flatten_default(items);
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var itemArr = items_1[_i];
        for (var _a4 = 0, itemArr_1 = itemArr; _a4 < itemArr_1.length; _a4++) {
          var item = itemArr_1[_a4];
          var _b = item.mappingData, x = _b.x, y = _b.y;
          item.x = is_array_default(x) ? x[x.length - 1] : x;
          item.y = is_array_default(y) ? y[y.length - 1] : y;
        }
      }
      var shared = tooltipCfg.shared;
      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min3 = Math.abs(point.y - snapItem[0].y);
        for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
          var aItem = items_2[_c];
          var yDistance = Math.abs(point.y - aItem[0].y);
          if (yDistance <= min3) {
            snapItem = aItem;
            min3 = yDistance;
          }
        }
        items = [snapItem];
      }
      return uniq(flatten_default(items));
    }
    return [];
  }
  var ActiveRegion = function(_super) {
    __extends(ActiveRegion2, _super);
    function ActiveRegion2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActiveRegion2.prototype.show = function(args) {
      var view = this.context.view;
      var ev = this.context.event;
      var tooltipCfg = view.getController("tooltip").getTooltipCfg();
      var tooltipItems = getItemsOfView(view, {
        x: ev.x,
        y: ev.y
      }, tooltipCfg);
      if (is_equal_default(tooltipItems, this.items)) {
        return;
      }
      this.items = tooltipItems;
      if (tooltipItems.length) {
        var xField_1 = view.getXScale().field;
        var xValue_1 = tooltipItems[0].data[xField_1];
        var elements_1 = [];
        var geometries = view.geometries;
        each_default(geometries, function(geometry) {
          if (geometry.type === "interval" || geometry.type === "schema") {
            var result = geometry.getElementsBy(function(ele) {
              var eleData = ele.getData();
              return eleData[xField_1] === xValue_1;
            });
            elements_1 = elements_1.concat(result);
          }
        });
        if (elements_1.length) {
          var coordinate_1 = view.getCoordinate();
          var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
          var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
          var groupBBox_1 = firstBBox_1;
          each_default(elements_1, function(ele) {
            var bbox = ele.shape.getCanvasBBox();
            if (coordinate_1.isTransposed) {
              if (bbox.minY < firstBBox_1.minY) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxY > lastBBox_1.maxY) {
                lastBBox_1 = bbox;
              }
            } else {
              if (bbox.minX < firstBBox_1.minX) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxX > lastBBox_1.maxX) {
                lastBBox_1 = bbox;
              }
            }
            groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
            groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
            groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
            groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
          });
          var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
          var path = void 0;
          if (coordinate_1.isRect) {
            var xScale = view.getXScale();
            var _a4 = args || {}, appendRatio = _a4.appendRatio, appendWidth = _a4.appendWidth;
            if (is_nil_default(appendWidth)) {
              appendRatio = is_nil_default(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
              appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
            }
            var minX = void 0;
            var minY = void 0;
            var width = void 0;
            var height = void 0;
            if (coordinate_1.isTransposed) {
              minX = coordinateBBox.minX;
              minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
              width = coordinateBBox.width;
              height = groupBBox_1.height + appendWidth * 2;
            } else {
              minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
              minY = coordinateBBox.minY;
              width = groupBBox_1.width + appendWidth * 2;
              height = coordinateBBox.height;
            }
            path = [
              ["M", minX, minY],
              ["L", minX + width, minY],
              ["L", minX + width, minY + height],
              ["L", minX, minY + height],
              ["Z"]
            ];
          } else {
            var firstElement = head(elements_1);
            var lastElement = last(elements_1);
            var startAngle = getAngle2(firstElement.getModel(), coordinate_1).startAngle;
            var endAngle = getAngle2(lastElement.getModel(), coordinate_1).endAngle;
            var center = coordinate_1.getCenter();
            var radius = coordinate_1.getRadius();
            var innterRadius = coordinate_1.innerRadius * radius;
            path = getSectorPath(center.x, center.y, radius, startAngle, endAngle, innterRadius);
          }
          if (this.regionPath) {
            this.regionPath.attr("path", path);
            this.regionPath.show();
          } else {
            var style = get_default(args, "style", DEFAULT_REGION_PATH_STYLE);
            this.regionPath = backgroundGroup.addShape({
              type: "path",
              name: "active-region",
              capture: false,
              attrs: __assign(__assign({}, style), { path })
            });
          }
        }
      }
    };
    ActiveRegion2.prototype.hide = function() {
      if (this.regionPath) {
        this.regionPath.hide();
      }
      this.items = null;
    };
    ActiveRegion2.prototype.destroy = function() {
      this.hide();
      if (this.regionPath) {
        this.regionPath.remove(true);
      }
      _super.prototype.destroy.call(this);
    };
    return ActiveRegion2;
  }(base_default13);
  var active_region_default = ActiveRegion;

  // node_modules/@antv/g2/esm/interaction/action/component/tooltip/geometry.js
  var TooltipAction = function(_super) {
    __extends(TooltipAction2, _super);
    function TooltipAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    TooltipAction2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var view = context.view;
      var isTooltipLocked = view.isTooltipLocked();
      if (isTooltipLocked) {
        return;
      }
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +new Date();
      var showDelay = get_default(context.view.getOptions(), "tooltip.showDelay", 16);
      if (timeStamp - lastTimeStamp > showDelay) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(view, curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    TooltipAction2.prototype.hide = function() {
      var view = this.context.view;
      var tooltip = view.getController("tooltip");
      var _a4 = this.context.event, clientX = _a4.clientX, clientY = _a4.clientY;
      if (tooltip.isCursorEntered({ x: clientX, y: clientY })) {
        return;
      }
      if (view.isTooltipLocked()) {
        return;
      }
      this.hideTooltip(view);
      this.location = null;
    };
    TooltipAction2.prototype.showTooltip = function(view, point) {
      view.showTooltip(point);
    };
    TooltipAction2.prototype.hideTooltip = function(view) {
      view.hideTooltip();
    };
    return TooltipAction2;
  }(base_default13);
  var geometry_default = TooltipAction;

  // node_modules/@antv/g2/esm/interaction/action/component/tooltip/sibling.js
  var SiblingTooltip = function(_super) {
    __extends(SiblingTooltip2, _super);
    function SiblingTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingTooltip2.prototype.showTooltip = function(view, point) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var siblingPoint = getSiblingPoint(view, sibling, point);
        sibling.showTooltip(siblingPoint);
      });
    };
    SiblingTooltip2.prototype.hideTooltip = function(view) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.hideTooltip();
      });
    };
    return SiblingTooltip2;
  }(geometry_default);
  var sibling_default = SiblingTooltip;

  // node_modules/@antv/g2/esm/interaction/action/component/tooltip/ellipsis-text.js
  var EllipsisText = function(_super) {
    __extends(EllipsisText2, _super);
    function EllipsisText2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    EllipsisText2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    EllipsisText2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +new Date();
      if (timeStamp - lastTimeStamp > 16) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    EllipsisText2.prototype.hide = function() {
      this.hideTooltip();
      this.location = null;
    };
    EllipsisText2.prototype.showTooltip = function(curLoc) {
      var context = this.context;
      var ev = context.event;
      var target = ev.target;
      if (target && target.get("tip")) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        var tipContent = target.get("tip");
        this.tooltip.update(__assign({ title: tipContent }, curLoc));
        this.tooltip.show();
      }
    };
    EllipsisText2.prototype.hideTooltip = function() {
      this.tooltip && this.tooltip.hide();
    };
    EllipsisText2.prototype.renderTooltip = function() {
      var _a4;
      var view = this.context.view;
      var canvas = view.canvas;
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var theme = view.getTheme();
      var tooltipStyles = get_default(theme, ["components", "tooltip", "domStyles"], {});
      var tooltip = new HtmlTooltip({
        parent: canvas.get("el").parentNode,
        region,
        visible: false,
        crosshairs: null,
        domStyles: __assign({}, deep_mix_default({}, tooltipStyles, (_a4 = {}, _a4[css_const_exports.CONTAINER_CLASS] = { "max-width": "50%" }, _a4[css_const_exports.TITLE_CLASS] = { "word-break": "break-all" }, _a4)))
      });
      tooltip.init();
      tooltip.setCapture(false);
      this.tooltip = tooltip;
    };
    return EllipsisText2;
  }(base_default13);
  var ellipsis_text_default = EllipsisText;

  // node_modules/@antv/g2/esm/interaction/action/element/state-base.js
  var StateBase = function(_super) {
    __extends(StateBase2, _super);
    function StateBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      return _this;
    }
    StateBase2.prototype.hasState = function(element) {
      return element.hasState(this.stateName);
    };
    StateBase2.prototype.setElementState = function(element, enable) {
      element.setState(this.stateName, enable);
    };
    StateBase2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    StateBase2.prototype.clear = function() {
      var view = this.context.view;
      this.clearViewState(view);
    };
    StateBase2.prototype.clearViewState = function(view) {
      var _this = this;
      var elements = getElementsByState(view, this.stateName);
      each_default(elements, function(el) {
        _this.setElementState(el, false);
      });
    };
    return StateBase2;
  }(base_default13);
  var state_base_default = StateBase;

  // node_modules/@antv/g2/esm/interaction/action/element/state.js
  function getItem(shape) {
    return get_default(shape.get("delegateObject"), "item");
  }
  var ElementState = function(_super) {
    __extends(ElementState2, _super);
    function ElementState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.ignoreListItemStates = ["unchecked"];
      return _this;
    }
    ElementState2.prototype.isItemIgnore = function(item, list) {
      var states = this.ignoreListItemStates;
      var filtered = states.filter(function(state) {
        return list.hasState(item, state);
      });
      return !!filtered.length;
    };
    ElementState2.prototype.setStateByComponent = function(component, item, enable) {
      var view = this.context.view;
      var field = component.get("field");
      var elements = getElements(view);
      this.setElementsStateByItem(elements, field, item, enable);
    };
    ElementState2.prototype.setStateByElement = function(element, enable) {
      this.setElementState(element, enable);
    };
    ElementState2.prototype.isMathItem = function(element, field, item) {
      var view = this.context.view;
      var scale4 = getScaleByField(view, field);
      var value = getElementValue(element, field);
      return !is_nil_default(value) && item.name === scale4.getText(value);
    };
    ElementState2.prototype.setElementsStateByItem = function(elements, field, item, enable) {
      var _this = this;
      each_default(elements, function(el) {
        if (_this.isMathItem(el, field, item)) {
          el.setState(_this.stateName, enable);
        }
      });
    };
    ElementState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement(this.context);
      if (element) {
        if (isElementChange(this.context)) {
          this.setStateByElement(element, enable);
        }
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component = delegateObject.component;
          if (item && component && !this.isItemIgnore(item, component)) {
            var event_1 = this.context.event.gEvent;
            if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
              return;
            }
            this.setStateByComponent(component, item, enable);
          }
        }
      }
    };
    ElementState2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setElementState(element, !hasState);
      }
    };
    ElementState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementState2;
  }(state_base_default);
  var state_default = ElementState;

  // node_modules/@antv/g2/esm/interaction/action/element/active.js
  var ElementActive = function(_super) {
    __extends(ElementActive2, _super);
    function ElementActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementActive2.prototype.active = function() {
      this.setState();
    };
    return ElementActive2;
  }(state_default);
  var active_default = ElementActive;

  // node_modules/@antv/g2/esm/interaction/action/element/link-by-color.js
  var LinkByColor = function(_super) {
    __extends(LinkByColor2, _super);
    function LinkByColor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = {};
      return _this;
    }
    LinkByColor2.prototype.getColorScale = function(view, element) {
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return null;
      }
      var scale4 = view.getScaleByField(colorAttr.getFields()[0]);
      return scale4;
    };
    LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
      var view = this.context.view;
      var isTransposed = view.getCoordinate().isTransposed;
      var bbox = element.shape.getCanvasBBox();
      var nextBBox = nextElement.shape.getCanvasBBox();
      var path = isTransposed ? [
        ["M", bbox.minX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", nextBBox.maxX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.minY],
        ["Z"]
      ] : [
        ["M", bbox.maxX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.maxY],
        ["Z"]
      ];
      return path;
    };
    LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
      var style = {
        opacity: 0.4,
        fill: element.shape.attr("fill")
      };
      group2.addShape({
        type: "path",
        attrs: __assign(__assign({}, deep_mix_default({}, style, is_function_default(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
      });
    };
    LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
      var _this = this;
      var view = this.context.view;
      var scale4 = this.getColorScale(view, element);
      if (!scale4) {
        return;
      }
      var value = getElementValue(element, scale4.field);
      if (!this.cache[value]) {
        var elements_1 = getElementsByField(view, scale4.field, value);
        var linkGroup = this.linkGroup;
        var group_1 = linkGroup.addGroup();
        this.cache[value] = group_1;
        var count_1 = elements_1.length;
        each_default(elements_1, function(el, index) {
          if (index < count_1 - 1) {
            var nextEl = elements_1[index + 1];
            _this.addLinkShape(group_1, el, nextEl, activeStyle);
          }
        });
      }
    };
    LinkByColor2.prototype.removeLink = function(element) {
      var scale4 = this.getColorScale(this.context.view, element);
      if (!scale4) {
        return;
      }
      var value = getElementValue(element, scale4.field);
      if (this.cache[value]) {
        this.cache[value].remove();
        this.cache[value] = null;
      }
    };
    LinkByColor2.prototype.link = function(args) {
      var context = this.context;
      if (!this.linkGroup) {
        this.linkGroup = context.view.foregroundGroup.addGroup({
          id: "link-by-color-group",
          capture: false
        });
      }
      var element = getCurrentElement(context);
      if (element) {
        this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
      }
    };
    LinkByColor2.prototype.unlink = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        this.removeLink(element);
      }
    };
    LinkByColor2.prototype.clear = function() {
      if (this.linkGroup) {
        this.linkGroup.clear();
      }
      this.cache = {};
    };
    LinkByColor2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.linkGroup) {
        this.linkGroup.remove();
      }
    };
    return LinkByColor2;
  }(base_default13);
  var link_by_color_default = LinkByColor;

  // node_modules/@antv/g2/esm/interaction/action/element/range-state.js
  var ElementRangeState = function(_super) {
    __extends(ElementRangeState2, _super);
    function ElementRangeState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.endPoint = null;
      _this.isStarted = false;
      _this.effectSiblings = false;
      _this.effectByRecord = false;
      return _this;
    }
    ElementRangeState2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    ElementRangeState2.prototype.start = function() {
      this.clear();
      this.startPoint = this.getCurrentPoint();
      this.isStarted = true;
    };
    ElementRangeState2.prototype.getIntersectElements = function() {
      var elements = null;
      if (isMask(this.context)) {
        elements = getMaskedElements(this.context, 10);
      } else {
        var startPoint = this.startPoint;
        var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
        if (!startPoint || !endPoint) {
          return;
        }
        var box2 = {
          minX: Math.min(startPoint.x, endPoint.x),
          minY: Math.min(startPoint.y, endPoint.y),
          maxX: Math.max(startPoint.x, endPoint.x),
          maxY: Math.max(startPoint.y, endPoint.y)
        };
        var view = this.context.view;
        elements = getIntersectElements(view, box2);
      }
      return elements;
    };
    ElementRangeState2.prototype.setStateEnable = function(enable) {
      if (this.effectSiblings && !this.effectByRecord) {
        this.setSiblingsState(enable);
      } else {
        var allElements = getElements(this.context.view);
        var elements = this.getIntersectElements();
        if (elements && elements.length) {
          if (this.effectByRecord) {
            this.setSiblingsStateByRecord(elements, enable);
          } else {
            this.setElementsState(elements, enable, allElements);
          }
        } else {
          this.clear();
        }
      }
    };
    ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      var records = elements.map(function(el) {
        return el.getModel().data;
      });
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      each_default(siblings, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = allElements.filter(function(el) {
          var record = el.getModel().data;
          return isInRecords(records, record, xFiled, yField);
        });
        _this.setElementsState(effectElements, enable, allElements);
      });
    };
    ElementRangeState2.prototype.setSiblingsState = function(enable) {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      if (isMask(this.context)) {
        each_default(siblings, function(sibling) {
          var allElements = getElements(sibling);
          var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
          if (effectElements && effectElements.length) {
            _this.setElementsState(effectElements, enable, allElements);
          } else {
            _this.clearViewState(sibling);
          }
        });
      }
    };
    ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
      var _this = this;
      each_default(allElements, function(el) {
        if (!elements.includes(el)) {
          _this.setElementState(el, false);
        } else {
          _this.setElementState(el, enable);
        }
      });
    };
    ElementRangeState2.prototype.end = function() {
      this.isStarted = false;
      this.endPoint = this.getCurrentPoint();
    };
    ElementRangeState2.prototype.clear = function() {
      var _this = this;
      var view = this.context.view;
      if (this.effectSiblings) {
        var siblings = getSilbings(view);
        each_default(siblings, function(sibling) {
          _this.clearViewState(sibling);
        });
      } else {
        this.clearViewState(view);
      }
    };
    return ElementRangeState2;
  }(state_base_default);
  var range_state_default = ElementRangeState;

  // node_modules/@antv/g2/esm/interaction/action/element/range-active.js
  var ElementRangeActive = function(_super) {
    __extends(ElementRangeActive2, _super);
    function ElementRangeActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeActive2.prototype.active = function() {
      this.setState();
    };
    return ElementRangeActive2;
  }(range_state_default);
  var range_active_default = ElementRangeActive;

  // node_modules/@antv/g2/esm/interaction/action/element/single-state.js
  var ElementSingleState = function(_super) {
    __extends(ElementSingleState2, _super);
    function ElementSingleState2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementSingleState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement(this.context);
      if (element) {
        if (!isElementChange(this.context)) {
          return;
        }
        if (enable) {
          this.clear();
          this.setElementState(element, true);
        } else if (this.hasState(element)) {
          this.setElementState(element, false);
        }
      }
    };
    ElementSingleState2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = this.hasState(element);
        if (!hasState) {
          this.clear();
        }
        this.setElementState(element, !hasState);
      }
    };
    ElementSingleState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementSingleState2;
  }(state_base_default);
  var single_state_default = ElementSingleState;

  // node_modules/@antv/g2/esm/interaction/action/element/single-active.js
  var ElementSingleActive = function(_super) {
    __extends(ElementSingleActive2, _super);
    function ElementSingleActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleActive2.prototype.active = function() {
      this.setState();
    };
    return ElementSingleActive2;
  }(single_state_default);
  var single_active_default = ElementSingleActive;

  // node_modules/@antv/g2/esm/interaction/action/element/highlight-util.js
  var STATUS_UNACTIVE = "inactive";
  var STATUS_ACTIVE = "active";
  function clearHighlight(view) {
    var elements = getElements(view);
    each_default(elements, function(el) {
      if (el.hasState(STATUS_ACTIVE)) {
        el.setState(STATUS_ACTIVE, false);
      }
      if (el.hasState(STATUS_UNACTIVE)) {
        el.setState(STATUS_UNACTIVE, false);
      }
    });
  }
  function setHighlightBy(elements, callback, enable) {
    each_default(elements, function(el) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE)) {
          el.setState(STATUS_UNACTIVE, false);
        }
        el.setState(STATUS_ACTIVE, enable);
      } else {
        if (el.hasState(STATUS_ACTIVE)) {
          el.setState(STATUS_ACTIVE, false);
        }
        el.setState(STATUS_UNACTIVE, enable);
      }
    });
  }

  // node_modules/@antv/g2/esm/interaction/action/element/highlight.js
  var STATUS_UNACTIVE2 = ELEMENT_STATE.INACTIVE;
  var STATUS_ACTIVE2 = ELEMENT_STATE.ACTIVE;
  var ElementHighlight = function(_super) {
    __extends(ElementHighlight2, _super);
    function ElementHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE2;
      return _this;
    }
    ElementHighlight2.prototype.setElementsStateByItem = function(elements, field, item, enable) {
      var _this = this;
      var callback = function(el) {
        return _this.isMathItem(el, field, item);
      };
      this.setHighlightBy(elements, callback, enable);
    };
    ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE2)) {
          el.setState(STATUS_UNACTIVE2, false);
        }
        el.setState(STATUS_ACTIVE2, true);
      } else if (!el.hasState(STATUS_ACTIVE2)) {
        el.setState(STATUS_UNACTIVE2, true);
      }
    };
    ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
      var _this = this;
      if (enable) {
        each_default(elements, function(el) {
          _this.setElementHighlight(el, callback);
        });
      } else {
        var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE2);
        var allCancel_1 = true;
        each_default(activeElements, function(el) {
          if (!callback(el)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each_default(elements, function(el) {
            if (callback(el)) {
              if (el.hasState(STATUS_ACTIVE2)) {
                el.setState(STATUS_ACTIVE2, false);
              }
              el.setState(STATUS_UNACTIVE2, true);
            }
          });
        }
      }
    };
    ElementHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      this.setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight(view);
    };
    return ElementHighlight2;
  }(state_default);
  var highlight_default = ElementHighlight;

  // node_modules/@antv/g2/esm/interaction/action/element/highlight-by-color.js
  var HighlightColor = function(_super) {
    __extends(HighlightColor2, _super);
    function HighlightColor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightColor2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return;
      }
      var scale4 = view.getScaleByField(colorAttr.getFields()[0]);
      var value = getElementValue(element, scale4.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue(el, scale4.field) === value;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    return HighlightColor2;
  }(highlight_default);
  var highlight_by_color_default = HighlightColor;

  // node_modules/@antv/g2/esm/interaction/action/element/highlight-by-x.js
  var HighlightX = function(_super) {
    __extends(HighlightX2, _super);
    function HighlightX2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightX2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE2)) {
          el.setState(STATUS_UNACTIVE2, false);
        }
        el.setState(STATUS_ACTIVE2, true);
      } else {
        el.setState(STATUS_UNACTIVE2, true);
        if (el.hasState(STATUS_ACTIVE2)) {
          el.setState(STATUS_ACTIVE2, false);
        }
      }
    };
    HighlightX2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var scale4 = view.getXScale();
      var value = getElementValue(element, scale4.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue(el, scale4.field) === value;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    HighlightX2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setStateByElement(element, !hasState);
      }
    };
    return HighlightX2;
  }(highlight_default);
  var highlight_by_x_default = HighlightX;

  // node_modules/@antv/g2/esm/interaction/action/element/range-highlight.js
  var EVENTS3;
  (function(EVENTS5) {
    EVENTS5["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
    EVENTS5["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
    EVENTS5["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
    EVENTS5["AFTER_CLEAR"] = "element-range-highlight:afterclear";
  })(EVENTS3 || (EVENTS3 = {}));
  var ElementRangeHighlight = function(_super) {
    __extends(ElementRangeHighlight2, _super);
    function ElementRangeHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeHighlight2.prototype.clearViewState = function(view) {
      clearHighlight(view);
    };
    ElementRangeHighlight2.prototype.highlight = function() {
      var _a4 = this.context, view = _a4.view, event = _a4.event;
      var elements = this.getIntersectElements();
      var payload = { view, event, highlightElements: elements };
      view.emit(EVENTS3.BEFORE_HIGHLIGHT, event_default.fromData(view, EVENTS3.BEFORE_HIGHLIGHT, payload));
      this.setState();
      view.emit(EVENTS3.AFTER_HIGHLIGHT, event_default.fromData(view, EVENTS3.AFTER_HIGHLIGHT, payload));
    };
    ElementRangeHighlight2.prototype.clear = function() {
      var view = this.context.view;
      view.emit(EVENTS3.BEFORE_CLEAR, event_default.fromData(view, EVENTS3.BEFORE_CLEAR, {}));
      _super.prototype.clear.call(this);
      view.emit(EVENTS3.AFTER_CLEAR, event_default.fromData(view, EVENTS3.AFTER_CLEAR, {}));
    };
    ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
      setHighlightBy(allElements, function(el) {
        return elements.indexOf(el) >= 0;
      }, enable);
    };
    return ElementRangeHighlight2;
  }(range_state_default);
  var range_highlight_default = ElementRangeHighlight;

  // node_modules/@antv/g2/esm/interaction/action/element/single-highlight.js
  var ElementSingleHighlight = function(_super) {
    __extends(ElementSingleHighlight2, _super);
    function ElementSingleHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementSingleHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight(view);
    };
    return ElementSingleHighlight2;
  }(single_state_default);
  var single_highlight_default = ElementSingleHighlight;

  // node_modules/@antv/g2/esm/interaction/action/element/range-selected.js
  var ElementRangeSelected = function(_super) {
    __extends(ElementRangeSelected2, _super);
    function ElementRangeSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementRangeSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementRangeSelected2;
  }(range_state_default);
  var range_selected_default = ElementRangeSelected;

  // node_modules/@antv/g2/esm/interaction/action/element/selected.js
  var ElementMultipleSelected = function(_super) {
    __extends(ElementMultipleSelected2, _super);
    function ElementMultipleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementMultipleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementMultipleSelected2;
  }(state_default);
  var selected_default = ElementMultipleSelected;

  // node_modules/@antv/g2/esm/interaction/action/element/single-selected.js
  var ElementSingleSelected = function(_super) {
    __extends(ElementSingleSelected2, _super);
    function ElementSingleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementSingleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementSingleSelected2;
  }(single_state_default);
  var single_selected_default = ElementSingleSelected;

  // node_modules/@antv/g2/esm/interaction/action/component/list-state.js
  var ListState = function(_super) {
    __extends(ListState2, _super);
    function ListState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      _this.ignoreItemStates = [];
      return _this;
    }
    ListState2.prototype.getTriggerListInfo = function() {
      var delegateObject = getDelegationObject(this.context);
      var info = null;
      if (isList(delegateObject)) {
        info = {
          item: delegateObject.item,
          list: delegateObject.component
        };
      }
      return info;
    };
    ListState2.prototype.getAllowComponents = function() {
      var _this = this;
      var view = this.context.view;
      var components = getComponents(view);
      var rst = [];
      each_default(components, function(component) {
        if (component.isList() && _this.allowSetStateByElement(component)) {
          rst.push(component);
        }
      });
      return rst;
    };
    ListState2.prototype.hasState = function(list, item) {
      return list.hasState(item, this.stateName);
    };
    ListState2.prototype.clearAllComponentsState = function() {
      var _this = this;
      var components = this.getAllowComponents();
      each_default(components, function(component) {
        component.clearItemsState(_this.stateName);
      });
    };
    ListState2.prototype.allowSetStateByElement = function(component) {
      var field = component.get("field");
      if (!field) {
        return false;
      }
      if (this.cfg && this.cfg.componentNames) {
        var name_1 = component.get("name");
        if (this.cfg.componentNames.indexOf(name_1) === -1) {
          return false;
        }
      }
      var view = this.context.view;
      var scale4 = getScaleByField(view, field);
      return scale4 && scale4.isCategory;
    };
    ListState2.prototype.allowSetStateByItem = function(item, list) {
      var ignoreStates = this.ignoreItemStates;
      if (ignoreStates.length) {
        var filterStates = ignoreStates.filter(function(state) {
          return list.hasState(item, state);
        });
        return filterStates.length === 0;
      }
      return true;
    };
    ListState2.prototype.setStateByElement = function(component, element, enable) {
      var field = component.get("field");
      var view = this.context.view;
      var scale4 = getScaleByField(view, field);
      var value = getElementValue(element, field);
      var text = scale4.getText(value);
      this.setItemsState(component, text, enable);
    };
    ListState2.prototype.setStateEnable = function(enable) {
      var _this = this;
      var element = getCurrentElement(this.context);
      if (element) {
        var components = this.getAllowComponents();
        each_default(components, function(component2) {
          _this.setStateByElement(component2, element, enable);
        });
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component = delegateObject.component;
          if (this.allowSetStateByElement(component) && this.allowSetStateByItem(item, component)) {
            this.setItemState(component, item, enable);
          }
        }
      }
    };
    ListState2.prototype.setItemsState = function(list, name, enable) {
      var _this = this;
      var items = list.getItems();
      each_default(items, function(item) {
        if (item.name === name) {
          _this.setItemState(list, item, enable);
        }
      });
    };
    ListState2.prototype.setItemState = function(list, item, enable) {
      list.setItemState(item, this.stateName, enable);
    };
    ListState2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    ListState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    ListState2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        var enable = this.hasState(list, item);
        this.setItemState(list, item, !enable);
      }
    };
    ListState2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        triggerInfo.list.clearItemsState(this.stateName);
      } else {
        this.clearAllComponentsState();
      }
    };
    return ListState2;
  }(base_default13);
  var list_state_default = ListState;

  // node_modules/@antv/g2/esm/interaction/action/component/list-active.js
  var ListActive = function(_super) {
    __extends(ListActive2, _super);
    function ListActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ListActive2.prototype.active = function() {
      this.setState();
    };
    return ListActive2;
  }(list_state_default);
  var list_active_default = ListActive;

  // node_modules/@antv/g2/esm/interaction/action/component/list-highlight-util.js
  var STATUS_UNACTIVE3 = "inactive";
  var STATUS_ACTIVE3 = "active";
  function clearList(list) {
    var items = list.getItems();
    each_default(items, function(item) {
      if (list.hasState(item, STATUS_ACTIVE3)) {
        list.setItemState(item, STATUS_ACTIVE3, false);
      }
      if (list.hasState(item, STATUS_UNACTIVE3)) {
        list.setItemState(item, STATUS_UNACTIVE3, false);
      }
    });
  }

  // node_modules/@antv/g2/esm/interaction/action/component/list-highlight.js
  var STATUS_UNACTIVE4 = "inactive";
  var STATUS_ACTIVE4 = "active";
  var ListHighlight = function(_super) {
    __extends(ListHighlight2, _super);
    function ListHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE4;
      _this.ignoreItemStates = ["unchecked"];
      return _this;
    }
    ListHighlight2.prototype.setItemsState = function(list, name, enable) {
      this.setHighlightBy(list, function(item) {
        return item.name === name;
      }, enable);
    };
    ListHighlight2.prototype.setItemState = function(list, item, enable) {
      var items = list.getItems();
      this.setHighlightBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNACTIVE4)) {
              list.setItemState(item, STATUS_UNACTIVE4, false);
            }
            list.setItemState(item, STATUS_ACTIVE4, true);
          } else if (!list.hasState(item, STATUS_ACTIVE4)) {
            list.setItemState(item, STATUS_UNACTIVE4, true);
          }
        });
      } else {
        var activeItems = list.getItemsByState(STATUS_ACTIVE4);
        var allCancel_1 = true;
        each_default(activeItems, function(item) {
          if (!callback(item)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each_default(items, function(item) {
            if (callback(item)) {
              if (list.hasState(item, STATUS_ACTIVE4)) {
                list.setItemState(item, STATUS_ACTIVE4, false);
              }
              list.setItemState(item, STATUS_UNACTIVE4, true);
            }
          });
        }
      }
    };
    ListHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ListHighlight2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        clearList(triggerInfo.list);
      } else {
        var components = this.getAllowComponents();
        each_default(components, function(component) {
          component.clearItemsState(STATUS_ACTIVE4);
          component.clearItemsState(STATUS_UNACTIVE4);
        });
      }
    };
    return ListHighlight2;
  }(list_state_default);
  var list_highlight_default = ListHighlight;

  // node_modules/@antv/g2/esm/interaction/action/component/list-selected.js
  var ListSelected = function(_super) {
    __extends(ListSelected2, _super);
    function ListSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ListSelected2.prototype.selected = function() {
      this.setState();
    };
    return ListSelected2;
  }(list_state_default);
  var list_selected_default = ListSelected;

  // node_modules/@antv/g2/esm/interaction/action/component/list-unchecked.js
  var ListUnchecked = function(_super) {
    __extends(ListUnchecked2, _super);
    function ListUnchecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "unchecked";
      return _this;
    }
    ListUnchecked2.prototype.unchecked = function() {
      this.setState();
    };
    return ListUnchecked2;
  }(list_state_default);
  var list_unchecked_default = ListUnchecked;

  // node_modules/@antv/g2/esm/interaction/action/component/list-checked.js
  var STATUS_UNCHECKED = "unchecked";
  var STATUS_CHECKED = "checked";
  var ListChecked = function(_super) {
    __extends(ListChecked2, _super);
    function ListChecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_CHECKED;
      return _this;
    }
    ListChecked2.prototype.setItemState = function(list, item, enable) {
      this.setCheckedBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNCHECKED)) {
              list.setItemState(item, STATUS_UNCHECKED, false);
            }
            list.setItemState(item, STATUS_CHECKED, true);
          } else if (!list.hasState(item, STATUS_CHECKED)) {
            list.setItemState(item, STATUS_UNCHECKED, true);
          }
        });
      }
    };
    ListChecked2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list_1 = triggerInfo.list, item = triggerInfo.item;
        var allChecked = !some_default(list_1.getItems(), function(t) {
          return list_1.hasState(t, STATUS_UNCHECKED);
        });
        if (allChecked || list_1.hasState(item, STATUS_UNCHECKED)) {
          this.setItemState(list_1, item, true);
        } else {
          this.reset();
        }
      }
    };
    ListChecked2.prototype.checked = function() {
      this.setState();
    };
    ListChecked2.prototype.reset = function() {
      var components = this.getAllowComponents();
      each_default(components, function(component) {
        component.clearItemsState(STATUS_CHECKED);
        component.clearItemsState(STATUS_UNCHECKED);
      });
    };
    return ListChecked2;
  }(list_state_default);
  var list_checked_default = ListChecked;

  // node_modules/@antv/g2/esm/interaction/action/mask/base.js
  var MaskBase = function(_super) {
    __extends(MaskBase2, _super);
    function MaskBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.maskShape = null;
      _this.points = [];
      _this.starting = false;
      _this.moving = false;
      _this.preMovePoint = null;
      _this.shapeType = "path";
      return _this;
    }
    MaskBase2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    MaskBase2.prototype.emitEvent = function(type) {
      var eventName = "mask:" + type;
      var view = this.context.view;
      var event = this.context.event;
      view.emit(eventName, {
        target: this.maskShape,
        shape: this.maskShape,
        points: this.points,
        x: event.x,
        y: event.y
      });
    };
    MaskBase2.prototype.createMask = function() {
      var view = this.context.view;
      var maskAttrs = this.getMaskAttrs();
      var maskShape = view.foregroundGroup.addShape({
        type: this.shapeType,
        name: "mask",
        draggable: true,
        attrs: __assign({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
      });
      return maskShape;
    };
    MaskBase2.prototype.getMaskPath = function() {
      return [];
    };
    MaskBase2.prototype.show = function() {
      if (this.maskShape) {
        this.maskShape.show();
        this.emitEvent("show");
      }
    };
    MaskBase2.prototype.start = function(arg) {
      this.starting = true;
      this.moving = false;
      this.points = [this.getCurrentPoint()];
      if (!this.maskShape) {
        this.maskShape = this.createMask();
        this.maskShape.set("capture", false);
      }
      this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
      this.emitEvent("start");
    };
    MaskBase2.prototype.moveStart = function() {
      this.moving = true;
      this.preMovePoint = this.getCurrentPoint();
    };
    MaskBase2.prototype.move = function() {
      if (!this.moving || !this.maskShape) {
        return;
      }
      var currentPoint = this.getCurrentPoint();
      var preMovePoint = this.preMovePoint;
      var dx = currentPoint.x - preMovePoint.x;
      var dy = currentPoint.y - preMovePoint.y;
      var points = this.points;
      each_default(points, function(point) {
        point.x += dx;
        point.y += dy;
      });
      this.updateMask();
      this.emitEvent("change");
      this.preMovePoint = currentPoint;
    };
    MaskBase2.prototype.updateMask = function(maskStyle) {
      var attrs = deep_mix_default({}, this.getMaskAttrs(), maskStyle);
      this.maskShape.attr(attrs);
    };
    MaskBase2.prototype.moveEnd = function() {
      this.moving = false;
      this.preMovePoint = null;
    };
    MaskBase2.prototype.end = function() {
      this.starting = false;
      this.emitEvent("end");
      if (this.maskShape) {
        this.maskShape.set("capture", true);
      }
    };
    MaskBase2.prototype.hide = function() {
      if (this.maskShape) {
        this.maskShape.hide();
        this.emitEvent("hide");
      }
    };
    MaskBase2.prototype.resize = function() {
      if (this.starting && this.maskShape) {
        this.points.push(this.getCurrentPoint());
        this.updateMask();
        this.emitEvent("change");
      }
    };
    MaskBase2.prototype.destroy = function() {
      this.points = [];
      if (this.maskShape) {
        this.maskShape.remove();
      }
      this.maskShape = null;
      this.preMovePoint = null;
      _super.prototype.destroy.call(this);
    };
    return MaskBase2;
  }(base_default13);
  var base_default18 = MaskBase;

  // node_modules/@antv/g2/esm/interaction/action/mask/circle.js
  var CircleMask = function(_super) {
    __extends(CircleMask2, _super);
    function CircleMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "circle";
      return _this;
    }
    CircleMask2.prototype.getMaskAttrs = function() {
      var points = this.points;
      var currentPoint = last(this.points);
      var r = 0;
      var x = 0;
      var y = 0;
      if (points.length) {
        var first = points[0];
        r = distance6(first, currentPoint) / 2;
        x = (currentPoint.x + first.x) / 2;
        y = (currentPoint.y + first.y) / 2;
      }
      return {
        x,
        y,
        r
      };
    };
    return CircleMask2;
  }(base_default18);
  var circle_default9 = CircleMask;

  // node_modules/@antv/g2/esm/interaction/action/mask/rect.js
  var RectMask = function(_super) {
    __extends(RectMask2, _super);
    function RectMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "rect";
      return _this;
    }
    RectMask2.prototype.getRegion = function() {
      var points = this.points;
      return {
        start: head(points),
        end: last(points)
      };
    };
    RectMask2.prototype.getMaskAttrs = function() {
      var _a4 = this.getRegion(), start = _a4.start, end = _a4.end;
      var x = Math.min(start.x, end.x);
      var y = Math.min(start.y, end.y);
      var width = Math.abs(end.x - start.x);
      var height = Math.abs(end.y - start.y);
      return {
        x,
        y,
        width,
        height
      };
    };
    return RectMask2;
  }(base_default18);
  var rect_default6 = RectMask;

  // node_modules/@antv/g2/esm/interaction/action/mask/dim-rect.js
  function clampPoint(point) {
    point.x = clamp_default(point.x, 0, 1);
    point.y = clamp_default(point.y, 0, 1);
  }
  var DimRect = function(_super) {
    __extends(DimRect2, _super);
    function DimRect2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dim = "x";
      _this.inPlot = true;
      return _this;
    }
    DimRect2.prototype.getRegion = function() {
      var start = null;
      var end = null;
      var points = this.points;
      var dim = this.dim;
      var coord = this.context.view.getCoordinate();
      var normalStart = coord.invert(head(points));
      var normalEnd = coord.invert(last(points));
      if (this.inPlot) {
        clampPoint(normalStart);
        clampPoint(normalEnd);
      }
      if (dim === "x") {
        start = coord.convert({
          x: normalStart.x,
          y: 0
        });
        end = coord.convert({
          x: normalEnd.x,
          y: 1
        });
      } else {
        start = coord.convert({
          x: 0,
          y: normalStart.y
        });
        end = coord.convert({
          x: 1,
          y: normalEnd.y
        });
      }
      return {
        start,
        end
      };
    };
    return DimRect2;
  }(rect_default6);
  var dim_rect_default = DimRect;

  // node_modules/@antv/g2/esm/interaction/action/mask/path.js
  var PathMask = function(_super) {
    __extends(PathMask2, _super);
    function PathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PathMask2.prototype.getMaskPath = function() {
      var points = this.points;
      var path = [];
      if (points.length) {
        each_default(points, function(point, index) {
          if (index === 0) {
            path.push(["M", point.x, point.y]);
          } else {
            path.push(["L", point.x, point.y]);
          }
        });
        path.push(["L", points[0].x, points[0].y]);
      }
      return path;
    };
    PathMask2.prototype.getMaskAttrs = function() {
      return {
        path: this.getMaskPath()
      };
    };
    PathMask2.prototype.addPoint = function() {
      this.resize();
    };
    return PathMask2;
  }(base_default18);
  var path_default7 = PathMask;

  // node_modules/@antv/g2/esm/interaction/action/mask/smooth-path.js
  var SmoothPathMask = function(_super) {
    __extends(SmoothPathMask2, _super);
    function SmoothPathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SmoothPathMask2.prototype.getMaskPath = function() {
      var points = this.points;
      return getSpline(points, true);
    };
    return SmoothPathMask2;
  }(path_default7);
  var smooth_path_default = SmoothPathMask;

  // node_modules/@antv/g2/esm/interaction/action/cursor.js
  var CursorAction = function(_super) {
    __extends(CursorAction2, _super);
    function CursorAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CursorAction2.prototype.setCursor = function(cursor) {
      var view = this.context.view;
      view.getCanvas().setCursor(cursor);
    };
    CursorAction2.prototype.default = function() {
      this.setCursor("default");
    };
    CursorAction2.prototype.pointer = function() {
      this.setCursor("pointer");
    };
    CursorAction2.prototype.move = function() {
      this.setCursor("move");
    };
    CursorAction2.prototype.crosshair = function() {
      this.setCursor("crosshair");
    };
    CursorAction2.prototype.wait = function() {
      this.setCursor("wait");
    };
    CursorAction2.prototype.help = function() {
      this.setCursor("help");
    };
    CursorAction2.prototype.text = function() {
      this.setCursor("text");
    };
    CursorAction2.prototype.eResize = function() {
      this.setCursor("e-resize");
    };
    CursorAction2.prototype.wResize = function() {
      this.setCursor("w-resize");
    };
    CursorAction2.prototype.nResize = function() {
      this.setCursor("n-resize");
    };
    CursorAction2.prototype.sResize = function() {
      this.setCursor("s-resize");
    };
    CursorAction2.prototype.neResize = function() {
      this.setCursor("ne-resize");
    };
    CursorAction2.prototype.nwResize = function() {
      this.setCursor("nw-resize");
    };
    CursorAction2.prototype.seResize = function() {
      this.setCursor("se-resize");
    };
    CursorAction2.prototype.swResize = function() {
      this.setCursor("sw-resize");
    };
    CursorAction2.prototype.nsResize = function() {
      this.setCursor("ns-resize");
    };
    CursorAction2.prototype.ewResize = function() {
      this.setCursor("ew-resize");
    };
    return CursorAction2;
  }(base_default13);
  var cursor_default = CursorAction;

  // node_modules/@antv/g2/esm/interaction/action/data/filter.js
  var DataFilter = function(_super) {
    __extends(DataFilter2, _super);
    function DataFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataFilter2.prototype.filterView = function(view, field, filter2) {
      var _this = this;
      if (view.getScaleByField(field)) {
        view.filter(field, filter2);
      }
      if (view.views && view.views.length) {
        each_default(view.views, function(subView) {
          _this.filterView(subView, field, filter2);
        });
      }
    };
    DataFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      if (delegateObject) {
        var view = this.context.view;
        var component = delegateObject.component;
        var field = component.get("field");
        if (isList(delegateObject)) {
          if (field) {
            var unCheckedItems = component.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            if (names_1.length) {
              this.filterView(view, field, function(value) {
                var text = scale_1.getText(value);
                return !names_1.includes(text);
              });
            } else {
              this.filterView(view, field, null);
            }
            view.render(true);
          }
        } else if (isSlider(delegateObject)) {
          var range = component.getValue();
          var min_1 = range[0], max_1 = range[1];
          this.filterView(view, field, function(value) {
            return value >= min_1 && value <= max_1;
          });
          view.render(true);
        }
      }
    };
    return DataFilter2;
  }(base_default13);
  var filter_default2 = DataFilter;

  // node_modules/@antv/g2/esm/interaction/action/data/range-filter.js
  function getFilter(scale4, dim, point1, point2) {
    var min3 = Math.min(point1[dim], point2[dim]);
    var max3 = Math.max(point1[dim], point2[dim]);
    var _a4 = scale4.range, rangeMin = _a4[0], rangeMax = _a4[1];
    if (min3 < rangeMin) {
      min3 = rangeMin;
    }
    if (max3 > rangeMax) {
      max3 = rangeMax;
    }
    if (min3 === rangeMax && max3 === rangeMax) {
      return null;
    }
    var minValue = scale4.invert(min3);
    var maxValue = scale4.invert(max3);
    if (scale4.isCategory) {
      var minIndex = scale4.values.indexOf(minValue);
      var maxIndex = scale4.values.indexOf(maxValue);
      var arr_1 = scale4.values.slice(minIndex, maxIndex + 1);
      return function(value) {
        return arr_1.includes(value);
      };
    } else {
      return function(value) {
        return value >= minValue && value <= maxValue;
      };
    }
  }
  var EVENTS4;
  (function(EVENTS5) {
    EVENTS5["FILTER"] = "brush-filter-processing";
    EVENTS5["RESET"] = "brush-filter-reset";
    EVENTS5["BEFORE_FILTER"] = "brush-filter:beforefilter";
    EVENTS5["AFTER_FILTER"] = "brush-filter:afterfilter";
    EVENTS5["BEFORE_RESET"] = "brush-filter:beforereset";
    EVENTS5["AFTER_RESET"] = "brush-filter:afterreset";
  })(EVENTS4 || (EVENTS4 = {}));
  var RangeFilter = function(_super) {
    __extends(RangeFilter2, _super);
    function RangeFilter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = ["x", "y"];
      _this.startPoint = null;
      _this.isStarted = false;
      return _this;
    }
    RangeFilter2.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    RangeFilter2.prototype.start = function() {
      var context = this.context;
      this.isStarted = true;
      this.startPoint = context.getCurrentPoint();
    };
    RangeFilter2.prototype.filter = function() {
      var startPoint;
      var currentPoint;
      if (isMask(this.context)) {
        var maskShape = this.context.event.target;
        var bbox = maskShape.getCanvasBBox();
        startPoint = { x: bbox.x, y: bbox.y };
        currentPoint = { x: bbox.maxX, y: bbox.maxY };
      } else {
        if (!this.isStarted) {
          return;
        }
        startPoint = this.startPoint;
        currentPoint = this.context.getCurrentPoint();
      }
      if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
        return;
      }
      var _a4 = this.context, view = _a4.view, event = _a4.event;
      var payload = { view, event, dims: this.dims };
      view.emit(EVENTS4.BEFORE_FILTER, event_default.fromData(view, EVENTS4.BEFORE_FILTER, payload));
      var coord = view.getCoordinate();
      var normalCurrent = coord.invert(currentPoint);
      var normalStart = coord.invert(startPoint);
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        var filter2 = getFilter(xScale, "x", normalCurrent, normalStart);
        this.filterView(view, xScale.field, filter2);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        var filter2 = getFilter(yScale, "y", normalCurrent, normalStart);
        this.filterView(view, yScale.field, filter2);
      }
      this.reRender(view, { source: EVENTS4.FILTER });
      view.emit(EVENTS4.AFTER_FILTER, event_default.fromData(view, EVENTS4.AFTER_FILTER, payload));
    };
    RangeFilter2.prototype.end = function() {
      this.isStarted = false;
    };
    RangeFilter2.prototype.reset = function() {
      var view = this.context.view;
      view.emit(EVENTS4.BEFORE_RESET, event_default.fromData(view, EVENTS4.BEFORE_RESET, {}));
      this.isStarted = false;
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        this.filterView(view, xScale.field, null);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        this.filterView(view, yScale.field, null);
      }
      this.reRender(view, { source: EVENTS4.RESET });
      view.emit(EVENTS4.AFTER_RESET, event_default.fromData(view, EVENTS4.AFTER_RESET, {}));
    };
    RangeFilter2.prototype.filterView = function(view, field, filter2) {
      view.filter(field, filter2);
    };
    RangeFilter2.prototype.reRender = function(view, payload) {
      view.render(true, payload);
    };
    return RangeFilter2;
  }(base_default13);
  var range_filter_default = RangeFilter;

  // node_modules/@antv/g2/esm/interaction/action/data/sibling-filter.js
  var SiblingFilter = function(_super) {
    __extends(SiblingFilter3, _super);
    function SiblingFilter3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingFilter3.prototype.filterView = function(view, field, filter2) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.filter(field, filter2);
      });
    };
    SiblingFilter3.prototype.reRender = function(view) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.render(true);
      });
    };
    return SiblingFilter3;
  }(range_filter_default);
  var sibling_filter_default = SiblingFilter;

  // node_modules/@antv/g2/esm/interaction/action/element/filter.js
  var ElementFilter = function(_super) {
    __extends(ElementFilter2, _super);
    function ElementFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      var view = this.context.view;
      var elements = getElements(view);
      if (isMask(this.context)) {
        var maskElements_1 = getMaskedElements(this.context, 10);
        if (maskElements_1) {
          each_default(elements, function(el) {
            if (maskElements_1.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      } else if (delegateObject) {
        var component = delegateObject.component;
        var field_1 = component.get("field");
        if (isList(delegateObject)) {
          if (field_1) {
            var unCheckedItems = component.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field_1);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            each_default(elements, function(el) {
              var value = getElementValue(el, field_1);
              var text = scale_1.getText(value);
              if (names_1.indexOf(text) >= 0) {
                el.hide();
              } else {
                el.show();
              }
            });
          }
        } else if (isSlider(delegateObject)) {
          var range = component.getValue();
          var min_1 = range[0], max_1 = range[1];
          each_default(elements, function(el) {
            var value = getElementValue(el, field_1);
            if (value >= min_1 && value <= max_1) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      }
    };
    ElementFilter2.prototype.clear = function() {
      var elements = getElements(this.context.view);
      each_default(elements, function(el) {
        el.show();
      });
    };
    ElementFilter2.prototype.reset = function() {
      this.clear();
    };
    return ElementFilter2;
  }(base_default13);
  var filter_default3 = ElementFilter;

  // node_modules/@antv/g2/esm/interaction/action/element/sibling-filter.js
  var SiblingFilter2 = function(_super) {
    __extends(SiblingFilter3, _super);
    function SiblingFilter3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.byRecord = false;
      return _this;
    }
    SiblingFilter3.prototype.filter = function() {
      if (isMask(this.context)) {
        if (this.byRecord) {
          this.filterByRecord();
        } else {
          this.filterByBBox();
        }
      }
    };
    SiblingFilter3.prototype.filterByRecord = function() {
      var view = this.context.view;
      var maskElements = getMaskedElements(this.context, 10);
      if (!maskElements) {
        return;
      }
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      var records = maskElements.map(function(el) {
        return el.getModel().data;
      });
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var elements = getElements(sibling);
        each_default(elements, function(el) {
          var record = el.getModel().data;
          if (isInRecords(records, record, xFiled, yField)) {
            el.show();
          } else {
            el.hide();
          }
        });
      });
    };
    SiblingFilter3.prototype.filterByBBox = function() {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
        var elements = getElements(sibling);
        if (maskElements) {
          each_default(elements, function(el) {
            if (maskElements.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      });
    };
    SiblingFilter3.prototype.reset = function() {
      var siblings = getSilbings(this.context.view);
      each_default(siblings, function(sibling) {
        var elements = getElements(sibling);
        each_default(elements, function(el) {
          el.show();
        });
      });
    };
    return SiblingFilter3;
  }(base_default13);
  var sibling_filter_default2 = SiblingFilter2;

  // node_modules/@antv/g2/esm/interaction/action/view/button.js
  var PADDING_RIGHT = 10;
  var PADDING_TOP = 5;
  var ButtonAction = function(_super) {
    __extends(ButtonAction2, _super);
    function ButtonAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonGroup = null;
      _this.buttonCfg = {
        name: "button",
        text: "button",
        textStyle: {
          x: 0,
          y: 0,
          fontSize: 12,
          fill: "#333333",
          cursor: "pointer"
        },
        padding: [8, 10],
        style: {
          fill: "#f7f7f7",
          stroke: "#cccccc",
          cursor: "pointer"
        },
        activeStyle: {
          fill: "#e6e6e6"
        }
      };
      return _this;
    }
    ButtonAction2.prototype.getButtonCfg = function() {
      return deep_mix_default(this.buttonCfg, this.cfg);
    };
    ButtonAction2.prototype.drawButton = function() {
      var config = this.getButtonCfg();
      var group2 = this.context.view.foregroundGroup.addGroup({
        name: config.name
      });
      var textShape = group2.addShape({
        type: "text",
        name: "button-text",
        attrs: __assign({ text: config.text }, config.textStyle)
      });
      var textBBox = textShape.getBBox();
      var padding = parsePadding(config.padding);
      var buttonShape = group2.addShape({
        type: "rect",
        name: "button-rect",
        attrs: __assign({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2] }, config.style)
      });
      buttonShape.toBack();
      group2.on("mouseenter", function() {
        buttonShape.attr(config.activeStyle);
      });
      group2.on("mouseleave", function() {
        buttonShape.attr(config.style);
      });
      this.buttonGroup = group2;
    };
    ButtonAction2.prototype.resetPosition = function() {
      var view = this.context.view;
      var coord = view.getCoordinate();
      var point = coord.convert({ x: 1, y: 1 });
      var buttonGroup = this.buttonGroup;
      var bbox = buttonGroup.getBBox();
      var matrix = ext_exports.transform(null, [
        ["t", point.x - bbox.width - PADDING_RIGHT, point.y + bbox.height + PADDING_TOP]
      ]);
      buttonGroup.setMatrix(matrix);
    };
    ButtonAction2.prototype.show = function() {
      if (!this.buttonGroup) {
        this.drawButton();
      }
      this.resetPosition();
      this.buttonGroup.show();
    };
    ButtonAction2.prototype.hide = function() {
      if (this.buttonGroup) {
        this.buttonGroup.hide();
      }
    };
    ButtonAction2.prototype.destroy = function() {
      var buttonGroup = this.buttonGroup;
      if (buttonGroup) {
        buttonGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return ButtonAction2;
  }(base_default13);
  var button_default = ButtonAction;

  // node_modules/@antv/g2/esm/interaction/action/view/drag.js
  var DISTANCE = 4;
  var Drag = function(_super) {
    __extends(Drag2, _super);
    function Drag2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.dragStart = false;
      return _this;
    }
    Drag2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
    };
    Drag2.prototype.drag = function() {
      if (!this.startPoint) {
        return;
      }
      var current = this.context.getCurrentPoint();
      var view = this.context.view;
      var event = this.context.event;
      if (!this.dragStart) {
        if (distance6(current, this.startPoint) > DISTANCE) {
          view.emit("dragstart", {
            target: event.target,
            x: event.x,
            y: event.y
          });
          this.dragStart = true;
        }
      } else {
        view.emit("drag", {
          target: event.target,
          x: event.x,
          y: event.y
        });
      }
    };
    Drag2.prototype.end = function() {
      if (this.dragStart) {
        var view = this.context.view;
        var event_1 = this.context.event;
        view.emit("dragend", {
          target: event_1.target,
          x: event_1.x,
          y: event_1.y
        });
      }
      this.starting = false;
      this.dragStart = false;
    };
    return Drag2;
  }(base_default13);
  var drag_default = Drag;

  // node_modules/@antv/g2/esm/interaction/action/view/move.js
  var MIN_DISTANCE = 5;
  var Move = function(_super) {
    __extends(Move2, _super);
    function Move2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.isMoving = false;
      _this.startPoint = null;
      _this.startMatrix = null;
      return _this;
    }
    Move2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
      this.startMatrix = this.context.view.middleGroup.getMatrix();
    };
    Move2.prototype.move = function() {
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var currentPoint = this.context.getCurrentPoint();
      var d = distance6(startPoint, currentPoint);
      if (d > MIN_DISTANCE && !this.isMoving) {
        this.isMoving = true;
      }
      if (this.isMoving) {
        var view = this.context.view;
        var matrix = ext_exports.transform(this.startMatrix, [
          ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
        ]);
        view.backgroundGroup.setMatrix(matrix);
        view.foregroundGroup.setMatrix(matrix);
        view.middleGroup.setMatrix(matrix);
      }
    };
    Move2.prototype.end = function() {
      if (this.isMoving) {
        this.isMoving = false;
      }
      this.startMatrix = null;
      this.starting = false;
      this.startPoint = null;
    };
    Move2.prototype.reset = function() {
      this.starting = false;
      this.startPoint = null;
      this.isMoving = false;
      var view = this.context.view;
      view.backgroundGroup.resetMatrix();
      view.foregroundGroup.resetMatrix();
      view.middleGroup.resetMatrix();
      this.isMoving = false;
    };
    return Move2;
  }(base_default13);
  var move_default = Move;

  // node_modules/@antv/g2/esm/interaction/action/view/scale-transform.js
  var DIM_X = "x";
  var DIM_Y = "y";
  var ScaleTranslate = function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = [DIM_X, DIM_Y];
      _this.cfgFields = ["dims"];
      _this.cacheScaleDefs = {};
      return _this;
    }
    ScaleTranslate4.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    ScaleTranslate4.prototype.getScale = function(dim) {
      var view = this.context.view;
      if (dim === "x") {
        return view.getXScale();
      } else {
        return view.getYScales()[0];
      }
    };
    ScaleTranslate4.prototype.resetDim = function(dim) {
      var view = this.context.view;
      if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
        var scale4 = this.getScale(dim);
        view.scale(scale4.field, this.cacheScaleDefs[dim]);
        this.cacheScaleDefs[dim] = null;
      }
    };
    ScaleTranslate4.prototype.reset = function() {
      this.resetDim(DIM_X);
      this.resetDim(DIM_Y);
      var view = this.context.view;
      view.render(true);
    };
    return ScaleTranslate4;
  }(base_default13);
  var scale_transform_default = ScaleTranslate;

  // node_modules/@antv/g2/esm/interaction/action/view/scale-translate.js
  var ScaleTranslate2 = function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.starting = false;
      _this.startCache = {};
      return _this;
    }
    ScaleTranslate4.prototype.start = function() {
      var _this = this;
      this.startPoint = this.context.getCurrentPoint();
      this.starting = true;
      var dims = this.dims;
      each_default(dims, function(dim) {
        var scale4 = _this.getScale(dim);
        var min3 = scale4.min, max3 = scale4.max, values2 = scale4.values;
        _this.startCache[dim] = { min: min3, max: max3, values: values2 };
      });
    };
    ScaleTranslate4.prototype.end = function() {
      this.startPoint = null;
      this.starting = false;
      this.startCache = {};
    };
    ScaleTranslate4.prototype.translate = function() {
      var _this = this;
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var coord = this.context.view.getCoordinate();
      var currentPoint = this.context.getCurrentPoint();
      var normalStart = coord.invert(startPoint);
      var noramlCurrent = coord.invert(currentPoint);
      var dx = noramlCurrent.x - normalStart.x;
      var dy = noramlCurrent.y - normalStart.y;
      var view = this.context.view;
      var dims = this.dims;
      each_default(dims, function(dim) {
        _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
      });
      view.render(true);
    };
    ScaleTranslate4.prototype.translateDim = function(dim, normalPoint) {
      if (this.hasDim(dim)) {
        var scale4 = this.getScale(dim);
        if (scale4.isLinear) {
          this.translateLinear(dim, scale4, normalPoint);
        }
      }
    };
    ScaleTranslate4.prototype.translateLinear = function(dim, scale4, normalPoint) {
      var view = this.context.view;
      var _a4 = this.startCache[dim], min3 = _a4.min, max3 = _a4.max;
      var range = max3 - min3;
      var d = normalPoint[dim] * range;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          nice: scale4.nice,
          min: min3,
          max: max3
        };
      }
      view.scale(scale4.field, {
        nice: false,
        min: min3 + d,
        max: max3 + d
      });
    };
    ScaleTranslate4.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.startPoint = null;
      this.starting = false;
    };
    return ScaleTranslate4;
  }(scale_transform_default);
  var scale_translate_default = ScaleTranslate2;

  // node_modules/@antv/g2/esm/interaction/action/view/scale-zoom.js
  var ScaleTranslate3 = function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.zoomRatio = 0.05;
      return _this;
    }
    ScaleTranslate4.prototype.zoomIn = function() {
      this.zoom(this.zoomRatio);
    };
    ScaleTranslate4.prototype.zoom = function(scale4) {
      var _this = this;
      var dims = this.dims;
      each_default(dims, function(dim) {
        _this.zoomDim(dim, scale4);
      });
      this.context.view.render(true);
    };
    ScaleTranslate4.prototype.zoomOut = function() {
      this.zoom(-1 * this.zoomRatio);
    };
    ScaleTranslate4.prototype.zoomDim = function(dim, dRatio) {
      if (this.hasDim(dim)) {
        var scale4 = this.getScale(dim);
        if (scale4.isLinear) {
          this.zoomLinear(dim, scale4, dRatio);
        }
      }
    };
    ScaleTranslate4.prototype.zoomLinear = function(dim, scale4, dRatio) {
      var view = this.context.view;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          nice: scale4.nice,
          min: scale4.min,
          max: scale4.max
        };
      }
      var scaleDef = this.cacheScaleDefs[dim];
      var range = scaleDef.max - scaleDef.min;
      var min3 = scale4.min, max3 = scale4.max;
      var d = dRatio * range;
      var toMin = min3 - d;
      var toMax = max3 + d;
      var curRange = toMax - toMin;
      var scaled = curRange / range;
      if (toMax > toMin && scaled < 100 && scaled > 0.01) {
        view.scale(scale4.field, {
          nice: false,
          min: min3 - d,
          max: max3 + d
        });
      }
    };
    return ScaleTranslate4;
  }(scale_transform_default);
  var scale_zoom_default = ScaleTranslate3;

  // node_modules/@antv/g2/esm/interaction/action/view/mousewheel-scroll.js
  function isWheelDown(event) {
    var wheelEvent = event.gEvent.originalEvent;
    return wheelEvent.deltaY > 0;
  }
  var DEFAULT_WHEELDELTA = 1;
  var MousewheelScroll = function(_super) {
    __extends(MousewheelScroll2, _super);
    function MousewheelScroll2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MousewheelScroll2.prototype.scroll = function(arg) {
      var _a4 = this.context, view = _a4.view, event = _a4.event;
      if (!view.getOptions().scrollbar) {
        return;
      }
      var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
      var scrollbarController = view.getController("scrollbar");
      var xScale = view.getXScale();
      var data = view.getOptions().data;
      var dataSize = size2(values_of_key_default(data, xScale.field));
      var step = size2(xScale.values);
      var currentRatio = scrollbarController.getValue();
      var currentStart = Math.floor((dataSize - step) * currentRatio);
      var nextStart = currentStart + (isWheelDown(event) ? wheelDelta : -wheelDelta);
      var correction = wheelDelta / (dataSize - step) / 1e4;
      var nextRatio = clamp_default(nextStart / (dataSize - step) + correction, 0, 1);
      scrollbarController.setValue(nextRatio);
    };
    return MousewheelScroll2;
  }(base_default13);
  var mousewheel_scroll_default = MousewheelScroll;

  // node_modules/@antv/g2/esm/index.js
  registerTheme("dark", createThemeByStyleSheet(antvDark));
  registerEngine("canvas", esm_exports);
  registerEngine("svg", esm_exports2);
  registerGeometry("Polygon", polygon_default6);
  registerGeometry("Interval", interval_default);
  registerGeometry("Schema", schema_default);
  registerGeometry("Path", path_default6);
  registerGeometry("Point", point_default);
  registerGeometry("Line", line_default10);
  registerGeometry("Area", area_default);
  registerGeometry("Edge", edge_default);
  registerGeometry("Heatmap", heatmap_default);
  registerGeometry("Violin", violin_default);
  registerGeometryLabel("base", base_default15);
  registerGeometryLabel("interval", interval_default2);
  registerGeometryLabel("pie", pie_default);
  registerGeometryLabel("polar", polar_default2);
  registerGeometryLabelLayout("overlap", overlap);
  registerGeometryLabelLayout("distribute", distribute);
  registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
  registerGeometryLabelLayout("hide-overlap", hideOverlap);
  registerGeometryLabelLayout("limit-in-shape", limitInShape);
  registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
  registerGeometryLabelLayout("limit-in-plot", limitInPlot);
  registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
  registerGeometryLabelLayout("adjust-color", adjustColor);
  registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
  registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
  registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
  registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
  registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
  registerAnimation("fade-in", fadeIn);
  registerAnimation("fade-out", fadeOut);
  registerAnimation("grow-in-x", growInX);
  registerAnimation("grow-in-xy", growInXY);
  registerAnimation("grow-in-y", growInY);
  registerAnimation("scale-in-x", scaleInX);
  registerAnimation("scale-in-y", scaleInY);
  registerAnimation("wave-in", waveIn);
  registerAnimation("zoom-in", zoomIn);
  registerAnimation("zoom-out", zoomOut);
  registerAnimation("position-update", positionUpdate);
  registerAnimation("sector-path-update", sectorPathUpdate);
  registerAnimation("path-in", pathIn);
  registerFacet("rect", rect_default5);
  registerFacet("mirror", mirror_default);
  registerFacet("list", list_default);
  registerFacet("matrix", matrix_default);
  registerFacet("circle", circle_default8);
  registerFacet("tree", tree_default);
  registerComponentController("axis", axis_default);
  registerComponentController("legend", legend_default);
  registerComponentController("tooltip", tooltip_default);
  registerComponentController("annotation", annotation_default);
  registerComponentController("slider", slider_default);
  registerComponentController("scrollbar", scrollbar_default);
  registerAction("tooltip", geometry_default);
  registerAction("sibling-tooltip", sibling_default);
  registerAction("ellipsis-text", ellipsis_text_default);
  registerAction("element-active", active_default);
  registerAction("element-single-active", single_active_default);
  registerAction("element-range-active", range_active_default);
  registerAction("element-highlight", highlight_default);
  registerAction("element-highlight-by-x", highlight_by_x_default);
  registerAction("element-highlight-by-color", highlight_by_color_default);
  registerAction("element-single-highlight", single_highlight_default);
  registerAction("element-range-highlight", range_highlight_default);
  registerAction("element-sibling-highlight", range_highlight_default, {
    effectSiblings: true,
    effectByRecord: true
  });
  registerAction("element-selected", selected_default);
  registerAction("element-single-selected", single_selected_default);
  registerAction("element-range-selected", range_selected_default);
  registerAction("element-link-by-color", link_by_color_default);
  registerAction("active-region", active_region_default);
  registerAction("list-active", list_active_default);
  registerAction("list-selected", list_selected_default);
  registerAction("list-highlight", list_highlight_default);
  registerAction("list-unchecked", list_unchecked_default);
  registerAction("list-checked", list_checked_default);
  registerAction("legend-item-highlight", list_highlight_default, {
    componentNames: ["legend"]
  });
  registerAction("axis-label-highlight", list_highlight_default, {
    componentNames: ["axis"]
  });
  registerAction("rect-mask", rect_default6);
  registerAction("x-rect-mask", dim_rect_default, { dim: "x" });
  registerAction("y-rect-mask", dim_rect_default, { dim: "y" });
  registerAction("circle-mask", circle_default9);
  registerAction("path-mask", path_default7);
  registerAction("smooth-path-mask", smooth_path_default);
  registerAction("cursor", cursor_default);
  registerAction("data-filter", filter_default2);
  registerAction("brush", range_filter_default);
  registerAction("brush-x", range_filter_default, { dims: ["x"] });
  registerAction("brush-y", range_filter_default, { dims: ["y"] });
  registerAction("sibling-filter", sibling_filter_default);
  registerAction("sibling-x-filter", sibling_filter_default);
  registerAction("sibling-y-filter", sibling_filter_default);
  registerAction("element-filter", filter_default3);
  registerAction("element-sibling-filter", sibling_filter_default2);
  registerAction("element-sibling-filter-record", sibling_filter_default2, { byRecord: true });
  registerAction("view-drag", drag_default);
  registerAction("view-move", move_default);
  registerAction("scale-translate", scale_translate_default);
  registerAction("scale-zoom", scale_zoom_default);
  registerAction("reset-button", button_default, {
    name: "reset-button",
    text: "reset"
  });
  registerAction("mousewheel-scroll", mousewheel_scroll_default);
  function isPointInView(context) {
    return context.isInPlot();
  }
  registerInteraction("tooltip", {
    start: [
      { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
      { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
    ],
    end: [
      { trigger: "plot:mouseleave", action: "tooltip:hide" },
      { trigger: "plot:leave", action: "tooltip:hide" },
      { trigger: "plot:touchend", action: "tooltip:hide" }
    ]
  });
  registerInteraction("ellipsis-text", {
    start: [
      {
        trigger: "legend-item-name:mousemove",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      },
      {
        trigger: "legend-item-name:touchstart",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      },
      {
        trigger: "axis-label:mousemove",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      },
      {
        trigger: "axis-label:touchstart",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      }
    ],
    end: [
      { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
      { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
      { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
      { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
    ]
  });
  registerInteraction("element-active", {
    start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
    end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
  });
  registerInteraction("element-selected", {
    start: [{ trigger: "element:click", action: "element-selected:toggle" }]
  });
  registerInteraction("element-highlight", {
    start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
    end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
  });
  registerInteraction("element-highlight-by-x", {
    start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
    end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
  });
  registerInteraction("element-highlight-by-color", {
    start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
    end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
  });
  registerInteraction("legend-active", {
    start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
    end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
  });
  registerInteraction("legend-highlight", {
    start: [
      { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
    ],
    end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
  });
  registerInteraction("axis-label-highlight", {
    start: [
      { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
    ],
    end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
  });
  registerInteraction("element-list-highlight", {
    start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
    end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
  });
  registerInteraction("element-range-highlight", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "mask:mouseenter", action: "cursor:move" },
      { trigger: "plot:mouseleave", action: "cursor:default" },
      { trigger: "mask:mouseleave", action: "cursor:crosshair" }
    ],
    start: [
      {
        trigger: "plot:mousedown",
        isEnable: function(context) {
          return !context.isInShape("mask");
        },
        action: ["rect-mask:start", "rect-mask:show"]
      },
      {
        trigger: "mask:dragstart",
        action: ["rect-mask:moveStart"]
      }
    ],
    processing: [
      {
        trigger: "plot:mousemove",
        action: ["rect-mask:resize"]
      },
      {
        trigger: "mask:drag",
        action: ["rect-mask:move"]
      },
      {
        trigger: "mask:change",
        action: ["element-range-highlight:highlight"]
      }
    ],
    end: [
      { trigger: "plot:mouseup", action: ["rect-mask:end"] },
      { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
      {
        trigger: "document:mouseup",
        isEnable: function(context) {
          return !context.isInPlot();
        },
        action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
      }
    ],
    rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
  });
  registerInteraction("brush", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      {
        trigger: "mousedown",
        isEnable: isPointInView,
        action: ["brush:start", "rect-mask:start", "rect-mask:show"]
      }
    ],
    processing: [
      {
        trigger: "mousemove",
        isEnable: isPointInView,
        action: ["rect-mask:resize"]
      }
    ],
    end: [
      {
        trigger: "mouseup",
        isEnable: isPointInView,
        action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
      }
    ],
    rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
  });
  registerInteraction("brush-visible", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      {
        trigger: "plot:mousedown",
        action: ["rect-mask:start", "rect-mask:show"]
      }
    ],
    processing: [
      {
        trigger: "plot:mousemove",
        action: ["rect-mask:resize"]
      },
      { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
    ],
    end: [
      {
        trigger: "plot:mouseup",
        action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
      }
    ],
    rollback: [
      {
        trigger: "dblclick",
        action: ["element-filter:clear"]
      }
    ]
  });
  registerInteraction("brush-x", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      {
        trigger: "mousedown",
        isEnable: isPointInView,
        action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
      }
    ],
    processing: [
      {
        trigger: "mousemove",
        isEnable: isPointInView,
        action: ["x-rect-mask:resize"]
      }
    ],
    end: [
      {
        trigger: "mouseup",
        isEnable: isPointInView,
        action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
      }
    ],
    rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
  });
  registerInteraction("element-path-highlight", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:start" },
      { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:show" }
    ],
    processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
    end: [{ trigger: "mouseup", action: "path-mask:end" }],
    rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
  });
  registerInteraction("element-single-selected", {
    start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
  });
  registerInteraction("legend-filter", {
    showEnable: [
      { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
      { trigger: "legend-item:mouseleave", action: "cursor:default" }
    ],
    start: [{ trigger: "legend-item:click", action: ["list-unchecked:toggle", "data-filter:filter"] }]
  });
  registerInteraction("continuous-filter", {
    start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
  });
  registerInteraction("continuous-visible-filter", {
    start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
  });
  registerInteraction("legend-visible-filter", {
    showEnable: [
      { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
      { trigger: "legend-item:mouseleave", action: "cursor:default" }
    ],
    start: [{ trigger: "legend-item:click", action: ["list-unchecked:toggle", "element-filter:filter"] }]
  });
  registerInteraction("active-region", {
    start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
    end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
  });
  function isWheelDown2(event) {
    event.gEvent.preventDefault();
    return event.gEvent.originalEvent.deltaY > 0;
  }
  registerInteraction("view-zoom", {
    start: [
      {
        trigger: "plot:mousewheel",
        isEnable: function(context) {
          return isWheelDown2(context.event);
        },
        action: "scale-zoom:zoomOut",
        throttle: { wait: 100, leading: true, trailing: false }
      },
      {
        trigger: "plot:mousewheel",
        isEnable: function(context) {
          return !isWheelDown2(context.event);
        },
        action: "scale-zoom:zoomIn",
        throttle: { wait: 100, leading: true, trailing: false }
      }
    ]
  });
  registerInteraction("sibling-tooltip", {
    start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
    end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
  });
  registerInteraction("plot-mousewheel-scroll", {
    start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
  });

  // hw2/client/dev/app.tsx
  var ZipfChart = defineComponent((_6, { slots }) => {
    const chartRef = ref(null);
    let chart;
    const tokenNum = ref(1);
    const range = ref({ min: 1, max: 1 });
    const useStemmer = ref(true);
    let zipf = [];
    onMounted(() => {
      chart = new chart_default({
        container: chartRef.value,
        autoFit: true,
        height: 300
      });
      changeStemmer(true);
    });
    const inputMin = (e) => {
      range.value = { min: Number(e.target.value), max: range.value.max };
      chart.data(zipf.slice(range.value.min - 1, range.value.max));
      chart.render();
    };
    const inputMax = (e) => {
      range.value = { max: Number(e.target.value), min: range.value.min };
      chart.data(zipf.slice(range.value.min - 1, range.value.max));
      chart.render();
    };
    const changeStemmer = (_useStemmer) => {
      useStemmer.value = _useStemmer;
      slots.changeStemmer(useStemmer.value);
      fetch(`./zipf/${_useStemmer}`).then((res) => res.json()).then((zipfData) => {
        zipf = zipfData;
        tokenNum.value = zipf.length;
        range.value = {
          min: Math.ceil(tokenNum.value * 0.01),
          max: Math.ceil(tokenNum.value * 0.05)
        };
        chart.data(zipf.slice(range.value.min - 1, range.value.max));
        chart.scale("count", {
          nice: true
        });
        chart.tooltip({
          showMarkers: false
        });
        chart.interaction("active-region");
        chart.interval().position("token*count");
        chart.render();
      });
    };
    return () => /* @__PURE__ */ h("div", {
      style: "position: relative;"
    }, /* @__PURE__ */ h("div", {
      ref: chartRef
    }), /* @__PURE__ */ h("br", null), /* @__PURE__ */ h("input", {
      type: "number",
      value: range.value.min,
      max: range.value.max,
      min: "1",
      step: "1",
      onChange: inputMin
    }), /* @__PURE__ */ h("button", {
      style: [
        "position: absolute;",
        "left: 50%;",
        "transform: translate(-50%,0%);"
      ],
      class: [useStemmer.value ? "on" : ""],
      onClick: () => changeStemmer(!useStemmer.value)
    }, "stemmer"), /* @__PURE__ */ h("input", {
      type: "number",
      value: range.value.max,
      max: tokenNum.value,
      min: range.value.min,
      step: "1",
      onChange: inputMax,
      style: "right:0px; position: absolute;"
    }));
  });
  var pageListFn = (page, numOfPage, toPage) => {
    let max3 = Math.min(numOfPage, page + 2);
    let min3 = Math.max(1, page - 2);
    if (max3 - min3 != 4 && (min3 != 1 || max3 != numOfPage)) {
      if (min3 == 1) {
        max3 = min3 + 4;
      } else if (max3 == numOfPage) {
        min3 = max3 - 4;
      }
    }
    max3 = Math.min(numOfPage, max3);
    min3 = Math.max(1, min3);
    let pageIndices = Array(max3 - min3 + 1).fill(0).map((_6, idx) => idx + min3);
    return /* @__PURE__ */ h("div", {
      style: "width:fit-content;margin-left:auto;margin-right:auto;"
    }, /* @__PURE__ */ h("div", {
      class: "page-button",
      onClick: toPage(1)
    }, "<<"), /* @__PURE__ */ h("div", {
      class: "page-button",
      onClick: toPage(page - 1)
    }, "<"), pageIndices.map((pageIdx) => {
      if (pageIdx == page) {
        return /* @__PURE__ */ h("div", {
          class: "page-button page-button-focus",
          onClick: toPage(pageIdx)
        }, pageIdx);
      } else {
        return /* @__PURE__ */ h("div", {
          class: "page-button",
          onClick: toPage(pageIdx)
        }, pageIdx);
      }
    }), /* @__PURE__ */ h("div", {
      class: "page-button",
      onClick: toPage(page + 1)
    }, ">"), /* @__PURE__ */ h("div", {
      class: "page-button",
      onClick: toPage(numOfPage)
    }, ">>"));
  };
  var App = defineComponent((_6, { slots }) => {
    let keyWord = ref("");
    let docs = ref([]);
    let suggest = ref([]);
    let page = ref(1);
    let numOfDocPerPage = 10;
    let numOfPage = ref(0);
    let numOfDoc = ref(0);
    let useStemmer = ref(true);
    let search = (e) => {
      if (e.target.value != "") {
        keyWord.value = e.target.value;
        fetch(`./keyWord/${keyWord.value}/${useStemmer.value}`).then((res) => res.json()).catch((err) => console.error(err)).then(({
          numOfDoc: _numOfDoc,
          suggest: _suggest
        }) => {
          numOfDoc.value = _numOfDoc;
          suggest.value = _suggest;
          numOfPage.value = Math.ceil(numOfDoc.value / numOfDocPerPage);
          toPage(1)();
        });
      }
    };
    let showingDoc = ref(-1);
    const toPage = (targetPage) => () => {
      if (targetPage < 1) {
        targetPage = 1;
      } else if (targetPage > numOfPage.value) {
        targetPage = numOfPage.value;
      }
      page.value = targetPage;
      showingDoc.value = -1;
      if (numOfDoc.value != 0)
        fetch(`./doc/${(page.value - 1) * numOfDocPerPage}/${Math.min(page.value * numOfDocPerPage, numOfDoc.value)}`).then((res) => res.json()).then((pubMeds) => {
          docs.value = pubMeds;
        });
    };
    let matchTarget = ref("");
    let setMatchTarget = (e) => {
      matchTarget.value = e.target.value;
    };
    const highlight = (text, target) => {
      if (target == "") {
        return [text];
      } else {
        let { vdom, lastIndex } = [
          ...text.toLowerCase().matchAll(new RegExp(target.toLowerCase(), "g"))
        ].reduce(({ vdom: vdom2, lastIndex: lastIndex2 }, curr) => {
          curr.index;
          return {
            vdom: [
              ...vdom2,
              text.slice(lastIndex2, curr.index),
              /* @__PURE__ */ h("span", {
                class: "highlight"
              }, text.slice(curr.index, curr.index + target.length))
            ],
            lastIndex: curr.index + target.length
          };
        }, { vdom: [], lastIndex: 0 });
        return [...vdom, text.slice(lastIndex)];
      }
    };
    return () => /* @__PURE__ */ h("div", {
      class: "app"
    }, /* @__PURE__ */ h(ZipfChart, null, {
      changeStemmer: (_useStemmer) => useStemmer.value = _useStemmer
    }), /* @__PURE__ */ h("br", null), /* @__PURE__ */ h("input", {
      type: "text",
      onChange: search,
      placeholder: "\u8ACB\u586B\u5165\u95DC\u9375\u5B57"
    }), /* @__PURE__ */ h("br", {
      style: [suggest.value.length != 0 ? "display:none;" : ""]
    }), /* @__PURE__ */ h("p", {
      style: [
        suggest.value.length == 0 ? "display:none;" : "",
        "text-align:center;"
      ]
    }, "\u76EE\u524D\u986F\u793A\u7684\u662F\u4EE5\u4E0B\u5B57\u8A5E\u7684\u641C\u5C0B\u7D50\u679C\uFF1A", suggest.value.reduce((prev, word2) => {
      if (prev == "")
        return word2;
      else if (word2 == "")
        return prev;
      else
        return `${prev} ${word2}`;
    }, "")), /* @__PURE__ */ h("p", {
      style: [
        numOfDoc.value == 0 ? "display:none;" : "",
        "text-align:center;"
      ]
    }, "\u7E3D\u5171\u6709 ", numOfDoc.value, " \u9805\u7D50\u679C"), /* @__PURE__ */ h("input", {
      class: "small",
      type: "text",
      placeholder: "\u6587\u672C\u641C\u5C0B",
      onChange: setMatchTarget,
      style: docs.value.length == 0 ? "display:none;" : ""
    }), /* @__PURE__ */ h("br", {
      style: docs.value.length == 0 ? "display:none;" : ""
    }), docs.value.map((doc2, idx) => {
      return /* @__PURE__ */ h(Fragment, null, /* @__PURE__ */ h("div", {
        class: "doc"
      }, /* @__PURE__ */ h("h2", {
        onClick: () => showingDoc.value = idx
      }, highlight(doc2.title ?? "", matchTarget.value)), /* @__PURE__ */ h("div", {
        style: idx != showingDoc.value ? "display:none;" : ""
      }, doc2.abstract.map((abstractText) => {
        return /* @__PURE__ */ h(Fragment, null, abstractText.category != "UNASSIGNED" ? /* @__PURE__ */ h("h3", null, abstractText.category) : "", /* @__PURE__ */ h("p", null, highlight(abstractText.text, matchTarget.value)));
      }))), /* @__PURE__ */ h("hr", null));
    }), /* @__PURE__ */ h("br", {
      style: docs.value.length == 0 ? "display:none;" : ""
    }), numOfPage.value != 0 ? pageListFn(page.value, numOfPage.value, toPage) : "", /* @__PURE__ */ h("br", null));
  });
  createApp(App).mount(document.body);
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=index.js.map
