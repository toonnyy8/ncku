(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod6) => function __require() {
    return mod6 || (0, cb[Object.keys(cb)[0]])((mod6 = { exports: {} }).exports, mod6), mod6.exports;
  };
  var __export = (target, all4) => {
    __markAsModule(target);
    for (var name in all4)
      __defProp(target, name, { get: all4[name], enumerable: true });
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from) {
          for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
          return to;
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/util/node_modules/tslib/tslib.js
  var require_tslib2 = __commonJS({
    "node_modules/@antv/util/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack3) {
          if (pack3 || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/g-base/node_modules/tslib/tslib.js
  var require_tslib3 = __commonJS({
    "node_modules/@antv/g-base/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack3) {
          if (pack3 || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/adjust/node_modules/tslib/tslib.js
  var require_tslib4 = __commonJS({
    "node_modules/@antv/adjust/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (b.hasOwnProperty(p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __createBinding10 = function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __exportStar10 = function(m, exports2) {
          for (var p3 in m)
            if (p3 !== "default" && !exports2.hasOwnProperty(p3))
              exports2[p3] = m[p3];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (Object.hasOwnProperty.call(mod6, k))
                result[k] = mod6[k];
          }
          result["default"] = mod6;
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/attr/node_modules/tslib/tslib.js
  var require_tslib5 = __commonJS({
    "node_modules/@antv/attr/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (b.hasOwnProperty(p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __createBinding10 = function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __exportStar10 = function(m, exports2) {
          for (var p3 in m)
            if (p3 !== "default" && !exports2.hasOwnProperty(p3))
              exports2[p3] = m[p3];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (Object.hasOwnProperty.call(mod6, k))
                result[k] = mod6[k];
          }
          result["default"] = mod6;
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/coord/node_modules/tslib/tslib.js
  var require_tslib6 = __commonJS({
    "node_modules/@antv/coord/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack3) {
          if (pack3 || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/component/node_modules/tslib/tslib.js
  var require_tslib7 = __commonJS({
    "node_modules/@antv/component/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack3) {
          if (pack3 || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/g-canvas/node_modules/tslib/tslib.js
  var require_tslib8 = __commonJS({
    "node_modules/@antv/g-canvas/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack3) {
          if (pack3 || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/@antv/g-svg/node_modules/tslib/tslib.js
  var require_tslib9 = __commonJS({
    "node_modules/@antv/g-svg/node_modules/tslib/tslib.js"(exports, module) {
      var __extends10;
      var __assign10;
      var __rest11;
      var __decorate10;
      var __param10;
      var __metadata10;
      var __awaiter10;
      var __generator10;
      var __exportStar10;
      var __values10;
      var __read10;
      var __spread10;
      var __spreadArrays10;
      var __spreadArray9;
      var __await10;
      var __asyncGenerator10;
      var __asyncDelegator10;
      var __asyncValues10;
      var __makeTemplateObject10;
      var __importStar10;
      var __importDefault10;
      var __classPrivateFieldGet10;
      var __classPrivateFieldSet10;
      var __createBinding10;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p3 in b)
            if (Object.prototype.hasOwnProperty.call(b, p3))
              d[p3] = b[p3];
        };
        __extends10 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign10 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p3 in s)
              if (Object.prototype.hasOwnProperty.call(s, p3))
                t[p3] = s[p3];
          }
          return t;
        };
        __rest11 = function(s, e) {
          var t = {};
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
              t[p3] = s[p3];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
              if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
                t[p3[i]] = s[p3[i]];
            }
          return t;
        };
        __decorate10 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param10 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata10 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter10 = function(thisArg, _arguments, P, generator2) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step4(generator2.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step4(generator2["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step4(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step4((generator2 = generator2.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator10 = function(thisArg, body) {
          var _6 = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step4([n, v]);
            };
          }
          function step4(op2) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_6)
              try {
                if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done)
                  return t;
                if (y = 0, t)
                  op2 = [op2[0] & 2, t.value];
                switch (op2[0]) {
                  case 0:
                  case 1:
                    t = op2;
                    break;
                  case 4:
                    _6.label++;
                    return { value: op2[1], done: false };
                  case 5:
                    _6.label++;
                    y = op2[1];
                    op2 = [0];
                    continue;
                  case 7:
                    op2 = _6.ops.pop();
                    _6.trys.pop();
                    continue;
                  default:
                    if (!(t = _6.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
                      _6 = 0;
                      continue;
                    }
                    if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
                      _6.label = op2[1];
                      break;
                    }
                    if (op2[0] === 6 && _6.label < t[1]) {
                      _6.label = t[1];
                      t = op2;
                      break;
                    }
                    if (t && _6.label < t[2]) {
                      _6.label = t[2];
                      _6.ops.push(op2);
                      break;
                    }
                    if (t[2])
                      _6.ops.pop();
                    _6.trys.pop();
                    continue;
                }
                op2 = body.call(thisArg, _6);
              } catch (e) {
                op2 = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op2[0] & 5)
              throw op2[1];
            return { value: op2[0] ? op2[1] : void 0, done: true };
          }
        };
        __exportStar10 = function(m, o) {
          for (var p3 in m)
            if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o, p3))
              __createBinding10(o, m, p3);
        };
        __createBinding10 = Object.create ? function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          Object.defineProperty(o, k22, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k22) {
          if (k22 === void 0)
            k22 = k;
          o[k22] = m[k];
        };
        __values10 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read10 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread10 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read10(arguments[i]));
          return ar;
        };
        __spreadArrays10 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray9 = function(to, from, pack3) {
          if (pack3 || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await10 = function(v) {
          return this instanceof __await10 ? (this.v = v, this) : new __await10(v);
        };
        __asyncGenerator10 = function(thisArg, _arguments, generator2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator2.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step4(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step4(r) {
            r.value instanceof __await10 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator10 = function(o) {
          var i, p3;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p3 = !p3) ? { value: __await10(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues10 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values10 === "function" ? __values10(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject10 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar10 = function(mod6) {
          if (mod6 && mod6.__esModule)
            return mod6;
          var result = {};
          if (mod6 != null) {
            for (var k in mod6)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod6, k))
                __createBinding10(result, mod6, k);
          }
          __setModuleDefault(result, mod6);
          return result;
        };
        __importDefault10 = function(mod6) {
          return mod6 && mod6.__esModule ? mod6 : { "default": mod6 };
        };
        __classPrivateFieldGet10 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet10 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        exporter("__extends", __extends10);
        exporter("__assign", __assign10);
        exporter("__rest", __rest11);
        exporter("__decorate", __decorate10);
        exporter("__param", __param10);
        exporter("__metadata", __metadata10);
        exporter("__awaiter", __awaiter10);
        exporter("__generator", __generator10);
        exporter("__exportStar", __exportStar10);
        exporter("__createBinding", __createBinding10);
        exporter("__values", __values10);
        exporter("__read", __read10);
        exporter("__spread", __spread10);
        exporter("__spreadArrays", __spreadArrays10);
        exporter("__spreadArray", __spreadArray9);
        exporter("__await", __await10);
        exporter("__asyncGenerator", __asyncGenerator10);
        exporter("__asyncDelegator", __asyncDelegator10);
        exporter("__asyncValues", __asyncValues10);
        exporter("__makeTemplateObject", __makeTemplateObject10);
        exporter("__importStar", __importStar10);
        exporter("__importDefault", __importDefault10);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet10);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet10);
      });
    }
  });

  // node_modules/long/src/long.js
  var require_long = __commonJS({
    "node_modules/long/src/long.js"(exports, module) {
      module.exports = Long2;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e) {
      }
      function Long2(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long2.prototype.__isLong__;
      Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long2.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache3;
        if (unsigned) {
          value >>>= 0;
          if (cache3 = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache3)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache3 = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache3)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long2.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long2.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long2(lowBits, highBits, unsigned);
      }
      Long2.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str4, unsigned, radix) {
        if (str4.length === 0)
          throw Error("empty string");
        if (str4 === "NaN" || str4 === "Infinity" || str4 === "+Infinity" || str4 === "-Infinity")
          return ZERO;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p3;
        if ((p3 = str4.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p3 === 0) {
          return fromString(str4.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;
        for (var i = 0; i < str4.length; i += 8) {
          var size3 = Math.min(8, str4.length - i), value = parseInt(str4.substring(i, i + size3), radix);
          if (size3 < 8) {
            var power = fromNumber(pow_dbl(radix, size3));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long2.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long2.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long2.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long2.UZERO = UZERO;
      var ONE = fromInt(1);
      Long2.ONE = ONE;
      var UONE = fromInt(1, true);
      Long2.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long2.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long2.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long2.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long2.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber2() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString3(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div5 = this.div(radixLong), rem1 = div5.mul(radixLong).sub(this);
            return div5.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven2() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals4(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(other);
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(other) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(other) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(other) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(other) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate3() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add8(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract4(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply6(multiplier) {
        if (this.isZero())
          return ZERO;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return ZERO;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide3(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
      };
      Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long2(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long2(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
    }
  });

  // (disabled):node_modules/node-fetch/browser.js
  var require_browser = __commonJS({
    "(disabled):node_modules/node-fetch/browser.js"() {
    }
  });

  // (disabled):util
  var require_util = __commonJS({
    "(disabled):util"() {
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global2, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy4(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = data.toString();
            for (var i = 0; i < data.length; i++) {
              n += data.charCodeAt(i);
              var h2 = 0.02519603282416938 * n;
              n = h2 >>> 0;
              h2 -= n;
              h2 *= n;
              n = h2 >>> 0;
              h2 -= n;
              n += h2 * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy4(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy4(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8)
              X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j)
              ;
            if (j == 8)
              w = X[7] = -1;
            else
              w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy4(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2)
                v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0)
                w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = t == 0 ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init(me, seed);
        }
        function copy4(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy4(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(pool3, math) {
        var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom5(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten4(options.entropy ? [seed, tostring(pool3)] : seed == null ? autoseed() : seed, 3), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool3);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy4(state, arc4);
              }
              prng2.state = function() {
                return copy4(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom5;
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count2) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count2--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy4(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten4(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten4(obj[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e) {
            var browser3 = global2.navigator, plugins = browser3 && browser3.plugins;
            return [+new Date(), global2, plugins, global2.screen, tostring(pool3)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool3);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom5;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom5;
          });
        }
      })([], Math);
    }
  });

  // node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/@tensorflow/tfjs-core/node_modules/seedrandom/index.js"(exports, module) {
      var alea5 = require_alea();
      var xor128 = require_xor128();
      var xorwow = require_xorwow();
      var xorshift7 = require_xorshift7();
      var xor4096 = require_xor4096();
      var tychei = require_tychei();
      var sr = require_seedrandom();
      sr.alea = alea5;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea2 = __commonJS({
    "node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global2, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy4(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = data.toString();
            for (var i = 0; i < data.length; i++) {
              n += data.charCodeAt(i);
              var h2 = 0.02519603282416938 * n;
              n = h2 >>> 0;
              h2 -= n;
              h2 *= n;
              n = h2 >>> 0;
              h2 -= n;
              n += h2 * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor1282 = __commonJS({
    "node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy4(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow2 = __commonJS({
    "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy4(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift72 = __commonJS({
    "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8)
              X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j)
              ;
            if (j == 8)
              w = X[7] = -1;
            else
              w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy4(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor40962 = __commonJS({
    "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2)
                v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0)
                w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = t == 0 ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init(me, seed);
        }
        function copy4(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei2 = __commonJS({
    "node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy4(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom3 = __commonJS({
    "node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(pool3, math) {
        var global2 = (0, eval)("this"), width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom5(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten4(options.entropy ? [seed, tostring(pool3)] : seed == null ? autoseed() : seed, 3), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool3);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy4(state, arc4);
              }
              prng2.state = function() {
                return copy4(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom5;
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count2) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count2--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy4(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten4(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten4(obj[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e) {
            var browser3 = global2.navigator, plugins = browser3 && browser3.plugins;
            return [+new Date(), global2, plugins, global2.screen, tostring(pool3)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool3);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom5;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom5;
          });
        }
      })([], Math);
    }
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom4 = __commonJS({
    "node_modules/seedrandom/index.js"(exports, module) {
      var alea5 = require_alea2();
      var xor128 = require_xor1282();
      var xorwow = require_xorwow2();
      var xorshift7 = require_xorshift72();
      var xor4096 = require_xor40962();
      var tychei = require_tychei2();
      var sr = require_seedrandom3();
      sr.alea = alea5;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // (disabled):string_decoder
  var require_string_decoder = __commonJS({
    "(disabled):string_decoder"() {
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/alea.js
  var require_alea3 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global2, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy4(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = data.toString();
            for (var i = 0; i < data.length; i++) {
              n += data.charCodeAt(i);
              var h2 = 0.02519603282416938 * n;
              n = h2 >>> 0;
              h2 -= n;
              h2 *= n;
              n = h2 >>> 0;
              h2 -= n;
              n += h2 * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xor128.js
  var require_xor1283 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy4(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xorwow.js
  var require_xorwow3 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy4(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift73 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i = me.i, t, v, w;
            t = X[i];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i] = v;
            me.i = i + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w, X = [];
            if (seed2 === (seed2 | 0)) {
              w = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8)
              X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j)
              ;
            if (j == 8)
              w = X[7] = -1;
            else
              w = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy4(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xor4096.js
  var require_xor40963 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w = me.w, X = me.X, i = me.i, t, v;
            me.w = w = w + 1640531527 | 0;
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i] = v ^ t;
            me.i = i;
            return v + (w ^ w >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i, j, w, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i = 0, j = -32; j < limit; ++j) {
              if (seed2)
                v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0)
                w = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w = w + 1640531527 | 0;
                t = X[j & 127] ^= v + w;
                i = t == 0 ? i + 1 : 0;
              }
            }
            if (i >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i + 34 & 127];
              t = X[i = i + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i] = v ^ t;
            }
            me2.w = w;
            me2.X = X;
            me2.i = i;
          }
          init(me, seed);
        }
        function copy4(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/tychei.js
  var require_tychei3 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global2, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy4(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy4(state, xg);
            prng.state = function() {
              return copy4(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(exports, typeof module == "object" && module, typeof define == "function" && define);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/seedrandom.js
  var require_seedrandom5 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(pool3, math) {
        var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom5(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten4(options.entropy ? [seed, tostring(pool3)] : seed == null ? autoseed() : seed, 3), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool3);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy4(state, arc4);
              }
              prng2.state = function() {
                return copy4(arc4, {});
              };
            }
            if (is_math_call) {
              math[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
        }
        math["seed" + rngname] = seedrandom5;
        function ARC4(key) {
          var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i < width) {
            s[i] = i++;
          }
          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          }
          (me.g = function(count2) {
            var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
            while (count2--) {
              t2 = s2[i2 = mask & i2 + 1];
              r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i2;
            me.j = j2;
            return r;
          })(width);
        }
        function copy4(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten4(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten4(obj[prop], depth - 1));
              } catch (e) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e) {
            var browser3 = global2.navigator, plugins = browser3 && browser3.plugins;
            return [+new Date(), global2, plugins, global2.screen, tostring(pool3)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math.random(), pool3);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom5;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom5;
          });
        }
      })([], Math);
    }
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/index.js
  var require_seedrandom6 = __commonJS({
    "node_modules/@tensorflow/tfjs-backend-cpu/node_modules/seedrandom/index.js"(exports, module) {
      var alea5 = require_alea3();
      var xor128 = require_xor1283();
      var xorwow = require_xorwow3();
      var xorshift7 = require_xorshift73();
      var xor4096 = require_xor40963();
      var tychei = require_tychei3();
      var sr = require_seedrandom5();
      sr.alea = alea5;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str4, expectsLowerCase) {
    const map5 = Object.create(null);
    const list = str4.split(",");
    for (let i = 0; i < list.length; i++) {
      map5[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map5[val.toLowerCase()] : (val) => !!map5[val];
  }
  var PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `HYDRATE_EVENTS`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `HOISTED`,
    [-2]: `BAIL`
  };
  var slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  var isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  var isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function normalizeStyle(value) {
    if (isArray(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value)) {
      return value;
    } else if (isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  var isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  var isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
  var EMPTY_OBJ = true ? Object.freeze({}) : {};
  var EMPTY_ARR = true ? Object.freeze([]) : [];
  var NOOP = () => {
  };
  var NO = () => false;
  var onRE = /^on[^a-z]/;
  var isOn = (key) => onRE.test(key);
  var isModelListener = (key) => key.startsWith("onUpdate:");
  var extend = Object.assign;
  var remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isSet = (val) => toTypeString(val) === "[object Set]";
  var isFunction = (val) => typeof val === "function";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = (val) => toTypeString(val) === "[object Object]";
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
  var cacheStringFunction = (fn) => {
    const cache3 = Object.create(null);
    return (str4) => {
      const hit = cache3[str4];
      return hit || (cache3[str4] = fn(str4));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction((str4) => {
    return str4.replace(camelizeRE, (_6, c) => c ? c.toUpperCase() : "");
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction((str4) => str4.replace(hyphenateRE, "-$1").toLowerCase());
  var capitalize = cacheStringFunction((str4) => str4.charAt(0).toUpperCase() + str4.slice(1));
  var toHandlerKey = cacheStringFunction((str4) => str4 ? `on${capitalize(str4)}` : ``);
  var hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  var invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  var def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  var toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };

  // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  var activeEffectScope;
  var effectScopeStack = [];
  var EffectScope = class {
    constructor(detached = false) {
      this.active = true;
      this.effects = [];
      this.cleanups = [];
      if (!detached && activeEffectScope) {
        this.parent = activeEffectScope;
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
      }
    }
    run(fn) {
      if (this.active) {
        try {
          this.on();
          return fn();
        } finally {
          this.off();
        }
      } else if (true) {
        warn(`cannot run an inactive effect scope.`);
      }
    }
    on() {
      if (this.active) {
        effectScopeStack.push(this);
        activeEffectScope = this;
      }
    }
    off() {
      if (this.active) {
        effectScopeStack.pop();
        activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
      }
    }
    stop(fromParent) {
      if (this.active) {
        this.effects.forEach((e) => e.stop());
        this.cleanups.forEach((cleanup) => cleanup());
        if (this.scopes) {
          this.scopes.forEach((e) => e.stop(true));
        }
        if (this.parent && !fromParent) {
          const last2 = this.parent.scopes.pop();
          if (last2 && last2 !== this) {
            this.parent.scopes[this.index] = last2;
            last2.index = this.index;
          }
        }
        this.active = false;
      }
    }
  };
  function recordEffectScope(effect2, scope) {
    scope = scope || activeEffectScope;
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  var createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
  };
  var wasTracked = (dep) => (dep.w & trackOpBit) > 0;
  var newTracked = (dep) => (dep.n & trackOpBit) > 0;
  var initDepMarkers = ({ deps }) => {
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].w |= trackOpBit;
      }
    }
  };
  var finalizeDepMarkers = (effect2) => {
    const { deps } = effect2;
    if (deps.length) {
      let ptr = 0;
      for (let i = 0; i < deps.length; i++) {
        const dep = deps[i];
        if (wasTracked(dep) && !newTracked(dep)) {
          dep.delete(effect2);
        } else {
          deps[ptr++] = dep;
        }
        dep.w &= ~trackOpBit;
        dep.n &= ~trackOpBit;
      }
      deps.length = ptr;
    }
  };
  var targetMap = new WeakMap();
  var effectTrackDepth = 0;
  var trackOpBit = 1;
  var maxMarkerBits = 30;
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol(true ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
  var ReactiveEffect = class {
    constructor(fn, scheduler = null, scope) {
      this.fn = fn;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      recordEffectScope(this, scope);
    }
    run() {
      if (!this.active) {
        return this.fn();
      }
      if (!effectStack.includes(this)) {
        try {
          effectStack.push(activeEffect = this);
          enableTracking();
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          resetTracking();
          effectStack.pop();
          const n = effectStack.length;
          activeEffect = n > 0 ? effectStack[n - 1] : void 0;
        }
      }
    }
    stop() {
      if (this.active) {
        cleanupEffect(this);
        if (this.onStop) {
          this.onStop();
        }
        this.active = false;
      }
    }
  };
  function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect2);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function track(target, type, key) {
    if (!isTracking()) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = true ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
  function isTracking() {
    return shouldTrack && activeEffect !== void 0;
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
      if (!newTracked(dep)) {
        dep.n |= trackOpBit;
        shouldTrack2 = !wasTracked(dep);
      }
    } else {
      shouldTrack2 = !dep.has(activeEffect);
    }
    if (shouldTrack2) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.onTrack) {
        activeEffect.onTrack(Object.assign({
          effect: activeEffect
        }, debuggerEventExtraInfo));
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const eventInfo = true ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
    if (deps.length === 1) {
      if (deps[0]) {
        if (true) {
          triggerEffects(deps[0], eventInfo);
        } else {
          triggerEffects(deps[0]);
        }
      }
    } else {
      const effects = [];
      for (const dep of deps) {
        if (dep) {
          effects.push(...dep);
        }
      }
      if (true) {
        triggerEffects(createDep(effects), eventInfo);
      } else {
        triggerEffects(createDep(effects));
      }
    }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
    for (const effect2 of isArray(dep) ? dep : [...dep]) {
      if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (effect2.onTrigger) {
          effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get = /* @__PURE__ */ createGetter();
  var shallowGet = /* @__PURE__ */ createGetter(false, true);
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get4(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    };
  }
  var set = /* @__PURE__ */ createSetter();
  var shallowSet = /* @__PURE__ */ createSetter(true);
  function createSetter(shallow = false) {
    return function set5(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      if (true) {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      if (true) {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
  });
  var shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
  });
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly2 = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly2 && track(rawTarget, "get", key);
    }
    !isReadonly2 && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly2 = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly2 && track(rawTarget, "has", key);
    }
    !isReadonly2 && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2 = false) {
    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get4 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get4.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get4 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (true) {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get4 ? get4.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow) {
    return function forEach3(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      if (true) {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = new WeakMap();
  var shallowReactiveMap = new WeakMap();
  var readonlyMap = new WeakMap();
  var shallowReadonlyMap = new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (target && target["__v_isReadonly"]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    def(value, "__v_skip", true);
    return value;
  }
  var toReactive = (value) => isObject(value) ? reactive(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  function trackRefValue(ref2) {
    if (isTracking()) {
      ref2 = toRaw(ref2);
      if (!ref2.dep) {
        ref2.dep = createDep();
      }
      if (true) {
        trackEffects(ref2.dep, {
          target: ref2,
          type: "get",
          key: "value"
        });
      } else {
        trackEffects(ref2.dep);
      }
    }
  }
  function triggerRefValue(ref2, newVal) {
    ref2 = toRaw(ref2);
    if (ref2.dep) {
      if (true) {
        triggerEffects(ref2.dep, {
          target: ref2,
          type: "set",
          key: "value",
          newValue: newVal
        });
      } else {
        triggerEffects(ref2.dep);
      }
    }
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  var RefImpl = class {
    constructor(value, _shallow) {
      this._shallow = _shallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = _shallow ? value : toRaw(value);
      this._value = _shallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      newVal = this._shallow ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = this._shallow ? newVal : toReactive(newVal);
        triggerRefValue(this, newVal);
      }
    }
  };
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  var shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  var ComputedRefImpl = class {
    constructor(getter, _setter, isReadonly2) {
      this._setter = _setter;
      this.dep = void 0;
      this._dirty = true;
      this.__v_isRef = true;
      this.effect = new ReactiveEffect(getter, () => {
        if (!this._dirty) {
          this._dirty = true;
          triggerRefValue(this);
        }
      });
      this["__v_isReadonly"] = isReadonly2;
    }
    get value() {
      const self2 = toRaw(this);
      trackRefValue(self2);
      if (self2._dirty) {
        self2._dirty = false;
        self2._value = self2.effect.run();
      }
      return self2._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
  };
  function computed(getterOrOptions, debugOptions) {
    let getter;
    let setter;
    const onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = true ? () => {
        console.warn("Write operation failed: computed value is readonly");
      } : NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);
    if (debugOptions) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  var _a;
  var tick = Promise.resolve();
  _a = "__v_isReadonly";

  // node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  var isHmrUpdating = false;
  var hmrDirtyComponents = new Set();
  if (true) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = new Map();
  function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
      createRecord(id);
      record = map.get(id);
    }
    record.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).delete(instance);
  }
  function createRecord(id) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, new Set());
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
      return;
    }
    [...record].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    const instances = [...record];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        extend(oldComp, newComp);
        for (const key in oldComp) {
          if (key !== "__file" && !(key in newComp)) {
            delete oldComp[key];
          }
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        queueJob(instance.parent.update);
        if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
          instance.parent.ceReload(newComp.styles);
        }
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
      }
    });
  }
  function tryWrap(fn) {
    return (id, arg) => {
      try {
        return fn(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
      }
    };
  }
  var devtools;
  var buffer = [];
  function emit(event, ...args) {
    if (devtools) {
      devtools.emit(event, ...args);
    } else {
      buffer.push({ event, args });
    }
  }
  function setDevtoolsHook(hook, target) {
    devtools = hook;
    if (devtools) {
      devtools.enabled = true;
      buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
      buffer = [];
    } else {
      const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook(newHook, target);
      });
    }
  }
  function devtoolsInitApp(app, version11) {
    emit("app:init", app, version11, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app) {
    emit("app:unmount", app);
  }
  var devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
  var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
  var devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
  }
  var devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
  var devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
  function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
      emit(hook, component.appContext.app, component.uid, component, type, time);
    };
  }
  function devtoolsComponentEmit(component, event, params) {
    emit("component:emit", component.appContext.app, component, event, params);
  }
  function emit$1(instance, event, ...rawArgs) {
    const props = instance.vnode.props || EMPTY_OBJ;
    if (true) {
      const { emitsOptions, propsOptions: [propsOptions] } = instance;
      if (emitsOptions) {
        if (!(event in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
            warn2(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
          }
        } else {
          const validator = emitsOptions[event];
          if (isFunction(validator)) {
            const isValid = validator(...rawArgs);
            if (!isValid) {
              warn2(`Invalid event arguments: event validation failed for event "${event}".`);
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modelArg = isModelListener2 && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a) => a.trim());
      } else if (number) {
        args = rawArgs.map(toNumber);
      }
    }
    if (true) {
      devtoolsComponentEmit(instance, event, args);
    }
    if (true) {
      const lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
        warn2(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(handler, instance, 6, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache3 = appContext.emitsCache;
    const cached = cache3.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      cache3.set(comp, null);
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    cache3.set(comp, normalized);
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }
  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx3 = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx3)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx3);
      const res = fn(...args);
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
      if (true) {
        devtoolsComponentUpdated(ctx3);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  var accessedAttrs = false;
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const { type: Component2, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx: ctx3, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if (true) {
      accessedAttrs = false;
    }
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx3));
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component2;
        if (attrs === props) {
          markAttrsAccessed();
        }
        result = normalizeVNode(render2.length > 1 ? render2(props, true ? {
          get attrs() {
            markAttrsAccessed();
            return attrs;
          },
          slots,
          emit: emit2
        } : { attrs, slots, emit: emit2 }) : render2(props, null));
        fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    let setRoot = void 0;
    if (result.patchFlag > 0 && result.patchFlag & 2048) {
      [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys2 = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys2.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys2.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
          }
          root = cloneVNode(root, fallthroughAttrs);
        } else if (!accessedAttrs && root.type !== Comment) {
          const allAttrs = Object.keys(attrs);
          const eventAttrs = [];
          const extraAttrs = [];
          for (let i = 0, l = allAttrs.length; i < l; i++) {
            const key = allAttrs[i];
            if (isOn(key)) {
              if (!isModelListener(key)) {
                eventAttrs.push(key[2].toLowerCase() + key.slice(3));
              }
            } else {
              extraAttrs.push(key);
            }
          }
          if (extraAttrs.length) {
            warn2(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
          }
          if (eventAttrs.length) {
            warn2(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
          }
        }
      }
    }
    if (vnode.dirs) {
      if (!isElementRoot(root)) {
        warn2(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
      }
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      if (!isElementRoot(root)) {
        warn2(`Component inside <Transition> renders non-element root node that cannot be animated.`);
      }
      root.transition = vnode.transition;
    }
    if (setRoot) {
      setRoot(root);
    } else {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  var getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
      return [vnode, void 0];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
      rawChildren[index] = updatedRoot;
      if (dynamicChildren) {
        if (dynamicIndex > -1) {
          dynamicChildren[dynamicIndex] = updatedRoot;
        } else if (updatedRoot.patchFlag > 0) {
          vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
        }
      }
    };
    return [normalizeVNode(childRoot), setRoot];
  };
  function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  var getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  var filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  var isElementRoot = (vnode) => {
    return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent && parent.subTree === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    }
  }
  var isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  function provide(key, value) {
    if (!currentInstance) {
      if (true) {
        warn2(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
      const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
      } else if (true) {
        warn2(`injection "${String(key)}" not found.`);
      }
    } else if (true) {
      warn2(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  var TransitionHookValidator = [Function, Array];
  var BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevTransitionKey;
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        if (children.length > 1) {
          warn2("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (mode && !["in-out", "out-in", "default"].includes(mode)) {
          warn2(`invalid <transition> mode: ${mode}`);
        }
        const child = children[0];
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        let transitionKeyChanged = false;
        const { getTransitionKey } = innerChild.type;
        if (getTransitionKey) {
          const key = getTransitionKey();
          if (prevTransitionKey === void 0) {
            prevTransitionKey = key;
          } else if (key !== prevTransitionKey) {
            prevTransitionKey = key;
            transitionKeyChanged = true;
          }
        }
        if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
          const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              instance.update();
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el._leaveCb = () => {
                earlyRemove();
                el._leaveCb = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  var BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el._leaveCb) {
          el._leaveCb(true);
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
          leavingVNode.el._leaveCb();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el._enterCb = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el._enterCb = void 0;
        };
        if (hook) {
          hook(el, done);
          if (hook.length <= 1) {
            done();
          }
        } else {
          done();
        }
      },
      leave(el, remove3) {
        const key2 = String(vnode.key);
        if (el._enterCb) {
          el._enterCb(true);
        }
        if (state.isUnmounting) {
          return remove3();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el._leaveCb = (cancelled) => {
          if (called)
            return;
          called = true;
          remove3();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el._leaveCb = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          onLeave(el, done);
          if (onLeave.length <= 1) {
            done();
          }
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
      } else if (keepComment || child.type !== Comment) {
        ret.push(child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent(options) {
    return isFunction(options) ? { setup: options, name: options.name } : options;
  }
  var isAsyncWrapper = (i) => !!i.type.__asyncLoader;
  var isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(type, hook, keepAliveRoot, true);
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }
  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (true) {
      const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
      warn2(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
  }
  var createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
  var onBeforeMount = createHook("bm");
  var onMounted = createHook("m");
  var onBeforeUpdate = createHook("bu");
  var onUpdated = createHook("u");
  var onBeforeUnmount = createHook("bum");
  var onUnmounted = createHook("um");
  var onServerPrefetch = createHook("sp");
  var onRenderTriggered = createHook("rtg");
  var onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }
  function createDuplicateChecker() {
    const cache3 = Object.create(null);
    return (type, key) => {
      if (cache3[key]) {
        warn2(`${type} property "${key}" is already defined in ${cache3[key]}.`);
      } else {
        cache3[key] = type;
      }
    };
  }
  var shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx3 = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = true ? createDuplicateChecker() : null;
    if (true) {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key in propsOptions) {
          checkDuplicateProperties("Props", key);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx3, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction(methodHandler)) {
          if (true) {
            Object.defineProperty(ctx3, key, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx3[key] = methodHandler.bind(publicThis);
          }
          if (true) {
            checkDuplicateProperties("Methods", key);
          }
        } else if (true) {
          warn2(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn2(`The data option must be a function. Plain object usage is no longer supported.`);
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn2(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
      }
      if (!isObject(data)) {
        warn2(`data() should return an object.`);
      } else {
        instance.data = reactive(data);
        if (true) {
          for (const key in data) {
            checkDuplicateProperties("Data", key);
            if (key[0] !== "$" && key[0] !== "_") {
              Object.defineProperty(ctx3, key, {
                configurable: true,
                enumerable: true,
                get: () => data[key],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get4 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get4 === NOOP) {
          warn2(`Computed property "${key}" has no getter.`);
        }
        const set5 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : true ? () => {
          warn2(`Write operation failed: computed property "${key}" is readonly.`);
        } : NOOP;
        const c = computed({
          get: get4,
          set: set5
        });
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        if (true) {
          checkDuplicateProperties("Computed", key);
        }
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx3, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register3, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register3(_hook.bind(publicThis)));
      } else if (hook) {
        register3(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx3, checkDuplicateProperties = NOOP, unwrapRef = false) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject(opt.from || key, opt.default, true);
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        if (unwrapRef) {
          Object.defineProperty(ctx3, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          if (true) {
            warn2(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
          }
          ctx3[key] = injected;
        }
      } else {
        ctx3[key] = injected;
      }
      if (true) {
        checkDuplicateProperties("Inject", key);
      }
    }
  }
  function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
  }
  function createWatcher(raw, ctx3, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx3[raw];
      if (isFunction(handler)) {
        watch(getter, handler);
      } else if (true) {
        warn2(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx3, publicThis, key));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx3[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else if (true) {
          warn2(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else if (true) {
      warn2(`Invalid watch option: "${key}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base2 = instance.type;
    const { mixins, extends: extendsOptions } = base2;
    const { mixins: globalMixins, optionsCache: cache3, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache3.get(base2);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base2;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
      }
      mergeOptions(resolved, base2, optionMergeStrategies);
    }
    cache3.set(base2, resolved);
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
      if (asMixin && key === "expose") {
        warn2(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
      } else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    watch: mergeWatchOptions,
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(extend(Object.create(null), to), from) : from;
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend(Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key)) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
    if (true) {
      validateProps(rawProps || {}, props, instance);
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(null, props);
            unsetCurrentInstance();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache3 = appContext.propsCache;
    const cached = cache3.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys2)
          needCastKeys.push(...keys2);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      cache3.set(comp, EMPTY_ARR);
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn2(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn2(`invalid props options`, raw);
      }
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : opt;
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    cache3.set(comp, res);
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$") {
      return true;
    } else if (true) {
      warn2(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? "null" : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type));
    } else if (isFunction(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
      let opt = options[key];
      if (opt == null)
        continue;
      validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
    }
  }
  function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    if (required && isAbsent) {
      warn2('Missing required prop: "' + name + '"');
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    if (type != null && type !== true) {
      let isValid = false;
      const types = isArray(type) ? type : [type];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid; i++) {
        const { valid, expectedType } = assertType(value, types[i]);
        expectedTypes.push(expectedType || "");
        isValid = valid;
      }
      if (!isValid) {
        warn2(getInvalidTypeMessage(name, value, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value)) {
      warn2('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  var isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
  function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
      const t = typeof value;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value instanceof type;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value);
    } else if (expectedType === "Array") {
      valid = isArray(value);
    } else if (expectedType === "null") {
      valid = value === null;
    } else {
      valid = value instanceof type;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value, type) {
    if (type === "String") {
      return `"${value}"`;
    } else if (type === "Number") {
      return `${Number(value)}`;
    } else {
      return `${value}`;
    }
  }
  function isExplicable(type) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  var isInternalKey = (key) => key[0] === "_" || key === "$stable";
  var normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  var normalizeSlot = (key, rawSlot, ctx3) => {
    const normalized = withCtx((...args) => {
      if (currentInstance) {
        warn2(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
      }
      return normalizeSlotValue(rawSlot(...args));
    }, ctx3);
    normalized._c = false;
    return normalized;
  };
  var normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx3 = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction(value)) {
        slots[key] = normalizeSlot(key, value, ctx3);
      } else if (value != null) {
        if (true) {
          warn2(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
        }
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  var normalizeVNodeSlots = (instance, children) => {
    if (!isKeepAlive(instance.vnode) && true) {
      warn2(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  var initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        instance.slots = toRaw(children);
        def(children, "_", type);
      } else {
        normalizeObjectSlots(children, instance.slots = {});
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  var updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (isHmrUpdating) {
          extend(slots, children);
        } else if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          extend(slots, children);
          if (!optimized && type === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
          delete slots[key];
        }
      }
    }
  };
  var isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text");
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn2("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap()
    };
  }
  var uid = 0;
  function createAppAPI(render, hydrate) {
    return function createApp2(rootComponent, rootProps = null) {
      if (rootProps != null && !isObject(rootProps)) {
        warn2(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = new Set();
      let isMounted = false;
      const app = context.app = {
        _uid: uid++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          if (true) {
            warn2(`app.config cannot be replaced. Modify individual options instead.`);
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn2(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else if (true) {
            warn2(`A plugin must either be a function or an object with an "install" function.`);
          }
          return app;
        },
        mixin(mixin) {
          if (__VUE_OPTIONS_API__) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (true) {
              warn2("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
            }
          } else if (true) {
            warn2("Mixins are only available in builds supporting Options API");
          }
          return app;
        },
        component(name, component) {
          if (true) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn2(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (true) {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn2(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, isSVG) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (true) {
              context.reload = () => {
                render(cloneVNode(vnode), rootContainer, isSVG);
              };
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render(vnode, rootContainer, isSVG);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            if (true) {
              app._instance = vnode.component;
              devtoolsInitApp(app, version);
            }
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          } else if (true) {
            warn2(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
          }
        },
        unmount() {
          if (isMounted) {
            render(null, app._container);
            if (true) {
              app._instance = null;
              devtoolsUnmountApp(app);
            }
            delete app._container.__vue_app__;
          } else if (true) {
            warn2(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key, value) {
          if (key in context.provides) {
            warn2(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
          }
          context.provides[key] = value;
          return app;
        }
      };
      return app;
    };
  }
  var supported;
  var perf;
  function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
      devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (true) {
      devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    const needWarn = [];
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
      needWarn.push(`__VUE_OPTIONS_API__`);
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_DEVTOOLS__ !== "boolean") {
      needWarn.push(`__VUE_PROD_DEVTOOLS__`);
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (needWarn.length) {
      const multi = needWarn.length > 1;
      console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see http://link.vuejs.org/feature-flags.`);
    }
  }
  var queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (true) {
      setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref2, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, isSVG);
          } else if (true) {
            patchStaticNode(n1, n2, container, isSVG);
          }
          break;
        case Fragment:
          processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (true) {
            warn2("Invalid VNode type:", type, `(${typeof type})`);
          }
      }
      if (ref2 != null && parentComponent) {
        setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    const patchStaticNode = (n1, n2, container, isSVG) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      isSVG = isSVG || n2.type === "svg";
      if (n1 == null) {
        mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
      if (false) {
        el = vnode.el = hostCloneNode(vnode.el);
      } else {
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      }
      if (true) {
        Object.defineProperty(el, "__vnode", {
          value: vnode,
          enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      const areChildrenSVG = isSVG && n2.type !== "foreignObject";
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        if (parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, isSVG);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
      if (oldProps !== newProps) {
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
          if (parentComponent && parentComponent.type.__hmrId) {
            traverseStaticChildren(n1, n2);
          } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(n1, n2, true);
          }
        } else {
          patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
          mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
      const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (true) {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (true) {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if (true) {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
        return;
      }
      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
      if (true) {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (true) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (true) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.update();
        }
      } else {
        n2.component = n1.component;
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          effect2.allowRecurse = false;
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          effect2.allowRecurse = true;
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (true) {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              if (true) {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
            } else {
              hydrateSubTree();
            }
          } else {
            if (true) {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
            if (true) {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
          }
          if (initialVNode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (true) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          let originNext = next;
          let vnodeHook;
          if (true) {
            pushWarningContext(next || instance.vnode);
          }
          effect2.allowRecurse = false;
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          effect2.allowRecurse = true;
          if (true) {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
          if (true) {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
          }
          if (true) {
            devtoolsComponentUpdated(instance);
          }
          if (true) {
            popWarningContext();
          }
        }
      };
      const effect2 = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
      const update3 = instance.update = effect2.run.bind(effect2);
      update3.id = instance.uid;
      effect2.allowRecurse = update3.allowRecurse = true;
      if (true) {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        update3.ownerInstance = instance;
      }
      update3();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(void 0, instance.update);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let i = 0;
      const l22 = c2.length;
      let e1 = c1.length - 1;
      let e22 = l22 - 1;
      while (i <= e1 && i <= e22) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e22) {
        const n1 = c1[e1];
        const n2 = c2[e22] = optimized ? cloneIfMounted(c2[e22]) : normalizeVNode(c2[e22]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e22--;
      }
      if (i > e1) {
        if (i <= e22) {
          const nextPos = e22 + 1;
          const anchor = nextPos < l22 ? c2[nextPos].el : parentAnchor;
          while (i <= e22) {
            patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            i++;
          }
        }
      } else if (i > e22) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = new Map();
        for (i = s2; i <= e22; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn2(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e22 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e22; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l22 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove4 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove4();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove4, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
      if (ref2 != null) {
        setRef(ref2, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove3(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove3 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        removeFragment(el, anchor);
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update: update3, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update3) {
        update3.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (true) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, isSVG) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, isSVG);
      }
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove3,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
      render,
      hydrate,
      createApp: createAppAPI(render, hydrate)
    };
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref2 } = rawRef;
    if (!owner) {
      warn2(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref2) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isString(ref2)) {
      const doSet = () => {
        {
          refs[ref2] = value;
        }
        if (hasOwn(setupState, ref2)) {
          setupState[ref2] = value;
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (isRef(ref2)) {
      const doSet = () => {
        ref2.value = value;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (isFunction(ref2)) {
      callWithErrorHandling(ref2, owner, 12, [value, refs]);
    } else if (true) {
      warn2("Invalid template ref type:", value, `(${typeof value})`);
    }
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Comment && !c2.el) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p3 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len3 = arr.length;
    for (i = 0; i < len3; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p3[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p3[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p3[v];
    }
    return result;
  }
  var isTeleport = (type) => type.__isTeleport;
  var NULL_DYNAMIC_COMPONENT = Symbol();
  var Fragment = Symbol(true ? "Fragment" : void 0);
  var Text = Symbol(true ? "Text" : void 0);
  var Comment = Symbol(true ? "Comment" : void 0);
  var Static = Symbol(true ? "Static" : void 0);
  var blockStack = [];
  var currentBlock = null;
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
      return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  var vnodeArgsTransformer;
  var createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
  };
  var InternalObjectKey = `__vInternal`;
  var normalizeKey = ({ key }) => key != null ? key : null;
  var normalizeRef = ({ ref: ref2 }) => {
    return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2 } : ref2 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn2(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = true ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!type) {
        warn2(`Invalid vnode type when creating vnode: ${type}.`);
      }
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(type, props, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn2(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref: ref2, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor
    };
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(Fragment, null, child.slice());
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (existing !== incoming) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  var getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = extend(Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => true ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
    $forceUpdate: (i) => () => queueJob(i.update),
    $nextTick: (i) => nextTick.bind(i.proxy),
    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
  });
  var PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      const { ctx: ctx3, setupState, data, props, accessCache, type, appContext } = instance;
      if (key === "__isVue") {
        return true;
      }
      if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn(setupState, key)) {
        return setupState[key];
      }
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 0:
              return setupState[key];
            case 1:
              return data[key];
            case 3:
              return ctx3[key];
            case 2:
              return props[key];
          }
        } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
          accessCache[key] = 0;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 1;
          return data[key];
        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
          accessCache[key] = 2;
          return props[key];
        } else if (ctx3 !== EMPTY_OBJ && hasOwn(ctx3, key)) {
          accessCache[key] = 3;
          return ctx3[key];
        } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
          accessCache[key] = 4;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance, "get", key);
          markAttrsAccessed();
        }
        return publicGetter(instance);
      } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
        return cssModule;
      } else if (ctx3 !== EMPTY_OBJ && hasOwn(ctx3, key)) {
        accessCache[key] = 3;
        return ctx3[key];
      } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
        {
          return globalProperties[key];
        }
      } else if (currentRenderingInstance && (!isString(key) || key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && (key[0] === "$" || key[0] === "_") && hasOwn(data, key)) {
          warn2(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
        } else if (instance === currentRenderingInstance) {
          warn2(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
        }
      }
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx: ctx3 } = instance;
      if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        setupState[key] = value;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
      } else if (hasOwn(instance.props, key)) {
        warn2(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        warn2(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`, instance);
        return false;
      } else {
        if (key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx3, key, {
            enumerable: true,
            configurable: true,
            value
          });
        } else {
          ctx3[key] = value;
        }
      }
      return true;
    },
    has({ _: { data, setupState, accessCache, ctx: ctx3, appContext, propsOptions } }, key) {
      let normalizedProps;
      return accessCache[key] !== void 0 || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx3, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    }
  };
  if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
      warn2(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
      return Reflect.ownKeys(target);
    };
  }
  function createDevRenderContext(instance) {
    const target = {};
    Object.defineProperty(target, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key) => {
      Object.defineProperty(target, key, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key](instance),
        set: NOOP
      });
    });
    return target;
  }
  function exposePropsOnRenderContext(instance) {
    const { ctx: ctx3, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key) => {
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx: ctx3, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key) => {
      if (!setupState.__isScriptSetup) {
        if (key[0] === "$" || key[0] === "_") {
          warn2(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
          return;
        }
        Object.defineProperty(ctx3, key, {
          enumerable: true,
          configurable: true,
          get: () => setupState[key],
          set: NOOP
        });
      }
    });
  }
  var emptyAppContext = createAppContext();
  var uid$1 = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid$1++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      update: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (true) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$1.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  var currentInstance = null;
  var getCurrentInstance = () => currentInstance || currentRenderingInstance;
  var setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
  };
  var unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
  };
  var isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
  function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
      warn2("Do not use built-in or reserved HTML elements as component id: " + name);
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component2 = instance.type;
    if (true) {
      if (Component2.name) {
        validateComponentName(Component2.name, instance.appContext.config);
      }
      if (Component2.components) {
        const names = Object.keys(Component2.components);
        for (let i = 0; i < names.length; i++) {
          validateComponentName(names[i], instance.appContext.config);
        }
      }
      if (Component2.directives) {
        const names = Object.keys(Component2.directives);
        for (let i = 0; i < names.length; i++) {
          validateDirectiveName(names[i]);
        }
      }
      if (Component2.compilerOptions && isRuntimeOnly()) {
        warn2(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
      }
    }
    instance.accessCache = Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if (true) {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component2;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(setup, instance, 0, [true ? shallowReadonly(instance.props) : instance.props, setupContext]);
      resetTracking();
      unsetCurrentInstance();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn2(`setup() should not return VNodes directly - return a render function instead.`);
      }
      if (true) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (true) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn2(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
  }
  var compile;
  var installWithProxy;
  var isRuntimeOnly = () => !compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component2 = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component2.render) {
        const template = Component2.template;
        if (template) {
          if (true) {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
          const finalCompilerOptions = extend(extend({
            isCustomElement,
            delimiters
          }, compilerOptions), componentCompilerOptions);
          Component2.render = compile(template, finalCompilerOptions);
          if (true) {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component2.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (__VUE_OPTIONS_API__ && true) {
      setCurrentInstance(instance);
      pauseTracking();
      applyOptions(instance);
      resetTracking();
      unsetCurrentInstance();
    }
    if (!Component2.render && instance.render === NOOP && !isSSR) {
      if (!compile && Component2.template) {
        warn2(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
      } else {
        warn2(`Component is missing template or render function.`);
      }
    }
  }
  function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, true ? {
      get(target, key) {
        markAttrsAccessed();
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn2(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn2(`setupContext.attrs is readonly.`);
        return false;
      }
    } : {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (instance.exposed) {
        warn2(`expose() should be called only once per setup().`);
      }
      instance.exposed = exposed || {};
    };
    let attrs;
    if (true) {
      return Object.freeze({
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        get slots() {
          return shallowReadonly(instance.slots);
        },
        get emit() {
          return (event, ...args) => instance.emit(event, ...args);
        },
        expose
      });
    } else {
      return {
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        }
      }));
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = (str4) => str4.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component2) {
    return isFunction(Component2) ? Component2.displayName || Component2.name : Component2.name;
  }
  function formatComponentName(instance, Component2, isRoot = false) {
    let name = getComponentName(Component2);
    if (!name && Component2.__file) {
      const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component2) {
            return key;
          }
        }
      };
      name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }
  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn2(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
      ]);
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys2 = Object.keys(props);
    keys2.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys2.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  var ErrorTypeStrings = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next"
  };
  function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    const values2 = [];
    for (let i = 0; i < fn.length; i++) {
      values2.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values2;
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = true ? ErrorTypeStrings[type] : type;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    if (true) {
      const info = ErrorTypeStrings[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn2(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }
  var isFlushing = false;
  var isFlushPending = false;
  var queue = [];
  var flushIndex = 0;
  var pendingPreFlushCbs = [];
  var activePreFlushCbs = null;
  var preFlushIndex = 0;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = Promise.resolve();
  var currentFlushPromise = null;
  var currentPreFlushParentJob = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn) {
    const p3 = currentFlushPromise || resolvedPromise;
    return fn ? p3.then(this ? fn.bind(this) : fn) : p3;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJobId = getId(queue[middle]);
      middleJobId < id ? start = middle + 1 : end = middle;
    }
    return start;
  }
  function queueJob(job) {
    if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!isArray(cb)) {
      if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
        pendingQueue.push(cb);
      }
    } else {
      pendingQueue.push(...cb);
    }
    queueFlush();
  }
  function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
  }
  function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
  }
  function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
      currentPreFlushParentJob = parentJob;
      activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
      pendingPreFlushCbs.length = 0;
      if (true) {
        seen = seen || new Map();
      }
      for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
        if (checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
          continue;
        }
        activePreFlushCbs[preFlushIndex]();
      }
      activePreFlushCbs = null;
      preFlushIndex = 0;
      currentPreFlushParentJob = null;
      flushPreFlushCbs(seen, parentJob);
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (true) {
        seen = seen || new Map();
      }
      activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
          continue;
        }
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = (job) => job.id == null ? Infinity : job.id;
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if (true) {
      seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    queue.sort((a, b) => getId(a) - getId(b));
    const check = true ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (check(job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
      seen.set(fn, 1);
    } else {
      const count2 = seen.get(fn);
      if (count2 > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        warn2(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
        return true;
      } else {
        seen.set(fn, count2 + 1);
      }
    }
  }
  var INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn2(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    if (!cb) {
      if (immediate !== void 0) {
        warn2(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
      }
      if (deep !== void 0) {
        warn2(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
      }
    }
    const warnInvalidSource = (s) => {
      warn2(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = !!source._shallow;
    } else if (isReactive(source)) {
      getter = () => source;
      deep = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some(isReactive);
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse(s);
        } else if (isFunction(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else {
          warnInvalidSource(s);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(source, instance, 3, [onInvalidate]);
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onInvalidate = (fn) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
      };
    };
    if (isInSSRComponentSetup) {
      onInvalidate = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onInvalidate
        ]);
      }
      return NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
            onInvalidate
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      scheduler = () => {
        if (!instance || instance.isMounted) {
          queuePreFlushCb(job);
        } else {
          job();
        }
      };
    }
    const effect2 = new ReactiveEffect(getter, scheduler);
    if (true) {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
    } else {
      effect2.run();
    }
    return () => {
      effect2.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect2);
      }
    };
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx3, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx3;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, seen) {
    if (!isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse(value.value, seen);
    } else if (isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse(value[i], seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse(v, seen);
      });
    } else if (isPlainObject(value)) {
      for (const key in value) {
        traverse(value[key], seen);
      }
    }
    return value;
  }
  true ? Object.freeze({}) : {};
  true ? Object.freeze([]) : [];
  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  var ssrContextKey = Symbol(true ? `ssrContext` : ``);
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#0b1bc9" };
    const stringStyle = { style: "color:#b62e24" };
    const keywordStyle = { style: "color:#9d288c" };
    const formatter = {
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed2 = extractKeys(instance, "computed");
      if (computed2) {
        blocks.push(createInstanceBlock("computed", computed2));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target).map((key) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      const opts = Comp[type];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (v._shallow) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  var version = "3.2.19";

  // node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var svgNS = "http://www.w3.org/2000/svg";
  var doc = typeof document !== "undefined" ? document : null;
  var staticTemplateCache = new Map();
  var nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, isSVG, is, props) => {
      const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    cloneNode(el) {
      const cloned = el.cloneNode(true);
      if (`_value` in el) {
        cloned._value = el._value;
      }
      return cloned;
    },
    insertStaticContent(content, parent, anchor, isSVG) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      let template = staticTemplateCache.get(content);
      if (!template) {
        const t = doc.createElement("template");
        t.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
        template = t.content;
        if (isSVG) {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        staticTemplateCache.set(content, template);
      }
      parent.insertBefore(template.cloneNode(true), anchor);
      return [
        before ? before.nextSibling : parent.firstChild,
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  function patchClass(el, value, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  function patchStyle(el, prev, next) {
    const style = el.style;
    const currentDisplay = style.display;
    if (!next) {
      el.removeAttribute("style");
    } else if (isString(next)) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else {
      for (const key in next) {
        setStyle(style, key, next[key]);
      }
      if (prev && !isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
  var importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  var prefixes = ["Webkit", "Moz", "ms"];
  var prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  var xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean4 = isSpecialBooleanAttr(key);
      if (value == null || isBoolean4 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean4 ? "" : value);
      }
    }
  }
  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    if (key === "value" && el.tagName !== "PROGRESS") {
      el._value = value;
      const newValue = value == null ? "" : value;
      if (el.value !== newValue) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      return;
    }
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        el[key] = includeBooleanAttr(value);
        return;
      } else if (value == null && type === "string") {
        el[key] = "";
        el.removeAttribute(key);
        return;
      } else if (type === "number") {
        try {
          el[key] = 0;
        } catch (_a4) {
        }
        el.removeAttribute(key);
        return;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
      if (true) {
        warn2(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
      }
    }
  }
  var _getNow = Date.now;
  var skipTimestampCheck = false;
  if (typeof window !== "undefined") {
    if (_getNow() > document.createEvent("Event").timeStamp) {
      _getNow = () => performance.now();
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  var cachedNow = 0;
  var p = Promise.resolve();
  var reset = () => {
    cachedNow = 0;
  };
  var getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  var optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    return [hyphenate(name.slice(2)), options];
  }
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      const timeStamp = e.timeStamp || _getNow();
      if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
        callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
      }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map((fn) => (e3) => !e3._stopped && fn(e3));
    } else {
      return value;
    }
  }
  var nativeOnRE = /^on[a-z]/;
  var patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && nativeOnRE.test(key) && isFunction(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (nativeOnRE.test(key) && isString(value)) {
      return false;
    }
    return key in el;
  }
  var TRANSITION = "transition";
  var ANIMATION = "animation";
  var Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  var DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  var TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
  var callHook2 = (hook, args = []) => {
    if (isArray(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  var hasExplicitCallback = (hook) => {
    return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        const resolve = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve);
          }
        });
        callHook2(onLeave, [el, resolve]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (true)
      validateDuration(res);
    return res;
  }
  function validateDuration(val) {
    if (typeof val !== "number") {
      warn2(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn2(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
    }
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el._vtc || (el._vtc = new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el._vtc = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  var endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout2 + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(TRANSITION + "Delay");
    const transitionDurations = getStyleProperties(TRANSITION + "Duration");
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + "Delay");
    const animationDurations = getStyleProperties(ANIMATION + "Duration");
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout2 = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout2 = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout2 = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout2 = Math.max(transitionTimeout, animationTimeout);
      type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
    return {
      type,
      timeout: timeout2,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  var positionMap = new WeakMap();
  var newPositionMap = new WeakMap();
  var rendererOptions = extend({ patchProp }, nodeOps);
  var renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  var createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    if (true) {
      injectNativeTagCheck(app);
      injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app._component;
      if (!isFunction(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, container instanceof SVGElement);
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function injectNativeTagCheck(app) {
    Object.defineProperty(app.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
      const isCustomElement = app.config.isCustomElement;
      Object.defineProperty(app.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn2(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
        }
      });
      const compilerOptions = app.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
      Object.defineProperty(app.config, "compilerOptions", {
        get() {
          warn2(msg);
          return compilerOptions;
        },
        set() {
          warn2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn2(`Failed to mount app: mount target selector "${container}" returned null.`);
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn2(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
  }

  // node_modules/vue/dist/vue.runtime.esm-bundler.js
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  if (true) {
    initDev();
  }

  // node_modules/tslib/modules/index.js
  var import_tslib = __toModule(require_tslib());
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // node_modules/@antv/util/esm/is-array-like.js
  var isArrayLike = function(value) {
    return value !== null && typeof value !== "function" && isFinite(value.length);
  };
  var is_array_like_default = isArrayLike;

  // node_modules/@antv/util/esm/contains.js
  var contains = function(arr, value) {
    if (!is_array_like_default(arr)) {
      return false;
    }
    return arr.indexOf(value) > -1;
  };
  var contains_default = contains;

  // node_modules/@antv/util/esm/filter.js
  var filter = function(arr, func2) {
    if (!is_array_like_default(arr)) {
      return arr;
    }
    var result = [];
    for (var index = 0; index < arr.length; index++) {
      var value = arr[index];
      if (func2(value, index)) {
        result.push(value);
      }
    }
    return result;
  };
  var filter_default = filter;

  // node_modules/@antv/util/esm/difference.js
  var difference = function(arr, values2) {
    if (values2 === void 0) {
      values2 = [];
    }
    return filter_default(arr, function(value) {
      return !contains_default(values2, value);
    });
  };
  var difference_default = difference;

  // node_modules/@antv/util/esm/is-type.js
  var toString = {}.toString;
  var isType = function(value, type) {
    return toString.call(value) === "[object " + type + "]";
  };
  var is_type_default = isType;

  // node_modules/@antv/util/esm/is-function.js
  var is_function_default = function(value) {
    return is_type_default(value, "Function");
  };

  // node_modules/@antv/util/esm/is-nil.js
  var isNil = function(value) {
    return value === null || value === void 0;
  };
  var is_nil_default = isNil;

  // node_modules/@antv/util/esm/is-array.js
  var is_array_default = function(value) {
    return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
  };

  // node_modules/@antv/util/esm/is-object.js
  var is_object_default = function(value) {
    var type = typeof value;
    return value !== null && type === "object" || type === "function";
  };

  // node_modules/@antv/util/esm/each.js
  function each(elements, func2) {
    if (!elements) {
      return;
    }
    var rst;
    if (is_array_default(elements)) {
      for (var i = 0, len3 = elements.length; i < len3; i++) {
        rst = func2(elements[i], i);
        if (rst === false) {
          break;
        }
      }
    } else if (is_object_default(elements)) {
      for (var k in elements) {
        if (elements.hasOwnProperty(k)) {
          rst = func2(elements[k], k);
          if (rst === false) {
            break;
          }
        }
      }
    }
  }
  var each_default = each;

  // node_modules/@antv/util/esm/keys.js
  var keys = Object.keys ? function(obj) {
    return Object.keys(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value, key) {
      if (!(is_function_default(obj) && key === "prototype")) {
        result.push(key);
      }
    });
    return result;
  };
  var keys_default = keys;

  // node_modules/@antv/util/esm/is-match.js
  function isMatch(obj, attrs) {
    var _keys = keys_default(attrs);
    var length3 = _keys.length;
    if (is_nil_default(obj))
      return !length3;
    for (var i = 0; i < length3; i += 1) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) {
        return false;
      }
    }
    return true;
  }
  var is_match_default = isMatch;

  // node_modules/@antv/util/esm/is-object-like.js
  var isObjectLike = function(value) {
    return typeof value === "object" && value !== null;
  };
  var is_object_like_default = isObjectLike;

  // node_modules/@antv/util/esm/is-plain-object.js
  var isPlainObject2 = function(value) {
    if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
      return false;
    }
    if (Object.getPrototypeOf(value) === null) {
      return true;
    }
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
  };
  var is_plain_object_default = isPlainObject2;

  // node_modules/@antv/util/esm/find.js
  function find(arr, predicate) {
    if (!is_array_default(arr))
      return null;
    var _predicate;
    if (is_function_default(predicate)) {
      _predicate = predicate;
    }
    if (is_plain_object_default(predicate)) {
      _predicate = function(a) {
        return is_match_default(a, predicate);
      };
    }
    if (_predicate) {
      for (var i = 0; i < arr.length; i += 1) {
        if (_predicate(arr[i])) {
          return arr[i];
        }
      }
    }
    return null;
  }
  var find_default = find;

  // node_modules/@antv/util/esm/first-value.js
  var firstValue = function(data, name) {
    var rst = null;
    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var value = obj[name];
      if (!is_nil_default(value)) {
        if (is_array_default(value)) {
          rst = value[0];
        } else {
          rst = value;
        }
        break;
      }
    }
    return rst;
  };
  var first_value_default = firstValue;

  // node_modules/@antv/util/esm/flatten.js
  var flatten = function(arr) {
    if (!is_array_default(arr)) {
      return [];
    }
    var rst = [];
    for (var i = 0; i < arr.length; i++) {
      rst = rst.concat(arr[i]);
    }
    return rst;
  };
  var flatten_default = flatten;

  // node_modules/@antv/util/esm/max.js
  var max_default = function(arr) {
    if (!is_array_default(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.max(prev, curr);
    }, arr[0]);
  };

  // node_modules/@antv/util/esm/min.js
  var min_default = function(arr) {
    if (!is_array_default(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.min(prev, curr);
    }, arr[0]);
  };

  // node_modules/@antv/util/esm/get-range.js
  var getRange = function(values2) {
    var filterValues = values2.filter(function(v) {
      return !isNaN(v);
    });
    if (!filterValues.length) {
      return {
        min: 0,
        max: 0
      };
    }
    if (is_array_default(values2[0])) {
      var tmp = [];
      for (var i = 0; i < values2.length; i++) {
        tmp = tmp.concat(values2[i]);
      }
      filterValues = tmp;
    }
    var max7 = max_default(filterValues);
    var min7 = min_default(filterValues);
    return {
      min: min7,
      max: max7
    };
  };
  var get_range_default = getRange;

  // node_modules/@antv/util/esm/pull.js
  var arrPrototype = Array.prototype;
  var splice = arrPrototype.splice;
  var indexOf = arrPrototype.indexOf;

  // node_modules/@antv/util/esm/pull-at.js
  var splice2 = Array.prototype.splice;
  var pullAt = function pullAt2(arr, indexes) {
    if (!is_array_like_default(arr)) {
      return [];
    }
    var length3 = arr ? indexes.length : 0;
    var last2 = length3 - 1;
    while (length3--) {
      var previous = void 0;
      var index = indexes[length3];
      if (length3 === last2 || index !== previous) {
        previous = index;
        splice2.call(arr, index, 1);
      }
    }
    return arr;
  };
  var pull_at_default = pullAt;

  // node_modules/@antv/util/esm/reduce.js
  var reduce = function(arr, fn, init) {
    if (!is_array_default(arr) && !is_plain_object_default(arr)) {
      return arr;
    }
    var result = init;
    each_default(arr, function(data, i) {
      result = fn(result, data, i);
    });
    return result;
  };
  var reduce_default = reduce;

  // node_modules/@antv/util/esm/remove.js
  var remove2 = function(arr, predicate) {
    var result = [];
    if (!is_array_like_default(arr)) {
      return result;
    }
    var i = -1;
    var indexes = [];
    var length3 = arr.length;
    while (++i < length3) {
      var value = arr[i];
      if (predicate(value, i, arr)) {
        result.push(value);
        indexes.push(i);
      }
    }
    pull_at_default(arr, indexes);
    return result;
  };
  var remove_default = remove2;

  // node_modules/@antv/util/esm/is-string.js
  var is_string_default = function(str4) {
    return is_type_default(str4, "String");
  };

  // node_modules/@antv/util/esm/uniq.js
  function uniq(arr, cache3) {
    if (cache3 === void 0) {
      cache3 = new Map();
    }
    var r = [];
    if (Array.isArray(arr)) {
      for (var i = 0, len3 = arr.length; i < len3; i++) {
        var item = arr[i];
        if (!cache3.has(item)) {
          r.push(item);
          cache3.set(item, true);
        }
      }
    }
    return r;
  }

  // node_modules/@antv/util/esm/values-of-key.js
  var values_of_key_default = function(data, name) {
    var rst = [];
    var tmpMap = {};
    for (var i = 0; i < data.length; i++) {
      var obj = data[i];
      var value = obj[name];
      if (!is_nil_default(value)) {
        if (!is_array_default(value)) {
          value = [value];
        }
        for (var j = 0; j < value.length; j++) {
          var val = value[j];
          if (!tmpMap[val]) {
            rst.push(val);
            tmpMap[val] = true;
          }
        }
      }
    }
    return rst;
  };

  // node_modules/@antv/util/esm/head.js
  function head(o) {
    if (is_array_like_default(o)) {
      return o[0];
    }
    return void 0;
  }

  // node_modules/@antv/util/esm/last.js
  function last(o) {
    if (is_array_like_default(o)) {
      var arr = o;
      return arr[arr.length - 1];
    }
    return void 0;
  }

  // node_modules/@antv/util/esm/every.js
  var every = function(arr, func2) {
    for (var i = 0; i < arr.length; i++) {
      if (!func2(arr[i], i))
        return false;
    }
    return true;
  };
  var every_default = every;

  // node_modules/@antv/util/esm/some.js
  var some = function(arr, func2) {
    for (var i = 0; i < arr.length; i++) {
      if (func2(arr[i], i))
        return true;
    }
    return false;
  };
  var some_default = some;

  // node_modules/@antv/util/esm/group-by.js
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  function groupBy(data, condition) {
    if (!condition || !is_array_default(data)) {
      return {};
    }
    var result = {};
    var predicate = is_function_default(condition) ? condition : function(item2) {
      return item2[condition];
    };
    var key;
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      key = predicate(item);
      if (hasOwnProperty2.call(result, key)) {
        result[key].push(item);
      } else {
        result[key] = [item];
      }
    }
    return result;
  }
  var group_by_default = groupBy;

  // node_modules/@antv/util/esm/group-to-map.js
  function groupToMap(data, condition) {
    if (!condition) {
      return {
        0: data
      };
    }
    if (!is_function_default(condition)) {
      var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
      condition = function(row) {
        var unique5 = "_";
        for (var i = 0, l = paramscondition_1.length; i < l; i++) {
          unique5 += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
        }
        return unique5;
      };
    }
    return group_by_default(data, condition);
  }

  // node_modules/@antv/util/esm/group.js
  var group_default = function(data, condition) {
    if (!condition) {
      return [data];
    }
    var groups = groupToMap(data, condition);
    var array2 = [];
    for (var i in groups) {
      array2.push(groups[i]);
    }
    return array2;
  };

  // node_modules/@antv/util/esm/clamp.js
  var clamp = function(a, min7, max7) {
    if (a < min7) {
      return min7;
    } else if (a > max7) {
      return max7;
    }
    return a;
  };
  var clamp_default = clamp;

  // node_modules/@antv/util/esm/fixed-base.js
  var fixedBase = function(v, base2) {
    var str4 = base2.toString();
    var index = str4.indexOf(".");
    if (index === -1) {
      return Math.round(v);
    }
    var length3 = str4.substr(index + 1).length;
    if (length3 > 20) {
      length3 = 20;
    }
    return parseFloat(v.toFixed(length3));
  };
  var fixed_base_default = fixedBase;

  // node_modules/@antv/util/esm/is-number.js
  var isNumber = function(value) {
    return is_type_default(value, "Number");
  };
  var is_number_default = isNumber;

  // node_modules/@antv/util/esm/is-integer.js
  var isInteger = Number.isInteger ? Number.isInteger : function(num) {
    return is_number_default(num) && num % 1 === 0;
  };

  // node_modules/@antv/util/esm/is-number-equal.js
  var PRECISION = 1e-5;
  function isNumberEqual(a, b, precision2) {
    if (precision2 === void 0) {
      precision2 = PRECISION;
    }
    return Math.abs(a - b) < precision2;
  }

  // node_modules/@antv/util/esm/mod.js
  var mod = function(n, m) {
    return (n % m + m) % m;
  };
  var mod_default = mod;

  // node_modules/@antv/util/esm/to-degree.js
  var DEGREE = 180 / Math.PI;

  // node_modules/@antv/util/esm/to-radian.js
  var RADIAN = Math.PI / 180;
  var toRadian = function(degree2) {
    return RADIAN * degree2;
  };
  var to_radian_default = toRadian;

  // node_modules/@antv/util/esm/has.js
  var has_default = function(obj, key) {
    return obj.hasOwnProperty(key);
  };

  // node_modules/@antv/util/esm/has-key.js
  var has_key_default = has_default;

  // node_modules/@antv/util/esm/values.js
  var values = Object.values ? function(obj) {
    return Object.values(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value, key) {
      if (!(is_function_default(obj) && key === "prototype")) {
        result.push(value);
      }
    });
    return result;
  };
  var values_default = values;

  // node_modules/@antv/util/esm/to-string.js
  var to_string_default = function(value) {
    if (is_nil_default(value))
      return "";
    return value.toString();
  };

  // node_modules/@antv/util/esm/lower-case.js
  var lowerCase = function(str4) {
    return to_string_default(str4).toLowerCase();
  };
  var lower_case_default = lowerCase;

  // node_modules/@antv/util/esm/substitute.js
  function substitute(str4, o) {
    if (!str4 || !o) {
      return str4;
    }
    return str4.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
      if (match.charAt(0) === "\\") {
        return match.slice(1);
      }
      return o[name] === void 0 ? "" : o[name];
    });
  }
  var substitute_default = substitute;

  // node_modules/@antv/util/esm/upper-first.js
  var upperFirst = function(value) {
    var str4 = to_string_default(value);
    return str4.charAt(0).toUpperCase() + str4.substring(1);
  };
  var upper_first_default = upperFirst;

  // node_modules/@antv/util/esm/get-type.js
  var toString2 = {}.toString;
  var getType2 = function(value) {
    return toString2.call(value).replace(/^\[object /, "").replace(/]$/, "");
  };
  var get_type_default = getType2;

  // node_modules/@antv/util/esm/is-boolean.js
  var isBoolean2 = function(value) {
    return is_type_default(value, "Boolean");
  };
  var is_boolean_default = isBoolean2;

  // node_modules/@antv/util/esm/is-date.js
  var isDate = function(value) {
    return is_type_default(value, "Date");
  };
  var is_date_default = isDate;

  // node_modules/@antv/util/esm/is-null.js
  var isNull = function(value) {
    return value === null;
  };
  var is_null_default = isNull;

  // node_modules/@antv/util/esm/is-prototype.js
  var objectProto = Object.prototype;
  var isPrototype = function(value) {
    var Ctor = value && value.constructor;
    var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var is_prototype_default = isPrototype;

  // node_modules/@antv/util/esm/is-undefined.js
  var isUndefined = function(value) {
    return value === void 0;
  };
  var is_undefined_default = isUndefined;

  // node_modules/@antv/util/esm/is-element.js
  var isElement = function(o) {
    return o instanceof Element || o instanceof HTMLDocument;
  };
  var is_element_default = isElement;

  // node_modules/@antv/util/esm/request-animation-frame.js
  function requestAnimationFrame2(fn) {
    var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
      return setTimeout(f, 16);
    };
    return method(fn);
  }

  // node_modules/@antv/util/esm/clear-animation-frame.js
  function cancelAnimationFrame(handler) {
    var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
    method(handler);
  }

  // node_modules/@antv/util/esm/mix.js
  function _mix(dist3, obj) {
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
        dist3[key] = obj[key];
      }
    }
  }
  function mix(dist3, src1, src2, src3) {
    if (src1)
      _mix(dist3, src1);
    if (src2)
      _mix(dist3, src2);
    if (src3)
      _mix(dist3, src3);
    return dist3;
  }

  // node_modules/@antv/util/esm/clone.js
  var clone = function(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (is_array_default(obj)) {
      rst = [];
      for (var i = 0, l = obj.length; i < l; i++) {
        if (typeof obj[i] === "object" && obj[i] != null) {
          rst[i] = clone(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (typeof obj[k] === "object" && obj[k] != null) {
          rst[k] = clone(obj[k]);
        } else {
          rst[k] = obj[k];
        }
      }
    }
    return rst;
  };
  var clone_default = clone;

  // node_modules/@antv/util/esm/debounce.js
  function debounce(func2, wait, immediate) {
    var timeout2;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout2 = null;
        if (!immediate) {
          func2.apply(context, args);
        }
      };
      var callNow = immediate && !timeout2;
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
      if (callNow) {
        func2.apply(context, args);
      }
    };
  }
  var debounce_default = debounce;

  // node_modules/@antv/util/esm/memoize.js
  var memoize_default = function(f, resolver) {
    if (!is_function_default(f)) {
      throw new TypeError("Expected a function");
    }
    var memoized = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache3 = memoized.cache;
      if (cache3.has(key)) {
        return cache3.get(key);
      }
      var result = f.apply(this, args);
      cache3.set(key, result);
      return result;
    };
    memoized.cache = new Map();
    return memoized;
  };

  // node_modules/@antv/util/esm/deep-mix.js
  var MAX_MIX_LEVEL = 5;
  function _deepMix(dist3, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        var value = src[key];
        if (value !== null && is_plain_object_default(value)) {
          if (!is_plain_object_default(dist3[key])) {
            dist3[key] = {};
          }
          if (level < maxLevel) {
            _deepMix(dist3[key], value, level + 1, maxLevel);
          } else {
            dist3[key] = src[key];
          }
        } else if (is_array_default(value)) {
          dist3[key] = [];
          dist3[key] = dist3[key].concat(value);
        } else if (value !== void 0) {
          dist3[key] = value;
        }
      }
    }
  }
  var deepMix = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      _deepMix(rst, args[i]);
    }
    return rst;
  };
  var deep_mix_default = deepMix;

  // node_modules/@antv/util/esm/index-of.js
  var indexOf2 = function(arr, obj) {
    if (!is_array_like_default(arr)) {
      return -1;
    }
    var m = Array.prototype.indexOf;
    if (m) {
      return m.call(arr, obj);
    }
    var index = -1;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === obj) {
        index = i;
        break;
      }
    }
    return index;
  };
  var index_of_default = indexOf2;

  // node_modules/@antv/util/esm/is-empty.js
  var hasOwnProperty3 = Object.prototype.hasOwnProperty;
  function isEmpty(value) {
    if (is_nil_default(value)) {
      return true;
    }
    if (is_array_like_default(value)) {
      return !value.length;
    }
    var type = get_type_default(value);
    if (type === "Map" || type === "Set") {
      return !value.size;
    }
    if (is_prototype_default(value)) {
      return !Object.keys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty3.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  var is_empty_default = isEmpty;

  // node_modules/@antv/util/esm/is-equal.js
  var isEqual = function(value, other) {
    if (value === other) {
      return true;
    }
    if (!value || !other) {
      return false;
    }
    if (is_string_default(value) || is_string_default(other)) {
      return false;
    }
    if (is_array_like_default(value) || is_array_like_default(other)) {
      if (value.length !== other.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < value.length; i++) {
        rst = isEqual(value[i], other[i]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    if (is_object_like_default(value) || is_object_like_default(other)) {
      var valueKeys = Object.keys(value);
      var otherKeys = Object.keys(other);
      if (valueKeys.length !== otherKeys.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < valueKeys.length; i++) {
        rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    return false;
  };
  var is_equal_default = isEqual;

  // node_modules/@antv/util/esm/map.js
  var map2 = function(arr, func2) {
    if (!is_array_like_default(arr)) {
      return arr;
    }
    var result = [];
    for (var index = 0; index < arr.length; index++) {
      var value = arr[index];
      result.push(func2(value, index));
    }
    return result;
  };
  var map_default = map2;

  // node_modules/@antv/util/esm/map-values.js
  var identity = function(v) {
    return v;
  };
  var map_values_default = function(object, func2) {
    if (func2 === void 0) {
      func2 = identity;
    }
    var r = {};
    if (is_object_default(object) && !is_nil_default(object)) {
      Object.keys(object).forEach(function(key) {
        r[key] = func2(object[key], key);
      });
    }
    return r;
  };

  // node_modules/@antv/util/esm/get.js
  var get_default = function(obj, key, defaultValue) {
    var p3 = 0;
    var keyArr = is_string_default(key) ? key.split(".") : key;
    while (obj && p3 < keyArr.length) {
      obj = obj[keyArr[p3++]];
    }
    return obj === void 0 || p3 < keyArr.length ? defaultValue : obj;
  };

  // node_modules/@antv/util/esm/set.js
  var set_default = function(obj, path, value) {
    var o = obj;
    var keyArr = is_string_default(path) ? path.split(".") : path;
    keyArr.forEach(function(key, idx) {
      if (idx < keyArr.length - 1) {
        if (!is_object_default(o[key])) {
          o[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
        }
        o = o[key];
      } else {
        o[key] = value;
      }
    });
    return obj;
  };

  // node_modules/@antv/util/esm/pick.js
  var hasOwnProperty4 = Object.prototype.hasOwnProperty;
  var pick_default = function(object, keys2) {
    if (object === null || !is_plain_object_default(object)) {
      return {};
    }
    var result = {};
    each_default(keys2, function(key) {
      if (hasOwnProperty4.call(object, key)) {
        result[key] = object[key];
      }
    });
    return result;
  };

  // node_modules/@antv/util/esm/throttle.js
  var throttle_default = function(func2, wait, options) {
    var timeout2, context, args, result;
    var previous = 0;
    if (!options)
      options = {};
    var later = function() {
      previous = options.leading === false ? 0 : Date.now();
      timeout2 = null;
      result = func2.apply(context, args);
      if (!timeout2)
        context = args = null;
    };
    var throttled = function() {
      var now3 = Date.now();
      if (!previous && options.leading === false)
        previous = now3;
      var remaining = wait - (now3 - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
        previous = now3;
        result = func2.apply(context, args);
        if (!timeout2)
          context = args = null;
      } else if (!timeout2 && options.trailing !== false) {
        timeout2 = setTimeout(later, remaining);
      }
      return result;
    };
    throttled.cancel = function() {
      clearTimeout(timeout2);
      previous = 0;
      timeout2 = context = args = null;
    };
    return throttled;
  };

  // node_modules/@antv/util/esm/to-array.js
  var to_array_default = function(value) {
    return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
  };

  // node_modules/@antv/util/esm/unique-id.js
  var map3 = {};
  var unique_id_default = function(prefix) {
    prefix = prefix || "g";
    if (!map3[prefix]) {
      map3[prefix] = 1;
    } else {
      map3[prefix] += 1;
    }
    return prefix + map3[prefix];
  };

  // node_modules/@antv/util/esm/noop.js
  var noop_default = function() {
  };

  // node_modules/@antv/util/esm/size.js
  function size2(o) {
    if (is_nil_default(o)) {
      return 0;
    }
    if (is_array_like_default(o)) {
      return o.length;
    }
    return Object.keys(o).length;
  }

  // node_modules/@antv/util/node_modules/tslib/modules/index.js
  var import_tslib2 = __toModule(require_tslib2());
  var {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter2,
    __generator: __generator2,
    __exportStar: __exportStar2,
    __createBinding: __createBinding2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __spreadArray: __spreadArray2,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2
  } = import_tslib2.default;

  // node_modules/@antv/util/esm/measure-text-width.js
  var ctx;
  var measure_text_width_default = memoize_default(function(text, font) {
    if (font === void 0) {
      font = {};
    }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (!ctx) {
      ctx = document.createElement("canvas").getContext("2d");
    }
    ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
    return ctx.measureText(is_string_default(text) ? text : "").width;
  }, function(text, font) {
    if (font === void 0) {
      font = {};
    }
    return __spreadArrays2([text], values_default(font)).join("");
  });

  // node_modules/@antv/util/esm/get-ellipsis-text.js
  var get_ellipsis_text_default = function(text, maxWidth, font, str4) {
    if (str4 === void 0) {
      str4 = "...";
    }
    var STEP = 16;
    var PLACEHOLDER_WIDTH = measure_text_width_default(str4, font);
    var leftText = !is_string_default(text) ? to_string_default(text) : text;
    var leftWidth = maxWidth;
    var r = [];
    var currentText;
    var currentWidth;
    if (measure_text_width_default(text, font) <= maxWidth) {
      return text;
    }
    while (true) {
      currentText = leftText.substr(0, STEP);
      currentWidth = measure_text_width_default(currentText, font);
      if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
        if (currentWidth > leftWidth) {
          break;
        }
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(STEP);
      if (!leftText) {
        return r.join("");
      }
    }
    while (true) {
      currentText = leftText.substr(0, 1);
      currentWidth = measure_text_width_default(currentText, font);
      if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
        break;
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(1);
      if (!leftText) {
        return r.join("");
      }
    }
    return "" + r.join("") + str4;
  };

  // node_modules/@antv/util/esm/cache.js
  var default_1 = function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def2) {
      var v = this.map[key];
      return v === void 0 ? def2 : v;
    };
    default_12.prototype.set = function(key, value) {
      this.map[key] = value;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }();
  var cache_default = default_1;

  // node_modules/@antv/g2/esm/constant.js
  var LAYER;
  (function(LAYER2) {
    LAYER2["FORE"] = "fore";
    LAYER2["MID"] = "mid";
    LAYER2["BG"] = "bg";
  })(LAYER || (LAYER = {}));
  var DIRECTION;
  (function(DIRECTION2) {
    DIRECTION2["TOP"] = "top";
    DIRECTION2["TOP_LEFT"] = "top-left";
    DIRECTION2["TOP_RIGHT"] = "top-right";
    DIRECTION2["RIGHT"] = "right";
    DIRECTION2["RIGHT_TOP"] = "right-top";
    DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
    DIRECTION2["LEFT"] = "left";
    DIRECTION2["LEFT_TOP"] = "left-top";
    DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
    DIRECTION2["BOTTOM"] = "bottom";
    DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
    DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
    DIRECTION2["RADIUS"] = "radius";
    DIRECTION2["CIRCLE"] = "circle";
    DIRECTION2["NONE"] = "none";
  })(DIRECTION || (DIRECTION = {}));
  var COMPONENT_TYPE;
  (function(COMPONENT_TYPE2) {
    COMPONENT_TYPE2["AXIS"] = "axis";
    COMPONENT_TYPE2["GRID"] = "grid";
    COMPONENT_TYPE2["LEGEND"] = "legend";
    COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
    COMPONENT_TYPE2["ANNOTATION"] = "annotation";
    COMPONENT_TYPE2["SLIDER"] = "slider";
    COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
    COMPONENT_TYPE2["OTHER"] = "other";
  })(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
  var GROUP_Z_INDEX = {
    FORE: 3,
    MID: 2,
    BG: 1
  };
  var VIEW_LIFE_CIRCLE;
  (function(VIEW_LIFE_CIRCLE2) {
    VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
    VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
    VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
    VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
    VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
    VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
    VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
    VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
    VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
    VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
    VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
  })(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
  var GEOMETRY_LIFE_CIRCLE;
  (function(GEOMETRY_LIFE_CIRCLE2) {
    GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
    GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
  })(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
  var PLOT_EVENTS;
  (function(PLOT_EVENTS2) {
    PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
    PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
    PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
    PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
    PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
    PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
    PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
    PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
    PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
    PLOT_EVENTS2["CLICK"] = "plot:click";
    PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
    PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
    PLOT_EVENTS2["LEAVE"] = "plot:leave";
    PLOT_EVENTS2["ENTER"] = "plot:enter";
  })(PLOT_EVENTS || (PLOT_EVENTS = {}));
  var ELEMENT_STATE;
  (function(ELEMENT_STATE2) {
    ELEMENT_STATE2["ACTIVE"] = "active";
    ELEMENT_STATE2["INACTIVE"] = "inactive";
    ELEMENT_STATE2["SELECTED"] = "selected";
    ELEMENT_STATE2["DEFAULT"] = "default";
  })(ELEMENT_STATE || (ELEMENT_STATE = {}));
  var GROUP_ATTRS = ["color", "shape", "size"];
  var FIELD_ORIGIN = "_origin";
  var MIN_CHART_WIDTH = 1;
  var MIN_CHART_HEIGHT = 1;
  var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;

  // node_modules/@antv/g2/esm/engine/index.js
  var ENGINES = {};
  function getEngine(name) {
    var G = ENGINES[name];
    if (!G) {
      throw new Error("G engine '" + name + "' is not exist, please register it at first.");
    }
    return G;
  }
  function registerEngine(name, engine2) {
    ENGINES[name] = engine2;
  }

  // node_modules/@antv/dom-util/esm/add-event-listener.js
  function addEventListener2(target, eventType, callback) {
    if (target) {
      if (typeof target.addEventListener === "function") {
        target.addEventListener(eventType, callback, false);
        return {
          remove: function() {
            target.removeEventListener(eventType, callback, false);
          }
        };
      }
      if (typeof target.attachEvent === "function") {
        target.attachEvent("on" + eventType, callback);
        return {
          remove: function() {
            target.detachEvent("on" + eventType, callback);
          }
        };
      }
    }
  }

  // node_modules/@antv/dom-util/esm/create-dom.js
  var TABLE;
  var TABLE_TR;
  var FRAGMENT_REG;
  var CONTAINERS;
  function initConstants() {
    TABLE = document.createElement("table");
    TABLE_TR = document.createElement("tr");
    FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
    CONTAINERS = {
      tr: document.createElement("tbody"),
      tbody: TABLE,
      thead: TABLE,
      tfoot: TABLE,
      td: TABLE_TR,
      th: TABLE_TR,
      "*": document.createElement("div")
    };
  }
  function createDom(str4) {
    if (!TABLE) {
      initConstants();
    }
    var name = FRAGMENT_REG.test(str4) && RegExp.$1;
    if (!name || !(name in CONTAINERS)) {
      name = "*";
    }
    var container = CONTAINERS[name];
    str4 = str4.replace(/(^\s*)|(\s*$)/g, "");
    container.innerHTML = "" + str4;
    var dom = container.childNodes[0];
    container.removeChild(dom);
    return dom;
  }

  // node_modules/@antv/dom-util/esm/get-style.js
  function getStyle(dom, name, defaultValue) {
    var v;
    try {
      v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
    } catch (e) {
    } finally {
      v = v === void 0 ? defaultValue : v;
    }
    return v;
  }

  // node_modules/@antv/dom-util/esm/get-height.js
  function getHeight(el, defaultValue) {
    var height = getStyle(el, "height", defaultValue);
    if (height === "auto") {
      height = el.offsetHeight;
    }
    return parseFloat(height);
  }

  // node_modules/@antv/dom-util/esm/get-outer-height.js
  function getOuterHeight(el, defaultValue) {
    var height = getHeight(el, defaultValue);
    var bTop = parseFloat(getStyle(el, "borderTopWidth")) || 0;
    var pTop = parseFloat(getStyle(el, "paddingTop")) || 0;
    var pBottom = parseFloat(getStyle(el, "paddingBottom")) || 0;
    var bBottom = parseFloat(getStyle(el, "borderBottomWidth")) || 0;
    var mTop = parseFloat(getStyle(el, "marginTop")) || 0;
    var mBottom = parseFloat(getStyle(el, "marginBottom")) || 0;
    return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
  }

  // node_modules/@antv/dom-util/esm/get-width.js
  function getHeight2(el, defaultValue) {
    var width = getStyle(el, "width", defaultValue);
    if (width === "auto") {
      width = el.offsetWidth;
    }
    return parseFloat(width);
  }

  // node_modules/@antv/dom-util/esm/get-outer-width.js
  function getOuterWidth(el, defaultValue) {
    var width = getHeight2(el, defaultValue);
    var bLeft = parseFloat(getStyle(el, "borderLeftWidth")) || 0;
    var pLeft = parseFloat(getStyle(el, "paddingLeft")) || 0;
    var pRight = parseFloat(getStyle(el, "paddingRight")) || 0;
    var bRight = parseFloat(getStyle(el, "borderRightWidth")) || 0;
    var mRight = parseFloat(getStyle(el, "marginRight")) || 0;
    var mLeft = parseFloat(getStyle(el, "marginLeft")) || 0;
    return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
  }

  // node_modules/@antv/dom-util/esm/modify-css.js
  function modifyCSS(dom, css) {
    if (dom) {
      for (var key in css) {
        if (css.hasOwnProperty(key)) {
          dom.style[key] = css[key];
        }
      }
    }
    return dom;
  }

  // node_modules/@antv/g2/esm/util/dom.js
  function getElementSize(ele) {
    var style = getComputedStyle(ele);
    return {
      width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
      height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
    };
  }
  function isNumber2(v) {
    return typeof v === "number" && !isNaN(v);
  }
  function getChartSize(ele, autoFit, width, height) {
    var w = width;
    var h2 = height;
    if (autoFit) {
      var size3 = getElementSize(ele);
      w = size3.width ? size3.width : w;
      h2 = size3.height ? size3.height : h2;
    }
    return {
      width: Math.max(isNumber2(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
      height: Math.max(isNumber2(h2) ? h2 : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
    };
  }
  function removeDom(dom) {
    var parent = dom.parentNode;
    if (parent) {
      parent.removeChild(dom);
    }
  }

  // node_modules/@antv/event-emitter/esm/index.js
  var WILDCARD = "*";
  var EventEmitter = function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      this.on(evt, callback, true);
      return this;
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD] || [];
      var doEmit = function(es) {
        var length3 = es.length;
        for (var i = 0; i < length3; i++) {
          if (!es[i]) {
            continue;
          }
          var _a4 = es[i], callback = _a4.callback, once = _a4.once;
          if (once) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length3--;
            i--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }();
  var esm_default = EventEmitter;

  // node_modules/@antv/g2/esm/base.js
  var Base = function(_super) {
    __extends(Base4, _super);
    function Base4(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var _a4 = cfg.visible, visible = _a4 === void 0 ? true : _a4;
      _this.visible = visible;
      return _this;
    }
    Base4.prototype.show = function() {
      var visible = this.visible;
      if (!visible) {
        this.changeVisible(true);
      }
    };
    Base4.prototype.hide = function() {
      var visible = this.visible;
      if (visible) {
        this.changeVisible(false);
      }
    };
    Base4.prototype.destroy = function() {
      this.off();
      this.destroyed = true;
    };
    Base4.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;
    };
    return Base4;
  }(esm_default);
  var base_default = Base;

  // node_modules/@antv/g-base/esm/util/path.js
  var path_exports = {};
  __export(path_exports, {
    catmullRomToBezier: () => catmullRomToBezier,
    fillPath: () => fillPath,
    fillPathByDiff: () => fillPathByDiff,
    formatPath: () => formatPath,
    intersection: () => intersection,
    parsePathArray: () => parsePathArray,
    parsePathString: () => parsePathString,
    pathToAbsolute: () => pathToAbsolute,
    pathToCurve: () => pathToCurve,
    rectPath: () => rectPath
  });
  var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
  var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
  var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
  var parsePathString = function(pathString) {
    if (!pathString) {
      return null;
    }
    if (is_array_default(pathString)) {
      return pathString;
    }
    var paramCounts = {
      a: 7,
      c: 6,
      o: 2,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      u: 3,
      z: 0
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND, function(a, b, c) {
      var params = [];
      var name = b.toLowerCase();
      c.replace(PATH_VALUES, function(a6, b10) {
        b10 && params.push(+b10);
      });
      if (name === "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = "l";
        b = b === "m" ? "l" : "L";
      }
      if (name === "o" && params.length === 1) {
        data.push([b, params[0]]);
      }
      if (name === "r") {
        data.push([b].concat(params));
      } else {
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      }
      return pathString;
    });
    return data;
  };
  var catmullRomToBezier = function(crp, z) {
    var d = [];
    for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
      var p3 = [
        {
          x: +crp[i - 2],
          y: +crp[i - 1]
        },
        {
          x: +crp[i],
          y: +crp[i + 1]
        },
        {
          x: +crp[i + 2],
          y: +crp[i + 3]
        },
        {
          x: +crp[i + 4],
          y: +crp[i + 5]
        }
      ];
      if (z) {
        if (!i) {
          p3[0] = {
            x: +crp[iLen - 2],
            y: +crp[iLen - 1]
          };
        } else if (iLen - 4 === i) {
          p3[3] = {
            x: +crp[0],
            y: +crp[1]
          };
        } else if (iLen - 2 === i) {
          p3[2] = {
            x: +crp[0],
            y: +crp[1]
          };
          p3[3] = {
            x: +crp[2],
            y: +crp[3]
          };
        }
      } else {
        if (iLen - 4 === i) {
          p3[3] = p3[2];
        } else if (!i) {
          p3[0] = {
            x: +crp[i],
            y: +crp[i + 1]
          };
        }
      }
      d.push([
        "C",
        (-p3[0].x + 6 * p3[1].x + p3[2].x) / 6,
        (-p3[0].y + 6 * p3[1].y + p3[2].y) / 6,
        (p3[1].x + 6 * p3[2].x - p3[3].x) / 6,
        (p3[1].y + 6 * p3[2].y - p3[3].y) / 6,
        p3[2].x,
        p3[2].y
      ]);
    }
    return d;
  };
  var ellipsePath = function(x, y, rx, ry, a) {
    var res = [];
    if (a === null && ry === null) {
      ry = rx;
    }
    x = +x;
    y = +y;
    rx = +rx;
    ry = +ry;
    if (a !== null) {
      var rad = Math.PI / 180;
      var x1 = x + rx * Math.cos(-ry * rad);
      var x2 = x + rx * Math.cos(-a * rad);
      var y1 = y + rx * Math.sin(-ry * rad);
      var y2 = y + rx * Math.sin(-a * rad);
      res = [
        ["M", x1, y1],
        ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
      ];
    } else {
      res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
    }
    return res;
  };
  var pathToAbsolute = function(pathArray) {
    pathArray = parsePathString(pathArray);
    if (!pathArray || !pathArray.length) {
      return [["M", 0, 0]];
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    if (pathArray[0][0] === "M") {
      x = +pathArray[0][1];
      y = +pathArray[0][2];
      mx = x;
      my = y;
      start++;
      res[0] = ["M", x, y];
    }
    var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
    for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
      res.push(r = []);
      pa = pathArray[i];
      pa0 = pa[0];
      if (pa0 !== pa0.toUpperCase()) {
        r[0] = pa0.toUpperCase();
        switch (r[0]) {
          case "A":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case "V":
            r[1] = +pa[1] + y;
            break;
          case "H":
            r[1] = +pa[1] + x;
            break;
          case "R":
            dots = [x, y].concat(pa.slice(1));
            for (var j = 2, jj = dots.length; j < jj; j++) {
              dots[j] = +dots[j] + x;
              dots[++j] = +dots[j] + y;
            }
            res.pop();
            res = res.concat(catmullRomToBezier(dots, crz));
            break;
          case "O":
            res.pop();
            dots = ellipsePath(x, y, pa[1], pa[2]);
            dots.push(dots[0]);
            res = res.concat(dots);
            break;
          case "U":
            res.pop();
            res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
            r = ["U"].concat(res[res.length - 1].slice(-2));
            break;
          case "M":
            mx = +pa[1] + x;
            my = +pa[2] + y;
            break;
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else if (pa0 === "R") {
        dots = [x, y].concat(pa.slice(1));
        res.pop();
        res = res.concat(catmullRomToBezier(dots, crz));
        r = ["R"].concat(pa.slice(-2));
      } else if (pa0 === "O") {
        res.pop();
        dots = ellipsePath(x, y, pa[1], pa[2]);
        dots.push(dots[0]);
        res = res.concat(dots);
      } else if (pa0 === "U") {
        res.pop();
        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
        r = ["U"].concat(res[res.length - 1].slice(-2));
      } else {
        for (var k = 0, kk = pa.length; k < kk; k++) {
          r[k] = pa[k];
        }
      }
      pa0 = pa0.toUpperCase();
      if (pa0 !== "O") {
        switch (r[0]) {
          case "Z":
            x = +mx;
            y = +my;
            break;
          case "H":
            x = r[1];
            break;
          case "V":
            y = r[1];
            break;
          case "M":
            mx = r[r.length - 2];
            my = r[r.length - 1];
            break;
          default:
            x = r[r.length - 2];
            y = r[r.length - 1];
        }
      }
    }
    return res;
  };
  var l2c = function(x1, y1, x2, y2) {
    return [x1, y1, x2, y2, x2, y2];
  };
  var q2c = function(x1, y1, ax, ay, x2, y2) {
    var _13 = 1 / 3;
    var _23 = 2 / 3;
    return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
  };
  var a2c = function(x1, y1, rx, ry, angle3, large_arc_flag, sweep_flag, x2, y2, recursive) {
    if (rx === ry) {
      rx += 1;
    }
    var _120 = Math.PI * 120 / 180;
    var rad = Math.PI / 180 * (+angle3 || 0);
    var res = [];
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    var rotate5 = function(x3, y3, rad2) {
      var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
      var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
      return {
        x: X,
        y: Y
      };
    };
    if (!recursive) {
      xy = rotate5(x1, y1, -rad);
      x1 = xy.x;
      y1 = xy.y;
      xy = rotate5(x2, y2, -rad);
      x2 = xy.x;
      y2 = xy.y;
      if (x1 === x2 && y1 === y2) {
        x2 += 1;
        y2 += 1;
      }
      var x = (x1 - x2) / 2;
      var y = (y1 - y2) / 2;
      var h2 = x * x / (rx * rx) + y * y / (ry * ry);
      if (h2 > 1) {
        h2 = Math.sqrt(h2);
        rx = h2 * rx;
        ry = h2 * ry;
      }
      var rx2 = rx * rx;
      var ry2 = ry * ry;
      var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
      cx = k * rx * y / ry + (x1 + x2) / 2;
      cy = k * -ry * x / rx + (y1 + y2) / 2;
      f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
      f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
      f1 = x1 < cx ? Math.PI - f1 : f1;
      f2 = x2 < cx ? Math.PI - f2 : f2;
      f1 < 0 && (f1 = Math.PI * 2 + f1);
      f2 < 0 && (f2 = Math.PI * 2 + f2);
      if (sweep_flag && f1 > f2) {
        f1 = f1 - Math.PI * 2;
      }
      if (!sweep_flag && f2 > f1) {
        f2 = f2 - Math.PI * 2;
      }
    } else {
      f1 = recursive[0];
      f2 = recursive[1];
      cx = recursive[2];
      cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > _120) {
      var f2old = f2;
      var x2old = x2;
      var y2old = y2;
      f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
      x2 = cx + rx * Math.cos(f2);
      y2 = cy + ry * Math.sin(f2);
      res = a2c(x2, y2, rx, ry, angle3, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c2 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = 4 / 3 * rx * t;
    var hy = 4 / 3 * ry * t;
    var m1 = [x1, y1];
    var m2 = [x1 + hx * s1, y1 - hy * c1];
    var m3 = [x2 + hx * s2, y2 - hy * c2];
    var m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
      return [m2, m3, m4].concat(res);
    }
    res = [m2, m3, m4].concat(res).join().split(",");
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i++) {
      newres[i] = i % 2 ? rotate5(res[i - 1], res[i], rad).y : rotate5(res[i], res[i + 1], rad).x;
    }
    return newres;
  };
  var pathToCurve = function(path, path2) {
    var p3 = pathToAbsolute(path);
    var p22 = path2 && pathToAbsolute(path2);
    var attrs = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    };
    var attrs2 = {
      x: 0,
      y: 0,
      bx: 0,
      by: 0,
      X: 0,
      Y: 0,
      qx: null,
      qy: null
    };
    var pcoms1 = [];
    var pcoms2 = [];
    var pfirst = "";
    var pcom = "";
    var ii;
    var processPath = function(path3, d, pcom2) {
      var nx;
      var ny;
      if (!path3) {
        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
      }
      !(path3[0] in {
        T: 1,
        Q: 1
      }) && (d.qx = d.qy = null);
      switch (path3[0]) {
        case "M":
          d.X = path3[1];
          d.Y = path3[2];
          break;
        case "A":
          path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
          break;
        case "S":
          if (pcom2 === "C" || pcom2 === "S") {
            nx = d.x * 2 - d.bx;
            ny = d.y * 2 - d.by;
          } else {
            nx = d.x;
            ny = d.y;
          }
          path3 = ["C", nx, ny].concat(path3.slice(1));
          break;
        case "T":
          if (pcom2 === "Q" || pcom2 === "T") {
            d.qx = d.x * 2 - d.qx;
            d.qy = d.y * 2 - d.qy;
          } else {
            d.qx = d.x;
            d.qy = d.y;
          }
          path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
          break;
        case "Q":
          d.qx = path3[1];
          d.qy = path3[2];
          path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
          break;
        case "L":
          path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
          break;
        case "H":
          path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
          break;
        case "V":
          path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
          break;
        case "Z":
          path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
          break;
        default:
          break;
      }
      return path3;
    };
    var fixArc = function(pp, i2) {
      if (pp[i2].length > 7) {
        pp[i2].shift();
        var pi2 = pp[i2];
        while (pi2.length) {
          pcoms1[i2] = "A";
          p22 && (pcoms2[i2] = "A");
          pp.splice(i2++, 0, ["C"].concat(pi2.splice(0, 6)));
        }
        pp.splice(i2, 1);
        ii = Math.max(p3.length, p22 && p22.length || 0);
      }
    };
    var fixM = function(path1, path22, a12, a22, i2) {
      if (path1 && path22 && path1[i2][0] === "M" && path22[i2][0] !== "M") {
        path22.splice(i2, 0, ["M", a22.x, a22.y]);
        a12.bx = 0;
        a12.by = 0;
        a12.x = path1[i2][1];
        a12.y = path1[i2][2];
        ii = Math.max(p3.length, p22 && p22.length || 0);
      }
    };
    ii = Math.max(p3.length, p22 && p22.length || 0);
    for (var i = 0; i < ii; i++) {
      p3[i] && (pfirst = p3[i][0]);
      if (pfirst !== "C") {
        pcoms1[i] = pfirst;
        i && (pcom = pcoms1[i - 1]);
      }
      p3[i] = processPath(p3[i], attrs, pcom);
      if (pcoms1[i] !== "A" && pfirst === "C")
        pcoms1[i] = "C";
      fixArc(p3, i);
      if (p22) {
        p22[i] && (pfirst = p22[i][0]);
        if (pfirst !== "C") {
          pcoms2[i] = pfirst;
          i && (pcom = pcoms2[i - 1]);
        }
        p22[i] = processPath(p22[i], attrs2, pcom);
        if (pcoms2[i] !== "A" && pfirst === "C") {
          pcoms2[i] = "C";
        }
        fixArc(p22, i);
      }
      fixM(p3, p22, attrs, attrs2, i);
      fixM(p22, p3, attrs2, attrs, i);
      var seg = p3[i];
      var seg2 = p22 && p22[i];
      var seglen = seg.length;
      var seg2len = p22 && seg2.length;
      attrs.x = seg[seglen - 2];
      attrs.y = seg[seglen - 1];
      attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
      attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
      attrs2.bx = p22 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
      attrs2.by = p22 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
      attrs2.x = p22 && seg2[seg2len - 2];
      attrs2.y = p22 && seg2[seg2len - 1];
    }
    return p22 ? [p3, p22] : p3;
  };
  var p2s = /,?([a-z]),?/gi;
  var parsePathArray = function(path) {
    return path.join(",").replace(p2s, "$1");
  };
  var base3 = function(t, p1, p22, p3, p4) {
    var t1 = -3 * p1 + 9 * p22 - 9 * p3 + 3 * p4;
    var t2 = t * t1 + 6 * p1 - 12 * p22 + 6 * p3;
    return t * t2 - 3 * p1 + 3 * p22;
  };
  var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
    if (z === null) {
      z = 1;
    }
    z = z > 1 ? 1 : z < 0 ? 0 : z;
    var z2 = z / 2;
    var n = 12;
    var Tvalues = [
      -0.1252,
      0.1252,
      -0.3678,
      0.3678,
      -0.5873,
      0.5873,
      -0.7699,
      0.7699,
      -0.9041,
      0.9041,
      -0.9816,
      0.9816
    ];
    var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
    var sum5 = 0;
    for (var i = 0; i < n; i++) {
      var ct = z2 * Tvalues[i] + z2;
      var xbase = base3(ct, x1, x2, x3, x4);
      var ybase = base3(ct, y1, y2, y3, y4);
      var comb = xbase * xbase + ybase * ybase;
      sum5 += Cvalues[i] * Math.sqrt(comb);
    }
    return z2 * sum5;
  };
  var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
    var tvalues = [];
    var bounds = [[], []];
    var a;
    var b;
    var c;
    var t;
    for (var i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (t > 0 && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      var b2ac = b * b - 4 * c * a;
      var sqrtb2ac = Math.sqrt(b2ac);
      if (b2ac < 0) {
        continue;
      }
      var t1 = (-b + sqrtb2ac) / (2 * a);
      if (t1 > 0 && t1 < 1) {
        tvalues.push(t1);
      }
      var t2 = (-b - sqrtb2ac) / (2 * a);
      if (t2 > 0 && t2 < 1) {
        tvalues.push(t2);
      }
    }
    var j = tvalues.length;
    var jlen = j;
    var mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }
    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return {
      min: {
        x: Math.min.apply(0, bounds[0]),
        y: Math.min.apply(0, bounds[1])
      },
      max: {
        x: Math.max.apply(0, bounds[0]),
        y: Math.max.apply(0, bounds[1])
      }
    };
  };
  var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
    if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
      return;
    }
    var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
    var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
    var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (!denominator) {
      return;
    }
    var px = nx / denominator;
    var py = ny / denominator;
    var px2 = +px.toFixed(2);
    var py2 = +py.toFixed(2);
    if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
      return;
    }
    return {
      x: px,
      y: py
    };
  };
  var isPointInsideBBox = function(bbox, x, y) {
    return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
  };
  var rectPath = function(x, y, w, h2, r) {
    if (r) {
      return [
        ["M", +x + +r, y],
        ["l", w - r * 2, 0],
        ["a", r, r, 0, 0, 1, r, r],
        ["l", 0, h2 - r * 2],
        ["a", r, r, 0, 0, 1, -r, r],
        ["l", r * 2 - w, 0],
        ["a", r, r, 0, 0, 1, -r, -r],
        ["l", 0, r * 2 - h2],
        ["a", r, r, 0, 0, 1, r, -r],
        ["z"]
      ];
    }
    var res = [["M", x, y], ["l", w, 0], ["l", 0, h2], ["l", -w, 0], ["z"]];
    res.parsePathArray = parsePathArray;
    return res;
  };
  var box = function(x, y, width, height) {
    if (x === null) {
      x = y = width = height = 0;
    }
    if (y === null) {
      y = x.y;
      width = x.width;
      height = x.height;
      x = x.x;
    }
    return {
      x,
      y,
      width,
      w: width,
      height,
      h: height,
      x2: x + width,
      y2: y + height,
      cx: x + width / 2,
      cy: y + height / 2,
      r1: Math.min(width, height) / 2,
      r2: Math.max(width, height) / 2,
      r0: Math.sqrt(width * width + height * height) / 2,
      path: rectPath(x, y, width, height),
      vb: [x, y, width, height].join(" ")
    };
  };
  var isBBoxIntersect = function(bbox1, bbox2) {
    bbox1 = box(bbox1);
    bbox2 = box(bbox2);
    return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
  };
  var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
    if (!is_array_default(p1x)) {
      p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
    }
    var bbox = curveDim.apply(null, p1x);
    return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
  };
  var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
    var t1 = 1 - t;
    var t13 = Math.pow(t1, 3);
    var t12 = Math.pow(t1, 2);
    var t2 = t * t;
    var t3 = t2 * t;
    var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
    var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
    var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
    var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
    var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
    var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
    var ax = t1 * p1x + t * c1x;
    var ay = t1 * p1y + t * c1y;
    var cx = t1 * c2x + t * p2x;
    var cy = t1 * c2y + t * p2y;
    var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
    return {
      x,
      y,
      m: {
        x: mx,
        y: my
      },
      n: {
        x: nx,
        y: ny
      },
      start: {
        x: ax,
        y: ay
      },
      end: {
        x: cx,
        y: cy
      },
      alpha
    };
  };
  var interHelper = function(bez1, bez2, justCount) {
    var bbox1 = bezierBBox(bez1);
    var bbox2 = bezierBBox(bez2);
    if (!isBBoxIntersect(bbox1, bbox2)) {
      return justCount ? 0 : [];
    }
    var l12 = bezlen.apply(0, bez1);
    var l22 = bezlen.apply(0, bez2);
    var n1 = ~~(l12 / 8);
    var n2 = ~~(l22 / 8);
    var dots1 = [];
    var dots2 = [];
    var xy = {};
    var res = justCount ? 0 : [];
    for (var i = 0; i < n1 + 1; i++) {
      var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
      dots1.push({
        x: d.x,
        y: d.y,
        t: i / n1
      });
    }
    for (var i = 0; i < n2 + 1; i++) {
      var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
      dots2.push({
        x: d.x,
        y: d.y,
        t: i / n2
      });
    }
    for (var i = 0; i < n1; i++) {
      for (var j = 0; j < n2; j++) {
        var di = dots1[i];
        var di1 = dots1[i + 1];
        var dj = dots2[j];
        var dj1 = dots2[j + 1];
        var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
        var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
        var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
        if (is) {
          if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
            continue;
          }
          xy[is.x.toFixed(4)] = is.y.toFixed(4);
          var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
          var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
          if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
            if (justCount) {
              res += 1;
            } else {
              res.push({
                x: is.x,
                y: is.y,
                t1,
                t2
              });
            }
          }
        }
      }
    }
    return res;
  };
  var interPathHelper = function(path1, path2, justCount) {
    path1 = pathToCurve(path1);
    path2 = pathToCurve(path2);
    var x1;
    var y1;
    var x2;
    var y2;
    var x1m;
    var y1m;
    var x2m;
    var y2m;
    var bez1;
    var bez2;
    var res = justCount ? 0 : [];
    for (var i = 0, ii = path1.length; i < ii; i++) {
      var pi2 = path1[i];
      if (pi2[0] === "M") {
        x1 = x1m = pi2[1];
        y1 = y1m = pi2[2];
      } else {
        if (pi2[0] === "C") {
          bez1 = [x1, y1].concat(pi2.slice(1));
          x1 = bez1[6];
          y1 = bez1[7];
        } else {
          bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
          x1 = x1m;
          y1 = y1m;
        }
        for (var j = 0, jj = path2.length; j < jj; j++) {
          var pj = path2[j];
          if (pj[0] === "M") {
            x2 = x2m = pj[1];
            y2 = y2m = pj[2];
          } else {
            if (pj[0] === "C") {
              bez2 = [x2, y2].concat(pj.slice(1));
              x2 = bez2[6];
              y2 = bez2[7];
            } else {
              bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
              x2 = x2m;
              y2 = y2m;
            }
            var intr = interHelper(bez1, bez2, justCount);
            if (justCount) {
              res += intr;
            } else {
              for (var k = 0, kk = intr.length; k < kk; k++) {
                intr[k].segment1 = i;
                intr[k].segment2 = j;
                intr[k].bez1 = bez1;
                intr[k].bez2 = bez2;
              }
              res = res.concat(intr);
            }
          }
        }
      }
    }
    return res;
  };
  var intersection = function(path1, path2) {
    return interPathHelper(path1, path2);
  };
  function decasteljau(points, t) {
    var left = [];
    var right = [];
    function recurse(points2, t2) {
      if (points2.length === 1) {
        left.push(points2[0]);
        right.push(points2[0]);
      } else {
        var middlePoints = [];
        for (var i = 0; i < points2.length - 1; i++) {
          if (i === 0) {
            left.push(points2[0]);
          }
          if (i === points2.length - 2) {
            right.push(points2[i + 1]);
          }
          middlePoints[i] = [
            (1 - t2) * points2[i][0] + t2 * points2[i + 1][0],
            (1 - t2) * points2[i][1] + t2 * points2[i + 1][1]
          ];
        }
        recurse(middlePoints, t2);
      }
    }
    if (points.length) {
      recurse(points, t);
    }
    return { left, right: right.reverse() };
  }
  function splitCurve(start, end, count2) {
    var points = [[start[1], start[2]]];
    count2 = count2 || 2;
    var segments = [];
    if (end[0] === "A") {
      points.push(end[6]);
      points.push(end[7]);
    } else if (end[0] === "C") {
      points.push([end[1], end[2]]);
      points.push([end[3], end[4]]);
      points.push([end[5], end[6]]);
    } else if (end[0] === "S" || end[0] === "Q") {
      points.push([end[1], end[2]]);
      points.push([end[3], end[4]]);
    } else {
      points.push([end[1], end[2]]);
    }
    var leftSegments = points;
    var t = 1 / count2;
    for (var i = 0; i < count2 - 1; i++) {
      var rt = t / (1 - t * i);
      var split4 = decasteljau(leftSegments, rt);
      segments.push(split4.left);
      leftSegments = split4.right;
    }
    segments.push(leftSegments);
    var result = segments.map(function(segment) {
      var cmd = [];
      if (segment.length === 4) {
        cmd.push("C");
        cmd = cmd.concat(segment[2]);
      }
      if (segment.length >= 3) {
        if (segment.length === 3) {
          cmd.push("Q");
        }
        cmd = cmd.concat(segment[1]);
      }
      if (segment.length === 2) {
        cmd.push("L");
      }
      cmd = cmd.concat(segment[segment.length - 1]);
      return cmd;
    });
    return result;
  }
  var splitSegment = function(start, end, count2) {
    if (count2 === 1) {
      return [[].concat(start)];
    }
    var segments = [];
    if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
      segments = segments.concat(splitCurve(start, end, count2));
    } else {
      var temp = [].concat(start);
      if (temp[0] === "M") {
        temp[0] = "L";
      }
      for (var i = 0; i <= count2 - 1; i++) {
        segments.push(temp);
      }
    }
    return segments;
  };
  var fillPath = function(source, target) {
    if (source.length === 1) {
      return source;
    }
    var sourceLen = source.length - 1;
    var targetLen = target.length - 1;
    var ratio = sourceLen / targetLen;
    var segmentsToFill = [];
    if (source.length === 1 && source[0][0] === "M") {
      for (var i = 0; i < targetLen - sourceLen; i++) {
        source.push(source[0]);
      }
      return source;
    }
    for (var i = 0; i < targetLen; i++) {
      var index = Math.floor(ratio * i);
      segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
    }
    var filled = segmentsToFill.reduce(function(filled2, count2, i2) {
      if (i2 === sourceLen) {
        return filled2.concat(source[sourceLen]);
      }
      return filled2.concat(splitSegment(source[i2], source[i2 + 1], count2));
    }, []);
    filled.unshift(source[0]);
    if (target[targetLen] === "Z" || target[targetLen] === "z") {
      filled.push("Z");
    }
    return filled;
  };
  var isEqual2 = function(obj1, obj2) {
    if (obj1.length !== obj2.length) {
      return false;
    }
    var result = true;
    each_default(obj1, function(item, i) {
      if (item !== obj2[i]) {
        result = false;
        return false;
      }
    });
    return result;
  };
  function getMinDiff(del, add8, modify) {
    var type = null;
    var min7 = modify;
    if (add8 < min7) {
      min7 = add8;
      type = "add";
    }
    if (del < min7) {
      min7 = del;
      type = "del";
    }
    return {
      type,
      min: min7
    };
  }
  var levenshteinDistance = function(source, target) {
    var sourceLen = source.length;
    var targetLen = target.length;
    var sourceSegment;
    var targetSegment;
    var temp = 0;
    if (sourceLen === 0 || targetLen === 0) {
      return null;
    }
    var dist3 = [];
    for (var i = 0; i <= sourceLen; i++) {
      dist3[i] = [];
      dist3[i][0] = { min: i };
    }
    for (var j = 0; j <= targetLen; j++) {
      dist3[0][j] = { min: j };
    }
    for (var i = 1; i <= sourceLen; i++) {
      sourceSegment = source[i - 1];
      for (var j = 1; j <= targetLen; j++) {
        targetSegment = target[j - 1];
        if (isEqual2(sourceSegment, targetSegment)) {
          temp = 0;
        } else {
          temp = 1;
        }
        var del = dist3[i - 1][j].min + 1;
        var add8 = dist3[i][j - 1].min + 1;
        var modify = dist3[i - 1][j - 1].min + temp;
        dist3[i][j] = getMinDiff(del, add8, modify);
      }
    }
    return dist3;
  };
  var fillPathByDiff = function(source, target) {
    var diffMatrix = levenshteinDistance(source, target);
    var sourceLen = source.length;
    var targetLen = target.length;
    var changes = [];
    var index = 1;
    var minPos = 1;
    if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
      for (var i = 1; i <= sourceLen; i++) {
        var min7 = diffMatrix[i][i].min;
        minPos = i;
        for (var j = index; j <= targetLen; j++) {
          if (diffMatrix[i][j].min < min7) {
            min7 = diffMatrix[i][j].min;
            minPos = j;
          }
        }
        index = minPos;
        if (diffMatrix[i][index].type) {
          changes.push({ index: i - 1, type: diffMatrix[i][index].type });
        }
      }
      for (var i = changes.length - 1; i >= 0; i--) {
        index = changes[i].index;
        if (changes[i].type === "add") {
          source.splice(index, 0, [].concat(source[index]));
        } else {
          source.splice(index, 1);
        }
      }
    }
    sourceLen = source.length;
    var diff2 = targetLen - sourceLen;
    if (sourceLen < targetLen) {
      for (var i = 0; i < diff2; i++) {
        if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
          source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
        } else {
          source.push(source[sourceLen - 1]);
        }
        sourceLen += 1;
      }
    }
    return source;
  };
  function _splitPoints(points, former, count2) {
    var result = [].concat(points);
    var index;
    var t = 1 / (count2 + 1);
    var formerEnd = _getSegmentPoints(former)[0];
    for (var i = 1; i <= count2; i++) {
      t *= i;
      index = Math.floor(points.length * t);
      if (index === 0) {
        result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
      } else {
        result.splice(index, 0, [
          formerEnd[0] * t + points[index][0] * (1 - t),
          formerEnd[1] * t + points[index][1] * (1 - t)
        ]);
      }
    }
    return result;
  }
  function _getSegmentPoints(segment) {
    var points = [];
    switch (segment[0]) {
      case "M":
        points.push([segment[1], segment[2]]);
        break;
      case "L":
        points.push([segment[1], segment[2]]);
        break;
      case "A":
        points.push([segment[6], segment[7]]);
        break;
      case "Q":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "T":
        points.push([segment[1], segment[2]]);
        break;
      case "C":
        points.push([segment[5], segment[6]]);
        points.push([segment[1], segment[2]]);
        points.push([segment[3], segment[4]]);
        break;
      case "S":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "H":
        points.push([segment[1], segment[1]]);
        break;
      case "V":
        points.push([segment[1], segment[1]]);
        break;
      default:
    }
    return points;
  }
  var formatPath = function(fromPath, toPath) {
    if (fromPath.length <= 1) {
      return fromPath;
    }
    var points;
    for (var i = 0; i < toPath.length; i++) {
      if (fromPath[i][0] !== toPath[i][0]) {
        points = _getSegmentPoints(fromPath[i]);
        switch (toPath[i][0]) {
          case "M":
            fromPath[i] = ["M"].concat(points[0]);
            break;
          case "L":
            fromPath[i] = ["L"].concat(points[0]);
            break;
          case "A":
            fromPath[i] = [].concat(toPath[i]);
            fromPath[i][6] = points[0][0];
            fromPath[i][7] = points[0][1];
            break;
          case "Q":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "T":
            fromPath[i] = ["T"].concat(points[0]);
            break;
          case "C":
            if (points.length < 3) {
              if (i > 0) {
                points = _splitPoints(points, fromPath[i - 1], 2);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "S":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          default:
            fromPath[i] = toPath[i];
        }
      }
    }
    return fromPath;
  };

  // node_modules/@antv/g-base/esm/event/graph-event.js
  var GraphEvent = function() {
    function GraphEvent3(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent3.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent3.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent3.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent3.prototype.save = function() {
    };
    GraphEvent3.prototype.restore = function() {
    };
    return GraphEvent3;
  }();
  var graph_event_default = GraphEvent;

  // node_modules/@antv/g-base/node_modules/tslib/modules/index.js
  var import_tslib5 = __toModule(require_tslib3());
  var {
    __extends: __extends3,
    __assign: __assign3,
    __rest: __rest3,
    __decorate: __decorate3,
    __param: __param3,
    __metadata: __metadata3,
    __awaiter: __awaiter3,
    __generator: __generator3,
    __exportStar: __exportStar3,
    __createBinding: __createBinding3,
    __values: __values3,
    __read: __read3,
    __spread: __spread3,
    __spreadArrays: __spreadArrays3,
    __spreadArray: __spreadArray3,
    __await: __await3,
    __asyncGenerator: __asyncGenerator3,
    __asyncDelegator: __asyncDelegator3,
    __asyncValues: __asyncValues3,
    __makeTemplateObject: __makeTemplateObject3,
    __importStar: __importStar3,
    __importDefault: __importDefault3,
    __classPrivateFieldGet: __classPrivateFieldGet3,
    __classPrivateFieldSet: __classPrivateFieldSet3
  } = import_tslib5.default;

  // node_modules/@antv/g-base/esm/util/util.js
  function removeFromArray(arr, obj) {
    var index = arr.indexOf(obj);
    if (index !== -1) {
      arr.splice(index, 1);
    }
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isParent(container, shape) {
    if (container.isCanvas()) {
      return true;
    }
    var parent = shape.getParent();
    var isParent3 = false;
    while (parent) {
      if (parent === container) {
        isParent3 = true;
        break;
      }
      parent = parent.getParent();
    }
    return isParent3;
  }
  function isAllowCapture(element) {
    return element.cfg.visible && element.cfg.capture;
  }

  // node_modules/@antv/g-base/esm/abstract/base.js
  var Base2 = function(_super) {
    __extends3(Base4, _super);
    function Base4(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base4.prototype.getDefaultCfg = function() {
      return {};
    };
    Base4.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base4.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base4.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base4;
  }(esm_default);
  var base_default2 = Base2;

  // node_modules/detect-browser/es/index.js
  var __spreadArray4 = function(to, from, pack3) {
    if (pack3 || arguments.length === 2)
      for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var BrowserInfo = function() {
    function BrowserInfo2(name, version11, os) {
      this.name = name;
      this.version = version11;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }();
  var NodeInfo = function() {
    function NodeInfo2(version11) {
      this.version = version11;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }();
  var SearchBotDeviceInfo = function() {
    function SearchBotDeviceInfo2(name, version11, os, bot) {
      this.name = name;
      this.version = version11;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }();
  var BotInfo = function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }();
  var ReactNativeInfo = function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }();
  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [
    ["aol", /AOLShield\/([0-9\._]+)/],
    ["edge", /Edge\/([0-9\._]+)/],
    ["edge-ios", /EdgiOS\/([0-9\._]+)/],
    ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
    ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
    ["samsung", /SamsungBrowser\/([0-9\.]+)/],
    ["silk", /\bSilk\/([0-9._-]+)\b/],
    ["miui", /MiuiBrowser\/([0-9\.]+)$/],
    ["beaker", /BeakerBrowser\/([0-9\.]+)/],
    ["edge-chromium", /EdgA?\/([0-9\.]+)/],
    [
      "chromium-webview",
      /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
    ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
    ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
    ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
    ["fxios", /FxiOS\/([0-9\.]+)/],
    ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
    ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
    ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
    ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
    ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
    ["ie", /MSIE\s(7\.0)/],
    ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
    ["android", /Android\s([0-9\.]+)/],
    ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
    ["safari", /Version\/([0-9\._]+).*Safari/],
    ["facebook", /FB[AS]V\/([0-9\.]+)/],
    ["instagram", /Instagram\s([0-9\.]+)/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
    ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
    ["curl", /^curl\/([0-9\.]+)$/],
    ["searchbot", SEARCHBOX_UA_REGEX]
  ];
  var operatingSystemRules = [
    ["iOS", /iP(hone|od|ad)/],
    ["Android OS", /Android/],
    ["BlackBerry OS", /BlackBerry|BB10/],
    ["Windows Mobile", /IEMobile/],
    ["Amazon OS", /Kindle/],
    ["Windows 3.11", /Win16/],
    ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
    ["Windows 98", /(Windows 98)|(Win98)/],
    ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
    ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
    ["Windows Server 2003", /(Windows NT 5.2)/],
    ["Windows Vista", /(Windows NT 6.0)/],
    ["Windows 7", /(Windows NT 6.1)/],
    ["Windows 8", /(Windows NT 6.2)/],
    ["Windows 8.1", /(Windows NT 6.3)/],
    ["Windows 10", /(Windows NT 10.0)/],
    ["Windows ME", /Windows ME/],
    ["Open BSD", /OpenBSD/],
    ["Sun OS", /SunOS/],
    ["Chrome OS", /CrOS/],
    ["Linux", /(Linux)|(X11)/],
    ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
    ["QNX", /QNX/],
    ["BeOS", /BeOS/],
    ["OS/2", /OS\/2/]
  ];
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua) {
    return ua !== "" && userAgentRules.reduce(function(matched, _a4) {
      var browser3 = _a4[0], regex = _a4[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser3, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
      return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArray4(__spreadArray4([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
      }
    } else {
      versionParts = [];
    }
    var version11 = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name, version11, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version11, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
      var _a4 = operatingSystemRules[ii], os = _a4[0], regex = _a4[1];
      var match = regex.exec(ua);
      if (match) {
        return os;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode = typeof process !== "undefined" && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count2) {
    var output = [];
    for (var ii = 0; ii < count2; ii++) {
      output.push("0");
    }
    return output;
  }

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };

  // node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add2,
    adjoint: () => adjoint,
    clone: () => clone2,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity2,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set2,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  function clone2(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2];
    var a10 = a[3], a11 = a[4], a12 = a[5];
    var a20 = a[6], a21 = a[7], a22 = a[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  function rotate(out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a, v) {
    var x = v[0], y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a, b, scale5) {
    out[0] = a[0] + b[0] * scale5;
    out[1] = a[1] + b[1] * scale5;
    out[2] = a[2] + b[2] * scale5;
    out[3] = a[3] + b[3] * scale5;
    out[4] = a[4] + b[4] * scale5;
    out[5] = a[5] + b[5] * scale5;
    out[6] = a[6] + b[6] * scale5;
    out[7] = a[7] + b[7] * scale5;
    out[8] = a[8] + b[8] * scale5;
    return out;
  }
  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  function equals(a, b) {
    var a0 = a[0], a12 = a[1], a22 = a[2], a32 = a[3], a42 = a[4], a52 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b02 = b[0], b12 = b[1], b22 = b[2], b32 = b[3], b42 = b[4], b52 = b[5], b62 = b[6], b72 = b[7], b82 = b[8];
    return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a32 - b32) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b32)) && Math.abs(a42 - b42) <= EPSILON * Math.max(1, Math.abs(a42), Math.abs(b42)) && Math.abs(a52 - b52) <= EPSILON * Math.max(1, Math.abs(a52), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
  }
  var mul = multiply;
  var sub = subtract;

  // node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add3,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone3,
    copy: () => copy2,
    create: () => create2,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals2,
    exactEquals: () => exactEquals2,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues2,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul2,
    multiply: () => multiply2,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    round: () => round,
    scale: () => scale2,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set3,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone3(a) {
    var out = new ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  function fromValues2(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function copy2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  function set3(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply2(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  function ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  function floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  function min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  function max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  function round(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
  }
  function scale2(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  function scaleAndAdd(out, a, b, scale5) {
    out[0] = a[0] + b[0] * scale5;
    out[1] = a[1] + b[1] * scale5;
    out[2] = a[2] + b[2] * scale5;
    return out;
  }
  function distance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return Math.hypot(x, y, z);
  }
  function squaredDistance(a, b) {
    var x = b[0] - a[0];
    var y = b[1] - a[1];
    var z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  function squaredLength(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return x * x + y * y + z * z;
  }
  function negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len3 = x * x + y * y + z * z;
    if (len3 > 0) {
      len3 = 1 / Math.sqrt(len3);
    }
    out[0] = a[0] * len3;
    out[1] = a[1] * len3;
    out[2] = a[2] * len3;
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a, b, t) {
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a, b, c, d, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function bezier(out, a, b, c, d, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  function random(out, scale5) {
    scale5 = scale5 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale5;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale5;
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a, b, rad) {
    var p3 = [], r = [];
    p3[0] = a[0] - b[0];
    p3[1] = a[1] - b[1];
    p3[2] = a[2] - b[2];
    r[0] = p3[0];
    r[1] = p3[1] * Math.cos(rad) - p3[2] * Math.sin(rad);
    r[2] = p3[1] * Math.sin(rad) + p3[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY(out, a, b, rad) {
    var p3 = [], r = [];
    p3[0] = a[0] - b[0];
    p3[1] = a[1] - b[1];
    p3[2] = a[2] - b[2];
    r[0] = p3[2] * Math.sin(rad) + p3[0] * Math.cos(rad);
    r[1] = p3[1];
    r[2] = p3[2] * Math.cos(rad) - p3[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ(out, a, b, rad) {
    var p3 = [], r = [];
    p3[0] = a[0] - b[0];
    p3[1] = a[1] - b[1];
    p3[2] = a[2] - b[2];
    r[0] = p3[0] * Math.cos(rad) - p3[1] * Math.sin(rad);
    r[1] = p3[0] * Math.sin(rad) + p3[1] * Math.cos(rad);
    r[2] = p3[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine2 = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine2, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str2(a) {
    return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
  }
  function exactEquals2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  function equals2(a, b) {
    var a0 = a[0], a12 = a[1], a22 = a[2];
    var b02 = b[0], b12 = b[1], b22 = b[2];
    return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
  }
  var sub2 = subtract2;
  var mul2 = multiply2;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var len = length;
  var sqrLen = squaredLength;
  var forEach = function() {
    var vec = create2();
    return function(a, stride, offset, count2, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // node_modules/gl-matrix/esm/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add4,
    angle: () => angle2,
    ceil: () => ceil2,
    clone: () => clone4,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals3,
    exactEquals: () => exactEquals3,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues3,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max2,
    min: () => min2,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    rotate: () => rotate2,
    round: () => round2,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set4,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat42,
    zero: () => zero2
  });
  function create3() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone4(a) {
    var out = new ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  function fromValues3(x, y) {
    var out = new ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
  }
  function copy3(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
  }
  function set4(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
  }
  function add4(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  function subtract3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  function multiply3(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
  }
  function divide2(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
  }
  function ceil2(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
  }
  function floor2(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
  }
  function min2(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
  }
  function max2(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
  }
  function round2(out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  function scaleAndAdd2(out, a, b, scale5) {
    out[0] = a[0] + b[0] * scale5;
    out[1] = a[1] + b[1] * scale5;
    return out;
  }
  function distance2(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return Math.hypot(x, y);
  }
  function squaredDistance2(a, b) {
    var x = b[0] - a[0], y = b[1] - a[1];
    return x * x + y * y;
  }
  function length2(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
  }
  function squaredLength2(a) {
    var x = a[0], y = a[1];
    return x * x + y * y;
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  function inverse2(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    return out;
  }
  function normalize2(out, a) {
    var x = a[0], y = a[1];
    var len3 = x * x + y * y;
    if (len3 > 0) {
      len3 = 1 / Math.sqrt(len3);
    }
    out[0] = a[0] * len3;
    out[1] = a[1] * len3;
    return out;
  }
  function dot2(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function cross2(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function random2(out, scale5) {
    scale5 = scale5 || 1;
    var r = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale5;
    out[1] = Math.sin(r) * scale5;
    return out;
  }
  function transformMat2(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  function transformMat2d(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  function transformMat32(out, a, m) {
    var x = a[0], y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  function rotate2(out, a, b, rad) {
    var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  function angle2(a, b) {
    var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine2 = mag && (x1 * x2 + y1 * y2) / mag;
    return Math.acos(Math.min(Math.max(cosine2, -1), 1));
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str3(a) {
    return "vec2(" + a[0] + ", " + a[1] + ")";
  }
  function exactEquals3(a, b) {
    return a[0] === b[0] && a[1] === b[1];
  }
  function equals3(a, b) {
    var a0 = a[0], a12 = a[1];
    var b02 = b[0], b12 = b[1];
    return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12));
  }
  var len2 = length2;
  var sub3 = subtract3;
  var mul3 = multiply3;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var sqrLen2 = squaredLength2;
  var forEach2 = function() {
    var vec = create3();
    return function(a, stride, offset, count2, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // node_modules/@antv/matrix-util/esm/ext.js
  var ext_exports = {};
  __export(ext_exports, {
    angleTo: () => angleTo,
    direction: () => direction,
    leftRotate: () => leftRotate,
    leftScale: () => leftScale,
    leftTranslate: () => leftTranslate,
    transform: () => transform,
    vertical: () => vertical
  });
  function leftTranslate(out, a, v) {
    var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    mat3_exports.fromTranslation(transMat, v);
    return mat3_exports.multiply(out, transMat, a);
  }
  function leftRotate(out, a, rad) {
    var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    mat3_exports.fromRotation(rotateMat, rad);
    return mat3_exports.multiply(out, rotateMat, a);
  }
  function leftScale(out, a, v) {
    var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    mat3_exports.fromScaling(scaleMat, v);
    return mat3_exports.multiply(out, scaleMat, a);
  }
  function leftMultiply(out, a, a12) {
    return mat3_exports.multiply(out, a12, a);
  }
  function transform(m, actions) {
    var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
    for (var i = 0, len3 = actions.length; i < len3; i++) {
      var action = actions[i];
      switch (action[0]) {
        case "t":
          leftTranslate(matrix, matrix, [action[1], action[2]]);
          break;
        case "s":
          leftScale(matrix, matrix, [action[1], action[2]]);
          break;
        case "r":
          leftRotate(matrix, matrix, action[1]);
          break;
        case "m":
          leftMultiply(matrix, matrix, action[1]);
          break;
        default:
          break;
      }
    }
    return matrix;
  }
  function direction(v1, v2) {
    return v1[0] * v2[1] - v2[0] * v1[1];
  }
  function angleTo(v1, v2, direct) {
    var ang = vec2_exports.angle(v1, v2);
    var angleLargeThanPI = direction(v1, v2) >= 0;
    if (direct) {
      if (angleLargeThanPI) {
        return Math.PI * 2 - ang;
      }
      return ang;
    }
    if (angleLargeThanPI) {
      return ang;
    }
    return Math.PI * 2 - ang;
  }
  function vertical(out, v, flag) {
    if (flag) {
      out[0] = v[1];
      out[1] = -1 * v[0];
    } else {
      out[0] = -1 * v[1];
      out[1] = v[0];
    }
    return out;
  }

  // node_modules/@antv/g-base/esm/util/matrix.js
  function multiplyMatrix(a, b) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b00 = b[0];
    var b01 = b[1];
    var b02 = b[2];
    var b10 = b[3];
    var b11 = b[4];
    var b12 = b[5];
    var b20 = b[6];
    var b21 = b[7];
    var b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function multiplyVec2(m, v) {
    var out = [];
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function invert2(a) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }

  // node_modules/@antv/g-base/esm/abstract/element.js
  var transform2 = ext_exports.transform;
  var MATRIX = "matrix";
  var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
  var RESERVED_PORPS = ["repeat"];
  var DELEGATION_SPLIT = ":";
  var WILDCARD2 = "*";
  function _cloneArrayAttr(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
      if (is_array_default(arr[i])) {
        result.push([].concat(arr[i]));
      } else {
        result.push(arr[i]);
      }
    }
    return result;
  }
  function getFormatFromAttrs(toAttrs, shape) {
    var fromAttrs = {};
    var attrs = shape.attrs;
    for (var k in toAttrs) {
      fromAttrs[k] = attrs[k];
    }
    return fromAttrs;
  }
  function getFormatToAttrs(props, shape) {
    var toAttrs = {};
    var attrs = shape.attr();
    each_default(props, function(v, k) {
      if (RESERVED_PORPS.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
        toAttrs[k] = v;
      }
    });
    return toAttrs;
  }
  function checkExistedAttrs(animations, animation) {
    if (animation.onFrame) {
      return animations;
    }
    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
    var hasOwnProperty5 = Object.prototype.hasOwnProperty;
    each_default(animations, function(item) {
      if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
        each_default(animation.toAttrs, function(v, k) {
          if (hasOwnProperty5.call(item.toAttrs, k)) {
            delete item.toAttrs[k];
            delete item.fromAttrs[k];
          }
        });
      }
    });
    return animations;
  }
  var Element2 = function(_super) {
    __extends3(Element5, _super);
    function Element5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element5.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element5.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element5.prototype.onCanvasChange = function(changeType) {
    };
    Element5.prototype.initAttrs = function(attrs) {
    };
    Element5.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element5.prototype.isGroup = function() {
      return false;
    };
    Element5.prototype.getParent = function() {
      return this.get("parent");
    };
    Element5.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element5.prototype.attr = function() {
      var _a4;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a4 = {}, _a4[name] = value, _a4));
        return this;
      }
      return this.attrs[name];
    };
    Element5.prototype.isClipped = function(refX, refY) {
      var clip2 = this.getClip();
      return clip2 && !clip2.isHit(refX, refY);
    };
    Element5.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element5.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element5.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element5.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element5.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element5.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element5.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element5.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element5.prototype.setMatrix = function(m) {
      this.attr(MATRIX, m);
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element5.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element5.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element5.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2(matrix, v);
      }
      return v;
    };
    Element5.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert2(matrix);
        if (invertMatrix) {
          return multiplyVec2(invertMatrix, v);
        }
      }
      return v;
    };
    Element5.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase4 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase4[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element5.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element5.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone6 = new cons({ attrs });
      each_default(CLONE_CFGS, function(cfgName) {
        clone6.set(cfgName, _this.get(cfgName));
      });
      return clone6;
    };
    Element5.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element5.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element5.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a4 = args[2], easing = _a4 === void 0 ? "easeLinear" : _a4, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat2;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat2 = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat2 = animateCfg.repeat || repeat2 || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat: repeat2,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element5.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element5.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element5.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element5.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element5.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD2]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element5.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element5.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element5.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtStart = function(rotate5) {
      var _a4 = this.attr(), x = _a4.x, y = _a4.y;
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtPoint = function(x, y, rotate5) {
      var matrix = this.getMatrix();
      var newMatrix = transform2(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element5;
  }(base_default2);
  var element_default = Element2;

  // node_modules/@antv/g-base/esm/abstract/container.js
  var SHAPE_MAP = {};
  var INDEX = "_INDEX";
  function setCanvas(element, canvas) {
    element.set("canvas", canvas);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setCanvas(child, canvas);
        });
      }
    }
  }
  function setTimeline(element, timeline) {
    element.set("timeline", timeline);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setTimeline(child, timeline);
        });
      }
    }
  }
  function removeChild(container, element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (destroy) {
      element.destroy();
    } else {
      element.set("parent", null);
      element.set("canvas", null);
    }
    removeFromArray(container.getChildren(), element);
  }
  function getComparer(compare) {
    return function(left, right) {
      var result = compare(left, right);
      return result === 0 ? left[INDEX] - right[INDEX] : result;
    };
  }
  var Container = function(_super) {
    __extends3(Container4, _super);
    function Container4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container4.prototype.isCanvas = function() {
      return false;
    };
    Container4.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container4.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getCanvasBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container4.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container4.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container4.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP[cfg.type] = shapeType;
      }
      var ShapeBase4 = this.getShapeBase();
      var shape = new ShapeBase4[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container4.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group2;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group2 = new groupClass(cfg);
        } else {
          group2 = new groupClass({
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group2 = new TmpGroupClass(tmpCfg);
      }
      this.add(group2);
      return group2;
    };
    Container4.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container4.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container4.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container4.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container4.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container4.prototype.getChildren = function() {
      return this.get("children");
    };
    Container4.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index) {
        child[INDEX] = index;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container4.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container4.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container4.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container4.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container4.prototype.getChildByIndex = function(index) {
      var children = this.getChildren();
      return children[index];
    };
    Container4.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container4.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container4.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container4.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container4.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container4.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container4.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container4.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container4;
  }(element_default);
  var container_default = Container;

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0)
        t._call.call(null, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now3 = clock.now(), delay = now3 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now3;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-ease/src/index.js
  var src_exports = {};
  __export(src_exports, {
    easeBack: () => backInOut,
    easeBackIn: () => backIn,
    easeBackInOut: () => backInOut,
    easeBackOut: () => backOut,
    easeBounce: () => bounceOut,
    easeBounceIn: () => bounceIn,
    easeBounceInOut: () => bounceInOut,
    easeBounceOut: () => bounceOut,
    easeCircle: () => circleInOut,
    easeCircleIn: () => circleIn,
    easeCircleInOut: () => circleInOut,
    easeCircleOut: () => circleOut,
    easeCubic: () => cubicInOut,
    easeCubicIn: () => cubicIn,
    easeCubicInOut: () => cubicInOut,
    easeCubicOut: () => cubicOut,
    easeElastic: () => elasticOut,
    easeElasticIn: () => elasticIn,
    easeElasticInOut: () => elasticInOut,
    easeElasticOut: () => elasticOut,
    easeExp: () => expInOut,
    easeExpIn: () => expIn,
    easeExpInOut: () => expInOut,
    easeExpOut: () => expOut,
    easeLinear: () => linear,
    easePoly: () => polyInOut,
    easePolyIn: () => polyIn,
    easePolyInOut: () => polyInOut,
    easePolyOut: () => polyOut,
    easeQuad: () => quadInOut,
    easeQuadIn: () => quadIn,
    easeQuadInOut: () => quadInOut,
    easeQuadOut: () => quadOut,
    easeSin: () => sinInOut,
    easeSinIn: () => sinIn,
    easeSinInOut: () => sinInOut,
    easeSinOut: () => sinOut
  });

  // node_modules/d3-ease/src/linear.js
  function linear(t) {
    return +t;
  }

  // node_modules/d3-ease/src/quad.js
  function quadIn(t) {
    return t * t;
  }
  function quadOut(t) {
    return t * (2 - t);
  }
  function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }

  // node_modules/d3-ease/src/cubic.js
  function cubicIn(t) {
    return t * t * t;
  }
  function cubicOut(t) {
    return --t * t * t + 1;
  }
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  // node_modules/d3-ease/src/poly.js
  var exponent = 3;
  var polyIn = function custom(e) {
    e = +e;
    function polyIn2(t) {
      return Math.pow(t, e);
    }
    polyIn2.exponent = custom;
    return polyIn2;
  }(exponent);
  var polyOut = function custom2(e) {
    e = +e;
    function polyOut2(t) {
      return 1 - Math.pow(1 - t, e);
    }
    polyOut2.exponent = custom2;
    return polyOut2;
  }(exponent);
  var polyInOut = function custom3(e) {
    e = +e;
    function polyInOut2(t) {
      return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }
    polyInOut2.exponent = custom3;
    return polyInOut2;
  }(exponent);

  // node_modules/d3-ease/src/sin.js
  var pi = Math.PI;
  var halfPi = pi / 2;
  function sinIn(t) {
    return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
  }
  function sinOut(t) {
    return Math.sin(t * halfPi);
  }
  function sinInOut(t) {
    return (1 - Math.cos(pi * t)) / 2;
  }

  // node_modules/d3-ease/src/math.js
  function tpmt(x) {
    return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
  }

  // node_modules/d3-ease/src/exp.js
  function expIn(t) {
    return tpmt(1 - +t);
  }
  function expOut(t) {
    return 1 - tpmt(t);
  }
  function expInOut(t) {
    return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
  }

  // node_modules/d3-ease/src/circle.js
  function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function circleOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }

  // node_modules/d3-ease/src/bounce.js
  var b1 = 4 / 11;
  var b2 = 6 / 11;
  var b3 = 8 / 11;
  var b4 = 3 / 4;
  var b5 = 9 / 11;
  var b6 = 10 / 11;
  var b7 = 15 / 16;
  var b8 = 21 / 22;
  var b9 = 63 / 64;
  var b0 = 1 / b1 / b1;
  function bounceIn(t) {
    return 1 - bounceOut(1 - t);
  }
  function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
  }
  function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
  }

  // node_modules/d3-ease/src/back.js
  var overshoot = 1.70158;
  var backIn = function custom4(s) {
    s = +s;
    function backIn2(t) {
      return (t = +t) * t * (s * (t - 1) + t);
    }
    backIn2.overshoot = custom4;
    return backIn2;
  }(overshoot);
  var backOut = function custom5(s) {
    s = +s;
    function backOut2(t) {
      return --t * t * ((t + 1) * s + t) + 1;
    }
    backOut2.overshoot = custom5;
    return backOut2;
  }(overshoot);
  var backInOut = function custom6(s) {
    s = +s;
    function backInOut2(t) {
      return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
    }
    backInOut2.overshoot = custom6;
    return backInOut2;
  }(overshoot);

  // node_modules/d3-ease/src/elastic.js
  var tau = 2 * Math.PI;
  var amplitude = 1;
  var period = 0.3;
  var elasticIn = function custom7(a, p3) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p3 /= tau);
    function elasticIn2(t) {
      return a * tpmt(- --t) * Math.sin((s - t) / p3);
    }
    elasticIn2.amplitude = function(a6) {
      return custom7(a6, p3 * tau);
    };
    elasticIn2.period = function(p4) {
      return custom7(a, p4);
    };
    return elasticIn2;
  }(amplitude, period);
  var elasticOut = function custom8(a, p3) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p3 /= tau);
    function elasticOut2(t) {
      return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p3);
    }
    elasticOut2.amplitude = function(a6) {
      return custom8(a6, p3 * tau);
    };
    elasticOut2.period = function(p4) {
      return custom8(a, p4);
    };
    return elasticOut2;
  }(amplitude, period);
  var elasticInOut = function custom9(a, p3) {
    var s = Math.asin(1 / (a = Math.max(1, a))) * (p3 /= tau);
    function elasticInOut2(t) {
      return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p3) : 2 - a * tpmt(t) * Math.sin((s + t) / p3)) / 2;
    }
    elasticInOut2.amplitude = function(a6) {
      return custom9(a6, p3 * tau);
    };
    elasticInOut2.period = function(p4) {
      return custom9(a, p4);
    };
    return elasticInOut2;
  }(amplitude, period);

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend2(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
  var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
  var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
  var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
  var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
  var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy: function(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable: function() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend2(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb: function() {
      return this;
    },
    displayable: function() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  }
  function rgb_formatRgb() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
  function hex(value) {
    value = Math.max(0, Math.min(255, Math.round(value) || 0));
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h2, s, l, a) {
    if (a <= 0)
      h2 = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h2 = s = NaN;
    else if (s <= 0)
      h2 = NaN;
    return new Hsl(h2, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min7 = Math.min(r, g, b), max7 = Math.max(r, g, b), h2 = NaN, s = max7 - min7, l = (max7 + min7) / 2;
    if (s) {
      if (r === max7)
        h2 = (g - b) / s + (g < b) * 6;
      else if (g === max7)
        h2 = (b - r) / s + 2;
      else
        h2 = (r - g) / s + 4;
      s /= l < 0.5 ? max7 + min7 : 2 - max7 - min7;
      h2 *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h2;
    }
    return new Hsl(h2, s, l, o.opacity);
  }
  function hsl(h2, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h2, s, l, opacity) {
    this.h = +h2;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend2(Color, {
    brighter: function(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker: function(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb: function() {
      var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
    },
    displayable: function() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl: function() {
      var a = this.opacity;
      a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
    }
  }));
  function hsl2rgb(h2, m1, m2) {
    return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values2) {
    var n = values2.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values2) {
    var n = values2.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  function constant_default(x) {
    return function() {
      return x;
    };
  }

  // node_modules/d3-interpolate/src/color.js
  function linear2(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear2(a, d) : constant_default(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y) {
    var color2 = gamma(y);
    function rgb2(start, end) {
      var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i)
        c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function array_default(a, b) {
    return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
  }
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i)
        c[i] = x[i](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = new Date();
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i)
        c[k] = i[k](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero3(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero3(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/@antv/g-base/esm/util/color.js
  var isColorProp = function(prop) {
    return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
  };
  var isGradientColor = function(val) {
    return /^[r,R,L,l]{1}[\s]*\(/.test(val);
  };

  // node_modules/@antv/g-base/esm/animate/timeline.js
  var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  function _update(shape, animation, ratio) {
    var cProps = {};
    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
    if (shape.destroyed) {
      return;
    }
    var interf;
    for (var k in toAttrs) {
      if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
        if (k === "path") {
          var toPath = toAttrs[k];
          var fromPath = fromAttrs[k];
          if (toPath.length > fromPath.length) {
            toPath = parsePathString(toAttrs[k]);
            fromPath = parsePathString(fromAttrs[k]);
            fromPath = fillPathByDiff(fromPath, toPath);
            fromPath = formatPath(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
          } else if (!animation.pathFormatted) {
            toPath = parsePathString(toAttrs[k]);
            fromPath = parsePathString(fromAttrs[k]);
            fromPath = formatPath(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
            animation.pathFormatted = true;
          }
          cProps[k] = [];
          for (var i = 0; i < toPath.length; i++) {
            var toPathPoint = toPath[i];
            var fromPathPoint = fromPath[i];
            var cPathPoint = [];
            for (var j = 0; j < toPathPoint.length; j++) {
              if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
                interf = value_default(fromPathPoint[j], toPathPoint[j]);
                cPathPoint.push(interf(ratio));
              } else {
                cPathPoint.push(toPathPoint[j]);
              }
            }
            cProps[k].push(cPathPoint);
          }
        } else if (k === "matrix") {
          var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
          var currentMatrix = matrixFn(ratio);
          cProps[k] = currentMatrix;
        } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {
          cProps[k] = toAttrs[k];
        } else if (!is_function_default(toAttrs[k])) {
          interf = value_default(fromAttrs[k], toAttrs[k]);
          cProps[k] = interf(ratio);
        }
      }
    }
    shape.attr(cProps);
  }
  function update(shape, animation, elapsed) {
    var startTime = animation.startTime, delay = animation.delay;
    if (elapsed < startTime + delay || animation._paused) {
      return false;
    }
    var ratio;
    var duration = animation.duration;
    var easing = animation.easing;
    elapsed = elapsed - startTime - animation.delay;
    if (animation.repeat) {
      ratio = elapsed % duration / duration;
      ratio = src_exports[easing](ratio);
    } else {
      ratio = elapsed / duration;
      if (ratio < 1) {
        ratio = src_exports[easing](ratio);
      } else {
        if (animation.onFrame) {
          shape.attr(animation.onFrame(1));
        } else {
          shape.attr(animation.toAttrs);
        }
        return true;
      }
    }
    if (animation.onFrame) {
      var attrs = animation.onFrame(ratio);
      shape.attr(attrs);
    } else {
      _update(shape, animation, ratio);
    }
    return false;
  }
  var Timeline = function() {
    function Timeline3(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline3.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation = animations[j];
                isFinished = update(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline3.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline3.prototype.removeAnimator = function(index) {
      this.animators.splice(index, 1);
    };
    Timeline3.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline3.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline3.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline3.prototype.getTime = function() {
      return this.current;
    };
    return Timeline3;
  }();
  var timeline_default = Timeline;

  // node_modules/@antv/g-base/esm/event/event-contoller.js
  var CLICK_OFFSET = 40;
  var LEFT_BTN_CODE = 0;
  var EVENTS = [
    "mousedown",
    "mouseup",
    "dblclick",
    "mouseout",
    "mouseover",
    "mousemove",
    "mouseleave",
    "mouseenter",
    "touchstart",
    "touchmove",
    "touchend",
    "dragenter",
    "dragover",
    "dragleave",
    "drop",
    "contextmenu",
    "mousewheel"
  ];
  function emitTargetEvent(target, type, eventObj) {
    eventObj.name = type;
    eventObj.target = target;
    eventObj.currentTarget = target;
    eventObj.delegateTarget = target;
    target.emit(type, eventObj);
  }
  function bubbleEvent(container, type, eventObj) {
    if (eventObj.bubbles) {
      var relativeShape = void 0;
      var isOverEvent = false;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
        isOverEvent = true;
      } else if (type === "mouseleave") {
        isOverEvent = true;
        relativeShape = eventObj.toShape;
      }
      if (container.isCanvas() && isOverEvent) {
        return;
      }
      if (relativeShape && isParent(container, relativeShape)) {
        eventObj.bubbles = false;
        return;
      }
      eventObj.name = type;
      eventObj.currentTarget = container;
      eventObj.delegateTarget = container;
      container.emit(type, eventObj);
    }
  }
  var EventController = function() {
    function EventController3(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController3.prototype.init = function() {
      this._bindEvents();
    };
    EventController3.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
      var eventObj = new graph_event_default(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point.x;
      eventObj.y = point.y;
      eventObj.clientX = point.clientX;
      eventObj.clientY = point.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController3.prototype._getShape = function(point, ev) {
      return this.canvas.getShape(point.x, point.y, ev);
    };
    EventController3.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point = canvas.getPointByEvent(ev);
      return {
        x: point.x,
        y: point.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController3.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController3.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController3.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController3.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController3.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController3.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController3.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController3.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now3 = event.timeStamp;
          var timeWindow = now3 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist3 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist3 > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController3.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController3.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController3;
  }();
  var event_contoller_default = EventController;

  // node_modules/@antv/g-base/esm/abstract/canvas.js
  var PX_SUFFIX = "px";
  var browser = detect();
  var isFirefox = browser && browser.name === "firefox";
  var Canvas = function(_super) {
    __extends3(Canvas5, _super);
    function Canvas5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas5.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas5.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas5.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas5.prototype.initEvents = function() {
      var eventController = new event_contoller_default({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas5.prototype.initTimeline = function() {
      var timeline = new timeline_default(this);
      this.set("timeline", timeline);
    };
    Canvas5.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas5.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas5.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas5.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas5.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas5.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a4 = this.getClientByEvent(ev), clientX = _a4.x, clientY = _a4.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas5.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas5.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas5.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas5.prototype.draw = function() {
    };
    Canvas5.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas5.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas5.prototype.isCanvas = function() {
      return true;
    };
    Canvas5.prototype.getParent = function() {
      return null;
    };
    Canvas5.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas5;
  }(container_default);
  var canvas_default = Canvas;

  // node_modules/@antv/g-base/esm/abstract/group.js
  var AbstractGroup = function(_super) {
    __extends3(AbstractGroup3, _super);
    function AbstractGroup3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup3.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup3.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup3.prototype.clone = function() {
      var clone6 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone6.add(child.clone());
      }
      return clone6;
    };
    return AbstractGroup3;
  }(container_default);
  var group_default2 = AbstractGroup;

  // node_modules/@antv/g-base/esm/abstract/shape.js
  var AbstractShape = function(_super) {
    __extends3(AbstractShape3, _super);
    function AbstractShape3(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape3.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape3.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape3.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape3.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a4 = attrs.shadowBlur, shadowBlur = _a4 === void 0 ? 0 : _a4, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape3.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape3.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape3.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape3.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape3;
  }(element_default);
  var shape_default = AbstractShape;

  // node_modules/@antv/g-base/esm/bbox/register.js
  var cache = new Map();
  function register(type, method) {
    cache.set(type, method);
  }
  function getMethod(type) {
    return cache.get(type);
  }

  // node_modules/@antv/g-base/esm/bbox/rect.js
  function rect_default(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
    return {
      x,
      y,
      width,
      height
    };
  }

  // node_modules/@antv/g-base/esm/bbox/circle.js
  function circle_default(shape) {
    var _a4 = shape.attr(), x = _a4.x, y = _a4.y, r = _a4.r;
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  }

  // node_modules/@antv/g-math/esm/util.js
  var util_exports = {};
  __export(util_exports, {
    distance: () => distance3,
    getBBoxByArray: () => getBBoxByArray,
    getBBoxRange: () => getBBoxRange,
    isNumberEqual: () => isNumberEqual2,
    piMod: () => piMod
  });
  function minNum(array2) {
    return Math.min.apply(null, array2);
  }
  function maxNum(array2) {
    return Math.max.apply(null, array2);
  }
  function distance3(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function isNumberEqual2(v1, v2) {
    return Math.abs(v1 - v2) < 1e-3;
  }
  function getBBoxByArray(xArr, yArr) {
    var minX = minNum(xArr);
    var minY = minNum(yArr);
    var maxX = maxNum(xArr);
    var maxY = maxNum(yArr);
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getBBoxRange(x1, y1, x2, y2) {
    return {
      minX: minNum([x1, x2]),
      maxX: maxNum([x1, x2]),
      minY: minNum([y1, y2]),
      maxY: maxNum([y1, y2])
    };
  }
  function piMod(angle3) {
    return (angle3 + Math.PI * 2) % (Math.PI * 2);
  }

  // node_modules/@antv/g-math/esm/line.js
  var line_default = {
    box: function(x1, y1, x2, y2) {
      return getBBoxByArray([x1, x2], [y1, y2]);
    },
    length: function(x1, y1, x2, y2) {
      return distance3(x1, y1, x2, y2);
    },
    pointAt: function(x1, y1, x2, y2, t) {
      return {
        x: (1 - t) * x1 + t * x2,
        y: (1 - t) * y1 + t * y2
      };
    },
    pointDistance: function(x1, y1, x2, y2, x, y) {
      var cross3 = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
      if (cross3 < 0) {
        return distance3(x1, y1, x, y);
      }
      var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (cross3 > lengthSquare) {
        return distance3(x2, y2, x, y);
      }
      return this.pointToLine(x1, y1, x2, y2, x, y);
    },
    pointToLine: function(x1, y1, x2, y2, x, y) {
      var d = [x2 - x1, y2 - y1];
      if (exactEquals3(d, [0, 0])) {
        return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      }
      var u = [-d[1], d[0]];
      normalize2(u, u);
      var a = [x - x1, y - y1];
      return Math.abs(dot2(a, u));
    },
    tangentAngle: function(x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1);
    }
  };

  // node_modules/@antv/g-math/esm/bezier.js
  var EPSILON2 = 1e-4;
  function nearestPoint(xArr, yArr, x, y, tCallback, length3) {
    var t;
    var d = Infinity;
    var v0 = [x, y];
    var segNum = 20;
    if (length3 && length3 > 200) {
      segNum = length3 / 10;
    }
    var increaseRate = 1 / segNum;
    var interval2 = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
      var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d) {
        t = _t;
        d = d1;
      }
    }
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count2 = xArr.length;
      return {
        x: xArr[count2 - 1],
        y: yArr[count2 - 1]
      };
    }
    d = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval2 < EPSILON2) {
        break;
      }
      var prev = t - interval2;
      var next = t + interval2;
      var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
      var d1 = distance3(v0[0], v0[1], v1[0], v1[1]);
      if (prev >= 0 && d1 < d) {
        t = prev;
        d = d1;
      } else {
        var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
        var d2 = distance3(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d2 < d) {
          t = next;
          d = d2;
        } else {
          interval2 *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(null, xArr.concat([t])),
      y: tCallback.apply(null, yArr.concat([t]))
    };
  }
  function snapLength(xArr, yArr) {
    var totalLength = 0;
    var count2 = xArr.length;
    for (var i = 0; i < count2; i++) {
      var x = xArr[i];
      var y = yArr[i];
      var nextX = xArr[(i + 1) % count2];
      var nextY = yArr[(i + 1) % count2];
      totalLength += distance3(x, y, nextX, nextY);
    }
    return totalLength / 2;
  }

  // node_modules/@antv/g-math/esm/quadratic.js
  function quadraticAt(p0, p1, p22, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p22;
  }
  function extrema(p0, p1, p22) {
    var a = p0 + p22 - 2 * p1;
    if (isNumberEqual2(a, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function derivativeAt(p0, p1, p22, t) {
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p22 - p1);
  }
  function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
    var xt = quadraticAt(x1, x2, x3, t);
    var yt = quadraticAt(y1, y2, y3, t);
    var controlPoint1 = line_default.pointAt(x1, y1, x2, y2, t);
    var controlPoint2 = line_default.pointAt(x2, y2, x3, y3, t);
    return [
      [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
      [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
    ];
  }
  function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
    if (iterationCount === 0) {
      return (distance3(x1, y1, x2, y2) + distance3(x2, y2, x3, y3) + distance3(x1, y1, x3, y3)) / 2;
    }
    var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
    var left = quadratics[0];
    var right = quadratics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
  }
  var quadratic_default = {
    box: function(x1, y1, x2, y2, x3, y3) {
      var xExtrema2 = extrema(x1, x2, x3)[0];
      var yExtrema2 = extrema(y1, y2, y3)[0];
      var xArr = [x1, x3];
      var yArr = [y1, y3];
      if (xExtrema2 !== void 0) {
        xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
      }
      if (yExtrema2 !== void 0) {
        yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function(x1, y1, x2, y2, x3, y3) {
      return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
    },
    nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
      return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
    },
    pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
      return distance3(point.x, point.y, x0, y0);
    },
    interpolationAt: quadraticAt,
    pointAt: function(x1, y1, x2, y2, x3, y3, t) {
      return {
        x: quadraticAt(x1, x2, x3, t),
        y: quadraticAt(y1, y2, y3, t)
      };
    },
    divide: function(x1, y1, x2, y2, x3, y3, t) {
      return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
    },
    tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
      var dx = derivativeAt(x1, x2, x3, t);
      var dy = derivativeAt(y1, y2, y3, t);
      var angle3 = Math.atan2(dy, dx);
      return piMod(angle3);
    }
  };

  // node_modules/@antv/g-math/esm/cubic.js
  function cubicAt(p0, p1, p22, p3, t) {
    var onet = 1 - t;
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p22 * t * t * onet + p3 * t * t * t;
  }
  function derivativeAt2(p0, p1, p22, p3, t) {
    var onet = 1 - t;
    return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p22 - p1) + t * t * (p3 - p22));
  }
  function extrema2(p0, p1, p22, p3) {
    var a = -3 * p0 + 9 * p1 - 9 * p22 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p22;
    var c = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual2(a, 0)) {
      if (!isNumberEqual2(b, 0)) {
        t1 = -c / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isNumberEqual2(disc, 0)) {
        extremas.push(-b / (2 * a));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a);
        t2 = (-b - discSqrt) / (2 * a);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var xt = cubicAt(x1, x2, x3, x4, t);
    var yt = cubicAt(y1, y2, y3, y4, t);
    var c1 = line_default.pointAt(x1, y1, x2, y2, t);
    var c2 = line_default.pointAt(x2, y2, x3, y3, t);
    var c3 = line_default.pointAt(x3, y3, x4, y4, t);
    var c12 = line_default.pointAt(c1.x, c1.y, c2.x, c2.y, t);
    var c23 = line_default.pointAt(c2.x, c2.y, c3.x, c3.y, t);
    return [
      [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
      [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
    ];
  }
  function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
    if (iterationCount === 0) {
      return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
    }
    var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
    var left = cubics[0];
    var right = cubics[1];
    left.push(iterationCount - 1);
    right.push(iterationCount - 1);
    return cubicLength.apply(null, left) + cubicLength.apply(null, right);
  }
  var cubic_default = {
    extrema: extrema2,
    box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      var xArr = [x1, x4];
      var yArr = [y1, y4];
      var xExtrema2 = extrema2(x1, x2, x3, x4);
      var yExtrema2 = extrema2(y1, y2, y3, y4);
      for (var i = 0; i < xExtrema2.length; i++) {
        xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
      }
      for (var i = 0; i < yExtrema2.length; i++) {
        yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
      return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
    },
    nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3) {
      return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length3);
    },
    pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3) {
      var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length3);
      return distance3(point.x, point.y, x0, y0);
    },
    interpolationAt: cubicAt,
    pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return {
        x: cubicAt(x1, x2, x3, x4, t),
        y: cubicAt(y1, y2, y3, y4, t)
      };
    },
    divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
    },
    tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
      var dx = derivativeAt2(x1, x2, x3, x4, t);
      var dy = derivativeAt2(y1, y2, y3, y4, t);
      return piMod(Math.atan2(dy, dx));
    }
  };

  // node_modules/@antv/g-math/esm/ellipse.js
  function copysign(v1, v2) {
    var absv = Math.abs(v1);
    return v2 > 0 ? absv : absv * -1;
  }
  var ellipse_default = {
    box: function(x, y, rx, ry) {
      return {
        x: x - rx,
        y: y - ry,
        width: rx * 2,
        height: ry * 2
      };
    },
    length: function(x, y, rx, ry) {
      return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
    },
    nearestPoint: function(x, y, rx, ry, x0, y0) {
      var a = rx;
      var b = ry;
      if (a === 0 || b === 0) {
        return {
          x,
          y
        };
      }
      var relativeX = x0 - x;
      var relativeY = y0 - y;
      var px = Math.abs(relativeX);
      var py = Math.abs(relativeY);
      var squareA = a * a;
      var squareB = b * b;
      var t = Math.PI / 4;
      var nearestX;
      var nearestY;
      for (var i = 0; i < 4; i++) {
        nearestX = a * Math.cos(t);
        nearestY = b * Math.sin(t);
        var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
        var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
        var rx1 = nearestX - ex;
        var ry1 = nearestY - ey;
        var qx = px - ex;
        var qy = py - ey;
        var r = Math.hypot(ry1, rx1);
        var q = Math.hypot(qy, qx);
        var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
        var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
        t += delta_t;
        t = Math.min(Math.PI / 2, Math.max(0, t));
      }
      return {
        x: x + copysign(nearestX, relativeX),
        y: y + copysign(nearestY, relativeY)
      };
    },
    pointDistance: function(x, y, rx, ry, x0, y0) {
      var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
      return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
    },
    pointAt: function(x, y, rx, ry, t) {
      var angle3 = 2 * Math.PI * t;
      return {
        x: x + rx * Math.cos(angle3),
        y: y + ry * Math.sin(angle3)
      };
    },
    tangentAngle: function(x, y, rx, ry, t) {
      var angle3 = 2 * Math.PI * t;
      var tangentAngle = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
      return piMod(tangentAngle);
    }
  };

  // node_modules/@antv/g-math/esm/arc.js
  function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
    return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
  }
  function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
    return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
  }
  function xExtrema(rx, ry, xRotation) {
    return Math.atan(-ry / rx * Math.tan(xRotation));
  }
  function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
  }
  function xAt(cx, cy, rx, ry, xRotation, angle3) {
    return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
  }
  function yAt(cx, cy, rx, ry, xRotation, angle3) {
    return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
  }
  function getAngle(rx, ry, x0, y0) {
    var angle3 = Math.atan2(y0 * rx, x0 * ry);
    return (angle3 + Math.PI * 2) % (Math.PI * 2);
  }
  function getPoint(rx, ry, angle3) {
    return {
      x: rx * Math.cos(angle3),
      y: ry * Math.sin(angle3)
    };
  }
  function rotate3(x, y, angle3) {
    var cos5 = Math.cos(angle3);
    var sin5 = Math.sin(angle3);
    return [x * cos5 - y * sin5, x * sin5 + y * cos5];
  }
  var arc_default = {
    box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
      var xDim = xExtrema(rx, ry, xRotation);
      var minX = Infinity;
      var maxX = -Infinity;
      var xs = [startAngle, endAngle];
      for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
        var xAngle = xDim + i;
        if (startAngle < endAngle) {
          if (startAngle < xAngle && xAngle < endAngle) {
            xs.push(xAngle);
          }
        } else {
          if (endAngle < xAngle && xAngle < startAngle) {
            xs.push(xAngle);
          }
        }
      }
      for (var i = 0; i < xs.length; i++) {
        var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
        if (x < minX) {
          minX = x;
        }
        if (x > maxX) {
          maxX = x;
        }
      }
      var yDim = yExtrema(rx, ry, xRotation);
      var minY = Infinity;
      var maxY = -Infinity;
      var ys = [startAngle, endAngle];
      for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
        var yAngle = yDim + i;
        if (startAngle < endAngle) {
          if (startAngle < yAngle && yAngle < endAngle) {
            ys.push(yAngle);
          }
        } else {
          if (endAngle < yAngle && yAngle < startAngle) {
            ys.push(yAngle);
          }
        }
      }
      for (var i = 0; i < ys.length; i++) {
        var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
        if (y < minY) {
          minY = y;
        }
        if (y > maxY) {
          maxY = y;
        }
      }
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    },
    nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
      var relativeVector = rotate3(x0 - cx, y0 - cy, -xRotation);
      var x1 = relativeVector[0], y1 = relativeVector[1];
      var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
      var angle3 = getAngle(rx, ry, relativePoint.x, relativePoint.y);
      if (angle3 < startAngle) {
        relativePoint = getPoint(rx, ry, startAngle);
      } else if (angle3 > endAngle) {
        relativePoint = getPoint(rx, ry, endAngle);
      }
      var vector = rotate3(relativePoint.x, relativePoint.y, xRotation);
      return {
        x: vector[0] + cx,
        y: vector[1] + cy
      };
    },
    pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
      var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
      return distance3(nearestPoint2.x, nearestPoint2.y, x0, y0);
    },
    pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
      var angle3 = (endAngle - startAngle) * t + startAngle;
      return {
        x: xAt(cx, cy, rx, ry, xRotation, angle3),
        y: yAt(cx, cy, rx, ry, xRotation, angle3)
      };
    },
    tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
      var angle3 = (endAngle - startAngle) * t + startAngle;
      var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
      var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
      return piMod(Math.atan2(dy, dx));
    }
  };

  // node_modules/@antv/g-math/esm/segments.js
  function analyzePoints(points) {
    var totalLength = 0;
    var segments = [];
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      var length_1 = distance3(from[0], from[1], to[0], to[1]);
      var seg = {
        from,
        to,
        length: length_1
      };
      segments.push(seg);
      totalLength += length_1;
    }
    return { segments, totalLength };
  }
  function lengthOfSegment(points) {
    if (points.length < 2) {
      return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      totalLength += distance3(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
  }
  function pointAtSegments(points, t) {
    if (t > 1 || t < 0 || points.length < 2) {
      return null;
    }
    var _a4 = analyzePoints(points), segments = _a4.segments, totalLength = _a4.totalLength;
    if (totalLength === 0) {
      return {
        x: points[0][0],
        y: points[0][1]
      };
    }
    var startRatio = 0;
    var point = null;
    for (var i = 0; i < segments.length; i++) {
      var seg = segments[i];
      var from = seg.from, to = seg.to;
      var currentRatio = seg.length / totalLength;
      if (t >= startRatio && t <= startRatio + currentRatio) {
        var localRatio = (t - startRatio) / currentRatio;
        point = line_default.pointAt(from[0], from[1], to[0], to[1], localRatio);
        break;
      }
      startRatio += currentRatio;
    }
    return point;
  }
  function angleAtSegments(points, t) {
    if (t > 1 || t < 0 || points.length < 2) {
      return 0;
    }
    var _a4 = analyzePoints(points), segments = _a4.segments, totalLength = _a4.totalLength;
    var startRatio = 0;
    var angle3 = 0;
    for (var i = 0; i < segments.length; i++) {
      var seg = segments[i];
      var from = seg.from, to = seg.to;
      var currentRatio = seg.length / totalLength;
      if (t >= startRatio && t <= startRatio + currentRatio) {
        angle3 = Math.atan2(to[1] - from[1], to[0] - from[0]);
        break;
      }
      startRatio += currentRatio;
    }
    return angle3;
  }
  function distanceAtSegment(points, x, y) {
    var minDistance = Infinity;
    for (var i = 0; i < points.length - 1; i++) {
      var point = points[i];
      var nextPoint = points[i + 1];
      var distance_1 = line_default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);
      if (distance_1 < minDistance) {
        minDistance = distance_1;
      }
    }
    return minDistance;
  }

  // node_modules/@antv/g-math/esm/polyline.js
  var polyline_default = {
    box: function(points) {
      var xArr = [];
      var yArr = [];
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        xArr.push(point[0]);
        yArr.push(point[1]);
      }
      return getBBoxByArray(xArr, yArr);
    },
    length: function(points) {
      return lengthOfSegment(points);
    },
    pointAt: function(points, t) {
      return pointAtSegments(points, t);
    },
    pointDistance: function(points, x, y) {
      return distanceAtSegment(points, x, y);
    },
    tangentAngle: function(points, t) {
      return angleAtSegments(points, t);
    }
  };

  // node_modules/@antv/g-base/esm/bbox/util.js
  function mergeBBox(bbox1, bbox2) {
    if (!bbox1 || !bbox2) {
      return bbox1 || bbox2;
    }
    return {
      minX: Math.min(bbox1.minX, bbox2.minX),
      minY: Math.min(bbox1.minY, bbox2.minY),
      maxX: Math.max(bbox1.maxX, bbox2.maxX),
      maxY: Math.max(bbox1.maxY, bbox2.maxY)
    };
  }
  function mergeArrowBBox(shape, bbox) {
    var startArrowShape = shape.get("startArrowShape");
    var endArrowShape = shape.get("endArrowShape");
    var startArrowBBox = null;
    var endArrowBBox = null;
    if (startArrowShape) {
      startArrowBBox = startArrowShape.getCanvasBBox();
      bbox = mergeBBox(bbox, startArrowBBox);
    }
    if (endArrowShape) {
      endArrowBBox = endArrowShape.getCanvasBBox();
      bbox = mergeBBox(bbox, endArrowBBox);
    }
    return bbox;
  }

  // node_modules/@antv/g-base/esm/bbox/polyline.js
  function polyline_default2(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    var _a4 = util_exports.getBBoxByArray(xArr, yArr), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/g-base/esm/bbox/polygon.js
  function polygon_default2(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return util_exports.getBBoxByArray(xArr, yArr);
  }

  // node_modules/@antv/g-base/esm/util/offscreen.js
  var offScreenCtx = null;
  function getOffScreenContext() {
    if (!offScreenCtx) {
      var canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      offScreenCtx = canvas.getContext("2d");
    }
    return offScreenCtx;
  }

  // node_modules/@antv/g-base/esm/util/text.js
  function getTextHeight(text, fontSize, lineHeight) {
    var lineCount = 1;
    if (is_string_default(text)) {
      lineCount = text.split("\n").length;
    }
    if (lineCount > 1) {
      var spaceingY = getLineSpaceing(fontSize, lineHeight);
      return fontSize * lineCount + spaceingY * (lineCount - 1);
    }
    return fontSize;
  }
  function getLineSpaceing(fontSize, lineHeight) {
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  }
  function getTextWidth(text, font) {
    var context = getOffScreenContext();
    var width = 0;
    if (is_nil_default(text) || text === "") {
      return width;
    }
    context.save();
    context.font = font;
    if (is_string_default(text) && text.includes("\n")) {
      var textArr = text.split("\n");
      each_default(textArr, function(subText) {
        var measureWidth = context.measureText(subText).width;
        if (width < measureWidth) {
          width = measureWidth;
        }
      });
    } else {
      width = context.measureText(text).width;
    }
    context.restore();
    return width;
  }
  function assembleFont(attrs) {
    var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
    return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
  }

  // node_modules/@antv/g-base/esm/bbox/text.js
  function text_default(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
    var font = attrs.font;
    if (!font) {
      font = assembleFont(attrs);
    }
    var width = getTextWidth(text, font);
    var bbox;
    if (!width) {
      bbox = {
        x,
        y,
        width: 0,
        height: 0
      };
    } else {
      var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
      var height = getTextHeight(text, fontSize, lineHeight);
      var point = {
        x,
        y: y - height
      };
      if (textAlign) {
        if (textAlign === "end" || textAlign === "right") {
          point.x -= width;
        } else if (textAlign === "center") {
          point.x -= width / 2;
        }
      }
      if (textBaseline) {
        if (textBaseline === "top") {
          point.y += height;
        } else if (textBaseline === "middle") {
          point.y += height / 2;
        }
      }
      bbox = {
        x: point.x,
        y: point.y,
        width,
        height
      };
    }
    return bbox;
  }

  // node_modules/@antv/path-util/esm/parse-path.js
  var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
  var regexDot = /[^\s\,]+/ig;
  function parsePath(p3) {
    var path = p3 || [];
    if (is_array_default(path)) {
      return path;
    }
    if (is_string_default(path)) {
      path = path.match(regexTags);
      each_default(path, function(item, index) {
        item = item.match(regexDot);
        if (item[0].length > 1) {
          var tag = item[0].charAt(0);
          item.splice(1, 0, item[0].substr(1));
          item[0] = tag;
        }
        each_default(item, function(sub7, i) {
          if (!isNaN(sub7)) {
            item[i] = +sub7;
          }
        });
        path[index] = item;
      });
      return path;
    }
  }
  var parse_path_default = parsePath;

  // node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
  function smoothBezier(points, smooth, isLoop, constraint) {
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min7;
    var max7;
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      min7 = constraint[0], max7 = constraint[1];
      for (var i = 0, l = points.length; i < l; i += 1) {
        var point = points[i];
        min7 = vec2_exports.min([0, 0], min7, point);
        max7 = vec2_exports.max([0, 0], max7, point);
      }
    }
    for (var i = 0, len3 = points.length; i < len3; i += 1) {
      var point = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point;
      } else if (i === len3 - 1 && !isLoop) {
        cp1 = point;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        var prevIdx = [i ? i - 1 : len3 - 1, i - 1][isLoop ? 0 : 1];
        prevPoint = points[prevIdx];
        nextPoint = points[isLoop ? (i + 1) % len3 : i + 1];
        var v = [0, 0];
        v = vec2_exports.sub(v, nextPoint, prevPoint);
        v = vec2_exports.scale(v, v, smooth);
        var d0 = vec2_exports.distance(point, prevPoint);
        var d1 = vec2_exports.distance(point, nextPoint);
        var sum5 = d0 + d1;
        if (sum5 !== 0) {
          d0 /= sum5;
          d1 /= sum5;
        }
        var v1 = vec2_exports.scale([0, 0], v, -d0);
        var v2 = vec2_exports.scale([0, 0], v, d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
        nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
        v1 = vec2_exports.sub([0, 0], nextCp0, point);
        v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
        cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
        v2 = vec2_exports.sub([0, 0], point, cp1);
        v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        if (hasConstraint) {
          cp1 = vec2_exports.max([0, 0], cp1, min7);
          cp1 = vec2_exports.min([0, 0], cp1, max7);
          nextCp0 = vec2_exports.max([0, 0], nextCp0, min7);
          nextCp0 = vec2_exports.min([0, 0], nextCp0, max7);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function catmullRom2Bezier(crp, z, constraint) {
    if (z === void 0) {
      z = false;
    }
    if (constraint === void 0) {
      constraint = [
        [0, 0],
        [1, 1]
      ];
    }
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len3 = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p3;
    for (var i = 0; i < len3 - 1; i += 1) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p3 = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len3];
      cp2 = controlPointList[len3 + 1];
      p3 = pointList[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]]);
    }
    return d1;
  }
  var catmull_rom_2_bezier_default = catmullRom2Bezier;

  // node_modules/@antv/path-util/esm/parse-path-string.js
  var SPACES2 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
  var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
  var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
  function parsePathString2(pathString) {
    if (!pathString) {
      return null;
    }
    if (is_array_default(pathString)) {
      return pathString;
    }
    var paramCounts = {
      a: 7,
      c: 6,
      o: 2,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      u: 3,
      z: 0
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND2, function(a, b, c) {
      var params = [];
      var name = b.toLowerCase();
      c.replace(PATH_VALUES2, function(a6, b10) {
        b10 && params.push(+b10);
      });
      if (name === "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = "l";
        b = b === "m" ? "l" : "L";
      }
      if (name === "o" && params.length === 1) {
        data.push([b, params[0]]);
      }
      if (name === "r") {
        data.push([b].concat(params));
      } else {
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      }
      return "";
    });
    return data;
  }

  // node_modules/@antv/path-util/esm/path-2-absolute.js
  var REGEX_MD = /[a-z]/;
  function toSymmetry(p3, c) {
    return [
      c[0] + (c[0] - p3[0]),
      c[1] + (c[1] - p3[1])
    ];
  }
  function pathToAbsolute2(pathString) {
    var pathArray = parsePathString2(pathString);
    if (!pathArray || !pathArray.length) {
      return [
        ["M", 0, 0]
      ];
    }
    var needProcess = false;
    for (var i = 0; i < pathArray.length; i++) {
      var cmd = pathArray[i][0];
      if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
        needProcess = true;
        break;
      }
    }
    if (!needProcess) {
      return pathArray;
    }
    var res = [];
    var x = 0;
    var y = 0;
    var mx = 0;
    var my = 0;
    var start = 0;
    var pa0;
    var dots;
    var first = pathArray[0];
    if (first[0] === "M" || first[0] === "m") {
      x = +first[1];
      y = +first[2];
      mx = x;
      my = y;
      start++;
      res[0] = ["M", x, y];
    }
    for (var i = start, ii = pathArray.length; i < ii; i++) {
      var pa = pathArray[i];
      var preParams = res[i - 1];
      var r = [];
      var cmd = pa[0];
      var upCmd = cmd.toUpperCase();
      if (cmd !== upCmd) {
        r[0] = upCmd;
        switch (upCmd) {
          case "A":
            r[1] = pa[1];
            r[2] = pa[2];
            r[3] = pa[3];
            r[4] = pa[4];
            r[5] = pa[5];
            r[6] = +pa[6] + x;
            r[7] = +pa[7] + y;
            break;
          case "V":
            r[1] = +pa[1] + y;
            break;
          case "H":
            r[1] = +pa[1] + x;
            break;
          case "M":
            mx = +pa[1] + x;
            my = +pa[2] + y;
            r[1] = mx;
            r[2] = my;
            break;
          default:
            for (var j = 1, jj = pa.length; j < jj; j++) {
              r[j] = +pa[j] + (j % 2 ? x : y);
            }
        }
      } else {
        r = pathArray[i];
      }
      switch (upCmd) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          r = ["L", x, y];
          break;
        case "V":
          y = r[1];
          r = ["L", x, y];
          break;
        case "T":
          x = r[1];
          y = r[2];
          var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
          r = ["Q", symetricT[0], symetricT[1], x, y];
          break;
        case "S":
          x = r[r.length - 2];
          y = r[r.length - 1];
          var length_1 = preParams.length;
          var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
          r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
      res.push(r);
    }
    return res;
  }

  // node_modules/@antv/path-util/esm/process/arc-2-cubic.js
  var TAU = Math.PI * 2;

  // node_modules/@antv/path-util/esm/get-arc-params.js
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function isSamePoint(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
  }
  function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    var x2 = params[6];
    var y2 = params[7];
    var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
    var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle([1, 0], u);
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return {
      cx,
      cy,
      rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
      ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }

  // node_modules/@antv/path-util/esm/path-2-segments.js
  function toSymmetry2(point, center) {
    return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
  }
  function getSegments(path) {
    path = parse_path_default(path);
    var segments = [];
    var currentPoint = null;
    var nextParams = null;
    var startMovePoint = null;
    var lastStartMovePointIndex = 0;
    var count2 = path.length;
    for (var i = 0; i < count2; i++) {
      var params = path[i];
      nextParams = path[i + 1];
      var command = params[0];
      var segment = {
        command,
        prePoint: currentPoint,
        params,
        startTangent: null,
        endTangent: null
      };
      switch (command) {
        case "M":
          startMovePoint = [params[1], params[2]];
          lastStartMovePointIndex = i;
          break;
        case "A":
          var arcParams = getArcParams(currentPoint, params);
          segment["arcParams"] = arcParams;
          break;
        default:
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
        nextParams = path[lastStartMovePointIndex + 1];
      } else {
        var len3 = params.length;
        currentPoint = [params[len3 - 2], params[len3 - 1]];
      }
      if (nextParams && nextParams[0] === "Z") {
        nextParams = path[lastStartMovePointIndex];
        if (segments[lastStartMovePointIndex]) {
          segments[lastStartMovePointIndex].prePoint = currentPoint;
        }
      }
      segment["currentPoint"] = currentPoint;
      if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
        segments[lastStartMovePointIndex].prePoint = segment.prePoint;
      }
      var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
      segment["nextPoint"] = nextPoint;
      var prePoint = segment.prePoint;
      if (["L", "H", "V"].includes(command)) {
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      } else if (command === "Q") {
        var cp = [params[1], params[2]];
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else if (command === "T") {
        var preSegment = segments[i - 1];
        var cp = toSymmetry2(preSegment.currentPoint, prePoint);
        if (preSegment.command === "Q") {
          segment.command = "Q";
          segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
          segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
        } else {
          segment.command = "TL";
          segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
          segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
        }
      } else if (command === "C") {
        var cp1 = [params[1], params[2]];
        var cp2 = [params[3], params[4]];
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
          segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        }
        if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
          segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
        }
      } else if (command === "S") {
        var preSegment = segments[i - 1];
        var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
        var cp2 = [params[1], params[2]];
        if (preSegment.command === "C") {
          segment.command = "C";
          segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
          segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        } else {
          segment.command = "SQ";
          segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
          segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        }
      } else if (command === "A") {
        var d = 1e-3;
        var _a4 = segment["arcParams"] || {}, _b = _a4.cx, cx = _b === void 0 ? 0 : _b, _c = _a4.cy, cy = _c === void 0 ? 0 : _c, _d = _a4.rx, rx = _d === void 0 ? 0 : _d, _e = _a4.ry, ry = _e === void 0 ? 0 : _e, _f = _a4.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a4.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a4.endAngle, endAngle = _h === void 0 ? 0 : _h;
        if (sweepFlag === 0) {
          d *= -1;
        }
        var dx1 = rx * Math.cos(startAngle - d) + cx;
        var dy1 = ry * Math.sin(startAngle - d) + cy;
        segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
        var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
        var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
        segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
      }
      segments.push(segment);
    }
    return segments;
  }

  // node_modules/@antv/path-util/esm/get-line-intersect.js
  var isBetween = function(value, min7, max7) {
    return value >= min7 && value <= max7;
  };
  function getLineIntersect(p0, p1, p22, p3) {
    var tolerance3 = 1e-3;
    var E = {
      x: p22.x - p0.x,
      y: p22.y - p0.y
    };
    var D0 = {
      x: p1.x - p0.x,
      y: p1.y - p0.y
    };
    var D1 = {
      x: p3.x - p22.x,
      y: p3.y - p22.y
    };
    var kross = D0.x * D1.y - D0.y * D1.x;
    var sqrKross = kross * kross;
    var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
    var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
    var point = null;
    if (sqrKross > tolerance3 * sqrLen0 * sqrLen1) {
      var s = (E.x * D1.y - E.y * D1.x) / kross;
      var t = (E.x * D0.y - E.y * D0.x) / kross;
      if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
        point = {
          x: p0.x + s * D0.x,
          y: p0.y + s * D0.y
        };
      }
    }
    return point;
  }

  // node_modules/@antv/path-util/esm/point-in-polygon.js
  var tolerance = 1e-6;
  function dcmp(x) {
    if (Math.abs(x) < tolerance) {
      return 0;
    }
    return x < 0 ? -1 : 1;
  }
  function onSegment(p1, p22, q) {
    if ((q[0] - p1[0]) * (p22[1] - p1[1]) === (p22[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p22[0]) <= q[0] && q[0] <= Math.max(p1[0], p22[0]) && Math.min(p1[1], p22[1]) <= q[1] && q[1] <= Math.max(p1[1], p22[1])) {
      return true;
    }
    return false;
  }
  function isInPolygon(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
      return false;
    }
    for (var i = 0; i < n; i++) {
      var p1 = points[i];
      var p22 = points[(i + 1) % n];
      if (onSegment(p1, p22, [x, y])) {
        return true;
      }
      if (dcmp(p1[1] - y) > 0 !== dcmp(p22[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p22[0]) / (p1[1] - p22[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }

  // node_modules/@antv/path-util/esm/is-polygons-intersect.js
  function parseToLines(points) {
    var lines = [];
    var count2 = points.length;
    for (var i = 0; i < count2 - 1; i++) {
      var point = points[i];
      var next = points[i + 1];
      lines.push({
        from: {
          x: point[0],
          y: point[1]
        },
        to: {
          x: next[0],
          y: next[1]
        }
      });
    }
    if (lines.length > 1) {
      var first = points[0];
      var last2 = points[count2 - 1];
      lines.push({
        from: {
          x: last2[0],
          y: last2[1]
        },
        to: {
          x: first[0],
          y: first[1]
        }
      });
    }
    return lines;
  }
  function lineIntersectPolygon(lines, line) {
    var isIntersect2 = false;
    each_default(lines, function(l) {
      if (getLineIntersect(l.from, l.to, line.from, line.to)) {
        isIntersect2 = true;
        return false;
      }
    });
    return isIntersect2;
  }
  function getBBox(points) {
    var xArr = points.map(function(p3) {
      return p3[0];
    });
    var yArr = points.map(function(p3) {
      return p3[1];
    });
    return {
      minX: Math.min.apply(null, xArr),
      maxX: Math.max.apply(null, xArr),
      minY: Math.min.apply(null, yArr),
      maxY: Math.max.apply(null, yArr)
    };
  }
  function intersectBBox(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
  }
  function isPolygonsIntersect(points1, points2) {
    if (points1.length < 2 || points2.length < 2) {
      return false;
    }
    var bbox1 = getBBox(points1);
    var bbox2 = getBBox(points2);
    if (!intersectBBox(bbox1, bbox2)) {
      return false;
    }
    var isIn = false;
    each_default(points2, function(point) {
      if (isInPolygon(points1, point[0], point[1])) {
        isIn = true;
        return false;
      }
    });
    if (isIn) {
      return true;
    }
    each_default(points1, function(point) {
      if (isInPolygon(points2, point[0], point[1])) {
        isIn = true;
        return false;
      }
    });
    if (isIn) {
      return true;
    }
    var lines1 = parseToLines(points1);
    var lines2 = parseToLines(points2);
    var isIntersect2 = false;
    each_default(lines2, function(line) {
      if (lineIntersectPolygon(lines1, line)) {
        isIntersect2 = true;
        return false;
      }
    });
    return isIntersect2;
  }

  // node_modules/@antv/g-base/esm/bbox/path.js
  function getPathBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    var minX = min_default(xArr);
    var minY = min_default(yArr);
    var maxX = max_default(xArr);
    var maxY = max_default(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    for (var i = 0; i < segmentsWithAngle.length; i++) {
      var segment = segmentsWithAngle[i];
      var currentPoint = segment.currentPoint;
      var extra = void 0;
      if (currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        minX = minX - extra.xExtra;
      } else if (currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        maxX = maxX + extra.xExtra;
      }
      if (currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        minY = minY - extra.yExtra;
      } else if (currentPoint[1] === maxY) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        maxY = maxY + extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function path_default(shape) {
    var attrs = shape.attr();
    var path = attrs.path, stroke = attrs.stroke;
    var lineWidth = stroke ? attrs.lineWidth : 0;
    var segments = shape.get("segments") || getSegments(path);
    var _a4 = getPathBox(segments, lineWidth), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/g-base/esm/bbox/line.js
  function line_default2(shape) {
    var attrs = shape.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var bbox = {
      minX,
      maxX,
      minY,
      maxY
    };
    bbox = mergeArrowBBox(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/g-base/esm/bbox/ellipse.js
  function ellipse_default2(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  }

  // node_modules/@antv/g-base/esm/bbox/index.js
  register("rect", rect_default);
  register("image", rect_default);
  register("circle", circle_default);
  register("marker", circle_default);
  register("polyline", polyline_default2);
  register("polygon", polygon_default2);
  register("text", text_default);
  register("path", path_default);
  register("line", line_default2);
  register("ellipse", ellipse_default2);

  // node_modules/@antv/adjust/esm/constant.js
  var DEFAULT_Y = 0;
  var MARGIN_RATIO = 1 / 2;
  var DODGE_RATIO = 1 / 2;
  var GAP = 0.05;

  // node_modules/@antv/adjust/esm/adjusts/adjust.js
  var Adjust = function() {
    function Adjust2(cfg) {
      var xField = cfg.xField, yField = cfg.yField, _a4 = cfg.adjustNames, adjustNames = _a4 === void 0 ? ["x", "y"] : _a4;
      this.adjustNames = adjustNames;
      this.xField = xField;
      this.yField = yField;
    }
    Adjust2.prototype.isAdjust = function(dim) {
      return this.adjustNames.indexOf(dim) >= 0;
    };
    Adjust2.prototype.getAdjustRange = function(dim, dimValue, values2) {
      var yField = this.yField;
      var index = values2.indexOf(dimValue);
      var length3 = values2.length;
      var pre;
      var next;
      if (!yField && this.isAdjust("y")) {
        pre = 0;
        next = 1;
      } else if (length3 > 1) {
        pre = values2[index === 0 ? 0 : index - 1];
        next = values2[index === length3 - 1 ? length3 - 1 : index + 1];
        if (index !== 0) {
          pre += (dimValue - pre) / 2;
        } else {
          pre -= (next - dimValue) / 2;
        }
        if (index !== length3 - 1) {
          next -= (next - dimValue) / 2;
        } else {
          next += (dimValue - values2[length3 - 2]) / 2;
        }
      } else {
        pre = dimValue === 0 ? 0 : dimValue - 0.5;
        next = dimValue === 0 ? 1 : dimValue + 0.5;
      }
      return {
        pre,
        next
      };
    };
    Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
      var _this = this;
      var dimValuesMap = this.getDimValues(mergedData);
      each_default(groupedDataArray, function(dataArray, index) {
        each_default(dimValuesMap, function(values2, dim) {
          _this.adjustDim(dim, values2, dataArray, index);
        });
      });
    };
    Adjust2.prototype.groupData = function(data, dim) {
      each_default(data, function(record) {
        if (record[dim] === void 0) {
          record[dim] = DEFAULT_Y;
        }
      });
      return group_by_default(data, dim);
    };
    Adjust2.prototype.adjustDim = function(dim, values2, data, index) {
    };
    Adjust2.prototype.getDimValues = function(mergedData) {
      var _a4 = this, xField = _a4.xField, yField = _a4.yField;
      var dimValuesMap = {};
      var dims = [];
      if (xField && this.isAdjust("x")) {
        dims.push(xField);
      }
      if (yField && this.isAdjust("y")) {
        dims.push(yField);
      }
      dims.forEach(function(dim2) {
        dimValuesMap[dim2] = values_of_key_default(mergedData, dim2).sort(function(v1, v2) {
          return v1 - v2;
        });
      });
      if (!yField && this.isAdjust("y")) {
        var dim = "y";
        dimValuesMap[dim] = [DEFAULT_Y, 1];
      }
      return dimValuesMap;
    };
    return Adjust2;
  }();
  var adjust_default = Adjust;

  // node_modules/@antv/adjust/esm/factory.js
  var ADJUST_MAP = {};
  var getAdjust = function(type) {
    return ADJUST_MAP[type.toLowerCase()];
  };
  var registerAdjust = function(type, ctor) {
    if (getAdjust(type)) {
      throw new Error("Adjust type '" + type + "' existed.");
    }
    ADJUST_MAP[type.toLowerCase()] = ctor;
  };

  // node_modules/@antv/adjust/node_modules/tslib/modules/index.js
  var import_tslib12 = __toModule(require_tslib4());
  var {
    __extends: __extends4,
    __assign: __assign4,
    __rest: __rest4,
    __decorate: __decorate4,
    __param: __param4,
    __metadata: __metadata4,
    __awaiter: __awaiter4,
    __generator: __generator4,
    __exportStar: __exportStar4,
    __createBinding: __createBinding4,
    __values: __values4,
    __read: __read4,
    __spread: __spread4,
    __spreadArrays: __spreadArrays4,
    __await: __await4,
    __asyncGenerator: __asyncGenerator4,
    __asyncDelegator: __asyncDelegator4,
    __asyncValues: __asyncValues4,
    __makeTemplateObject: __makeTemplateObject4,
    __importStar: __importStar4,
    __importDefault: __importDefault4,
    __classPrivateFieldGet: __classPrivateFieldGet4,
    __classPrivateFieldSet: __classPrivateFieldSet4
  } = import_tslib12.default;

  // node_modules/@antv/adjust/esm/adjusts/dodge.js
  var Dodge = function(_super) {
    __extends4(Dodge2, _super);
    function Dodge2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.cacheMap = {};
      _this.adjustDataArray = [];
      _this.mergeData = [];
      var _a4 = cfg.marginRatio, marginRatio = _a4 === void 0 ? MARGIN_RATIO : _a4, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio;
      _this.marginRatio = marginRatio;
      _this.dodgeRatio = dodgeRatio;
      _this.dodgeBy = dodgeBy;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.xDimensionLegenth = xDimensionLength;
      _this.groupNum = groupNum;
      _this.defaultSize = defaultSize;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      return _this;
    }
    Dodge2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone_default(groupDataArray);
      var mergeData = flatten_default(groupedDataArray);
      var dodgeBy = this.dodgeBy;
      var adjustDataArray = dodgeBy ? group_default(mergeData, dodgeBy) : groupedDataArray;
      this.cacheMap = {};
      this.adjustDataArray = adjustDataArray;
      this.mergeData = mergeData;
      this.adjustData(adjustDataArray, mergeData);
      this.adjustDataArray = [];
      this.mergeData = [];
      return groupedDataArray;
    };
    Dodge2.prototype.adjustDim = function(dim, values2, data, frameIndex) {
      var _this = this;
      var map5 = this.getDistribution(dim);
      var groupData = this.groupData(data, dim);
      each_default(groupData, function(group2, key) {
        var range5;
        if (values2.length === 1) {
          range5 = {
            pre: values2[0] - 1,
            next: values2[0] + 1
          };
        } else {
          range5 = _this.getAdjustRange(dim, parseFloat(key), values2);
        }
        each_default(group2, function(d) {
          var value = d[dim];
          var valueArr = map5[value];
          var valIndex = valueArr.indexOf(frameIndex);
          d[dim] = _this.getDodgeOffset(range5, valIndex, valueArr.length);
        });
      });
      return [];
    };
    Dodge2.prototype.getDodgeOffset = function(range5, idx, len3) {
      var _a4 = this, dodgeRatio = _a4.dodgeRatio, marginRatio = _a4.marginRatio, intervalPadding = _a4.intervalPadding, dodgePadding = _a4.dodgePadding;
      var pre = range5.pre, next = range5.next;
      var tickLength = next - pre;
      var position;
      if (!is_nil_default(intervalPadding) && is_nil_default(dodgePadding) && intervalPadding >= 0) {
        var offset = this.getIntervalOnlyOffset(len3, idx);
        position = pre + offset;
      } else if (!is_nil_default(dodgePadding) && is_nil_default(intervalPadding) && dodgePadding >= 0) {
        var offset = this.getDodgeOnlyOffset(len3, idx);
        position = pre + offset;
      } else if (!is_nil_default(intervalPadding) && !is_nil_default(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
        var offset = this.getIntervalAndDodgeOffset(len3, idx);
        position = pre + offset;
      } else {
        var width = tickLength * dodgeRatio / len3;
        var margin = marginRatio * width;
        var offset = 1 / 2 * (tickLength - len3 * width - (len3 - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
        position = (pre + next) / 2 + offset;
      }
      return position;
    };
    Dodge2.prototype.getIntervalOnlyOffset = function(len3, idx) {
      var _a4 = this, defaultSize = _a4.defaultSize, intervalPadding = _a4.intervalPadding, xDimensionLegenth = _a4.xDimensionLegenth, groupNum = _a4.groupNum, dodgeRatio = _a4.dodgeRatio, maxColumnWidth = _a4.maxColumnWidth, minColumnWidth = _a4.minColumnWidth, columnWidthRatio = _a4.columnWidthRatio;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len3 - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      geomWidth = !is_nil_default(columnWidthRatio) ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
      if (!is_nil_default(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!is_nil_default(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len3 * geomWidth) / (len3 - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDodgeOnlyOffset = function(len3, idx) {
      var _a4 = this, defaultSize = _a4.defaultSize, dodgePadding = _a4.dodgePadding, xDimensionLegenth = _a4.xDimensionLegenth, groupNum = _a4.groupNum, marginRatio = _a4.marginRatio, maxColumnWidth = _a4.maxColumnWidth, minColumnWidth = _a4.minColumnWidth, columnWidthRatio = _a4.columnWidthRatio;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      geomWidth = columnWidthRatio ? 1 / groupNum / len3 * columnWidthRatio : geomWidth;
      if (!is_nil_default(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!is_nil_default(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedIntervalPadding = (1 - (geomWidth * len3 + normalizedDodgePadding * (len3 - 1)) * groupNum) / (groupNum - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getIntervalAndDodgeOffset = function(len3, idx) {
      var _a4 = this, intervalPadding = _a4.intervalPadding, dodgePadding = _a4.dodgePadding, xDimensionLegenth = _a4.xDimensionLegenth, groupNum = _a4.groupNum;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len3 - 1)) / len3;
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDistribution = function(dim) {
      var groupedDataArray = this.adjustDataArray;
      var cacheMap = this.cacheMap;
      var map5 = cacheMap[dim];
      if (!map5) {
        map5 = {};
        each_default(groupedDataArray, function(data, index) {
          var values2 = values_of_key_default(data, dim);
          if (!values2.length) {
            values2.push(0);
          }
          each_default(values2, function(val) {
            if (!map5[val]) {
              map5[val] = [];
            }
            map5[val].push(index);
          });
        });
        cacheMap[dim] = map5;
      }
      return map5;
    };
    return Dodge2;
  }(adjust_default);
  var dodge_default = Dodge;

  // node_modules/@antv/adjust/esm/adjusts/jitter.js
  function randomNumber(min7, max7) {
    return (max7 - min7) * Math.random() + min7;
  }
  var Jitter = function(_super) {
    __extends4(Jitter2, _super);
    function Jitter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Jitter2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone_default(groupDataArray);
      var mergeData = flatten_default(groupedDataArray);
      this.adjustData(groupedDataArray, mergeData);
      return groupedDataArray;
    };
    Jitter2.prototype.adjustDim = function(dim, values2, dataArray) {
      var _this = this;
      var groupDataArray = this.groupData(dataArray, dim);
      return each_default(groupDataArray, function(data, dimValue) {
        return _this.adjustGroup(data, dim, parseFloat(dimValue), values2);
      });
    };
    Jitter2.prototype.getAdjustOffset = function(range5) {
      var pre = range5.pre, next = range5.next;
      var margin = (next - pre) * GAP;
      return randomNumber(pre + margin, next - margin);
    };
    Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values2) {
      var _this = this;
      var range5 = this.getAdjustRange(dim, dimValue, values2);
      each_default(group2, function(data) {
        data[dim] = _this.getAdjustOffset(range5);
      });
      return group2;
    };
    return Jitter2;
  }(adjust_default);
  var jitter_default = Jitter;

  // node_modules/@antv/adjust/esm/adjusts/stack.js
  var Cache = cache_default;
  var Stack = function(_super) {
    __extends4(Stack2, _super);
    function Stack2(cfg) {
      var _this = _super.call(this, cfg) || this;
      var _a4 = cfg.adjustNames, adjustNames = _a4 === void 0 ? ["y"] : _a4, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size3 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
      _this.adjustNames = adjustNames;
      _this.height = height;
      _this.size = size3;
      _this.reverseOrder = reverseOrder;
      return _this;
    }
    Stack2.prototype.process = function(groupDataArray) {
      var _a4 = this, yField = _a4.yField, reverseOrder = _a4.reverseOrder;
      var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
      return reverseOrder ? this.reverse(d) : d;
    };
    Stack2.prototype.reverse = function(groupedDataArray) {
      return groupedDataArray.slice(0).reverse();
    };
    Stack2.prototype.processStack = function(groupDataArray) {
      var _a4 = this, xField = _a4.xField, yField = _a4.yField, reverseOrder = _a4.reverseOrder;
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var positive = new Cache();
      var negative = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data) {
          var _a5;
          var x = get_default(data, xField, 0);
          var y = get_default(data, [yField]);
          var xKey = x.toString();
          y = is_array_default(y) ? y[1] : y;
          if (!is_nil_default(y)) {
            var cache3 = y >= 0 ? positive : negative;
            if (!cache3.has(xKey)) {
              cache3.set(xKey, 0);
            }
            var xValue = cache3.get(xKey);
            var newXValue = y + xValue;
            cache3.set(xKey, newXValue);
            return __assign4(__assign4({}, data), (_a5 = {}, _a5[yField] = [xValue, newXValue], _a5));
          }
          return data;
        });
      });
    };
    Stack2.prototype.processOneDimStack = function(groupDataArray) {
      var _this = this;
      var _a4 = this, xField = _a4.xField, height = _a4.height, reverseOrder = _a4.reverseOrder;
      var yField = "y";
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var cache3 = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data) {
          var _a5;
          var size3 = _this.size;
          var xValue = data[xField];
          var stackHeight = size3 * 2 / height;
          if (!cache3.has(xValue)) {
            cache3.set(xValue, stackHeight / 2);
          }
          var stackValue = cache3.get(xValue);
          cache3.set(xValue, stackValue + stackHeight);
          return __assign4(__assign4({}, data), (_a5 = {}, _a5[yField] = stackValue, _a5));
        });
      });
    };
    return Stack2;
  }(adjust_default);
  var stack_default = Stack;

  // node_modules/@antv/adjust/esm/adjusts/symmetric.js
  var Symmetric = function(_super) {
    __extends4(Symmetric2, _super);
    function Symmetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Symmetric2.prototype.process = function(groupDataArray) {
      var mergeData = flatten_default(groupDataArray);
      var _a4 = this, xField = _a4.xField, yField = _a4.yField;
      var cache3 = this.getXValuesMaxMap(mergeData);
      var max7 = Math.max.apply(Math, Object.keys(cache3).map(function(key) {
        return cache3[key];
      }));
      return map_default(groupDataArray, function(dataArray) {
        return map_default(dataArray, function(data) {
          var _a5, _b;
          var yValue = data[yField];
          var xValue = data[xField];
          if (is_array_default(yValue)) {
            var off_1 = (max7 - cache3[xValue]) / 2;
            return __assign4(__assign4({}, data), (_a5 = {}, _a5[yField] = map_default(yValue, function(y) {
              return off_1 + y;
            }), _a5));
          }
          var offset = (max7 - yValue) / 2;
          return __assign4(__assign4({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
        });
      });
    };
    Symmetric2.prototype.getXValuesMaxMap = function(mergeData) {
      var _this = this;
      var _a4 = this, xField = _a4.xField, yField = _a4.yField;
      var groupDataArray = group_by_default(mergeData, function(data) {
        return data[xField];
      });
      return map_values_default(groupDataArray, function(dataArray) {
        return _this.getDimMaxValue(dataArray, yField);
      });
    };
    Symmetric2.prototype.getDimMaxValue = function(mergeData, dim) {
      var dimValues = map_default(mergeData, function(data) {
        return get_default(data, dim, []);
      });
      var flattenValues = flatten_default(dimValues);
      return Math.max.apply(Math, flattenValues);
    };
    return Symmetric2;
  }(adjust_default);
  var symmetric_default = Symmetric;

  // node_modules/@antv/adjust/esm/index.js
  registerAdjust("Dodge", dodge_default);
  registerAdjust("Jitter", jitter_default);
  registerAdjust("Stack", stack_default);
  registerAdjust("Symmetric", symmetric_default);

  // node_modules/@antv/attr/esm/attributes/base.js
  var toScaleString = function(scale5, value) {
    if (is_string_default(value)) {
      return value;
    }
    return scale5.invert(scale5.scale(value));
  };
  var Attribute = function() {
    function Attribute2(cfg) {
      this.names = [];
      this.scales = [];
      this.linear = false;
      this.values = [];
      this.callback = function() {
        return [];
      };
      this._parseCfg(cfg);
    }
    Attribute2.prototype.mapping = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      var values2 = params.map(function(param, idx) {
        return _this._toOriginParam(param, _this.scales[idx]);
      });
      return this.callback.apply(this, values2);
    };
    Attribute2.prototype.getLinearValue = function(percent) {
      var steps = this.values.length - 1;
      var step4 = Math.floor(steps * percent);
      var leftPercent = steps * percent - step4;
      var start = this.values[step4];
      var end = step4 === steps ? start : this.values[step4 + 1];
      return start + (end - start) * leftPercent;
    };
    Attribute2.prototype.getNames = function() {
      var scales = this.scales;
      var names = this.names;
      var length3 = Math.min(scales.length, names.length);
      var rst = [];
      for (var i = 0; i < length3; i += 1) {
        rst.push(names[i]);
      }
      return rst;
    };
    Attribute2.prototype.getFields = function() {
      return this.scales.map(function(scale5) {
        return scale5.field;
      });
    };
    Attribute2.prototype.getScale = function(name) {
      return this.scales[this.names.indexOf(name)];
    };
    Attribute2.prototype.defaultCallback = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 0) {
        return this.values;
      }
      return params.map(function(param, idx) {
        var scale5 = _this.scales[idx];
        return scale5.type === "identity" ? scale5.values[0] : _this._getAttributeValue(scale5, param);
      });
    };
    Attribute2.prototype._parseCfg = function(cfg) {
      var _this = this;
      var _a4 = cfg.type, type = _a4 === void 0 ? "base" : _a4, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values2 = _d === void 0 ? [] : _d, callback = cfg.callback;
      this.type = type;
      this.scales = scales;
      this.values = values2;
      this.names = names;
      this.callback = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        if (callback) {
          var ret = callback.apply(void 0, params);
          if (!is_nil_default(ret)) {
            return [ret];
          }
        }
        return _this.defaultCallback.apply(_this, params);
      };
    };
    Attribute2.prototype._getAttributeValue = function(scale5, value) {
      if (scale5.isCategory && !this.linear) {
        var idx = scale5.translate(value);
        return this.values[idx % this.values.length];
      }
      var percent = scale5.scale(value);
      return this.getLinearValue(percent);
    };
    Attribute2.prototype._toOriginParam = function(param, scale5) {
      return !scale5.isLinear ? is_array_default(param) ? param.map(function(p3) {
        return toScaleString(scale5, p3);
      }) : toScaleString(scale5, param) : param;
    };
    return Attribute2;
  }();
  var base_default3 = Attribute;

  // node_modules/@antv/attr/node_modules/tslib/modules/index.js
  var import_tslib17 = __toModule(require_tslib5());
  var {
    __extends: __extends5,
    __assign: __assign5,
    __rest: __rest5,
    __decorate: __decorate5,
    __param: __param5,
    __metadata: __metadata5,
    __awaiter: __awaiter5,
    __generator: __generator5,
    __exportStar: __exportStar5,
    __createBinding: __createBinding5,
    __values: __values5,
    __read: __read5,
    __spread: __spread5,
    __spreadArrays: __spreadArrays5,
    __await: __await5,
    __asyncGenerator: __asyncGenerator5,
    __asyncDelegator: __asyncDelegator5,
    __asyncValues: __asyncValues5,
    __makeTemplateObject: __makeTemplateObject5,
    __importStar: __importStar5,
    __importDefault: __importDefault5,
    __classPrivateFieldGet: __classPrivateFieldGet5,
    __classPrivateFieldSet: __classPrivateFieldSet5
  } = import_tslib17.default;

  // node_modules/@antv/color-util/esm/index.js
  var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
  var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  var isGradientColor2 = function(val) {
    return /^[r,R,L,l]{1}[\s]*\(/.test(val);
  };
  var createTmp = function() {
    var i = document.createElement("i");
    i.title = "Web Colour Picker";
    i.style.display = "none";
    document.body.appendChild(i);
    return i;
  };
  var getValue = function(start, end, percent, index) {
    return start[index] + (end[index] - start[index]) * percent;
  };
  function arr2rgb(arr) {
    return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
  }
  var rgb2arr = function(str4) {
    return [
      parseInt(str4.substr(1, 2), 16),
      parseInt(str4.substr(3, 2), 16),
      parseInt(str4.substr(5, 2), 16)
    ];
  };
  var toHex = function(value) {
    var x16Value = Math.round(value).toString(16);
    return x16Value.length === 1 ? "0" + x16Value : x16Value;
  };
  var calColor = function(points, percent) {
    var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
    var steps = points.length - 1;
    var step4 = Math.floor(steps * fixedPercent);
    var left = steps * fixedPercent - step4;
    var start = points[step4];
    var end = step4 === steps ? start : points[step4 + 1];
    return arr2rgb([
      getValue(start, end, left, 0),
      getValue(start, end, left, 1),
      getValue(start, end, left, 2)
    ]);
  };
  var iEl;
  var toRGB = function(color2) {
    if (color2[0] === "#" && color2.length === 7) {
      return color2;
    }
    if (!iEl) {
      iEl = createTmp();
    }
    iEl.style.color = color2;
    var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
    var matches = RGB_REG.exec(rst);
    var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
      return Number(s);
    });
    rst = arr2rgb(cArray);
    return rst;
  };
  var gradient = function(colors) {
    var colorArray = is_string_default(colors) ? colors.split("-") : colors;
    var points = map_default(colorArray, function(color2) {
      return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
    });
    return function(percent) {
      return calColor(points, percent);
    };
  };
  var toCSSGradient = function(gradientColor) {
    if (isGradientColor2(gradientColor)) {
      var cssColor_1;
      var steps = void 0;
      if (gradientColor[0] === "l") {
        var arr = regexLG.exec(gradientColor);
        var angle3 = +arr[1] + 90;
        steps = arr[2];
        cssColor_1 = "linear-gradient(" + angle3 + "deg, ";
      } else if (gradientColor[0] === "r") {
        cssColor_1 = "radial-gradient(";
        var arr = regexRG.exec(gradientColor);
        steps = arr[4];
      }
      var colorStops_1 = steps.match(regexColorStop);
      each_default(colorStops_1, function(item, index) {
        var itemArr = item.split(":");
        cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
        if (index !== colorStops_1.length - 1) {
          cssColor_1 += ", ";
        }
      });
      cssColor_1 += ")";
      return cssColor_1;
    }
    return gradientColor;
  };
  var esm_default2 = {
    rgb2arr,
    gradient,
    toRGB: memoize_default(toRGB),
    toCSSGradient
  };

  // node_modules/@antv/attr/esm/attributes/color.js
  var Color2 = function(_super) {
    __extends5(Color3, _super);
    function Color3(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "color";
      _this.names = ["color"];
      if (is_string_default(_this.values)) {
        _this.linear = true;
      }
      _this.gradient = esm_default2.gradient(_this.values);
      return _this;
    }
    Color3.prototype.getLinearValue = function(percent) {
      return this.gradient(percent);
    };
    return Color3;
  }(base_default3);
  var color_default = Color2;

  // node_modules/@antv/attr/esm/attributes/opacity.js
  var Opacity = function(_super) {
    __extends5(Opacity2, _super);
    function Opacity2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "opacity";
      _this.names = ["opacity"];
      return _this;
    }
    return Opacity2;
  }(base_default3);
  var opacity_default = Opacity;

  // node_modules/@antv/attr/esm/attributes/position.js
  var Position = function(_super) {
    __extends5(Position2, _super);
    function Position2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.names = ["x", "y"];
      _this.type = "position";
      return _this;
    }
    Position2.prototype.mapping = function(x, y) {
      var _a4 = this.scales, scaleX = _a4[0], scaleY = _a4[1];
      if (is_nil_default(x) || is_nil_default(y)) {
        return [];
      }
      return [
        is_array_default(x) ? x.map(function(xi) {
          return scaleX.scale(xi);
        }) : scaleX.scale(x),
        is_array_default(y) ? y.map(function(yi) {
          return scaleY.scale(yi);
        }) : scaleY.scale(y)
      ];
    };
    return Position2;
  }(base_default3);
  var position_default = Position;

  // node_modules/@antv/attr/esm/attributes/shape.js
  var Shape = function(_super) {
    __extends5(Shape2, _super);
    function Shape2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "shape";
      _this.names = ["shape"];
      return _this;
    }
    Shape2.prototype.getLinearValue = function(percent) {
      var idx = Math.round((this.values.length - 1) * percent);
      return this.values[idx];
    };
    return Shape2;
  }(base_default3);
  var shape_default2 = Shape;

  // node_modules/@antv/attr/esm/attributes/size.js
  var Size = function(_super) {
    __extends5(Size2, _super);
    function Size2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "size";
      _this.names = ["size"];
      return _this;
    }
    return Size2;
  }(base_default3);
  var size_default = Size;

  // node_modules/@antv/scale/esm/tick-method/register.js
  var methodCache = {};
  function getTickMethod(key) {
    return methodCache[key];
  }
  function registerTickMethod(key, method) {
    methodCache[key] = method;
  }

  // node_modules/@antv/scale/esm/base.js
  var Scale = function() {
    function Scale2(cfg) {
      this.type = "base";
      this.isCategory = false;
      this.isLinear = false;
      this.isContinuous = false;
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    Scale2.prototype.translate = function(v) {
      return v;
    };
    Scale2.prototype.change = function(cfg) {
      mix(this.__cfg__, cfg);
      this.init();
    };
    Scale2.prototype.clone = function() {
      return this.constructor(this.__cfg__);
    };
    Scale2.prototype.getTicks = function() {
      var _this = this;
      return map_default(this.ticks, function(tick2, idx) {
        if (is_object_default(tick2)) {
          return tick2;
        }
        return {
          text: _this.getText(tick2, idx),
          tickValue: tick2,
          value: _this.scale(tick2)
        };
      });
    };
    Scale2.prototype.getText = function(value, key) {
      var formatter = this.formatter;
      var res = formatter ? formatter(value, key) : value;
      if (is_nil_default(res) || !is_function_default(res.toString)) {
        return "";
      }
      return res.toString();
    };
    Scale2.prototype.getConfig = function(key) {
      return this.__cfg__[key];
    };
    Scale2.prototype.init = function() {
      mix(this, this.__cfg__);
      this.setDomain();
      if (is_empty_default(this.getConfig("ticks"))) {
        this.ticks = this.calculateTicks();
      }
    };
    Scale2.prototype.initCfg = function() {
    };
    Scale2.prototype.setDomain = function() {
    };
    Scale2.prototype.calculateTicks = function() {
      var tickMethod = this.tickMethod;
      var ticks = [];
      if (is_string_default(tickMethod)) {
        var method = getTickMethod(tickMethod);
        if (!method) {
          throw new Error("There is no method to to calculate ticks!");
        }
        ticks = method(this);
      } else if (is_function_default(tickMethod)) {
        ticks = tickMethod(this);
      }
      return ticks;
    };
    Scale2.prototype.rangeMin = function() {
      return this.range[0];
    };
    Scale2.prototype.rangeMax = function() {
      return this.range[1];
    };
    Scale2.prototype.calcPercent = function(value, min7, max7) {
      if (is_number_default(value)) {
        return (value - min7) / (max7 - min7);
      }
      return NaN;
    };
    Scale2.prototype.calcValue = function(percent, min7, max7) {
      return min7 + percent * (max7 - min7);
    };
    return Scale2;
  }();
  var base_default4 = Scale;

  // node_modules/@antv/scale/esm/category/base.js
  var Category = function(_super) {
    __extends(Category3, _super);
    function Category3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cat";
      _this.isCategory = true;
      return _this;
    }
    Category3.prototype.buildIndexMap = function() {
      if (!this.translateIndexMap) {
        this.translateIndexMap = new Map();
        for (var i = 0; i < this.values.length; i++) {
          this.translateIndexMap.set(this.values[i], i);
        }
      }
    };
    Category3.prototype.translate = function(value) {
      this.buildIndexMap();
      var idx = this.translateIndexMap.get(value);
      if (idx === void 0) {
        idx = is_number_default(value) ? value : NaN;
      }
      return idx;
    };
    Category3.prototype.scale = function(value) {
      var order = this.translate(value);
      var percent = this.calcPercent(order, this.min, this.max);
      return this.calcValue(percent, this.rangeMin(), this.rangeMax());
    };
    Category3.prototype.invert = function(scaledValue) {
      var domainRange = this.max - this.min;
      var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
      var idx = Math.round(domainRange * percent) + this.min;
      if (idx < this.min || idx > this.max) {
        return NaN;
      }
      return this.values[idx];
    };
    Category3.prototype.getText = function(value) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var v = value;
      if (is_number_default(value) && !this.values.includes(value)) {
        v = this.values[v];
      }
      return _super.prototype.getText.apply(this, __spreadArray([v], args, false));
    };
    Category3.prototype.initCfg = function() {
      this.tickMethod = "cat";
    };
    Category3.prototype.setDomain = function() {
      if (is_nil_default(this.getConfig("min"))) {
        this.min = 0;
      }
      if (is_nil_default(this.getConfig("max"))) {
        var size3 = this.values.length;
        this.max = size3 > 1 ? size3 - 1 : size3;
      }
      if (this.translateIndexMap) {
        this.translateIndexMap = void 0;
      }
    };
    return Category3;
  }(base_default4);
  var base_default5 = Category;

  // node_modules/fecha/lib/fecha.js
  var fecha_exports = {};
  __export(fecha_exports, {
    assign: () => assign,
    default: () => fecha_default,
    defaultI18n: () => defaultI18n,
    format: () => format,
    parse: () => parse,
    setGlobalDateI18n: () => setGlobalDateI18n,
    setGlobalDateMasks: () => setGlobalDateMasks
  });
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigitsOptional = "[1-9]\\d?";
  var twoDigits = "\\d\\d";
  var threeDigits = "\\d{3}";
  var fourDigits = "\\d{4}";
  var word = "[^\\s]+";
  var literal = /\[([^]*?)\]/gm;
  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len3 = arr.length; i < len3; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }
  var monthUpdate = function(arrName) {
    return function(v, i18n) {
      var lowerCaseArr = i18n[arrName].map(function(v2) {
        return v2.toLowerCase();
      });
      var index = lowerCaseArr.indexOf(v.toLowerCase());
      if (index > -1) {
        return index;
      }
      return null;
    };
  };
  function assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var _a4 = 0, args_1 = args; _a4 < args_1.length; _a4++) {
      var obj = args_1[_a4];
      for (var key in obj) {
        origObj[key] = obj[key];
      }
    }
    return origObj;
  }
  var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var defaultI18n = {
    dayNamesShort,
    dayNames,
    monthNamesShort,
    monthNames,
    amPm: ["am", "pm"],
    DoFn: function(dayOfMonth) {
      return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
    }
  };
  var globalI18n = assign({}, defaultI18n);
  var setGlobalDateI18n = function(i18n) {
    return globalI18n = assign(globalI18n, i18n);
  };
  var regexEscape = function(str4) {
    return str4.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
  };
  var pad = function(val, len3) {
    if (len3 === void 0) {
      len3 = 2;
    }
    val = String(val);
    while (val.length < len3) {
      val = "0" + val;
    }
    return val;
  };
  var formatFlags = {
    D: function(dateObj) {
      return String(dateObj.getDate());
    },
    DD: function(dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return String(dateObj.getDay());
    },
    dd: function(dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return String(dateObj.getMonth() + 1);
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function(dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return String(dateObj.getHours() % 12 || 12);
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return String(dateObj.getHours());
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return String(dateObj.getMinutes());
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return String(dateObj.getSeconds());
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var offset = dateObj.getTimezoneOffset();
      return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
    },
    Z: function(dateObj) {
      var offset = dateObj.getTimezoneOffset();
      return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
    }
  };
  var monthParse = function(v) {
    return +v - 1;
  };
  var emptyDigits = [null, twoDigitsOptional];
  var emptyWord = [null, word];
  var amPm = [
    "isPm",
    word,
    function(v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        return 0;
      } else if (val === i18n.amPm[1]) {
        return 1;
      }
      return null;
    }
  ];
  var timezoneOffset = [
    "timezoneOffset",
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
    function(v) {
      var parts = (v + "").match(/([+-]|\d\d)/gi);
      if (parts) {
        var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
        return parts[0] === "+" ? minutes : -minutes;
      }
      return 0;
    }
  ];
  var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function(v) {
      return parseInt(v, 10);
    }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
      "year",
      twoDigits,
      function(v) {
        var now3 = new Date();
        var cent = +("" + now3.getFullYear()).substr(0, 2);
        return +("" + (+v > 68 ? cent - 1 : cent) + v);
      }
    ],
    h: ["hour", twoDigitsOptional, void 0, "isPm"],
    hh: ["hour", twoDigits, void 0, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\d", function(v) {
      return +v * 100;
    }],
    SS: ["millisecond", twoDigits, function(v) {
      return +v * 10;
    }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
  };
  var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
  };
  var setGlobalDateMasks = function(masks) {
    return assign(globalMasks, masks);
  };
  var format = function(dateObj, mask, i18n) {
    if (mask === void 0) {
      mask = globalMasks["default"];
    }
    if (i18n === void 0) {
      i18n = {};
    }
    if (typeof dateObj === "number") {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
      throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return "@@@";
    });
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    mask = mask.replace(token, function($0) {
      return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    return mask.replace(/@@@/g, function() {
      return literals.shift();
    });
  };
  function parse(dateStr, format2, i18n) {
    if (i18n === void 0) {
      i18n = {};
    }
    if (typeof format2 !== "string") {
      throw new Error("Invalid format in fecha parse");
    }
    format2 = globalMasks[format2] || format2;
    if (dateStr.length > 1e3) {
      return null;
    }
    var today = new Date();
    var dateInfo = {
      year: today.getFullYear(),
      month: 0,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
      isPm: null,
      timezoneOffset: null
    };
    var parseInfo = [];
    var literals = [];
    var newFormat = format2.replace(literal, function($0, $1) {
      literals.push(regexEscape($1));
      return "@@@";
    });
    var specifiedFields = {};
    var requiredFields = {};
    newFormat = regexEscape(newFormat).replace(token, function($0) {
      var info = parseFlags[$0];
      var field2 = info[0], regex = info[1], requiredField = info[3];
      if (specifiedFields[field2]) {
        throw new Error("Invalid format. " + field2 + " specified twice in format");
      }
      specifiedFields[field2] = true;
      if (requiredField) {
        requiredFields[requiredField] = true;
      }
      parseInfo.push(info);
      return "(" + regex + ")";
    });
    Object.keys(requiredFields).forEach(function(field2) {
      if (!specifiedFields[field2]) {
        throw new Error("Invalid format. " + field2 + " is required in specified format");
      }
    });
    newFormat = newFormat.replace(/@@@/g, function() {
      return literals.shift();
    });
    var matches = dateStr.match(new RegExp(newFormat, "i"));
    if (!matches) {
      return null;
    }
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    for (var i = 1; i < matches.length; i++) {
      var _a4 = parseInfo[i - 1], field = _a4[0], parser = _a4[2];
      var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
      if (value == null) {
        return null;
      }
      dateInfo[field] = value;
    }
    if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }
    var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i = 0, len3 = validateFields.length; i < len3; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()) {
        return null;
      }
    }
    if (dateInfo.timezoneOffset == null) {
      return dateWithoutTZ;
    }
    return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
  }
  var fecha = {
    format,
    parse,
    defaultI18n,
    setGlobalDateI18n,
    setGlobalDateMasks
  };
  var fecha_default = fecha;

  // node_modules/@antv/scale/esm/util/bisector.js
  function bisector_default(getter) {
    return function(a, x, _lo, _hi) {
      var lo = is_nil_default(_lo) ? 0 : _lo;
      var hi = is_nil_default(_hi) ? a.length : _hi;
      while (lo < hi) {
        var mid2 = lo + hi >>> 1;
        if (getter(a[mid2]) > x) {
          hi = mid2;
        } else {
          lo = mid2 + 1;
        }
      }
      return lo;
    };
  }

  // node_modules/@antv/scale/esm/util/time.js
  var FORMAT_METHOD = "format";
  function timeFormat(time, mask) {
    var method = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
    return method(time, mask);
  }
  function toTimeStamp(value) {
    if (is_string_default(value)) {
      if (value.indexOf("T") > 0) {
        value = new Date(value).getTime();
      } else {
        value = new Date(value.replace(/-/gi, "/")).getTime();
      }
    }
    if (is_date_default(value)) {
      value = value.getTime();
    }
    return value;
  }
  var SECOND = 1e3;
  var MINUTE = 60 * SECOND;
  var HOUR = 60 * MINUTE;
  var DAY = 24 * HOUR;
  var MONTH = DAY * 31;
  var YEAR = DAY * 365;
  var intervals = [
    ["HH:mm:ss", SECOND],
    ["HH:mm:ss", SECOND * 10],
    ["HH:mm:ss", SECOND * 30],
    ["HH:mm", MINUTE],
    ["HH:mm", MINUTE * 10],
    ["HH:mm", MINUTE * 30],
    ["HH", HOUR],
    ["HH", HOUR * 6],
    ["HH", HOUR * 12],
    ["YYYY-MM-DD", DAY],
    ["YYYY-MM-DD", DAY * 4],
    ["YYYY-WW", DAY * 7],
    ["YYYY-MM", MONTH],
    ["YYYY-MM", MONTH * 4],
    ["YYYY-MM", MONTH * 6],
    ["YYYY", DAY * 380]
  ];
  function getTickInterval(min7, max7, tickCount) {
    var target = (max7 - min7) / tickCount;
    var idx = bisector_default(function(o) {
      return o[1];
    })(intervals, target) - 1;
    var interval2 = intervals[idx];
    if (idx < 0) {
      interval2 = intervals[0];
    } else if (idx >= intervals.length) {
      interval2 = last(intervals);
    }
    return interval2;
  }

  // node_modules/@antv/scale/esm/category/time.js
  var TimeCat = function(_super) {
    __extends(TimeCat2, _super);
    function TimeCat2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "timeCat";
      return _this;
    }
    TimeCat2.prototype.translate = function(value) {
      value = toTimeStamp(value);
      var index = this.values.indexOf(value);
      if (index === -1) {
        if (is_number_default(value) && value < this.values.length) {
          index = value;
        } else {
          index = NaN;
        }
      }
      return index;
    };
    TimeCat2.prototype.getText = function(value, tickIndex) {
      var index = this.translate(value);
      if (index > -1) {
        var result = this.values[index];
        var formatter = this.formatter;
        result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
        return result;
      }
      return value;
    };
    TimeCat2.prototype.initCfg = function() {
      this.tickMethod = "time-cat";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
    };
    TimeCat2.prototype.setDomain = function() {
      var values2 = this.values;
      each_default(values2, function(v, i) {
        values2[i] = toTimeStamp(v);
      });
      values2.sort(function(v1, v2) {
        return v1 - v2;
      });
      _super.prototype.setDomain.call(this);
    };
    return TimeCat2;
  }(base_default5);
  var time_default = TimeCat;

  // node_modules/@antv/scale/esm/continuous/base.js
  var Continuous = function(_super) {
    __extends(Continuous2, _super);
    function Continuous2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isContinuous = true;
      return _this;
    }
    Continuous2.prototype.scale = function(value) {
      if (is_nil_default(value)) {
        return NaN;
      }
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var max7 = this.max;
      var min7 = this.min;
      if (max7 === min7) {
        return rangeMin;
      }
      var percent = this.getScalePercent(value);
      return rangeMin + percent * (rangeMax - rangeMin);
    };
    Continuous2.prototype.init = function() {
      _super.prototype.init.call(this);
      var ticks = this.ticks;
      var firstTick = head(ticks);
      var lastTick = last(ticks);
      if (firstTick < this.min) {
        this.min = firstTick;
      }
      if (lastTick > this.max) {
        this.max = lastTick;
      }
      if (!is_nil_default(this.minLimit)) {
        this.min = firstTick;
      }
      if (!is_nil_default(this.maxLimit)) {
        this.max = lastTick;
      }
    };
    Continuous2.prototype.setDomain = function() {
      var _a4 = get_range_default(this.values), min7 = _a4.min, max7 = _a4.max;
      if (is_nil_default(this.min)) {
        this.min = min7;
      }
      if (is_nil_default(this.max)) {
        this.max = max7;
      }
      if (this.min > this.max) {
        this.min = min7;
        this.max = max7;
      }
    };
    Continuous2.prototype.calculateTicks = function() {
      var _this = this;
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        ticks = filter_default(ticks, function(tick2) {
          return tick2 >= _this.min && tick2 <= _this.max;
        });
      }
      return ticks;
    };
    Continuous2.prototype.getScalePercent = function(value) {
      var max7 = this.max;
      var min7 = this.min;
      return (value - min7) / (max7 - min7);
    };
    Continuous2.prototype.getInvertPercent = function(value) {
      return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous2;
  }(base_default4);
  var base_default6 = Continuous;

  // node_modules/@antv/scale/esm/continuous/linear.js
  var Linear = function(_super) {
    __extends(Linear3, _super);
    function Linear3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "linear";
      _this.isLinear = true;
      return _this;
    }
    Linear3.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      return this.min + percent * (this.max - this.min);
    };
    Linear3.prototype.initCfg = function() {
      this.tickMethod = "wilkinson-extended";
      this.nice = false;
    };
    return Linear3;
  }(base_default6);
  var linear_default = Linear;

  // node_modules/@antv/scale/esm/util/math.js
  function calBase(a, b) {
    var e = Math.E;
    var value;
    if (b >= 0) {
      value = Math.pow(e, Math.log(b) / a);
    } else {
      value = Math.pow(e, Math.log(-b) / a) * -1;
    }
    return value;
  }
  function log(a, b) {
    if (a === 1) {
      return 1;
    }
    return Math.log(b) / Math.log(a);
  }
  function getLogPositiveMin(values2, base2, max7) {
    if (is_nil_default(max7)) {
      max7 = Math.max.apply(null, values2);
    }
    var positiveMin = max7;
    each_default(values2, function(value) {
      if (value > 0 && value < positiveMin) {
        positiveMin = value;
      }
    });
    if (positiveMin === max7) {
      positiveMin = max7 / base2;
    }
    if (positiveMin > 1) {
      positiveMin = 1;
    }
    return positiveMin;
  }

  // node_modules/@antv/scale/esm/continuous/log.js
  var Log = function(_super) {
    __extends(Log3, _super);
    function Log3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      return _this;
    }
    Log3.prototype.invert = function(value) {
      var base2 = this.base;
      var max7 = log(base2, this.max);
      var rangeMin = this.rangeMin();
      var range5 = this.rangeMax() - rangeMin;
      var min7;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        if (value === 0) {
          return 0;
        }
        min7 = log(base2, positiveMin / base2);
        var appendPercent = 1 / (max7 - min7) * range5;
        if (value < appendPercent) {
          return value / appendPercent * positiveMin;
        }
      } else {
        min7 = log(base2, this.min);
      }
      var percent = (value - rangeMin) / range5;
      var tmp = percent * (max7 - min7) + min7;
      return Math.pow(base2, tmp);
    };
    Log3.prototype.initCfg = function() {
      this.tickMethod = "log";
      this.base = 10;
      this.tickCount = 6;
      this.nice = true;
    };
    Log3.prototype.setDomain = function() {
      _super.prototype.setDomain.call(this);
      var min7 = this.min;
      if (min7 < 0) {
        throw new Error("When you use log scale, the minimum value must be greater than zero!");
      }
      if (min7 === 0) {
        this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
      }
    };
    Log3.prototype.getScalePercent = function(value) {
      var max7 = this.max;
      var min7 = this.min;
      if (max7 === min7) {
        return 0;
      }
      if (value <= 0) {
        return 0;
      }
      var base2 = this.base;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        min7 = positiveMin * 1 / base2;
      }
      var percent;
      if (value < positiveMin) {
        percent = value / positiveMin / (log(base2, max7) - log(base2, min7));
      } else {
        percent = (log(base2, value) - log(base2, min7)) / (log(base2, max7) - log(base2, min7));
      }
      return percent;
    };
    return Log3;
  }(base_default6);
  var log_default = Log;

  // node_modules/@antv/scale/esm/continuous/pow.js
  var Pow = function(_super) {
    __extends(Pow3, _super);
    function Pow3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pow";
      return _this;
    }
    Pow3.prototype.invert = function(value) {
      var percent = this.getInvertPercent(value);
      var exponent3 = this.exponent;
      var max7 = calBase(exponent3, this.max);
      var min7 = calBase(exponent3, this.min);
      var tmp = percent * (max7 - min7) + min7;
      var factor = tmp >= 0 ? 1 : -1;
      return Math.pow(tmp, exponent3) * factor;
    };
    Pow3.prototype.initCfg = function() {
      this.tickMethod = "pow";
      this.exponent = 2;
      this.tickCount = 5;
      this.nice = true;
    };
    Pow3.prototype.getScalePercent = function(value) {
      var max7 = this.max;
      var min7 = this.min;
      if (max7 === min7) {
        return 0;
      }
      var exponent3 = this.exponent;
      var percent = (calBase(exponent3, value) - calBase(exponent3, min7)) / (calBase(exponent3, max7) - calBase(exponent3, min7));
      return percent;
    };
    return Pow3;
  }(base_default6);
  var pow_default = Pow;

  // node_modules/@antv/scale/esm/continuous/time.js
  var Time = function(_super) {
    __extends(Time2, _super);
    function Time2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "time";
      return _this;
    }
    Time2.prototype.getText = function(value, index) {
      var numberValue = this.translate(value);
      var formatter = this.formatter;
      return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
    };
    Time2.prototype.scale = function(value) {
      var v = value;
      if (is_string_default(v) || is_date_default(v)) {
        v = this.translate(v);
      }
      return _super.prototype.scale.call(this, v);
    };
    Time2.prototype.translate = function(v) {
      return toTimeStamp(v);
    };
    Time2.prototype.initCfg = function() {
      this.tickMethod = "time-pretty";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
      this.nice = false;
    };
    Time2.prototype.setDomain = function() {
      var values2 = this.values;
      var minConfig3 = this.getConfig("min");
      var maxConfig3 = this.getConfig("max");
      if (!is_nil_default(minConfig3) || !is_number_default(minConfig3)) {
        this.min = this.translate(this.min);
      }
      if (!is_nil_default(maxConfig3) || !is_number_default(maxConfig3)) {
        this.max = this.translate(this.max);
      }
      if (values2 && values2.length) {
        var timeStamps_1 = [];
        var min_1 = Infinity;
        var secondMin_1 = min_1;
        var max_1 = 0;
        each_default(values2, function(v) {
          var timeStamp = toTimeStamp(v);
          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: " + v + " in time scale!");
          }
          if (min_1 > timeStamp) {
            secondMin_1 = min_1;
            min_1 = timeStamp;
          } else if (secondMin_1 > timeStamp) {
            secondMin_1 = timeStamp;
          }
          if (max_1 < timeStamp) {
            max_1 = timeStamp;
          }
          timeStamps_1.push(timeStamp);
        });
        if (values2.length > 1) {
          this.minTickInterval = secondMin_1 - min_1;
        }
        if (is_nil_default(minConfig3)) {
          this.min = min_1;
        }
        if (is_nil_default(maxConfig3)) {
          this.max = max_1;
        }
      }
    };
    return Time2;
  }(linear_default);
  var time_default2 = Time;

  // node_modules/@antv/scale/esm/continuous/quantize.js
  var Quantize = function(_super) {
    __extends(Quantize2, _super);
    function Quantize2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantize";
      return _this;
    }
    Quantize2.prototype.invert = function(value) {
      var ticks = this.ticks;
      var length3 = ticks.length;
      var percent = this.getInvertPercent(value);
      var minIndex = Math.floor(percent * (length3 - 1));
      if (minIndex >= length3 - 1) {
        return last(ticks);
      }
      if (minIndex < 0) {
        return head(ticks);
      }
      var minTick = ticks[minIndex];
      var nextTick2 = ticks[minIndex + 1];
      var minIndexPercent = minIndex / (length3 - 1);
      var maxIndexPercent = (minIndex + 1) / (length3 - 1);
      return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick2 - minTick);
    };
    Quantize2.prototype.initCfg = function() {
      this.tickMethod = "r-pretty";
      this.tickCount = 5;
      this.nice = true;
    };
    Quantize2.prototype.calculateTicks = function() {
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        if (last(ticks) !== this.max) {
          ticks.push(this.max);
        }
        if (head(ticks) !== this.min) {
          ticks.unshift(this.min);
        }
      }
      return ticks;
    };
    Quantize2.prototype.getScalePercent = function(value) {
      var ticks = this.ticks;
      if (value < head(ticks)) {
        return 0;
      }
      if (value > last(ticks)) {
        return 1;
      }
      var minIndex = 0;
      each_default(ticks, function(tick2, index) {
        if (value >= tick2) {
          minIndex = index;
        } else {
          return false;
        }
      });
      return minIndex / (ticks.length - 1);
    };
    return Quantize2;
  }(base_default6);
  var quantize_default = Quantize;

  // node_modules/@antv/scale/esm/continuous/quantile.js
  var Quantile = function(_super) {
    __extends(Quantile2, _super);
    function Quantile2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantile";
      return _this;
    }
    Quantile2.prototype.initCfg = function() {
      this.tickMethod = "quantile";
      this.tickCount = 5;
      this.nice = true;
    };
    return Quantile2;
  }(quantize_default);
  var quantile_default = Quantile;

  // node_modules/@antv/scale/esm/factory.js
  var map4 = {};
  function getClass(key) {
    return map4[key];
  }
  function registerClass(key, cls) {
    if (getClass(key)) {
      throw new Error("type '" + key + "' existed.");
    }
    map4[key] = cls;
  }

  // node_modules/@antv/scale/esm/identity/index.js
  var Identity = function(_super) {
    __extends(Identity4, _super);
    function Identity4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "identity";
      _this.isIdentity = true;
      return _this;
    }
    Identity4.prototype.calculateTicks = function() {
      return this.values;
    };
    Identity4.prototype.scale = function(value) {
      if (this.values[0] !== value && is_number_default(value)) {
        return value;
      }
      return this.range[0];
    };
    Identity4.prototype.invert = function(value) {
      var range5 = this.range;
      if (value < range5[0] || value > range5[1]) {
        return NaN;
      }
      return this.values[0];
    };
    return Identity4;
  }(base_default4);
  var identity_default2 = Identity;

  // node_modules/@antv/scale/esm/util/pretty-number.js
  function prettyNumber(n) {
    return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
  }

  // node_modules/@antv/scale/esm/util/extended.js
  var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
  var eps = Number.EPSILON * 100;
  function mod2(n, m) {
    return (n % m + m) % m;
  }
  function round3(n) {
    return Math.round(n * 1e12) / 1e12;
  }
  function simplicity(q, Q, j, lmin, lmax, lstep) {
    var n = size2(Q);
    var i = index_of_default(Q, q);
    var v = 0;
    var m = mod2(lmin, lstep);
    if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
      v = 1;
    }
    return 1 - i / (n - 1) - j + v;
  }
  function simplicityMax(q, Q, j) {
    var n = size2(Q);
    var i = index_of_default(Q, q);
    var v = 1;
    return 1 - i / (n - 1) - j + v;
  }
  function density(k, m, dMin, dMax, lMin, lMax) {
    var r = (k - 1) / (lMax - lMin);
    var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
    return 2 - Math.max(r / rt, rt / r);
  }
  function densityMax(k, m) {
    if (k >= m) {
      return 2 - (k - 1) / (m - 1);
    }
    return 1;
  }
  function coverage(dMin, dMax, lMin, lMax) {
    var range5 = dMax - dMin;
    return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range5, 2);
  }
  function coverageMax(dMin, dMax, span) {
    var range5 = dMax - dMin;
    if (span > range5) {
      var half = (span - range5) / 2;
      return 1 - Math.pow(half, 2) / Math.pow(0.1 * range5, 2);
    }
    return 1;
  }
  function legibility() {
    return 1;
  }
  function extended(dMin, dMax, n, onlyLoose, Q, w) {
    if (n === void 0) {
      n = 5;
    }
    if (onlyLoose === void 0) {
      onlyLoose = true;
    }
    if (Q === void 0) {
      Q = DEFAULT_Q;
    }
    if (w === void 0) {
      w = [0.25, 0.2, 0.5, 0.05];
    }
    var m = n < 0 ? 0 : Math.round(n);
    if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
      return {
        min: 0,
        max: 0,
        ticks: []
      };
    }
    if (dMax - dMin < 1e-15 || m === 1) {
      return {
        min: dMin,
        max: dMax,
        ticks: [dMin]
      };
    }
    var best = {
      score: -2,
      lmin: 0,
      lmax: 0,
      lstep: 0
    };
    var j = 1;
    while (j < Infinity) {
      for (var i = 0; i < Q.length; i += 1) {
        var q = Q[i];
        var sm = simplicityMax(q, Q, j);
        if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
          j = Infinity;
          break;
        }
        var k = 2;
        while (k < Infinity) {
          var dm = densityMax(k, m);
          if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
            break;
          }
          var delta = (dMax - dMin) / (k + 1) / j / q;
          var z = Math.ceil(Math.log10(delta));
          while (z < Infinity) {
            var step4 = j * q * Math.pow(10, z);
            var cm = coverageMax(dMin, dMax, step4 * (k - 1));
            if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
              break;
            }
            var minStart = Math.floor(dMax / step4) * j - (k - 1) * j;
            var maxStart = Math.ceil(dMin / step4) * j;
            if (minStart <= maxStart) {
              var count2 = maxStart - minStart;
              for (var i_1 = 0; i_1 <= count2; i_1 += 1) {
                var start = minStart + i_1;
                var lMin = start * (step4 / j);
                var lMax = lMin + step4 * (k - 1);
                var lStep = step4;
                var s = simplicity(q, Q, j, lMin, lMax, lStep);
                var c = coverage(dMin, dMax, lMin, lMax);
                var g = density(k, m, dMin, dMax, lMin, lMax);
                var l = legibility();
                var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
                if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                  best.lmin = lMin;
                  best.lmax = lMax;
                  best.lstep = lStep;
                  best.score = score;
                }
              }
            }
            z += 1;
          }
          k += 1;
        }
      }
      j += 1;
    }
    var lmax = prettyNumber(best.lmax);
    var lmin = prettyNumber(best.lmin);
    var lstep = prettyNumber(best.lstep);
    var tickCount = Math.floor(round3((lmax - lmin) / lstep)) + 1;
    var ticks = new Array(tickCount);
    ticks[0] = prettyNumber(lmin);
    for (var i = 1; i < tickCount; i++) {
      ticks[i] = prettyNumber(ticks[i - 1] + lstep);
    }
    return {
      min: Math.min(dMin, head(ticks)),
      max: Math.max(dMax, last(ticks)),
      ticks
    };
  }

  // node_modules/@antv/scale/esm/tick-method/cat.js
  function calculateCatTicks(cfg) {
    var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount;
    var ticks = values2;
    if (is_number_default(tickInterval)) {
      return filter_default(ticks, function(__, i) {
        return i % tickInterval === 0;
      });
    }
    var min7 = cfg.min, max7 = cfg.max;
    if (is_nil_default(min7)) {
      min7 = 0;
    }
    if (is_nil_default(max7)) {
      max7 = values2.length - 1;
    }
    if (is_number_default(tickCount) && tickCount < max7 - min7) {
      var ticks_1 = extended(min7, max7, tickCount, false, [1, 2, 5, 3, 4, 7, 6, 8, 9]).ticks;
      var valid = filter_default(ticks_1, function(tick2) {
        return tick2 >= min7 && tick2 <= max7;
      });
      return valid.map(function(index) {
        return values2[index];
      });
    }
    return values2.slice(min7, max7 + 1);
  }

  // node_modules/@antv/scale/esm/util/d3-linear.js
  function d3Linear(cfg) {
    var min7 = cfg.min, max7 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
    var linear4 = new D3Linear();
    linear4.domain([min7, max7]);
    if (nice) {
      linear4.nice(tickCount);
    }
    return linear4.ticks(tickCount);
  }
  var DEFAULT_COUNT = 5;
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  var D3Linear = function() {
    function D3Linear2() {
      this._domain = [0, 1];
    }
    D3Linear2.prototype.domain = function(domain) {
      if (domain) {
        this._domain = Array.from(domain, Number);
        return this;
      }
      return this._domain.slice();
    };
    D3Linear2.prototype.nice = function(count2) {
      var _a4, _b;
      if (count2 === void 0) {
        count2 = DEFAULT_COUNT;
      }
      var d = this._domain.slice();
      var i0 = 0;
      var i1 = this._domain.length - 1;
      var start = this._domain[i0];
      var stop2 = this._domain[i1];
      var step4;
      if (stop2 < start) {
        _a4 = [stop2, start], start = _a4[0], stop2 = _a4[1];
        _b = [i1, i0], i0 = _b[0], i1 = _b[1];
      }
      step4 = tickIncrement(start, stop2, count2);
      if (step4 > 0) {
        start = Math.floor(start / step4) * step4;
        stop2 = Math.ceil(stop2 / step4) * step4;
        step4 = tickIncrement(start, stop2, count2);
      } else if (step4 < 0) {
        start = Math.ceil(start * step4) / step4;
        stop2 = Math.floor(stop2 * step4) / step4;
        step4 = tickIncrement(start, stop2, count2);
      }
      if (step4 > 0) {
        d[i0] = Math.floor(start / step4) * step4;
        d[i1] = Math.ceil(stop2 / step4) * step4;
        this.domain(d);
      } else if (step4 < 0) {
        d[i0] = Math.ceil(start * step4) / step4;
        d[i1] = Math.floor(stop2 * step4) / step4;
        this.domain(d);
      }
      return this;
    };
    D3Linear2.prototype.ticks = function(count2) {
      if (count2 === void 0) {
        count2 = DEFAULT_COUNT;
      }
      return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count2 || DEFAULT_COUNT);
    };
    return D3Linear2;
  }();
  function d3ArrayTicks(start, stop2, count2) {
    var reverse4;
    var i = -1;
    var n;
    var ticks;
    var step4;
    stop2 = +stop2, start = +start, count2 = +count2;
    if (start === stop2 && count2 > 0) {
      return [start];
    }
    if (reverse4 = stop2 < start) {
      n = start, start = stop2, stop2 = n;
    }
    if ((step4 = tickIncrement(start, stop2, count2)) === 0 || !isFinite(step4)) {
      return [];
    }
    if (step4 > 0) {
      start = Math.ceil(start / step4);
      stop2 = Math.floor(stop2 / step4);
      ticks = new Array(n = Math.ceil(stop2 - start + 1));
      while (++i < n) {
        ticks[i] = (start + i) * step4;
      }
    } else {
      start = Math.floor(start * step4);
      stop2 = Math.ceil(stop2 * step4);
      ticks = new Array(n = Math.ceil(start - stop2 + 1));
      while (++i < n) {
        ticks[i] = (start - i) / step4;
      }
    }
    if (reverse4) {
      ticks.reverse();
    }
    return ticks;
  }
  function tickIncrement(start, stop2, count2) {
    var step4 = (stop2 - start) / Math.max(0, count2);
    var power = Math.floor(Math.log(step4) / Math.LN10);
    var error = step4 / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }

  // node_modules/@antv/scale/esm/util/interval.js
  function snapMultiple(v, base2, snapType) {
    var div5;
    if (snapType === "ceil") {
      div5 = Math.ceil(v / base2);
    } else if (snapType === "floor") {
      div5 = Math.floor(v / base2);
    } else {
      div5 = Math.round(v / base2);
    }
    return div5 * base2;
  }
  function intervalTicks(min7, max7, interval2) {
    var minTick = snapMultiple(min7, interval2, "floor");
    var maxTick = snapMultiple(max7, interval2, "ceil");
    minTick = fixed_base_default(minTick, interval2);
    maxTick = fixed_base_default(maxTick, interval2);
    var ticks = [];
    for (var i = minTick; i <= maxTick; i = i + interval2) {
      var tickValue = fixed_base_default(i, interval2);
      ticks.push(tickValue);
    }
    return {
      min: minTick,
      max: maxTick,
      ticks
    };
  }

  // node_modules/@antv/scale/esm/util/strict-limit.js
  function strictLimit(cfg, defaultMin, defaultMax) {
    var _a4;
    var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min7 = cfg.min, max7 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
    var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min7 : defaultMin : minLimit;
    var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max7 : defaultMax : maxLimit;
    if (tickMin > tickMax) {
      _a4 = [tickMin, tickMax], tickMax = _a4[0], tickMin = _a4[1];
    }
    if (tickCount <= 2) {
      return [tickMin, tickMax];
    }
    var step4 = (tickMax - tickMin) / (tickCount - 1);
    var ticks = [];
    for (var i = 0; i < tickCount; i++) {
      ticks.push(tickMin + step4 * i);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/d3-linear.js
  function d3LinearTickMethod(cfg) {
    var min7 = cfg.min, max7 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = d3Linear(cfg);
    if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
      return strictLimit(cfg, head(ticks), last(ticks));
    }
    if (tickInterval) {
      return intervalTicks(min7, max7, tickInterval).ticks;
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/linear.js
  function linear3(cfg) {
    var min7 = cfg.min, max7 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = extended(min7, max7, tickCount, nice).ticks;
    if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
      return strictLimit(cfg, head(ticks), last(ticks));
    }
    if (tickInterval) {
      return intervalTicks(min7, max7, tickInterval).ticks;
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/log.js
  function calculateLogTicks(cfg) {
    var base2 = cfg.base, tickCount = cfg.tickCount, min7 = cfg.min, max7 = cfg.max, values2 = cfg.values;
    var minTick;
    var maxTick = log(base2, max7);
    if (min7 > 0) {
      minTick = Math.floor(log(base2, min7));
    } else {
      var positiveMin = getLogPositiveMin(values2, base2, max7);
      minTick = Math.floor(log(base2, positiveMin));
    }
    var count2 = maxTick - minTick;
    var avg2 = Math.ceil(count2 / tickCount);
    var ticks = [];
    for (var i = minTick; i < maxTick + avg2; i = i + avg2) {
      ticks.push(Math.pow(base2, i));
    }
    if (min7 <= 0) {
      ticks.unshift(0);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/util/pretty.js
  function pretty(min7, max7, m) {
    if (m === void 0) {
      m = 5;
    }
    if (min7 === max7) {
      return {
        max: max7,
        min: min7,
        ticks: [min7]
      };
    }
    var n = m < 0 ? 0 : Math.round(m);
    if (n === 0)
      return { max: max7, min: min7, ticks: [] };
    var h2 = 1.5;
    var h5 = 0.5 + 1.5 * h2;
    var d = max7 - min7;
    var c = d / n;
    var base2 = Math.pow(10, Math.floor(Math.log10(c)));
    var unit = base2;
    if (2 * base2 - c < h2 * (c - unit)) {
      unit = 2 * base2;
      if (5 * base2 - c < h5 * (c - unit)) {
        unit = 5 * base2;
        if (10 * base2 - c < h2 * (c - unit)) {
          unit = 10 * base2;
        }
      }
    }
    var nu = Math.ceil(max7 / unit);
    var ns = Math.floor(min7 / unit);
    var hi = Math.max(nu * unit, max7);
    var lo = Math.min(ns * unit, min7);
    var size3 = Math.floor((hi - lo) / unit) + 1;
    var ticks = new Array(size3);
    for (var i = 0; i < size3; i++) {
      ticks[i] = prettyNumber(lo + i * unit);
    }
    return {
      min: lo,
      max: hi,
      ticks
    };
  }

  // node_modules/@antv/scale/esm/tick-method/pow.js
  function calculatePowTicks(cfg) {
    var exponent3 = cfg.exponent, tickCount = cfg.tickCount;
    var max7 = Math.ceil(calBase(exponent3, cfg.max));
    var min7 = Math.floor(calBase(exponent3, cfg.min));
    var ticks = pretty(min7, max7, tickCount).ticks;
    return ticks.map(function(tick2) {
      var factor = tick2 >= 0 ? 1 : -1;
      return Math.pow(tick2, exponent3) * factor;
    });
  }

  // node_modules/@antv/scale/esm/tick-method/quantile.js
  function quantileSorted(x, p3) {
    var idx = x.length * p3;
    if (p3 === 1) {
      return x[x.length - 1];
    } else if (p3 === 0) {
      return x[0];
    } else if (idx % 1 !== 0) {
      return x[Math.ceil(idx) - 1];
    } else if (x.length % 2 === 0) {
      return (x[idx - 1] + x[idx]) / 2;
    } else {
      return x[idx];
    }
  }
  function calculateTicks(cfg) {
    var tickCount = cfg.tickCount, values2 = cfg.values;
    if (!values2 || !values2.length) {
      return [];
    }
    var sorted = values2.slice().sort(function(a, b) {
      return a - b;
    });
    var ticks = [];
    for (var i = 0; i < tickCount; i++) {
      var p3 = i / (tickCount - 1);
      ticks.push(quantileSorted(sorted, p3));
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/r-prettry.js
  function linearPretty(cfg) {
    var min7 = cfg.min, max7 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
    var ticks = pretty(min7, max7, tickCount).ticks;
    if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
      return strictLimit(cfg, head(ticks), last(ticks));
    }
    if (tickInterval) {
      return intervalTicks(min7, max7, tickInterval).ticks;
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/time.js
  function calculateTimeTicks(cfg) {
    var min7 = cfg.min, max7 = cfg.max, minTickInterval = cfg.minTickInterval;
    var tickInterval = cfg.tickInterval;
    var tickCount = cfg.tickCount;
    if (tickInterval) {
      tickCount = Math.ceil((max7 - min7) / tickInterval);
    } else {
      tickInterval = getTickInterval(min7, max7, tickCount)[1];
      var count2 = (max7 - min7) / tickInterval;
      var ratio = count2 / tickCount;
      if (ratio > 1) {
        tickInterval = tickInterval * Math.ceil(ratio);
      }
      if (minTickInterval && tickInterval < minTickInterval) {
        tickInterval = minTickInterval;
      }
    }
    var ticks = [];
    for (var i = min7; i < max7 + tickInterval; i += tickInterval) {
      ticks.push(i);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/time-cat.js
  function calculateTimeCatTicks(cfg) {
    var ticks = calculateCatTicks(cfg);
    var lastValue = last(cfg.values);
    if (lastValue !== last(ticks)) {
      ticks.push(lastValue);
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/time-pretty.js
  function getYear(date) {
    return new Date(date).getFullYear();
  }
  function createYear(year) {
    return new Date(year, 0, 1).getTime();
  }
  function getMonth(date) {
    return new Date(date).getMonth();
  }
  function diffMonth(min7, max7) {
    var minYear = getYear(min7);
    var maxYear = getYear(max7);
    var minMonth = getMonth(min7);
    var maxMonth = getMonth(max7);
    return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
  }
  function creatMonth(year, month) {
    return new Date(year, month, 1).getTime();
  }
  function diffDay(min7, max7) {
    return Math.ceil((max7 - min7) / DAY);
  }
  function diffHour(min7, max7) {
    return Math.ceil((max7 - min7) / HOUR);
  }
  function diffMinus(min7, max7) {
    return Math.ceil((max7 - min7) / (60 * 1e3));
  }
  function timePretty(cfg) {
    var min7 = cfg.min, max7 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
    var tickInterval = cfg.tickInterval;
    var ticks = [];
    if (!tickInterval) {
      tickInterval = (max7 - min7) / tickCount;
      if (minTickInterval && tickInterval < minTickInterval) {
        tickInterval = minTickInterval;
      }
    }
    var minYear = getYear(min7);
    if (tickInterval > YEAR) {
      var maxYear = getYear(max7);
      var yearInterval = Math.ceil(tickInterval / YEAR);
      for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
        ticks.push(createYear(i));
      }
    } else if (tickInterval > MONTH) {
      var monthInterval = Math.ceil(tickInterval / MONTH);
      var mmMoth = getMonth(min7);
      var dMonths = diffMonth(min7, max7);
      for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
        ticks.push(creatMonth(minYear, i + mmMoth));
      }
    } else if (tickInterval > DAY) {
      var date = new Date(min7);
      var year = date.getFullYear();
      var month = date.getMonth();
      var mday = date.getDate();
      var day = Math.ceil(tickInterval / DAY);
      var ddays = diffDay(min7, max7);
      for (var i = 0; i < ddays + day; i = i + day) {
        ticks.push(new Date(year, month, mday + i).getTime());
      }
    } else if (tickInterval > HOUR) {
      var date = new Date(min7);
      var year = date.getFullYear();
      var month = date.getMonth();
      var day = date.getDate();
      var hour = date.getHours();
      var hours = Math.ceil(tickInterval / HOUR);
      var dHours = diffHour(min7, max7);
      for (var i = 0; i <= dHours + hours; i = i + hours) {
        ticks.push(new Date(year, month, day, hour + i).getTime());
      }
    } else if (tickInterval > MINUTE) {
      var dMinus = diffMinus(min7, max7);
      var minutes = Math.ceil(tickInterval / MINUTE);
      for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
        ticks.push(min7 + i * MINUTE);
      }
    } else {
      var interval2 = tickInterval;
      if (interval2 < SECOND) {
        interval2 = SECOND;
      }
      var minSecond = Math.floor(min7 / SECOND) * SECOND;
      var dSeconds = Math.ceil((max7 - min7) / SECOND);
      var seconds = Math.ceil(interval2 / SECOND);
      for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
        ticks.push(minSecond + i * SECOND);
      }
    }
    if (ticks.length >= 512) {
      console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
    }
    return ticks;
  }

  // node_modules/@antv/scale/esm/tick-method/index.js
  registerTickMethod("cat", calculateCatTicks);
  registerTickMethod("time-cat", calculateTimeCatTicks);
  registerTickMethod("wilkinson-extended", linear3);
  registerTickMethod("r-pretty", linearPretty);
  registerTickMethod("time", calculateTimeTicks);
  registerTickMethod("time-pretty", timePretty);
  registerTickMethod("log", calculateLogTicks);
  registerTickMethod("pow", calculatePowTicks);
  registerTickMethod("quantile", calculateTicks);
  registerTickMethod("d3-linear", d3LinearTickMethod);

  // node_modules/@antv/scale/esm/index.js
  registerClass("cat", base_default5);
  registerClass("category", base_default5);
  registerClass("identity", identity_default2);
  registerClass("linear", linear_default);
  registerClass("log", log_default);
  registerClass("pow", pow_default);
  registerClass("time", time_default2);
  registerClass("timeCat", time_default);
  registerClass("quantize", quantize_default);
  registerClass("quantile", quantile_default);

  // node_modules/@antv/attr/esm/factory.js
  var ATTRIBUTE_MAP = {};
  var getAttribute = function(type) {
    return ATTRIBUTE_MAP[type.toLowerCase()];
  };
  var registerAttribute = function(type, ctor) {
    if (getAttribute(type)) {
      throw new Error("Attribute type '" + type + "' existed.");
    }
    ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
  };

  // node_modules/@antv/attr/esm/index.js
  registerAttribute("Color", color_default);
  registerAttribute("Opacity", opacity_default);
  registerAttribute("Position", position_default);
  registerAttribute("Shape", shape_default2);
  registerAttribute("Size", size_default);

  // node_modules/@antv/coord/node_modules/tslib/modules/index.js
  var import_tslib33 = __toModule(require_tslib6());
  var {
    __extends: __extends6,
    __assign: __assign6,
    __rest: __rest6,
    __decorate: __decorate6,
    __param: __param6,
    __metadata: __metadata6,
    __awaiter: __awaiter6,
    __generator: __generator6,
    __exportStar: __exportStar6,
    __createBinding: __createBinding6,
    __values: __values6,
    __read: __read6,
    __spread: __spread6,
    __spreadArrays: __spreadArrays6,
    __spreadArray: __spreadArray5,
    __await: __await6,
    __asyncGenerator: __asyncGenerator6,
    __asyncDelegator: __asyncDelegator6,
    __asyncValues: __asyncValues6,
    __makeTemplateObject: __makeTemplateObject6,
    __importStar: __importStar6,
    __importDefault: __importDefault6,
    __classPrivateFieldGet: __classPrivateFieldGet6,
    __classPrivateFieldSet: __classPrivateFieldSet6
  } = import_tslib33.default;

  // node_modules/@antv/coord/esm/coord/base.js
  var Coordinate = function() {
    function Coordinate2(cfg) {
      this.type = "coordinate";
      this.isRect = false;
      this.isHelix = false;
      this.isPolar = false;
      this.isReflectX = false;
      this.isReflectY = false;
      var start = cfg.start, end = cfg.end, _a4 = cfg.matrix, matrix = _a4 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a4, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
      this.start = start;
      this.end = end;
      this.matrix = matrix;
      this.originalMatrix = __spreadArray5([], matrix);
      this.isTransposed = isTransposed;
    }
    Coordinate2.prototype.initial = function() {
      this.center = {
        x: (this.start.x + this.end.x) / 2,
        y: (this.start.y + this.end.y) / 2
      };
      this.width = Math.abs(this.end.x - this.start.x);
      this.height = Math.abs(this.end.y - this.start.y);
    };
    Coordinate2.prototype.update = function(cfg) {
      mix(this, cfg);
      this.initial();
    };
    Coordinate2.prototype.convertDim = function(percent, dim) {
      var _a4;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a4 = [end, start], start = _a4[0], end = _a4[1];
      }
      return start + percent * (end - start);
    };
    Coordinate2.prototype.invertDim = function(value, dim) {
      var _a4;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a4 = [end, start], start = _a4[0], end = _a4[1];
      }
      return (value - start) / (end - start);
    };
    Coordinate2.prototype.applyMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var vector = [x, y, tag];
      vec3_exports.transformMat3(vector, vector, matrix);
      return vector;
    };
    Coordinate2.prototype.invertMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var inverted = mat3_exports.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
      var vector = [x, y, tag];
      if (inverted) {
        vec3_exports.transformMat3(vector, vector, inverted);
      }
      return vector;
    };
    Coordinate2.prototype.convert = function(point) {
      var _a4 = this.convertPoint(point), x = _a4.x, y = _a4.y;
      var vector = this.applyMatrix(x, y, 1);
      return {
        x: vector[0],
        y: vector[1]
      };
    };
    Coordinate2.prototype.invert = function(point) {
      var vector = this.invertMatrix(point.x, point.y, 1);
      return this.invertPoint({
        x: vector[0],
        y: vector[1]
      });
    };
    Coordinate2.prototype.rotate = function(radian) {
      var matrix = this.matrix;
      var center = this.center;
      ext_exports.leftTranslate(matrix, matrix, [-center.x, -center.y]);
      ext_exports.leftRotate(matrix, matrix, radian);
      ext_exports.leftTranslate(matrix, matrix, [center.x, center.y]);
      return this;
    };
    Coordinate2.prototype.reflect = function(dim) {
      if (dim === "x") {
        this.isReflectX = !this.isReflectX;
      } else {
        this.isReflectY = !this.isReflectY;
      }
      return this;
    };
    Coordinate2.prototype.scale = function(s1, s2) {
      var matrix = this.matrix;
      var center = this.center;
      ext_exports.leftTranslate(matrix, matrix, [-center.x, -center.y]);
      ext_exports.leftScale(matrix, matrix, [s1, s2]);
      ext_exports.leftTranslate(matrix, matrix, [center.x, center.y]);
      return this;
    };
    Coordinate2.prototype.translate = function(x, y) {
      var matrix = this.matrix;
      ext_exports.leftTranslate(matrix, matrix, [x, y]);
      return this;
    };
    Coordinate2.prototype.transpose = function() {
      this.isTransposed = !this.isTransposed;
      return this;
    };
    Coordinate2.prototype.getCenter = function() {
      return this.center;
    };
    Coordinate2.prototype.getWidth = function() {
      return this.width;
    };
    Coordinate2.prototype.getHeight = function() {
      return this.height;
    };
    Coordinate2.prototype.getRadius = function() {
      return this.radius;
    };
    Coordinate2.prototype.isReflect = function(dim) {
      return dim === "x" ? this.isReflectX : this.isReflectY;
    };
    Coordinate2.prototype.resetMatrix = function(matrix) {
      this.matrix = matrix ? matrix : __spreadArray5([], this.originalMatrix);
    };
    return Coordinate2;
  }();
  var base_default7 = Coordinate;

  // node_modules/@antv/coord/esm/coord/cartesian.js
  var Cartesian = function(_super) {
    __extends6(Cartesian2, _super);
    function Cartesian2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isRect = true;
      _this.type = "cartesian";
      _this.initial();
      return _this;
    }
    Cartesian2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var start = this.start;
      var end = this.end;
      this.x = {
        start: start.x,
        end: end.x
      };
      this.y = {
        start: start.y,
        end: end.y
      };
    };
    Cartesian2.prototype.convertPoint = function(point) {
      var _a4;
      var x = point.x, y = point.y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      return {
        x: this.convertDim(x, "x"),
        y: this.convertDim(y, "y")
      };
    };
    Cartesian2.prototype.invertPoint = function(point) {
      var _a4;
      var x = this.invertDim(point.x, "x");
      var y = this.invertDim(point.y, "y");
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      return { x, y };
    };
    return Cartesian2;
  }(base_default7);
  var cartesian_default = Cartesian;

  // node_modules/@antv/coord/esm/coord/helix.js
  var Helix = function(_super) {
    __extends6(Helix2, _super);
    function Helix2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isHelix = true;
      _this.type = "helix";
      var _a4 = cfg.startAngle, startAngle = _a4 === void 0 ? 1.25 * Math.PI : _a4, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Helix2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
      var maxRadius = Math.min(this.width, this.height) / 2;
      if (this.radius && this.radius >= 0 && this.radius <= 1) {
        maxRadius = maxRadius * this.radius;
      }
      this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);
      this.a = this.d / (Math.PI * 2);
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * maxRadius,
        end: this.innerRadius * maxRadius + this.d * 0.99
      };
    };
    Helix2.prototype.convertPoint = function(point) {
      var _a4;
      var x = point.x, y = point.y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      var thi = this.convertDim(x, "x");
      var r = this.a * thi;
      var newY = this.convertDim(y, "y");
      return {
        x: this.center.x + Math.cos(thi) * (r + newY),
        y: this.center.y + Math.sin(thi) * (r + newY)
      };
    };
    Helix2.prototype.invertPoint = function(point) {
      var _a4;
      var d = this.d + this.y.start;
      var v = vec2_exports.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);
      var thi = ext_exports.angleTo(v, [1, 0], true);
      var rMin = thi * this.a;
      if (vec2_exports.length(v) < rMin) {
        rMin = vec2_exports.length(v);
      }
      var index = Math.floor((vec2_exports.length(v) - rMin) / d);
      thi = 2 * index * Math.PI + thi;
      var r = this.a * thi;
      var newY = vec2_exports.length(v) - r;
      newY = isNumberEqual(newY, 0) ? 0 : newY;
      var x = this.invertDim(thi, "x");
      var y = this.invertDim(newY, "y");
      x = isNumberEqual(x, 0) ? 0 : x;
      y = isNumberEqual(y, 0) ? 0 : y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      return { x, y };
    };
    return Helix2;
  }(base_default7);
  var helix_default = Helix;

  // node_modules/@antv/coord/esm/coord/polar.js
  var Polar = function(_super) {
    __extends6(Polar2, _super);
    function Polar2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isPolar = true;
      _this.type = "polar";
      var _a4 = cfg.startAngle, startAngle = _a4 === void 0 ? -Math.PI / 2 : _a4, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Polar2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      while (this.endAngle < this.startAngle) {
        this.endAngle += Math.PI * 2;
      }
      var oneBox = this.getOneBox();
      var oneWidth = oneBox.maxX - oneBox.minX;
      var oneHeight = oneBox.maxY - oneBox.minY;
      var left = Math.abs(oneBox.minX) / oneWidth;
      var top = Math.abs(oneBox.minY) / oneHeight;
      var maxRadius;
      if (this.height / oneHeight > this.width / oneWidth) {
        maxRadius = this.width / oneWidth;
        this.circleCenter = {
          x: this.center.x - (0.5 - left) * this.width,
          y: this.center.y - (0.5 - top) * maxRadius * oneHeight
        };
      } else {
        maxRadius = this.height / oneHeight;
        this.circleCenter = {
          x: this.center.x - (0.5 - left) * maxRadius * oneWidth,
          y: this.center.y - (0.5 - top) * this.height
        };
      }
      this.polarRadius = this.radius;
      if (!this.radius) {
        this.polarRadius = maxRadius;
      } else if (this.radius > 0 && this.radius <= 1) {
        this.polarRadius = maxRadius * this.radius;
      } else if (this.radius <= 0 || this.radius > maxRadius) {
        this.polarRadius = maxRadius;
      }
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * this.polarRadius,
        end: this.polarRadius
      };
    };
    Polar2.prototype.getRadius = function() {
      return this.polarRadius;
    };
    Polar2.prototype.convertPoint = function(point) {
      var _a4;
      var center = this.getCenter();
      var x = point.x, y = point.y;
      if (this.isTransposed) {
        _a4 = [y, x], x = _a4[0], y = _a4[1];
      }
      x = this.convertDim(x, "x");
      y = this.convertDim(y, "y");
      return {
        x: center.x + Math.cos(x) * y,
        y: center.y + Math.sin(x) * y
      };
    };
    Polar2.prototype.invertPoint = function(point) {
      var _a4;
      var center = this.getCenter();
      var vPoint = [point.x - center.x, point.y - center.y];
      var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
      if (this.isReflect("x")) {
        _a4 = [endAngle, startAngle], startAngle = _a4[0], endAngle = _a4[1];
      }
      var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      ext_exports.leftRotate(m, m, startAngle);
      var vStart3 = [1, 0, 0];
      vec3_exports.transformMat3(vStart3, vStart3, m);
      var vStart2 = [vStart3[0], vStart3[1]];
      var angle3 = ext_exports.angleTo(vStart2, vPoint, endAngle < startAngle);
      if (isNumberEqual(angle3, Math.PI * 2)) {
        angle3 = 0;
      }
      var radius = vec2_exports.length(vPoint);
      var xPercent = angle3 / (endAngle - startAngle);
      xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
      var yPercent = this.invertDim(radius, "y");
      var rst = { x: 0, y: 0 };
      rst.x = this.isTransposed ? yPercent : xPercent;
      rst.y = this.isTransposed ? xPercent : yPercent;
      return rst;
    };
    Polar2.prototype.getCenter = function() {
      return this.circleCenter;
    };
    Polar2.prototype.getOneBox = function() {
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
        return {
          minX: -1,
          maxX: 1,
          minY: -1,
          maxY: 1
        };
      }
      var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
      var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
      for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
        xs.push(Math.cos(i));
        ys.push(Math.sin(i));
      }
      return {
        minX: Math.min.apply(Math, xs),
        maxX: Math.max.apply(Math, xs),
        minY: Math.min.apply(Math, ys),
        maxY: Math.max.apply(Math, ys)
      };
    };
    return Polar2;
  }(base_default7);
  var polar_default = Polar;

  // node_modules/@antv/coord/esm/factory.js
  var COORDINATE_MAP = {};
  var getCoordinate = function(type) {
    return COORDINATE_MAP[type.toLowerCase()];
  };
  var registerCoordinate = function(type, ctor) {
    COORDINATE_MAP[type.toLowerCase()] = ctor;
  };

  // node_modules/@antv/coord/esm/index.js
  registerCoordinate("rect", cartesian_default);
  registerCoordinate("cartesian", cartesian_default);
  registerCoordinate("polar", polar_default);
  registerCoordinate("helix", helix_default);

  // node_modules/@antv/component/esm/annotation/index.js
  var annotation_exports = {};
  __export(annotation_exports, {
    Arc: () => arc_default2,
    DataMarker: () => data_marker_default,
    DataRegion: () => data_region_default,
    Html: () => html_default,
    Image: () => image_default,
    Line: () => line_default4,
    Region: () => region_default,
    RegionFilter: () => region_filter_default,
    Shape: () => shape_default4,
    Text: () => text_default3
  });

  // node_modules/@antv/component/node_modules/tslib/modules/index.js
  var import_tslib38 = __toModule(require_tslib7());
  var {
    __extends: __extends7,
    __assign: __assign7,
    __rest: __rest7,
    __decorate: __decorate7,
    __param: __param7,
    __metadata: __metadata7,
    __awaiter: __awaiter7,
    __generator: __generator7,
    __exportStar: __exportStar7,
    __createBinding: __createBinding7,
    __values: __values7,
    __read: __read7,
    __spread: __spread7,
    __spreadArrays: __spreadArrays7,
    __spreadArray: __spreadArray6,
    __await: __await7,
    __asyncGenerator: __asyncGenerator7,
    __asyncDelegator: __asyncDelegator7,
    __asyncValues: __asyncValues7,
    __makeTemplateObject: __makeTemplateObject7,
    __importStar: __importStar7,
    __importDefault: __importDefault7,
    __classPrivateFieldGet: __classPrivateFieldGet7,
    __classPrivateFieldSet: __classPrivateFieldSet7
  } = import_tslib38.default;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/path.js
  var SPACES3 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
  var PATH_COMMAND3 = new RegExp("([a-z])[" + SPACES3 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES3 + "]*,?[" + SPACES3 + "]*)+)", "ig");
  var PATH_VALUES3 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES3 + "]*,?[" + SPACES3 + "]*", "ig");
  var parsePathString3 = function(pathString) {
    if (!pathString) {
      return null;
    }
    if (is_array_default(pathString)) {
      return pathString;
    }
    var paramCounts = {
      a: 7,
      c: 6,
      o: 2,
      h: 1,
      l: 2,
      m: 2,
      r: 4,
      q: 4,
      s: 4,
      t: 2,
      v: 1,
      u: 3,
      z: 0
    };
    var data = [];
    String(pathString).replace(PATH_COMMAND3, function(a, b, c) {
      var params = [];
      var name = b.toLowerCase();
      c.replace(PATH_VALUES3, function(a6, b10) {
        b10 && params.push(+b10);
      });
      if (name === "m" && params.length > 2) {
        data.push([b].concat(params.splice(0, 2)));
        name = "l";
        b = b === "m" ? "l" : "L";
      }
      if (name === "o" && params.length === 1) {
        data.push([b, params[0]]);
      }
      if (name === "r") {
        data.push([b].concat(params));
      } else {
        while (params.length >= paramCounts[name]) {
          data.push([b].concat(params.splice(0, paramCounts[name])));
          if (!paramCounts[name]) {
            break;
          }
        }
      }
      return pathString;
    });
    return data;
  };
  var isEqual3 = function(obj1, obj2) {
    if (obj1.length !== obj2.length) {
      return false;
    }
    var result = true;
    each_default(obj1, function(item, i) {
      if (item !== obj2[i]) {
        result = false;
        return false;
      }
    });
    return result;
  };
  function getMinDiff2(del, add8, modify) {
    var type = null;
    var min7 = modify;
    if (add8 < min7) {
      min7 = add8;
      type = "add";
    }
    if (del < min7) {
      min7 = del;
      type = "del";
    }
    return {
      type,
      min: min7
    };
  }
  var levenshteinDistance2 = function(source, target) {
    var sourceLen = source.length;
    var targetLen = target.length;
    var sourceSegment;
    var targetSegment;
    var temp = 0;
    if (sourceLen === 0 || targetLen === 0) {
      return null;
    }
    var dist3 = [];
    for (var i = 0; i <= sourceLen; i++) {
      dist3[i] = [];
      dist3[i][0] = { min: i };
    }
    for (var j = 0; j <= targetLen; j++) {
      dist3[0][j] = { min: j };
    }
    for (var i = 1; i <= sourceLen; i++) {
      sourceSegment = source[i - 1];
      for (var j = 1; j <= targetLen; j++) {
        targetSegment = target[j - 1];
        if (isEqual3(sourceSegment, targetSegment)) {
          temp = 0;
        } else {
          temp = 1;
        }
        var del = dist3[i - 1][j].min + 1;
        var add8 = dist3[i][j - 1].min + 1;
        var modify = dist3[i - 1][j - 1].min + temp;
        dist3[i][j] = getMinDiff2(del, add8, modify);
      }
    }
    return dist3;
  };
  var fillPathByDiff3 = function(source, target) {
    var diffMatrix = levenshteinDistance2(source, target);
    var sourceLen = source.length;
    var targetLen = target.length;
    var changes = [];
    var index = 1;
    var minPos = 1;
    if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
      for (var i = 1; i <= sourceLen; i++) {
        var min7 = diffMatrix[i][i].min;
        minPos = i;
        for (var j = index; j <= targetLen; j++) {
          if (diffMatrix[i][j].min < min7) {
            min7 = diffMatrix[i][j].min;
            minPos = j;
          }
        }
        index = minPos;
        if (diffMatrix[i][index].type) {
          changes.push({ index: i - 1, type: diffMatrix[i][index].type });
        }
      }
      for (var i = changes.length - 1; i >= 0; i--) {
        index = changes[i].index;
        if (changes[i].type === "add") {
          source.splice(index, 0, [].concat(source[index]));
        } else {
          source.splice(index, 1);
        }
      }
    }
    sourceLen = source.length;
    var diff2 = targetLen - sourceLen;
    if (sourceLen < targetLen) {
      for (var i = 0; i < diff2; i++) {
        if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
          source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
        } else {
          source.push(source[sourceLen - 1]);
        }
        sourceLen += 1;
      }
    }
    return source;
  };
  function _splitPoints2(points, former, count2) {
    var result = [].concat(points);
    var index;
    var t = 1 / (count2 + 1);
    var formerEnd = _getSegmentPoints2(former)[0];
    for (var i = 1; i <= count2; i++) {
      t *= i;
      index = Math.floor(points.length * t);
      if (index === 0) {
        result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
      } else {
        result.splice(index, 0, [
          formerEnd[0] * t + points[index][0] * (1 - t),
          formerEnd[1] * t + points[index][1] * (1 - t)
        ]);
      }
    }
    return result;
  }
  function _getSegmentPoints2(segment) {
    var points = [];
    switch (segment[0]) {
      case "M":
        points.push([segment[1], segment[2]]);
        break;
      case "L":
        points.push([segment[1], segment[2]]);
        break;
      case "A":
        points.push([segment[6], segment[7]]);
        break;
      case "Q":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "T":
        points.push([segment[1], segment[2]]);
        break;
      case "C":
        points.push([segment[5], segment[6]]);
        points.push([segment[1], segment[2]]);
        points.push([segment[3], segment[4]]);
        break;
      case "S":
        points.push([segment[3], segment[4]]);
        points.push([segment[1], segment[2]]);
        break;
      case "H":
        points.push([segment[1], segment[1]]);
        break;
      case "V":
        points.push([segment[1], segment[1]]);
        break;
      default:
    }
    return points;
  }
  var formatPath3 = function(fromPath, toPath) {
    if (fromPath.length <= 1) {
      return fromPath;
    }
    var points;
    for (var i = 0; i < toPath.length; i++) {
      if (fromPath[i][0] !== toPath[i][0]) {
        points = _getSegmentPoints2(fromPath[i]);
        switch (toPath[i][0]) {
          case "M":
            fromPath[i] = ["M"].concat(points[0]);
            break;
          case "L":
            fromPath[i] = ["L"].concat(points[0]);
            break;
          case "A":
            fromPath[i] = [].concat(toPath[i]);
            fromPath[i][6] = points[0][0];
            fromPath[i][7] = points[0][1];
            break;
          case "Q":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints2(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["Q"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "T":
            fromPath[i] = ["T"].concat(points[0]);
            break;
          case "C":
            if (points.length < 3) {
              if (i > 0) {
                points = _splitPoints2(points, fromPath[i - 1], 2);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["C"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          case "S":
            if (points.length < 2) {
              if (i > 0) {
                points = _splitPoints2(points, fromPath[i - 1], 1);
              } else {
                fromPath[i] = toPath[i];
                break;
              }
            }
            fromPath[i] = ["S"].concat(points.reduce(function(arr, i2) {
              return arr.concat(i2);
            }, []));
            break;
          default:
            fromPath[i] = toPath[i];
        }
      }
    }
    return fromPath;
  };

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/event/graph-event.js
  var GraphEvent2 = function() {
    function GraphEvent3(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent3.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent3.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent3.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent3.prototype.save = function() {
    };
    GraphEvent3.prototype.restore = function() {
    };
    return GraphEvent3;
  }();
  var graph_event_default2 = GraphEvent2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/util.js
  function removeFromArray2(arr, obj) {
    var index = arr.indexOf(obj);
    if (index !== -1) {
      arr.splice(index, 1);
    }
  }
  var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isParent2(container, shape) {
    if (container.isCanvas()) {
      return true;
    }
    var parent = shape.getParent();
    var isParent3 = false;
    while (parent) {
      if (parent === container) {
        isParent3 = true;
        break;
      }
      parent = parent.getParent();
    }
    return isParent3;
  }
  function isAllowCapture2(element) {
    return element.cfg.visible && element.cfg.capture;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/base.js
  var Base3 = function(_super) {
    __extends7(Base4, _super);
    function Base4(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base4.prototype.getDefaultCfg = function() {
      return {};
    };
    Base4.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base4.prototype.set = function(name, value) {
      this.cfg[name] = value;
    };
    Base4.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base4;
  }(esm_default);
  var base_default8 = Base3;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/matrix.js
  function multiplyMatrix2(a, b) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b00 = b[0];
    var b01 = b[1];
    var b02 = b[2];
    var b10 = b[3];
    var b11 = b[4];
    var b12 = b[5];
    var b20 = b[6];
    var b21 = b[7];
    var b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function multiplyVec22(m, v) {
    var out = [];
    var x = v[0];
    var y = v[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function invert3(a) {
    var out = [];
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a10 = a[3];
    var a11 = a[4];
    var a12 = a[5];
    var a20 = a[6];
    var a21 = a[7];
    var a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/element.js
  var transform3 = ext_exports.transform;
  var MATRIX2 = "matrix";
  var CLONE_CFGS2 = ["zIndex", "capture", "visible", "type"];
  var RESERVED_PORPS2 = ["repeat"];
  var DELEGATION_SPLIT2 = ":";
  var WILDCARD3 = "*";
  function _cloneArrayAttr2(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
      if (is_array_default(arr[i])) {
        result.push([].concat(arr[i]));
      } else {
        result.push(arr[i]);
      }
    }
    return result;
  }
  function getFormatFromAttrs2(toAttrs, shape) {
    var fromAttrs = {};
    var attrs = shape.attrs;
    for (var k in toAttrs) {
      fromAttrs[k] = attrs[k];
    }
    return fromAttrs;
  }
  function getFormatToAttrs2(props, shape) {
    var toAttrs = {};
    var attrs = shape.attr();
    each_default(props, function(v, k) {
      if (RESERVED_PORPS2.indexOf(k) === -1 && !is_equal_default(attrs[k], v)) {
        toAttrs[k] = v;
      }
    });
    return toAttrs;
  }
  function checkExistedAttrs2(animations, animation) {
    if (animation.onFrame) {
      return animations;
    }
    var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
    var hasOwnProperty5 = Object.prototype.hasOwnProperty;
    each_default(animations, function(item) {
      if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
        each_default(animation.toAttrs, function(v, k) {
          if (hasOwnProperty5.call(item.toAttrs, k)) {
            delete item.toAttrs[k];
            delete item.fromAttrs[k];
          }
        });
      }
    });
    return animations;
  }
  var Element3 = function(_super) {
    __extends7(Element5, _super);
    function Element5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element5.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element5.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element5.prototype.onCanvasChange = function(changeType) {
    };
    Element5.prototype.initAttrs = function(attrs) {
    };
    Element5.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element5.prototype.isGroup = function() {
      return false;
    };
    Element5.prototype.getParent = function() {
      return this.get("parent");
    };
    Element5.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element5.prototype.attr = function() {
      var _a4;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value = args[1];
      if (!name)
        return this.attrs;
      if (is_object_default(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value);
        this.afterAttrsChange((_a4 = {}, _a4[name] = value, _a4));
        return this;
      }
      return this.attrs[name];
    };
    Element5.prototype.isClipped = function(refX, refY) {
      var clip2 = this.getClip();
      return clip2 && !clip2.isHit(refX, refY);
    };
    Element5.prototype.setAttr = function(name, value) {
      var originValue = this.attrs[name];
      if (originValue !== value) {
        this.attrs[name] = value;
        this.onAttrChange(name, value, originValue);
      }
    };
    Element5.prototype.onAttrChange = function(name, value, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element5.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element5.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element5.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element5.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element5.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      var el = this.get("el");
      var index = children.indexOf(this);
      children.splice(index, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element5.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray2(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element5.prototype.resetMatrix = function() {
      this.attr(MATRIX2, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getMatrix = function() {
      return this.attr(MATRIX2);
    };
    Element5.prototype.setMatrix = function(m) {
      this.attr(MATRIX2, m);
      this.onCanvasChange("matrix");
    };
    Element5.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix2(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element5.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix2(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element5.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element5.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec22(matrix, v);
      }
      return v;
    };
    Element5.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert3(matrix);
        if (invertMatrix) {
          return multiplyVec22(invertMatrix, v);
        }
      }
      return v;
    };
    Element5.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase4 = this.getShapeBase();
        var shapeType = upper_first_default(clipCfg.type);
        var Cons = ShapeBase4[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element5.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element5.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each_default(originAttrs, function(i, k) {
        if (is_array_default(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr2(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone6 = new cons({ attrs });
      each_default(CLONE_CFGS2, function(cfgName) {
        clone6.set(cfgName, _this.get(cfgName));
      });
      return clone6;
    };
    Element5.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element5.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element5.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a4 = args[2], easing = _a4 === void 0 ? "easeLinear" : _a4, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat2;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (is_function_default(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat2 = toAttrs.repeat;
      }
      if (is_object_default(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat2 = animateCfg.repeat || repeat2 || false;
        callback = animateCfg.callback || noop_default;
        pauseCallback = animateCfg.pauseCallback || noop_default;
        resumeCallback = animateCfg.resumeCallback || noop_default;
      } else {
        if (is_number_default(callback)) {
          delay = callback;
          callback = null;
        }
        if (is_function_default(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs2(toAttrs, this);
      var animation = {
        fromAttrs: getFormatFromAttrs2(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat: repeat2,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: unique_id_default(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs2(animations, animation);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element5.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each_default(animations, function(animation) {
        if (toEnd) {
          if (animation.onFrame) {
            _this.attr(animation.onFrame(1));
          } else {
            _this.attr(animation.toAttrs);
          }
        }
        if (animation.callback) {
          animation.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element5.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each_default(animations, function(animation) {
        animation._paused = true;
        animation._pauseTime = pauseTime;
        if (animation.pauseCallback) {
          animation.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element5.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each_default(animations, function(animation) {
        animation.startTime = animation.startTime + (current - pauseTime);
        animation._paused = false;
        animation._pauseTime = null;
        if (animation.resumeCallback) {
          animation.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element5.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      var events = this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent2(element, relativeShape)) {
            return "break";
          }
          if (is_array_default(name_1)) {
            each_default(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element5.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT2 + eventObj.type;
      if (events[eventName] || events[WILDCARD3]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element5.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element5.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element5.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtStart = function(rotate5) {
      var _a4 = this.attr(), x = _a4.x, y = _a4.y;
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element5.prototype.rotateAtPoint = function(x, y, rotate5) {
      var matrix = this.getMatrix();
      var newMatrix = transform3(matrix, [
        ["t", -x, -y],
        ["r", rotate5],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element5;
  }(base_default8);
  var element_default2 = Element3;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/container.js
  var SHAPE_MAP2 = {};
  var INDEX2 = "_INDEX";
  function setCanvas2(element, canvas) {
    element.set("canvas", canvas);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setCanvas2(child, canvas);
        });
      }
    }
  }
  function setTimeline2(element, timeline) {
    element.set("timeline", timeline);
    if (element.isGroup()) {
      var children = element.get("children");
      if (children.length) {
        children.forEach(function(child) {
          setTimeline2(child, timeline);
        });
      }
    }
  }
  function removeChild2(container, element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (destroy) {
      element.destroy();
    } else {
      element.set("parent", null);
      element.set("canvas", null);
    }
    removeFromArray2(container.getChildren(), element);
  }
  function getComparer2(compare) {
    return function(left, right) {
      var result = compare(left, right);
      return result === 0 ? left[INDEX2] - right[INDEX2] : result;
    };
  }
  var Container2 = function(_super) {
    __extends7(Container4, _super);
    function Container4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container4.prototype.isCanvas = function() {
      return false;
    };
    Container4.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container4.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each_default(children, function(child) {
          var box3 = child.getCanvasBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min_default(xArr);
        maxX = max_default(xArr);
        minY = min_default(yArr);
        maxY = max_default(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      return box2;
    };
    Container4.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container4.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container4.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each_default(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container4.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (is_object_default(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP2[cfg.type];
      if (!shapeType) {
        shapeType = upper_first_default(cfg.type);
        SHAPE_MAP2[cfg.type] = shapeType;
      }
      var ShapeBase4 = this.getShapeBase();
      var shape = new ShapeBase4[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container4.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group2;
      if (is_function_default(groupClass)) {
        if (cfg) {
          group2 = new groupClass(cfg);
        } else {
          group2 = new groupClass({
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group2 = new TmpGroupClass(tmpCfg);
      }
      this.add(group2);
      return group2;
    };
    Container4.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container4.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture2(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container4.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture2(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container4.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild2(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas2(element, canvas);
      }
      if (timeline) {
        setTimeline2(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container4.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container4.prototype.getChildren = function() {
      return this.get("children");
    };
    Container4.prototype.sort = function() {
      var children = this.getChildren();
      each_default(children, function(child, index) {
        child[INDEX2] = index;
        return child;
      });
      children.sort(getComparer2(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container4.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container4.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container4.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container4.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container4.prototype.getChildByIndex = function(index) {
      var children = this.getChildren();
      return children[index];
    };
    Container4.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container4.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container4.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container4.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container4.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each_default(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container4.prototype.findById = function(id) {
      return this.find(function(element) {
        return element.get("id") === id;
      });
    };
    Container4.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container4.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container4;
  }(element_default2);
  var container_default2 = Container2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/color.js
  var isColorProp2 = function(prop) {
    return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
  };
  var isGradientColor3 = function(val) {
    return /^[r,R,L,l]{1}[\s]*\(/.test(val);
  };

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/animate/timeline.js
  var IDENTITY_MATRIX2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  function _update2(shape, animation, ratio) {
    var cProps = {};
    var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
    if (shape.destroyed) {
      return;
    }
    var interf;
    for (var k in toAttrs) {
      if (!is_equal_default(fromAttrs[k], toAttrs[k])) {
        if (k === "path") {
          var toPath = toAttrs[k];
          var fromPath = fromAttrs[k];
          if (toPath.length > fromPath.length) {
            toPath = parsePathString3(toAttrs[k]);
            fromPath = parsePathString3(fromAttrs[k]);
            fromPath = fillPathByDiff3(fromPath, toPath);
            fromPath = formatPath3(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
          } else if (!animation.pathFormatted) {
            toPath = parsePathString3(toAttrs[k]);
            fromPath = parsePathString3(fromAttrs[k]);
            fromPath = formatPath3(fromPath, toPath);
            animation.fromAttrs.path = fromPath;
            animation.toAttrs.path = toPath;
            animation.pathFormatted = true;
          }
          cProps[k] = [];
          for (var i = 0; i < toPath.length; i++) {
            var toPathPoint = toPath[i];
            var fromPathPoint = fromPath[i];
            var cPathPoint = [];
            for (var j = 0; j < toPathPoint.length; j++) {
              if (is_number_default(toPathPoint[j]) && fromPathPoint && is_number_default(fromPathPoint[j])) {
                interf = value_default(fromPathPoint[j], toPathPoint[j]);
                cPathPoint.push(interf(ratio));
              } else {
                cPathPoint.push(toPathPoint[j]);
              }
            }
            cProps[k].push(cPathPoint);
          }
        } else if (k === "matrix") {
          var matrixFn = array_default(fromAttrs[k] || IDENTITY_MATRIX2, toAttrs[k] || IDENTITY_MATRIX2);
          var currentMatrix = matrixFn(ratio);
          cProps[k] = currentMatrix;
        } else if (isColorProp2(k) && isGradientColor3(toAttrs[k])) {
          cProps[k] = toAttrs[k];
        } else if (!is_function_default(toAttrs[k])) {
          interf = value_default(fromAttrs[k], toAttrs[k]);
          cProps[k] = interf(ratio);
        }
      }
    }
    shape.attr(cProps);
  }
  function update2(shape, animation, elapsed) {
    var startTime = animation.startTime, delay = animation.delay;
    if (elapsed < startTime + delay || animation._paused) {
      return false;
    }
    var ratio;
    var duration = animation.duration;
    var easing = animation.easing;
    elapsed = elapsed - startTime - animation.delay;
    if (animation.repeat) {
      ratio = elapsed % duration / duration;
      ratio = src_exports[easing](ratio);
    } else {
      ratio = elapsed / duration;
      if (ratio < 1) {
        ratio = src_exports[easing](ratio);
      } else {
        if (animation.onFrame) {
          shape.attr(animation.onFrame(1));
        } else {
          shape.attr(animation.toAttrs);
        }
        return true;
      }
    }
    if (animation.onFrame) {
      var attrs = animation.onFrame(ratio);
      shape.attr(attrs);
    } else {
      _update2(shape, animation, ratio);
    }
    return false;
  }
  var Timeline2 = function() {
    function Timeline3(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline3.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation = animations[j];
                isFinished = update2(shape, animation, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation.callback) {
                    animation.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline3.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline3.prototype.removeAnimator = function(index) {
      this.animators.splice(index, 1);
    };
    Timeline3.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline3.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline3.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline3.prototype.getTime = function() {
      return this.current;
    };
    return Timeline3;
  }();
  var timeline_default2 = Timeline2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/event/event-contoller.js
  var CLICK_OFFSET2 = 40;
  var LEFT_BTN_CODE2 = 0;
  var EVENTS2 = [
    "mousedown",
    "mouseup",
    "dblclick",
    "mouseout",
    "mouseover",
    "mousemove",
    "mouseleave",
    "mouseenter",
    "touchstart",
    "touchmove",
    "touchend",
    "dragenter",
    "dragover",
    "dragleave",
    "drop",
    "contextmenu",
    "mousewheel"
  ];
  function emitTargetEvent2(target, type, eventObj) {
    eventObj.name = type;
    eventObj.target = target;
    eventObj.currentTarget = target;
    eventObj.delegateTarget = target;
    target.emit(type, eventObj);
  }
  function bubbleEvent2(container, type, eventObj) {
    if (eventObj.bubbles) {
      var relativeShape = void 0;
      var isOverEvent = false;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
        isOverEvent = true;
      } else if (type === "mouseleave") {
        isOverEvent = true;
        relativeShape = eventObj.toShape;
      }
      if (container.isCanvas() && isOverEvent) {
        return;
      }
      if (relativeShape && isParent2(container, relativeShape)) {
        eventObj.bubbles = false;
        return;
      }
      eventObj.name = type;
      eventObj.currentTarget = container;
      eventObj.delegateTarget = container;
      container.emit(type, eventObj);
    }
  }
  var EventController2 = function() {
    function EventController3(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController3.prototype.init = function() {
      this._bindEvents();
    };
    EventController3.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS2, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each_default(EVENTS2, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController3.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
      var eventObj = new graph_event_default2(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point.x;
      eventObj.y = point.y;
      eventObj.clientX = point.clientX;
      eventObj.clientY = point.clientY;
      eventObj.propagationPath.push(target);
      return eventObj;
    };
    EventController3.prototype._getShape = function(point, ev) {
      return this.canvas.getShape(point.x, point.y, ev);
    };
    EventController3.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point = canvas.getPointByEvent(ev);
      return {
        x: point.x,
        y: point.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController3.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController3.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE2) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController3.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController3.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController3.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController3.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE2) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController3.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController3.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now3 = event.timeStamp;
          var timeWindow = now3 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist3 = dx * dx + dy * dy;
          if (timeWindow > 120 || dist3 > CLICK_OFFSET2) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController3.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent2(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent2(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent2(canvas, type, eventObj);
      }
    };
    EventController3.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController3;
  }();
  var event_contoller_default2 = EventController2;

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/canvas.js
  var PX_SUFFIX2 = "px";
  var browser2 = detect();
  var isFirefox2 = browser2 && browser2.name === "firefox";
  var Canvas2 = function(_super) {
    __extends7(Canvas5, _super);
    function Canvas5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas5.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas5.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas5.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas5.prototype.initEvents = function() {
      var eventController = new event_contoller_default2({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas5.prototype.initTimeline = function() {
      var timeline = new timeline_default2(this);
      this.set("timeline", timeline);
    };
    Canvas5.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser2) {
        el.style.width = width + PX_SUFFIX2;
        el.style.height = height + PX_SUFFIX2;
      }
    };
    Canvas5.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas5.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas5.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas5.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser2 && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas5.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox2 && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!is_nil_default(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a4 = this.getClientByEvent(ev), clientX = _a4.x, clientY = _a4.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas5.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas5.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas5.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas5.prototype.draw = function() {
    };
    Canvas5.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas5.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas5.prototype.isCanvas = function() {
      return true;
    };
    Canvas5.prototype.getParent = function() {
      return null;
    };
    Canvas5.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas5;
  }(container_default2);

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/group.js
  var AbstractGroup2 = function(_super) {
    __extends7(AbstractGroup3, _super);
    function AbstractGroup3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup3.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup3.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup3.prototype.clone = function() {
      var clone6 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone6.add(child.clone());
      }
      return clone6;
    };
    return AbstractGroup3;
  }(container_default2);

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/abstract/shape.js
  var AbstractShape2 = function(_super) {
    __extends7(AbstractShape3, _super);
    function AbstractShape3(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape3.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape3.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape3.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape3.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec22(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec22(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec22(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec22(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a4 = attrs.shadowBlur, shadowBlur = _a4 === void 0 ? 0 : _a4, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY = Math.max(maxY, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    AbstractShape3.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape3.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape3.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape3.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape3.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape3;
  }(element_default2);

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/register.js
  var cache2 = new Map();
  function register2(type, method) {
    cache2.set(type, method);
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/rect.js
  function rect_default2(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
    return {
      x,
      y,
      width,
      height
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/circle.js
  function circle_default2(shape) {
    var _a4 = shape.attr(), x = _a4.x, y = _a4.y, r = _a4.r;
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/util.js
  function mergeBBox2(bbox1, bbox2) {
    if (!bbox1 || !bbox2) {
      return bbox1 || bbox2;
    }
    return {
      minX: Math.min(bbox1.minX, bbox2.minX),
      minY: Math.min(bbox1.minY, bbox2.minY),
      maxX: Math.max(bbox1.maxX, bbox2.maxX),
      maxY: Math.max(bbox1.maxY, bbox2.maxY)
    };
  }
  function mergeArrowBBox2(shape, bbox) {
    var startArrowShape = shape.get("startArrowShape");
    var endArrowShape = shape.get("endArrowShape");
    var startArrowBBox = null;
    var endArrowBBox = null;
    if (startArrowShape) {
      startArrowBBox = startArrowShape.getCanvasBBox();
      bbox = mergeBBox2(bbox, startArrowBBox);
    }
    if (endArrowShape) {
      endArrowBBox = endArrowShape.getCanvasBBox();
      bbox = mergeBBox2(bbox, endArrowBBox);
    }
    return bbox;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/polyline.js
  function polyline_default3(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    var _a4 = util_exports.getBBoxByArray(xArr, yArr), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox2(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/polygon.js
  function polygon_default3(shape) {
    var attrs = shape.attr();
    var points = attrs.points;
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return util_exports.getBBoxByArray(xArr, yArr);
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/offscreen.js
  var offScreenCtx2 = null;
  function getOffScreenContext2() {
    if (!offScreenCtx2) {
      var canvas = document.createElement("canvas");
      canvas.width = 1;
      canvas.height = 1;
      offScreenCtx2 = canvas.getContext("2d");
    }
    return offScreenCtx2;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/util/text.js
  function getTextHeight2(text, fontSize, lineHeight) {
    var lineCount = 1;
    if (is_string_default(text)) {
      lineCount = text.split("\n").length;
    }
    if (lineCount > 1) {
      var spaceingY = getLineSpaceing2(fontSize, lineHeight);
      return fontSize * lineCount + spaceingY * (lineCount - 1);
    }
    return fontSize;
  }
  function getLineSpaceing2(fontSize, lineHeight) {
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  }
  function getTextWidth2(text, font) {
    var context = getOffScreenContext2();
    var width = 0;
    if (is_nil_default(text) || text === "") {
      return width;
    }
    context.save();
    context.font = font;
    if (is_string_default(text) && text.includes("\n")) {
      var textArr = text.split("\n");
      each_default(textArr, function(subText) {
        var measureWidth = context.measureText(subText).width;
        if (width < measureWidth) {
          width = measureWidth;
        }
      });
    } else {
      width = context.measureText(text).width;
    }
    context.restore();
    return width;
  }
  function assembleFont2(attrs) {
    var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
    return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/text.js
  function text_default2(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
    var font = attrs.font;
    if (!font) {
      font = assembleFont2(attrs);
    }
    var width = getTextWidth2(text, font);
    var bbox;
    if (!width) {
      bbox = {
        x,
        y,
        width: 0,
        height: 0
      };
    } else {
      var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
      var height = getTextHeight2(text, fontSize, lineHeight);
      var point = {
        x,
        y: y - height
      };
      if (textAlign) {
        if (textAlign === "end" || textAlign === "right") {
          point.x -= width;
        } else if (textAlign === "center") {
          point.x -= width / 2;
        }
      }
      if (textBaseline) {
        if (textBaseline === "top") {
          point.y += height;
        } else if (textBaseline === "middle") {
          point.y += height / 2;
        }
      }
      bbox = {
        x: point.x,
        y: point.y,
        width,
        height
      };
    }
    return bbox;
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/path.js
  function getPathBox2(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item);
    });
    var minX = min_default(xArr);
    var minY = min_default(yArr);
    var maxX = max_default(xArr);
    var maxY = max_default(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    for (var i = 0; i < segmentsWithAngle.length; i++) {
      var segment = segmentsWithAngle[i];
      var currentPoint = segment.currentPoint;
      var extra = void 0;
      if (currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        minX = minX - extra.xExtra;
      } else if (currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        maxX = maxX + extra.xExtra;
      }
      if (currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        minY = minY - extra.yExtra;
      } else if (currentPoint[1] === maxY) {
        extra = getExtraFromSegmentWithAngle2(segment, lineWidth);
        maxY = maxY + extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function getExtraFromSegmentWithAngle2(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function path_default2(shape) {
    var attrs = shape.attr();
    var path = attrs.path, stroke = attrs.stroke;
    var lineWidth = stroke ? attrs.lineWidth : 0;
    var segments = shape.get("segments") || getSegments(path);
    var _a4 = getPathBox2(segments, lineWidth), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
    var bbox = {
      minX: x,
      minY: y,
      maxX: x + width,
      maxY: y + height
    };
    bbox = mergeArrowBBox2(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/line.js
  function line_default3(shape) {
    var attrs = shape.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var bbox = {
      minX,
      maxX,
      minY,
      maxY
    };
    bbox = mergeArrowBBox2(shape, bbox);
    return {
      x: bbox.minX,
      y: bbox.minY,
      width: bbox.maxX - bbox.minX,
      height: bbox.maxY - bbox.minY
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/ellipse.js
  function ellipse_default3(shape) {
    var attrs = shape.attr();
    var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  }

  // node_modules/@antv/component/node_modules/@antv/g-base/esm/bbox/index.js
  register2("rect", rect_default2);
  register2("image", rect_default2);
  register2("circle", circle_default2);
  register2("marker", circle_default2);
  register2("polyline", polyline_default3);
  register2("polygon", polygon_default3);
  register2("text", text_default2);
  register2("path", path_default2);
  register2("line", line_default3);
  register2("ellipse", ellipse_default3);

  // node_modules/@antv/component/esm/util/event.js
  function propagationDelegate(group2, eventName, eventObject) {
    var event = new graph_event_default2(eventName, eventObject);
    event.target = group2;
    event.propagationPath.push(group2);
    group2.emitDelegation(eventName, event);
    var parent = group2.getParent();
    while (parent) {
      parent.emitDelegation(eventName, event);
      event.propagationPath.push(parent);
      parent = parent.getParent();
    }
  }

  // node_modules/@antv/component/esm/util/matrix.js
  var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  function getMatrixByAngle(point, angle3, matrix) {
    if (matrix === void 0) {
      matrix = identityMatrix;
    }
    if (!angle3) {
      return null;
    }
    var m = ext_exports.transform(matrix, [
      ["t", -point.x, -point.y],
      ["r", angle3],
      ["t", point.x, point.y]
    ]);
    return m;
  }
  function getMatrixByTranslate(point, currentMatrix) {
    if (!point.x && !point.y) {
      return null;
    }
    return ext_exports.transform(currentMatrix || identityMatrix, [["t", point.x, point.y]]);
  }
  function getAngleByMatrix(matrix) {
    var xVector = [1, 0, 0];
    var out = [0, 0, 0];
    vec3_exports.transformMat3(out, xVector, matrix);
    return Math.atan2(out[1], out[0]);
  }
  function multiplyVec23(matrix, v) {
    var out = [0, 0];
    vec2_exports.transformMat3(out, v, matrix);
    return out;
  }
  function applyMatrix2BBox(matrix, bbox) {
    var topLeft = multiplyVec23(matrix, [bbox.minX, bbox.minY]);
    var topRight = multiplyVec23(matrix, [bbox.maxX, bbox.minY]);
    var bottomLeft = multiplyVec23(matrix, [bbox.minX, bbox.maxY]);
    var bottomRight = multiplyVec23(matrix, [bbox.maxX, bbox.maxY]);
    var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
    var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
    var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function applyRotate(shape, rotate5, x, y) {
    if (rotate5) {
      var matrix = getMatrixByAngle({ x, y }, rotate5, shape.getMatrix());
      shape.setMatrix(matrix);
    }
  }
  function applyTranslate(shape, x, y) {
    var translateMatrix = getMatrixByTranslate({ x, y });
    shape.attr("matrix", translateMatrix);
  }

  // node_modules/@antv/component/esm/util/util.js
  function formatPadding(padding) {
    var top = 0;
    var left = 0;
    var right = 0;
    var bottom = 0;
    if (is_number_default(padding)) {
      top = left = right = bottom = padding;
    } else if (is_array_default(padding)) {
      top = padding[0];
      right = !is_nil_default(padding[1]) ? padding[1] : padding[0];
      bottom = !is_nil_default(padding[2]) ? padding[2] : padding[0];
      left = !is_nil_default(padding[3]) ? padding[3] : right;
    }
    return [top, right, bottom, left];
  }
  function clearDom(container) {
    var children = container.childNodes;
    var length3 = children.length;
    for (var i = length3 - 1; i >= 0; i--) {
      container.removeChild(children[i]);
    }
  }
  function hasClass(elements, cName) {
    return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
  }
  function regionToBBox(region) {
    var start = region.start, end = region.end;
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    var maxX = Math.max(start.x, end.x);
    var maxY = Math.max(start.y, end.y);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function pointsToBBox(points) {
    var xs = points.map(function(point) {
      return point.x;
    });
    var ys = points.map(function(point) {
      return point.y;
    });
    var minX = Math.min.apply(Math, xs);
    var minY = Math.min.apply(Math, ys);
    var maxX = Math.max.apply(Math, xs);
    var maxY = Math.max.apply(Math, ys);
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  function createBBox(x, y, width, height) {
    var maxX = x + width;
    var maxY = y + height;
    return {
      x,
      y,
      width,
      height,
      minX: x,
      minY: y,
      maxX: isNaN(maxX) ? 0 : maxX,
      maxY: isNaN(maxY) ? 0 : maxY
    };
  }
  function getValueByPercent(min7, max7, percent) {
    return (1 - percent) * min7 + max7 * percent;
  }
  function getCirclePoint(center, radius, angle3) {
    return {
      x: center.x + Math.cos(angle3) * radius,
      y: center.y + Math.sin(angle3) * radius
    };
  }
  function distance4(p1, p22) {
    var dx = p22.x - p1.x;
    var dy = p22.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  var near = function(x, y, e) {
    if (e === void 0) {
      e = Math.pow(Number.EPSILON, 0.5);
    }
    return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
  };
  function intersectBBox2(box1, box2) {
    var minX = Math.max(box1.minX, box2.minX);
    var minY = Math.max(box1.minY, box2.minY);
    var maxX = Math.min(box1.maxX, box2.maxX);
    var maxY = Math.min(box1.maxY, box2.maxY);
    return createBBox(minX, minY, maxX - minX, maxY - minY);
  }
  function getBBoxWithClip(element) {
    var clipShape = element.getClip();
    var clipBBox = clipShape && clipShape.getBBox();
    var bbox;
    if (!element.isGroup()) {
      bbox = element.getBBox();
    } else {
      var minX_1 = Infinity;
      var maxX_1 = -Infinity;
      var minY_1 = Infinity;
      var maxY_1 = -Infinity;
      var children = element.getChildren();
      if (children.length > 0) {
        each_default(children, function(child) {
          if (child.get("visible")) {
            if (child.isGroup() && child.get("children").length === 0) {
              return true;
            }
            var box2 = getBBoxWithClip(child);
            var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
            var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
            var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
            var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
            var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
            var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
            var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
            var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
            if (boxMinX < minX_1) {
              minX_1 = boxMinX;
            }
            if (boxMaxX > maxX_1) {
              maxX_1 = boxMaxX;
            }
            if (boxMinY < minY_1) {
              minY_1 = boxMinY;
            }
            if (boxMaxY > maxY_1) {
              maxY_1 = boxMaxY;
            }
          }
        });
      } else {
        minX_1 = 0;
        maxX_1 = 0;
        minY_1 = 0;
        maxY_1 = 0;
      }
      bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
    }
    if (clipBBox) {
      return intersectBBox2(bbox, clipBBox);
    } else {
      return bbox;
    }
  }
  function updateClip(element, newElement) {
    if (!element.getClip() && !newElement.getClip()) {
      return;
    }
    var newClipShape = newElement.getClip();
    if (!newClipShape) {
      element.setClip(null);
      return;
    }
    var clipCfg = {
      type: newClipShape.get("type"),
      attrs: newClipShape.attr()
    };
    element.setClip(clipCfg);
  }
  function toPx(number) {
    return number + "px";
  }
  function getTextPoint(start, end, position, offset) {
    var lineLength = distance4(start, end);
    var offsetPercent = offset / lineLength;
    var percent = 0;
    if (position === "start") {
      percent = 0 - offsetPercent;
    } else if (position === "end") {
      percent = 1 + offsetPercent;
    }
    return {
      x: getValueByPercent(start.x, end.x, percent),
      y: getValueByPercent(start.y, end.y, percent)
    };
  }

  // node_modules/@antv/component/esm/abstract/component.js
  var LOCATION_FIELD_MAP = {
    none: [],
    point: ["x", "y"],
    region: ["start", "end"],
    points: ["points"],
    circle: ["center", "radius", "startAngle", "endAngle"]
  };
  var Component = function(_super) {
    __extends7(Component2, _super);
    function Component2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initCfg();
      return _this;
    }
    Component2.prototype.getDefaultCfg = function() {
      return {
        id: "",
        name: "",
        type: "",
        locationType: "none",
        offsetX: 0,
        offsetY: 0,
        animate: false,
        capture: true,
        updateAutoRender: false,
        animateOption: {
          appear: null,
          update: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          enter: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          leave: {
            duration: 350,
            easing: "easeQuadIn"
          }
        },
        events: null,
        defaultCfg: {},
        visible: true
      };
    };
    Component2.prototype.clear = function() {
    };
    Component2.prototype.update = function(cfg) {
      var _this = this;
      var defaultCfg = this.get("defaultCfg");
      each_default(cfg, function(value, name) {
        var originCfg = _this.get(name);
        var newCfg = value;
        if (originCfg !== value) {
          if (is_object_default(value) && defaultCfg[name]) {
            newCfg = deep_mix_default({}, defaultCfg[name], value);
          }
          _this.set(name, newCfg);
        }
      });
      this.updateInner(cfg);
      this.afterUpdate(cfg);
    };
    Component2.prototype.updateInner = function(cfg) {
    };
    Component2.prototype.afterUpdate = function(cfg) {
      if (has_key_default(cfg, "visible")) {
        if (cfg.visible) {
          this.show();
        } else {
          this.hide();
        }
      }
      if (has_key_default(cfg, "capture")) {
        this.setCapture(cfg.capture);
      }
    };
    Component2.prototype.getLayoutBBox = function() {
      return this.getBBox();
    };
    Component2.prototype.getLocationType = function() {
      return this.get("locationType");
    };
    Component2.prototype.getOffset = function() {
      return {
        offsetX: this.get("offsetX"),
        offsetY: this.get("offsetY")
      };
    };
    Component2.prototype.setOffset = function(offsetX, offsetY) {
      this.update({
        offsetX,
        offsetY
      });
    };
    Component2.prototype.setLocation = function(cfg) {
      var location = __assign7({}, cfg);
      this.update(location);
    };
    Component2.prototype.getLocation = function() {
      var _this = this;
      var location = {};
      var locationType = this.get("locationType");
      var fields = LOCATION_FIELD_MAP[locationType];
      each_default(fields, function(field) {
        location[field] = _this.get(field);
      });
      return location;
    };
    Component2.prototype.isList = function() {
      return false;
    };
    Component2.prototype.isSlider = function() {
      return false;
    };
    Component2.prototype.init = function() {
    };
    Component2.prototype.initCfg = function() {
      var _this = this;
      var defaultCfg = this.get("defaultCfg");
      each_default(defaultCfg, function(value, name) {
        var cfg = _this.get(name);
        if (is_object_default(cfg)) {
          var newCfg = deep_mix_default({}, value, cfg);
          _this.set(name, newCfg);
        }
      });
    };
    return Component2;
  }(base_default8);
  var component_default = Component;

  // node_modules/@antv/component/esm/abstract/group-component.js
  var STATUS_UPDATE = "update_status";
  var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
  var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
  var GroupComponent = function(_super) {
    __extends7(GroupComponent2, _super);
    function GroupComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        container: null,
        shapesMap: {},
        group: null,
        capture: true,
        isRegister: false,
        isUpdating: false,
        isInit: true
      });
    };
    GroupComponent2.prototype.remove = function() {
      this.clear();
      var group2 = this.get("group");
      group2.remove();
    };
    GroupComponent2.prototype.clear = function() {
      var group2 = this.get("group");
      group2.clear();
      this.set("shapesMap", {});
      this.clearOffScreenCache();
      this.set("isInit", true);
    };
    GroupComponent2.prototype.getChildComponentById = function(id) {
      var group2 = this.getElementById(id);
      var inst = group2 && group2.get("component");
      return inst;
    };
    GroupComponent2.prototype.getElementById = function(id) {
      return this.get("shapesMap")[id];
    };
    GroupComponent2.prototype.getElementByLocalId = function(localId) {
      var id = this.getElementId(localId);
      return this.getElementById(id);
    };
    GroupComponent2.prototype.getElementsByName = function(name) {
      var rst = [];
      each_default(this.get("shapesMap"), function(elem) {
        if (elem.get("name") === name) {
          rst.push(elem);
        }
      });
      return rst;
    };
    GroupComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    GroupComponent2.prototype.updateInner = function(cfg) {
      this.offScreenRender();
      if (this.get("updateAutoRender")) {
        this.render();
      }
    };
    GroupComponent2.prototype.render = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (!offScreenGroup) {
        offScreenGroup = this.offScreenRender();
      }
      var group2 = this.get("group");
      this.updateElements(offScreenGroup, group2);
      this.deleteElements();
      this.applyOffset();
      if (!this.get("eventInitted")) {
        this.initEvent();
        this.set("eventInitted", true);
      }
      this.set("isInit", false);
    };
    GroupComponent2.prototype.show = function() {
      var group2 = this.get("group");
      group2.show();
      this.set("visible", true);
    };
    GroupComponent2.prototype.hide = function() {
      var group2 = this.get("group");
      group2.hide();
      this.set("visible", false);
    };
    GroupComponent2.prototype.setCapture = function(capture) {
      var group2 = this.get("group");
      group2.set("capture", capture);
      this.set("capture", capture);
    };
    GroupComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.remove();
      _super.prototype.destroy.call(this);
    };
    GroupComponent2.prototype.getBBox = function() {
      return this.get("group").getCanvasBBox();
    };
    GroupComponent2.prototype.getLayoutBBox = function() {
      var group2 = this.get("group");
      var bbox = this.getInnerLayoutBBox();
      var matrix = group2.getTotalMatrix();
      if (matrix) {
        bbox = applyMatrix2BBox(matrix, bbox);
      }
      return bbox;
    };
    GroupComponent2.prototype.on = function(evt, callback, once) {
      var group2 = this.get("group");
      group2.on(evt, callback, once);
      return this;
    };
    GroupComponent2.prototype.off = function(evt, callback) {
      var group2 = this.get("group");
      group2 && group2.off(evt, callback);
      return this;
    };
    GroupComponent2.prototype.emit = function(eventName, eventObject) {
      var group2 = this.get("group");
      group2.emit(eventName, eventObject);
    };
    GroupComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      if (!this.get("group")) {
        this.initGroup();
      }
      this.offScreenRender();
    };
    GroupComponent2.prototype.getInnerLayoutBBox = function() {
      return this.get("offScreenBBox") || this.get("group").getBBox();
    };
    GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
      var group2 = this.get("group");
      eventObject.target = group2;
      group2.emit(eventName, eventObject);
      propagationDelegate(group2, eventName, eventObject);
    };
    GroupComponent2.prototype.createOffScreenGroup = function() {
      var group2 = this.get("group");
      var GroupClass = group2.getGroupBase();
      var newGroup = new GroupClass({
        delegateObject: this.getDelegateObject()
      });
      return newGroup;
    };
    GroupComponent2.prototype.applyOffset = function() {
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: offsetX,
        y: offsetY
      });
    };
    GroupComponent2.prototype.initGroup = function() {
      var container = this.get("container");
      this.set("group", container.addGroup({
        id: this.get("id"),
        name: this.get("name"),
        capture: this.get("capture"),
        visible: this.get("visible"),
        isComponent: true,
        component: this,
        delegateObject: this.getDelegateObject()
      }));
    };
    GroupComponent2.prototype.offScreenRender = function() {
      this.clearOffScreenCache();
      var offScreenGroup = this.createOffScreenGroup();
      this.renderInner(offScreenGroup);
      this.set("offScreenGroup", offScreenGroup);
      this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
      return offScreenGroup;
    };
    GroupComponent2.prototype.addGroup = function(parent, cfg) {
      this.appendDelegateObject(parent, cfg);
      var group2 = parent.addGroup(cfg);
      if (this.get("isRegister")) {
        this.registerElement(group2);
      }
      return group2;
    };
    GroupComponent2.prototype.addShape = function(parent, cfg) {
      this.appendDelegateObject(parent, cfg);
      var shape = parent.addShape(cfg);
      if (this.get("isRegister")) {
        this.registerElement(shape);
      }
      return shape;
    };
    GroupComponent2.prototype.addComponent = function(parent, cfg) {
      var id = cfg.id, Ctor = cfg.component, restCfg = __rest7(cfg, ["id", "component"]);
      var inst = new Ctor(__assign7(__assign7({}, restCfg), { id, container: parent, updateAutoRender: this.get("updateAutoRender") }));
      inst.init();
      inst.render();
      if (this.get("isRegister")) {
        this.registerElement(inst.get("group"));
      }
      return inst;
    };
    GroupComponent2.prototype.initEvent = function() {
    };
    GroupComponent2.prototype.removeEvent = function() {
      var group2 = this.get("group");
      group2.off();
    };
    GroupComponent2.prototype.getElementId = function(localId) {
      var id = this.get("id");
      var name = this.get("name");
      return id + "-" + name + "-" + localId;
    };
    GroupComponent2.prototype.registerElement = function(element) {
      var id = element.get("id");
      this.get("shapesMap")[id] = element;
    };
    GroupComponent2.prototype.unregisterElement = function(element) {
      var id = element.get("id");
      delete this.get("shapesMap")[id];
    };
    GroupComponent2.prototype.moveElementTo = function(element, point) {
      var matrix = getMatrixByTranslate(point);
      element.attr("matrix", matrix);
    };
    GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
      var originOpacity = newElement.attr("opacity");
      if (is_nil_default(originOpacity)) {
        originOpacity = 1;
      }
      newElement.attr("opacity", 0);
      newElement.animate({ opacity: originOpacity }, animateCfg);
    };
    GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
      originElement.animate({ opacity: 0 }, animateCfg);
    };
    GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
      originElement.animate(newAttrs, animateCfg);
    };
    GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
      var _this = this;
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      var children = newGroup.getChildren().slice(0);
      var preElement;
      each_default(children, function(element) {
        var elementId = element.get("id");
        var originElement = _this.getElementById(elementId);
        var elementName = element.get("name");
        if (originElement) {
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            var origChildComponent = originElement.get("component");
            var newCfg = pick_default(childComponent.cfg, difference_default(keys_default(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
            origChildComponent.update(newCfg);
            originElement.set(STATUS_UPDATE, "update");
          } else {
            var replaceAttrs = _this.getReplaceAttrs(originElement, element);
            if (animate && animateOption.update) {
              _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
            } else {
              originElement.attr(replaceAttrs);
            }
            if (element.isGroup()) {
              _this.updateElements(element, originElement);
            }
            each_default(COPY_PROPERTIES, function(name) {
              originElement.set(name, element.get(name));
            });
            updateClip(originElement, element);
            preElement = originElement;
            originElement.set(STATUS_UPDATE, "update");
          }
        } else {
          originGroup.add(element);
          var siblings = originGroup.getChildren();
          siblings.splice(siblings.length - 1, 1);
          if (preElement) {
            var index = siblings.indexOf(preElement);
            siblings.splice(index + 1, 0, element);
          } else {
            siblings.unshift(element);
          }
          _this.registerElement(element);
          element.set(STATUS_UPDATE, "add");
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            childComponent.set("container", originGroup);
          } else if (element.isGroup()) {
            _this.registerNewGroup(element);
          }
          preElement = element;
          if (animate) {
            var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
            if (animateCfg) {
              _this.addAnimation(elementName, element, animateCfg);
            }
          }
        }
      });
    };
    GroupComponent2.prototype.clearUpdateStatus = function(group2) {
      var children = group2.getChildren();
      each_default(children, function(el) {
        el.set(STATUS_UPDATE, null);
      });
    };
    GroupComponent2.prototype.clearOffScreenCache = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (offScreenGroup) {
        offScreenGroup.destroy();
      }
      this.set("offScreenGroup", null);
      this.set("offScreenBBox", null);
    };
    GroupComponent2.prototype.getDelegateObject = function() {
      var _a4;
      var name = this.get("name");
      var delegateObject = (_a4 = {}, _a4[name] = this, _a4.component = this, _a4);
      return delegateObject;
    };
    GroupComponent2.prototype.appendDelegateObject = function(parent, cfg) {
      var parentObject = parent.get("delegateObject");
      if (!cfg.delegateObject) {
        cfg.delegateObject = {};
      }
      mix(cfg.delegateObject, parentObject);
    };
    GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
      var originAttrs = originElement.attr();
      var newAttrs = newElement.attr();
      each_default(originAttrs, function(v, k) {
        if (newAttrs[k] === void 0) {
          newAttrs[k] = void 0;
        }
      });
      return newAttrs;
    };
    GroupComponent2.prototype.registerNewGroup = function(group2) {
      var _this = this;
      var children = group2.getChildren();
      each_default(children, function(element) {
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
      });
    };
    GroupComponent2.prototype.deleteElements = function() {
      var _this = this;
      var shapesMap = this.get("shapesMap");
      var deleteArray = [];
      each_default(shapesMap, function(element, id) {
        if (!element.get(STATUS_UPDATE) || element.destroyed) {
          deleteArray.push([id, element]);
        } else {
          element.set(STATUS_UPDATE, null);
        }
      });
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      each_default(deleteArray, function(item) {
        var id = item[0], element = item[1];
        if (!element.destroyed) {
          var elementName = element.get("name");
          if (animate && animateOption.leave) {
            var callbackAnimCfg = mix({
              callback: function() {
                _this.removeElement(element);
              }
            }, animateOption.leave);
            _this.removeAnimation(elementName, element, callbackAnimCfg);
          } else {
            _this.removeElement(element);
          }
        }
        delete shapesMap[id];
      });
    };
    GroupComponent2.prototype.removeElement = function(element) {
      if (element.get("isGroup")) {
        var component = element.get("component");
        if (component) {
          component.destroy();
        }
      }
      element.remove();
    };
    return GroupComponent2;
  }(component_default);
  var group_component_default = GroupComponent;

  // node_modules/@antv/component/esm/util/text.js
  var ELLIPSIS_CODE = "\u2026";
  function strLen(str4) {
    var len3 = 0;
    for (var i = 0; i < str4.length; i++) {
      len3 += charAtLength(str4, i);
    }
    return len3;
  }
  function charAtLength(str4, i) {
    if (str4.charCodeAt(i) > 0 && str4.charCodeAt(i) < 128) {
      return 1;
    } else {
      return 2;
    }
  }
  function ellipsisString(str4, reseveLength, position) {
    if (position === void 0) {
      position = "tail";
    }
    var count2 = str4.length;
    var rst = "";
    if (position === "tail") {
      for (var i = 0, index = 0; i < reseveLength; ) {
        var charLength = charAtLength(str4, index);
        if (i + charLength <= reseveLength) {
          rst += str4[index];
          i += charAtLength(str4, index);
          index++;
        } else {
          break;
        }
      }
      rst += ELLIPSIS_CODE;
    } else if (position === "head") {
      for (var i = 0, index = count2 - 1; i < reseveLength; ) {
        var charLength = charAtLength(str4, index);
        if (i + charLength <= reseveLength) {
          rst += str4[index];
          i += charAtLength(str4, index);
          index--;
        } else {
          break;
        }
      }
      rst = ELLIPSIS_CODE + rst;
    } else {
      var startStr = "";
      var endStr = "";
      for (var i = 0, startIndex = 0, endIndex = count2 - 1; i < reseveLength; ) {
        var startCodeLen = charAtLength(str4, startIndex);
        var hasAdd = false;
        if (startCodeLen + i <= reseveLength) {
          startStr += str4[startIndex];
          startIndex++;
          i += startCodeLen;
          hasAdd = true;
        }
        var endCodeLen = charAtLength(str4, endIndex);
        if (endCodeLen + i <= reseveLength) {
          endStr = str4[endIndex] + endStr;
          i += endCodeLen;
          endIndex--;
          hasAdd = true;
        }
        if (!hasAdd) {
          break;
        }
      }
      rst = startStr + ELLIPSIS_CODE + endStr;
    }
    return rst;
  }

  // node_modules/@antv/component/esm/util/label.js
  var ELLIPSIS_CODE2 = "\u2026";
  var ELLIPSIS_CODE_LENGTH = 2;
  var OPTIMIZE_THRESHOLD = 400;
  function getMaxLabelWidthOptimized(labels) {
    var texts = labels.map(function(label) {
      var text = label.attr("text");
      return is_nil_default(text) ? "" : "" + text;
    });
    var maxLen = 0;
    var maxIdx = 0;
    for (var i = 0; i < texts.length; i += 1) {
      var len3 = 0;
      for (var j = 0; j <= texts[i].length; j += 1) {
        var code = texts[i].charCodeAt(j);
        if (code >= 19968 && code <= 40869) {
          len3 += 2;
        } else {
          len3 += 1;
        }
      }
      if (len3 > maxLen) {
        maxLen = len3;
        maxIdx = i;
      }
    }
    return labels[maxIdx].getBBox().width;
  }
  function getMaxLabelWidth(labels) {
    if (labels.length > OPTIMIZE_THRESHOLD) {
      return getMaxLabelWidthOptimized(labels);
    }
    var max7 = 0;
    each_default(labels, function(label) {
      var bbox = label.getBBox();
      var width = bbox.width;
      if (max7 < width) {
        max7 = width;
      }
    });
    return max7;
  }
  function getLabelLength(isVertical2, label) {
    var bbox = label.getCanvasBBox();
    return isVertical2 ? bbox.width : bbox.height;
  }
  function ellipsisLabel(isVertical2, label, limitLength, position) {
    var _a4;
    if (position === void 0) {
      position = "tail";
    }
    var text = (_a4 = label.attr("text")) !== null && _a4 !== void 0 ? _a4 : "";
    if (position === "tail") {
      var font = pick_default(label.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
      var ellipsisText = get_ellipsis_text_default(text, limitLength, font, "\u2026");
      if (text !== ellipsisText) {
        label.attr("text", ellipsisText);
        label.set("tip", text);
        return true;
      }
      label.set("tip", null);
      return false;
    }
    var labelLength = getLabelLength(isVertical2, label);
    var codeLength = strLen(text);
    var ellipsisFlag = false;
    if (limitLength < labelLength) {
      var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
      var newText = void 0;
      if (reserveLength >= 0) {
        newText = ellipsisString(text, reserveLength, position);
      } else {
        newText = ELLIPSIS_CODE2;
      }
      if (newText) {
        label.attr("text", newText);
        ellipsisFlag = true;
      }
    }
    if (ellipsisFlag) {
      label.set("tip", text);
    } else {
      label.set("tip", null);
    }
    return ellipsisFlag;
  }

  // node_modules/@antv/component/esm/util/graphic.js
  function renderTag(container, tagCfg) {
    var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id = tagCfg.id, name = tagCfg.name, rotate5 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
    var tagGroup = container.addGroup({
      id: id + "-group",
      name: name + "-group",
      attrs: {
        x,
        y
      }
    });
    var text = tagGroup.addShape({
      type: "text",
      id,
      name,
      attrs: __assign7({ x: 0, y: 0, text: content }, style)
    });
    var padding = formatPadding(get_default(background, "padding", 0));
    if (maxLength && autoEllipsis) {
      var maxTextLength = maxLength - (padding[1] + padding[3]);
      ellipsisLabel(!isVertical2, text, maxTextLength, ellipsisPosition);
    }
    if (background) {
      var backgroundStyle = get_default(background, "style", {});
      var _a4 = text.getCanvasBBox(), minX = _a4.minX, minY = _a4.minY, width = _a4.width, height = _a4.height;
      var tagBg = tagGroup.addShape("rect", {
        id: id + "-bg",
        name: id + "-bg",
        attrs: __assign7({ x: minX - padding[3], y: minY - padding[0], width: width + padding[1] + padding[3], height: height + padding[0] + padding[2] }, backgroundStyle)
      });
      tagBg.toBack();
    }
    applyTranslate(tagGroup, x, y);
    applyRotate(tagGroup, rotate5, x, y);
  }

  // node_modules/@antv/component/esm/util/theme.js
  var theme_default = {
    fontFamily: '\n  "-apple-system", BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
    textColor: "#2C3542",
    activeTextColor: "#333333",
    uncheckedColor: "#D8D8D8",
    lineColor: "#416180",
    regionColor: "#CCD7EB",
    verticalAxisRotate: -Math.PI / 4,
    horizontalAxisRotate: Math.PI / 4
  };

  // node_modules/@antv/component/esm/annotation/line.js
  var LineAnnotation = function(_super) {
    __extends7(LineAnnotation2, _super);
    function LineAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "bottom",
          fontFamily: theme_default.fontFamily
        },
        text: {
          position: "center",
          autoRotate: true,
          content: null,
          offsetX: 0,
          offsetY: 0,
          style: {
            stroke: theme_default.lineColor,
            lineWidth: 1
          }
        }
      } });
    };
    LineAnnotation2.prototype.renderInner = function(group2) {
      this.renderLine(group2);
      if (this.get("text")) {
        this.renderLabel(group2);
      }
    };
    LineAnnotation2.prototype.renderLine = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      this.addShape(group2, {
        type: "line",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: __assign7({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style)
      });
    };
    LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
      var percent;
      if (position === "start") {
        percent = 0;
      } else if (position === "center") {
        percent = 0.5;
      } else if (is_string_default(position) && position.indexOf("%") !== -1) {
        percent = parseInt(position, 10) / 100;
      } else if (is_number_default(position)) {
        percent = position;
      } else {
        percent = 1;
      }
      if (percent > 1 || percent < 0) {
        percent = 1;
      }
      return {
        x: getValueByPercent(start.x, end.x, percent),
        y: getValueByPercent(start.y, end.y, percent)
      };
    };
    LineAnnotation2.prototype.renderLabel = function(group2) {
      var text = this.get("text");
      var start = this.get("start");
      var end = this.get("end");
      var position = text.position, content = text.content, style = text.style, offsetX = text.offsetX, offsetY = text.offsetY, autoRotate = text.autoRotate, maxLength = text.maxLength, autoEllipsis = text.autoEllipsis, ellipsisPosition = text.ellipsisPosition, background = text.background, _a4 = text.isVertical, isVertical2 = _a4 === void 0 ? false : _a4;
      var point = this.getLabelPoint(start, end, position);
      var x = point.x + offsetX;
      var y = point.y + offsetY;
      var cfg = {
        id: this.getElementId("line-text"),
        name: "annotation-line-text",
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis,
        ellipsisPosition,
        background,
        isVertical: isVertical2
      };
      if (autoRotate) {
        var vector = [end.x - start.x, end.y - start.y];
        cfg.rotate = Math.atan2(vector[1], vector[0]);
      }
      renderTag(group2, cfg);
    };
    return LineAnnotation2;
  }(group_component_default);
  var line_default4 = LineAnnotation;

  // node_modules/@antv/component/esm/annotation/text.js
  var TextAnnotation = function(_super) {
    __extends7(TextAnnotation2, _super);
    function TextAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TextAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
        style: {
          fill: theme_default.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: theme_default.fontFamily
        }
      } });
    };
    TextAnnotation2.prototype.setLocation = function(location) {
      this.set("x", location.x);
      this.set("y", location.y);
      this.resetLocation();
    };
    TextAnnotation2.prototype.renderInner = function(group2) {
      var _a4 = this.getLocation(), x = _a4.x, y = _a4.y;
      var content = this.get("content");
      var style = this.get("style");
      var id = this.getElementId("text");
      var name = this.get("name") + "-text";
      var maxLength = this.get("maxLength");
      var autoEllipsis = this.get("autoEllipsis");
      var isVertical2 = this.get("isVertical");
      var ellipsisPosition = this.get("ellipsisPosition");
      var background = this.get("background");
      var rotate5 = this.get("rotate");
      var cfg = {
        id,
        name,
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis,
        isVertical: isVertical2,
        ellipsisPosition,
        background,
        rotate: rotate5
      };
      renderTag(group2, cfg);
    };
    TextAnnotation2.prototype.resetLocation = function() {
      var textGroup = this.getElementByLocalId("text-group");
      if (textGroup) {
        var _a4 = this.getLocation(), x = _a4.x, y = _a4.y;
        var rotate5 = this.get("rotate");
        applyTranslate(textGroup, x, y);
        applyRotate(textGroup, rotate5, x, y);
      }
    };
    return TextAnnotation2;
  }(group_component_default);
  var text_default3 = TextAnnotation;

  // node_modules/@antv/component/esm/annotation/arc.js
  var ArcAnnotation = function(_super) {
    __extends7(ArcAnnotation2, _super);
    function ArcAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ArcAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
        stroke: "#999",
        lineWidth: 1
      } });
    };
    ArcAnnotation2.prototype.renderInner = function(group2) {
      this.renderArc(group2);
    };
    ArcAnnotation2.prototype.getArcPath = function() {
      var _a4 = this.getLocation(), center = _a4.center, radius = _a4.radius, startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var startPoint = getCirclePoint(center, radius, startAngle);
      var endPoint = getCirclePoint(center, radius, endAngle);
      var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
      var path = [["M", startPoint.x, startPoint.y]];
      if (endAngle - startAngle === Math.PI * 2) {
        var middlePoint = getCirclePoint(center, radius, startAngle + Math.PI);
        path.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
        path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      } else {
        path.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      }
      return path;
    };
    ArcAnnotation2.prototype.renderArc = function(group2) {
      var path = this.getArcPath();
      var style = this.get("style");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("arc"),
        name: "annotation-arc",
        attrs: __assign7({ path }, style)
      });
    };
    return ArcAnnotation2;
  }(group_component_default);
  var arc_default2 = ArcAnnotation;

  // node_modules/@antv/component/esm/annotation/region.js
  var RegionAnnotation = function(_super) {
    __extends7(RegionAnnotation2, _super);
    function RegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
        style: {
          lineWidth: 0,
          fill: theme_default.regionColor,
          opacity: 0.4
        }
      } });
    };
    RegionAnnotation2.prototype.renderInner = function(group2) {
      this.renderRegion(group2);
    };
    RegionAnnotation2.prototype.renderRegion = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign7({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style)
      });
    };
    return RegionAnnotation2;
  }(group_component_default);
  var region_default = RegionAnnotation;

  // node_modules/@antv/component/esm/annotation/image.js
  var ImageAnnotation = function(_super) {
    __extends7(ImageAnnotation2, _super);
    function ImageAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
    };
    ImageAnnotation2.prototype.renderInner = function(group2) {
      this.renderImage(group2);
    };
    ImageAnnotation2.prototype.getImageAttrs = function() {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      var src = this.get("src");
      return __assign7({ x: bbox.x, y: bbox.y, img: src, width: bbox.width, height: bbox.height }, style);
    };
    ImageAnnotation2.prototype.renderImage = function(group2) {
      this.addShape(group2, {
        type: "image",
        id: this.getElementId("image"),
        name: "annotation-image",
        attrs: this.getImageAttrs()
      });
    };
    return ImageAnnotation2;
  }(group_component_default);
  var image_default = ImageAnnotation;

  // node_modules/@antv/component/esm/annotation/data-marker.js
  var DataMarkerAnnotation = function(_super) {
    __extends7(DataMarkerAnnotation2, _super);
    function DataMarkerAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
        point: {
          display: true,
          style: {
            r: 3,
            fill: "#FFFFFF",
            stroke: "#1890FF",
            lineWidth: 2
          }
        },
        line: {
          display: true,
          length: 20,
          style: {
            stroke: theme_default.lineColor,
            lineWidth: 1
          }
        },
        text: {
          content: "",
          display: true,
          style: {
            fill: theme_default.textColor,
            opacity: 0.65,
            fontSize: 12,
            textAlign: "start",
            fontFamily: theme_default.fontFamily
          }
        }
      } });
    };
    DataMarkerAnnotation2.prototype.renderInner = function(group2) {
      if (get_default(this.get("line"), "display")) {
        this.renderLine(group2);
      }
      if (get_default(this.get("text"), "display")) {
        this.renderText(group2);
      }
      if (get_default(this.get("point"), "display")) {
        this.renderPoint(group2);
      }
      if (this.get("autoAdjust")) {
        this.autoAdjust(group2);
      }
    };
    DataMarkerAnnotation2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x") + this.get("offsetX"),
        y: this.get("y") + this.get("offsetY")
      });
    };
    DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
      var point = this.getShapeAttrs().point;
      this.addShape(group2, {
        type: "circle",
        id: this.getElementId("point"),
        name: "annotation-point",
        attrs: point
      });
    };
    DataMarkerAnnotation2.prototype.renderLine = function(group2) {
      var line = this.getShapeAttrs().line;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: line
      });
    };
    DataMarkerAnnotation2.prototype.renderText = function(group2) {
      var textAttrs = this.getShapeAttrs().text;
      var x = textAttrs.x, y = textAttrs.y, text = textAttrs.text, style = __rest7(textAttrs, ["x", "y", "text"]);
      var _a4 = this.get("text"), background = _a4.background, maxLength = _a4.maxLength, autoEllipsis = _a4.autoEllipsis, isVertival = _a4.isVertival, ellipsisPosition = _a4.ellipsisPosition;
      var tagCfg = {
        x,
        y,
        id: this.getElementId("text"),
        name: "annotation-text",
        content: text,
        style,
        background,
        maxLength,
        autoEllipsis,
        isVertival,
        ellipsisPosition
      };
      renderTag(group2, tagCfg);
    };
    DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
      var direction2 = this.get("direction");
      var x = this.get("x");
      var y = this.get("y");
      var lineLength = get_default(this.get("line"), "length", 0);
      var coordinateBBox = this.get("coordinateBBox");
      var _a4 = group2.getBBox(), minX = _a4.minX, maxX = _a4.maxX, minY = _a4.minY, maxY = _a4.maxY;
      var textGroup = group2.findById(this.getElementId("text-group"));
      var textShape = group2.findById(this.getElementId("text"));
      var lineShape = group2.findById(this.getElementId("line"));
      if (!coordinateBBox) {
        return;
      }
      if (textGroup) {
        if (x + minX <= coordinateBBox.minX) {
          var overflow = coordinateBBox.minX - (x + minX);
          applyTranslate(textGroup, textGroup.attr("x") + overflow, textGroup.attr("y"));
        }
        if (x + maxX >= coordinateBBox.maxX) {
          var overflow = x + maxX - coordinateBBox.maxX;
          applyTranslate(textGroup, textGroup.attr("x") - overflow, textGroup.attr("y"));
        }
      }
      if (direction2 === "upward" && y + minY <= coordinateBBox.minY || direction2 !== "upward" && y + maxY >= coordinateBBox.maxY) {
        var textBaseline = void 0;
        var factor = void 0;
        if (direction2 === "upward" && y + minY <= coordinateBBox.minY) {
          textBaseline = "top";
          factor = 1;
        } else {
          textBaseline = "bottom";
          factor = -1;
        }
        textShape.attr("textBaseline", textBaseline);
        if (lineShape) {
          lineShape.attr("path", [
            ["M", 0, 0],
            ["L", 0, lineLength * factor]
          ]);
        }
        applyTranslate(textGroup, textGroup.attr("x"), (lineLength + 2) * factor);
      }
    };
    DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
      var lineDisplay = get_default(this.get("line"), "display");
      var pointStyle = get_default(this.get("point"), "style", {});
      var lineStyle = get_default(this.get("line"), "style", {});
      var textStyle2 = get_default(this.get("text"), "style", {});
      var direction2 = this.get("direction");
      var lineLength = lineDisplay ? get_default(this.get("line"), "length", 0) : 0;
      var factor = direction2 === "upward" ? -1 : 1;
      return {
        point: __assign7({ x: 0, y: 0 }, pointStyle),
        line: __assign7({ path: [
          ["M", 0, 0],
          ["L", 0, lineLength * factor]
        ] }, lineStyle),
        text: __assign7({ x: 0, y: (lineLength + 2) * factor, text: get_default(this.get("text"), "content", ""), textBaseline: direction2 === "upward" ? "bottom" : "top" }, textStyle2)
      };
    };
    return DataMarkerAnnotation2;
  }(group_component_default);
  var data_marker_default = DataMarkerAnnotation;

  // node_modules/@antv/component/esm/annotation/data-region.js
  var DataRegionAnnotation = function(_super) {
    __extends7(DataRegionAnnotation2, _super);
    function DataRegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataRegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
        region: {
          style: {
            lineWidth: 0,
            fill: theme_default.regionColor,
            opacity: 0.4
          }
        },
        text: {
          content: "",
          style: {
            textAlign: "center",
            textBaseline: "bottom",
            fontSize: 12,
            fill: theme_default.textColor,
            fontFamily: theme_default.fontFamily
          }
        }
      } });
    };
    DataRegionAnnotation2.prototype.renderInner = function(group2) {
      var regionStyle = get_default(this.get("region"), "style", {});
      var textStyle2 = get_default(this.get("text"), "style", {});
      var lineLength = this.get("lineLength") || 0;
      var points = this.get("points");
      if (!points.length) {
        return;
      }
      var bbox = pointsToBBox(points);
      var path = [];
      path.push(["M", points[0].x, bbox.minY - lineLength]);
      points.forEach(function(point) {
        path.push(["L", point.x, point.y]);
      });
      path.push(["L", points[points.length - 1].x, points[points.length - 1].y - lineLength]);
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign7({ path }, regionStyle)
      });
      var textCfg = __assign7({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
      renderTag(group2, textCfg);
    };
    return DataRegionAnnotation2;
  }(group_component_default);
  var data_region_default = DataRegionAnnotation;

  // node_modules/@antv/component/esm/annotation/region-filter.js
  var RegionFilterAnnotation = function(_super) {
    __extends7(RegionFilterAnnotation2, _super);
    function RegionFilterAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
    };
    RegionFilterAnnotation2.prototype.renderInner = function(group2) {
      var _this = this;
      var start = this.get("start");
      var end = this.get("end");
      var layer = this.addGroup(group2, {
        id: this.getElementId("region-filter"),
        capture: false
      });
      each_default(this.get("shapes"), function(shape, shapeIdx) {
        var type = shape.get("type");
        var attrs = clone_default(shape.attr());
        _this.adjustShapeAttrs(attrs);
        _this.addShape(layer, {
          id: _this.getElementId("shape-" + type + "-" + shapeIdx),
          capture: false,
          type,
          attrs
        });
      });
      var clipBBox = regionToBBox({ start, end });
      layer.setClip({
        type: "rect",
        attrs: {
          x: clipBBox.minX,
          y: clipBBox.minY,
          width: clipBBox.width,
          height: clipBBox.height
        }
      });
    };
    RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
      var color2 = this.get("color");
      if (attr.fill) {
        attr.fill = attr.fillStyle = color2;
      }
      attr.stroke = attr.strokeStyle = color2;
    };
    return RegionFilterAnnotation2;
  }(group_component_default);
  var region_filter_default = RegionFilterAnnotation;

  // node_modules/@antv/component/esm/annotation/shape.js
  var ShapeAnnotation = function(_super) {
    __extends7(ShapeAnnotation2, _super);
    function ShapeAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "shape", draw: noop_default });
    };
    ShapeAnnotation2.prototype.renderInner = function(group2) {
      var render = this.get("render");
      if (is_function_default(render)) {
        render(group2);
      }
    };
    return ShapeAnnotation2;
  }(group_component_default);
  var shape_default4 = ShapeAnnotation;

  // node_modules/@antv/component/esm/abstract/html-component.js
  var HtmlComponent = function(_super) {
    __extends7(HtmlComponent2, _super);
    function HtmlComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
      return cfg;
    };
    HtmlComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    HtmlComponent2.prototype.show = function() {
      var container = this.get("container");
      container.style.display = "";
      this.set("visible", true);
    };
    HtmlComponent2.prototype.hide = function() {
      var container = this.get("container");
      container.style.display = "none";
      this.set("visible", false);
    };
    HtmlComponent2.prototype.setCapture = function(capture) {
      var container = this.getContainer();
      var value = capture ? "auto" : "none";
      container.style.pointerEvents = value;
      this.set("capture", capture);
    };
    HtmlComponent2.prototype.getBBox = function() {
      var container = this.getContainer();
      var x = parseFloat(container.style.left) || 0;
      var y = parseFloat(container.style.top) || 0;
      return createBBox(x, y, container.clientWidth, container.clientHeight);
    };
    HtmlComponent2.prototype.clear = function() {
      var container = this.get("container");
      clearDom(container);
    };
    HtmlComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    HtmlComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.initContainer();
      this.initDom();
      this.resetStyles();
      this.applyStyles();
      this.initEvent();
      this.initCapture();
      this.initVisible();
    };
    HtmlComponent2.prototype.initCapture = function() {
      this.setCapture(this.get("capture"));
    };
    HtmlComponent2.prototype.initVisible = function() {
      if (!this.get("visible")) {
        this.hide();
      } else {
        this.show();
      }
    };
    HtmlComponent2.prototype.initDom = function() {
    };
    HtmlComponent2.prototype.initContainer = function() {
      var container = this.get("container");
      if (is_nil_default(container)) {
        container = this.createDom();
        var parent_1 = this.get("parent");
        if (is_string_default(parent_1)) {
          parent_1 = document.getElementById(parent_1);
          this.set("parent", parent_1);
        }
        parent_1.appendChild(container);
        this.set("container", container);
      } else if (is_string_default(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
      if (!this.get("parent")) {
        this.set("parent", container.parentNode);
      }
    };
    HtmlComponent2.prototype.resetStyles = function() {
      var style = this.get("domStyles");
      var defaultStyles = this.get("defaultStyles");
      if (!style) {
        style = defaultStyles;
      } else {
        style = deep_mix_default({}, defaultStyles, style);
      }
      this.set("domStyles", style);
    };
    HtmlComponent2.prototype.applyStyles = function() {
      var domStyles = this.get("domStyles");
      if (!domStyles) {
        return;
      }
      var container = this.getContainer();
      this.applyChildrenStyles(container, domStyles);
      var containerClassName = this.get("containerClassName");
      if (containerClassName && hasClass(container, containerClassName)) {
        var containerCss = domStyles[containerClassName];
        modifyCSS(container, containerCss);
      }
    };
    HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
      each_default(styles, function(style, name) {
        var elements = element.getElementsByClassName(name);
        each_default(elements, function(el) {
          modifyCSS(el, style);
        });
      });
    };
    HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
      var domStyles = this.get("domStyles");
      modifyCSS(dom, domStyles[cssName]);
    };
    HtmlComponent2.prototype.createDom = function() {
      var containerTpl = this.get("containerTpl");
      return createDom(containerTpl);
    };
    HtmlComponent2.prototype.initEvent = function() {
    };
    HtmlComponent2.prototype.removeDom = function() {
      var container = this.get("container");
      container && container.parentNode && container.parentNode.removeChild(container);
    };
    HtmlComponent2.prototype.removeEvent = function() {
    };
    HtmlComponent2.prototype.updateInner = function(cfg) {
      if (has_key_default(cfg, "domStyles")) {
        this.resetStyles();
        this.applyStyles();
      }
      this.resetPosition();
    };
    HtmlComponent2.prototype.resetPosition = function() {
    };
    ;
    return HtmlComponent2;
  }(component_default);
  var html_component_default = HtmlComponent;

  // node_modules/@antv/component/esm/annotation/html.js
  var HtmlAnnotation = function(_super) {
    __extends7(HtmlAnnotation2, _super);
    function HtmlAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
    };
    HtmlAnnotation2.prototype.render = function() {
      var container = this.getContainer();
      var html = this.get("html");
      clearDom(container);
      var rst = is_function_default(html) ? html(container) : html;
      if (is_element_default(rst)) {
        container.appendChild(rst);
      } else if (is_string_default(rst)) {
        container.appendChild(createDom(rst));
      }
      this.resetPosition();
    };
    HtmlAnnotation2.prototype.resetPosition = function() {
      var container = this.getContainer();
      var _a4 = this.getLocation(), x = _a4.x, y = _a4.y;
      var alignX = this.get("alignX");
      var alignY = this.get("alignY");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      var domWidth = getOuterWidth(container);
      var domHeight = getOuterHeight(container);
      var position = {
        x,
        y
      };
      if (alignX === "middle") {
        position.x -= Math.round(domWidth / 2);
      } else if (alignX === "right") {
        position.x -= Math.round(domWidth);
      }
      if (alignY === "middle") {
        position.y -= Math.round(domHeight / 2);
      } else if (alignY === "bottom") {
        position.y -= Math.round(domHeight);
      }
      if (offsetX) {
        position.x += offsetX;
      }
      if (offsetY) {
        position.y += offsetY;
      }
      modifyCSS(container, {
        position: "absolute",
        left: position.x + "px",
        top: position.y + "px",
        zIndex: this.get("zIndex")
      });
    };
    return HtmlAnnotation2;
  }(html_component_default);
  var html_default = HtmlAnnotation;

  // node_modules/@antv/component/esm/axis/index.js
  var axis_exports = {};
  __export(axis_exports, {
    Base: () => base_default9,
    Circle: () => circle_default3,
    Line: () => line_default5
  });

  // node_modules/@antv/component/esm/util/state.js
  function getStatesStyle(item, elementName, stateStyles) {
    var styleName = elementName + "Style";
    var styles = null;
    each_default(stateStyles, function(v, state) {
      if (item[state] && v[styleName]) {
        if (!styles) {
          styles = {};
        }
        mix(styles, v[styleName]);
      }
    });
    return styles;
  }

  // node_modules/@antv/component/esm/axis/base.js
  var AxisBase = function(_super) {
    __extends7(AxisBase2, _super);
    function AxisBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        name: "axis",
        ticks: [],
        line: {},
        tickLine: {},
        subTickLine: null,
        title: null,
        label: {},
        verticalFactor: 1,
        verticalLimitLength: null,
        overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
        tickStates: {},
        optimize: {},
        defaultCfg: {
          line: {
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            }
          },
          tickLine: {
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            },
            alignTick: true,
            length: 5,
            displayWithLabel: true
          },
          subTickLine: {
            style: {
              lineWidth: 1,
              stroke: theme_default.lineColor
            },
            count: 4,
            length: 2
          },
          label: {
            autoRotate: true,
            autoHide: false,
            autoEllipsis: false,
            style: {
              fontSize: 12,
              fill: theme_default.textColor,
              fontFamily: theme_default.fontFamily,
              fontWeight: "normal"
            },
            offset: 10,
            offsetX: 0,
            offsetY: 0
          },
          title: {
            autoRotate: true,
            spacing: 5,
            position: "center",
            style: {
              fontSize: 12,
              fill: theme_default.textColor,
              textBaseline: "middle",
              fontFamily: theme_default.fontFamily,
              textAlign: "center"
            }
          },
          tickStates: {
            active: {
              labelStyle: {
                fontWeight: 500
              },
              tickLineStyle: {
                lineWidth: 2
              }
            },
            inactive: {
              labelStyle: {
                fill: theme_default.uncheckedColor
              }
            }
          },
          optimize: {
            enable: true,
            threshold: 400
          }
        },
        theme: {}
      });
    };
    AxisBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.drawLine(group2);
      }
      this.drawTicks(group2);
      if (this.get("title")) {
        this.drawTitle(group2);
      }
    };
    AxisBase2.prototype.isList = function() {
      return true;
    };
    AxisBase2.prototype.getItems = function() {
      return this.get("ticks");
    };
    AxisBase2.prototype.setItems = function(items) {
      this.update({
        ticks: items
      });
    };
    AxisBase2.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    AxisBase2.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("label-group");
      itemGroup && itemGroup.clear();
    };
    AxisBase2.prototype.setItemState = function(item, state, value) {
      item[state] = value;
      this.updateTickStates(item);
    };
    AxisBase2.prototype.hasState = function(item, state) {
      return !!item[state];
    };
    AxisBase2.prototype.getItemStates = function(item) {
      var tickStates = this.get("tickStates");
      var rst = [];
      each_default(tickStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    AxisBase2.prototype.clearItemsState = function(state) {
      var _this = this;
      var items = this.getItemsByState(state);
      each_default(items, function(item) {
        _this.setItemState(item, state, false);
      });
    };
    AxisBase2.prototype.getItemsByState = function(state) {
      var _this = this;
      var items = this.getItems();
      return filter_default(items, function(item) {
        return _this.hasState(item, state);
      });
    };
    AxisBase2.prototype.getSidePoint = function(point, offset) {
      var self2 = this;
      var vector = self2.getSideVector(offset, point);
      return {
        x: point.x + vector[0],
        y: point.y + vector[1]
      };
    };
    AxisBase2.prototype.getTextAnchor = function(vector) {
      var align;
      if (isNumberEqual(vector[0], 0)) {
        align = "center";
      } else if (vector[0] > 0) {
        align = "start";
      } else if (vector[0] < 0) {
        align = "end";
      }
      return align;
    };
    AxisBase2.prototype.getTextBaseline = function(vector) {
      var base2;
      if (isNumberEqual(vector[1], 0)) {
        base2 = "middle";
      } else if (vector[1] > 0) {
        base2 = "top";
      } else if (vector[1] < 0) {
        base2 = "bottom";
      }
      return base2;
    };
    AxisBase2.prototype.processOverlap = function(labelGroup) {
    };
    AxisBase2.prototype.drawLine = function(group2) {
      var path = this.getLinePath();
      var line = this.get("line");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "axis-line",
        attrs: mix({
          path
        }, line.style)
      });
    };
    AxisBase2.prototype.getTickLineItems = function(ticks) {
      var _this = this;
      var tickLineItems = [];
      var tickLine = this.get("tickLine");
      var alignTick = tickLine.alignTick;
      var tickLineLength = tickLine.length;
      var tickSegment = 1;
      var tickCount = ticks.length;
      if (tickCount >= 2) {
        tickSegment = ticks[1].value - ticks[0].value;
      }
      each_default(ticks, function(tick2) {
        var point = tick2.point;
        if (!alignTick) {
          point = _this.getTickPoint(tick2.value - tickSegment / 2);
        }
        var endPoint = _this.getSidePoint(point, tickLineLength);
        tickLineItems.push({
          startPoint: point,
          tickValue: tick2.value,
          endPoint,
          tickId: tick2.id,
          id: "tickline-" + tick2.id
        });
      });
      return tickLineItems;
    };
    AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
      var subTickLineItems = [];
      var subTickLine = this.get("subTickLine");
      var subCount = subTickLine.count;
      var tickLineCount = tickLineItems.length;
      if (tickLineCount >= 2) {
        for (var i = 0; i < tickLineCount - 1; i++) {
          var pre = tickLineItems[i];
          var next = tickLineItems[i + 1];
          for (var j = 0; j < subCount; j++) {
            var percent = (j + 1) / (subCount + 1);
            var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;
            var point = this.getTickPoint(tickValue);
            var endPoint = this.getSidePoint(point, subTickLine.length);
            subTickLineItems.push({
              startPoint: point,
              endPoint,
              tickValue,
              id: "sub-" + pre.id + "-" + j
            });
          }
        }
      }
      return subTickLineItems;
    };
    AxisBase2.prototype.getTickLineAttrs = function(tickItem, type, index, tickItems) {
      var style = this.get(type).style;
      var item = {
        points: [tickItem.startPoint, tickItem.endPoint]
      };
      var defaultTickLineStyle = get_default(this.get("theme"), ["tickLine", "style"], {});
      style = is_function_default(style) ? mix({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
      var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
      return __assign7({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
    };
    AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type, index, tickItems) {
      this.addShape(tickLineGroup, {
        type: "line",
        id: this.getElementId(tickItem.id),
        name: "axis-" + type,
        attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
      });
    };
    AxisBase2.prototype.drawTickLines = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var subTickLine = this.get("subTickLine");
      var tickLineItems = this.getTickLineItems(ticks);
      var tickLineGroup = this.addGroup(group2, {
        name: "axis-tickline-group",
        id: this.getElementId("tickline-group")
      });
      var tickCfg = this.get("tickLine");
      each_default(tickLineItems, function(item, index) {
        if (tickCfg.displayWithLabel) {
          var labelId = _this.getElementId("label-" + item.tickId);
          if (group2.findById(labelId)) {
            _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
          }
        } else {
          _this.drawTick(item, tickLineGroup, "tickLine", index, tickLineItems);
        }
      });
      if (subTickLine) {
        var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
        each_default(subTickLineItems_1, function(item, index) {
          _this.drawTick(item, tickLineGroup, "subTickLine", index, subTickLineItems_1);
        });
      }
    };
    AxisBase2.prototype.processTicks = function() {
      var _this = this;
      var ticks = this.get("ticks");
      each_default(ticks, function(tick2) {
        tick2.point = _this.getTickPoint(tick2.value);
        if (is_nil_default(tick2.id)) {
          tick2.id = tick2.name;
        }
      });
    };
    AxisBase2.prototype.drawTicks = function(group2) {
      var _this = this;
      this.optimizeTicks();
      this.processTicks();
      if (this.get("label")) {
        this.drawLabels(group2);
      }
      if (this.get("tickLine")) {
        this.drawTickLines(group2);
      }
      var ticks = this.get("ticks");
      each_default(ticks, function(tick2) {
        _this.applyTickStates(tick2, group2);
      });
    };
    AxisBase2.prototype.optimizeTicks = function() {
      var optimize = this.get("optimize");
      var ticks = this.get("ticks");
      if (optimize && optimize.enable && optimize.threshold > 0) {
        var len3 = size2(ticks);
        if (len3 > optimize.threshold) {
          var page_1 = Math.ceil(len3 / optimize.threshold);
          var optimizedTicks = ticks.filter(function(tick2, idx) {
            return idx % page_1 === 0;
          });
          this.set("ticks", optimizedTicks);
          this.set("originalTicks", ticks);
        }
      }
    };
    AxisBase2.prototype.getLabelAttrs = function(tick2, index, ticks) {
      var labelCfg = this.get("label");
      var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate5 = labelCfg.rotate, formatter = labelCfg.formatter;
      var point = this.getSidePoint(tick2.point, offset);
      var vector = this.getSideVector(offset, point);
      var text = formatter ? formatter(tick2.name, tick2, index) : tick2.name;
      var style = labelCfg.style;
      style = is_function_default(style) ? get_default(this.get("theme"), ["label", "style"], {}) : style;
      var attrs = mix({
        x: point.x + offsetX,
        y: point.y + offsetY,
        text,
        textAlign: this.getTextAnchor(vector),
        textBaseline: this.getTextBaseline(vector)
      }, style);
      if (rotate5) {
        attrs.matrix = getMatrixByAngle(point, rotate5);
      }
      return attrs;
    };
    AxisBase2.prototype.drawLabels = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var labelGroup = this.addGroup(group2, {
        name: "axis-label-group",
        id: this.getElementId("label-group")
      });
      each_default(ticks, function(tick2, index) {
        _this.addShape(labelGroup, {
          type: "text",
          name: "axis-label",
          id: _this.getElementId("label-" + tick2.id),
          attrs: _this.getLabelAttrs(tick2, index, ticks),
          delegateObject: {
            tick: tick2,
            item: tick2,
            index
          }
        });
      });
      this.processOverlap(labelGroup);
      var labels = labelGroup.getChildren();
      var defaultLabelStyle = get_default(this.get("theme"), ["label", "style"], {});
      var _a4 = this.get("label"), style = _a4.style, formatter = _a4.formatter;
      if (is_function_default(style)) {
        var afterProcessTicks_1 = labels.map(function(label) {
          return get_default(label.get("delegateObject"), "tick");
        });
        each_default(labels, function(label, index) {
          var tick2 = label.get("delegateObject").tick;
          var text = formatter ? formatter(tick2.name, tick2, index) : tick2.name;
          var newStyle = mix({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
          label.attr(newStyle);
        });
      }
    };
    AxisBase2.prototype.getTitleAttrs = function() {
      var titleCfg = this.get("title");
      var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a4 = titleCfg.spacing, spacing = _a4 === void 0 ? 0 : _a4, autoRotate = titleCfg.autoRotate;
      var titleHeight = style.fontSize;
      var percent = 0.5;
      if (position === "start") {
        percent = 0;
      } else if (position === "end") {
        percent = 1;
      }
      var point = this.getTickPoint(percent);
      var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2);
      var attrs = mix({
        x: titlePoint.x,
        y: titlePoint.y,
        text: titleCfg.text
      }, style);
      var rotate5 = titleCfg.rotate;
      var angle3 = rotate5;
      if (is_nil_default(rotate5) && autoRotate) {
        var vector = this.getAxisVector(point);
        var v1 = [1, 0];
        angle3 = ext_exports.angleTo(vector, v1, true);
      }
      if (angle3) {
        var matrix = getMatrixByAngle(titlePoint, angle3);
        attrs.matrix = matrix;
      }
      return attrs;
    };
    AxisBase2.prototype.drawTitle = function(group2) {
      this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "axis-title",
        attrs: this.getTitleAttrs()
      });
    };
    AxisBase2.prototype.applyTickStates = function(tick2, group2) {
      var states = this.getItemStates(tick2);
      if (states.length) {
        var tickStates = this.get("tickStates");
        var labelId = this.getElementId("label-" + tick2.id);
        var labelShape = group2.findById(labelId);
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick2, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        var tickLineId = this.getElementId("tickline-" + tick2.id);
        var tickLineShape = group2.findById(tickLineId);
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick2, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      }
    };
    AxisBase2.prototype.updateTickStates = function(tick2) {
      var states = this.getItemStates(tick2);
      var tickStates = this.get("tickStates");
      var labelCfg = this.get("label");
      var labelShape = this.getElementByLocalId("label-" + tick2.id);
      var tickLineCfg = this.get("tickLine");
      var tickLineShape = this.getElementByLocalId("tickline-" + tick2.id);
      if (states.length) {
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick2, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick2, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      } else {
        if (labelShape) {
          labelShape.attr(labelCfg.style);
        }
        if (tickLineShape) {
          tickLineShape.attr(tickLineCfg.style);
        }
      }
    };
    return AxisBase2;
  }(group_component_default);
  var base_default9 = AxisBase;

  // node_modules/@antv/component/esm/axis/overlap/index.js
  var overlap_exports = {};
  __export(overlap_exports, {
    autoEllipsis: () => auto_ellipsis_exports,
    autoHide: () => auto_hide_exports,
    autoRotate: () => auto_rotate_exports
  });

  // node_modules/@antv/component/esm/axis/overlap/auto-ellipsis.js
  var auto_ellipsis_exports = {};
  __export(auto_ellipsis_exports, {
    ellipsisHead: () => ellipsisHead,
    ellipsisMiddle: () => ellipsisMiddle,
    ellipsisTail: () => ellipsisTail,
    getDefault: () => getDefault
  });
  function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
    var children = labelGroup.getChildren();
    var ellipsisFlag = false;
    each_default(children, function(label) {
      var rst = ellipsisLabel(isVertical2, label, limitLength, position);
      ellipsisFlag = ellipsisFlag || rst;
    });
    return ellipsisFlag;
  }
  function getDefault() {
    return ellipsisTail;
  }
  function ellipsisHead(isVertical2, labelGroup, limitLength) {
    return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
  }
  function ellipsisTail(isVertical2, labelGroup, limitLength) {
    return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
  }
  function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
    return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
  }

  // node_modules/@antv/component/esm/axis/overlap/auto-hide.js
  var auto_hide_exports = {};
  __export(auto_hide_exports, {
    equidistance: () => equidistance,
    equidistanceWithReverseBoth: () => equidistanceWithReverseBoth,
    getDefault: () => getDefault2,
    reserveBoth: () => reserveBoth,
    reserveFirst: () => reserveFirst,
    reserveLast: () => reserveLast
  });
  function isRotate(label) {
    var matrix = label.attr("matrix");
    return matrix && matrix[0] !== 1;
  }
  function getRotateAngle(label) {
    var angle3 = isRotate(label) ? getAngleByMatrix(label.attr("matrix")) : 0;
    return angle3 % 360;
  }
  function isOverlap(isVertical2, first, second, minGap) {
    var overlap2 = false;
    var angle3 = getRotateAngle(first);
    var distance8 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
    var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
    if (isVertical2) {
      var ratio = Math.abs(Math.cos(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        overlap2 = prevBBox.width + minGap > distance8;
      } else {
        overlap2 = prevBBox.height / ratio + minGap > distance8;
      }
    } else {
      var ratio = Math.abs(Math.sin(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        overlap2 = prevBBox.width + minGap > distance8;
      } else {
        overlap2 = prevBBox.height / ratio + minGap > distance8;
      }
    }
    return overlap2;
  }
  function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice().filter(function(item) {
      return item.get("visible");
    });
    if (!labels.length) {
      return false;
    }
    var hasHide = false;
    if (reversed) {
      labels.reverse();
    }
    var count2 = labels.length;
    var first = labels[0];
    var prev = first;
    for (var i = 1; i < count2; i++) {
      var label = labels[i];
      var curBBox = label.getBBox();
      var isHide = isOverlap(isVertical2, prev, label, minGap);
      if (isHide) {
        label.hide();
        hasHide = true;
      } else {
        prev = label;
      }
    }
    return hasHide;
  }
  function parityHide(isVertical2, labelsGroup, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice();
    if (labels.length < 2) {
      return false;
    }
    var hasHide = false;
    var first = labels[0];
    var firstBBox = first.getBBox();
    var second = labels[1];
    var count2 = labels.length;
    var angle3 = getRotateAngle(first);
    var distance8 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
    var interval2 = 0;
    if (isVertical2) {
      var ratio = Math.abs(Math.cos(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        var maxWidth = getMaxLabelWidth(labels);
        interval2 = (maxWidth + minGap) / distance8;
      } else {
        interval2 = (firstBBox.height / ratio + minGap) / distance8;
      }
    } else {
      var ratio = Math.abs(Math.sin(angle3));
      if (near(ratio, 0, Math.PI / 180)) {
        var maxWidth = getMaxLabelWidth(labels);
        interval2 = (maxWidth + minGap) / distance8;
      } else {
        interval2 = (firstBBox.height / ratio + minGap) / distance8;
      }
    }
    if (interval2 > 1) {
      interval2 = Math.ceil(interval2);
      for (var i = 0; i < count2; i++) {
        if (i % interval2 !== 0) {
          labels[i].hide();
          hasHide = true;
        }
      }
    }
    return hasHide;
  }
  function getDefault2() {
    return equidistance;
  }
  function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
  }
  function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
  }
  function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
    var labels = labelsGroup.getChildren().slice();
    if (labels.length <= 2) {
      return false;
    }
    var hasHide = false;
    var count2 = labels.length;
    var first = labels[0];
    var last2 = labels[count2 - 1];
    var preLabel = first;
    for (var i = 1; i < count2 - 1; i++) {
      var label = labels[i];
      var curBBox = label.getBBox();
      var isHide = isOverlap(isVertical2, preLabel, label, minGap);
      if (isHide) {
        label.hide();
        hasHide = true;
      } else {
        preLabel = label;
      }
    }
    var overlap2 = isOverlap(isVertical2, preLabel, last2, minGap);
    if (overlap2) {
      preLabel.hide();
      hasHide = true;
    }
    return hasHide;
  }
  function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
    if (reserveOne(isVertical2, labelsGroup, false)) {
      hasHide = true;
    }
    return hasHide;
  }
  function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
    var labels = labelsGroup.getChildren().slice();
    var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
    if (labels.length > 2) {
      var first = labels[0];
      var last2 = labels[labels.length - 1];
      if (!first.get("visible")) {
        first.show();
        if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
          hasHide = true;
        }
      }
      if (!last2.get("visible")) {
        last2.show();
        if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
          hasHide = true;
        }
      }
    }
    return hasHide;
  }

  // node_modules/@antv/component/esm/axis/overlap/auto-rotate.js
  var auto_rotate_exports = {};
  __export(auto_rotate_exports, {
    fixedAngle: () => fixedAngle,
    getDefault: () => getDefault3,
    unfixedAngle: () => unfixedAngle
  });
  function setLabelsAngle(labels, angle3) {
    each_default(labels, function(label) {
      var x = label.attr("x");
      var y = label.attr("y");
      var matrix = getMatrixByAngle({ x, y }, angle3);
      label.attr("matrix", matrix);
    });
  }
  function labelRotate(isVertical2, labelsGroup, limitLength, getAngle4) {
    var labels = labelsGroup.getChildren();
    if (!labels.length) {
      return false;
    }
    if (!isVertical2 && labels.length < 2) {
      return false;
    }
    var maxWidth = getMaxLabelWidth(labels);
    var isOverlap2 = false;
    if (isVertical2) {
      isOverlap2 = !!limitLength && maxWidth > limitLength;
    } else {
      var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
      isOverlap2 = maxWidth > tickWidth;
    }
    if (isOverlap2) {
      var angle3 = getAngle4(limitLength, maxWidth);
      setLabelsAngle(labels, angle3);
    }
    return isOverlap2;
  }
  function getDefault3() {
    return fixedAngle;
  }
  function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
    return labelRotate(isVertical2, labelsGroup, limitLength, function() {
      if (is_number_default(customRotate)) {
        return customRotate;
      }
      return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
    });
  }
  function unfixedAngle(isVertical2, labelsGroup, limitLength) {
    return labelRotate(isVertical2, labelsGroup, limitLength, function(length3, maxWidth) {
      if (!length3) {
        return isVertical2 ? theme_default.verticalAxisRotate : theme_default.horizontalAxisRotate;
      }
      if (isVertical2) {
        return -Math.acos(length3 / maxWidth);
      } else {
        var angle3 = 0;
        if (length3 > maxWidth) {
          angle3 = Math.PI / 4;
        } else {
          angle3 = Math.asin(length3 / maxWidth);
          if (angle3 > Math.PI / 4) {
            angle3 = Math.PI / 4;
          }
        }
        return angle3;
      }
    });
  }

  // node_modules/@antv/component/esm/axis/line.js
  var Line = function(_super) {
    __extends7(Line6, _super);
    function Line6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        type: "line",
        locationType: "region",
        start: null,
        end: null
      });
    };
    Line6.prototype.getLinePath = function() {
      var start = this.get("start");
      var end = this.get("end");
      var path = [];
      path.push(["M", start.x, start.y]);
      path.push(["L", end.x, end.y]);
      return path;
    };
    Line6.prototype.getInnerLayoutBBox = function() {
      var start = this.get("start");
      var end = this.get("end");
      var bbox = _super.prototype.getInnerLayoutBBox.call(this);
      var minX = Math.min(start.x, end.x, bbox.x);
      var minY = Math.min(start.y, end.y, bbox.y);
      var maxX = Math.max(start.x, end.x, bbox.maxX);
      var maxY = Math.max(start.y, end.y, bbox.maxY);
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
    };
    Line6.prototype.isVertical = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual(start.x, end.x);
    };
    Line6.prototype.isHorizontal = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual(start.y, end.y);
    };
    Line6.prototype.getTickPoint = function(tickValue) {
      var self2 = this;
      var start = self2.get("start");
      var end = self2.get("end");
      var regionX = end.x - start.x;
      var regionY = end.y - start.y;
      return {
        x: start.x + regionX * tickValue,
        y: start.y + regionY * tickValue
      };
    };
    Line6.prototype.getSideVector = function(offset) {
      var axisVector = this.getAxisVector();
      var normal = vec2_exports.normalize([0, 0], axisVector);
      var factor = this.get("verticalFactor");
      var verticalVector = [normal[1], normal[0] * -1];
      return vec2_exports.scale([0, 0], verticalVector, offset * factor);
    };
    Line6.prototype.getAxisVector = function() {
      var start = this.get("start");
      var end = this.get("end");
      return [end.x - start.x, end.y - start.y];
    };
    Line6.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var isHorizontal = this.isHorizontal();
      if (!isVertical2 && !isHorizontal) {
        return;
      }
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each_default(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (is_nil_default(titleCfg.offset)) {
          var bbox = labelGroup.getCanvasBBox();
          var length_1 = isVertical2 ? bbox.width : bbox.height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Line6.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return is_nil_default(labelCfg.rotate);
      }
      return true;
    };
    Line6.prototype.autoProcessOverlap = function(name, value, labelGroup, limitLength) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var hasAdjusted = false;
      var util75 = overlap_exports[name];
      if (value === true) {
        var labelCfg = this.get("label");
        hasAdjusted = util75.getDefault()(isVertical2, labelGroup, limitLength);
      } else if (is_function_default(value)) {
        hasAdjusted = value(isVertical2, labelGroup, limitLength);
      } else if (is_object_default(value)) {
        var overlapCfg = value;
        if (util75[overlapCfg.type]) {
          hasAdjusted = util75[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util75[value]) {
        hasAdjusted = util75[value](isVertical2, labelGroup, limitLength);
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each_default(labels, function(label) {
            var textAlign = label.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each_default(children, function(label) {
          if (!label.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label);
            }
            label.remove();
          }
        });
      }
    };
    return Line6;
  }(base_default9);
  var line_default5 = Line;

  // node_modules/@antv/component/esm/axis/circle.js
  var Circle = function(_super) {
    __extends7(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    Circle6.prototype.getLinePath = function() {
      var center = this.get("center");
      var x = center.x;
      var y = center.y;
      var rx = this.get("radius");
      var ry = rx;
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var path = [];
      if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
        path = [["M", x, y - ry], ["A", rx, ry, 0, 1, 1, x, y + ry], ["A", rx, ry, 0, 1, 1, x, y - ry], ["Z"]];
      } else {
        var startPoint = this.getCirclePoint(startAngle);
        var endPoint = this.getCirclePoint(endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path = [
          ["M", x, y],
          ["L", startPoint.x, startPoint.y],
          ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
          ["L", x, y]
        ];
      }
      return path;
    };
    Circle6.prototype.getTickPoint = function(tickValue) {
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var angle3 = startAngle + (endAngle - startAngle) * tickValue;
      return this.getCirclePoint(angle3);
    };
    Circle6.prototype.getSideVector = function(offset, point) {
      var center = this.get("center");
      var vector = [point.x - center.x, point.y - center.y];
      var factor = this.get("verticalFactor");
      var vecLen = vec2_exports.length(vector);
      vec2_exports.scale(vector, vector, factor * offset / vecLen);
      return vector;
    };
    Circle6.prototype.getAxisVector = function(point) {
      var center = this.get("center");
      var vector = [point.x - center.x, point.y - center.y];
      return [vector[1], -1 * vector[0]];
    };
    Circle6.prototype.getCirclePoint = function(angle3, radius) {
      var center = this.get("center");
      radius = radius || this.get("radius");
      return {
        x: center.x + Math.cos(angle3) * radius,
        y: center.y + Math.sin(angle3) * radius
      };
    };
    Circle6.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return is_nil_default(labelCfg.rotate);
      }
      return true;
    };
    Circle6.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each_default(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (is_nil_default(titleCfg.offset)) {
          var length_1 = labelGroup.getCanvasBBox().height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Circle6.prototype.autoProcessOverlap = function(name, value, labelGroup, limitLength) {
      var _this = this;
      var hasAdjusted = false;
      var util75 = overlap_exports[name];
      if (limitLength > 0) {
        if (value === true) {
          hasAdjusted = util75.getDefault()(false, labelGroup, limitLength);
        } else if (is_function_default(value)) {
          hasAdjusted = value(false, labelGroup, limitLength);
        } else if (is_object_default(value)) {
          var overlapCfg = value;
          if (util75[overlapCfg.type]) {
            hasAdjusted = util75[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
          }
        } else if (util75[value]) {
          hasAdjusted = util75[value](false, labelGroup, limitLength);
        }
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each_default(labels, function(label) {
            var textAlign = label.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each_default(children, function(label) {
          if (!label.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label);
            }
            label.remove();
          }
        });
      }
    };
    return Circle6;
  }(base_default9);
  var circle_default3 = Circle;

  // node_modules/@antv/component/esm/crosshair/index.js
  var crosshair_exports = {};
  __export(crosshair_exports, {
    Base: () => base_default10,
    Circle: () => circle_default4,
    Html: () => html_default2,
    Line: () => line_default6
  });

  // node_modules/@antv/component/esm/crosshair/base.js
  var CrosshairBase = function(_super) {
    __extends7(CrosshairBase2, _super);
    function CrosshairBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        },
        text: {
          position: "start",
          offset: 10,
          autoRotate: false,
          content: null,
          style: {
            fill: theme_default.textColor,
            textAlign: "center",
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily
          }
        },
        textBackground: {
          padding: 5,
          style: {
            stroke: theme_default.lineColor
          }
        }
      } });
    };
    CrosshairBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.renderLine(group2);
      }
      if (this.get("text")) {
        this.renderText(group2);
        this.renderBackground(group2);
      }
    };
    CrosshairBase2.prototype.renderText = function(group2) {
      var text = this.get("text");
      var style = text.style, autoRotate = text.autoRotate, content = text.content;
      if (!is_nil_default(content)) {
        var textPoint = this.getTextPoint();
        var matrix = null;
        if (autoRotate) {
          var angle3 = this.getRotateAngle();
          matrix = getMatrixByAngle(textPoint, angle3);
        }
        this.addShape(group2, {
          type: "text",
          name: "crosshair-text",
          id: this.getElementId("text"),
          attrs: __assign7(__assign7(__assign7({}, textPoint), { text: content, matrix }), style)
        });
      }
    };
    CrosshairBase2.prototype.renderLine = function(group2) {
      var path = this.getLinePath();
      var line = this.get("line");
      var style = line.style;
      this.addShape(group2, {
        type: "path",
        name: "crosshair-line",
        id: this.getElementId("line"),
        attrs: __assign7({ path }, style)
      });
    };
    CrosshairBase2.prototype.renderBackground = function(group2) {
      var textId = this.getElementId("text");
      var textShape = group2.findById(textId);
      var textBackground = this.get("textBackground");
      if (textBackground && textShape) {
        var textBBox = textShape.getBBox();
        var padding = formatPadding(textBackground.padding);
        var style = textBackground.style;
        var backgroundShape = this.addShape(group2, {
          type: "rect",
          name: "crosshair-text-background",
          id: this.getElementId("text-background"),
          attrs: __assign7({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2], matrix: textShape.attr("matrix") }, style)
        });
        backgroundShape.toBack();
      }
    };
    return CrosshairBase2;
  }(group_component_default);
  var base_default10 = CrosshairBase;

  // node_modules/@antv/component/esm/crosshair/line.js
  var LineCrosshair = function(_super) {
    __extends7(LineCrosshair3, _super);
    function LineCrosshair3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "line", locationType: "region", start: null, end: null });
    };
    LineCrosshair3.prototype.getRotateAngle = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      var position = this.get("text").position;
      var angle3 = Math.atan2(end.y - start.y, end.x - start.x);
      var tangentAngle = position === "start" ? angle3 - Math.PI / 2 : angle3 + Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair3.prototype.getTextPoint = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    LineCrosshair3.prototype.getLinePath = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      return [
        ["M", start.x, start.y],
        ["L", end.x, end.y]
      ];
    };
    return LineCrosshair3;
  }(base_default10);
  var line_default6 = LineCrosshair;

  // node_modules/@antv/component/esm/crosshair/circle.js
  var LineCrosshair2 = function(_super) {
    __extends7(LineCrosshair3, _super);
    function LineCrosshair3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    LineCrosshair3.prototype.getRotateAngle = function() {
      var _a4 = this.getLocation(), startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var position = this.get("text").position;
      var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair3.prototype.getTextPoint = function() {
      var text = this.get("text");
      var position = text.position, offset = text.offset;
      var _a4 = this.getLocation(), center = _a4.center, radius = _a4.radius, startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var angle3 = position === "start" ? startAngle : endAngle;
      var tangentAngle = this.getRotateAngle() - Math.PI;
      var point = getCirclePoint(center, radius, angle3);
      var offsetX = Math.cos(tangentAngle) * offset;
      var offsetY = Math.sin(tangentAngle) * offset;
      return {
        x: point.x + offsetX,
        y: point.y + offsetY
      };
    };
    LineCrosshair3.prototype.getLinePath = function() {
      var _a4 = this.getLocation(), center = _a4.center, radius = _a4.radius, startAngle = _a4.startAngle, endAngle = _a4.endAngle;
      var path = null;
      if (endAngle - startAngle === Math.PI * 2) {
        var x = center.x, y = center.y;
        path = [
          ["M", x, y - radius],
          ["A", radius, radius, 0, 1, 1, x, y + radius],
          ["A", radius, radius, 0, 1, 1, x, y - radius],
          ["Z"]
        ];
      } else {
        var startPoint = getCirclePoint(center, radius, startAngle);
        var endPoint = getCirclePoint(center, radius, endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path = [
          ["M", startPoint.x, startPoint.y],
          ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
        ];
      }
      return path;
    };
    return LineCrosshair3;
  }(base_default10);
  var circle_default4 = LineCrosshair2;

  // node_modules/@antv/component/esm/crosshair/css-const.js
  var CONTAINER_CLASS = "g2-crosshair";
  var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
  var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";

  // node_modules/@antv/component/esm/crosshair/html-theme.js
  var _a2;
  var html_theme_default = (_a2 = {}, _a2["" + CONTAINER_CLASS] = {
    position: "relative"
  }, _a2["" + CROSSHAIR_LINE] = {
    position: "absolute",
    backgroundColor: "rgba(0, 0, 0, 0.25)"
  }, _a2["" + CROSSHAIR_TEXT] = {
    position: "absolute",
    color: theme_default.textColor,
    fontFamily: theme_default.fontFamily
  }, _a2);

  // node_modules/@antv/component/esm/crosshair/html.js
  var HtmlCrosshair = function(_super) {
    __extends7(HtmlCrosshair2, _super);
    function HtmlCrosshair2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlCrosshair2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS, defaultStyles: html_theme_default, defaultCfg: {
        text: {
          position: "start",
          content: null,
          align: "center",
          offset: 10
        }
      } });
    };
    HtmlCrosshair2.prototype.render = function() {
      this.resetText();
      this.resetPosition();
    };
    HtmlCrosshair2.prototype.initCrossHair = function() {
      var container = this.getContainer();
      var crosshairTpl = this.get("crosshairTpl");
      var crosshairEl = createDom(crosshairTpl);
      container.appendChild(crosshairEl);
      this.applyStyle(CROSSHAIR_LINE, crosshairEl);
      this.set("crosshairEl", crosshairEl);
    };
    HtmlCrosshair2.prototype.getTextPoint = function() {
      var _a4 = this.getLocation(), start = _a4.start, end = _a4.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    HtmlCrosshair2.prototype.resetText = function() {
      var text = this.get("text");
      var textEl = this.get("textEl");
      if (text) {
        var content = text.content;
        if (!textEl) {
          var container = this.getContainer();
          var textTpl = substitute_default(this.get("textTpl"), text);
          textEl = createDom(textTpl);
          container.appendChild(textEl);
          this.applyStyle(CROSSHAIR_TEXT, textEl);
          this.set("textEl", textEl);
        }
        textEl.innerHTML = content;
      } else if (textEl) {
        textEl.remove();
      }
    };
    HtmlCrosshair2.prototype.isVertical = function(start, end) {
      return start.x === end.x;
    };
    HtmlCrosshair2.prototype.resetPosition = function() {
      var crosshairEl = this.get("crosshairEl");
      if (!crosshairEl) {
        this.initCrossHair();
        crosshairEl = this.get("crosshairEl");
      }
      var start = this.get("start");
      var end = this.get("end");
      var minX = Math.min(start.x, end.x);
      var minY = Math.min(start.y, end.y);
      if (this.isVertical(start, end)) {
        modifyCSS(crosshairEl, {
          width: "1px",
          height: toPx(Math.abs(end.y - start.y))
        });
      } else {
        modifyCSS(crosshairEl, {
          height: "1px",
          width: toPx(Math.abs(end.x - start.x))
        });
      }
      modifyCSS(crosshairEl, {
        top: toPx(minY),
        left: toPx(minX)
      });
      this.alignText();
    };
    HtmlCrosshair2.prototype.alignText = function() {
      var textEl = this.get("textEl");
      if (textEl) {
        var align = this.get("text").align;
        var clientWidth = textEl.clientWidth;
        var point = this.getTextPoint();
        switch (align) {
          case "center":
            point.x = point.x - clientWidth / 2;
            break;
          case "right":
            point.x = point.x - clientWidth;
          case "left":
            break;
        }
        modifyCSS(textEl, {
          top: toPx(point.y),
          left: toPx(point.x)
        });
      }
    };
    HtmlCrosshair2.prototype.updateInner = function(cfg) {
      if (has_key_default(cfg, "text")) {
        this.resetText();
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    return HtmlCrosshair2;
  }(html_component_default);
  var html_default2 = HtmlCrosshair;

  // node_modules/@antv/component/esm/grid/index.js
  var grid_exports = {};
  __export(grid_exports, {
    Base: () => base_default11,
    Circle: () => circle_default5,
    Line: () => line_default7
  });

  // node_modules/@antv/component/esm/grid/base.js
  var GridBase = function(_super) {
    __extends7(GridBase2, _super);
    function GridBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GridBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
        line: {
          type: "line",
          style: {
            lineWidth: 1,
            stroke: theme_default.lineColor
          }
        }
      } });
    };
    GridBase2.prototype.getLineType = function() {
      var line = this.get("line") || this.get("defaultCfg").line;
      return line.type;
    };
    GridBase2.prototype.renderInner = function(group2) {
      this.drawGrid(group2);
    };
    GridBase2.prototype.getAlternatePath = function(prePoints, points) {
      var regionPath = this.getGridPath(prePoints);
      var reversePoints = points.slice(0).reverse();
      var nextPath = this.getGridPath(reversePoints, true);
      var closed = this.get("closed");
      if (closed) {
        regionPath = regionPath.concat(nextPath);
      } else {
        nextPath[0][0] = "L";
        regionPath = regionPath.concat(nextPath);
        regionPath.push(["Z"]);
      }
      return regionPath;
    };
    GridBase2.prototype.getPathStyle = function() {
      return this.get("line").style;
    };
    GridBase2.prototype.drawGrid = function(group2) {
      var _this = this;
      var line = this.get("line");
      var items = this.get("items");
      var alternateColor = this.get("alternateColor");
      var preItem = null;
      each_default(items, function(item, index) {
        var id = item.id || index;
        if (line) {
          var style = _this.getPathStyle();
          style = is_function_default(style) ? style(item, index, items) : style;
          var lineId = _this.getElementId("line-" + id);
          var gridPath = _this.getGridPath(item.points);
          _this.addShape(group2, {
            type: "path",
            name: "grid-line",
            id: lineId,
            attrs: mix({
              path: gridPath
            }, style)
          });
        }
        if (alternateColor && index > 0) {
          var regionId = _this.getElementId("region-" + id);
          var isEven2 = index % 2 === 0;
          if (is_string_default(alternateColor)) {
            if (isEven2) {
              _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
            }
          } else {
            var color2 = isEven2 ? alternateColor[1] : alternateColor[0];
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color2);
          }
        }
        preItem = item;
      });
    };
    GridBase2.prototype.drawAlternateRegion = function(id, group2, prePoints, points, color2) {
      var regionPath = this.getAlternatePath(prePoints, points);
      this.addShape(group2, {
        type: "path",
        id,
        name: "grid-region",
        attrs: {
          path: regionPath,
          fill: color2
        }
      });
    };
    return GridBase2;
  }(group_component_default);
  var base_default11 = GridBase;

  // node_modules/@antv/component/esm/grid/circle.js
  function distance5(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }
  var Circle2 = function(_super) {
    __extends7(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        type: "circle",
        center: null,
        closed: true
      });
    };
    Circle6.prototype.getGridPath = function(points, reversed) {
      var lineType = this.getLineType();
      var closed = this.get("closed");
      var path = [];
      if (points.length) {
        if (lineType === "circle") {
          var center = this.get("center");
          var firstPoint = points[0];
          var radius_1 = distance5(center.x, center.y, firstPoint.x, firstPoint.y);
          var sweepFlag_1 = reversed ? 0 : 1;
          if (closed) {
            path.push(["M", center.x, center.y - radius_1]);
            path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);
            path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);
            path.push(["Z"]);
          } else {
            each_default(points, function(point, index) {
              if (index === 0) {
                path.push(["M", point.x, point.y]);
              } else {
                path.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);
              }
            });
          }
        } else {
          each_default(points, function(point, index) {
            if (index === 0) {
              path.push(["M", point.x, point.y]);
            } else {
              path.push(["L", point.x, point.y]);
            }
          });
          if (closed) {
            path.push(["Z"]);
          }
        }
      }
      return path;
    };
    return Circle6;
  }(base_default11);
  var circle_default5 = Circle2;

  // node_modules/@antv/component/esm/grid/line.js
  var Line2 = function(_super) {
    __extends7(Line6, _super);
    function Line6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line6.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "line" });
    };
    Line6.prototype.getGridPath = function(points) {
      var path = [];
      each_default(points, function(point, index) {
        if (index === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
      return path;
    };
    return Line6;
  }(base_default11);
  var line_default7 = Line2;

  // node_modules/@antv/component/esm/legend/index.js
  var legend_exports = {};
  __export(legend_exports, {
    Base: () => base_default12,
    Category: () => category_default,
    Continuous: () => continuous_default
  });

  // node_modules/@antv/component/esm/legend/base.js
  var LegendBase = function(_super) {
    __extends7(LegendBase2, _super);
    function LegendBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LegendBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        name: "legend",
        layout: "horizontal",
        locationType: "point",
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0,
        title: null,
        background: null
      });
    };
    LegendBase2.prototype.getLayoutBBox = function() {
      var bbox = _super.prototype.getLayoutBBox.call(this);
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var width = bbox.width, height = bbox.height;
      if (maxWidth) {
        width = Math.min(width, maxWidth);
      }
      if (maxHeight) {
        height = Math.min(height, maxHeight);
      }
      return createBBox(bbox.minX, bbox.minY, width, height);
    };
    LegendBase2.prototype.setLocation = function(cfg) {
      this.set("x", cfg.x);
      this.set("y", cfg.y);
      this.resetLocation();
    };
    LegendBase2.prototype.resetLocation = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: x + offsetX,
        y: y + offsetY
      });
    };
    LegendBase2.prototype.applyOffset = function() {
      this.resetLocation();
    };
    LegendBase2.prototype.getDrawPoint = function() {
      return this.get("currentPoint");
    };
    LegendBase2.prototype.setDrawPoint = function(point) {
      return this.set("currentPoint", point);
    };
    LegendBase2.prototype.renderInner = function(group2) {
      this.resetDraw();
      if (this.get("title")) {
        this.drawTitle(group2);
      }
      this.drawLegendContent(group2);
      if (this.get("background")) {
        this.drawBackground(group2);
      }
    };
    LegendBase2.prototype.drawBackground = function(group2) {
      var background = this.get("background");
      var bbox = group2.getBBox();
      var padding = formatPadding(background.padding);
      var attrs = __assign7({
        x: 0,
        y: 0,
        width: bbox.width + padding[1] + padding[3],
        height: bbox.height + padding[0] + padding[2]
      }, background.style);
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        name: "legend-background",
        attrs
      });
      backgroundShape.toBack();
    };
    LegendBase2.prototype.drawTitle = function(group2) {
      var currentPoint = this.get("currentPoint");
      var titleCfg = this.get("title");
      var spacing = titleCfg.spacing, style = titleCfg.style, text = titleCfg.text;
      var shape = this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "legend-title",
        attrs: __assign7({ text, x: currentPoint.x, y: currentPoint.y }, style)
      });
      var bbox = shape.getBBox();
      this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
    };
    LegendBase2.prototype.resetDraw = function() {
      var background = this.get("background");
      var currentPoint = { x: 0, y: 0 };
      if (background) {
        var padding = formatPadding(background.padding);
        currentPoint.x = padding[3];
        currentPoint.y = padding[0];
      }
      this.set("currentPoint", currentPoint);
    };
    return LegendBase2;
  }(group_component_default);
  var base_default12 = LegendBase;

  // node_modules/@antv/component/esm/legend/category.js
  var DEFAULT_PAGE_NAVIGATOR = {
    marker: {
      style: {
        inactiveFill: "#000",
        inactiveOpacity: 0.45,
        fill: "#000",
        opacity: 1,
        size: 12
      }
    },
    text: {
      style: {
        fill: "#ccc",
        fontSize: 12
      }
    }
  };
  var textStyle = {
    fill: theme_default.textColor,
    fontSize: 12,
    textAlign: "start",
    textBaseline: "middle",
    fontFamily: theme_default.fontFamily,
    fontWeight: "normal",
    lineHeight: 12
  };
  var Category2 = function(_super) {
    __extends7(Category3, _super);
    function Category3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.currentPageIndex = 1;
      _this.totalPagesCnt = 1;
      _this.pageWidth = 0;
      _this.pageHeight = 0;
      _this.startX = 0;
      _this.startY = 0;
      _this.onNavigationBack = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex > 1) {
          _this.currentPageIndex -= 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      _this.onNavigationAfter = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex < _this.totalPagesCnt) {
          _this.currentPageIndex += 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      return _this;
    }
    Category3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
        title: {
          spacing: 5,
          style: {
            fill: theme_default.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        },
        background: {
          padding: 5,
          style: {
            stroke: theme_default.lineColor
          }
        },
        itemBackground: {
          style: {
            opacity: 0,
            fill: "#fff"
          }
        },
        pageNavigator: DEFAULT_PAGE_NAVIGATOR,
        itemName: {
          spacing: 16,
          style: textStyle
        },
        marker: {
          spacing: 8,
          style: {
            r: 6,
            symbol: "circle"
          }
        },
        itemValue: {
          alignRight: false,
          formatter: null,
          style: textStyle
        },
        itemStates: {
          active: {
            nameStyle: {
              opacity: 0.8
            }
          },
          unchecked: {
            nameStyle: {
              fill: theme_default.uncheckedColor
            },
            markerStyle: {
              fill: theme_default.uncheckedColor,
              stroke: theme_default.uncheckedColor
            }
          },
          inactive: {
            nameStyle: {
              fill: theme_default.uncheckedColor
            },
            markerStyle: {
              opacity: 0.2
            }
          }
        }
      } });
    };
    Category3.prototype.isList = function() {
      return true;
    };
    Category3.prototype.getItems = function() {
      return this.get("items");
    };
    Category3.prototype.setItems = function(items) {
      this.update({
        items
      });
    };
    Category3.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    Category3.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("item-group");
      itemGroup && itemGroup.clear();
    };
    Category3.prototype.setItemState = function(item, state, value) {
      item[state] = value;
      var itemElement = this.getElementByLocalId("item-" + item.id);
      if (itemElement) {
        var items = this.getItems();
        var index = items.indexOf(item);
        var offsetGroup = this.createOffScreenGroup();
        var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
        this.updateElements(newElement, itemElement);
        this.clearUpdateStatus(itemElement);
      }
    };
    Category3.prototype.hasState = function(item, state) {
      return !!item[state];
    };
    Category3.prototype.getItemStates = function(item) {
      var itemStates = this.get("itemStates");
      var rst = [];
      each_default(itemStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    Category3.prototype.clearItemsState = function(state) {
      var _this = this;
      var items = this.getItemsByState(state);
      each_default(items, function(item) {
        _this.setItemState(item, state, false);
      });
    };
    Category3.prototype.getItemsByState = function(state) {
      var _this = this;
      var items = this.getItems();
      return filter_default(items, function(item) {
        return _this.hasState(item, state);
      });
    };
    Category3.prototype.drawLegendContent = function(group2) {
      this.processItems();
      this.drawItems(group2);
    };
    Category3.prototype.processItems = function() {
      var items = this.get("items");
      each_default(items, function(item) {
        if (!item.id) {
          item.id = item.name;
        }
      });
    };
    Category3.prototype.drawItems = function(group2) {
      var _this = this;
      var itemContainerGroup = this.addGroup(group2, {
        id: this.getElementId("item-container-group"),
        name: "legend-item-container-group"
      });
      var itemGroup = this.addGroup(itemContainerGroup, {
        id: this.getElementId("item-group"),
        name: "legend-item-group"
      });
      var itemHeight = this.getItemHeight();
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemMarginBottom = this.get("itemMarginBottom");
      var currentPoint = this.get("currentPoint");
      var startX = currentPoint.x;
      var startY = currentPoint.y;
      var layout = this.get("layout");
      var items = this.get("items");
      var wrapped = false;
      var pageWidth = 0;
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      each_default(items, function(item, index) {
        var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);
        var bbox = subGroup.getBBox();
        var width = itemWidth || bbox.width;
        if (width > pageWidth) {
          pageWidth = width;
        }
        if (layout === "horizontal") {
          if (maxWidth && maxWidth < currentPoint.x + width - startX) {
            wrapped = true;
            currentPoint.x = startX;
            currentPoint.y += itemHeight + itemMarginBottom;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.x += width + itemSpacing;
        } else {
          if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
            wrapped = true;
            currentPoint.x += pageWidth + itemSpacing;
            currentPoint.y = startY;
            pageWidth = 0;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.y += itemHeight + itemMarginBottom;
        }
      });
      if (wrapped && this.get("flipPage")) {
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.totalPagesCnt = 1;
        this.startX = startX;
        this.startY = startY;
        this.adjustNavigation(group2, itemGroup);
      }
    };
    Category3.prototype.getItemHeight = function() {
      var itemHeight = this.get("itemHeight");
      if (!itemHeight) {
        var style_1 = (this.get("itemName") || {}).style;
        if (is_function_default(style_1)) {
          var items_1 = this.getItems();
          items_1.forEach(function(item, index) {
            var fontSize = __assign7(__assign7({}, textStyle), style_1(item, index, items_1)).fontSize;
            if (itemHeight < fontSize) {
              itemHeight = fontSize;
            }
          });
        } else if (style_1) {
          itemHeight = style_1.fontSize;
        }
      }
      return itemHeight;
    };
    Category3.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
      var markerAttrs = __assign7(__assign7(__assign7({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get_default(item.marker, "symbol", "circle") }), get_default(item.marker, "style", {}));
      var shape = this.addShape(container, {
        type: "marker",
        id: this.getElementId("item-" + item.id + "-marker"),
        name: "legend-item-marker",
        attrs: markerAttrs
      });
      var bbox = shape.getBBox();
      shape.attr("x", bbox.width / 2);
      var _a4 = shape.attr(), stroke = _a4.stroke, fill4 = _a4.fill;
      if (stroke) {
        shape.set("isStroke", true);
      }
      if (fill4) {
        shape.set("isFill", true);
      }
      return shape;
    };
    Category3.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index) {
      var formatter = cfg.formatter;
      var style = cfg.style;
      var attrs = __assign7(__assign7({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index) : item[textName] }, textStyle), is_function_default(style) ? style(item, index, this.getItems()) : style);
      return this.addShape(container, {
        type: "text",
        id: this.getElementId("item-" + item.id + "-" + textName),
        name: "legend-item-" + textName,
        attrs
      });
    };
    Category3.prototype.drawItem = function(item, index, itemHeight, itemGroup) {
      var groupId = "item-" + item.id;
      var subContainer = this.addGroup(itemGroup, {
        name: "legend-item-container",
        id: this.getElementId("item-container-" + groupId),
        delegateObject: {
          item,
          index
        }
      });
      var subGroup = this.addGroup(subContainer, {
        name: "legend-item",
        id: this.getElementId(groupId),
        delegateObject: {
          item,
          index
        }
      });
      var marker = this.get("marker");
      var itemName = this.get("itemName");
      var itemValue = this.get("itemValue");
      var itemBackground = this.get("itemBackground");
      var itemWidth = this.getLimitItemWidth();
      var curX = 0;
      if (marker) {
        var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
        var spacing = marker.spacing;
        var itemMarkerSpacing = get_default(item, ["marker", "spacing"]);
        if (is_number_default(itemMarkerSpacing)) {
          spacing = itemMarkerSpacing;
        }
        curX = markerShape.getBBox().maxX + spacing;
      }
      if (itemName) {
        var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index);
        if (itemWidth) {
          ellipsisLabel(true, nameShape, clamp_default(itemWidth - curX, 0, itemWidth));
        }
        curX = nameShape.getBBox().maxX + itemName.spacing;
      }
      if (itemValue) {
        var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index);
        if (itemWidth) {
          if (itemValue.alignRight) {
            valueShape.attr({
              textAlign: "right",
              x: itemWidth
            });
            ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth), "head");
          } else {
            ellipsisLabel(true, valueShape, clamp_default(itemWidth - curX, 0, itemWidth));
          }
        }
      }
      if (itemBackground) {
        var bbox = subGroup.getBBox();
        var backShape = this.addShape(subGroup, {
          type: "rect",
          name: "legend-item-background",
          id: this.getElementId(groupId + "-background"),
          attrs: __assign7({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
        });
        backShape.toBack();
      }
      this.applyItemStates(item, subGroup);
      return subGroup;
    };
    Category3.prototype.adjustNavigation = function(container, itemGroup) {
      var _this = this;
      var startX = this.startX;
      var startY = this.startY;
      var layout = this.get("layout");
      var subGroups = itemGroup.findAll(function(item) {
        return item.get("name") === "legend-item";
      });
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemHeight = this.getItemHeight();
      var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var navigation = this.drawNavigation(container, layout, "00/00", pageNavigator);
      var navigationBBox = navigation.getBBox();
      var currentPoint = { x: startX, y: startY };
      var pages = 1;
      var widthLimit = 0;
      var pageWidth = 0;
      var maxItemWidth = 0;
      var itemMarginBottom = this.get("itemMarginBottom");
      if (layout === "horizontal") {
        var maxRow = this.get("maxRow") || 1;
        var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
        this.pageHeight = maxRowHeight_1 * maxRow;
        each_default(subGroups, function(item) {
          var bbox = item.getBBox();
          var width = itemWidth || bbox.width;
          if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
            if (pages === 1) {
              widthLimit = currentPoint.x + itemSpacing;
              _this.pageWidth = widthLimit;
              _this.moveElementTo(navigation, {
                x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
                y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
              });
            }
            pages += 1;
            currentPoint.x = startX;
            currentPoint.y += maxRowHeight_1;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: width + itemSpacing,
              height: itemHeight
            }
          });
          currentPoint.x += width + itemSpacing;
        });
      } else {
        each_default(subGroups, function(item) {
          var bbox = item.getBBox();
          if (bbox.width > pageWidth) {
            pageWidth = bbox.width;
          }
        });
        maxItemWidth = pageWidth;
        pageWidth += itemSpacing;
        if (maxWidth) {
          pageWidth = Math.min(maxWidth, pageWidth);
          maxItemWidth = Math.min(maxWidth, maxItemWidth);
        }
        this.pageWidth = pageWidth;
        this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
        var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
        each_default(subGroups, function(item, index) {
          if (index !== 0 && index % cntPerPage_1 === 0) {
            pages += 1;
            currentPoint.x += pageWidth;
            currentPoint.y = startY;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: pageWidth,
              height: itemHeight
            }
          });
          currentPoint.y += itemHeight + itemMarginBottom;
        });
        this.totalPagesCnt = pages;
        this.moveElementTo(navigation, {
          x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
          y: maxHeight - navigationBBox.height - navigationBBox.minY
        });
      }
      if (this.pageHeight && this.pageWidth) {
        itemGroup.getParent().setClip({
          type: "rect",
          attrs: {
            x: this.startX,
            y: this.startY,
            width: this.pageWidth,
            height: this.pageHeight
          }
        });
      }
      if (layout === "horizontal" && this.get("maxRow")) {
        this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
      } else {
        this.totalPagesCnt = pages;
      }
      if (this.currentPageIndex > this.totalPagesCnt) {
        this.currentPageIndex = 1;
      }
      this.updateNavigation(navigation);
      itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
    };
    Category3.prototype.drawNavigation = function(group2, layout, text, styleCfg) {
      var currentPoint = { x: 0, y: 0 };
      var subGroup = this.addGroup(group2, {
        id: this.getElementId("navigation-group"),
        name: "legend-navigation"
      });
      var _a4 = get_default(styleCfg.marker, "style", {}), _b = _a4.size, size3 = _b === void 0 ? 12 : _b, arrowStyle = __rest7(_a4, ["size"]);
      var leftArrow = this.drawArrow(subGroup, currentPoint, "navigation-arrow-left", layout === "horizontal" ? "up" : "left", size3, arrowStyle);
      leftArrow.on("click", this.onNavigationBack);
      var leftArrowBBox = leftArrow.getBBox();
      currentPoint.x += leftArrowBBox.width + 2;
      var textShape = this.addShape(subGroup, {
        type: "text",
        id: this.getElementId("navigation-text"),
        name: "navigation-text",
        attrs: __assign7({ x: currentPoint.x, y: currentPoint.y + size3 / 2, text, textBaseline: "middle" }, get_default(styleCfg.text, "style"))
      });
      var textBBox = textShape.getBBox();
      currentPoint.x += textBBox.width + 2;
      var rightArrow = this.drawArrow(subGroup, currentPoint, "navigation-arrow-right", layout === "horizontal" ? "down" : "right", size3, arrowStyle);
      rightArrow.on("click", this.onNavigationAfter);
      return subGroup;
    };
    Category3.prototype.updateNavigation = function(navigation) {
      var pageNavigator = deep_mix_default({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var _a4 = pageNavigator.marker.style, fill4 = _a4.fill, opacity = _a4.opacity, inactiveFill = _a4.inactiveFill, inactiveOpacity = _a4.inactiveOpacity;
      var text = this.currentPageIndex + "/" + this.totalPagesCnt;
      var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
      var leftArrow = navigation ? navigation.findById(this.getElementId("navigation-arrow-left")) : this.getElementByLocalId("navigation-arrow-left");
      var rightArrow = navigation ? navigation.findById(this.getElementId("navigation-arrow-right")) : this.getElementByLocalId("navigation-arrow-right");
      var origBBox = textShape.getBBox();
      textShape.attr("text", text);
      var newBBox = textShape.getBBox();
      textShape.attr("x", textShape.attr("x") - (newBBox.width - origBBox.width) / 2);
      leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
      leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill4);
      leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
      rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
      rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill4);
      rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
    };
    Category3.prototype.drawArrow = function(group2, currentPoint, name, direction2, size3, style) {
      var x = currentPoint.x, y = currentPoint.y;
      var rotateMap = {
        right: 90 * Math.PI / 180,
        left: (360 - 90) * Math.PI / 180,
        up: 0,
        down: 180 * Math.PI / 180
      };
      var shape = this.addShape(group2, {
        type: "path",
        id: this.getElementId(name),
        name,
        attrs: __assign7({ path: [["M", x + size3 / 2, y], ["L", x, y + size3], ["L", x + size3, y + size3], ["Z"]], cursor: "pointer" }, style)
      });
      shape.attr("matrix", getMatrixByAngle({ x: x + size3 / 2, y: y + size3 / 2 }, rotateMap[direction2]));
      return shape;
    };
    Category3.prototype.getCurrentNavigationMatrix = function() {
      var _a4 = this, currentPageIndex = _a4.currentPageIndex, pageWidth = _a4.pageWidth, pageHeight = _a4.pageHeight;
      var layout = this.get("layout");
      var translate3 = layout === "horizontal" ? {
        x: 0,
        y: pageHeight * (1 - currentPageIndex)
      } : {
        x: pageWidth * (1 - currentPageIndex),
        y: 0
      };
      return getMatrixByTranslate(translate3);
    };
    Category3.prototype.applyItemStates = function(item, subGroup) {
      var states = this.getItemStates(item);
      var hasStates = states.length > 0;
      if (hasStates) {
        var children = subGroup.getChildren();
        var itemStates_1 = this.get("itemStates");
        each_default(children, function(element) {
          var name = element.get("name");
          var elName = name.split("-")[2];
          var statesStyle = getStatesStyle(item, elName, itemStates_1);
          if (statesStyle) {
            element.attr(statesStyle);
            if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
              if (element.get("isStroke")) {
                element.attr("fill", null);
              }
              if (element.get("isFill")) {
                element.attr("stroke", null);
              }
            }
          }
        });
      }
    };
    Category3.prototype.getLimitItemWidth = function() {
      var itemWidth = this.get("itemWidth");
      var maxItemWidth = this.get("maxItemWidth");
      if (maxItemWidth) {
        if (itemWidth) {
          maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
        }
      } else if (itemWidth) {
        maxItemWidth = itemWidth;
      }
      return maxItemWidth;
    };
    return Category3;
  }(base_default12);
  var category_default = Category2;

  // node_modules/@antv/component/esm/legend/continuous.js
  var HANDLER_HEIGHT_RATIO = 1.4;
  var HANDLER_TRIANGLE_RATIO = 0.4;
  var ContinueLegend = function(_super) {
    __extends7(ContinueLegend2, _super);
    function ContinueLegend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ContinueLegend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
        label: {
          align: "rail",
          spacing: 5,
          formatter: null,
          style: {
            fontSize: 12,
            fill: theme_default.textColor,
            textBaseline: "middle",
            fontFamily: theme_default.fontFamily
          }
        },
        handler: {
          size: 10,
          style: {
            fill: "#fff",
            stroke: "#333"
          }
        },
        track: {},
        rail: {
          type: "color",
          size: 20,
          defaultLength: 100,
          style: {
            fill: "#DCDEE2"
          }
        },
        title: {
          spacing: 5,
          style: {
            fill: theme_default.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        }
      } });
    };
    ContinueLegend2.prototype.isSlider = function() {
      return true;
    };
    ContinueLegend2.prototype.getValue = function() {
      return this.getCurrentValue();
    };
    ContinueLegend2.prototype.getRange = function() {
      return {
        min: this.get("min"),
        max: this.get("max")
      };
    };
    ContinueLegend2.prototype.setRange = function(min7, max7) {
      this.update({
        min: min7,
        max: max7
      });
    };
    ContinueLegend2.prototype.setValue = function(value) {
      var originValue = this.getValue();
      this.set("value", value);
      var group2 = this.get("group");
      this.resetTrackClip();
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value
      });
    };
    ContinueLegend2.prototype.initEvent = function() {
      var group2 = this.get("group");
      this.bindSliderEvent(group2);
      this.bindRailEvent(group2);
      this.bindTrackEvent(group2);
    };
    ContinueLegend2.prototype.drawLegendContent = function(group2) {
      this.drawRail(group2);
      this.drawLabels(group2);
      this.fixedElements(group2);
      this.resetTrack(group2);
      this.resetTrackClip(group2);
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
    };
    ContinueLegend2.prototype.bindSliderEvent = function(group2) {
      this.bindHandlersEvent(group2);
    };
    ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
      var _this = this;
      group2.on("legend-handler-min:drag", function(ev) {
        var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var maxValue = currentValue[1];
        if (maxValue < minValue) {
          maxValue = minValue;
        }
        _this.setValue([minValue, maxValue]);
      });
      group2.on("legend-handler-max:drag", function(ev) {
        var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var minValue = currentValue[0];
        if (minValue > maxValue) {
          minValue = maxValue;
        }
        _this.setValue([minValue, maxValue]);
      });
    };
    ContinueLegend2.prototype.bindRailEvent = function(group2) {
    };
    ContinueLegend2.prototype.bindTrackEvent = function(group2) {
      var _this = this;
      var prePoint = null;
      group2.on("legend-track:dragstart", function(ev) {
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:drag", function(ev) {
        if (!prePoint) {
          return;
        }
        var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
        var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var curDiff = currentValue[1] - currentValue[0];
        var range5 = _this.getRange();
        var dValue = curValue - preValue;
        if (dValue < 0) {
          if (currentValue[0] + dValue > range5.min) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range5.min, range5.min + curDiff]);
          }
        } else if (dValue > 0) {
          if (dValue > 0 && currentValue[1] + dValue < range5.max) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range5.max - curDiff, range5.max]);
          }
        }
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:dragend", function(ev) {
        prePoint = null;
      });
    };
    ContinueLegend2.prototype.drawLabels = function(group2) {
      this.drawLabel("min", group2);
      this.drawLabel("max", group2);
    };
    ContinueLegend2.prototype.drawLabel = function(name, group2) {
      var labelCfg = this.get("label");
      var style = labelCfg.style;
      var labelAlign = labelCfg.align;
      var labelFormatter = labelCfg.formatter;
      var value = this.get(name);
      var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
      var localId = "label-" + name;
      this.addShape(group2, {
        type: "text",
        id: this.getElementId(localId),
        name: "legend-label-" + name,
        attrs: __assign7(__assign7({ x: 0, y: 0, text: is_function_default(labelFormatter) ? labelFormatter(value) : value }, style), alignAttrs)
      });
    };
    ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
      var isVertical2 = this.isVertical();
      var textAlign = "center";
      var textBaseline = "middle";
      if (isVertical2) {
        textAlign = "start";
        if (align !== "rail") {
          if (name === "min") {
            textBaseline = "top";
          } else {
            textBaseline = "bottom";
          }
        } else {
          textBaseline = "top";
        }
      } else {
        if (align !== "rail") {
          textBaseline = "top";
          if (name === "min") {
            textAlign = "start";
          } else {
            textAlign = "end";
          }
        } else {
          textAlign = "start";
          textBaseline = "middle";
        }
      }
      return {
        textAlign,
        textBaseline
      };
    };
    ContinueLegend2.prototype.getRailPath = function(x, y, w, h2) {
      var railCfg = this.get("rail");
      var size3 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
      var isVertical2 = this.isVertical();
      var length3 = defaultLength;
      var width = w;
      var height = h2;
      if (!width) {
        width = isVertical2 ? size3 : length3;
      }
      if (!height) {
        height = isVertical2 ? length3 : size3;
      }
      var path = [];
      if (type === "color") {
        path.push(["M", x, y]);
        path.push(["L", x + width, y]);
        path.push(["L", x + width, y + height]);
        path.push(["L", x, y + height]);
        path.push(["Z"]);
      } else {
        path.push(["M", x + width, y]);
        path.push(["L", x + width, y + height]);
        path.push(["L", x, y + height]);
        path.push(["Z"]);
      }
      return path;
    };
    ContinueLegend2.prototype.drawRail = function(group2) {
      var railCfg = this.get("rail");
      var style = railCfg.style;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("rail"),
        name: "legend-rail",
        attrs: __assign7({ path: this.getRailPath(0, 0) }, style)
      });
    };
    ContinueLegend2.prototype.getTrackColor = function(colors) {
      var count2 = colors.length;
      if (!count2) {
        return null;
      }
      if (count2 === 1) {
        return colors[0];
      }
      var color2;
      if (this.isVertical()) {
        color2 = "l(90)";
      } else {
        color2 = "l(0)";
      }
      for (var i = 0; i < count2; i++) {
        var percent = i / (count2 - 1);
        color2 += " " + percent + ":" + colors[i];
      }
      return color2;
    };
    ContinueLegend2.prototype.getTrackPath = function(group2) {
      var railShape = this.getRailShape(group2);
      var path = railShape.attr("path");
      return clone_default(path);
    };
    ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
      var value = this.getCurrentValue();
      var min7 = value[0], max7 = value[1];
      var railBBox = this.getRailBBox(group2);
      var startPoint = this.getPointByValue(min7, group2);
      var endPoint = this.getPointByValue(max7, group2);
      var isVertical2 = this.isVertical();
      var x;
      var y;
      var width;
      var height;
      if (isVertical2) {
        x = railBBox.minX;
        y = startPoint.y;
        width = railBBox.width;
        height = endPoint.y - startPoint.y;
      } else {
        x = startPoint.x;
        y = railBBox.minY;
        width = endPoint.x - startPoint.x;
        height = railBBox.height;
      }
      return {
        x,
        y,
        width,
        height
      };
    };
    ContinueLegend2.prototype.getTrackAttrs = function(group2) {
      var trackCfg = this.get("track");
      var colors = this.get("colors");
      var path = this.getTrackPath(group2);
      return mix({
        path,
        fill: this.getTrackColor(colors)
      }, trackCfg.style);
    };
    ContinueLegend2.prototype.resetTrackClip = function(group2) {
      var container = group2 || this.get("group");
      var trackId = this.getElementId("track");
      var trackShape = container.findById(trackId);
      var clipShape = trackShape.getClip();
      var attrs = this.getClipTrackAttrs(group2);
      if (!clipShape) {
        trackShape.setClip({
          type: "rect",
          attrs
        });
      } else {
        clipShape.attr(attrs);
      }
    };
    ContinueLegend2.prototype.resetTrack = function(group2) {
      var trackId = this.getElementId("track");
      var trackShape = group2.findById(trackId);
      var trackAttrs = this.getTrackAttrs(group2);
      if (trackShape) {
        trackShape.attr(trackAttrs);
      } else {
        this.addShape(group2, {
          type: "path",
          id: trackId,
          draggable: this.get("slidable"),
          name: "legend-track",
          attrs: trackAttrs
        });
      }
    };
    ContinueLegend2.prototype.getPointByValue = function(value, group2) {
      var _a4 = this.getRange(), min7 = _a4.min, max7 = _a4.max;
      var percent = (value - min7) / (max7 - min7);
      var bbox = this.getRailBBox(group2);
      var isVertcal = this.isVertical();
      var point = { x: 0, y: 0 };
      if (isVertcal) {
        point.x = bbox.minX + bbox.width / 2;
        point.y = getValueByPercent(bbox.minY, bbox.maxY, percent);
      } else {
        point.x = getValueByPercent(bbox.minX, bbox.maxX, percent);
        point.y = bbox.minY + bbox.height / 2;
      }
      return point;
    };
    ContinueLegend2.prototype.getRailShape = function(group2) {
      var container = group2 || this.get("group");
      return container.findById(this.getElementId("rail"));
    };
    ContinueLegend2.prototype.getRailBBox = function(group2) {
      var railShape = this.getRailShape(group2);
      var bbox = railShape.getBBox();
      return bbox;
    };
    ContinueLegend2.prototype.getRailCanvasBBox = function() {
      var container = this.get("group");
      var railShape = container.findById(this.getElementId("rail"));
      var bbox = railShape.getCanvasBBox();
      return bbox;
    };
    ContinueLegend2.prototype.isVertical = function() {
      return this.get("layout") === "vertical";
    };
    ContinueLegend2.prototype.getValueByCanvasPoint = function(x, y) {
      var _a4 = this.getRange(), min7 = _a4.min, max7 = _a4.max;
      var bbox = this.getRailCanvasBBox();
      var isVertcal = this.isVertical();
      var step4 = this.get("step");
      var percent;
      if (isVertcal) {
        percent = (y - bbox.minY) / bbox.height;
      } else {
        percent = (x - bbox.minX) / bbox.width;
      }
      var value = getValueByPercent(min7, max7, percent);
      if (step4) {
        var count2 = Math.round((value - min7) / step4);
        value = min7 + count2 * step4;
      }
      if (value > max7) {
        value = max7;
      }
      if (value < min7) {
        value = min7;
      }
      return value;
    };
    ContinueLegend2.prototype.getCurrentValue = function() {
      var value = this.get("value");
      if (!value) {
        var values2 = this.get("values");
        if (!values2) {
          return [this.get("min"), this.get("max")];
        }
        return [Math.max(Math.min.apply(Math, __spreadArrays7(values2, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays7(values2, [this.get("min")])), this.get("max"))];
      }
      return value;
    };
    ContinueLegend2.prototype.resetHandlers = function(group2) {
      var currentValue = this.getCurrentValue();
      var min7 = currentValue[0], max7 = currentValue[1];
      this.resetHandler(group2, "min", min7);
      this.resetHandler(group2, "max", max7);
    };
    ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point) {
      var isVertical2 = this.isVertical();
      var path = [];
      var width = handlerCfg.size;
      var x = point.x, y = point.y;
      var height = width * HANDLER_HEIGHT_RATIO;
      var halfWidth = width / 2;
      var oneSixthWidth = width / 6;
      if (isVertical2) {
        var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
        path.push(["M", x, y]);
        path.push(["L", triangleX, y + halfWidth]);
        path.push(["L", x + height, y + halfWidth]);
        path.push(["L", x + height, y - halfWidth]);
        path.push(["L", triangleX, y - halfWidth]);
        path.push(["Z"]);
        path.push(["M", triangleX, y + oneSixthWidth]);
        path.push(["L", x + height - 2, y + oneSixthWidth]);
        path.push(["M", triangleX, y - oneSixthWidth]);
        path.push(["L", x + height - 2, y - oneSixthWidth]);
      } else {
        var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
        path.push(["M", x, y]);
        path.push(["L", x - halfWidth, triangleY]);
        path.push(["L", x - halfWidth, y + height]);
        path.push(["L", x + halfWidth, y + height]);
        path.push(["L", x + halfWidth, triangleY]);
        path.push(["Z"]);
        path.push(["M", x - oneSixthWidth, triangleY]);
        path.push(["L", x - oneSixthWidth, y + height - 2]);
        path.push(["M", x + oneSixthWidth, triangleY]);
        path.push(["L", x + oneSixthWidth, y + height - 2]);
      }
      return path;
    };
    ContinueLegend2.prototype.resetHandler = function(group2, name, value) {
      var point = this.getPointByValue(value, group2);
      var handlerCfg = this.get("handler");
      var path = this.getHandlerPath(handlerCfg, point);
      var id = this.getElementId("handler-" + name);
      var handlerShape = group2.findById(id);
      var isVertical2 = this.isVertical();
      if (handlerShape) {
        handlerShape.attr("path", path);
      } else {
        this.addShape(group2, {
          type: "path",
          name: "legend-handler-" + name,
          draggable: true,
          id,
          attrs: __assign7(__assign7({ path }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
        });
      }
    };
    ContinueLegend2.prototype.fixedElements = function(group2) {
      var railShape = group2.findById(this.getElementId("rail"));
      var minLabel = group2.findById(this.getElementId("label-min"));
      var maxLabel = group2.findById(this.getElementId("label-max"));
      var startPoint = this.getDrawPoint();
      if (this.isVertical()) {
        this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
      } else {
        this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
      }
    };
    ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
      var isVertical2 = this.isVertical();
      var lengthField = isVertical2 ? "height" : "width";
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var maxLength = this.get("max" + upper_first_default(lengthField));
      if (maxLength) {
        var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
        var diff2 = elementsLength - maxLength;
        if (diff2 > 0) {
          this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
        }
      }
    };
    ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length3) {
      var bbox = railShape.getBBox();
      var path;
      if (lengthField === "height") {
        path = this.getRailPath(bbox.x, bbox.y, bbox.width, length3);
      } else {
        path = this.getRailPath(bbox.x, bbox.y, length3, bbox.height);
      }
      railShape.attr("path", path);
    };
    ContinueLegend2.prototype.changeRailPosition = function(railShape, x, y) {
      var bbox = railShape.getBBox();
      var path = this.getRailPath(x, y, bbox.width, bbox.height);
      railShape.attr("path", path);
    };
    ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      var railHeight = railBBox.height;
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railHeight / 2
        });
        this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
          y: startPoint.y + railHeight / 2
        });
      } else if (labelAlign === "top") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      } else {
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height + spacing
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y + railBBox.height + spacing
        });
      }
    };
    ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
        });
      } else if (labelAlign === "right") {
        minLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y + railBBox.height
        });
      } else {
        var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height
        });
      }
    };
    return ContinueLegend2;
  }(base_default12);
  var continuous_default = ContinueLegend;

  // node_modules/@antv/component/esm/tooltip/index.js
  var tooltip_exports = {};
  __export(tooltip_exports, {
    Html: () => html_default3
  });

  // node_modules/@antv/component/esm/tooltip/css-const.js
  var css_const_exports = {};
  __export(css_const_exports, {
    CONTAINER_CLASS: () => CONTAINER_CLASS2,
    CROSSHAIR_X: () => CROSSHAIR_X,
    CROSSHAIR_Y: () => CROSSHAIR_Y,
    LIST_CLASS: () => LIST_CLASS,
    LIST_ITEM_CLASS: () => LIST_ITEM_CLASS,
    MARKER_CLASS: () => MARKER_CLASS,
    NAME_CLASS: () => NAME_CLASS,
    TITLE_CLASS: () => TITLE_CLASS,
    VALUE_CLASS: () => VALUE_CLASS
  });
  var CONTAINER_CLASS2 = "g2-tooltip";
  var TITLE_CLASS = "g2-tooltip-title";
  var LIST_CLASS = "g2-tooltip-list";
  var LIST_ITEM_CLASS = "g2-tooltip-list-item";
  var MARKER_CLASS = "g2-tooltip-marker";
  var VALUE_CLASS = "g2-tooltip-value";
  var NAME_CLASS = "g2-tooltip-name";
  var CROSSHAIR_X = "g2-tooltip-crosshair-x";
  var CROSSHAIR_Y = "g2-tooltip-crosshair-y";

  // node_modules/@antv/component/esm/tooltip/html-theme.js
  var _a3;
  var html_theme_default2 = (_a3 = {}, _a3["" + CONTAINER_CLASS2] = {
    position: "absolute",
    visibility: "visible",
    zIndex: 8,
    transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
    backgroundColor: "rgba(255, 255, 255, 0.9)",
    boxShadow: "0px 0px 10px #aeaeae",
    borderRadius: "3px",
    color: "rgb(87, 87, 87)",
    fontSize: "12px",
    fontFamily: theme_default.fontFamily,
    lineHeight: "20px",
    padding: "10px 10px 6px 10px"
  }, _a3["" + TITLE_CLASS] = {
    marginBottom: "4px"
  }, _a3["" + LIST_CLASS] = {
    margin: "0px",
    listStyleType: "none",
    padding: "0px"
  }, _a3["" + LIST_ITEM_CLASS] = {
    listStyleType: "none",
    marginBottom: "4px"
  }, _a3["" + MARKER_CLASS] = {
    width: "8px",
    height: "8px",
    borderRadius: "50%",
    display: "inline-block",
    marginRight: "8px"
  }, _a3["" + VALUE_CLASS] = {
    display: "inline-block",
    float: "right",
    marginLeft: "30px"
  }, _a3["" + CROSSHAIR_X] = {
    position: "absolute",
    width: "1px",
    backgroundColor: "rgba(0, 0, 0, 0.25)"
  }, _a3["" + CROSSHAIR_Y] = {
    position: "absolute",
    height: "1px",
    backgroundColor: "rgba(0, 0, 0, 0.25)"
  }, _a3);

  // node_modules/@antv/component/esm/util/align.js
  function getOutSides(x, y, width, height, limitBox) {
    var hits = {
      left: x < limitBox.x,
      right: x + width > limitBox.x + limitBox.width,
      top: y < limitBox.y,
      bottom: y + height > limitBox.y + limitBox.height
    };
    return hits;
  }
  function getPointByPosition(x, y, offset, width, height, position) {
    var px = x;
    var py = y;
    switch (position) {
      case "left":
        px = x - width - offset;
        py = y - height / 2;
        break;
      case "right":
        px = x + offset;
        py = y - height / 2;
        break;
      case "top":
        px = x - width / 2;
        py = y - height - offset;
        break;
      case "bottom":
        px = x - width / 2;
        py = y + offset;
        break;
      default:
        px = x + offset;
        py = y - height - offset;
        break;
    }
    return {
      x: px,
      y: py
    };
  }
  function getAlignPoint(x, y, offset, width, height, position, limitBox) {
    var point = getPointByPosition(x, y, offset, width, height, position);
    if (limitBox) {
      var outSides = getOutSides(point.x, point.y, width, height, limitBox);
      if (position === "auto") {
        if (outSides.right) {
          point.x = Math.max(0, x - width - offset);
        }
        if (outSides.top) {
          point.y = Math.max(0, y - height - offset);
        }
      } else if (position === "top" || position === "bottom") {
        if (outSides.left) {
          point.x = limitBox.x;
        }
        if (outSides.right) {
          point.x = limitBox.x + limitBox.width - width;
        }
        if (position === "top" && outSides.top) {
          point.y = y + offset;
        }
        if (position === "bottom" && outSides.bottom) {
          point.y = y - height - offset;
        }
      } else {
        if (outSides.top) {
          point.y = limitBox.y;
        }
        if (outSides.bottom) {
          point.y = limitBox.y + limitBox.height - height;
        }
        if (position === "left" && outSides.left) {
          point.x = x + offset;
        }
        if (position === "right" && outSides.right) {
          point.x = x - width - offset;
        }
      }
    }
    return point;
  }

  // node_modules/@antv/component/esm/tooltip/html.js
  function hasOneKey(obj, keys2) {
    var result = false;
    each_default(keys2, function(key) {
      if (has_key_default(obj, key)) {
        result = true;
        return false;
      }
    });
    return result;
  }
  var Tooltip = function(_super) {
    __extends7(Tooltip3, _super);
    function Tooltip3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Tooltip3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), {
        name: "tooltip",
        type: "html",
        x: 0,
        y: 0,
        items: [],
        customContent: null,
        containerTpl: '<div class="' + CONTAINER_CLASS2 + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
        itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
        xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
        yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
        title: null,
        showTitle: true,
        region: null,
        crosshairsRegion: null,
        containerClassName: CONTAINER_CLASS2,
        crosshairs: null,
        offset: 10,
        position: "right",
        domStyles: null,
        defaultStyles: html_theme_default2
      });
    };
    Tooltip3.prototype.render = function() {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        this.resetTitle();
        this.renderItems();
      }
      this.resetPosition();
    };
    Tooltip3.prototype.clear = function() {
      this.clearCrosshairs();
      this.setTitle("");
      this.clearItemDoms();
    };
    Tooltip3.prototype.show = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", true);
      modifyCSS(container, {
        visibility: "visible"
      });
      this.setCrossHairsVisible(true);
    };
    Tooltip3.prototype.hide = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", false);
      modifyCSS(container, {
        visibility: "hidden"
      });
      this.setCrossHairsVisible(false);
    };
    Tooltip3.prototype.getLocation = function() {
      return { x: this.get("x"), y: this.get("y") };
    };
    Tooltip3.prototype.setLocation = function(point) {
      this.set("x", point.x);
      this.set("y", point.y);
      this.resetPosition();
    };
    Tooltip3.prototype.setCrossHairsVisible = function(visible) {
      var display = visible ? "" : "none";
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && modifyCSS(xCrosshairDom, {
        display
      });
      yCrosshairDom && modifyCSS(yCrosshairDom, {
        display
      });
    };
    Tooltip3.prototype.initContainer = function() {
      _super.prototype.initContainer.call(this);
      if (this.get("customContent")) {
        if (this.get("container")) {
          this.get("container").remove();
        }
        var container = this.getHtmlContentNode();
        this.get("parent").appendChild(container);
        this.set("container", container);
        this.resetStyles();
        this.applyStyles();
      }
    };
    Tooltip3.prototype.updateInner = function(cfg) {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        if (hasOneKey(cfg, ["title", "showTitle"])) {
          this.resetTitle();
        }
        if (has_key_default(cfg, "items")) {
          this.renderItems();
        }
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    Tooltip3.prototype.initDom = function() {
      this.cacheDoms();
    };
    Tooltip3.prototype.removeDom = function() {
      _super.prototype.removeDom.call(this);
      this.clearCrosshairs();
    };
    Tooltip3.prototype.resetPosition = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offset = this.get("offset");
      var _a4 = this.getOffset(), offsetX = _a4.offsetX, offsetY = _a4.offsetY;
      var position = this.get("position");
      var region = this.get("region");
      var container = this.getContainer();
      var bbox = this.getBBox();
      var width = bbox.width, height = bbox.height;
      var limitBox;
      if (region) {
        limitBox = regionToBBox(region);
      }
      var point = getAlignPoint(x, y, offset, width, height, position, limitBox);
      modifyCSS(container, {
        left: toPx(point.x + offsetX),
        top: toPx(point.y + offsetY)
      });
      this.resetCrosshairs();
    };
    Tooltip3.prototype.renderCustomContent = function() {
      var node = this.getHtmlContentNode();
      var parent = this.get("parent");
      var curContainer = this.get("container");
      if (curContainer && curContainer.parentNode === parent) {
        parent.replaceChild(node, curContainer);
      } else {
        parent.appendChild(node);
      }
      this.set("container", node);
      this.resetStyles();
      this.applyStyles();
    };
    Tooltip3.prototype.getHtmlContentNode = function() {
      var node;
      var customContent = this.get("customContent");
      if (customContent) {
        var elem = customContent(this.get("title"), this.get("items"));
        if (is_element_default(elem)) {
          node = elem;
        } else {
          node = createDom(elem);
        }
      }
      return node;
    };
    Tooltip3.prototype.cacheDoms = function() {
      var container = this.getContainer();
      var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
      var listDom = container.getElementsByClassName(LIST_CLASS)[0];
      this.set("titleDom", titleDom);
      this.set("listDom", listDom);
    };
    Tooltip3.prototype.resetTitle = function() {
      var title = this.get("title");
      var showTitle = this.get("showTitle");
      if (showTitle && title) {
        this.setTitle(title);
      } else {
        this.setTitle("");
      }
    };
    Tooltip3.prototype.setTitle = function(text) {
      var titleDom = this.get("titleDom");
      if (titleDom) {
        titleDom.innerText = text;
      }
    };
    Tooltip3.prototype.resetCrosshairs = function() {
      var crosshairsRegion = this.get("crosshairsRegion");
      var crosshairs = this.get("crosshairs");
      if (!crosshairsRegion || !crosshairs) {
        this.clearCrosshairs();
      } else {
        var crosshairBox = regionToBBox(crosshairsRegion);
        var xCrosshairDom = this.get("xCrosshairDom");
        var yCrosshairDom = this.get("yCrosshairDom");
        if (crosshairs === "x") {
          this.resetCrosshair("x", crosshairBox);
          if (yCrosshairDom) {
            yCrosshairDom.remove();
            this.set("yCrosshairDom", null);
          }
        } else if (crosshairs === "y") {
          this.resetCrosshair("y", crosshairBox);
          if (xCrosshairDom) {
            xCrosshairDom.remove();
            this.set("xCrosshairDom", null);
          }
        } else {
          this.resetCrosshair("x", crosshairBox);
          this.resetCrosshair("y", crosshairBox);
        }
        this.setCrossHairsVisible(this.get("visible"));
      }
    };
    Tooltip3.prototype.resetCrosshair = function(name, bbox) {
      var croshairDom = this.checkCrosshair(name);
      var value = this.get(name);
      if (name === "x") {
        modifyCSS(croshairDom, {
          left: toPx(value),
          top: toPx(bbox.y),
          height: toPx(bbox.height)
        });
      } else {
        modifyCSS(croshairDom, {
          top: toPx(value),
          left: toPx(bbox.x),
          width: toPx(bbox.width)
        });
      }
    };
    Tooltip3.prototype.checkCrosshair = function(name) {
      var domName = name + "CrosshairDom";
      var tplName = name + "CrosshairTpl";
      var constName = "CROSSHAIR_" + name.toUpperCase();
      var styleName = css_const_exports[constName];
      var croshairDom = this.get(domName);
      var parent = this.get("parent");
      if (!croshairDom) {
        croshairDom = createDom(this.get(tplName));
        this.applyStyle(styleName, croshairDom);
        parent.appendChild(croshairDom);
        this.set(domName, croshairDom);
      }
      return croshairDom;
    };
    Tooltip3.prototype.renderItems = function() {
      this.clearItemDoms();
      var items = this.get("items");
      var itemTpl = this.get("itemTpl");
      var listDom = this.get("listDom");
      if (listDom) {
        each_default(items, function(item) {
          var color2 = esm_default2.toCSSGradient(item.color);
          var substituteObj = __assign7(__assign7({}, item), { color: color2 });
          var domStr = substitute_default(itemTpl, substituteObj);
          var itemDom = createDom(domStr);
          listDom.appendChild(itemDom);
        });
        this.applyChildrenStyles(listDom, this.get("domStyles"));
      }
    };
    Tooltip3.prototype.clearItemDoms = function() {
      if (this.get("listDom")) {
        clearDom(this.get("listDom"));
      }
    };
    Tooltip3.prototype.clearCrosshairs = function() {
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && xCrosshairDom.remove();
      yCrosshairDom && yCrosshairDom.remove();
      this.set("xCrosshairDom", null);
      this.set("yCrosshairDom", null);
    };
    return Tooltip3;
  }(html_component_default);
  var html_default3 = Tooltip;

  // node_modules/@antv/component/esm/trend/constant.js
  var BACKGROUND_STYLE = {
    opacity: 0
  };
  var LINE_STYLE = {
    stroke: "#C5C5C5",
    strokeOpacity: 0.85
  };
  var AREA_STYLE = {
    fill: "#CACED4",
    opacity: 0.85
  };

  // node_modules/@antv/component/esm/trend/path.js
  function pointsToPath(points) {
    return map_default(points, function(p3, idx) {
      var command = idx === 0 ? "M" : "L";
      var x = p3[0], y = p3[1];
      return [command, x, y];
    });
  }
  function getLinePath(points) {
    return pointsToPath(points);
  }
  function getSmoothLinePath(points) {
    if (points.length <= 2) {
      return getLinePath(points);
    }
    var data = [];
    each_default(points, function(p3) {
      if (!is_equal_default(p3, data.slice(data.length - 2))) {
        data.push(p3[0], p3[1]);
      }
    });
    var path = catmull_rom_2_bezier_default(data, false);
    var _a4 = head(points), x = _a4[0], y = _a4[1];
    path.unshift(["M", x, y]);
    return path;
  }
  function dataToPath(data, width, height, smooth) {
    if (smooth === void 0) {
      smooth = true;
    }
    var y = new linear_default({
      values: data
    });
    var x = new base_default5({
      values: map_default(data, function(v, idx) {
        return idx;
      })
    });
    var points = map_default(data, function(v, idx) {
      return [x.scale(idx) * width, height - y.scale(v) * height];
    });
    return smooth ? getSmoothLinePath(points) : getLinePath(points);
  }
  function getAreaLineY(data, height) {
    var y = new linear_default({
      values: data
    });
    var lineY = Math.max(0, y.min);
    return height - y.scale(lineY) * height;
  }
  function linePathToAreaPath(path, width, height, data) {
    var areaPath = __spreadArrays7(path);
    var lineYPx = getAreaLineY(data, height);
    areaPath.push(["L", width, lineYPx]);
    areaPath.push(["L", 0, lineYPx]);
    areaPath.push(["Z"]);
    return areaPath;
  }

  // node_modules/@antv/component/esm/trend/trend.js
  var Trend = function(_super) {
    __extends7(Trend2, _super);
    function Trend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Trend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
    };
    Trend2.prototype.renderInner = function(group2) {
      var _a4 = this.cfg, width = _a4.width, height = _a4.height, data = _a4.data, smooth = _a4.smooth, isArea = _a4.isArea, backgroundStyle = _a4.backgroundStyle, lineStyle = _a4.lineStyle, areaStyle = _a4.areaStyle;
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign7({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var path = dataToPath(data, width, height, smooth);
      this.addShape(group2, {
        id: this.getElementId("line"),
        type: "path",
        attrs: __assign7({ path }, lineStyle)
      });
      if (isArea) {
        var areaPath = linePathToAreaPath(path, width, height, data);
        this.addShape(group2, {
          id: this.getElementId("area"),
          type: "path",
          attrs: __assign7({ path: areaPath }, areaStyle)
        });
      }
    };
    Trend2.prototype.applyOffset = function() {
      var _a4 = this.cfg, x = _a4.x, y = _a4.y;
      this.moveElementTo(this.get("group"), {
        x,
        y
      });
    };
    return Trend2;
  }(group_component_default);

  // node_modules/@antv/component/esm/slider/handler.js
  var DEFAULT_HANDLER_STYLE = {
    fill: "#F7F7F7",
    stroke: "#BFBFBF",
    radius: 2,
    opacity: 1,
    cursor: "ew-resize",
    highLightFill: "#FFF"
  };
  var Handler = function(_super) {
    __extends7(Handler2, _super);
    function Handler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Handler2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
    };
    Handler2.prototype.renderInner = function(group2) {
      var _a4 = this.cfg, width = _a4.width, height = _a4.height, style = _a4.style;
      var fill4 = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        attrs: {
          x: 0,
          y: 0,
          width,
          height,
          fill: fill4,
          stroke,
          radius,
          opacity,
          cursor
        }
      });
      var x1 = 1 / 3 * width;
      var x2 = 2 / 3 * width;
      var y1 = 1 / 4 * height;
      var y2 = 3 / 4 * height;
      this.addShape(group2, {
        id: this.getElementId("line-left"),
        type: "line",
        attrs: {
          x1,
          y1,
          x2: x1,
          y2,
          stroke,
          cursor
        }
      });
      this.addShape(group2, {
        id: this.getElementId("line-right"),
        type: "line",
        attrs: {
          x1: x2,
          y1,
          x2,
          y2,
          stroke,
          cursor
        }
      });
    };
    Handler2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Handler2.prototype.initEvent = function() {
      this.bindEvents();
    };
    Handler2.prototype.bindEvents = function() {
      var _this = this;
      this.get("group").on("mouseenter", function() {
        var highLightFill = _this.get("style").highLightFill;
        _this.getElementByLocalId("background").attr("fill", highLightFill);
        _this.draw();
      });
      this.get("group").on("mouseleave", function() {
        var fill4 = _this.get("style").fill;
        _this.getElementByLocalId("background").attr("fill", fill4);
        _this.draw();
      });
    };
    Handler2.prototype.draw = function() {
      var canvas = this.get("container").get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    return Handler2;
  }(group_component_default);

  // node_modules/@antv/component/esm/slider/constant.js
  var BACKGROUND_STYLE2 = {
    fill: "#416180",
    opacity: 0.05
  };
  var FOREGROUND_STYLE = {
    fill: "#5B8FF9",
    opacity: 0.15,
    cursor: "move"
  };
  var DEFAULT_HANDLER_WIDTH = 10;
  var HANDLER_STYLE = {
    width: DEFAULT_HANDLER_WIDTH,
    height: 24
  };
  var TEXT_STYLE = {
    textBaseline: "middle",
    fill: "#000",
    opacity: 0.45
  };
  var SLIDER_CHANGE = "sliderchange";

  // node_modules/@antv/component/esm/slider/slider.js
  var Slider = function(_super) {
    __extends7(Slider3, _super);
    function Slider3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(target) {
        return function(e) {
          _this.currentTarget = target;
          var event = e.originalEvent;
          event.stopPropagation();
          event.preventDefault();
          _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
          _this.prevY = get_default(event, "touches.0.pageY", event.pageY);
          var containerDOM = _this.getContainerDOM();
          containerDOM.addEventListener("mousemove", _this.onMouseMove);
          containerDOM.addEventListener("mouseup", _this.onMouseUp);
          containerDOM.addEventListener("mouseleave", _this.onMouseUp);
          containerDOM.addEventListener("touchmove", _this.onMouseMove);
          containerDOM.addEventListener("touchend", _this.onMouseUp);
          containerDOM.addEventListener("touchcancel", _this.onMouseUp);
        };
      };
      _this.onMouseMove = function(event) {
        var width = _this.cfg.width;
        var originValue = [_this.get("start"), _this.get("end")];
        event.stopPropagation();
        event.preventDefault();
        var x = get_default(event, "touches.0.pageX", event.pageX);
        var y = get_default(event, "touches.0.pageY", event.pageY);
        var offsetX = x - _this.prevX;
        var offsetXRange = _this.adjustOffsetRange(offsetX / width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
        _this.prevX = x;
        _this.prevY = y;
        _this.draw();
        _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
        _this.delegateEmit("valuechanged", {
          originValue,
          value: [_this.get("start"), _this.get("end")]
        });
      };
      _this.onMouseUp = function() {
        if (_this.currentTarget) {
          _this.currentTarget = void 0;
        }
        var containerDOM = _this.getContainerDOM();
        if (containerDOM) {
          containerDOM.removeEventListener("mousemove", _this.onMouseMove);
          containerDOM.removeEventListener("mouseup", _this.onMouseUp);
          containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
          containerDOM.removeEventListener("touchmove", _this.onMouseMove);
          containerDOM.removeEventListener("touchend", _this.onMouseUp);
          containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
        }
      };
      return _this;
    }
    Slider3.prototype.setRange = function(min7, max7) {
      this.set("minLimit", min7);
      this.set("maxLimit", max7);
      var oldStart = this.get("start");
      var oldEnd = this.get("end");
      var newStart = clamp_default(oldStart, min7, max7);
      var newEnd = clamp_default(oldEnd, min7, max7);
      if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
        this.setValue([newStart, newEnd]);
      }
    };
    Slider3.prototype.getRange = function() {
      return {
        min: this.get("minLimit") || 0,
        max: this.get("maxLimit") || 1
      };
    };
    Slider3.prototype.setValue = function(value) {
      var range5 = this.getRange();
      if (is_array_default(value) && value.length === 2) {
        var originValue = [this.get("start"), this.get("end")];
        this.update({
          start: clamp_default(value[0], range5.min, range5.max),
          end: clamp_default(value[1], range5.min, range5.max)
        });
        if (!this.get("updateAutoRender")) {
          this.render();
        }
        this.delegateEmit("valuechanged", {
          originValue,
          value
        });
      }
    };
    Slider3.prototype.getValue = function() {
      return [this.get("start"), this.get("end")];
    };
    Slider3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
        backgroundStyle: BACKGROUND_STYLE2,
        foregroundStyle: FOREGROUND_STYLE,
        handlerStyle: HANDLER_STYLE,
        textStyle: TEXT_STYLE
      } });
    };
    Slider3.prototype.update = function(cfg) {
      var start = cfg.start, end = cfg.end;
      var validCfg = __assign7({}, cfg);
      if (!is_nil_default(start)) {
        validCfg.start = clamp_default(start, 0, 1);
      }
      if (!is_nil_default(end)) {
        validCfg.end = clamp_default(end, 0, 1);
      }
      _super.prototype.update.call(this, validCfg);
      this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
      this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
      this.trend = this.getChildComponentById(this.getElementId("trend"));
    };
    Slider3.prototype.init = function() {
      this.set("start", clamp_default(this.get("start"), 0, 1));
      this.set("end", clamp_default(this.get("end"), 0, 1));
      _super.prototype.init.call(this);
    };
    Slider3.prototype.render = function() {
      _super.prototype.render.call(this);
      this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
    };
    Slider3.prototype.renderInner = function(group2) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end, width = _a4.width, height = _a4.height, _b = _a4.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a4.minText, maxText = _a4.maxText, _c = _a4.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a4.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a4.textStyle, textStyle2 = _e === void 0 ? {} : _e;
      var handlerStyle = deep_mix_default({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
      var min7 = start * width;
      var max7 = end * width;
      if (size2(get_default(trendCfg, "data"))) {
        this.trend = this.addComponent(group2, __assign7({
          component: Trend,
          id: this.getElementId("trend"),
          x: 0,
          y: 0,
          width,
          height
        }, trendCfg));
      }
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign7({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var minTextShape = this.addShape(group2, {
        id: this.getElementId("minText"),
        type: "text",
        attrs: __assign7({
          y: height / 2,
          textAlign: "right",
          text: minText,
          silent: false
        }, textStyle2)
      });
      var maxTextShape = this.addShape(group2, {
        id: this.getElementId("maxText"),
        type: "text",
        attrs: __assign7({
          y: height / 2,
          textAlign: "left",
          text: maxText,
          silent: false
        }, textStyle2)
      });
      var foregroundShape = this.addShape(group2, {
        id: this.getElementId("foreground"),
        name: "foreground",
        type: "rect",
        attrs: __assign7({
          y: 0,
          height
        }, foregroundStyle)
      });
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var handlerHeight = get_default(handlerStyle, "height", 24);
      this.minHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("minHandler"),
        name: "handler-min",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
      this.maxHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("maxHandler"),
        name: "handler-max",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
    };
    Slider3.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Slider3.prototype.initEvent = function() {
      this.bindEvents();
    };
    Slider3.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end, width = _a4.width, minText = _a4.minText, maxText = _a4.maxText, handlerStyle = _a4.handlerStyle, height = _a4.height;
      var min7 = start * width;
      var max7 = end * width;
      if (this.trend) {
        this.trend.update({
          width,
          height
        });
        if (!this.get("updateAutoRender")) {
          this.trend.render();
        }
      }
      foregroundShape.attr("x", min7);
      foregroundShape.attr("width", max7 - min7);
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      minTextShape.attr("text", minText);
      maxTextShape.attr("text", maxText);
      var _b = this._dodgeText([min7, max7], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
      if (this.minHandler) {
        this.minHandler.update({
          x: min7 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.minHandler.render();
        }
      }
      each_default(minAttrs, function(v, k) {
        return minTextShape.attr(k, v);
      });
      if (this.maxHandler) {
        this.maxHandler.update({
          x: max7 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.maxHandler.render();
        }
      }
      each_default(maxAttrs, function(v, k) {
        return maxTextShape.attr(k, v);
      });
    };
    Slider3.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
      group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
      group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
      group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
      var foreground = group2.findById(this.getElementId("foreground"));
      foreground.on("mousedown", this.onMouseDown("foreground"));
      foreground.on("touchstart", this.onMouseDown("foreground"));
    };
    Slider3.prototype.adjustOffsetRange = function(offsetRange) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end;
      switch (this.currentTarget) {
        case "minHandler": {
          var min7 = 0 - start;
          var max7 = 1 - start;
          return Math.min(max7, Math.max(min7, offsetRange));
        }
        case "maxHandler": {
          var min7 = 0 - end;
          var max7 = 1 - end;
          return Math.min(max7, Math.max(min7, offsetRange));
        }
        case "foreground": {
          var min7 = 0 - start;
          var max7 = 1 - end;
          return Math.min(max7, Math.max(min7, offsetRange));
        }
      }
    };
    Slider3.prototype.updateStartEnd = function(offsetRange) {
      var _a4 = this.cfg, start = _a4.start, end = _a4.end;
      switch (this.currentTarget) {
        case "minHandler":
          start += offsetRange;
          break;
        case "maxHandler":
          end += offsetRange;
          break;
        case "foreground":
          start += offsetRange;
          end += offsetRange;
          break;
      }
      this.set("start", start);
      this.set("end", end);
    };
    Slider3.prototype._dodgeText = function(range5, minTextShape, maxTextShape) {
      var _a4, _b;
      var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
      var PADDING = 2;
      var handlerWidth = get_default(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var min7 = range5[0], max7 = range5[1];
      var sorted = false;
      if (min7 > max7) {
        _a4 = [max7, min7], min7 = _a4[0], max7 = _a4[1];
        _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
        sorted = true;
      }
      var minBBox = minTextShape.getBBox();
      var maxBBox = maxTextShape.getBBox();
      var minAttrs = minBBox.width > min7 - PADDING ? { x: min7 + handlerWidth / 2 + PADDING, textAlign: "left" } : { x: min7 - handlerWidth / 2 - PADDING, textAlign: "right" };
      var maxAttrs = maxBBox.width > width - max7 - PADDING ? { x: max7 - handlerWidth / 2 - PADDING, textAlign: "right" } : { x: max7 + handlerWidth / 2 + PADDING, textAlign: "left" };
      return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    Slider3.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Slider3.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    return Slider3;
  }(group_component_default);

  // node_modules/@antv/component/esm/scrollbar/scrollbar.js
  var DEFAULT_STYLE = {
    trackColor: "rgba(0,0,0,0)",
    thumbColor: "rgba(0,0,0,0.15)",
    size: 8,
    lineCap: "round"
  };
  var DEFAULT_THEME = {
    default: DEFAULT_STYLE,
    hover: {
      thumbColor: "rgba(0,0,0,0.2)"
    }
  };
  var Scrollbar = function(_super) {
    __extends7(Scrollbar3, _super);
    function Scrollbar3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clearEvents = noop_default;
      _this.onStartEvent = function(isMobile2) {
        return function(e) {
          _this.isMobile = isMobile2;
          e.originalEvent.preventDefault();
          var clientX = isMobile2 ? get_default(e.originalEvent, "touches.0.clientX") : e.clientX;
          var clientY = isMobile2 ? get_default(e.originalEvent, "touches.0.clientY") : e.clientY;
          _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
          _this.bindLaterEvent();
        };
      };
      _this.bindLaterEvent = function() {
        var containerDOM = _this.getContainerDOM();
        var events = [];
        if (_this.isMobile) {
          events = [
            addEventListener2(containerDOM, "touchmove", _this.onMouseMove),
            addEventListener2(containerDOM, "touchend", _this.onMouseUp),
            addEventListener2(containerDOM, "touchcancel", _this.onMouseUp)
          ];
        } else {
          events = [
            addEventListener2(containerDOM, "mousemove", _this.onMouseMove),
            addEventListener2(containerDOM, "mouseup", _this.onMouseUp),
            addEventListener2(containerDOM, "mouseleave", _this.onMouseUp)
          ];
        }
        _this.clearEvents = function() {
          events.forEach(function(e) {
            e.remove();
          });
        };
      };
      _this.onMouseMove = function(e) {
        var _a4 = _this.cfg, isHorizontal = _a4.isHorizontal, thumbOffset = _a4.thumbOffset;
        e.preventDefault();
        var clientX = _this.isMobile ? get_default(e, "touches.0.clientX") : e.clientX;
        var clientY = _this.isMobile ? get_default(e, "touches.0.clientY") : e.clientY;
        var endPos = isHorizontal ? clientX : clientY;
        var diff2 = endPos - _this.startPos;
        _this.startPos = endPos;
        _this.updateThumbOffset(thumbOffset + diff2);
      };
      _this.onMouseUp = function(e) {
        e.preventDefault();
        _this.clearEvents();
      };
      _this.onTrackClick = function(e) {
        var _a4 = _this.cfg, isHorizontal = _a4.isHorizontal, x = _a4.x, y = _a4.y, thumbLen = _a4.thumbLen;
        var containerDOM = _this.getContainerDOM();
        var rect = containerDOM.getBoundingClientRect();
        var clientX = e.clientX, clientY = e.clientY;
        var offset = isHorizontal ? clientX - rect.left - x - thumbLen / 2 : clientY - rect.top - y - thumbLen / 2;
        var newOffset = _this.validateRange(offset);
        _this.updateThumbOffset(newOffset);
      };
      _this.onThumbMouseOver = function() {
        var thumbColor = _this.cfg.theme.hover.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      _this.onThumbMouseOut = function() {
        var thumbColor = _this.cfg.theme.default.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      return _this;
    }
    Scrollbar3.prototype.setRange = function(min7, max7) {
      this.set("minLimit", min7);
      this.set("maxLimit", max7);
      var curValue = this.getValue();
      var newValue = clamp_default(curValue, min7, max7);
      if (curValue !== newValue && !this.get("isInit")) {
        this.setValue(newValue);
      }
    };
    Scrollbar3.prototype.getRange = function() {
      var min7 = this.get("minLimit") || 0;
      var max7 = this.get("maxLimit") || 1;
      return { min: min7, max: max7 };
    };
    Scrollbar3.prototype.setValue = function(value) {
      var range5 = this.getRange();
      var originalValue = this.getValue();
      this.update({
        thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp_default(value, range5.min, range5.max)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: this.getValue()
      });
    };
    Scrollbar3.prototype.getValue = function() {
      return clamp_default(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
    };
    Scrollbar3.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign7(__assign7({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
    };
    Scrollbar3.prototype.renderInner = function(group2) {
      this.renderTrackShape(group2);
      this.renderThumbShape(group2);
    };
    Scrollbar3.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Scrollbar3.prototype.initEvent = function() {
      this.bindEvents();
    };
    Scrollbar3.prototype.renderTrackShape = function(group2) {
      var _a4 = this.cfg, trackLen = _a4.trackLen, _b = _a4.theme, theme = _b === void 0 ? { default: {} } : _b;
      var _c = deep_mix_default({}, DEFAULT_THEME, theme).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
      var size3 = get_default(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: 0 + size3 / 2,
        y1: size3 / 2,
        x2: trackLen - size3 / 2,
        y2: size3 / 2,
        lineWidth: size3,
        stroke: trackColor,
        lineCap
      } : {
        x1: size3 / 2,
        y1: 0 + size3 / 2,
        x2: size3 / 2,
        y2: trackLen - size3 / 2,
        lineWidth: size3,
        stroke: trackColor,
        lineCap
      };
      return this.addShape(group2, {
        id: this.getElementId("track"),
        name: "track",
        type: "line",
        attrs
      });
    };
    Scrollbar3.prototype.renderThumbShape = function(group2) {
      var _a4 = this.cfg, thumbOffset = _a4.thumbOffset, thumbLen = _a4.thumbLen, theme = _a4.theme;
      var _b = deep_mix_default({}, DEFAULT_THEME, theme).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
      var size3 = get_default(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: thumbOffset + size3 / 2,
        y1: size3 / 2,
        x2: thumbOffset + thumbLen - size3 / 2,
        y2: size3 / 2,
        lineWidth: size3,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      } : {
        x1: size3 / 2,
        y1: thumbOffset + size3 / 2,
        x2: size3 / 2,
        y2: thumbOffset + thumbLen - size3 / 2,
        lineWidth: size3,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      };
      return this.addShape(group2, {
        id: this.getElementId("thumb"),
        name: "thumb",
        type: "line",
        attrs
      });
    };
    Scrollbar3.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("mousedown", this.onStartEvent(false));
      group2.on("mouseup", this.onMouseUp);
      group2.on("touchstart", this.onStartEvent(true));
      group2.on("touchend", this.onMouseUp);
      var trackShape = group2.findById(this.getElementId("track"));
      trackShape.on("click", this.onTrackClick);
      var thumbShape = group2.findById(this.getElementId("thumb"));
      thumbShape.on("mouseover", this.onThumbMouseOver);
      thumbShape.on("mouseout", this.onThumbMouseOut);
    };
    Scrollbar3.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    Scrollbar3.prototype.validateRange = function(offset) {
      var _a4 = this.cfg, thumbLen = _a4.thumbLen, trackLen = _a4.trackLen;
      var newOffset = offset;
      if (offset + thumbLen > trackLen) {
        newOffset = trackLen - thumbLen;
      } else if (offset + thumbLen < thumbLen) {
        newOffset = 0;
      }
      return newOffset;
    };
    Scrollbar3.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Scrollbar3.prototype.updateThumbOffset = function(offset) {
      var _a4 = this.cfg, thumbOffset = _a4.thumbOffset, isHorizontal = _a4.isHorizontal, thumbLen = _a4.thumbLen, size3 = _a4.size;
      var newOffset = this.validateRange(offset);
      if (newOffset === thumbOffset) {
        return;
      }
      var thumbShape = this.getElementByLocalId("thumb");
      if (isHorizontal) {
        thumbShape.attr({
          x1: newOffset + size3 / 2,
          x2: newOffset + thumbLen - size3 / 2
        });
      } else {
        thumbShape.attr({
          y1: newOffset + size3 / 2,
          y2: newOffset + thumbLen - size3 / 2
        });
      }
      this.emitOffsetChange(newOffset);
    };
    Scrollbar3.prototype.emitOffsetChange = function(offset) {
      var _a4 = this.cfg, originalValue = _a4.thumbOffset, trackLen = _a4.trackLen, thumbLen = _a4.thumbLen;
      this.cfg.thumbOffset = offset;
      this.emit("scrollchange", {
        thumbOffset: offset,
        ratio: clamp_default(offset / (trackLen - thumbLen), 0, 1)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: offset
      });
    };
    return Scrollbar3;
  }(group_component_default);

  // node_modules/@antv/g2/esm/dependents.js
  var LineAxis = axis_exports.Line;
  var CircleAxis = axis_exports.Circle;
  var LineGrid = grid_exports.Line;
  var CircleGrid = grid_exports.Circle;
  var CategoryLegend = legend_exports.Category;
  var ContinuousLegend = legend_exports.Continuous;
  var HtmlTooltip = tooltip_exports.Html;

  // node_modules/@antv/g2/esm/util/graphics.js
  function getPointsBox(points) {
    if (is_empty_default(points)) {
      return null;
    }
    var minX = points[0].x;
    var maxX = points[0].x;
    var minY = points[0].y;
    var maxY = points[0].y;
    each_default(points, function(point) {
      minX = minX > point.x ? point.x : minX;
      maxX = maxX < point.x ? point.x : maxX;
      minY = minY > point.y ? point.y : minY;
      maxY = maxY < point.y ? point.y : maxY;
    });
    return {
      minX,
      maxX,
      minY,
      maxY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  function uniqueValues(array2) {
    return Array.from(new Set(array2)).length === 1;
  }
  function mid(array2) {
    return (min_default(array2) + max_default(array2)) / 2;
  }
  function polarToCartesian(centerX, centerY, radius, angleInRadian) {
    return {
      x: centerX + radius * Math.cos(angleInRadian),
      y: centerY + radius * Math.sin(angleInRadian)
    };
  }
  function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
    if (innerRadius === void 0) {
      innerRadius = 0;
    }
    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
    var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
    var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
    if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
      var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
      var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
      var circlePathCommands = [
        ["M", start.x, start.y],
        ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
        ["A", radius, radius, 0, 1, 1, end.x, end.y],
        ["M", innerStart.x, innerStart.y]
      ];
      if (innerRadius) {
        circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
        circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
      }
      circlePathCommands.push(["M", start.x, start.y]);
      circlePathCommands.push(["Z"]);
      return circlePathCommands;
    }
    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
    var sectorPathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
      ["L", innerEnd.x, innerEnd.y]
    ];
    if (innerRadius) {
      sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
    }
    sectorPathCommands.push(["L", start.x, start.y]);
    sectorPathCommands.push(["Z"]);
    return sectorPathCommands;
  }
  function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
    var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
    var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
    if (isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
      var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
      return [
        ["M", start.x, start.y],
        ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
        ["A", radius, radius, 0, 1, 1, start.x, start.y],
        ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
        ["A", radius, radius, 0, 1, 0, start.x, start.y],
        ["Z"]
      ];
    }
    var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
    ];
  }
  function getAngle2(shapeModel, coordinate) {
    var points = shapeModel.points;
    var box2 = getPointsBox(points);
    var endAngle;
    var startAngle;
    var coordStartAngle = coordinate.startAngle, coordEndAngle = coordinate.endAngle;
    var diffAngle = coordEndAngle - coordStartAngle;
    if (coordinate.isTransposed) {
      endAngle = box2.maxY * diffAngle;
      startAngle = box2.minY * diffAngle;
    } else {
      endAngle = box2.maxX * diffAngle;
      startAngle = box2.minX * diffAngle;
    }
    endAngle += coordStartAngle;
    startAngle += coordStartAngle;
    return {
      startAngle,
      endAngle
    };
  }
  function getPolygonCentroid(xs, ys) {
    if (is_number_default(xs) && is_number_default(ys)) {
      return [xs, ys];
    }
    xs = xs;
    ys = ys;
    if (uniqueValues(xs) || uniqueValues(ys))
      return [mid(xs), mid(ys)];
    var i = -1;
    var x = 0;
    var y = 0;
    var former;
    var current = xs.length - 1;
    var diff2;
    var k = 0;
    while (++i < xs.length) {
      former = current;
      current = i;
      k += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
      x += (xs[former] + xs[current]) * diff2;
      y += (ys[former] + ys[current]) * diff2;
    }
    k *= 3;
    return [x / k, y / k];
  }
  function getReplaceAttrs(sourceShape, targetShape) {
    var originAttrs = sourceShape.attr();
    var newAttrs = targetShape.attr();
    each_default(originAttrs, function(v, k) {
      if (newAttrs[k] === void 0) {
        newAttrs[k] = void 0;
      }
    });
    return newAttrs;
  }

  // node_modules/@antv/g2/esm/util/helper.js
  function isBetween2(value, start, end) {
    var min7 = Math.min(start, end);
    var max7 = Math.max(start, end);
    return value >= min7 && value <= max7;
  }
  function padEnd(source, targetLength, padValue) {
    if (is_string_default(source)) {
      return source.padEnd(targetLength, padValue);
    } else if (is_array_default(source)) {
      var sourceLength = source.length;
      if (sourceLength < targetLength) {
        var diff2 = targetLength - sourceLength;
        for (var i = 0; i < diff2; i++) {
          source.push(padValue);
        }
      }
    }
    return source;
  }
  function omit(obj, keys2) {
    if (typeof obj === "object") {
      keys2.forEach(function(key) {
        delete obj[key];
      });
    }
    return obj;
  }
  function uniq2(sourceArray, targetArray, map5) {
    if (targetArray === void 0) {
      targetArray = [];
    }
    if (map5 === void 0) {
      map5 = new Map();
    }
    for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {
      var source = sourceArray_1[_i];
      if (!map5.has(source)) {
        targetArray.push(source);
        map5.set(source, true);
      }
    }
    return targetArray;
  }

  // node_modules/@antv/g2/esm/util/bbox.js
  var BBox = function() {
    function BBox2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = x;
      this.y = y;
      this.height = height;
      this.width = width;
    }
    BBox2.fromRange = function(minX, minY, maxX, maxY) {
      return new BBox2(minX, minY, maxX - minX, maxY - minY);
    };
    BBox2.fromObject = function(bbox) {
      return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
    };
    Object.defineProperty(BBox2.prototype, "minX", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxX", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "minY", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxY", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tl", {
      get: function() {
        return { x: this.x, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tr", {
      get: function() {
        return { x: this.maxX, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bl", {
      get: function() {
        return { x: this.x, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "br", {
      get: function() {
        return { x: this.maxX, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.minY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return {
          x: this.maxX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.maxY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return {
          x: this.minX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    BBox2.prototype.isEqual = function(bbox) {
      return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
    };
    BBox2.prototype.contains = function(child) {
      return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
    };
    BBox2.prototype.clone = function() {
      return new BBox2(this.x, this.y, this.width, this.height);
    };
    BBox2.prototype.add = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each_default(subBBox, function(b) {
        bbox.x = Math.min(b.x, bbox.x);
        bbox.y = Math.min(b.y, bbox.y);
        bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.merge = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each_default(subBBox, function(b) {
        bbox.x = Math.max(b.x, bbox.x);
        bbox.y = Math.max(b.y, bbox.y);
        bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.cut = function(subBBox, direction2) {
      var width = subBBox.width;
      var height = subBBox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
        default:
          return this;
      }
    };
    BBox2.prototype.shrink = function(gap) {
      var top = gap[0], right = gap[1], bottom = gap[2], left = gap[3];
      return new BBox2(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);
    };
    BBox2.prototype.expand = function(gap) {
      var top = gap[0], right = gap[1], bottom = gap[2], left = gap[3];
      return new BBox2(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);
    };
    BBox2.prototype.exceed = function(bbox) {
      return [
        Math.max(-this.minY + bbox.minY, 0),
        Math.max(this.maxX - bbox.maxX, 0),
        Math.max(this.maxY - bbox.maxY, 0),
        Math.max(-this.minX + bbox.minX, 0)
      ];
    };
    BBox2.prototype.collide = function(bbox) {
      return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
    };
    BBox2.prototype.size = function() {
      return this.width * this.height;
    };
    BBox2.prototype.isPointIn = function(p3) {
      return p3.x >= this.minX && p3.x <= this.maxX && p3.y >= this.minY && p3.y <= this.maxY;
    };
    return BBox2;
  }();
  function toPoints(bbox) {
    return [
      [bbox.minX, bbox.minY],
      [bbox.maxX, bbox.minY],
      [bbox.maxX, bbox.maxY],
      [bbox.minX, bbox.maxY]
    ];
  }

  // node_modules/@antv/g2/esm/util/coordinate.js
  function getXDimensionLength(coordinate) {
    if (coordinate.isPolar && !coordinate.isTransposed) {
      return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();
    }
    var start = coordinate.convert({ x: 0, y: 0 });
    var end = coordinate.convert({ x: 1, y: 0 });
    return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
  }
  function isFullCircle(coordinate) {
    if (coordinate.isPolar) {
      var startAngle = coordinate.startAngle, endAngle = coordinate.endAngle;
      return endAngle - startAngle === Math.PI * 2;
    }
    return false;
  }
  function getDistanceToCenter(coordinate, point) {
    var center = coordinate.getCenter();
    return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
  }
  function isPointInCoordinate(coordinate, point) {
    var result = false;
    if (coordinate) {
      if (coordinate.type === "theta") {
        var start = coordinate.start, end = coordinate.end;
        result = isBetween2(point.x, start.x, end.x) && isBetween2(point.y, start.y, end.y);
      } else {
        var invertPoint = coordinate.invert(point);
        result = isBetween2(invertPoint.x, 0, 1) && isBetween2(invertPoint.y, 0, 1);
      }
    }
    return result;
  }
  function getAngleByPoint(coordinate, point) {
    var center = coordinate.getCenter();
    return Math.atan2(point.y - center.y, point.x - center.x);
  }
  function getCoordinateClipCfg(coordinate, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    if (coordinate.isPolar) {
      var startAngle_1 = coordinate.startAngle, endAngle_1 = coordinate.endAngle;
      var center_1 = coordinate.getCenter();
      var radius_1 = coordinate.getRadius();
      return {
        type: "path",
        startState: {
          path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
        },
        endState: function(ratio) {
          var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
          var path = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
          return {
            path
          };
        },
        attrs: {
          path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
        }
      };
    }
    var endState;
    if (coordinate.isTransposed) {
      endState = {
        height: height + margin * 2
      };
    } else {
      endState = {
        width: width + margin * 2
      };
    }
    return {
      type: "rect",
      startState: {
        x: start.x - margin,
        y: end.y - margin,
        width: coordinate.isTransposed ? width + margin * 2 : 0,
        height: coordinate.isTransposed ? 0 : height + margin * 2
      },
      endState,
      attrs: {
        x: start.x - margin,
        y: end.y - margin,
        width: width + margin * 2,
        height: height + margin * 2
      }
    };
  }
  function getCoordinateBBox(coordinate, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);
    return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
  }

  // node_modules/@antv/g2/esm/util/scale.js
  var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
  function getDefaultType(value) {
    var type = "linear";
    if (dateRegex.test(value)) {
      type = "timeCat";
    } else if (is_string_default(value)) {
      type = "cat";
    }
    return type;
  }
  function createScaleByField(field, data, scaleDef) {
    var validData = data || [];
    if (is_number_default(field) || is_nil_default(first_value_default(validData, field)) && is_empty_default(scaleDef)) {
      var Identity4 = getClass("identity");
      return new Identity4({
        field: field.toString(),
        values: [field]
      });
    }
    var values2 = values_of_key_default(validData, field);
    var type = get_default(scaleDef, "type", getDefaultType(values2[0]));
    var ScaleCtor = getClass(type);
    return new ScaleCtor(__assign({ field, values: values2 }, scaleDef));
  }
  function syncScale(scale5, newScale) {
    if (scale5.type !== "identity" && newScale.type !== "identity") {
      var obj = {};
      for (var k in newScale) {
        if (Object.prototype.hasOwnProperty.call(newScale, k)) {
          obj[k] = newScale[k];
        }
      }
      scale5.change(obj);
    }
  }
  function getName(scale5) {
    return scale5.alias || scale5.field;
  }
  function getDefaultCategoryScaleRange(scale5, coordinate, theme) {
    var values2 = scale5.values;
    var count2 = values2.length;
    var range5;
    if (count2 === 1) {
      range5 = [0.5, 1];
    } else {
      var widthRatio = 1;
      var offset = 0;
      if (isFullCircle(coordinate)) {
        if (!coordinate.isTransposed) {
          range5 = [0, 1 - 1 / count2];
        } else {
          widthRatio = get_default(theme, "widthRatio.multiplePie", 1 / 1.3);
          offset = 1 / count2 * widthRatio;
          range5 = [offset / 2, 1 - offset / 2];
        }
      } else {
        offset = 1 / count2 / 2;
        range5 = [offset, 1 - offset];
      }
    }
    return range5;
  }
  function getMaxScale(scale5) {
    var values2 = scale5.values.filter(function(item) {
      return !is_nil_default(item) && !isNaN(item);
    });
    return Math.max.apply(Math, __spreadArray(__spreadArray([], values2, false), [is_nil_default(scale5.max) ? -Infinity : scale5.max], false));
  }

  // node_modules/@antv/g2/esm/util/axis.js
  function getLineAxisRelativeRegion(direction2) {
    var start;
    var end;
    switch (direction2) {
      case DIRECTION.TOP:
        start = { x: 0, y: 1 };
        end = { x: 1, y: 1 };
        break;
      case DIRECTION.RIGHT:
        start = { x: 1, y: 0 };
        end = { x: 1, y: 1 };
        break;
      case DIRECTION.BOTTOM:
        start = { x: 0, y: 0 };
        end = { x: 1, y: 0 };
        break;
      case DIRECTION.LEFT:
        start = { x: 0, y: 0 };
        end = { x: 0, y: 1 };
        break;
      default:
        start = end = { x: 0, y: 0 };
    }
    return { start, end };
  }
  function getCircleAxisRelativeRegion(coordinate) {
    var start;
    var end;
    if (coordinate.isTransposed) {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 0
      };
    } else {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
    }
    return { start, end };
  }
  function getAxisRegion(coordinate, direction2) {
    var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
    if (coordinate.isRect) {
      region = getLineAxisRelativeRegion(direction2);
    } else if (coordinate.isPolar) {
      region = getCircleAxisRelativeRegion(coordinate);
    }
    var start = region.start, end = region.end;
    return {
      start: coordinate.convert(start),
      end: coordinate.convert(end)
    };
  }
  function isVertical(region) {
    var start = region.start, end = region.end;
    return start.x === end.x;
  }
  function getAxisFactorByRegion(region, center) {
    var start = region.start, end = region.end;
    var isAxisVertical = isVertical(region);
    if (isAxisVertical) {
      if ((start.y - end.y) * (center.x - start.x) > 0) {
        return 1;
      } else {
        return -1;
      }
    } else {
      if ((end.x - start.x) * (start.y - center.y) > 0) {
        return -1;
      } else {
        return 1;
      }
    }
  }
  function getAxisThemeCfg(theme, direction2) {
    var axisTheme = get_default(theme, ["components", "axis"], {});
    return deep_mix_default({}, get_default(axisTheme, ["common"], {}), deep_mix_default({}, get_default(axisTheme, [direction2], {})));
  }
  function getAxisTitleOptions(theme, direction2, axisOptions) {
    var axisTheme = get_default(theme, ["components", "axis"], {});
    return deep_mix_default({}, get_default(axisTheme, ["common", "title"], {}), deep_mix_default({}, get_default(axisTheme, [direction2, "title"], {})), axisOptions);
  }
  function getCircleAxisCenterRadius(coordinate) {
    var x = coordinate.x, y = coordinate.y, center = coordinate.circleCenter;
    var isReflectY = y.start > y.end;
    var start = coordinate.isTransposed ? coordinate.convert({
      x: isReflectY ? 0 : 1,
      y: 0
    }) : coordinate.convert({
      x: 0,
      y: isReflectY ? 0 : 1
    });
    var startVector = [start.x - center.x, start.y - center.y];
    var normalVector = [1, 0];
    var startAngle = start.y > center.y ? vec2_exports.angle(startVector, normalVector) : vec2_exports.angle(startVector, normalVector) * -1;
    var endAngle = startAngle + (x.end - x.start);
    var radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
    return {
      center,
      radius,
      startAngle,
      endAngle
    };
  }
  function getAxisOption(axes, field) {
    if (is_boolean_default(axes)) {
      return axes === false ? false : {};
    }
    return get_default(axes, [field]);
  }
  function getAxisDirection(axisOption, def2) {
    return get_default(axisOption, "position", def2);
  }
  function getAxisTitleText(scale5, axisOption) {
    return get_default(axisOption, ["title", "text"], getName(scale5));
  }

  // node_modules/@antv/g2/esm/facet/facet.js
  var Facet = function() {
    function Facet2(view, cfg) {
      this.destroyed = false;
      this.facets = [];
      this.view = view;
      this.cfg = deep_mix_default({}, this.getDefaultCfg(), cfg);
    }
    Facet2.prototype.init = function() {
      if (!this.container) {
        this.container = this.createContainer();
      }
      var data = this.view.getData();
      this.facets = this.generateFacets(data);
    };
    Facet2.prototype.render = function() {
      this.renderViews();
    };
    Facet2.prototype.update = function() {
    };
    Facet2.prototype.clear = function() {
      this.clearFacetViews();
    };
    Facet2.prototype.destroy = function() {
      this.clear();
      if (this.container) {
        this.container.remove(true);
        this.container = void 0;
      }
      this.destroyed = true;
      this.view = void 0;
      this.facets = [];
    };
    Facet2.prototype.facetToView = function(facet) {
      var region = facet.region, data = facet.data, _a4 = facet.padding, padding = _a4 === void 0 ? this.cfg.padding : _a4;
      var view = this.view.createView({
        region,
        padding
      });
      view.data(data || []);
      facet.view = view;
      this.beforeEachView(view, facet);
      var eachView = this.cfg.eachView;
      if (eachView) {
        eachView(view, facet);
      }
      this.afterEachView(view, facet);
      return view;
    };
    Facet2.prototype.createContainer = function() {
      var foregroundGroup = this.view.getLayer(LAYER.FORE);
      return foregroundGroup.addGroup();
    };
    Facet2.prototype.renderViews = function() {
      this.createFacetViews();
    };
    Facet2.prototype.createFacetViews = function() {
      var _this = this;
      return this.facets.map(function(facet) {
        return _this.facetToView(facet);
      });
    };
    Facet2.prototype.clearFacetViews = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        if (facet.view) {
          _this.view.removeView(facet.view);
          facet.view = void 0;
        }
      });
    };
    Facet2.prototype.parseSpacing = function() {
      var _a4 = this.view.viewBBox, width = _a4.width, height = _a4.height;
      var spacing = this.cfg.spacing;
      return spacing.map(function(s, idx) {
        if (is_number_default(s))
          return s / (idx === 0 ? width : height);
        else
          return parseFloat(s) / 100;
      });
    };
    Facet2.prototype.getFieldValues = function(data, field) {
      var rst = [];
      var cache3 = {};
      each_default(data, function(d) {
        var value = d[field];
        if (!is_nil_default(value) && !cache3[value]) {
          rst.push(value);
          cache3[value] = true;
        }
      });
      return rst;
    };
    Facet2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var _a4 = this.parseSpacing(), xSpacing = _a4[0], ySpacing = _a4[1];
      var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
      var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
      var start = {
        x: (xRatio + xSpacing) * xIndex,
        y: (yRatio + ySpacing) * yIndex
      };
      var end = {
        x: start.x + xRatio,
        y: start.y + yRatio
      };
      return { start, end };
    };
    Facet2.prototype.getDefaultCfg = function() {
      return {
        eachView: void 0,
        showTitle: true,
        spacing: [0, 0],
        padding: 10,
        fields: []
      };
    };
    Facet2.prototype.getDefaultTitleCfg = function() {
      var fontFamily = this.view.getTheme().fontFamily;
      return {
        style: {
          fontSize: 14,
          fill: "#666",
          fontFamily
        }
      };
    };
    Facet2.prototype.processAxis = function(view, facet) {
      var options = view.getOptions();
      var coordinateOption = options.coordinate;
      var geometries = view.geometries;
      var coordinateType = get_default(coordinateOption, "type", "rect");
      if (coordinateType === "rect" && geometries.length) {
        if (is_nil_default(options.axes)) {
          options.axes = {};
        }
        var axes = options.axes;
        var _a4 = geometries[0].getXYFields(), x = _a4[0], y = _a4[1];
        var xOption = getAxisOption(axes, x);
        var yOption = getAxisOption(axes, y);
        if (xOption !== false) {
          options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
        }
        if (yOption !== false) {
          options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
        }
      }
    };
    Facet2.prototype.getFacetDataFilter = function(conditions) {
      return function(datum) {
        return every_default(conditions, function(condition) {
          var field = condition.field, value = condition.value;
          if (!is_nil_default(value) && field) {
            return datum[field] === value;
          }
          return true;
        });
      };
    };
    return Facet2;
  }();

  // node_modules/@antv/g2/esm/facet/index.js
  var Facets = {};
  var getFacet = function(type) {
    return Facets[lower_case_default(type)];
  };
  var registerFacet = function(type, ctor) {
    Facets[lower_case_default(type)] = ctor;
  };

  // node_modules/@antv/g2/esm/interaction/action/base.js
  var Action = function() {
    function Action2(context, cfg) {
      this.context = context;
      this.cfg = cfg;
      context.addAction(this);
    }
    Action2.prototype.applyCfg = function(cfg) {
      mix(this, cfg);
    };
    Action2.prototype.init = function() {
      this.applyCfg(this.cfg);
    };
    Action2.prototype.destroy = function() {
      this.context.removeAction(this);
      this.context = null;
    };
    return Action2;
  }();
  var base_default13 = Action;

  // node_modules/@antv/g2/esm/interaction/action/callback.js
  var CallbackAction = function(_super) {
    __extends(CallbackAction2, _super);
    function CallbackAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CallbackAction2.prototype.execute = function() {
      if (this.callback) {
        this.callback(this.context);
      }
    };
    CallbackAction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.callback = null;
    };
    return CallbackAction2;
  }(base_default13);
  var callback_default = CallbackAction;

  // node_modules/@antv/g2/esm/interaction/action/register.js
  var ActionCache = {};
  function createAction(actionName, context) {
    var actionOption = ActionCache[actionName];
    var action = null;
    if (actionOption) {
      var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
      action = new ActionClass(context, cfg);
      action.name = actionName;
      action.init();
    }
    return action;
  }
  function registerAction(actionName, ActionClass, cfg) {
    ActionCache[actionName] = {
      ActionClass,
      cfg
    };
  }
  function createCallbackAction(callback, context) {
    var action = new callback_default(context);
    action.callback = callback;
    action.name = "callback";
    return action;
  }

  // node_modules/@antv/g2/esm/geometry/shape/util/path.js
  function _points2path(points, isInCircle) {
    var path = [];
    if (points.length) {
      path.push(["M", points[0].x, points[0].y]);
      for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
        var item = points[i];
        path.push(["L", item.x, item.y]);
      }
      if (isInCircle) {
        path.push(["Z"]);
      }
    }
    return path;
  }
  function _convertArr(arr, coord) {
    var tmp = [arr[0]];
    for (var i = 1, len3 = arr.length; i < len3; i = i + 2) {
      var point = coord.convert({
        x: arr[i],
        y: arr[i + 1]
      });
      tmp.push(point.x, point.y);
    }
    return tmp;
  }
  function _convertArcPath(path, coord) {
    var isTransposed = coord.isTransposed;
    var r = path[1];
    var x = path[6];
    var y = path[7];
    var point = coord.convert({ x, y });
    var direction2 = isTransposed ? 0 : 1;
    return ["A", r, r, 0, 0, direction2, point.x, point.y];
  }
  function _convertPolarPath(pre, cur, coord) {
    var isTransposed = coord.isTransposed, startAngle = coord.startAngle, endAngle = coord.endAngle;
    var prePoint = pre[0].toLowerCase() === "a" ? {
      x: pre[6],
      y: pre[7]
    } : {
      x: pre[1],
      y: pre[2]
    };
    var curPoint = {
      x: cur[1],
      y: cur[2]
    };
    var rst = [];
    var xDim = isTransposed ? "y" : "x";
    var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
    var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
    var flag = angleRange > Math.PI ? 1 : 0;
    var convertPoint = coord.convert(curPoint);
    var r = getDistanceToCenter(coord, convertPoint);
    if (r >= 0.5) {
      if (angleRange === Math.PI * 2) {
        var middlePoint = {
          x: (curPoint.x + prePoint.x) / 2,
          y: (curPoint.y + prePoint.y) / 2
        };
        var middleConvertPoint = coord.convert(middlePoint);
        rst.push(["A", r, r, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
        rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
      } else {
        rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
      }
    }
    return rst;
  }
  function _filterFullCirleLine(path) {
    each_default(path, function(subPath, index) {
      var cur = subPath;
      if (cur[0].toLowerCase() === "a") {
        var pre = path[index - 1];
        var next = path[index + 1];
        if (next && next[0].toLowerCase() === "a") {
          if (pre && pre[0].toLowerCase() === "l") {
            pre[0] = "M";
          }
        } else if (pre && pre[0].toLowerCase() === "a") {
          if (next && next[0].toLowerCase() === "l") {
            next[0] = "M";
          }
        }
      }
    });
  }
  var smoothBezier2 = function(points, smooth, isLoop, constraint) {
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min7;
    var max7;
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      min7 = constraint[0], max7 = constraint[1];
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        min7 = vec2_exports.min([0, 0], min7, point);
        max7 = vec2_exports.max([0, 0], max7, point);
      }
    }
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point;
      } else if (i === len3 - 1 && !isLoop) {
        cp1 = point;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        prevPoint = points[isLoop ? i ? i - 1 : len3 - 1 : i - 1];
        nextPoint = points[isLoop ? (i + 1) % len3 : i + 1];
        var v = [0, 0];
        v = vec2_exports.sub(v, nextPoint, prevPoint);
        v = vec2_exports.scale(v, v, smooth);
        var d0 = vec2_exports.distance(point, prevPoint);
        var d1 = vec2_exports.distance(point, nextPoint);
        var sum5 = d0 + d1;
        if (sum5 !== 0) {
          d0 /= sum5;
          d1 /= sum5;
        }
        var v1 = vec2_exports.scale([0, 0], v, -d0);
        var v2 = vec2_exports.scale([0, 0], v, d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
        nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
        v1 = vec2_exports.sub([0, 0], nextCp0, point);
        v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
        cp1 = vec2_exports.add([0, 0], point, v1);
        cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
        cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
        v2 = vec2_exports.sub([0, 0], point, cp1);
        v2 = vec2_exports.scale([0, 0], v2, d1 / d0);
        nextCp0 = vec2_exports.add([0, 0], point, v2);
        if (hasConstraint) {
          cp1 = vec2_exports.max([0, 0], cp1, min7);
          cp1 = vec2_exports.min([0, 0], cp1, max7);
          nextCp0 = vec2_exports.max([0, 0], nextCp0, min7);
          nextCp0 = vec2_exports.min([0, 0], nextCp0, max7);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  };
  function catmullRom2bezier(crp, z, constraint) {
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l = crp.length; i < l; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier2(pointList, 0.4, isLoop, constraint);
    var len3 = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p3;
    for (var i = 0; i < len3 - 1; i++) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p3 = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len3];
      cp2 = controlPointList[len3 + 1];
      p3 = pointList[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p3[0], p3[1]]);
    }
    return d1;
  }
  function getLinePath2(points, isInCircle) {
    return _points2path(points, isInCircle);
  }
  function getSplinePath(points, isInCircle, constaint) {
    var data = [];
    var first = points[0];
    var prePoint = null;
    if (points.length <= 2) {
      return getLinePath2(points, isInCircle);
    }
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
        data.push(point.x);
        data.push(point.y);
        prePoint = point;
      }
    }
    var constraint = constaint || [
      [0, 0],
      [1, 1]
    ];
    var splinePath = catmullRom2bezier(data, isInCircle, constraint);
    splinePath.unshift(["M", first.x, first.y]);
    return splinePath;
  }
  function convertNormalPath(coord, path) {
    var tmp = [];
    each_default(path, function(subPath) {
      var action = subPath[0];
      switch (action.toLowerCase()) {
        case "m":
        case "l":
        case "c":
          tmp.push(_convertArr(subPath, coord));
          break;
        case "a":
          tmp.push(_convertArcPath(subPath, coord));
          break;
        case "z":
        default:
          tmp.push(subPath);
          break;
      }
    });
    return tmp;
  }
  function convertPolarPath(coord, path) {
    var tmp = [];
    var pre;
    var cur;
    var transposed;
    var equals4;
    each_default(path, function(subPath, index) {
      var action = subPath[0];
      switch (action.toLowerCase()) {
        case "m":
        case "c":
        case "q":
          tmp.push(_convertArr(subPath, coord));
          break;
        case "l":
          pre = path[index - 1];
          cur = subPath;
          transposed = coord.isTransposed;
          equals4 = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
          if (equals4) {
            tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
          } else {
            tmp.push(_convertArr(subPath, coord));
          }
          break;
        case "a":
          tmp.push(_convertArcPath(subPath, coord));
          break;
        case "z":
        default:
          tmp.push(subPath);
          break;
      }
    });
    _filterFullCirleLine(tmp);
    return tmp;
  }

  // node_modules/@antv/g2/esm/interaction/action/util.js
  function getMaskBBox(context, tolerance3) {
    var event = context.event;
    var maskShape = event.target;
    var maskBBox = maskShape.getCanvasBBox();
    if (!(maskBBox.width >= tolerance3 || maskBBox.height >= tolerance3)) {
      return null;
    }
    return maskBBox;
  }
  function getMaskPath(context, tolerance3) {
    var event = context.event;
    var maskShape = event.target;
    var maskBBox = maskShape.getCanvasBBox();
    if (!(maskBBox.width >= tolerance3 || maskBBox.height >= tolerance3)) {
      return null;
    }
    return maskShape.attr("path");
  }
  function getCurrentElement(context) {
    var event = context.event;
    var element;
    var target = event.target;
    if (target) {
      element = target.get("element");
    }
    return element;
  }
  function getDelegationObject(context) {
    var event = context.event;
    var target = event.target;
    var delegateObject;
    if (target) {
      delegateObject = target.get("delegateObject");
    }
    return delegateObject;
  }
  function isElementChange(context) {
    var event = context.event.gEvent;
    if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
      return false;
    }
    return true;
  }
  function isList(delegateObject) {
    return delegateObject && delegateObject.component && delegateObject.component.isList();
  }
  function isSlider(delegateObject) {
    return delegateObject && delegateObject.component && delegateObject.component.isSlider();
  }
  function isMask(context) {
    var event = context.event;
    var target = event.target;
    return target && target.get("name") === "mask";
  }
  function getMaskedElements(context, tolerance3) {
    var target = context.event.target;
    if (target.get("type") === "path") {
      var maskPath = getMaskPath(context, tolerance3);
      if (!maskPath) {
        return;
      }
      return getElementsByPath(context.view, maskPath);
    }
    var maskBBox = getMaskBBox(context, tolerance3);
    if (!maskBBox) {
      return null;
    }
    return getIntersectElements(context.view, maskBBox);
  }
  function getSiblingMaskElements(context, sibling, tolerance3) {
    var maskBBox = getMaskBBox(context, tolerance3);
    if (!maskBBox) {
      return null;
    }
    var view = context.view;
    var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
    var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
    var box2 = {
      minX: start.x,
      minY: start.y,
      maxX: end.x,
      maxY: end.y
    };
    return getIntersectElements(sibling, box2);
  }
  function getElements(view) {
    var geometries = view.geometries;
    var rst = [];
    each_default(geometries, function(geom) {
      var elements = geom.elements;
      rst = rst.concat(elements);
    });
    if (view.views && view.views.length) {
      each_default(view.views, function(subView) {
        rst = rst.concat(getElements(subView));
      });
    }
    return rst;
  }
  function getElementsByField(view, field, value) {
    var elements = getElements(view);
    return elements.filter(function(el) {
      return getElementValue(el, field) === value;
    });
  }
  function getElementsByState(view, stateName) {
    var geometries = view.geometries;
    var rst = [];
    each_default(geometries, function(geom) {
      var elements = geom.getElementsBy(function(el) {
        return el.hasState(stateName);
      });
      rst = rst.concat(elements);
    });
    return rst;
  }
  function getElementValue(element, field) {
    var model2 = element.getModel();
    var record = model2.data;
    var value;
    if (is_array_default(record)) {
      value = record[0][field];
    } else {
      value = record[field];
    }
    return value;
  }
  function intersectRect(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
  }
  function getIntersectElements(view, box2) {
    var elements = getElements(view);
    var rst = [];
    each_default(elements, function(el) {
      var shape = el.shape;
      var shapeBBox = shape.getCanvasBBox();
      if (intersectRect(box2, shapeBBox)) {
        rst.push(el);
      }
    });
    return rst;
  }
  function pathToPoints(path) {
    var points = [];
    each_default(path, function(seg) {
      var command = seg[0];
      if (command !== "A") {
        for (var i = 1; i < seg.length; i = i + 2) {
          points.push([seg[i], seg[i + 1]]);
        }
      } else {
        var length_1 = seg.length;
        points.push([seg[length_1 - 2], seg[length_1 - 1]]);
      }
    });
    return points;
  }
  function getElementsByPath(view, path) {
    var elements = getElements(view);
    var points = pathToPoints(path);
    var rst = elements.filter(function(el) {
      var shape = el.shape;
      var shapePoints;
      if (shape.get("type") === "path") {
        shapePoints = pathToPoints(shape.attr("path"));
      } else {
        var shapeBBox = shape.getCanvasBBox();
        shapePoints = toPoints(shapeBBox);
      }
      return isPolygonsIntersect(points, shapePoints);
    });
    return rst;
  }
  function getComponents(view) {
    return view.getComponents().map(function(co) {
      return co.component;
    });
  }
  function distance6(p1, p22) {
    var dx = p22.x - p1.x;
    var dy = p22.y - p1.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function getSpline(points, z) {
    if (points.length <= 2) {
      return getLinePath2(points, false);
    }
    var first = points[0];
    var arr = [];
    each_default(points, function(point) {
      arr.push(point.x);
      arr.push(point.y);
    });
    var path = catmullRom2bezier(arr, z, null);
    path.unshift(["M", first.x, first.y]);
    return path;
  }
  function isInBox(box2, point) {
    return box2.x <= point.x && box2.maxX >= point.x && box2.y <= point.y && box2.maxY > point.y;
  }
  function getSilbings(view) {
    var parent = view.parent;
    var siblings = null;
    if (parent) {
      siblings = parent.views.filter(function(sub7) {
        return sub7 !== view;
      });
    }
    return siblings;
  }
  function point2Normalize(view, point) {
    var coord = view.getCoordinate();
    return coord.invert(point);
  }
  function getSiblingPoint(view, sibling, point) {
    var normalPoint = point2Normalize(view, point);
    return sibling.getCoordinate().convert(normalPoint);
  }
  function isInRecords(records, record, xFiled, yField) {
    var isIn = false;
    each_default(records, function(r) {
      if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
        isIn = true;
        return false;
      }
    });
    return isIn;
  }
  function getScaleByField(view, field) {
    var scale5 = view.getScaleByField(field);
    if (!scale5 && view.views) {
      each_default(view.views, function(subView) {
        scale5 = getScaleByField(subView, field);
        if (scale5) {
          return false;
        }
      });
    }
    return scale5;
  }

  // node_modules/@antv/g2/esm/interaction/context.js
  var Context = function() {
    function Context2(view) {
      this.actions = [];
      this.event = null;
      this.cacheMap = {};
      this.view = view;
    }
    Context2.prototype.cache = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 1) {
        return this.cacheMap[params[0]];
      } else if (params.length === 2) {
        this.cacheMap[params[0]] = params[1];
      }
    };
    Context2.prototype.getAction = function(name) {
      return this.actions.find(function(action) {
        return action.name === name;
      });
    };
    Context2.prototype.addAction = function(action) {
      this.actions.push(action);
    };
    Context2.prototype.removeAction = function(action) {
      var actions = this.actions;
      var index = this.actions.indexOf(action);
      if (index >= 0) {
        actions.splice(index, 1);
      }
    };
    Context2.prototype.getCurrentPoint = function() {
      var event = this.event;
      if (event) {
        if (event.target instanceof HTMLElement) {
          var canvas = this.view.getCanvas();
          var point = canvas.getPointByClient(event.clientX, event.clientY);
          return point;
        } else {
          return {
            x: event.x,
            y: event.y
          };
        }
      }
      return null;
    };
    Context2.prototype.getCurrentShape = function() {
      return get_default(this.event, ["gEvent", "shape"]);
    };
    Context2.prototype.isInPlot = function() {
      var point = this.getCurrentPoint();
      if (point) {
        return this.view.isPointInPlot(point);
      }
      return false;
    };
    Context2.prototype.isInShape = function(name) {
      var shape = this.getCurrentShape();
      if (shape) {
        return shape.get("name") === name;
      }
      return false;
    };
    Context2.prototype.isInComponent = function(name) {
      var components = getComponents(this.view);
      var point = this.getCurrentPoint();
      if (point) {
        return !!components.find(function(component) {
          var bbox = component.getBBox();
          if (name) {
            return component.get("name") === name && isInBox(bbox, point);
          } else {
            return isInBox(bbox, point);
          }
        });
      }
      return false;
    };
    Context2.prototype.destroy = function() {
      each_default(this.actions.slice(), function(action) {
        action.destroy();
      });
      this.view = null;
      this.event = null;
      this.actions = null;
      this.cacheMap = null;
    };
    return Context2;
  }();
  var context_default = Context;

  // node_modules/@antv/g2/esm/interaction/interaction.js
  var Interaction = function() {
    function Interaction2(view, cfg) {
      this.view = view;
      this.cfg = cfg;
    }
    Interaction2.prototype.init = function() {
      this.initEvents();
    };
    Interaction2.prototype.initEvents = function() {
    };
    Interaction2.prototype.clearEvents = function() {
    };
    Interaction2.prototype.destroy = function() {
      this.clearEvents();
    };
    return Interaction2;
  }();
  var interaction_default = Interaction;

  // node_modules/@antv/g2/esm/interaction/grammar-interaction.js
  function parseAction(actionStr, context, arg) {
    var arr = actionStr.split(":");
    var actionName = arr[0];
    var action = context.getAction(actionName) || createAction(actionName, context);
    if (!action) {
      throw new Error("There is no action named " + actionName);
    }
    var methodName = arr[1];
    return {
      action,
      methodName,
      arg
    };
  }
  function executeAction(actionObject) {
    var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
    if (action[methodName]) {
      action[methodName](arg);
    } else {
      throw new Error("Action(" + action.name + ") doesn't have a method called " + methodName);
    }
  }
  var STEP_NAMES = {
    START: "start",
    SHOW_ENABLE: "showEnable",
    END: "end",
    ROLLBACK: "rollback",
    PROCESSING: "processing"
  };
  var GrammarInteraction = function(_super) {
    __extends(GrammarInteraction2, _super);
    function GrammarInteraction2(view, steps) {
      var _this = _super.call(this, view, steps) || this;
      _this.callbackCaches = {};
      _this.emitCaches = {};
      _this.steps = steps;
      return _this;
    }
    GrammarInteraction2.prototype.init = function() {
      this.initContext();
      _super.prototype.init.call(this);
    };
    GrammarInteraction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.steps = null;
      if (this.context) {
        this.context.destroy();
        this.context = null;
      }
      this.callbackCaches = null;
      this.view = null;
    };
    GrammarInteraction2.prototype.initEvents = function() {
      var _this = this;
      each_default(this.steps, function(stepArr, stepName) {
        each_default(stepArr, function(step4) {
          var callback = _this.getActionCallback(stepName, step4);
          if (callback) {
            _this.bindEvent(step4.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.clearEvents = function() {
      var _this = this;
      each_default(this.steps, function(stepArr, stepName) {
        each_default(stepArr, function(step4) {
          var callback = _this.getActionCallback(stepName, step4);
          if (callback) {
            _this.offEvent(step4.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.initContext = function() {
      var view = this.view;
      var context = new context_default(view);
      this.context = context;
      var steps = this.steps;
      each_default(steps, function(subSteps) {
        each_default(subSteps, function(step4) {
          if (is_function_default(step4.action)) {
            step4.actionObject = {
              action: createCallbackAction(step4.action, context),
              methodName: "execute"
            };
          } else if (is_string_default(step4.action)) {
            step4.actionObject = parseAction(step4.action, context, step4.arg);
          } else if (is_array_default(step4.action)) {
            var actionArr = step4.action;
            var argArr_1 = is_array_default(step4.arg) ? step4.arg : [step4.arg];
            step4.actionObject = [];
            each_default(actionArr, function(actionStr, idx) {
              step4.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
            });
          }
        });
      });
    };
    GrammarInteraction2.prototype.isAllowStep = function(stepName) {
      var currentStepName = this.currentStepName;
      var steps = this.steps;
      if (currentStepName === stepName) {
        return true;
      }
      if (stepName === STEP_NAMES.SHOW_ENABLE) {
        return true;
      }
      if (stepName === STEP_NAMES.PROCESSING) {
        return currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.START) {
        return currentStepName !== STEP_NAMES.PROCESSING;
      }
      if (stepName === STEP_NAMES.END) {
        return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.ROLLBACK) {
        if (steps[STEP_NAMES.END]) {
          return currentStepName === STEP_NAMES.END;
        } else if (currentStepName === STEP_NAMES.START) {
          return true;
        }
      }
      return false;
    };
    GrammarInteraction2.prototype.isAllowExecute = function(stepName, step4) {
      if (this.isAllowStep(stepName)) {
        var key = this.getKey(stepName, step4);
        if (step4.once && this.emitCaches[key]) {
          return false;
        }
        if (step4.isEnable) {
          return step4.isEnable(this.context);
        }
        return true;
      }
      return false;
    };
    GrammarInteraction2.prototype.enterStep = function(stepName) {
      this.currentStepName = stepName;
      this.emitCaches = {};
    };
    GrammarInteraction2.prototype.afterExecute = function(stepName, step4) {
      if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
        this.enterStep(stepName);
      }
      var key = this.getKey(stepName, step4);
      this.emitCaches[key] = true;
    };
    GrammarInteraction2.prototype.getKey = function(stepName, step4) {
      return stepName + step4.trigger + step4.action;
    };
    GrammarInteraction2.prototype.getActionCallback = function(stepName, step4) {
      var _this = this;
      var context = this.context;
      var callbackCaches = this.callbackCaches;
      var actionObject = step4.actionObject;
      if (step4.action && actionObject) {
        var key = this.getKey(stepName, step4);
        if (!callbackCaches[key]) {
          var actionCallback = function(event) {
            context.event = event;
            if (_this.isAllowExecute(stepName, step4)) {
              if (is_array_default(actionObject)) {
                each_default(actionObject, function(obj) {
                  context.event = event;
                  executeAction(obj);
                });
              } else {
                context.event = event;
                executeAction(actionObject);
              }
              _this.afterExecute(stepName, step4);
              if (step4.callback) {
                context.event = event;
                step4.callback(context);
              }
            } else {
              context.event = null;
            }
          };
          if (step4.debounce) {
            callbackCaches[key] = debounce_default(actionCallback, step4.debounce.wait, step4.debounce.immediate);
          } else if (step4.throttle) {
            callbackCaches[key] = throttle_default(actionCallback, step4.throttle.wait, {
              leading: step4.throttle.leading,
              trailing: step4.throttle.trailing
            });
          } else {
            callbackCaches[key] = actionCallback;
          }
        }
        return callbackCaches[key];
      }
      return null;
    };
    GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.addEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.addEventListener(nameArr[1], callback);
      } else {
        this.view.on(eventName, callback);
      }
    };
    GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.removeEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.removeEventListener(nameArr[1], callback);
      } else {
        this.view.off(eventName, callback);
      }
    };
    return GrammarInteraction2;
  }(interaction_default);
  var grammar_interaction_default = GrammarInteraction;

  // node_modules/@antv/g2/esm/interaction/index.js
  var Interactions = {};
  function getInteraction(name) {
    return Interactions[lower_case_default(name)];
  }
  function registerInteraction(name, interaction) {
    Interactions[lower_case_default(name)] = interaction;
  }
  function createInteraction(name, view, cfg) {
    var interaciton = getInteraction(name);
    if (!interaciton) {
      return null;
    }
    if (is_plain_object_default(interaciton)) {
      var steps = mix(clone_default(interaciton), cfg);
      return new grammar_interaction_default(view, steps);
    } else {
      var cls = interaciton;
      return new cls(view, cfg);
    }
  }

  // node_modules/@antv/g2/esm/theme/util/create-by-style-sheet.js
  function createAxisStyles(styleSheet) {
    return {
      title: {
        autoRotate: true,
        position: "center",
        spacing: styleSheet.axisTitleSpacing,
        style: {
          fill: styleSheet.axisTitleTextFillColor,
          fontSize: styleSheet.axisTitleTextFontSize,
          lineHeight: styleSheet.axisTitleTextLineHeight,
          textBaseline: "middle",
          fontFamily: styleSheet.fontFamily
        }
      },
      label: {
        autoRotate: false,
        autoEllipsis: false,
        autoHide: { type: "equidistance", cfg: { minGap: 6 } },
        offset: styleSheet.axisLabelOffset,
        style: {
          fill: styleSheet.axisLabelFillColor,
          fontSize: styleSheet.axisLabelFontSize,
          lineHeight: styleSheet.axisLabelLineHeight,
          fontFamily: styleSheet.fontFamily
        }
      },
      line: {
        style: {
          lineWidth: styleSheet.axisLineBorder,
          stroke: styleSheet.axisLineBorderColor
        }
      },
      grid: {
        line: {
          type: "line",
          style: {
            stroke: styleSheet.axisGridBorderColor,
            lineWidth: styleSheet.axisGridBorder,
            lineDash: styleSheet.axisGridLineDash
          }
        },
        alignTick: true,
        animate: true
      },
      tickLine: {
        style: {
          lineWidth: styleSheet.axisTickLineBorder,
          stroke: styleSheet.axisTickLineBorderColor
        },
        alignTick: true,
        length: styleSheet.axisTickLineLength
      },
      subTickLine: null,
      animate: true
    };
  }
  function createLegendStyles(styleSheet) {
    return {
      title: null,
      marker: {
        symbol: "circle",
        spacing: styleSheet.legendMarkerSpacing,
        style: {
          r: styleSheet.legendCircleMarkerSize,
          fill: styleSheet.legendMarkerColor
        }
      },
      itemName: {
        spacing: 5,
        style: {
          fill: styleSheet.legendItemNameFillColor,
          fontFamily: styleSheet.fontFamily,
          fontSize: styleSheet.legendItemNameFontSize,
          lineHeight: styleSheet.legendItemNameLineHeight,
          fontWeight: styleSheet.legendItemNameFontWeight,
          textAlign: "start",
          textBaseline: "middle"
        }
      },
      itemStates: {
        active: {
          nameStyle: {
            opacity: 0.8
          }
        },
        unchecked: {
          nameStyle: {
            fill: "#D8D8D8"
          },
          markerStyle: {
            fill: "#D8D8D8",
            stroke: "#D8D8D8"
          }
        },
        inactive: {
          nameStyle: {
            fill: "#D8D8D8"
          },
          markerStyle: {
            opacity: 0.2
          }
        }
      },
      flipPage: true,
      pageNavigator: {
        marker: {
          style: {
            size: styleSheet.legendPageNavigatorMarkerSize,
            inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
            inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
            fill: styleSheet.legendPageNavigatorMarkerFillColor,
            opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
          }
        },
        text: {
          style: {
            fill: styleSheet.legendPageNavigatorTextFillColor,
            fontSize: styleSheet.legendPageNavigatorTextFontSize
          }
        }
      },
      animate: false,
      maxItemWidth: 200,
      itemSpacing: styleSheet.legendItemSpacing,
      itemMarginBottom: styleSheet.legendItemMarginBottom,
      padding: styleSheet.legendPadding
    };
  }
  function createThemeByStyleSheet(styleSheet) {
    var _a4;
    var shapeStyles = {
      point: {
        default: {
          fill: styleSheet.pointFillColor,
          r: styleSheet.pointSize,
          stroke: styleSheet.pointBorderColor,
          lineWidth: styleSheet.pointBorder,
          fillOpacity: styleSheet.pointFillOpacity
        },
        active: {
          stroke: styleSheet.pointActiveBorderColor,
          lineWidth: styleSheet.pointActiveBorder
        },
        selected: {
          stroke: styleSheet.pointSelectedBorderColor,
          lineWidth: styleSheet.pointSelectedBorder
        },
        inactive: {
          fillOpacity: styleSheet.pointInactiveFillOpacity,
          strokeOpacity: styleSheet.pointInactiveBorderOpacity
        }
      },
      hollowPoint: {
        default: {
          fill: styleSheet.hollowPointFillColor,
          lineWidth: styleSheet.hollowPointBorder,
          stroke: styleSheet.hollowPointBorderColor,
          strokeOpacity: styleSheet.hollowPointBorderOpacity,
          r: styleSheet.hollowPointSize
        },
        active: {
          stroke: styleSheet.hollowPointActiveBorderColor,
          strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
        },
        selected: {
          lineWidth: styleSheet.hollowPointSelectedBorder,
          stroke: styleSheet.hollowPointSelectedBorderColor,
          strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
        },
        inactive: {
          strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
        }
      },
      area: {
        default: {
          fill: styleSheet.areaFillColor,
          fillOpacity: styleSheet.areaFillOpacity,
          stroke: null
        },
        active: {
          fillOpacity: styleSheet.areaActiveFillOpacity
        },
        selected: {
          fillOpacity: styleSheet.areaSelectedFillOpacity
        },
        inactive: {
          fillOpacity: styleSheet.areaInactiveFillOpacity
        }
      },
      hollowArea: {
        default: {
          fill: null,
          stroke: styleSheet.hollowAreaBorderColor,
          lineWidth: styleSheet.hollowAreaBorder,
          strokeOpacity: styleSheet.hollowAreaBorderOpacity
        },
        active: {
          fill: null,
          lineWidth: styleSheet.hollowAreaActiveBorder
        },
        selected: {
          fill: null,
          lineWidth: styleSheet.hollowAreaSelectedBorder
        },
        inactive: {
          strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
        }
      },
      interval: {
        default: {
          fill: styleSheet.intervalFillColor,
          fillOpacity: styleSheet.intervalFillOpacity
        },
        active: {
          stroke: styleSheet.intervalActiveBorderColor,
          lineWidth: styleSheet.intervalActiveBorder
        },
        selected: {
          stroke: styleSheet.intervalSelectedBorderColor,
          lineWidth: styleSheet.intervalSelectedBorder
        },
        inactive: {
          fillOpacity: styleSheet.intervalInactiveFillOpacity,
          strokeOpacity: styleSheet.intervalInactiveBorderOpacity
        }
      },
      hollowInterval: {
        default: {
          fill: styleSheet.hollowIntervalFillColor,
          stroke: styleSheet.hollowIntervalBorderColor,
          lineWidth: styleSheet.hollowIntervalBorder,
          strokeOpacity: styleSheet.hollowIntervalBorderOpacity
        },
        active: {
          stroke: styleSheet.hollowIntervalActiveBorderColor,
          lineWidth: styleSheet.hollowIntervalActiveBorder,
          strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
        },
        selected: {
          stroke: styleSheet.hollowIntervalSelectedBorderColor,
          lineWidth: styleSheet.hollowIntervalSelectedBorder,
          strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
        },
        inactive: {
          stroke: styleSheet.hollowIntervalInactiveBorderColor,
          lineWidth: styleSheet.hollowIntervalInactiveBorder,
          strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
        }
      },
      line: {
        default: {
          stroke: styleSheet.lineBorderColor,
          lineWidth: styleSheet.lineBorder,
          strokeOpacity: styleSheet.lineBorderOpacity,
          fill: null,
          lineAppendWidth: 10,
          lineCap: "round",
          lineJoin: "round"
        },
        active: {
          lineWidth: styleSheet.lineActiveBorder
        },
        selected: {
          lineWidth: styleSheet.lineSelectedBorder
        },
        inactive: {
          strokeOpacity: styleSheet.lineInactiveBorderOpacity
        }
      }
    };
    var axisStyles = createAxisStyles(styleSheet);
    var legendStyles = createLegendStyles(styleSheet);
    return {
      background: styleSheet.backgroundColor,
      defaultColor: styleSheet.brandColor,
      subColor: styleSheet.subColor,
      semanticRed: styleSheet.paletteSemanticRed,
      semanticGreen: styleSheet.paletteSemanticGreen,
      padding: "auto",
      fontFamily: styleSheet.fontFamily,
      columnWidthRatio: 1 / 2,
      maxColumnWidth: null,
      minColumnWidth: null,
      roseWidthRatio: 0.9999999,
      multiplePieWidthRatio: 1 / 1.3,
      colors10: styleSheet.paletteQualitative10,
      colors20: styleSheet.paletteQualitative20,
      sequenceColors: styleSheet.paletteSequence,
      shapes: {
        point: [
          "hollow-circle",
          "hollow-square",
          "hollow-bowtie",
          "hollow-diamond",
          "hollow-hexagon",
          "hollow-triangle",
          "hollow-triangle-down",
          "circle",
          "square",
          "bowtie",
          "diamond",
          "hexagon",
          "triangle",
          "triangle-down",
          "cross",
          "tick",
          "plus",
          "hyphen",
          "line"
        ],
        line: ["line", "dash", "dot", "smooth"],
        area: ["area", "smooth", "line", "smooth-line"],
        interval: ["rect", "hollow-rect", "line", "tick"]
      },
      sizes: [1, 10],
      geometries: {
        interval: {
          rect: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: function(element) {
                var coordinate = element.geometry.coordinate;
                if (coordinate.isPolar && coordinate.isTransposed) {
                  var _a5 = getAngle2(element.getModel(), coordinate), startAngle = _a5.startAngle, endAngle = _a5.endAngle;
                  var middleAngle = (startAngle + endAngle) / 2;
                  var r = 7.5;
                  var x = r * Math.cos(middleAngle);
                  var y = r * Math.sin(middleAngle);
                  return {
                    matrix: ext_exports.transform(null, [["t", x, y]])
                  };
                }
                return shapeStyles.interval.selected;
              }
            }
          },
          "hollow-rect": {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          line: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          tick: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          funnel: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: shapeStyles.interval.selected
            }
          },
          pyramid: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: shapeStyles.interval.selected
            }
          }
        },
        line: {
          line: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          dot: {
            default: {
              style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
            },
            active: {
              style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
            },
            inactive: {
              style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
            },
            selected: {
              style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
            }
          },
          dash: {
            default: {
              style: __assign(__assign({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
            },
            active: {
              style: __assign(__assign({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
            },
            inactive: {
              style: __assign(__assign({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
            },
            selected: {
              style: __assign(__assign({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
            }
          },
          smooth: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          hv: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          vh: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          hvh: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          vhv: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          }
        },
        polygon: {
          polygon: {
            default: {
              style: shapeStyles.interval.default
            },
            active: {
              style: shapeStyles.interval.active
            },
            inactive: {
              style: shapeStyles.interval.inactive
            },
            selected: {
              style: shapeStyles.interval.selected
            }
          }
        },
        point: {
          circle: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          square: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          bowtie: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          diamond: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          hexagon: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          triangle: {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          "triangle-down": {
            default: {
              style: shapeStyles.point.default
            },
            active: {
              style: shapeStyles.point.active
            },
            inactive: {
              style: shapeStyles.point.inactive
            },
            selected: {
              style: shapeStyles.point.selected
            }
          },
          "hollow-circle": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-square": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-bowtie": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-diamond": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-hexagon": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-triangle": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          "hollow-triangle-down": {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          cross: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          tick: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          plus: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          hyphen: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          },
          line: {
            default: {
              style: shapeStyles.hollowPoint.default
            },
            active: {
              style: shapeStyles.hollowPoint.active
            },
            inactive: {
              style: shapeStyles.hollowPoint.inactive
            },
            selected: {
              style: shapeStyles.hollowPoint.selected
            }
          }
        },
        area: {
          area: {
            default: {
              style: shapeStyles.area.default
            },
            active: {
              style: shapeStyles.area.active
            },
            inactive: {
              style: shapeStyles.area.inactive
            },
            selected: {
              style: shapeStyles.area.selected
            }
          },
          smooth: {
            default: {
              style: shapeStyles.area.default
            },
            active: {
              style: shapeStyles.area.active
            },
            inactive: {
              style: shapeStyles.area.inactive
            },
            selected: {
              style: shapeStyles.area.selected
            }
          },
          line: {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          },
          "smooth-line": {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          }
        },
        schema: {
          candle: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          },
          box: {
            default: {
              style: shapeStyles.hollowInterval.default
            },
            active: {
              style: shapeStyles.hollowInterval.active
            },
            inactive: {
              style: shapeStyles.hollowInterval.inactive
            },
            selected: {
              style: shapeStyles.hollowInterval.selected
            }
          }
        },
        edge: {
          line: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          vhv: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          smooth: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          arc: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          }
        },
        violin: {
          violin: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          smooth: {
            default: {
              style: shapeStyles.line.default
            },
            active: {
              style: shapeStyles.line.active
            },
            inactive: {
              style: shapeStyles.line.inactive
            },
            selected: {
              style: shapeStyles.line.selected
            }
          },
          hollow: {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          },
          "hollow-smooth": {
            default: {
              style: shapeStyles.hollowArea.default
            },
            active: {
              style: shapeStyles.hollowArea.active
            },
            inactive: {
              style: shapeStyles.hollowArea.inactive
            },
            selected: {
              style: shapeStyles.hollowArea.selected
            }
          }
        }
      },
      components: {
        axis: {
          common: axisStyles,
          top: {
            position: "top",
            grid: null,
            title: null,
            verticalLimitLength: 1 / 2
          },
          bottom: {
            position: "bottom",
            grid: null,
            title: null,
            verticalLimitLength: 1 / 2
          },
          left: {
            position: "left",
            title: null,
            line: null,
            tickLine: null,
            verticalLimitLength: 1 / 3
          },
          right: {
            position: "right",
            title: null,
            line: null,
            tickLine: null,
            verticalLimitLength: 1 / 3
          },
          circle: {
            title: null,
            grid: deep_mix_default({}, axisStyles.grid, { line: { type: "line" } })
          },
          radius: {
            title: null,
            grid: deep_mix_default({}, axisStyles.grid, { line: { type: "circle" } })
          }
        },
        legend: {
          common: legendStyles,
          right: {
            layout: "vertical",
            padding: styleSheet.legendVerticalPadding
          },
          left: {
            layout: "vertical",
            padding: styleSheet.legendVerticalPadding
          },
          top: {
            layout: "horizontal",
            padding: styleSheet.legendHorizontalPadding
          },
          bottom: {
            layout: "horizontal",
            padding: styleSheet.legendHorizontalPadding
          },
          continuous: {
            title: null,
            background: null,
            track: {},
            rail: {
              type: "color",
              size: styleSheet.sliderRailHeight,
              defaultLength: styleSheet.sliderRailWidth,
              style: {
                fill: styleSheet.sliderRailFillColor,
                stroke: styleSheet.sliderRailBorderColor,
                lineWidth: styleSheet.sliderRailBorder
              }
            },
            label: {
              align: "rail",
              spacing: 4,
              formatter: null,
              style: {
                fill: styleSheet.sliderLabelTextFillColor,
                fontSize: styleSheet.sliderLabelTextFontSize,
                lineHeight: styleSheet.sliderLabelTextLineHeight,
                textBaseline: "middle",
                fontFamily: styleSheet.fontFamily
              }
            },
            handler: {
              size: styleSheet.sliderHandlerWidth,
              style: {
                fill: styleSheet.sliderHandlerFillColor,
                stroke: styleSheet.sliderHandlerBorderColor
              }
            },
            slidable: true,
            padding: legendStyles.padding
          }
        },
        tooltip: {
          showContent: true,
          follow: true,
          showCrosshairs: false,
          showMarkers: true,
          shared: false,
          enterable: false,
          position: "auto",
          marker: {
            symbol: "circle",
            stroke: "#fff",
            shadowBlur: 10,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowColor: "rgba(0,0,0,0.09)",
            lineWidth: 2,
            r: 4
          },
          crosshairs: {
            line: {
              style: {
                stroke: styleSheet.tooltipCrosshairsBorderColor,
                lineWidth: styleSheet.tooltipCrosshairsBorder
              }
            },
            text: null,
            textBackground: {
              padding: 2,
              style: {
                fill: "rgba(0, 0, 0, 0.25)",
                lineWidth: 0,
                stroke: null
              }
            },
            follow: false
          },
          domStyles: (_a4 = {}, _a4["" + css_const_exports.CONTAINER_CLASS] = {
            position: "absolute",
            visibility: "hidden",
            zIndex: 8,
            transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
            backgroundColor: styleSheet.tooltipContainerFillColor,
            opacity: styleSheet.tooltipContainerFillOpacity,
            boxShadow: styleSheet.tooltipContainerShadow,
            borderRadius: styleSheet.tooltipContainerBorderRadius + "px",
            color: styleSheet.tooltipTextFillColor,
            fontSize: styleSheet.tooltipTextFontSize + "px",
            fontFamily: styleSheet.fontFamily,
            lineHeight: styleSheet.tooltipTextLineHeight + "px",
            padding: "0 12px 0 12px"
          }, _a4["" + css_const_exports.TITLE_CLASS] = {
            marginBottom: "12px",
            marginTop: "12px"
          }, _a4["" + css_const_exports.LIST_CLASS] = {
            margin: 0,
            listStyleType: "none",
            padding: 0
          }, _a4["" + css_const_exports.LIST_ITEM_CLASS] = {
            listStyleType: "none",
            padding: 0,
            marginBottom: "12px",
            marginTop: "12px",
            marginLeft: 0,
            marginRight: 0
          }, _a4["" + css_const_exports.MARKER_CLASS] = {
            width: "8px",
            height: "8px",
            borderRadius: "50%",
            display: "inline-block",
            marginRight: "8px"
          }, _a4["" + css_const_exports.VALUE_CLASS] = {
            display: "inline-block",
            float: "right",
            marginLeft: "30px"
          }, _a4)
        },
        annotation: {
          arc: {
            style: {
              stroke: styleSheet.annotationArcBorderColor,
              lineWidth: styleSheet.annotationArcBorder
            },
            animate: true
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineDash: styleSheet.annotationLineDash,
              lineWidth: styleSheet.annotationLineBorder
            },
            text: {
              position: "start",
              autoRotate: true,
              style: {
                fill: styleSheet.annotationTextFillColor,
                stroke: styleSheet.annotationTextBorderColor,
                lineWidth: styleSheet.annotationTextBorder,
                fontSize: styleSheet.annotationTextFontSize,
                textAlign: "start",
                fontFamily: styleSheet.fontFamily,
                textBaseline: "bottom"
              }
            },
            animate: true
          },
          text: {
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textBaseline: "middle",
              textAlign: "start",
              fontFamily: styleSheet.fontFamily
            },
            animate: true
          },
          region: {
            top: false,
            style: {
              lineWidth: styleSheet.annotationRegionBorder,
              stroke: styleSheet.annotationRegionBorderColor,
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            animate: true
          },
          image: {
            top: false,
            animate: true
          },
          dataMarker: {
            top: true,
            point: {
              style: {
                r: 3,
                stroke: styleSheet.brandColor,
                lineWidth: 2
              }
            },
            line: {
              style: {
                stroke: styleSheet.annotationLineBorderColor,
                lineWidth: styleSheet.annotationLineBorder
              },
              length: styleSheet.annotationDataMarkerLineLength
            },
            text: {
              style: {
                textAlign: "start",
                fill: styleSheet.annotationTextFillColor,
                stroke: styleSheet.annotationTextBorderColor,
                lineWidth: styleSheet.annotationTextBorder,
                fontSize: styleSheet.annotationTextFontSize,
                fontFamily: styleSheet.fontFamily
              }
            },
            direction: "upward",
            autoAdjust: true,
            animate: true
          },
          dataRegion: {
            style: {
              region: {
                fill: styleSheet.annotationRegionFillColor,
                fillOpacity: styleSheet.annotationRegionFillOpacity
              },
              text: {
                textAlign: "center",
                textBaseline: "bottom",
                fill: styleSheet.annotationTextFillColor,
                stroke: styleSheet.annotationTextBorderColor,
                lineWidth: styleSheet.annotationTextBorder,
                fontSize: styleSheet.annotationTextFontSize,
                fontFamily: styleSheet.fontFamily
              }
            },
            animate: true
          }
        },
        slider: {
          common: {
            padding: [8, 8, 8, 8],
            backgroundStyle: {
              fill: styleSheet.cSliderBackgroundFillColor,
              opacity: styleSheet.cSliderBackgroundFillOpacity
            },
            foregroundStyle: {
              fill: styleSheet.cSliderForegroundFillColor,
              opacity: styleSheet.cSliderForegroundFillOpacity
            },
            handlerStyle: {
              width: styleSheet.cSliderHandlerWidth,
              height: styleSheet.cSliderHandlerHeight,
              fill: styleSheet.cSliderHandlerFillColor,
              opacity: styleSheet.cSliderHandlerFillOpacity,
              stroke: styleSheet.cSliderHandlerBorderColor,
              lineWidth: styleSheet.cSliderHandlerBorder,
              radius: styleSheet.cSliderHandlerBorderRadius,
              highLightFill: styleSheet.cSliderHandlerHighlightFillColor
            },
            textStyle: {
              fill: styleSheet.cSliderTextFillColor,
              opacity: styleSheet.cSliderTextFillOpacity,
              fontSize: styleSheet.cSliderTextFontSize,
              lineHeight: styleSheet.cSliderTextLineHeight,
              fontWeight: styleSheet.cSliderTextFontWeight,
              stroke: styleSheet.cSliderTextBorderColor,
              lineWidth: styleSheet.cSliderTextBorder
            }
          }
        },
        scrollbar: {
          common: {
            padding: [8, 8, 8, 8]
          },
          default: {
            style: {
              trackColor: styleSheet.scrollbarTrackFillColor,
              thumbColor: styleSheet.scrollbarThumbFillColor
            }
          },
          hover: {
            style: {
              thumbColor: styleSheet.scrollbarThumbHighlightFillColor
            }
          }
        }
      },
      labels: {
        offset: 12,
        style: {
          fill: styleSheet.labelFillColor,
          fontSize: styleSheet.labelFontSize,
          fontFamily: styleSheet.fontFamily,
          stroke: styleSheet.labelBorderColor,
          lineWidth: styleSheet.labelBorder
        },
        fillColorDark: styleSheet.labelFillColorDark,
        fillColorLight: styleSheet.labelFillColorLight,
        autoRotate: true
      },
      innerLabels: {
        style: {
          fill: styleSheet.innerLabelFillColor,
          fontSize: styleSheet.innerLabelFontSize,
          fontFamily: styleSheet.fontFamily,
          stroke: styleSheet.innerLabelBorderColor,
          lineWidth: styleSheet.innerLabelBorder
        },
        autoRotate: true
      },
      overflowLabels: {
        style: {
          fill: styleSheet.overflowLabelFillColor,
          fontSize: styleSheet.overflowLabelFontSize,
          fontFamily: styleSheet.fontFamily,
          stroke: styleSheet.overflowLabelBorderColor,
          lineWidth: styleSheet.overflowLabelBorder
        }
      },
      pieLabels: {
        labelHeight: 14,
        offset: 10,
        labelLine: {
          style: {
            lineWidth: styleSheet.labelLineBorder
          }
        },
        autoRotate: true
      }
    };
  }

  // node_modules/@antv/g2/esm/theme/style-sheet/light.js
  var BLACK_COLORS = {
    100: "#000",
    95: "#0D0D0D",
    85: "#262626",
    65: "#595959",
    45: "#8C8C8C",
    25: "#BFBFBF",
    15: "#D9D9D9",
    6: "#F0F0F0"
  };
  var WHITE_COLORS = {
    100: "#FFFFFF",
    95: "#F2F2F2",
    85: "#D9D9D9",
    65: "#A6A6A6",
    45: "#737373",
    25: "#404040",
    15: "#262626",
    6: "#0F0F0F"
  };
  var QUALITATIVE_10 = [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#6F5EF9",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
  var QUALITATIVE_20 = [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#6F5EF9",
    "#D3CEFD",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
  var SINGLE_SEQUENCE = [
    "#B8E1FF",
    "#9AC5FF",
    "#7DAAFF",
    "#5B8FF9",
    "#3D76DD",
    "#085EC0",
    "#0047A5",
    "#00318A",
    "#001D70"
  ];
  var createLightStyleSheet = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var _a4 = cfg.backgroundColor, backgroundColor = _a4 === void 0 ? "transparent" : _a4, _b = cfg.subColor, subColor = _b === void 0 ? "rgba(0,0,0,0.05)" : _b, _c = cfg.paletteQualitative10, paletteQualitative10 = _c === void 0 ? QUALITATIVE_10 : _c, _d = cfg.paletteQualitative20, paletteQualitative20 = _d === void 0 ? QUALITATIVE_20 : _d, _e = cfg.paletteSemanticRed, paletteSemanticRed = _e === void 0 ? "#F4664A" : _e, _f = cfg.paletteSemanticGreen, paletteSemanticGreen = _f === void 0 ? "#30BF78" : _f, _g = cfg.paletteSemanticYellow, paletteSemanticYellow = _g === void 0 ? "#FAAD14" : _g, _h = cfg.paletteSequence, paletteSequence = _h === void 0 ? SINGLE_SEQUENCE : _h, _j = cfg.fontFamily, fontFamily = _j === void 0 ? '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : _j;
    var _k = cfg.brandColor, brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
    return {
      backgroundColor,
      brandColor,
      subColor,
      paletteQualitative10,
      paletteQualitative20,
      paletteSemanticRed,
      paletteSemanticGreen,
      paletteSemanticYellow,
      paletteSequence,
      fontFamily,
      axisLineBorderColor: BLACK_COLORS[25],
      axisLineBorder: 1,
      axisLineDash: null,
      axisTitleTextFillColor: BLACK_COLORS[65],
      axisTitleTextFontSize: 12,
      axisTitleTextLineHeight: 12,
      axisTitleTextFontWeight: "normal",
      axisTitleSpacing: 12,
      axisTickLineBorderColor: BLACK_COLORS[25],
      axisTickLineLength: 4,
      axisTickLineBorder: 1,
      axisSubTickLineBorderColor: BLACK_COLORS[15],
      axisSubTickLineLength: 2,
      axisSubTickLineBorder: 1,
      axisLabelFillColor: BLACK_COLORS[45],
      axisLabelFontSize: 12,
      axisLabelLineHeight: 12,
      axisLabelFontWeight: "normal",
      axisLabelOffset: 8,
      axisGridBorderColor: BLACK_COLORS[15],
      axisGridBorder: 1,
      axisGridLineDash: null,
      legendTitleTextFillColor: BLACK_COLORS[45],
      legendTitleTextFontSize: 12,
      legendTitleTextLineHeight: 21,
      legendTitleTextFontWeight: "normal",
      legendMarkerColor: brandColor,
      legendMarkerSpacing: 8,
      legendMarkerSize: 4,
      legendCircleMarkerSize: 4,
      legendSquareMarkerSize: 4,
      legendLineMarkerSize: 5,
      legendItemNameFillColor: BLACK_COLORS[65],
      legendItemNameFontSize: 12,
      legendItemNameLineHeight: 12,
      legendItemNameFontWeight: "normal",
      legendItemSpacing: 24,
      legendItemMarginBottom: 12,
      legendPadding: [8, 8, 8, 8],
      legendHorizontalPadding: [8, 0, 8, 0],
      legendVerticalPadding: [0, 8, 0, 8],
      legendPageNavigatorMarkerSize: 12,
      legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[100],
      legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
      legendPageNavigatorMarkerFillColor: BLACK_COLORS[100],
      legendPageNavigatorMarkerFillOpacity: 1,
      legendPageNavigatorTextFillColor: BLACK_COLORS[45],
      legendPageNavigatorTextFontSize: 12,
      sliderRailFillColor: BLACK_COLORS[15],
      sliderRailBorder: 0,
      sliderRailBorderColor: null,
      sliderRailWidth: 100,
      sliderRailHeight: 12,
      sliderLabelTextFillColor: BLACK_COLORS[45],
      sliderLabelTextFontSize: 12,
      sliderLabelTextLineHeight: 12,
      sliderLabelTextFontWeight: "normal",
      sliderHandlerFillColor: BLACK_COLORS[6],
      sliderHandlerWidth: 10,
      sliderHandlerHeight: 14,
      sliderHandlerBorder: 1,
      sliderHandlerBorderColor: BLACK_COLORS[25],
      annotationArcBorderColor: BLACK_COLORS[15],
      annotationArcBorder: 1,
      annotationLineBorderColor: BLACK_COLORS[25],
      annotationLineBorder: 1,
      annotationLineDash: null,
      annotationTextFillColor: BLACK_COLORS[65],
      annotationTextFontSize: 12,
      annotationTextLineHeight: 12,
      annotationTextFontWeight: "normal",
      annotationTextBorderColor: null,
      annotationTextBorder: 0,
      annotationRegionFillColor: BLACK_COLORS[100],
      annotationRegionFillOpacity: 0.06,
      annotationRegionBorder: 0,
      annotationRegionBorderColor: null,
      annotationDataMarkerLineLength: 16,
      tooltipCrosshairsBorderColor: BLACK_COLORS[25],
      tooltipCrosshairsBorder: 1,
      tooltipCrosshairsLineDash: null,
      tooltipContainerFillColor: "rgb(255, 255, 255)",
      tooltipContainerFillOpacity: 0.95,
      tooltipContainerShadow: "0px 0px 10px #aeaeae",
      tooltipContainerBorderRadius: 3,
      tooltipTextFillColor: BLACK_COLORS[65],
      tooltipTextFontSize: 12,
      tooltipTextLineHeight: 12,
      tooltipTextFontWeight: "bold",
      labelFillColor: BLACK_COLORS[65],
      labelFillColorDark: "#2c3542",
      labelFillColorLight: "#ffffff",
      labelFontSize: 12,
      labelLineHeight: 12,
      labelFontWeight: "normal",
      labelBorderColor: null,
      labelBorder: 0,
      innerLabelFillColor: WHITE_COLORS[100],
      innerLabelFontSize: 12,
      innerLabelLineHeight: 12,
      innerLabelFontWeight: "normal",
      innerLabelBorderColor: null,
      innerLabelBorder: 0,
      overflowLabelFillColor: BLACK_COLORS[65],
      overflowLabelFontSize: 12,
      overflowLabelLineHeight: 12,
      overflowLabelFontWeight: "normal",
      overflowLabelBorderColor: WHITE_COLORS[100],
      overflowLabelBorder: 1,
      labelLineBorder: 1,
      labelLineBorderColor: BLACK_COLORS[25],
      cSliderRailHieght: 16,
      cSliderBackgroundFillColor: "#416180",
      cSliderBackgroundFillOpacity: 0.05,
      cSliderForegroundFillColor: "#5B8FF9",
      cSliderForegroundFillOpacity: 0.15,
      cSliderHandlerHeight: 24,
      cSliderHandlerWidth: 10,
      cSliderHandlerFillColor: "#F7F7F7",
      cSliderHandlerFillOpacity: 1,
      cSliderHandlerHighlightFillColor: "#FFF",
      cSliderHandlerBorderColor: "#BFBFBF",
      cSliderHandlerBorder: 1,
      cSliderHandlerBorderRadius: 2,
      cSliderTextFillColor: "#000",
      cSliderTextFillOpacity: 0.45,
      cSliderTextFontSize: 12,
      cSliderTextLineHeight: 12,
      cSliderTextFontWeight: "normal",
      cSliderTextBorderColor: null,
      cSliderTextBorder: 0,
      scrollbarTrackFillColor: "rgba(0,0,0,0)",
      scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
      scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
      pointFillColor: brandColor,
      pointFillOpacity: 0.95,
      pointSize: 4,
      pointBorder: 1,
      pointBorderColor: WHITE_COLORS[100],
      pointBorderOpacity: 1,
      pointActiveBorderColor: BLACK_COLORS[100],
      pointSelectedBorder: 2,
      pointSelectedBorderColor: BLACK_COLORS[100],
      pointInactiveFillOpacity: 0.3,
      pointInactiveBorderOpacity: 0.3,
      hollowPointSize: 4,
      hollowPointBorder: 1,
      hollowPointBorderColor: brandColor,
      hollowPointBorderOpacity: 0.95,
      hollowPointFillColor: WHITE_COLORS[100],
      hollowPointActiveBorder: 1,
      hollowPointActiveBorderColor: BLACK_COLORS[100],
      hollowPointActiveBorderOpacity: 1,
      hollowPointSelectedBorder: 2,
      hollowPointSelectedBorderColor: BLACK_COLORS[100],
      hollowPointSelectedBorderOpacity: 1,
      hollowPointInactiveBorderOpacity: 0.3,
      lineBorder: 2,
      lineBorderColor: brandColor,
      lineBorderOpacity: 1,
      lineActiveBorder: 3,
      lineSelectedBorder: 3,
      lineInactiveBorderOpacity: 0.3,
      areaFillColor: brandColor,
      areaFillOpacity: 0.25,
      areaActiveFillColor: brandColor,
      areaActiveFillOpacity: 0.5,
      areaSelectedFillColor: brandColor,
      areaSelectedFillOpacity: 0.5,
      areaInactiveFillOpacity: 0.3,
      hollowAreaBorderColor: brandColor,
      hollowAreaBorder: 2,
      hollowAreaBorderOpacity: 1,
      hollowAreaActiveBorder: 3,
      hollowAreaActiveBorderColor: BLACK_COLORS[100],
      hollowAreaSelectedBorder: 3,
      hollowAreaSelectedBorderColor: BLACK_COLORS[100],
      hollowAreaInactiveBorderOpacity: 0.3,
      intervalFillColor: brandColor,
      intervalFillOpacity: 0.95,
      intervalActiveBorder: 1,
      intervalActiveBorderColor: BLACK_COLORS[100],
      intervalActiveBorderOpacity: 1,
      intervalSelectedBorder: 2,
      intervalSelectedBorderColor: BLACK_COLORS[100],
      intervalSelectedBorderOpacity: 1,
      intervalInactiveBorderOpacity: 0.3,
      intervalInactiveFillOpacity: 0.3,
      hollowIntervalBorder: 2,
      hollowIntervalBorderColor: brandColor,
      hollowIntervalBorderOpacity: 1,
      hollowIntervalFillColor: WHITE_COLORS[100],
      hollowIntervalActiveBorder: 2,
      hollowIntervalActiveBorderColor: BLACK_COLORS[100],
      hollowIntervalSelectedBorder: 3,
      hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
      hollowIntervalSelectedBorderOpacity: 1,
      hollowIntervalInactiveBorderOpacity: 0.3
    };
  };
  var antvLight = createLightStyleSheet();

  // node_modules/@antv/g2/esm/theme/util/create-theme.js
  function createTheme(themeCfg) {
    var _a4 = themeCfg.styleSheet, styleSheetCfg = _a4 === void 0 ? {} : _a4, themeObject = __rest(themeCfg, ["styleSheet"]);
    var styleSheet = createLightStyleSheet(styleSheetCfg);
    return deep_mix_default({}, createThemeByStyleSheet(styleSheet), themeObject);
  }

  // node_modules/@antv/g2/esm/theme/index.js
  var defaultTheme = createTheme({});
  var Themes = {
    default: defaultTheme
  };
  function getTheme(theme) {
    return get_default(Themes, lower_case_default(theme), Themes.default);
  }
  function registerTheme(theme, value) {
    Themes[lower_case_default(theme)] = createTheme(value);
  }

  // node_modules/@antv/g2/esm/util/tooltip.js
  function snapEqual(v1, v2, scale5) {
    var value1 = scale5.translate(v1);
    var value2 = scale5.translate(v2);
    return isNumberEqual(value1, value2);
  }
  function getXValueByPoint(point, geometry) {
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var range5 = xScale.range;
    var rangeMax = range5[range5.length - 1];
    var rangeMin = range5[0];
    var invertPoint = coordinate.invert(point);
    var xValue = invertPoint.x;
    if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {
      xValue = rangeMin;
    }
    return xScale.translate(xScale.invert(xValue));
  }
  function filterYValue(data, point, geometry) {
    var coordinate = geometry.coordinate;
    var yScale = geometry.getYScale();
    var yField = yScale.field;
    var invertPoint = coordinate.invert(point);
    var yValue = yScale.invert(invertPoint.y);
    var result = find_default(data, function(obj) {
      var originData = obj[FIELD_ORIGIN];
      return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
    });
    return result || data[data.length - 1];
  }
  var getXDistance = memoize_default(function(scale5) {
    if (scale5.isCategory) {
      return 1;
    }
    var scaleValues = scale5.values;
    var length3 = scaleValues.length;
    var min7 = scale5.translate(scaleValues[0]);
    var max7 = min7;
    for (var index = 0; index < length3; index++) {
      var value = scaleValues[index];
      var numericValue = scale5.translate(value);
      if (numericValue < min7) {
        min7 = numericValue;
      }
      if (numericValue > max7) {
        max7 = numericValue;
      }
    }
    return (max7 - min7) / (length3 - 1);
  });
  function getTooltipTitle(originData, geometry, title) {
    var positionAttr = geometry.getAttribute("position");
    var fields = positionAttr.getFields();
    var scales = geometry.scales;
    var titleField = is_function_default(title) || !title ? fields[0] : title;
    var titleScale = scales[titleField];
    var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
    return is_function_default(title) ? title(tooltipTitle, originData) : tooltipTitle;
  }
  function getAttributesForLegend(geometry) {
    var attributes = values_default(geometry.attributes);
    return filter_default(attributes, function(attribute) {
      return contains_default(GROUP_ATTRS, attribute.type);
    });
  }
  function getTooltipValueScale(geometry) {
    var attributes = getAttributesForLegend(geometry);
    var scale5;
    for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
      var attribute = attributes_1[_i];
      var tmpScale = attribute.getScale(attribute.type);
      if (tmpScale && tmpScale.isLinear) {
        scale5 = tmpScale;
        break;
      }
    }
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    return scale5 || yScale || xScale;
  }
  function getTooltipValue(originData, valueScale) {
    var field = valueScale.field;
    var value = originData[field];
    if (is_array_default(value)) {
      var texts = value.map(function(eachValue) {
        return valueScale.getText(eachValue);
      });
      return texts.join("-");
    }
    return valueScale.getText(value);
  }
  function getTooltipName(originData, geometry) {
    var nameScale;
    var groupScales = geometry.getGroupScales();
    if (groupScales.length) {
      nameScale = groupScales[0];
    }
    if (nameScale) {
      var field = nameScale.field;
      return nameScale.getText(originData[field]);
    }
    var valueScale = getTooltipValueScale(geometry);
    return getName(valueScale);
  }
  function findDataByPoint(point, data, geometry) {
    if (data.length === 0) {
      return null;
    }
    var geometryType = geometry.type;
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    var xField = xScale.field;
    var yField = yScale.field;
    var rst = null;
    if (geometryType === "heatmap" || geometryType === "point") {
      var coordinate = geometry.coordinate;
      var invertPoint = coordinate.invert(point);
      var x = xScale.invert(invertPoint.x);
      var y = yScale.invert(invertPoint.y);
      var min7 = Infinity;
      for (var index = 0; index < data.length; index++) {
        var obj = data[index];
        var originData = obj[FIELD_ORIGIN];
        var range5 = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
        if (range5 < min7) {
          min7 = range5;
          rst = obj;
        }
      }
      return rst;
    }
    var first = data[0];
    var last2 = data[data.length - 1];
    var xValue = getXValueByPoint(point, geometry);
    var firstXValue = first[FIELD_ORIGIN][xField];
    var firstYValue = first[FIELD_ORIGIN][yField];
    var lastXValue = last2[FIELD_ORIGIN][xField];
    var isYArray = yScale.isLinear && is_array_default(firstYValue);
    if (is_array_default(firstXValue)) {
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var originData = record[FIELD_ORIGIN];
        if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
          if (isYArray) {
            if (!is_array_default(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        }
      }
      if (is_array_default(rst)) {
        rst = filterYValue(rst, point, geometry);
      }
    } else {
      var next = void 0;
      if (!xScale.isLinear && xScale.type !== "timeCat") {
        for (var index = 0; index < data.length; index++) {
          var record = data[index];
          var originData = record[FIELD_ORIGIN];
          if (snapEqual(originData[xField], xValue, xScale)) {
            if (isYArray) {
              if (!is_array_default(rst)) {
                rst = [];
              }
              rst.push(record);
            } else {
              rst = record;
              break;
            }
          } else if (xScale.translate(originData[xField]) <= xValue) {
            last2 = record;
            next = data[index + 1];
          }
        }
        if (is_array_default(rst)) {
          rst = filterYValue(rst, point, geometry);
        }
      } else {
        if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
          return null;
        }
        var firstIdx = 0;
        var lastIdx = data.length - 1;
        var middleIdx = void 0;
        while (firstIdx <= lastIdx) {
          middleIdx = Math.floor((firstIdx + lastIdx) / 2);
          var item = data[middleIdx][FIELD_ORIGIN][xField];
          if (snapEqual(item, xValue, xScale)) {
            return data[middleIdx];
          }
          if (xScale.translate(item) <= xScale.translate(xValue)) {
            firstIdx = middleIdx + 1;
            last2 = data[middleIdx];
            next = data[middleIdx + 1];
          } else {
            if (lastIdx === 0) {
              last2 = data[0];
            }
            lastIdx = middleIdx - 1;
          }
        }
      }
      if (last2 && next) {
        if (Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
          last2 = next;
        }
      }
    }
    var distance8 = getXDistance(geometry.getXScale());
    if (!rst && Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) <= distance8 / 2) {
      rst = last2;
    }
    return rst;
  }
  function getTooltipItems(data, geometry, title, showNil) {
    if (title === void 0) {
      title = "";
    }
    if (showNil === void 0) {
      showNil = false;
    }
    var originData = data[FIELD_ORIGIN];
    var tooltipTitle = getTooltipTitle(originData, geometry, title);
    var tooltipOption = geometry.tooltipOption;
    var defaultColor = geometry.theme.defaultColor;
    var items = [];
    var name;
    var value;
    function addItem(itemName, itemValue) {
      if (showNil || !is_nil_default(itemValue) && itemValue !== "") {
        var item = {
          title: tooltipTitle,
          data: originData,
          mappingData: data,
          name: itemName,
          value: itemValue,
          color: data.color || defaultColor,
          marker: true
        };
        items.push(item);
      }
    }
    if (is_object_default(tooltipOption)) {
      var fields = tooltipOption.fields, callback = tooltipOption.callback;
      if (callback) {
        var callbackParams = fields.map(function(field2) {
          return data[FIELD_ORIGIN][field2];
        });
        var cfg = callback.apply(void 0, callbackParams);
        var itemCfg = __assign({ data: data[FIELD_ORIGIN], mappingData: data, title: tooltipTitle, color: data.color || defaultColor, marker: true }, cfg);
        items.push(itemCfg);
      } else {
        var scales = geometry.scales;
        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
          var field = fields_1[_i];
          if (!is_nil_default(originData[field])) {
            var scale5 = scales[field];
            name = getName(scale5);
            value = scale5.getText(originData[field]);
            addItem(name, value);
          }
        }
      }
    } else {
      var valueScale = getTooltipValueScale(geometry);
      value = getTooltipValue(originData, valueScale);
      name = getTooltipName(originData, geometry);
      addItem(name, value);
    }
    return items;
  }
  function getTooltipItemsByFindData(geometry, point, title, tooltipCfg) {
    var showNil = tooltipCfg.showNil;
    var result = [];
    var dataArray = geometry.dataArray;
    if (!is_empty_default(dataArray)) {
      geometry.sort(dataArray);
      for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {
        var data = dataArray_1[_i];
        var record = findDataByPoint(point, data, geometry);
        if (record) {
          var elementId = geometry.getElementId(record);
          var element = geometry.elementsMap[elementId];
          if (geometry.type === "heatmap" || element.visible) {
            var items = getTooltipItems(record, geometry, title, showNil);
            if (items.length) {
              result.push(items);
            }
          }
        }
      }
    }
    return result;
  }
  function getTooltipItemsByHitShape(geometry, point, title, tooltipCfg) {
    var showNil = tooltipCfg.showNil;
    var result = [];
    var container = geometry.container;
    var shape = container.getShape(point.x, point.y);
    if (shape && shape.get("visible") && shape.get("origin")) {
      var mappingData = shape.get("origin").mappingData;
      var items = getTooltipItems(mappingData, geometry, title, showNil);
      if (items.length) {
        result.push(items);
      }
    }
    return result;
  }
  function findItemsFromView(view, point, tooltipCfg) {
    var result = [];
    var geometries = view.geometries;
    var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
    for (var _i = 0, geometries_1 = geometries; _i < geometries_1.length; _i++) {
      var geometry = geometries_1[_i];
      if (geometry.visible && geometry.tooltipOption !== false) {
        var geometryType = geometry.type;
        var tooltipItems = void 0;
        if (["point", "edge", "polygon"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
        } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
        } else {
          if (shared !== false) {
            tooltipItems = getTooltipItemsByFindData(geometry, point, title, tooltipCfg);
          } else {
            tooltipItems = getTooltipItemsByHitShape(geometry, point, title, tooltipCfg);
          }
        }
        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          }
          result.push(tooltipItems);
        }
      }
    }
    return result;
  }
  function findItemsFromViewRecurisive(view, point, tooltipCfg) {
    var result = findItemsFromView(view, point, tooltipCfg);
    for (var _i = 0, _a4 = view.views; _i < _a4.length; _i++) {
      var childView = _a4[_i];
      result = result.concat(findItemsFromView(childView, point, tooltipCfg));
    }
    return result;
  }

  // node_modules/@antv/g2/esm/util/padding.js
  function isAutoPadding(padding) {
    return !is_number_default(padding) && !is_array_default(padding);
  }
  function parsePadding(padding) {
    if (padding === void 0) {
      padding = 0;
    }
    var paddingArray = is_array_default(padding) ? padding : [padding];
    switch (paddingArray.length) {
      case 0:
        paddingArray = [0, 0, 0, 0];
        break;
      case 1:
        paddingArray = new Array(4).fill(paddingArray[0]);
        break;
      case 2:
        paddingArray = __spreadArray(__spreadArray([], paddingArray, true), paddingArray, true);
        break;
      case 3:
        paddingArray = __spreadArray(__spreadArray([], paddingArray, true), [paddingArray[1]], false);
        break;
      default:
        paddingArray = paddingArray.slice(0, 4);
        break;
    }
    return paddingArray;
  }

  // node_modules/@antv/g2/esm/chart/controller/index.js
  var LOAD_COMPONENT_CONTROLLERS = {};
  function registerComponentController(name, plugin) {
    LOAD_COMPONENT_CONTROLLERS[name] = plugin;
  }
  function getComponentControllerNames() {
    return Object.keys(LOAD_COMPONENT_CONTROLLERS);
  }
  function getComponentController(name) {
    return LOAD_COMPONENT_CONTROLLERS[name];
  }

  // node_modules/@antv/g2/esm/chart/controller/coordinate.js
  var CoordinateController = function() {
    function CoordinateController2(option) {
      this.option = this.wrapperOption(option);
    }
    CoordinateController2.prototype.update = function(option) {
      this.option = this.wrapperOption(option);
      return this;
    };
    CoordinateController2.prototype.hasAction = function(actionName) {
      var actions = this.option.actions;
      return some_default(actions, function(action) {
        return action[0] === actionName;
      });
    };
    CoordinateController2.prototype.create = function(start, end) {
      var _a4 = this.option, type = _a4.type, cfg = _a4.cfg;
      var isTheta = type === "theta";
      var props = __assign({ start, end }, cfg);
      var C = getCoordinate(isTheta ? "polar" : type);
      this.coordinate = new C(props);
      this.coordinate.type = type;
      if (isTheta) {
        if (!this.hasAction("transpose")) {
          this.transpose();
        }
      }
      this.execActions();
      return this.coordinate;
    };
    CoordinateController2.prototype.adjust = function(start, end) {
      this.coordinate.update({
        start,
        end
      });
      this.coordinate.resetMatrix();
      this.execActions(["scale", "rotate", "translate"]);
      return this.coordinate;
    };
    CoordinateController2.prototype.rotate = function(angle3) {
      this.option.actions.push(["rotate", angle3]);
      return this;
    };
    CoordinateController2.prototype.reflect = function(dim) {
      this.option.actions.push(["reflect", dim]);
      return this;
    };
    CoordinateController2.prototype.scale = function(sx, sy) {
      this.option.actions.push(["scale", sx, sy]);
      return this;
    };
    CoordinateController2.prototype.transpose = function() {
      this.option.actions.push(["transpose"]);
      return this;
    };
    CoordinateController2.prototype.getOption = function() {
      return this.option;
    };
    CoordinateController2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    CoordinateController2.prototype.wrapperOption = function(option) {
      return __assign({ type: "rect", actions: [], cfg: {} }, option);
    };
    CoordinateController2.prototype.execActions = function(includeActions) {
      var _this = this;
      var actions = this.option.actions;
      each_default(actions, function(action) {
        var _a4;
        var actionName = action[0], args = action.slice(1);
        var shouldExec = is_nil_default(includeActions) ? true : includeActions.includes(actionName);
        if (shouldExec) {
          (_a4 = _this.coordinate)[actionName].apply(_a4, args);
        }
      });
    };
    return CoordinateController2;
  }();
  var coordinate_default = CoordinateController;

  // node_modules/@antv/g2/esm/chart/event.js
  var Event = function() {
    function Event2(view, gEvent, data) {
      this.view = view;
      this.gEvent = gEvent;
      this.data = data;
      this.type = gEvent.type;
    }
    Event2.fromData = function(view, type, data) {
      return new Event2(view, new graph_event_default(type, {}), data);
    };
    Object.defineProperty(Event2.prototype, "target", {
      get: function() {
        return this.gEvent.target;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "event", {
      get: function() {
        return this.gEvent.originalEvent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "x", {
      get: function() {
        return this.gEvent.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "y", {
      get: function() {
        return this.gEvent.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientX", {
      get: function() {
        return this.gEvent.clientX;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientY", {
      get: function() {
        return this.gEvent.clientY;
      },
      enumerable: false,
      configurable: true
    });
    Event2.prototype.toString = function() {
      return "[Event (type=" + this.type + ")]";
    };
    Event2.prototype.clone = function() {
      return new Event2(this.view, this.gEvent, this.data);
    };
    return Event2;
  }();
  var event_default = Event;

  // node_modules/@antv/g2/esm/chart/layout/index.js
  function defaultLayout(view) {
    var axis = view.getController("axis");
    var legend = view.getController("legend");
    var annotation = view.getController("annotation");
    var slider = view.getController("slider");
    var scrollbar = view.getController("scrollbar");
    [axis, slider, scrollbar, legend, annotation].forEach(function(controller) {
      if (controller) {
        controller.layout();
      }
    });
  }

  // node_modules/@antv/g2/esm/chart/util/scale-pool.js
  var ScalePool = function() {
    function ScalePool2() {
      this.scales = new Map();
      this.syncScales = new Map();
    }
    ScalePool2.prototype.createScale = function(field, data, scaleDef, key) {
      var finalScaleDef = scaleDef;
      var cacheScaleMeta = this.getScaleMeta(key);
      if (data.length === 0 && cacheScaleMeta) {
        var cacheScale = cacheScaleMeta.scale;
        var cacheScaleDef = {
          type: cacheScale.type
        };
        if (cacheScale.isCategory) {
          cacheScaleDef.values = cacheScale.values;
        }
        finalScaleDef = deep_mix_default(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
      }
      var scale5 = createScaleByField(field, data, finalScaleDef);
      this.cacheScale(scale5, scaleDef, key);
      return scale5;
    };
    ScalePool2.prototype.sync = function(coordinate, theme) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var min7 = Number.MAX_SAFE_INTEGER;
        var max7 = Number.MIN_SAFE_INTEGER;
        var values2 = [];
        each_default(scaleKeys, function(key) {
          var scale5 = _this.getScale(key);
          max7 = is_number_default(scale5.max) ? Math.max(max7, scale5.max) : max7;
          min7 = is_number_default(scale5.min) ? Math.min(min7, scale5.min) : min7;
          each_default(scale5.values, function(v) {
            if (!values2.includes(v)) {
              values2.push(v);
            }
          });
        });
        each_default(scaleKeys, function(key) {
          var scale5 = _this.getScale(key);
          if (scale5.isContinuous) {
            scale5.change({
              min: min7,
              max: max7,
              values: values2
            });
          } else if (scale5.isCategory) {
            var range5 = scale5.range;
            var cacheScaleMeta = _this.getScaleMeta(key);
            if (values2 && !get_default(cacheScaleMeta, ["scaleDef", "range"])) {
              range5 = getDefaultCategoryScaleRange(deep_mix_default({}, scale5, {
                values: values2
              }), coordinate, theme);
            }
            scale5.change({
              values: values2,
              range: range5
            });
          }
        });
      });
    };
    ScalePool2.prototype.cacheScale = function(scale5, scaleDef, key) {
      var sm = this.getScaleMeta(key);
      if (sm && sm.scale.type === scale5.type) {
        syncScale(sm.scale, scale5);
        sm.scaleDef = scaleDef;
      } else {
        sm = {
          key,
          scale: scale5,
          scaleDef
        };
        this.scales.set(key, sm);
      }
      var syncKey = this.getSyncKey(sm);
      sm.syncKey = syncKey;
      this.removeFromSyncScales(key);
      if (syncKey) {
        var scaleKeys = this.syncScales.get(syncKey);
        if (!scaleKeys) {
          scaleKeys = [];
          this.syncScales.set(syncKey, scaleKeys);
        }
        scaleKeys.push(key);
      }
    };
    ScalePool2.prototype.getScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (!scaleMeta) {
        var field = last(key.split("-"));
        var scaleKeys = this.syncScales.get(field);
        if (scaleKeys && scaleKeys.length) {
          scaleMeta = this.getScaleMeta(scaleKeys[0]);
        }
      }
      return scaleMeta && scaleMeta.scale;
    };
    ScalePool2.prototype.deleteScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (scaleMeta) {
        var syncKey = scaleMeta.syncKey;
        var scaleKeys = this.syncScales.get(syncKey);
        if (scaleKeys && scaleKeys.length) {
          var idx = scaleKeys.indexOf(key);
          if (idx !== -1) {
            scaleKeys.splice(idx, 1);
          }
        }
      }
      this.scales.delete(key);
    };
    ScalePool2.prototype.clear = function() {
      this.scales.clear();
      this.syncScales.clear();
    };
    ScalePool2.prototype.removeFromSyncScales = function(key) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var idx = scaleKeys.indexOf(key);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
          if (scaleKeys.length === 0) {
            _this.syncScales.delete(syncKey);
          }
          return false;
        }
      });
    };
    ScalePool2.prototype.getSyncKey = function(sm) {
      var scale5 = sm.scale, scaleDef = sm.scaleDef;
      var field = scale5.field;
      var sync = get_default(scaleDef, ["sync"]);
      return sync === true ? field : sync === false ? void 0 : sync;
    };
    ScalePool2.prototype.getScaleMeta = function(key) {
      return this.scales.get(key);
    };
    return ScalePool2;
  }();

  // node_modules/@antv/g2/esm/chart/layout/padding-cal.js
  var PaddingCal = function() {
    function PaddingCal2(top, right, bottom, left) {
      if (top === void 0) {
        top = 0;
      }
      if (right === void 0) {
        right = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      this.top = top;
      this.right = right;
      this.bottom = bottom;
      this.left = left;
    }
    PaddingCal2.instance = function(top, right, bottom, left) {
      if (top === void 0) {
        top = 0;
      }
      if (right === void 0) {
        right = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left === void 0) {
        left = 0;
      }
      return new PaddingCal2(top, right, bottom, left);
    };
    PaddingCal2.prototype.max = function(padding) {
      var top = padding[0], right = padding[1], bottom = padding[2], left = padding[3];
      this.top = Math.max(this.top, top);
      this.right = Math.max(this.right, right);
      this.bottom = Math.max(this.bottom, bottom);
      this.left = Math.max(this.left, left);
      return this;
    };
    PaddingCal2.prototype.shrink = function(padding) {
      var top = padding[0], right = padding[1], bottom = padding[2], left = padding[3];
      this.top += top;
      this.right += right;
      this.bottom += bottom;
      this.left += left;
      return this;
    };
    PaddingCal2.prototype.inc = function(bbox, direction2) {
      var width = bbox.width, height = bbox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          this.top += height;
          break;
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          this.right += width;
          break;
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          this.bottom += height;
          break;
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          this.left += width;
          break;
        default:
          break;
      }
      return this;
    };
    PaddingCal2.prototype.getPadding = function() {
      return [this.top, this.right, this.bottom, this.left];
    };
    PaddingCal2.prototype.clone = function() {
      return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray([void 0], this.getPadding(), false)))();
    };
    return PaddingCal2;
  }();

  // node_modules/@antv/g2/esm/chart/layout/auto.js
  function calculatePadding(view) {
    var padding = view.padding;
    if (!isAutoPadding(padding)) {
      return new (PaddingCal.bind.apply(PaddingCal, __spreadArray([void 0], parsePadding(padding), false)))();
    }
    var viewBBox = view.viewBBox;
    var paddingCal = new PaddingCal();
    var axisComponents = [];
    var paddingComponents = [];
    var otherComponents = [];
    each_default(view.getComponents(), function(co) {
      var type = co.type;
      if (type === COMPONENT_TYPE.AXIS) {
        axisComponents.push(co);
      } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
        paddingComponents.push(co);
      } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
        otherComponents.push(co);
      }
    });
    each_default(axisComponents, function(co) {
      var component = co.component;
      var bboxObject = component.getLayoutBBox();
      var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
      var exceed = componentBBox.exceed(viewBBox);
      paddingCal.max(exceed);
    });
    each_default(paddingComponents, function(co) {
      var component = co.component, direction2 = co.direction;
      var bboxObject = component.getLayoutBBox();
      var componentPadding = component.get("padding");
      var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
      paddingCal.inc(componentBBox, direction2);
    });
    each_default(otherComponents, function(co) {
      var component = co.component, direction2 = co.direction;
      var bboxObject = component.getLayoutBBox();
      var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
      paddingCal.inc(componentBBox, direction2);
    });
    return paddingCal;
  }

  // node_modules/@antv/g2/esm/chart/util/sync-view-padding.js
  function defaultSyncViewPadding(chart, views, PC) {
    var syncPadding = PC.instance();
    views.forEach(function(v) {
      v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
    });
  }

  // node_modules/@antv/g2/esm/chart/view.js
  var View = function(_super) {
    __extends(View2, _super);
    function View2(props) {
      var _this = _super.call(this, { visible: props.visible }) || this;
      _this.views = [];
      _this.geometries = [];
      _this.controllers = [];
      _this.interactions = {};
      _this.limitInPlot = false;
      _this.options = {
        data: [],
        animate: true
      };
      _this.usedControllers = getComponentControllerNames();
      _this.scalePool = new ScalePool();
      _this.layoutFunc = defaultLayout;
      _this.isPreMouseInPlot = false;
      _this.isDataChanged = false;
      _this.isCoordinateChanged = false;
      _this.createdScaleKeys = new Map();
      _this.onCanvasEvent = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          var e = _this.createViewEvent(evt);
          _this.doPlotEvent(e);
          _this.emit(name, e);
        }
      };
      _this.onDelegateEvents = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          return;
        }
        var e = _this.createViewEvent(evt);
        _this.emit(name, e);
      };
      var _a4 = props.id, id = _a4 === void 0 ? unique_id_default("view") : _a4, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding = props.padding, appendPadding = props.appendPadding, theme = props.theme, options = props.options, limitInPlot2 = props.limitInPlot, syncViewPadding = props.syncViewPadding;
      _this.parent = parent;
      _this.canvas = canvas;
      _this.backgroundGroup = backgroundGroup;
      _this.middleGroup = middleGroup;
      _this.foregroundGroup = foregroundGroup;
      _this.region = region;
      _this.padding = padding;
      _this.appendPadding = appendPadding;
      _this.options = __assign(__assign({}, _this.options), options);
      _this.limitInPlot = limitInPlot2;
      _this.id = id;
      _this.syncViewPadding = syncViewPadding;
      _this.themeObject = is_object_default(theme) ? deep_mix_default({}, getTheme("default"), createTheme(theme)) : getTheme(theme);
      _this.init();
      return _this;
    }
    View2.prototype.setLayout = function(layout) {
      this.layoutFunc = layout;
    };
    View2.prototype.init = function() {
      this.calculateViewBBox();
      this.initEvents();
      this.initComponentController();
      this.initOptions();
    };
    View2.prototype.render = function(isUpdate, payload) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
      this.paint(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    View2.prototype.clear = function() {
      var _this = this;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
      this.filteredData = [];
      this.coordinateInstance = void 0;
      this.isDataChanged = false;
      this.isCoordinateChanged = false;
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        geometries[i].clear();
        geometries[i].container.remove(true);
        geometries[i].labelsContainer.remove(true);
      }
      this.geometries = [];
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        if (controllers[i].name === "annotation") {
          controllers[i].clear(true);
        } else {
          controllers[i].clear();
        }
      }
      this.createdScaleKeys.forEach(function(v, k) {
        _this.getRootView().scalePool.deleteScale(k);
      });
      this.createdScaleKeys.clear();
      var views = this.views;
      for (var i = 0; i < views.length; i++) {
        views[i].clear();
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
    };
    View2.prototype.destroy = function() {
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
      var interactions = this.interactions;
      each_default(interactions, function(interaction) {
        if (interaction) {
          interaction.destroy();
        }
      });
      this.clear();
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        controller.destroy();
      }
      this.backgroundGroup.remove(true);
      this.middleGroup.remove(true);
      this.foregroundGroup.remove(true);
      _super.prototype.destroy.call(this);
    };
    View2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var geometries = this.geometries;
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry = geometries[i];
        geometry.changeVisible(visible);
      }
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        controller.changeVisible(visible);
      }
      this.foregroundGroup.set("visible", visible);
      this.middleGroup.set("visible", visible);
      this.backgroundGroup.set("visible", visible);
      this.getCanvas().draw();
      return this;
    };
    View2.prototype.data = function(data) {
      set_default(this.options, "data", data);
      this.isDataChanged = true;
      return this;
    };
    View2.prototype.source = function(data) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
      return this.data(data);
    };
    View2.prototype.filter = function(field, condition) {
      if (is_function_default(condition)) {
        set_default(this.options, ["filters", field], condition);
        return this;
      }
      if (!condition && get_default(this.options, ["filters", field])) {
        delete this.options.filters[field];
      }
      return this;
    };
    View2.prototype.axis = function(field, axisOption) {
      if (is_boolean_default(field)) {
        set_default(this.options, ["axes"], field);
      } else {
        set_default(this.options, ["axes", field], axisOption);
      }
      return this;
    };
    View2.prototype.legend = function(field, legendOption) {
      if (is_boolean_default(field)) {
        set_default(this.options, ["legends"], field);
      } else if (is_string_default(field)) {
        set_default(this.options, ["legends", field], legendOption);
        if (is_plain_object_default(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
          set_default(this.options, ["filters", field], function(name) {
            var _a4;
            return (_a4 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a4 !== void 0 ? _a4 : true;
          });
        }
      } else {
        set_default(this.options, ["legends"], field);
      }
      return this;
    };
    View2.prototype.scale = function(field, scaleOption) {
      var _this = this;
      if (is_string_default(field)) {
        set_default(this.options, ["scales", field], scaleOption);
      } else if (is_object_default(field)) {
        each_default(field, function(v, k) {
          set_default(_this.options, ["scales", k], v);
        });
      }
      return this;
    };
    View2.prototype.tooltip = function(cfg) {
      set_default(this.options, "tooltip", cfg);
      return this;
    };
    View2.prototype.annotation = function() {
      return this.getController("annotation");
    };
    View2.prototype.guide = function() {
      console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
      return this.annotation();
    };
    View2.prototype.coordinate = function(type, coordinateCfg) {
      if (is_string_default(type)) {
        set_default(this.options, "coordinate", { type, cfg: coordinateCfg });
      } else {
        set_default(this.options, "coordinate", type);
      }
      this.coordinateController.update(this.options.coordinate);
      return this.coordinateController;
    };
    View2.prototype.coord = function(type, coordinateCfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
      return this.coordinate(type, coordinateCfg);
    };
    View2.prototype.facet = function(type, cfg) {
      if (this.facetInstance) {
        this.facetInstance.destroy();
      }
      var Ctor = getFacet(type);
      if (!Ctor) {
        throw new Error("facet '" + type + "' is not exist!");
      }
      this.facetInstance = new Ctor(this, __assign(__assign({}, cfg), { type }));
      return this;
    };
    View2.prototype.animate = function(status) {
      set_default(this.options, "animate", status);
      return this;
    };
    View2.prototype.updateOptions = function(options) {
      this.clear();
      mix(this.options, options);
      this.views.forEach(function(view) {
        return view.destroy();
      });
      this.views = [];
      this.initOptions();
      this.coordinateBBox = this.viewBBox;
      return this;
    };
    View2.prototype.option = function(name, opt) {
      if (View2.prototype[name]) {
        throw new Error(`Can't use built in variable name "` + name + '", please change another one.');
      }
      set_default(this.options, name, opt);
      return this;
    };
    View2.prototype.theme = function(theme) {
      this.themeObject = is_object_default(theme) ? deep_mix_default({}, this.themeObject, createTheme(theme)) : getTheme(theme);
      return this;
    };
    View2.prototype.interaction = function(name, cfg) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
      }
      var interaction = createInteraction(name, this, cfg);
      if (interaction) {
        interaction.init();
        this.interactions[name] = interaction;
      }
      return this;
    };
    View2.prototype.removeInteraction = function(name) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
        this.interactions[name] = void 0;
      }
    };
    View2.prototype.changeData = function(data) {
      this.isDataChanged = true;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.data(data);
      this.paint(true);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.changeData(data);
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, event_default.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    View2.prototype.createView = function(cfg) {
      if (this.parent && this.parent.parent) {
        console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
      }
      var sharedOptions = {
        data: this.options.data,
        scales: clone_default(this.options.scales),
        axes: clone_default(this.options.axes),
        coordinate: clone_default(this.coordinateController.getOption()),
        tooltip: clone_default(this.options.tooltip),
        legends: clone_default(this.options.legends),
        animate: this.options.animate,
        visible: this.visible
      };
      var v = new View2(__assign(__assign({
        parent: this,
        canvas: this.canvas,
        backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        theme: this.themeObject,
        padding: this.padding
      }, cfg), { options: __assign(__assign({}, sharedOptions), get_default(cfg, "options", {})) }));
      this.views.push(v);
      return v;
    };
    View2.prototype.view = function(cfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
      return this.createView(cfg);
    };
    View2.prototype.removeView = function(view) {
      var removedView = remove_default(this.views, function(v) {
        return v === view;
      })[0];
      if (removedView) {
        removedView.destroy();
      }
      return removedView;
    };
    View2.prototype.getCoordinate = function() {
      return this.coordinateInstance;
    };
    View2.prototype.getTheme = function() {
      return this.themeObject;
    };
    View2.prototype.getXScale = function() {
      var g = this.geometries[0];
      return g ? g.getXScale() : null;
    };
    View2.prototype.getYScales = function() {
      var tmpMap = {};
      var yScales = [];
      this.geometries.forEach(function(g) {
        var yScale = g.getYScale();
        var field = yScale.field;
        if (!tmpMap[field]) {
          tmpMap[field] = true;
          yScales.push(yScale);
        }
      });
      return yScales;
    };
    View2.prototype.getScalesByDim = function(dimType) {
      var geometries = this.geometries;
      var scales = {};
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry = geometries[i];
        var scale5 = dimType === "x" ? geometry.getXScale() : geometry.getYScale();
        if (scale5 && !scales[scale5.field]) {
          scales[scale5.field] = scale5;
        }
      }
      return scales;
    };
    View2.prototype.getScale = function(field, key) {
      var defaultKey = key ? key : this.getScaleKey(field);
      return this.getRootView().scalePool.getScale(defaultKey);
    };
    View2.prototype.getScaleByField = function(field, key) {
      return this.getScale(field, key);
    };
    View2.prototype.getOptions = function() {
      return this.options;
    };
    View2.prototype.getData = function() {
      return this.filteredData;
    };
    View2.prototype.getOriginalData = function() {
      return this.options.data;
    };
    View2.prototype.getPadding = function() {
      return this.autoPadding.getPadding();
    };
    View2.prototype.getGeometries = function() {
      return this.geometries;
    };
    View2.prototype.getElements = function() {
      return reduce_default(this.geometries, function(elements, geometry) {
        return elements.concat(geometry.getElements());
      }, []);
    };
    View2.prototype.getElementsBy = function(condition) {
      return this.getElements().filter(function(el) {
        return condition(el);
      });
    };
    View2.prototype.getLayer = function(layer) {
      return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
    };
    View2.prototype.isPointInPlot = function(point) {
      return isPointInCoordinate(this.getCoordinate(), point);
    };
    View2.prototype.getLegendAttributes = function() {
      return flatten_default(this.geometries.map(function(g) {
        return g.getGroupAttributes();
      }));
    };
    View2.prototype.getGroupScales = function() {
      var scales = this.geometries.map(function(g) {
        return g.getGroupScales();
      });
      return uniq2(flatten_default(scales));
    };
    View2.prototype.getCanvas = function() {
      return this.getRootView().canvas;
    };
    View2.prototype.getRootView = function() {
      var v = this;
      while (true) {
        if (v.parent) {
          v = v.parent;
          continue;
        }
        break;
      }
      return v;
    };
    View2.prototype.getXY = function(data) {
      var coordinate = this.getCoordinate();
      var xScales = this.getScalesByDim("x");
      var yScales = this.getScalesByDim("y");
      var x;
      var y;
      each_default(data, function(value, key) {
        if (xScales[key]) {
          x = xScales[key].scale(value);
        }
        if (yScales[key]) {
          y = yScales[key].scale(value);
        }
      });
      if (!is_nil_default(x) && !is_nil_default(y)) {
        return coordinate.convert({ x, y });
      }
    };
    View2.prototype.getController = function(name) {
      return find_default(this.controllers, function(c) {
        return c.name === name;
      });
    };
    View2.prototype.showTooltip = function(point) {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.showTooltip(point);
      }
      return this;
    };
    View2.prototype.hideTooltip = function() {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.hideTooltip();
      }
      return this;
    };
    View2.prototype.lockTooltip = function() {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.lockTooltip();
      }
      return this;
    };
    View2.prototype.unlockTooltip = function() {
      var tooltip = this.getController("tooltip");
      if (tooltip) {
        tooltip.unlockTooltip();
      }
      return this;
    };
    View2.prototype.isTooltipLocked = function() {
      var tooltip = this.getController("tooltip");
      return tooltip && tooltip.isTooltipLocked();
    };
    View2.prototype.getTooltipItems = function(point) {
      var tooltip = this.getController("tooltip");
      return tooltip ? tooltip.getTooltipItems(point) : [];
    };
    View2.prototype.getSnapRecords = function(point) {
      var geometries = this.geometries;
      var rst = [];
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geom = geometries[i];
        var dataArray = geom.dataArray;
        geom.sort(dataArray);
        var record = void 0;
        for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
          var data = dataArray[j];
          record = findDataByPoint(point, data, geom);
          if (record) {
            rst.push(record);
          }
        }
      }
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        var snapRecords = view.getSnapRecords(point);
        rst = rst.concat(snapRecords);
      }
      return rst;
    };
    View2.prototype.getComponents = function() {
      var components = [];
      var controllers = this.controllers;
      for (var i = 0, len3 = controllers.length; i < len3; i++) {
        var controller = controllers[i];
        components = components.concat(controller.getComponents());
      }
      return components;
    };
    View2.prototype.filterData = function(data) {
      var filters = this.options.filters;
      if (size2(filters) === 0) {
        return data;
      }
      return filter_default(data, function(datum, idx) {
        var fields = Object.keys(filters);
        return fields.every(function(field) {
          var condition = filters[field];
          return condition(datum[field], datum, idx);
        });
      });
    };
    View2.prototype.filterFieldData = function(field, data) {
      var filters = this.options.filters;
      var condition = get_default(filters, field);
      if (is_undefined_default(condition)) {
        return data;
      }
      return data.filter(function(datum, idx) {
        return condition(datum[field], datum, idx);
      });
    };
    View2.prototype.adjustCoordinate = function() {
      var _a4 = this.getCoordinate(), curStart = _a4.start, curEnd = _a4.end;
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      if (is_equal_default(curStart, start) && is_equal_default(curEnd, end)) {
        this.isCoordinateChanged = false;
        return;
      }
      this.isCoordinateChanged = true;
      this.coordinateInstance = this.coordinateController.adjust(start, end);
    };
    View2.prototype.paint = function(isUpdate) {
      this.renderDataRecursive(isUpdate);
      this.syncScale();
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
      this.renderPaddingRecursive(isUpdate);
      this.renderLayoutRecursive(isUpdate);
      this.renderBackgroundStyleShape();
      this.renderPaintRecursive(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
      this.isDataChanged = false;
    };
    View2.prototype.renderBackgroundStyleShape = function() {
      if (this.parent) {
        return;
      }
      var background = get_default(this.themeObject, "background");
      if (background) {
        if (!this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
            attrs: {},
            zIndex: -1,
            capture: false
          });
          this.backgroundStyleRectShape.toBack();
        }
        var _a4 = this.viewBBox, x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
        this.backgroundStyleRectShape.attr({
          fill: background,
          x,
          y,
          width,
          height
        });
      } else {
        if (this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape.remove(true);
          this.backgroundStyleRectShape = void 0;
        }
      }
    };
    View2.prototype.renderPaddingRecursive = function(isUpdate) {
      this.calculateViewBBox();
      this.adjustCoordinate();
      this.initComponents(isUpdate);
      this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
      this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
      this.adjustCoordinate();
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderPaddingRecursive(isUpdate);
      }
    };
    View2.prototype.renderLayoutRecursive = function(isUpdate) {
      var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : is_function_default(this.syncViewPadding) ? this.syncViewPadding : void 0;
      if (syncViewPaddingFn) {
        syncViewPaddingFn(this, this.views, PaddingCal);
        this.views.forEach(function(v) {
          v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
          v.adjustCoordinate();
        });
      }
      this.doLayout();
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderLayoutRecursive(isUpdate);
      }
    };
    View2.prototype.renderPaintRecursive = function(isUpdate) {
      var middleGroup = this.middleGroup;
      if (this.limitInPlot) {
        var _a4 = getCoordinateClipCfg(this.coordinateInstance), type = _a4.type, attrs = _a4.attrs;
        middleGroup.setClip({
          type,
          attrs
        });
      } else {
        middleGroup.setClip(void 0);
      }
      this.paintGeometries(isUpdate);
      this.renderComponents(isUpdate);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderPaintRecursive(isUpdate);
      }
    };
    View2.prototype.createScale = function(field, data, scaleDef, key) {
      var currentScaleDef = get_default(this.options.scales, [field]);
      var mergedScaleDef = __assign(__assign({}, currentScaleDef), scaleDef);
      if (this.parent) {
        return this.parent.createScale(field, data, mergedScaleDef, key);
      }
      return this.scalePool.createScale(field, data, mergedScaleDef, key);
    };
    View2.prototype.renderDataRecursive = function(isUpdate) {
      this.doFilterData();
      this.createCoordinate();
      this.initGeometries(isUpdate);
      this.renderFacet(isUpdate);
      var views = this.views;
      for (var i = 0, len3 = views.length; i < len3; i++) {
        var view = views[i];
        view.renderDataRecursive(isUpdate);
      }
    };
    View2.prototype.calculateViewBBox = function() {
      var x;
      var y;
      var width;
      var height;
      if (this.parent) {
        var bbox = this.parent.coordinateBBox;
        x = bbox.x;
        y = bbox.y;
        width = bbox.width;
        height = bbox.height;
      } else {
        x = 0;
        y = 0;
        width = this.canvas.get("width");
        height = this.canvas.get("height");
      }
      var _a4 = this.region, start = _a4.start, end = _a4.end;
      var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
        this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      }
      this.coordinateBBox = this.viewBBox;
    };
    View2.prototype.initEvents = function() {
      this.foregroundGroup.on("*", this.onDelegateEvents);
      this.middleGroup.on("*", this.onDelegateEvents);
      this.backgroundGroup.on("*", this.onDelegateEvents);
      this.canvas.on("*", this.onCanvasEvent);
    };
    View2.prototype.initComponentController = function() {
      var usedControllers = this.usedControllers;
      for (var i = 0, len3 = usedControllers.length; i < len3; i++) {
        var controllerName = usedControllers[i];
        var Ctor = getComponentController(controllerName);
        if (Ctor) {
          this.controllers.push(new Ctor(this));
        }
      }
    };
    View2.prototype.createViewEvent = function(evt) {
      var shape = evt.shape, name = evt.name;
      var data = shape ? shape.get("origin") : null;
      var e = new event_default(this, evt, data);
      e.type = name;
      return e;
    };
    View2.prototype.doPlotEvent = function(e) {
      var type = e.type, x = e.x, y = e.y;
      var point = { x, y };
      var ALL_EVENTS = [
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseleave",
        "mousewheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "click",
        "dblclick",
        "contextmenu"
      ];
      if (ALL_EVENTS.includes(type)) {
        var currentInPlot = this.isPointInPlot(point);
        var newEvent = e.clone();
        if (currentInPlot) {
          var TYPE = "plot:" + type;
          newEvent.type = TYPE;
          this.emit(TYPE, newEvent);
          if (type === "mouseleave" || type === "touchend") {
            this.isPreMouseInPlot = false;
          }
        }
        if (type === "mousemove" || type === "touchmove") {
          if (this.isPreMouseInPlot && !currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
          } else if (!this.isPreMouseInPlot && currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
              this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
            }
            newEvent.type = PLOT_EVENTS.ENTER;
            this.emit(PLOT_EVENTS.ENTER, newEvent);
          }
          this.isPreMouseInPlot = currentInPlot;
        } else if (type === "mouseleave" || type === "touchend") {
          if (this.isPreMouseInPlot) {
            if (type === "mouseleave") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
            this.isPreMouseInPlot = false;
          }
        }
      }
    };
    View2.prototype.doFilterData = function() {
      var data = this.options.data;
      this.filteredData = this.filterData(data);
    };
    View2.prototype.initGeometries = function(isUpdate) {
      this.createOrUpdateScales();
      var coordinate = this.getCoordinate();
      var scaleDefs = get_default(this.options, "scales", {});
      var geometries = this.geometries;
      for (var i = 0, len3 = geometries.length; i < len3; i++) {
        var geometry = geometries[i];
        geometry.scales = this.getGeometryScales();
        var cfg = {
          coordinate,
          scaleDefs,
          data: this.filteredData,
          theme: this.themeObject,
          isDataChanged: this.isDataChanged,
          isCoordinateChanged: this.isCoordinateChanged
        };
        if (isUpdate) {
          geometry.update(cfg);
        } else {
          geometry.init(cfg);
        }
      }
      this.adjustScales();
    };
    View2.prototype.createOrUpdateScales = function() {
      var fields = this.getScaleFields();
      var groupedFields = this.getGroupedFields();
      var _a4 = this.getOptions(), data = _a4.data, _b = _a4.scales, scales = _b === void 0 ? {} : _b;
      var filteredData = this.filteredData;
      for (var i = 0, len3 = fields.length; i < len3; i++) {
        var field = fields[i];
        var scaleDef = scales[field];
        var key = this.getScaleKey(field);
        this.createScale(field, groupedFields.includes(field) ? data : filteredData, scaleDef, key);
        this.createdScaleKeys.set(key, true);
      }
    };
    View2.prototype.syncScale = function() {
      this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
    };
    View2.prototype.getGeometryScales = function() {
      var fields = this.getScaleFields();
      var scales = {};
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        scales[field] = this.getScaleByField(field);
      }
      return scales;
    };
    View2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        var geometryScales = geometry.getScaleFields();
        uniq2(geometryScales, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.getGroupedFields = function() {
      var fields = [];
      var tmpMap = new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        var groupFields = geometry.getGroupFields();
        uniq2(groupFields, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.adjustScales = function() {
      this.adjustCategoryScaleRange();
    };
    View2.prototype.adjustCategoryScaleRange = function() {
      var _this = this;
      var xyScales = __spreadArray([this.getXScale()], this.getYScales(), true).filter(function(e) {
        return !!e;
      });
      var coordinate = this.getCoordinate();
      var scaleOptions = this.options.scales;
      each_default(xyScales, function(scale5) {
        var field = scale5.field, values2 = scale5.values, isCategory = scale5.isCategory, isIdentity = scale5.isIdentity;
        if (isCategory || isIdentity) {
          if (values2 && !get_default(scaleOptions, [field, "range"])) {
            scale5.range = getDefaultCategoryScaleRange(scale5, coordinate, _this.theme);
          }
        }
      });
    };
    View2.prototype.initComponents = function(isUpdate) {
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        if (isUpdate) {
          controller.update();
        } else {
          controller.clear();
          controller.render();
        }
      }
    };
    View2.prototype.doLayout = function() {
      this.layoutFunc(this);
    };
    View2.prototype.createCoordinate = function() {
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      this.coordinateInstance = this.coordinateController.create(start, end);
    };
    View2.prototype.paintGeometries = function(isUpdate) {
      var doAnimation = this.options.animate;
      var coordinate = this.getCoordinate();
      var canvasRegion = {
        x: this.viewBBox.x,
        y: this.viewBBox.y,
        minX: this.viewBBox.minX,
        minY: this.viewBBox.minY,
        maxX: this.viewBBox.maxX,
        maxY: this.viewBBox.maxY,
        width: this.viewBBox.width,
        height: this.viewBBox.height
      };
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        geometry.coordinate = coordinate;
        geometry.canvasRegion = canvasRegion;
        if (!doAnimation) {
          geometry.animate(false);
        }
        geometry.paint(isUpdate);
      }
    };
    View2.prototype.renderComponents = function(isUpdate) {
      for (var i = 0; i < this.getComponents().length; i++) {
        var co = this.getComponents()[i];
        co.component.render();
      }
    };
    View2.prototype.renderFacet = function(isUpdate) {
      if (this.facetInstance) {
        if (isUpdate) {
          this.facetInstance.update();
        } else {
          this.facetInstance.clear();
          this.facetInstance.init();
          this.facetInstance.render();
        }
      }
    };
    View2.prototype.initOptions = function() {
      var _this = this;
      var _a4 = this.options, _b = _a4.geometries, geometries = _b === void 0 ? [] : _b, _c = _a4.interactions, interactions = _c === void 0 ? [] : _c, _d = _a4.views, views = _d === void 0 ? [] : _d, _e = _a4.annotations, annotations = _e === void 0 ? [] : _e, coordinate = _a4.coordinate, events = _a4.events, facets = _a4.facets;
      if (this.coordinateController) {
        coordinate && this.coordinateController.update(coordinate);
      } else {
        this.coordinateController = new coordinate_default(coordinate);
      }
      for (var i = 0; i < geometries.length; i++) {
        var geometryOption = geometries[i];
        this.createGeometry(geometryOption);
      }
      for (var j = 0; j < interactions.length; j++) {
        var interactionOption = interactions[j];
        var type = interactionOption.type, cfg = interactionOption.cfg;
        this.interaction(type, cfg);
      }
      for (var k = 0; k < views.length; k++) {
        var viewOption = views[k];
        this.createView(viewOption);
      }
      var annotationComponent = this.getController("annotation");
      for (var l = 0; l < annotations.length; l++) {
        var annotationOption = annotations[l];
        annotationComponent.annotation(annotationOption);
      }
      if (events) {
        each_default(events, function(eventCallback, eventName) {
          _this.on(eventName, eventCallback);
        });
      }
      if (facets) {
        each_default(facets, function(facet) {
          var type2 = facet.type, rest = __rest(facet, ["type"]);
          _this.facet(type2, rest);
        });
      }
    };
    View2.prototype.createGeometry = function(geometryOption) {
      var type = geometryOption.type, _a4 = geometryOption.cfg, cfg = _a4 === void 0 ? {} : _a4;
      if (this[type]) {
        var geometry_1 = this[type](cfg);
        each_default(geometryOption, function(v, k) {
          if (is_function_default(geometry_1[k])) {
            geometry_1[k](v);
          }
        });
      }
    };
    View2.prototype.getScaleKey = function(field) {
      return this.id + "-" + field;
    };
    return View2;
  }(base_default);
  function registerGeometry(name, Ctor) {
    View.prototype[name.toLowerCase()] = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      var props = __assign({
        container: this.middleGroup.addGroup(),
        labelsContainer: this.foregroundGroup.addGroup()
      }, cfg);
      var geometry = new Ctor(props);
      this.geometries.push(geometry);
      return geometry;
    };
  }
  var view_default = View;

  // node_modules/@antv/g2/esm/chart/chart.js
  var Chart = function(_super) {
    __extends(Chart2, _super);
    function Chart2(props) {
      var _this = this;
      var container = props.container, width = props.width, height = props.height, _a4 = props.autoFit, autoFit = _a4 === void 0 ? false : _a4, padding = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer2 = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text"] : _f, options = props.options, limitInPlot2 = props.limitInPlot, theme = props.theme, syncViewPadding = props.syncViewPadding;
      var ele = is_string_default(container) ? document.getElementById(container) : container;
      var wrapperElement = createDom('<div style="position:relative;"></div>');
      ele.appendChild(wrapperElement);
      var size3 = getChartSize(ele, autoFit, width, height);
      var G = getEngine(renderer2);
      var canvas = new G.Canvas(__assign({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size3));
      _this = _super.call(this, {
        parent: null,
        canvas,
        backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        padding,
        appendPadding,
        visible,
        options,
        limitInPlot: limitInPlot2,
        theme,
        syncViewPadding
      }) || this;
      _this.onResize = debounce_default(function() {
        _this.forceFit();
      }, 300);
      _this.ele = ele;
      _this.canvas = canvas;
      _this.width = size3.width;
      _this.height = size3.height;
      _this.autoFit = autoFit;
      _this.localRefresh = localRefresh;
      _this.renderer = renderer2;
      _this.wrapperElement = wrapperElement;
      _this.updateCanvasStyle();
      _this.bindAutoFit();
      _this.initDefaultInteractions(defaultInteractions);
      return _this;
    }
    Chart2.prototype.initDefaultInteractions = function(interactions) {
      var _this = this;
      each_default(interactions, function(interaction) {
        _this.interaction(interaction);
      });
    };
    Chart2.prototype.aria = function(ariaOption) {
      var ATTR = "aria-label";
      if (ariaOption === false) {
        this.ele.removeAttribute(ATTR);
      } else {
        this.ele.setAttribute(ATTR, ariaOption.label);
      }
    };
    Chart2.prototype.changeSize = function(width, height) {
      if (this.width === width && this.height === height) {
        return this;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
      this.width = width;
      this.height = height;
      this.canvas.changeSize(width, height);
      this.render(true);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
      return this;
    };
    Chart2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.aria(false);
    };
    Chart2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unbindAutoFit();
      this.canvas.destroy();
      removeDom(this.wrapperElement);
      this.wrapperElement = null;
    };
    Chart2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      this.wrapperElement.style.display = visible ? "" : "none";
      return this;
    };
    Chart2.prototype.forceFit = function() {
      if (!this.destroyed) {
        var _a4 = getChartSize(this.ele, true, this.width, this.height), width = _a4.width, height = _a4.height;
        this.changeSize(width, height);
      }
    };
    Chart2.prototype.updateCanvasStyle = function() {
      modifyCSS(this.canvas.get("el"), {
        display: "inline-block",
        verticalAlign: "middle"
      });
    };
    Chart2.prototype.bindAutoFit = function() {
      if (this.autoFit) {
        window.addEventListener("resize", this.onResize);
      }
    };
    Chart2.prototype.unbindAutoFit = function() {
      if (this.autoFit) {
        window.removeEventListener("resize", this.onResize);
      }
    };
    return Chart2;
  }(view_default);
  var chart_default = Chart;

  // node_modules/@antv/g2/esm/chart/controller/base.js
  var Controller = function() {
    function Controller2(view) {
      this.visible = true;
      this.components = [];
      this.view = view;
    }
    Controller2.prototype.clear = function(includeOption) {
      each_default(this.components, function(co) {
        co.component.destroy();
      });
      this.components = [];
    };
    Controller2.prototype.destroy = function() {
      this.clear();
    };
    Controller2.prototype.getComponents = function() {
      return this.components;
    };
    Controller2.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.components.forEach(function(co) {
        if (visible) {
          co.component.show();
        } else {
          co.component.hide();
        }
      });
      this.visible = visible;
    };
    return Controller2;
  }();

  // node_modules/@antv/g2/esm/chart/controller/tooltip.js
  function uniq3(items) {
    var uniqItems = [];
    var _loop_1 = function(index2) {
      var item = items[index2];
      var result = find_default(uniqItems, function(subItem) {
        return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
      });
      if (!result) {
        uniqItems.push(item);
      }
    };
    for (var index = 0; index < items.length; index++) {
      _loop_1(index);
    }
    return uniqItems;
  }
  var Tooltip2 = function(_super) {
    __extends(Tooltip3, _super);
    function Tooltip3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isLocked = false;
      return _this;
    }
    Object.defineProperty(Tooltip3.prototype, "name", {
      get: function() {
        return "tooltip";
      },
      enumerable: false,
      configurable: true
    });
    Tooltip3.prototype.init = function() {
    };
    Tooltip3.prototype.isVisible = function() {
      var option = this.view.getOptions().tooltip;
      return option !== false;
    };
    Tooltip3.prototype.render = function() {
    };
    Tooltip3.prototype.showTooltip = function(point) {
      this.point = point;
      if (!this.isVisible()) {
        return;
      }
      var view = this.view;
      var items = this.getTooltipItems(point);
      if (!items.length) {
        this.hideTooltip();
        return;
      }
      var title = this.getTitle(items);
      var dataPoint = {
        x: items[0].x,
        y: items[0].y
      };
      view.emit("tooltip:show", event_default.fromData(view, "tooltip:show", __assign({ items, title }, point)));
      var cfg = this.getTooltipCfg();
      var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
      var lastItems = this.items;
      var lastTitle = this.title;
      if (!is_equal_default(lastTitle, title) || !is_equal_default(lastItems, items)) {
        view.emit("tooltip:change", event_default.fromData(view, "tooltip:change", __assign({ items, title }, point)));
        if (is_function_default(showContent) ? showContent(items) : showContent) {
          if (!this.tooltip) {
            this.renderTooltip();
          }
          this.tooltip.update(mix({}, cfg, {
            items: this.getItemsAfterProcess(items),
            title
          }, follow ? point : {}));
          this.tooltip.show();
        }
        if (showMarkers) {
          this.renderTooltipMarkers(items, marker);
        }
      } else {
        if (this.tooltip && follow) {
          this.tooltip.update(point);
          this.tooltip.show();
        }
        if (this.tooltipMarkersGroup) {
          this.tooltipMarkersGroup.show();
        }
      }
      this.items = items;
      this.title = title;
      if (showCrosshairs) {
        var isCrosshairsFollowCursor = get_default(cfg, ["crosshairs", "follow"], false);
        this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);
      }
    };
    Tooltip3.prototype.hideTooltip = function() {
      var follow = this.getTooltipCfg().follow;
      if (!follow) {
        this.point = null;
        return;
      }
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      var xCrosshair = this.xCrosshair;
      var yCrosshair = this.yCrosshair;
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
      var tooltip = this.tooltip;
      if (tooltip) {
        tooltip.hide();
      }
      this.view.emit("tooltip:hide", event_default.fromData(this.view, "tooltip:hide", {}));
      this.point = null;
    };
    Tooltip3.prototype.lockTooltip = function() {
      this.isLocked = true;
      if (this.tooltip) {
        this.tooltip.setCapture(true);
      }
    };
    Tooltip3.prototype.unlockTooltip = function() {
      this.isLocked = false;
      var cfg = this.getTooltipCfg();
      if (this.tooltip) {
        this.tooltip.setCapture(cfg.capture);
      }
    };
    Tooltip3.prototype.isTooltipLocked = function() {
      return this.isLocked;
    };
    Tooltip3.prototype.clear = function() {
      var _a4 = this, tooltip = _a4.tooltip, xCrosshair = _a4.xCrosshair, yCrosshair = _a4.yCrosshair, tooltipMarkersGroup = _a4.tooltipMarkersGroup;
      if (tooltip) {
        tooltip.hide();
        tooltip.clear();
      }
      if (xCrosshair) {
        xCrosshair.clear();
      }
      if (yCrosshair) {
        yCrosshair.clear();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.clear();
      }
      if (tooltip === null || tooltip === void 0 ? void 0 : tooltip.get("customContent")) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
      this.title = null;
      this.items = null;
    };
    Tooltip3.prototype.destroy = function() {
      if (this.tooltip) {
        this.tooltip.destroy();
      }
      if (this.xCrosshair) {
        this.xCrosshair.destroy();
      }
      if (this.yCrosshair) {
        this.yCrosshair.destroy();
      }
      if (this.guideGroup) {
        this.guideGroup.remove(true);
      }
      this.reset();
    };
    Tooltip3.prototype.reset = function() {
      this.items = null;
      this.title = null;
      this.tooltipMarkersGroup = null;
      this.tooltipCrosshairsGroup = null;
      this.xCrosshair = null;
      this.yCrosshair = null;
      this.tooltip = null;
      this.guideGroup = null;
      this.isLocked = false;
      this.point = null;
    };
    Tooltip3.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      var _a4 = this, tooltip = _a4.tooltip, tooltipMarkersGroup = _a4.tooltipMarkersGroup, xCrosshair = _a4.xCrosshair, yCrosshair = _a4.yCrosshair;
      if (visible) {
        if (tooltip) {
          tooltip.show();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.show();
        }
        if (xCrosshair) {
          xCrosshair.show();
        }
        if (yCrosshair) {
          yCrosshair.show();
        }
      } else {
        if (tooltip) {
          tooltip.hide();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.hide();
        }
        if (xCrosshair) {
          xCrosshair.hide();
        }
        if (yCrosshair) {
          yCrosshair.hide();
        }
      }
      this.visible = visible;
    };
    Tooltip3.prototype.getTooltipItems = function(point) {
      var items = this.findItemsFromView(this.view, point);
      if (items.length) {
        items = flatten_default(items);
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
          var itemArr = items_1[_i];
          for (var _a4 = 0, itemArr_1 = itemArr; _a4 < itemArr_1.length; _a4++) {
            var item = itemArr_1[_a4];
            var _b = item.mappingData, x = _b.x, y = _b.y;
            item.x = is_array_default(x) ? x[x.length - 1] : x;
            item.y = is_array_default(y) ? y[y.length - 1] : y;
          }
        }
        var shared = this.getTooltipCfg().shared;
        if (shared === false && items.length > 1) {
          var snapItem = items[0];
          var min7 = Math.abs(point.y - snapItem[0].y);
          for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
            var aItem = items_2[_c];
            var yDistance = Math.abs(point.y - aItem[0].y);
            if (yDistance <= min7) {
              snapItem = aItem;
              min7 = yDistance;
            }
          }
          items = [snapItem];
        }
        return uniq3(flatten_default(items));
      }
      return [];
    };
    Tooltip3.prototype.layout = function() {
    };
    Tooltip3.prototype.update = function() {
      if (this.point) {
        this.showTooltip(this.point);
      }
      if (this.tooltip) {
        var canvas = this.view.getCanvas();
        this.tooltip.set("region", {
          start: { x: 0, y: 0 },
          end: { x: canvas.get("width"), y: canvas.get("height") }
        });
      }
    };
    Tooltip3.prototype.isCursorEntered = function(point) {
      if (this.tooltip) {
        var el = this.tooltip.getContainer();
        var capture = this.tooltip.get("capture");
        if (el && capture) {
          var _a4 = el.getBoundingClientRect(), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
          return new BBox(x, y, width, height).isPointIn(point);
        }
      }
      return false;
    };
    Tooltip3.prototype.getTooltipCfg = function() {
      var view = this.view;
      var option = view.getOptions().tooltip;
      var processOption = this.processCustomContent(option);
      var theme = view.getTheme();
      var defaultCfg = get_default(theme, ["components", "tooltip"], {});
      var enterable = get_default(processOption, "enterable", defaultCfg.enterable);
      return deep_mix_default({}, defaultCfg, processOption, {
        capture: enterable || this.isLocked ? true : false
      });
    };
    Tooltip3.prototype.processCustomContent = function(option) {
      if (is_boolean_default(option) || !get_default(option, "customContent")) {
        return option;
      }
      var currentCustomContent = option.customContent;
      var customContent = function(title, items) {
        var content = currentCustomContent(title, items) || "";
        return is_string_default(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
      };
      return __assign(__assign({}, option), { customContent });
    };
    Tooltip3.prototype.getTitle = function(items) {
      var title = items[0].title || items[0].name;
      this.title = title;
      return title;
    };
    Tooltip3.prototype.renderTooltip = function() {
      var canvas = this.view.getCanvas();
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var cfg = this.getTooltipCfg();
      var tooltip = new HtmlTooltip(__assign(__assign({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
      tooltip.init();
      this.tooltip = tooltip;
    };
    Tooltip3.prototype.renderTooltipMarkers = function(items, marker) {
      var tooltipMarkersGroup = this.getTooltipMarkersGroup();
      for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
        var item = items_3[_i];
        var x = item.x, y = item.y;
        var attrs = __assign(__assign({ fill: item.color, symbol: "circle", shadowColor: item.color }, marker), { x, y });
        tooltipMarkersGroup.addShape("marker", {
          attrs
        });
      }
    };
    Tooltip3.prototype.renderCrosshairs = function(point, cfg) {
      var crosshairsType = get_default(cfg, ["crosshairs", "type"], "x");
      if (crosshairsType === "x") {
        if (this.yCrosshair) {
          this.yCrosshair.hide();
        }
        this.renderXCrosshairs(point, cfg);
      } else if (crosshairsType === "y") {
        if (this.xCrosshair) {
          this.xCrosshair.hide();
        }
        this.renderYCrosshairs(point, cfg);
      } else if (crosshairsType === "xy") {
        this.renderXCrosshairs(point, cfg);
        this.renderYCrosshairs(point, cfg);
      }
    };
    Tooltip3.prototype.renderXCrosshairs = function(point, tooltipCfg) {
      var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
      if (!isPointInCoordinate(coordinate, point)) {
        return;
      }
      var start;
      var end;
      if (coordinate.isRect) {
        if (coordinate.isTransposed) {
          start = {
            x: coordinate.start.x,
            y: point.y
          };
          end = {
            x: coordinate.end.x,
            y: point.y
          };
        } else {
          start = {
            x: point.x,
            y: coordinate.end.y
          };
          end = {
            x: point.x,
            y: coordinate.start.y
          };
        }
      } else {
        var angle3 = getAngleByPoint(coordinate, point);
        var center = coordinate.getCenter();
        var radius = coordinate.getRadius();
        end = polarToCartesian(center.x, center.y, radius, angle3);
        start = center;
      }
      var cfg = deep_mix_default({
        start,
        end,
        container: this.getTooltipCrosshairsGroup()
      }, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point, tooltipCfg));
      delete cfg.type;
      var xCrosshair = this.xCrosshair;
      if (xCrosshair) {
        xCrosshair.update(cfg);
      } else {
        xCrosshair = new crosshair_exports.Line(cfg);
        xCrosshair.init();
      }
      xCrosshair.render();
      xCrosshair.show();
      this.xCrosshair = xCrosshair;
    };
    Tooltip3.prototype.renderYCrosshairs = function(point, tooltipCfg) {
      var coordinate = this.getViewWithGeometry(this.view).getCoordinate();
      if (!isPointInCoordinate(coordinate, point)) {
        return;
      }
      var cfg;
      var type;
      if (coordinate.isRect) {
        var start = void 0;
        var end = void 0;
        if (coordinate.isTransposed) {
          start = {
            x: point.x,
            y: coordinate.end.y
          };
          end = {
            x: point.x,
            y: coordinate.start.y
          };
        } else {
          start = {
            x: coordinate.start.x,
            y: point.y
          };
          end = {
            x: coordinate.end.x,
            y: point.y
          };
        }
        cfg = {
          start,
          end
        };
        type = "Line";
      } else {
        cfg = {
          center: coordinate.getCenter(),
          radius: getDistanceToCenter(coordinate, point),
          startAngle: coordinate.startAngle,
          endAngle: coordinate.endAngle
        };
        type = "Circle";
      }
      cfg = deep_mix_default({
        container: this.getTooltipCrosshairsGroup()
      }, cfg, get_default(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point, tooltipCfg));
      delete cfg.type;
      var yCrosshair = this.yCrosshair;
      if (yCrosshair) {
        if (coordinate.isRect && yCrosshair.get("type") === "circle" || !coordinate.isRect && yCrosshair.get("type") === "line") {
          yCrosshair = new crosshair_exports[type](cfg);
          yCrosshair.init();
        } else {
          yCrosshair.update(cfg);
        }
      } else {
        yCrosshair = new crosshair_exports[type](cfg);
        yCrosshair.init();
      }
      yCrosshair.render();
      yCrosshair.show();
      this.yCrosshair = yCrosshair;
    };
    Tooltip3.prototype.getCrosshairsText = function(type, point, tooltipCfg) {
      var textCfg = get_default(tooltipCfg, ["crosshairs", "text"]);
      var follow = get_default(tooltipCfg, ["crosshairs", "follow"]);
      var items = this.items;
      if (textCfg) {
        var view = this.getViewWithGeometry(this.view);
        var firstItem = items[0];
        var xScale = view.getXScale();
        var yScale = view.getYScales()[0];
        var xValue = void 0;
        var yValue = void 0;
        if (follow) {
          var invertPoint = this.view.getCoordinate().invert(point);
          xValue = xScale.invert(invertPoint.x);
          yValue = yScale.invert(invertPoint.y);
        } else {
          xValue = firstItem.data[xScale.field];
          yValue = firstItem.data[yScale.field];
        }
        var content = type === "x" ? xValue : yValue;
        if (is_function_default(textCfg)) {
          textCfg = textCfg(type, content, items, point);
        } else {
          textCfg.content = content;
        }
        return {
          text: textCfg
        };
      }
    };
    Tooltip3.prototype.getGuideGroup = function() {
      if (!this.guideGroup) {
        var foregroundGroup = this.view.foregroundGroup;
        this.guideGroup = foregroundGroup.addGroup({
          name: "tooltipGuide",
          capture: false
        });
      }
      return this.guideGroup;
    };
    Tooltip3.prototype.getTooltipMarkersGroup = function() {
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
        tooltipMarkersGroup.clear();
        tooltipMarkersGroup.show();
      } else {
        tooltipMarkersGroup = this.getGuideGroup().addGroup({
          name: "tooltipMarkersGroup"
        });
        tooltipMarkersGroup.toFront();
        this.tooltipMarkersGroup = tooltipMarkersGroup;
      }
      return tooltipMarkersGroup;
    };
    Tooltip3.prototype.getTooltipCrosshairsGroup = function() {
      var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
      if (!tooltipCrosshairsGroup) {
        tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
          name: "tooltipCrosshairsGroup",
          capture: false
        });
        tooltipCrosshairsGroup.toBack();
        this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
      }
      return tooltipCrosshairsGroup;
    };
    Tooltip3.prototype.findItemsFromView = function(view, point) {
      if (view.getOptions().tooltip === false) {
        return [];
      }
      var tooltipCfg = this.getTooltipCfg();
      var result = findItemsFromView(view, point, tooltipCfg);
      for (var _i = 0, _a4 = view.views; _i < _a4.length; _i++) {
        var childView = _a4[_i];
        result = result.concat(this.findItemsFromView(childView, point));
      }
      return result;
    };
    Tooltip3.prototype.getViewWithGeometry = function(view) {
      var _this = this;
      if (view.geometries.length) {
        return view;
      }
      return find_default(view.views, function(childView) {
        return _this.getViewWithGeometry(childView);
      });
    };
    Tooltip3.prototype.getItemsAfterProcess = function(originalItems) {
      var customItems = this.getTooltipCfg().customItems;
      var fn = customItems ? customItems : function(v) {
        return v;
      };
      return fn(originalItems);
    };
    return Tooltip3;
  }(Controller);
  var tooltip_default = Tooltip2;

  // node_modules/@antv/g2/esm/animate/animation/index.js
  var ANIMATIONS_MAP = {};
  function getAnimation(type) {
    return ANIMATIONS_MAP[type.toLowerCase()];
  }
  function registerAnimation(type, animation) {
    ANIMATIONS_MAP[type.toLowerCase()] = animation;
  }

  // node_modules/@antv/g2/esm/animate/index.js
  var DEFAULT_ANIMATE_CFG = {
    appear: {
      duration: 450,
      easing: "easeQuadOut"
    },
    update: {
      duration: 400,
      easing: "easeQuadInOut"
    },
    enter: {
      duration: 400,
      easing: "easeQuadInOut"
    },
    leave: {
      duration: 350,
      easing: "easeQuadIn"
    }
  };
  var GEOMETRY_ANIMATE_CFG = {
    interval: function(coordinate) {
      return {
        enter: {
          animation: coordinate.isRect ? coordinate.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
        },
        update: {
          animation: coordinate.isPolar && coordinate.isTransposed ? "sector-path-update" : null
        },
        leave: {
          animation: "fade-out"
        }
      };
    },
    line: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    path: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    point: {
      appear: {
        animation: "zoom-in"
      },
      enter: {
        animation: "zoom-in"
      },
      leave: {
        animation: "zoom-out"
      }
    },
    area: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    polygon: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    schema: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    edge: {
      enter: {
        animation: "fade-in"
      },
      leave: {
        animation: "fade-out"
      }
    },
    label: {
      appear: {
        animation: "fade-in",
        delay: 450
      },
      enter: {
        animation: "fade-in"
      },
      update: {
        animation: "position-update"
      },
      leave: {
        animation: "fade-out"
      }
    }
  };
  var GEOMETRY_GROUP_APPEAR_ANIMATION = {
    line: function() {
      return {
        animation: "wave-in"
      };
    },
    area: function() {
      return {
        animation: "wave-in"
      };
    },
    path: function() {
      return {
        animation: "fade-in"
      };
    },
    interval: function(coordinate) {
      var animation;
      if (coordinate.isRect) {
        animation = coordinate.isTransposed ? "grow-in-x" : "grow-in-y";
      } else {
        animation = "grow-in-xy";
        if (coordinate.isPolar && coordinate.isTransposed) {
          animation = "wave-in";
        }
      }
      return {
        animation
      };
    },
    schema: function(coordinate) {
      var animation;
      if (coordinate.isRect) {
        animation = coordinate.isTransposed ? "grow-in-x" : "grow-in-y";
      } else {
        animation = "grow-in-xy";
      }
      return {
        animation
      };
    },
    polygon: function() {
      return {
        animation: "fade-in",
        duration: 500
      };
    },
    edge: function() {
      return {
        animation: "fade-in"
      };
    }
  };
  function parseAnimateConfig(animateCfg, data) {
    return {
      delay: is_function_default(animateCfg.delay) ? animateCfg.delay(data) : animateCfg.delay,
      easing: is_function_default(animateCfg.easing) ? animateCfg.easing(data) : animateCfg.easing,
      duration: is_function_default(animateCfg.duration) ? animateCfg.duration(data) : animateCfg.duration,
      callback: animateCfg.callback,
      repeat: animateCfg.repeat
    };
  }
  function getDefaultAnimateCfg(elementName, coordinate, animateType) {
    var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
    if (animateCfg) {
      if (is_function_default(animateCfg)) {
        animateCfg = animateCfg(coordinate);
      }
      animateCfg = deep_mix_default({}, DEFAULT_ANIMATE_CFG, animateCfg);
      if (animateType) {
        return animateCfg[animateType];
      }
    }
    return animateCfg;
  }
  function doAnimate(shape, animateCfg, cfg) {
    var data = get_default(shape.get("origin"), "data", FIELD_ORIGIN);
    var animation = animateCfg.animation;
    var parsedAnimateCfg = parseAnimateConfig(animateCfg, data);
    if (animation) {
      var animateFunction = getAnimation(animation);
      if (animateFunction) {
        animateFunction(shape, parsedAnimateCfg, cfg);
      }
    } else {
      shape.animate(cfg.toAttrs, parsedAnimateCfg);
    }
  }
  function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate, minYPoint) {
    if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
      var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate);
      var animation = getAnimation(get_default(defaultCfg, "animation", ""));
      if (animation) {
        var cfg = __assign(__assign(__assign({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
        container.stopAnimate();
        animation(container, cfg, {
          coordinate,
          minYPoint,
          toAttrs: null
        });
      }
    }
  }

  // node_modules/@antv/g2/esm/geometry/shape/constant.js
  var BACKGROUND_SHAPE = "element-background";

  // node_modules/@antv/g2/esm/geometry/element/index.js
  var Element4 = function(_super) {
    __extends(Element5, _super);
    function Element5(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.states = [];
      var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a4 = cfg.visible, visible = _a4 === void 0 ? true : _a4;
      _this.shapeFactory = shapeFactory;
      _this.container = container;
      _this.offscreenGroup = offscreenGroup;
      _this.visible = visible;
      _this.elementIndex = elementIndex;
      return _this;
    }
    Element5.prototype.draw = function(model2, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.model = model2;
      this.data = model2.data;
      this.shapeType = this.getShapeType(model2);
      this.drawShape(model2, isUpdate);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Element5.prototype.update = function(model2) {
      var _a4 = this, shapeFactory = _a4.shapeFactory, shape = _a4.shape;
      if (!shape) {
        return;
      }
      this.model = model2;
      this.data = model2.data;
      this.shapeType = this.getShapeType(model2);
      this.setShapeInfo(shape, model2);
      var offscreenGroup = this.getOffscreenGroup();
      var newShape = shapeFactory.drawShape(this.shapeType, model2, offscreenGroup);
      newShape.cfg.data = this.data;
      newShape.cfg.origin = model2;
      newShape.cfg.element = this;
      this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
    };
    Element5.prototype.destroy = function() {
      var _a4 = this, shapeFactory = _a4.shapeFactory, shape = _a4.shape;
      if (shape) {
        var animateCfg = this.getAnimateCfg("leave");
        if (animateCfg) {
          doAnimate(shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign({}, shape.attr())
          });
        } else {
          shape.remove(true);
        }
      }
      this.states = [];
      this.shapeFactory = void 0;
      this.container = void 0;
      this.shape = void 0;
      this.animate = void 0;
      this.geometry = void 0;
      this.labelShape = void 0;
      this.model = void 0;
      this.data = void 0;
      this.offscreenGroup = void 0;
      this.statesStyle = void 0;
      _super.prototype.destroy.call(this);
    };
    Element5.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      if (visible) {
        if (this.shape) {
          this.shape.show();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label) {
            label.show();
          });
        }
      } else {
        if (this.shape) {
          this.shape.hide();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label) {
            label.hide();
          });
        }
      }
    };
    Element5.prototype.setState = function(stateName, stateStatus) {
      var _a4 = this, states = _a4.states, shapeFactory = _a4.shapeFactory, model2 = _a4.model, shape = _a4.shape, shapeType = _a4.shapeType;
      var index = states.indexOf(stateName);
      if (stateStatus) {
        if (index > -1) {
          return;
        }
        states.push(stateName);
        if (stateName === "active" || stateName === "selected") {
          shape === null || shape === void 0 ? void 0 : shape.toFront();
        }
      } else {
        if (index === -1) {
          return;
        }
        states.splice(index, 1);
        if (stateName === "active" || stateName === "selected") {
          if (this.geometry.zIndexReversed) {
            shape.setZIndex(this.geometry.elements.length - this.elementIndex);
          } else {
            shape.setZIndex(this.elementIndex);
          }
        }
      }
      var offscreenShape = shapeFactory.drawShape(shapeType, model2, this.getOffscreenGroup());
      if (states.length) {
        this.syncShapeStyle(shape, offscreenShape, states, null);
      } else {
        this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
      }
      offscreenShape.remove(true);
      var eventObject = {
        state: stateName,
        stateStatus,
        element: this,
        target: this.container
      };
      this.container.emit("statechange", eventObject);
      propagationDelegate(this.shape, "statechange", eventObject);
    };
    Element5.prototype.clearStates = function() {
      var _this = this;
      var states = this.states;
      each_default(states, function(state) {
        _this.setState(state, false);
      });
      this.states = [];
    };
    Element5.prototype.hasState = function(stateName) {
      return this.states.includes(stateName);
    };
    Element5.prototype.getStates = function() {
      return this.states;
    };
    Element5.prototype.getData = function() {
      return this.data;
    };
    Element5.prototype.getModel = function() {
      return this.model;
    };
    Element5.prototype.getBBox = function() {
      var _a4 = this, shape = _a4.shape, labelShape = _a4.labelShape;
      var bbox = {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
      if (shape) {
        bbox = shape.getCanvasBBox();
      }
      if (labelShape) {
        labelShape.forEach(function(label) {
          var labelBBox = label.getCanvasBBox();
          bbox.x = Math.min(labelBBox.x, bbox.x);
          bbox.y = Math.min(labelBBox.y, bbox.y);
          bbox.minX = Math.min(labelBBox.minX, bbox.minX);
          bbox.minY = Math.min(labelBBox.minY, bbox.minY);
          bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
          bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
        });
      }
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      return bbox;
    };
    Element5.prototype.getStatesStyle = function() {
      if (!this.statesStyle) {
        var _a4 = this, shapeType = _a4.shapeType, geometry = _a4.geometry, shapeFactory = _a4.shapeFactory;
        var stateOption = geometry.stateOption;
        var defaultShapeType = shapeFactory.defaultShapeType;
        var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
        this.statesStyle = deep_mix_default({}, stateTheme, stateOption);
      }
      return this.statesStyle;
    };
    Element5.prototype.getStateStyle = function(stateName, shapeKey) {
      var statesStyle = this.getStatesStyle();
      var stateCfg = get_default(statesStyle, [stateName, "style"], {});
      var shapeStyle = stateCfg[shapeKey] || stateCfg;
      if (is_function_default(shapeStyle)) {
        return shapeStyle(this);
      }
      return shapeStyle;
    };
    Element5.prototype.getAnimateCfg = function(animateType) {
      var _this = this;
      var animate = this.animate;
      if (animate) {
        var cfg_1 = animate[animateType];
        if (cfg_1) {
          return __assign(__assign({}, cfg_1), { callback: function() {
            var _a4;
            is_function_default(cfg_1.callback) && cfg_1.callback();
            (_a4 = _this.geometry) === null || _a4 === void 0 ? void 0 : _a4.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
          } });
        }
        return cfg_1;
      }
      return null;
    };
    Element5.prototype.drawShape = function(model2, isUpdate) {
      var _a4;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
      this.shape = shapeFactory.drawShape(shapeType, model2, container);
      if (this.shape) {
        this.setShapeInfo(this.shape, model2);
        var name_1 = this.shape.cfg.name;
        if (!name_1) {
          this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
        } else if (is_string_default(name_1)) {
          this.shape.cfg.name = ["element", name_1];
        }
        var animateType = isUpdate ? "enter" : "appear";
        var animateCfg = this.getAnimateCfg(animateType);
        if (animateCfg) {
          (_a4 = this.geometry) === null || _a4 === void 0 ? void 0 : _a4.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(this.shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign({}, this.shape.attr())
          });
        }
      }
    };
    Element5.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Element5.prototype.setShapeInfo = function(shape, data) {
      var _this = this;
      shape.cfg.origin = data;
      shape.cfg.element = this;
      if (shape.isGroup()) {
        var children = shape.get("children");
        children.forEach(function(child) {
          _this.setShapeInfo(child, data);
        });
      }
    };
    Element5.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index) {
      var _this = this;
      var _a4;
      if (states === void 0) {
        states = [];
      }
      if (index === void 0) {
        index = 0;
      }
      if (!sourceShape || !targetShape) {
        return;
      }
      var clip2 = sourceShape.get("clipShape");
      var newClip = targetShape.get("clipShape");
      this.syncShapeStyle(clip2, newClip, states, animateCfg);
      if (sourceShape.isGroup()) {
        var children = sourceShape.get("children");
        var newChildren = targetShape.get("children");
        for (var i = 0; i < children.length; i++) {
          this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
        }
      } else {
        if (!is_empty_default(states) && !is_equal_default(states, ["reset"])) {
          var name_2 = sourceShape.get("name");
          if (is_array_default(name_2)) {
            name_2 = name_2[1];
          }
          each_default(states, function(state) {
            if (targetShape.get("name") !== BACKGROUND_SHAPE) {
              var style = _this.getStateStyle(state, name_2 || index);
              targetShape.attr(style);
            }
          });
        }
        var newAttrs = getReplaceAttrs(sourceShape, targetShape);
        if (this.animate) {
          if (animateCfg) {
            (_a4 = this.geometry) === null || _a4 === void 0 ? void 0 : _a4.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
            doAnimate(sourceShape, animateCfg, {
              coordinate: this.shapeFactory.coordinate,
              toAttrs: newAttrs,
              shapeModel: this.model
            });
          } else if (!is_empty_default(states)) {
            sourceShape.stopAnimate();
            sourceShape.animate(newAttrs, {
              duration: 300
            });
          } else {
            sourceShape.attr(newAttrs);
          }
        } else {
          sourceShape.attr(newAttrs);
        }
      }
    };
    Element5.prototype.getShapeType = function(model2) {
      var shape = get_default(model2, "shape");
      return is_array_default(shape) ? shape[0] : shape;
    };
    return Element5;
  }(base_default);
  var element_default3 = Element4;

  // node_modules/@antv/g2/esm/geometry/label/index.js
  var GEOMETRY_LABELS_MAP = {};
  var GEOMETRY_LABELS_LAYOUT_MAP = {};
  function getGeometryLabel(type) {
    return GEOMETRY_LABELS_MAP[type.toLowerCase()];
  }
  function registerGeometryLabel(type, ctor) {
    GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
  }
  function getGeometryLabelLayout(type) {
    return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
  }
  function registerGeometryLabelLayout(type, layoutFn) {
    GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
  }

  // node_modules/@antv/g2/esm/geometry/shape/base.js
  var ShapeFactoryBase = {
    coordinate: null,
    defaultShapeType: null,
    theme: null,
    getShapePoints: function(shapeType, shapePoint) {
      var shape = this.getShape(shapeType);
      if (shape.getPoints) {
        return shape.getPoints(shapePoint);
      }
      return this.getDefaultPoints(shapePoint);
    },
    getShape: function(shapeType) {
      var shape = this[shapeType] || this[this.defaultShapeType];
      shape.coordinate = this.coordinate;
      return shape;
    },
    getDefaultPoints: function() {
      return [];
    },
    getDefaultStyle: function(geometryTheme) {
      return get_default(geometryTheme, [this.defaultShapeType, "default", "style"], {});
    },
    getMarker: function(shapeType, markerCfg) {
      var shape = this.getShape(shapeType);
      if (!shape.getMarker) {
        var defaultShapeType = this.defaultShapeType;
        shape = this.getShape(defaultShapeType);
      }
      var theme = this.theme;
      var shapeStyle = get_default(theme, [shapeType, "default"], {});
      var markerStyle = shape.getMarker(markerCfg);
      return deep_mix_default({}, shapeStyle, markerStyle);
    },
    drawShape: function(shapeType, cfg, container) {
      var shape = this.getShape(shapeType);
      return shape.draw(cfg, container);
    }
  };
  var ShapeBase = {
    coordinate: null,
    parsePath: function(path) {
      var coordinate = this.coordinate;
      var parsedPath = parsePathString2(path);
      if (coordinate.isPolar) {
        parsedPath = convertPolarPath(coordinate, parsedPath);
      } else {
        parsedPath = convertNormalPath(coordinate, parsedPath);
      }
      return parsedPath;
    },
    parsePoint: function(point) {
      var coordinate = this.coordinate;
      return coordinate.convert(point);
    },
    parsePoints: function(points) {
      var coordinate = this.coordinate;
      return points.map(function(point) {
        return coordinate.convert(point);
      });
    },
    draw: function(cfg, container) {
    }
  };
  var ShapeFactoryMap = {};
  function registerShapeFactory(factoryName, cfg) {
    var className = upper_first_default(factoryName);
    var geomObj = __assign(__assign(__assign({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
    ShapeFactoryMap[className] = geomObj;
    return geomObj;
  }
  function registerShape(factoryName, shapeType, cfg) {
    var className = upper_first_default(factoryName);
    var factory = ShapeFactoryMap[className];
    var shapeObj = __assign(__assign({}, ShapeBase), cfg);
    factory[shapeType] = shapeObj;
    return shapeObj;
  }
  function getShapeFactory(factoryName) {
    var className = upper_first_default(factoryName);
    return ShapeFactoryMap[className];
  }

  // node_modules/@antv/g2/esm/geometry/util/group-data.js
  function group(data, fields, appendConditions) {
    if (appendConditions === void 0) {
      appendConditions = {};
    }
    if (!fields) {
      return [data];
    }
    var groups = groupToMap(data, fields);
    var array2 = [];
    if (fields.length === 1 && appendConditions[fields[0]]) {
      var values2 = appendConditions[fields[0]];
      for (var _i = 0, values_1 = values2; _i < values_1.length; _i++) {
        var value = values_1[_i];
        var arr = groups["_" + value];
        if (arr) {
          array2.push(arr);
        }
      }
    } else {
      for (var k in groups) {
        if (groups.hasOwnProperty(k)) {
          var eachGroup = groups[k];
          array2.push(eachGroup);
        }
      }
    }
    return array2;
  }

  // node_modules/@antv/g2/esm/geometry/util/is-model-change.js
  function isModelChange(currentModel, preModel) {
    return some_default(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key) {
      return !is_equal_default(currentModel[key], preModel[key]);
    });
  }

  // node_modules/@antv/g2/esm/geometry/util/parse-fields.js
  function parseFields(field) {
    if (is_array_default(field)) {
      return field;
    }
    return field.split("*");
  }

  // node_modules/@antv/g2/esm/geometry/util/diff.js
  function diff(keyItem, keys2) {
    var added = [];
    var updated = [];
    var removed = [];
    var keyIncluded = new Map();
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (keyItem[key])
        updated.push(key);
      else
        added.push(key);
      keyIncluded.set(key, true);
    }
    Object.keys(keyItem).forEach(function(key2) {
      if (!keyIncluded.has(key2))
        removed.push(key2);
    });
    return {
      added,
      updated,
      removed
    };
  }

  // node_modules/@antv/g2/esm/geometry/base.js
  function filterLabelsById(id, labelsMap) {
    var labels = [];
    each_default(labelsMap, function(label, labelId) {
      var elementId = labelId.split(" ")[0];
      if (elementId === id) {
        labels.push(label);
      }
    });
    return labels;
  }
  var Geometry = function(_super) {
    __extends(Geometry2, _super);
    function Geometry2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "base";
      _this.attributes = {};
      _this.elements = [];
      _this.elementsMap = {};
      _this.animateOption = true;
      _this.attributeOption = {};
      _this.lastElementsMap = {};
      _this.generatePoints = false;
      _this.beforeMappingData = null;
      _this.adjusts = {};
      _this.idFields = [];
      _this.hasSorted = false;
      _this.isCoordinateChanged = false;
      var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate = cfg.coordinate, data = cfg.data, _a4 = cfg.sortable, sortable = _a4 === void 0 ? false : _a4, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed;
      _this.container = container;
      _this.labelsContainer = labelsContainer;
      _this.coordinate = coordinate;
      _this.data = data;
      _this.sortable = sortable;
      _this.visible = visible;
      _this.userTheme = theme;
      _this.scales = scales;
      _this.scaleDefs = scaleDefs;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.roseWidthRatio = roseWidthRatio;
      _this.multiplePieWidthRatio = multiplePieWidthRatio;
      _this.zIndexReversed = zIndexReversed;
      return _this;
    }
    Geometry2.prototype.position = function(cfg) {
      var positionCfg = cfg;
      if (!is_plain_object_default(cfg)) {
        positionCfg = {
          fields: parseFields(cfg)
        };
      }
      var fields = get_default(positionCfg, "fields");
      if (fields.length === 1) {
        fields.unshift("1");
        set_default(positionCfg, "fields", fields);
      }
      set_default(this.attributeOption, "position", positionCfg);
      return this;
    };
    Geometry2.prototype.color = function(field, cfg) {
      this.createAttrOption("color", field, cfg);
      return this;
    };
    Geometry2.prototype.shape = function(field, cfg) {
      this.createAttrOption("shape", field, cfg);
      return this;
    };
    Geometry2.prototype.size = function(field, cfg) {
      this.createAttrOption("size", field, cfg);
      return this;
    };
    Geometry2.prototype.adjust = function(adjustCfg) {
      var adjusts = adjustCfg;
      if (is_string_default(adjustCfg) || is_plain_object_default(adjustCfg)) {
        adjusts = [adjustCfg];
      }
      each_default(adjusts, function(adjust, index) {
        if (!is_object_default(adjust)) {
          adjusts[index] = { type: adjust };
        }
      });
      this.adjustOption = adjusts;
      return this;
    };
    Geometry2.prototype.style = function(field, styleFunc) {
      if (is_string_default(field)) {
        var fields = parseFields(field);
        this.styleOption = {
          fields,
          callback: styleFunc
        };
      } else {
        var _a4 = field, fields = _a4.fields, callback = _a4.callback, cfg = _a4.cfg;
        if (fields || callback || cfg) {
          this.styleOption = field;
        } else {
          this.styleOption = {
            cfg: field
          };
        }
      }
      return this;
    };
    Geometry2.prototype.tooltip = function(field, cfg) {
      if (is_string_default(field)) {
        var fields = parseFields(field);
        this.tooltipOption = {
          fields,
          callback: cfg
        };
      } else {
        this.tooltipOption = field;
      }
      return this;
    };
    Geometry2.prototype.animate = function(cfg) {
      this.animateOption = cfg;
      return this;
    };
    Geometry2.prototype.label = function(field, secondParam, thirdParam) {
      if (is_string_default(field)) {
        var labelOption = {};
        var fields = parseFields(field);
        labelOption.fields = fields;
        if (is_function_default(secondParam)) {
          labelOption.callback = secondParam;
        } else if (is_plain_object_default(secondParam)) {
          labelOption.cfg = secondParam;
        }
        if (thirdParam) {
          labelOption.cfg = thirdParam;
        }
        this.labelOption = labelOption;
      } else {
        this.labelOption = field;
      }
      return this;
    };
    Geometry2.prototype.state = function(cfg) {
      this.stateOption = cfg;
      return this;
    };
    Geometry2.prototype.customInfo = function(cfg) {
      this.customOption = cfg;
      return this;
    };
    Geometry2.prototype.init = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(this.data);
      this.adjustScale();
    };
    Geometry2.prototype.update = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      var data = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
      var _a4 = this, attributeOption = _a4.attributeOption, lastAttributeOption = _a4.lastAttributeOption;
      if (!is_equal_default(attributeOption, lastAttributeOption)) {
        this.init(cfg);
      } else if (data && (isDataChanged || !is_equal_default(data, this.data))) {
        this.setCfg(cfg);
        this.initAttributes();
        this.processData(data);
      } else {
        this.setCfg(cfg);
      }
      this.adjustScale();
      this.isCoordinateChanged = isCoordinateChanged;
    };
    Geometry2.prototype.paint = function(isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      if (this.animateOption) {
        this.animateOption = deep_mix_default({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
      }
      this.defaultSize = void 0;
      this.elementsMap = {};
      this.elements = [];
      var offscreenGroup = this.getOffscreenGroup();
      offscreenGroup.clear();
      var beforeMappingData = this.beforeMappingData;
      var dataArray = this.beforeMapping(beforeMappingData);
      this.dataArray = new Array(dataArray.length);
      for (var i = 0; i < dataArray.length; i++) {
        var data = dataArray[i];
        this.dataArray[i] = this.mapping(data);
      }
      this.updateElements(this.dataArray, isUpdate);
      this.lastElementsMap = this.elementsMap;
      if (this.canDoGroupAnimation(isUpdate)) {
        var container = this.container;
        var type = this.type;
        var coordinate = this.coordinate;
        var animateCfg = get_default(this.animateOption, "appear");
        var yScale = this.getYScale();
        var yMinPoint = coordinate.convert({
          x: 0,
          y: yScale.scale(this.getYMinValue())
        });
        doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);
      }
      if (this.labelOption) {
        this.renderLabels(flatten_default(this.dataArray), isUpdate);
      }
      this.lastAttributeOption = __assign({}, this.attributeOption);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Geometry2.prototype.clear = function() {
      var _a4 = this, container = _a4.container, geometryLabel = _a4.geometryLabel, offscreenGroup = _a4.offscreenGroup;
      if (container) {
        container.clear();
      }
      if (geometryLabel) {
        geometryLabel.clear();
      }
      if (offscreenGroup) {
        offscreenGroup.clear();
      }
      this.scaleDefs = void 0;
      this.attributes = {};
      this.scales = {};
      this.elementsMap = {};
      this.lastElementsMap = {};
      this.elements = [];
      this.adjusts = {};
      this.dataArray = null;
      this.beforeMappingData = null;
      this.lastAttributeOption = void 0;
      this.defaultSize = void 0;
      this.idFields = [];
      this.groupScales = void 0;
      this.hasSorted = false;
      this.isCoordinateChanged = false;
    };
    Geometry2.prototype.destroy = function() {
      this.clear();
      var container = this.container;
      container.remove(true);
      if (this.offscreenGroup) {
        this.offscreenGroup.remove(true);
        this.offscreenGroup = null;
      }
      if (this.geometryLabel) {
        this.geometryLabel.destroy();
        this.geometryLabel = null;
      }
      this.theme = void 0;
      this.shapeFactory = void 0;
      _super.prototype.destroy.call(this);
    };
    Geometry2.prototype.getGroupScales = function() {
      return this.groupScales;
    };
    Geometry2.prototype.getAttribute = function(name) {
      return this.attributes[name];
    };
    Geometry2.prototype.getXScale = function() {
      return this.getAttribute("position").scales[0];
    };
    Geometry2.prototype.getYScale = function() {
      return this.getAttribute("position").scales[1];
    };
    Geometry2.prototype.getGroupAttributes = function() {
      var rst = [];
      each_default(this.attributes, function(attr) {
        if (GROUP_ATTRS.includes(attr.type)) {
          rst.push(attr);
        }
      });
      return rst;
    };
    Geometry2.prototype.getDefaultValue = function(attrName) {
      var value;
      var attr = this.getAttribute(attrName);
      if (attr && is_empty_default(attr.scales)) {
        value = attr.values[0];
      }
      return value;
    };
    Geometry2.prototype.getAttributeValues = function(attr, obj) {
      var params = [];
      var scales = attr.scales;
      for (var index = 0, length_1 = scales.length; index < length_1; index++) {
        var scale5 = scales[index];
        var field = scale5.field;
        if (scale5.isIdentity) {
          params.push(scale5.values);
        } else {
          params.push(obj[field]);
        }
      }
      return attr.mapping.apply(attr, params);
    };
    Geometry2.prototype.getAdjust = function(adjustType) {
      return this.adjusts[adjustType];
    };
    Geometry2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    Geometry2.prototype.getData = function() {
      return this.data;
    };
    Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
      var shapeFactory = this.getShapeFactory();
      return shapeFactory.getMarker(shapeName, cfg);
    };
    Geometry2.prototype.getElementsBy = function(condition) {
      return this.elements.filter(function(element) {
        return condition(element);
      });
    };
    Geometry2.prototype.getElements = function() {
      return this.elements;
    };
    Geometry2.prototype.getElementId = function(data) {
      data = is_array_default(data) ? data[0] : data;
      var originData = data[FIELD_ORIGIN];
      if (this.idFields.length) {
        var elementId = originData[this.idFields[0]];
        for (var index = 1; index < this.idFields.length; index++) {
          elementId += "-" + originData[this.idFields[index]];
        }
        return elementId;
      }
      var type = this.type;
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field || "x";
      var yField = yScale.field || "y";
      var yVal = originData[yField];
      var xVal;
      if (xScale.type === "identity") {
        xVal = xScale.values[0];
      } else {
        xVal = originData[xField];
      }
      var id;
      if (type === "interval" || type === "schema") {
        id = "" + xVal;
      } else if (type === "line" || type === "area" || type === "path") {
        id = type;
      } else {
        id = xVal + "-" + yVal;
      }
      var groupScales = this.groupScales;
      if (is_empty_default(groupScales)) {
        groupScales = get_default(this.getAttribute("color"), "scales", []);
      }
      for (var index = 0, length_2 = groupScales.length; index < length_2; index++) {
        var groupScale = groupScales[index];
        var field = groupScale.field;
        id = id + "-" + originData[field];
      }
      var dodgeAdjust = this.getAdjust("dodge");
      if (dodgeAdjust) {
        var dodgeBy = dodgeAdjust.dodgeBy;
        if (dodgeBy) {
          id = id + "-" + originData[dodgeBy];
        }
      }
      if (this.getAdjust("jitter")) {
        id = id + "-" + data.x + "-" + data.y;
      }
      return id;
    };
    Geometry2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = new Map();
      var _a4 = this, attributeOption = _a4.attributeOption, labelOption = _a4.labelOption, tooltipOption = _a4.tooltipOption;
      for (var attributeType in attributeOption) {
        if (attributeOption.hasOwnProperty(attributeType)) {
          var eachOpt = attributeOption[attributeType];
          if (eachOpt.fields) {
            uniq2(eachOpt.fields, fields, tmpMap);
          } else if (eachOpt.values) {
            uniq2(eachOpt.values, fields, tmpMap);
          }
        }
      }
      if (labelOption && labelOption.fields) {
        uniq2(labelOption.fields, fields, tmpMap);
      }
      if (is_object_default(tooltipOption) && tooltipOption.fields) {
        uniq2(tooltipOption.fields, fields, tmpMap);
      }
      return fields;
    };
    Geometry2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var elements = this.elements;
      for (var index = 0, length_3 = elements.length; index < length_3; index++) {
        var element = elements[index];
        element.changeVisible(visible);
      }
      if (visible) {
        if (this.container) {
          this.container.show();
        }
        if (this.labelsContainer) {
          this.labelsContainer.show();
        }
      } else {
        if (this.container) {
          this.container.hide();
        }
        if (this.labelsContainer) {
          this.labelsContainer.hide();
        }
      }
    };
    Geometry2.prototype.getFields = function() {
      var uniqMap = new Map();
      var fields = [];
      Object.values(this.attributeOption).forEach(function(cfg) {
        var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
        fs.forEach(function(f) {
          if (!uniqMap.has(f)) {
            fields.push(f);
          }
          uniqMap.set(f, true);
        });
      }, []);
      return fields;
    };
    Geometry2.prototype.getGroupFields = function() {
      var groupFields = [];
      var tmpMap = new Map();
      for (var index = 0, length_4 = GROUP_ATTRS.length; index < length_4; index++) {
        var attributeName = GROUP_ATTRS[index];
        var cfg = this.attributeOption[attributeName];
        if (cfg && cfg.fields) {
          uniq2(cfg.fields, groupFields, tmpMap);
        }
      }
      return groupFields;
    };
    Geometry2.prototype.getXYFields = function() {
      var _a4 = this.attributeOption.position.fields, x = _a4[0], y = _a4[1];
      return [x, y];
    };
    Geometry2.prototype.getXField = function() {
      return get_default(this.getXYFields(), [0]);
    };
    Geometry2.prototype.getYField = function() {
      return get_default(this.getXYFields(), [1]);
    };
    Geometry2.prototype.getShapes = function() {
      return this.elements.map(function(element) {
        return element.shape;
      });
    };
    Geometry2.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Geometry2.prototype.sort = function(mappingArray) {
      if (!this.hasSorted) {
        var xScale_1 = this.getXScale();
        var xField_1 = xScale_1.field;
        for (var index = 0; index < mappingArray.length; index++) {
          var itemArr = mappingArray[index];
          itemArr.sort(function(obj1, obj2) {
            return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
          });
        }
      }
      this.hasSorted = true;
    };
    Geometry2.prototype.adjustScale = function() {
      var yScale = this.getYScale();
      if (yScale && this.getAdjust("stack")) {
        this.updateStackRange(yScale, this.beforeMappingData);
      }
    };
    Geometry2.prototype.getShapeFactory = function() {
      var shapeType = this.shapeType;
      if (!getShapeFactory(shapeType)) {
        return;
      }
      if (!this.shapeFactory) {
        this.shapeFactory = clone_default(getShapeFactory(shapeType));
      }
      this.shapeFactory.coordinate = this.coordinate;
      this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
      return this.shapeFactory;
    };
    Geometry2.prototype.createShapePointsCfg = function(obj) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var x = this.normalizeValues(obj[xScale.field], xScale);
      var y;
      if (yScale) {
        y = this.normalizeValues(obj[yScale.field], yScale);
      } else {
        y = obj.y ? obj.y : 0.1;
      }
      return {
        x,
        y,
        y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
      };
    };
    Geometry2.prototype.createElement = function(mappingDatum, index, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var container = this.container;
      var shapeCfg = this.getDrawCfg(mappingDatum);
      var shapeFactory = this.getShapeFactory();
      var element = new element_default3({
        shapeFactory,
        container,
        offscreenGroup: this.getOffscreenGroup(),
        elementIndex: index
      });
      element.animate = this.animateOption;
      element.geometry = this;
      element.draw(shapeCfg, isUpdate);
      return element;
    };
    Geometry2.prototype.getDrawCfg = function(mappingDatum) {
      var originData = mappingDatum[FIELD_ORIGIN];
      var cfg = {
        mappingData: mappingDatum,
        data: originData,
        x: mappingDatum.x,
        y: mappingDatum.y,
        color: mappingDatum.color,
        size: mappingDatum.size,
        isInCircle: this.coordinate.isPolar,
        customInfo: this.customOption
      };
      var shapeName = mappingDatum.shape;
      if (!shapeName && this.getShapeFactory()) {
        shapeName = this.getShapeFactory().defaultShapeType;
      }
      cfg.shape = shapeName;
      var theme = this.theme.geometries[this.shapeType];
      cfg.defaultStyle = get_default(theme, [shapeName, "default"], {}).style;
      if (!cfg.defaultStyle && this.getShapeFactory()) {
        cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);
      }
      var styleOption = this.styleOption;
      if (styleOption) {
        cfg.style = this.getStyleCfg(styleOption, originData);
      }
      if (this.generatePoints) {
        cfg.points = mappingDatum.points;
        cfg.nextPoints = mappingDatum.nextPoints;
      }
      return cfg;
    };
    Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyDatum = new Map();
      var keys2 = [];
      var keyIndex = new Map();
      var index = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        for (var j = 0; j < mappingData.length; j++) {
          var mappingDatum = mappingData[j];
          var key = this.getElementId(mappingDatum);
          var finalKey = keyDatum.has(key) ? key + "-" + i + "-" + j : key;
          keys2.push(finalKey);
          keyDatum.set(finalKey, mappingDatum);
          keyIndex.set(finalKey, index);
          index++;
        }
      }
      this.elements = new Array(index);
      var _a4 = diff(this.lastElementsMap, keys2), added = _a4.added, updated = _a4.updated, removed = _a4.removed;
      for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
        var key = added_1[_i];
        var mappingDatum = keyDatum.get(key);
        var i = keyIndex.get(key);
        var element = this.createElement(mappingDatum, i, isUpdate);
        this.elements[i] = element;
        this.elementsMap[key] = element;
        if (element.shape) {
          element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
        }
      }
      for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
        var key = updated_1[_b];
        var element = this.lastElementsMap[key];
        var mappingDatum = keyDatum.get(key);
        var currentShapeCfg = this.getDrawCfg(mappingDatum);
        var preShapeCfg = element.getModel();
        var i = keyIndex.get(key);
        if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
          element.animate = this.animateOption;
          element.update(currentShapeCfg);
        }
        this.elements[i] = element;
        this.elementsMap[key] = element;
        if (element.shape) {
          element.shape.setZIndex(this.zIndexReversed ? this.elements.length - i : i);
        }
      }
      for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
        var key = removed_1[_c];
        var element = this.lastElementsMap[key];
        element.animate = this.animateOption;
        element.destroy();
      }
    };
    Geometry2.prototype.getLabelType = function() {
      var _a4 = this, labelOption = _a4.labelOption, coordinate = _a4.coordinate, type = _a4.type;
      var coordinateType = coordinate.type, isTransposed = coordinate.isTransposed;
      var labelType = get_default(labelOption, ["cfg", "type"]);
      if (!labelType) {
        if (coordinateType === "polar") {
          labelType = isTransposed ? "pie" : "polar";
        } else if (coordinateType === "theta") {
          labelType = "pie";
        } else if (type === "interval" || type === "polygon") {
          labelType = "interval";
        } else {
          labelType = "base";
        }
      }
      return labelType;
    };
    Geometry2.prototype.getYMinValue = function() {
      var yScale = this.getYScale();
      var min7 = yScale.min, max7 = yScale.max;
      var value;
      if (min7 >= 0) {
        value = min7;
      } else if (max7 <= 0) {
        value = max7;
      } else {
        value = 0;
      }
      return value;
    };
    Geometry2.prototype.createAttrOption = function(attrName, field, cfg) {
      if (is_nil_default(field) || is_object_default(field)) {
        if (is_object_default(field) && is_equal_default(Object.keys(field), ["values"])) {
          set_default(this.attributeOption, attrName, {
            fields: field.values
          });
        } else {
          set_default(this.attributeOption, attrName, field);
        }
      } else {
        var attrCfg = {};
        if (is_number_default(field)) {
          attrCfg.values = [field];
        } else {
          attrCfg.fields = parseFields(field);
        }
        if (cfg) {
          if (is_function_default(cfg)) {
            attrCfg.callback = cfg;
          } else {
            attrCfg.values = cfg;
          }
        }
        set_default(this.attributeOption, attrName, attrCfg);
      }
    };
    Geometry2.prototype.initAttributes = function() {
      var _this = this;
      var _a4 = this, attributes = _a4.attributes, attributeOption = _a4.attributeOption, theme = _a4.theme, shapeType = _a4.shapeType;
      this.groupScales = [];
      var tmpMap = {};
      var _loop_1 = function(attrType2) {
        if (attributeOption.hasOwnProperty(attrType2)) {
          var option = attributeOption[attrType2];
          if (!option) {
            return { value: void 0 };
          }
          var attrCfg = __assign({}, option);
          var callback = attrCfg.callback, values2 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
          var scales = fields.map(function(field) {
            var scale5 = _this.scales[field];
            if (scale5.isCategory && !tmpMap[field] && GROUP_ATTRS.includes(attrType2)) {
              _this.groupScales.push(scale5);
              tmpMap[field] = true;
            }
            return scale5;
          });
          attrCfg.scales = scales;
          if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
            attrCfg.values = scales[0].values;
          } else if (!callback && !values2) {
            if (attrType2 === "size") {
              attrCfg.values = theme.sizes;
            } else if (attrType2 === "shape") {
              attrCfg.values = theme.shapes[shapeType] || [];
            } else if (attrType2 === "color") {
              if (scales.length) {
                attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;
              } else {
                attrCfg.values = theme.colors10;
              }
            }
          }
          var AttributeCtor = getAttribute(attrType2);
          attributes[attrType2] = new AttributeCtor(attrCfg);
        }
      };
      for (var attrType in attributeOption) {
        var state_1 = _loop_1(attrType);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    };
    Geometry2.prototype.processData = function(data) {
      this.hasSorted = false;
      var scales = this.getAttribute("position").scales;
      var categoryScales = scales.filter(function(scale6) {
        return scale6.isCategory;
      });
      var groupedArray = this.groupData(data);
      var beforeAdjust = [];
      for (var i = 0, len3 = groupedArray.length; i < len3; i++) {
        var subData = groupedArray[i];
        var arr = [];
        for (var j = 0, subLen = subData.length; j < subLen; j++) {
          var originData = subData[j];
          var item = {};
          for (var k in originData) {
            item[k] = originData[k];
          }
          item[FIELD_ORIGIN] = originData;
          for (var _i = 0, categoryScales_1 = categoryScales; _i < categoryScales_1.length; _i++) {
            var scale5 = categoryScales_1[_i];
            var field = scale5.field;
            item[field] = scale5.translate(item[field]);
          }
          arr.push(item);
        }
        beforeAdjust.push(arr);
      }
      var dataArray = this.adjustData(beforeAdjust);
      this.beforeMappingData = dataArray;
      return dataArray;
    };
    Geometry2.prototype.adjustData = function(dataArray) {
      var adjustOption = this.adjustOption;
      var _a4 = this, intervalPadding = _a4.intervalPadding, dodgePadding = _a4.dodgePadding, theme = _a4.theme;
      var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;
      var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;
      var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;
      var result = dataArray;
      if (adjustOption) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xField = xScale.field;
        var yField = yScale ? yScale.field : null;
        var xDimensionLength = getXDimensionLength(this.coordinate);
        var groupNum = xScale.values.length;
        var sizeAttr = this.getAttribute("size");
        var defaultSize = void 0;
        if (sizeAttr) {
          defaultSize = sizeAttr.values[0];
        }
        for (var i = 0, len3 = adjustOption.length; i < len3; i++) {
          var adjust = adjustOption[i];
          var adjustCfg = __assign({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust);
          var type = adjust.type;
          if (type === "dodge") {
            var adjustNames = [];
            if (xScale.isCategory || xScale.type === "identity") {
              adjustNames.push("x");
            } else if (!yScale) {
              adjustNames.push("y");
            } else {
              throw new Error("dodge is not support linear attribute, please use category attribute!");
            }
            adjustCfg.adjustNames = adjustNames;
            adjustCfg.dodgeRatio = columnWidthRatio;
          } else if (type === "stack") {
            var coordinate = this.coordinate;
            if (!yScale) {
              adjustCfg.height = coordinate.getHeight();
              var size3 = this.getDefaultValue("size") || 3;
              adjustCfg.size = size3;
            }
            if (!coordinate.isTransposed && is_nil_default(adjustCfg.reverseOrder)) {
              adjustCfg.reverseOrder = true;
            }
          }
          var adjustCtor = getAdjust(type);
          var adjustInstance = new adjustCtor(adjustCfg);
          result = adjustInstance.process(result);
          this.adjusts[type] = adjustInstance;
        }
      }
      return result;
    };
    Geometry2.prototype.groupData = function(data) {
      var groupScales = this.getGroupScales();
      var scaleDefs = this.scaleDefs;
      var appendConditions = {};
      var groupFields = [];
      for (var index = 0; index < groupScales.length; index++) {
        var scale5 = groupScales[index];
        var field = scale5.field;
        groupFields.push(field);
        if (get_default(scaleDefs, [field, "values"])) {
          appendConditions[field] = scaleDefs[field].values;
        }
      }
      return group(data, groupFields, appendConditions);
    };
    Geometry2.prototype.updateStackRange = function(scale5, dataArray) {
      var mergeArray = flatten_default(dataArray);
      var field = scale5.field;
      var min7 = scale5.min;
      var max7 = scale5.max;
      for (var index = 0; index < mergeArray.length; index++) {
        var obj = mergeArray[index];
        var tmpMin = Math.min.apply(null, obj[field]);
        var tmpMax = Math.max.apply(null, obj[field]);
        if (tmpMin < min7) {
          min7 = tmpMin;
        }
        if (tmpMax > max7) {
          max7 = tmpMax;
        }
      }
      var scaleDefs = this.scaleDefs;
      var cfg = {};
      if (min7 < scale5.min && !get_default(scaleDefs, [field, "min"])) {
        cfg.min = min7;
      }
      if (max7 > scale5.max && !get_default(scaleDefs, [field, "max"])) {
        cfg.max = max7;
      }
      scale5.change(cfg);
    };
    Geometry2.prototype.beforeMapping = function(beforeMappingData) {
      var source = beforeMappingData;
      if (this.sortable) {
        this.sort(source);
      }
      if (this.generatePoints) {
        for (var index = 0, length_5 = source.length; index < length_5; index++) {
          var currentData = source[index];
          this.generateShapePoints(currentData);
          var nextData = source[index + 1];
          if (nextData) {
            this.generateShapePoints(nextData);
            currentData[0].nextPoints = nextData[0].points;
          }
        }
      }
      return source;
    };
    Geometry2.prototype.generateShapePoints = function(data) {
      var shapeFactory = this.getShapeFactory();
      var shapeAttr = this.getAttribute("shape");
      for (var index = 0; index < data.length; index++) {
        var obj = data[index];
        var cfg = this.createShapePointsCfg(obj);
        var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
        var points = shapeFactory.getShapePoints(shape, cfg);
        obj.points = points;
      }
    };
    Geometry2.prototype.normalizeValues = function(values2, scale5) {
      var rst = [];
      if (is_array_default(values2)) {
        for (var index = 0; index < values2.length; index++) {
          var value = values2[index];
          rst.push(scale5.scale(value));
        }
      } else {
        rst = scale5.scale(values2);
      }
      return rst;
    };
    Geometry2.prototype.mapping = function(data) {
      var attributes = this.attributes;
      var mappingData = [];
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var newRecord = {
          _origin: record[FIELD_ORIGIN],
          points: record.points,
          nextPoints: record.nextPoints
        };
        for (var k in attributes) {
          if (attributes.hasOwnProperty(k)) {
            var attr = attributes[k];
            var names = attr.names;
            var values2 = this.getAttributeValues(attr, record);
            if (names.length > 1) {
              for (var j = 0; j < values2.length; j += 1) {
                var val = values2[j];
                var name_1 = names[j];
                newRecord[name_1] = is_array_default(val) && val.length === 1 ? val[0] : val;
              }
            } else {
              newRecord[names[0]] = values2.length === 1 ? values2[0] : values2;
            }
          }
        }
        this.convertPoint(newRecord);
        mappingData.push(newRecord);
      }
      return mappingData;
    };
    Geometry2.prototype.convertPoint = function(mappingRecord) {
      var x = mappingRecord.x, y = mappingRecord.y;
      var rstX;
      var rstY;
      var obj;
      var coordinate = this.coordinate;
      if (is_array_default(x) && is_array_default(y)) {
        rstX = [];
        rstY = [];
        for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
          obj = coordinate.convert({
            x: x[i],
            y: y[j]
          });
          rstX.push(obj.x);
          rstY.push(obj.y);
        }
      } else if (is_array_default(y)) {
        rstY = [];
        for (var index = 0; index < y.length; index++) {
          var yVal = y[index];
          obj = coordinate.convert({
            x,
            y: yVal
          });
          if (rstX && rstX !== obj.x) {
            if (!is_array_default(rstX)) {
              rstX = [rstX];
            }
            rstX.push(obj.x);
          } else {
            rstX = obj.x;
          }
          rstY.push(obj.y);
        }
      } else if (is_array_default(x)) {
        rstX = [];
        for (var index = 0; index < x.length; index++) {
          var xVal = x[index];
          obj = coordinate.convert({
            x: xVal,
            y
          });
          if (rstY && rstY !== obj.y) {
            if (!is_array_default(rstY)) {
              rstY = [rstY];
            }
            rstY.push(obj.y);
          } else {
            rstY = obj.y;
          }
          rstX.push(obj.x);
        }
      } else {
        var point = coordinate.convert({
          x,
          y
        });
        rstX = point.x;
        rstY = point.y;
      }
      mappingRecord.x = rstX;
      mappingRecord.y = rstY;
    };
    Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
      var _a4 = styleOption.fields, fields = _a4 === void 0 ? [] : _a4, callback = styleOption.callback, cfg = styleOption.cfg;
      if (cfg) {
        return cfg;
      }
      var params = fields.map(function(field) {
        return originData[field];
      });
      return callback.apply(void 0, params);
    };
    Geometry2.prototype.setCfg = function(cfg) {
      var _this = this;
      var coordinate = cfg.coordinate, data = cfg.data, theme = cfg.theme, scaleDefs = cfg.scaleDefs;
      if (coordinate) {
        this.coordinate = coordinate;
      }
      if (data) {
        this.data = data;
      }
      if (scaleDefs) {
        this.scaleDefs = scaleDefs;
        this.idFields = [];
        each_default(scaleDefs, function(scaleDef, field) {
          if (scaleDef && scaleDef.key) {
            _this.idFields.push(field);
          }
        });
      }
      if (theme) {
        this.theme = this.userTheme ? deep_mix_default({}, theme, this.userTheme) : theme;
      }
    };
    Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var geometryLabel = this.geometryLabel;
      if (!geometryLabel) {
        var labelType = this.getLabelType();
        var GeometryLabelsCtor = getGeometryLabel(labelType);
        geometryLabel = new GeometryLabelsCtor(this);
        this.geometryLabel = geometryLabel;
      }
      geometryLabel.render(mappingArray, isUpdate);
      var labelsMap = geometryLabel.labelsRenderer.shapesMap;
      each_default(this.elementsMap, function(element, id) {
        var labels = filterLabelsById(id, labelsMap);
        if (labels.length) {
          element.labelShape = labels;
          for (var i = 0; i < labels.length; i++) {
            var label = labels[i];
            var labelChildren = label.getChildren();
            for (var j = 0; j < labelChildren.length; j++) {
              var child = labelChildren[j];
              child.cfg.name = ["element", "label"];
              child.cfg.element = element;
            }
          }
        }
      });
    };
    Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
      return !isUpdate && this.animateOption && (get_default(this.animateOption, "appear") === void 0 || get_default(this.animateOption, "appear") && get_default(this.animateOption, ["appear", "animation"]) === void 0);
    };
    return Geometry2;
  }(base_default);
  var base_default14 = Geometry;

  // node_modules/@antv/g2/esm/util/transform.js
  var transform4 = ext_exports.transform;
  function translate2(element, x, y) {
    var matrix = transform4(element.getMatrix(), [["t", x, y]]);
    element.setMatrix(matrix);
  }
  function getRotateMatrix(element, rotateRadian) {
    var _a4 = element.attr(), x = _a4.x, y = _a4.y;
    var matrix = transform4(element.getMatrix(), [
      ["t", -x, -y],
      ["r", rotateRadian],
      ["t", x, y]
    ]);
    return matrix;
  }
  function rotate4(element, rotateRadian) {
    var matrix = getRotateMatrix(element, rotateRadian);
    element.setMatrix(matrix);
  }

  // node_modules/@antv/g2/esm/geometry/label/util/index.js
  function findLabelTextShape(label) {
    return label.find(function(el) {
      return el.get("type") === "text";
    });
  }
  function getlLabelBackgroundInfo(labelGroup, labelItem, padding) {
    if (padding === void 0) {
      padding = [0, 0, 0, 0];
    }
    var content = labelGroup.getChildren()[0];
    if (content) {
      var labelShape = content.clone();
      if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
        rotate4(labelShape, -labelItem.rotate);
      }
      var _a4 = labelShape.getCanvasBBox(), x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
      labelShape.destroy();
      var boxPadding = padding;
      if (is_nil_default(boxPadding)) {
        boxPadding = [2, 2, 2, 2];
      } else if (is_number_default(boxPadding)) {
        boxPadding = new Array(4).fill(boxPadding);
      }
      return {
        x: x - boxPadding[3],
        y: y - boxPadding[0],
        width: width + boxPadding[1] + boxPadding[3],
        height: height + boxPadding[0] + boxPadding[2],
        rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
      };
    }
  }
  function getOverlapArea(a, b, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
  }
  function checkShapeOverlap(cur, dones) {
    var box2 = cur.getBBox();
    return some_default(dones, function(done) {
      var target = done.getBBox();
      return getOverlapArea(box2, target, 2) > 0;
    });
  }

  // node_modules/@antv/g2/esm/component/update-label.js
  function updateLabel(fromShape, toShape, cfg) {
    var data = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate = cfg.coordinate;
    var updateAnimateCfg = get_default(animateCfg, "update");
    fromShape.set("data", data);
    fromShape.set("origin", origin);
    fromShape.set("animateCfg", animateCfg);
    fromShape.set("coordinate", coordinate);
    fromShape.set("visible", toShape.get("visible"));
    fromShape.getChildren().forEach(function(fromChild, idx) {
      var toChild = toShape.getChildByIndex(idx);
      if (!toChild) {
        fromShape.removeChild(fromChild);
        fromChild.remove(true);
      } else {
        fromChild.set("data", data);
        fromChild.set("origin", origin);
        fromChild.set("animateCfg", animateCfg);
        fromChild.set("coordinate", coordinate);
        var newAttrs = getReplaceAttrs(fromChild, toChild);
        if (updateAnimateCfg) {
          doAnimate(fromChild, updateAnimateCfg, {
            toAttrs: newAttrs,
            coordinate
          });
        } else {
          fromChild.attr(newAttrs);
        }
        if (toChild.isGroup()) {
          updateLabel(fromChild, toChild, cfg);
        }
      }
    });
    each_default(toShape.getChildren(), function(child, idx) {
      if (idx >= fromShape.getCount()) {
        if (!child.destroyed) {
          fromShape.add(child);
        }
      }
    });
  }

  // node_modules/@antv/g2/esm/component/labels.js
  var Labels = function() {
    function Labels2(cfg) {
      this.shapesMap = {};
      this.lastShapesMap = {};
      var layout = cfg.layout, container = cfg.container;
      this.layout = layout;
      this.container = container;
    }
    Labels2.prototype.render = function(items, shapes, isUpdate) {
      var _this = this;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.shapesMap = {};
      var container = this.container;
      var offscreenGroup = this.createOffscreenGroup();
      if (items.length) {
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
          var item = items_1[_i];
          if (item) {
            this.renderLabel(item, offscreenGroup);
          }
        }
        this.doLayout(items, shapes);
        this.renderLabelLine(items);
        this.renderLabelBackground(items);
        this.adjustLabel(items);
      }
      var lastShapesMap = this.lastShapesMap;
      var shapesMap = this.shapesMap;
      each_default(shapesMap, function(shape, id) {
        if (shape.destroyed) {
          delete shapesMap[id];
        } else {
          if (lastShapesMap[id]) {
            var data = shape.get("data");
            var origin_1 = shape.get("origin");
            var coordinate = shape.get("coordinate");
            var currentAnimateCfg = shape.get("animateCfg");
            var currentShape = lastShapesMap[id];
            updateLabel(currentShape, shapesMap[id], {
              data,
              origin: origin_1,
              animateCfg: currentAnimateCfg,
              coordinate
            });
            _this.shapesMap[id] = currentShape;
          } else {
            container.add(shape);
            var animateCfg = get_default(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
            if (animateCfg) {
              doAnimate(shape, animateCfg, {
                toAttrs: __assign({}, shape.attr()),
                coordinate: shape.get("coordinate")
              });
            }
          }
          delete lastShapesMap[id];
        }
      });
      each_default(lastShapesMap, function(deleteShape) {
        var animateCfg = get_default(deleteShape.get("animateCfg"), "leave");
        if (animateCfg) {
          doAnimate(deleteShape, animateCfg, {
            toAttrs: null,
            coordinate: deleteShape.get("coordinate")
          });
        } else {
          deleteShape.remove(true);
        }
      });
      this.lastShapesMap = shapesMap;
      offscreenGroup.destroy();
    };
    Labels2.prototype.clear = function() {
      this.container.clear();
      this.shapesMap = {};
      this.lastShapesMap = {};
    };
    Labels2.prototype.destroy = function() {
      this.container.destroy();
      this.shapesMap = null;
      this.lastShapesMap = null;
    };
    Labels2.prototype.renderLabel = function(cfg, container) {
      var id = cfg.id, elementId = cfg.elementId, data = cfg.data, mappingData = cfg.mappingData, coordinate = cfg.coordinate, animate = cfg.animate, content = cfg.content;
      var shapeAppendCfg = {
        id,
        elementId,
        data,
        origin: __assign(__assign({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
        coordinate
      };
      var labelGroup = container.addGroup(__assign({
        name: "label",
        animateCfg: this.animate === false || animate === null || animate === false ? false : deep_mix_default({}, this.animate, animate)
      }, shapeAppendCfg));
      var labelShape;
      if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
        var _a4 = content.getCanvasBBox(), width = _a4.width, height = _a4.height;
        var textAlign = get_default(cfg, "textAlign", "left");
        var x = cfg.x;
        var y = cfg.y - height / 2;
        if (textAlign === "center") {
          x = x - width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          x = x - width;
        }
        translate2(content, x, y);
        labelShape = content;
        labelGroup.add(content);
      } else {
        var fill4 = get_default(cfg, ["style", "fill"]);
        labelShape = labelGroup.addShape("text", __assign({ attrs: __assign(__assign({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get_default(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: is_null_default(fill4) ? cfg.color : fill4 }) }, shapeAppendCfg));
      }
      if (cfg.rotate) {
        rotate4(labelShape, cfg.rotate);
      }
      this.shapesMap[id] = labelGroup;
    };
    Labels2.prototype.doLayout = function(items, shapes) {
      var _this = this;
      if (this.layout) {
        var layouts = is_array_default(this.layout) ? this.layout : [this.layout];
        each_default(layouts, function(layout) {
          var layoutFn = getGeometryLabelLayout(get_default(layout, "type", ""));
          if (layoutFn) {
            var labelShapes_1 = [];
            var geometryShapes_1 = [];
            each_default(_this.shapesMap, function(labelShape, id) {
              labelShapes_1.push(labelShape);
              geometryShapes_1.push(shapes[labelShape.get("elementId")]);
            });
            layoutFn(items, labelShapes_1, geometryShapes_1, _this.region, layout.cfg);
          }
        });
      }
    };
    Labels2.prototype.renderLabelLine = function(labelItems) {
      var _this = this;
      each_default(labelItems, function(labelItem) {
        var coordinate = get_default(labelItem, "coordinate");
        if (!labelItem || !coordinate) {
          return;
        }
        var center = coordinate.getCenter();
        var radius = coordinate.getRadius();
        if (!labelItem.labelLine) {
          return;
        }
        var labelLineCfg = get_default(labelItem, "labelLine", {});
        var id = labelItem.id;
        var path = labelLineCfg.path;
        if (!path) {
          var start = polarToCartesian(center.x, center.y, radius, labelItem.angle);
          path = [
            ["M", start.x, start.y],
            ["L", labelItem.x, labelItem.y]
          ];
        }
        var labelGroup = _this.shapesMap[id];
        if (!labelGroup.destroyed) {
          labelGroup.addShape("path", {
            capture: false,
            attrs: __assign({ path, stroke: labelItem.color ? labelItem.color : get_default(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
            id,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
        }
      });
    };
    Labels2.prototype.renderLabelBackground = function(labelItems) {
      var _this = this;
      each_default(labelItems, function(labelItem) {
        var coordinate = get_default(labelItem, "coordinate");
        var background = get_default(labelItem, "background");
        if (!background || !coordinate) {
          return;
        }
        var id = labelItem.id;
        var labelGroup = _this.shapesMap[id];
        if (!labelGroup.destroyed) {
          var labelContentShape = labelGroup.getChildren()[0];
          if (labelContentShape) {
            var _a4 = getlLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a4.rotation, box2 = __rest(_a4, ["rotation"]);
            var backgroundShape = labelGroup.addShape("rect", {
              attrs: __assign(__assign({}, box2), background.style || {}),
              id,
              origin: labelItem.mappingData,
              data: labelItem.data,
              coordinate: labelItem.coordinate
            });
            backgroundShape.setZIndex(-1);
            if (rotation) {
              var matrix = labelContentShape.getMatrix();
              backgroundShape.setMatrix(matrix);
            }
          }
        }
      });
    };
    Labels2.prototype.createOffscreenGroup = function() {
      var container = this.container;
      var GroupClass = container.getGroupBase();
      var newGroup = new GroupClass({});
      return newGroup;
    };
    Labels2.prototype.adjustLabel = function(items) {
      var _this = this;
      each_default(items, function(item) {
        if (item) {
          var id = item.id;
          var labelGroup = _this.shapesMap[id];
          if (!labelGroup.destroyed) {
            var labelShapes = labelGroup.findAll(function(ele) {
              return ele.get("type") !== "path";
            });
            each_default(labelShapes, function(labelShape) {
              if (labelShape) {
                if (item.offsetX) {
                  labelShape.attr("x", labelShape.attr("x") + item.offsetX);
                }
                if (item.offsetY) {
                  labelShape.attr("y", labelShape.attr("y") + item.offsetY);
                }
              }
            });
          }
        }
      });
    };
    return Labels2;
  }();
  var labels_default = Labels;

  // node_modules/@antv/g2/esm/geometry/label/base.js
  function avg(arr) {
    var sum5 = 0;
    each_default(arr, function(value) {
      sum5 += value;
    });
    return sum5 / arr.length;
  }
  var GeometryLabel = function() {
    function GeometryLabel2(geometry) {
      this.geometry = geometry;
    }
    GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
      var _this = this;
      var items = [];
      var labelCfgs = this.getLabelCfgs(mapppingArray);
      each_default(mapppingArray, function(mappingData, index) {
        var labelCfg = labelCfgs[index];
        if (!labelCfg || is_nil_default(mappingData.x) || is_nil_default(mappingData.y)) {
          items.push(null);
          return;
        }
        var labelContent = !is_array_default(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
        labelCfg.content = labelContent;
        var total = labelContent.length;
        each_default(labelContent, function(content, subIndex) {
          if (is_nil_default(content) || content === "") {
            items.push(null);
            return;
          }
          var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
          if (!item.textAlign) {
            item.textAlign = _this.getLabelAlign(item, subIndex, total);
          }
          if (item.offset <= 0) {
            item.labelLine = null;
          }
          items.push(item);
        });
      });
      return items;
    };
    GeometryLabel2.prototype.render = function(mapppingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var labelItems = this.getLabelItems(mapppingArray);
      var labelsRenderer = this.getLabelsRenderer();
      var shapes = this.getGeometryShapes();
      labelsRenderer.render(labelItems, shapes, isUpdate);
    };
    GeometryLabel2.prototype.clear = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.clear();
      }
    };
    GeometryLabel2.prototype.destroy = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.destroy();
      }
      this.labelsRenderer = null;
    };
    GeometryLabel2.prototype.getCoordinate = function() {
      return this.geometry.coordinate;
    };
    GeometryLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var geometry = this.geometry;
      var type = geometry.type, theme = geometry.theme;
      if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && !["line", "point", "path"].includes(type)) {
        return get_default(theme, "innerLabels", {});
      }
      return get_default(theme, "labels", {});
    };
    GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var type = geometry.type, theme = geometry.theme;
      var themedLabelCfg;
      if (type === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type)) {
        themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme.innerLabels, labelCfg);
      } else {
        themedLabelCfg = deep_mix_default({}, defaultLabelCfg, theme.labels, labelCfg);
      }
      return themedLabelCfg;
    };
    GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
    };
    GeometryLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate = this.getCoordinate();
      var vector = this.getOffsetVector(offset);
      return coordinate.isTransposed ? vector[0] : vector[1];
    };
    GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total) {
      var offset = labelCfg.offset;
      var coordinate = this.getCoordinate();
      var transposed = coordinate.isTransposed;
      var dim = transposed ? "x" : "y";
      var factor = transposed ? 1 : -1;
      var offsetPoint = {
        x: 0,
        y: 0
      };
      if (index > 0 || total === 1) {
        offsetPoint[dim] = offset * factor;
      } else {
        offsetPoint[dim] = offset * factor * -1;
      }
      return offsetPoint;
    };
    GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var coordinate = this.getCoordinate();
      var total = labelCfg.content.length;
      function getDimValue(value, idx, isAvg) {
        if (isAvg === void 0) {
          isAvg = false;
        }
        var v = value;
        if (is_array_default(v)) {
          if (labelCfg.content.length === 1) {
            if (isAvg) {
              v = avg(v);
            } else {
              if (v.length <= 2) {
                v = v[value.length - 1];
              } else {
                v = avg(v);
              }
            }
          } else {
            v = v[idx];
          }
        }
        return v;
      }
      var label = {
        content: labelCfg.content[index],
        x: 0,
        y: 0,
        start: { x: 0, y: 0 },
        color: "#fff"
      };
      var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      var isFunnel = shape === "funnel" || shape === "pyramid";
      if (this.geometry.type === "polygon") {
        var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
        label.x = centroid[0];
        label.y = centroid[1];
      } else if (this.geometry.type === "interval" && !isFunnel) {
        label.x = getDimValue(mappingData.x, index, true);
        label.y = getDimValue(mappingData.y, index);
      } else {
        label.x = getDimValue(mappingData.x, index);
        label.y = getDimValue(mappingData.y, index);
      }
      if (isFunnel) {
        var nextPoints = get_default(mappingData, "nextPoints");
        var points = get_default(mappingData, "points");
        if (nextPoints) {
          var point1 = coordinate.convert(points[1]);
          var point2 = coordinate.convert(nextPoints[1]);
          label.x = (point1.x + point2.x) / 2;
          label.y = (point1.y + point2.y) / 2;
        } else if (shape === "pyramid") {
          var point1 = coordinate.convert(points[1]);
          var point2 = coordinate.convert(points[2]);
          label.x = (point1.x + point2.x) / 2;
          label.y = (point1.y + point2.y) / 2;
        }
      }
      if (labelCfg.position) {
        this.setLabelPosition(label, mappingData, index, labelCfg.position);
      }
      var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
      label.start = { x: label.x, y: label.y };
      label.x += offsetPoint.x;
      label.y += offsetPoint.y;
      label.color = mappingData.color;
      return label;
    };
    GeometryLabel2.prototype.getLabelAlign = function(item, index, total) {
      var align = "center";
      var coordinate = this.getCoordinate();
      if (coordinate.isTransposed) {
        var offset = item.offset;
        if (offset < 0) {
          align = "right";
        } else if (offset === 0) {
          align = "center";
        } else {
          align = "left";
        }
        if (total > 1 && index === 0) {
          if (align === "right") {
            align = "left";
          } else if (align === "left") {
            align = "right";
          }
        }
      }
      return align;
    };
    GeometryLabel2.prototype.getLabelId = function(mappingData) {
      var geometry = this.geometry;
      var type = geometry.type;
      var xScale = geometry.getXScale();
      var yScale = geometry.getYScale();
      var origin = mappingData[FIELD_ORIGIN];
      var labelId = geometry.getElementId(mappingData);
      if (type === "line" || type === "area") {
        labelId += " " + origin[xScale.field];
      } else if (type === "path") {
        labelId += " " + origin[xScale.field] + "-" + origin[yScale.field];
      }
      return labelId;
    };
    GeometryLabel2.prototype.getLabelsRenderer = function() {
      var _a4 = this.geometry, labelsContainer = _a4.labelsContainer, labelOption = _a4.labelOption, canvasRegion = _a4.canvasRegion, animateOption = _a4.animateOption;
      var coordinate = this.geometry.coordinate;
      var labelsRenderer = this.labelsRenderer;
      if (!labelsRenderer) {
        labelsRenderer = new labels_default({
          container: labelsContainer,
          layout: get_default(labelOption, ["cfg", "layout"], {
            type: this.defaultLayout
          })
        });
        this.labelsRenderer = labelsRenderer;
      }
      labelsRenderer.region = canvasRegion;
      labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate) : false;
      return labelsRenderer;
    };
    GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
      var _this = this;
      var geometry = this.geometry;
      var labelOption = geometry.labelOption, scales = geometry.scales, coordinate = geometry.coordinate;
      var _a4 = labelOption, fields = _a4.fields, callback = _a4.callback, cfg = _a4.cfg;
      var labelScales = fields.map(function(field) {
        return scales[field];
      });
      var labelCfgs = [];
      each_default(mapppingArray, function(mappingData, index) {
        var origin = mappingData[FIELD_ORIGIN];
        var originText = _this.getLabelText(origin, labelScales);
        var callbackCfg;
        if (callback) {
          var originValues = fields.map(function(field) {
            return origin[field];
          });
          callbackCfg = callback.apply(void 0, originValues);
          if (is_nil_default(callbackCfg)) {
            labelCfgs.push(null);
            return;
          }
        }
        var labelCfg = __assign(__assign({
          id: _this.getLabelId(mappingData),
          elementId: _this.geometry.getElementId(mappingData),
          data: origin,
          mappingData,
          coordinate
        }, cfg), callbackCfg);
        if (is_function_default(labelCfg.position)) {
          labelCfg.position = labelCfg.position(origin, mappingData, index);
        }
        var offset = _this.getLabelOffset(labelCfg.offset || 0);
        var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
        labelCfg = deep_mix_default({}, defaultLabelCfg, labelCfg);
        labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
        var content = labelCfg.content;
        if (is_function_default(content)) {
          labelCfg.content = content(origin, mappingData, index);
        } else if (is_undefined_default(content)) {
          labelCfg.content = originText[0];
        }
        labelCfgs.push(labelCfg);
      });
      return labelCfgs;
    };
    GeometryLabel2.prototype.getLabelText = function(origin, scales) {
      var labelTexts = [];
      each_default(scales, function(scale5) {
        var value = origin[scale5.field];
        if (is_array_default(value)) {
          value = value.map(function(subVal) {
            return scale5.getText(subVal);
          });
        } else {
          value = scale5.getText(value);
        }
        if (is_nil_default(value) || value === "") {
          labelTexts.push(null);
        } else {
          labelTexts.push(value);
        }
      });
      return labelTexts;
    };
    GeometryLabel2.prototype.getOffsetVector = function(offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var coordinate = this.getCoordinate();
      var actualOffset = 0;
      if (is_number_default(offset)) {
        actualOffset = offset;
      }
      return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);
    };
    GeometryLabel2.prototype.getGeometryShapes = function() {
      var geometry = this.geometry;
      var shapes = {};
      each_default(geometry.elementsMap, function(element, id) {
        shapes[id] = element.shape;
      });
      each_default(geometry.getOffscreenGroup().getChildren(), function(child) {
        var id = geometry.getElementId(child.get("origin").mappingData);
        shapes[id] = child;
      });
      return shapes;
    };
    return GeometryLabel2;
  }();
  var base_default15 = GeometryLabel;

  // node_modules/@antv/g2/esm/util/attr.js
  function getMappingValue(attr, value, def2) {
    if (!attr) {
      return def2;
    }
    var r;
    if (attr.callback && attr.callback.length > 1) {
      var restArgs = Array(attr.callback.length - 1).fill("");
      r = attr.mapping.apply(attr, __spreadArray([value], restArgs, false)).join("");
    } else {
      r = attr.mapping(value).join("");
    }
    return r || def2;
  }

  // node_modules/@antv/g2/esm/util/marker.js
  var MarkerSymbols = {
    hexagon: function(x, y, r) {
      var diffX = r / 2 * Math.sqrt(3);
      return [
        ["M", x, y - r],
        ["L", x + diffX, y - r / 2],
        ["L", x + diffX, y + r / 2],
        ["L", x, y + r],
        ["L", x - diffX, y + r / 2],
        ["L", x - diffX, y - r / 2],
        ["Z"]
      ];
    },
    bowtie: function(x, y, r) {
      var diffY = r - 1.5;
      return [["M", x - r, y - diffY], ["L", x + r, y + diffY], ["L", x + r, y - diffY], ["L", x - r, y + diffY], ["Z"]];
    },
    cross: function(x, y, r) {
      return [
        ["M", x - r, y - r],
        ["L", x + r, y + r],
        ["M", x + r, y - r],
        ["L", x - r, y + r]
      ];
    },
    tick: function(x, y, r) {
      return [
        ["M", x - r / 2, y - r],
        ["L", x + r / 2, y - r],
        ["M", x, y - r],
        ["L", x, y + r],
        ["M", x - r / 2, y + r],
        ["L", x + r / 2, y + r]
      ];
    },
    plus: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y],
        ["M", x, y - r],
        ["L", x, y + r]
      ];
    },
    hyphen: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    line: function(x, y, r) {
      return [
        ["M", x, y - r],
        ["L", x, y + r]
      ];
    }
  };

  // node_modules/@antv/g2/esm/util/legend.js
  var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
  function handleUserMarkerStyle(markerStyle, style) {
    if (is_function_default(style)) {
      return style(markerStyle);
    }
    return deep_mix_default({}, markerStyle, style);
  }
  function adpatorMarkerStyle(marker, color2) {
    var symbol = marker.symbol;
    if (is_string_default(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
      var markerStyle = get_default(marker, "style", {});
      var lineWidth = get_default(markerStyle, "lineWidth", 1);
      var stroke = markerStyle.stroke || markerStyle.fill || color2;
      marker.style = deep_mix_default({}, marker.style, { lineWidth, stroke, fill: null });
    }
  }
  function setMarkerSymbol(marker) {
    var symbol = marker.symbol;
    if (is_string_default(symbol) && MarkerSymbols[symbol]) {
      marker.symbol = MarkerSymbols[symbol];
    }
  }
  function getLegendLayout(direction2) {
    return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
  }
  function getLegendItems(view, geometry, attr, themeMarker, userMarker) {
    var scale5 = attr.getScale(attr.type);
    if (scale5.isCategory) {
      var field_1 = scale5.field;
      var colorAttr_1 = geometry.getAttribute("color");
      var shapeAttr_1 = geometry.getAttribute("shape");
      var defaultColor_1 = view.getTheme().defaultColor;
      var isInPolar_1 = geometry.coordinate.isPolar;
      return scale5.getTicks().map(function(tick2, index) {
        var _a4;
        var text = tick2.text, scaleValue = tick2.value;
        var name = text;
        var value = scale5.invert(scaleValue);
        var unchecked = view.filterFieldData(field_1, [(_a4 = {}, _a4[field_1] = value, _a4)]).length === 0;
        each_default(view.views, function(subView) {
          var _a5;
          if (!subView.filterFieldData(field_1, [(_a5 = {}, _a5[field_1] = value, _a5)]).length) {
            unchecked = true;
          }
        });
        var color2 = getMappingValue(colorAttr_1, value, defaultColor_1);
        var shape = getMappingValue(shapeAttr_1, value, "point");
        var marker = geometry.getShapeMarker(shape, {
          color: color2,
          isInPolar: isInPolar_1
        });
        var markerCfg = userMarker;
        if (is_function_default(markerCfg)) {
          markerCfg = markerCfg(name, index, __assign({ name, value }, deep_mix_default({}, themeMarker, marker)));
        }
        marker = deep_mix_default({}, themeMarker, marker, omit(__assign({}, markerCfg), ["style"]));
        adpatorMarkerStyle(marker, color2);
        if (markerCfg && markerCfg.style) {
          marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
        }
        setMarkerSymbol(marker);
        return { id: value, name, value, marker, unchecked };
      });
    }
    return [];
  }
  function getCustomLegendItems(themeMarker, userMarker, customItems) {
    return customItems.map(function(item, index) {
      var markerCfg = userMarker;
      if (is_function_default(markerCfg)) {
        markerCfg = markerCfg(item.name, index, deep_mix_default({}, themeMarker, item));
      }
      var itemMarker = is_function_default(item.marker) ? item.marker(item.name, index, deep_mix_default({}, themeMarker, item)) : item.marker;
      var marker = deep_mix_default({}, themeMarker, markerCfg, itemMarker);
      setMarkerSymbol(marker);
      item.marker = marker;
      return item;
    });
  }
  function getLegendThemeCfg(theme, direction2) {
    var legendTheme = get_default(theme, ["components", "legend"], {});
    return deep_mix_default({}, get_default(legendTheme, ["common"], {}), deep_mix_default({}, get_default(legendTheme, [direction2], {})));
  }

  // node_modules/@antv/g2/esm/theme/style-sheet/dark.js
  var WHITE_COLORS2 = {
    100: "#000",
    95: "#0D0D0D",
    85: "#262626",
    65: "#595959",
    45: "#8C8C8C",
    25: "#BFBFBF",
    15: "#D9D9D9",
    6: "#F0F0F0"
  };
  var BLACK_COLORS2 = {
    100: "#FFFFFF",
    95: "#F2F2F2",
    85: "#D9D9D9",
    65: "#A6A6A6",
    45: "#737373",
    25: "#404040",
    15: "#262626",
    6: "#0F0F0F"
  };
  var QUALITATIVE_102 = [
    "#5B8FF9",
    "#5AD8A6",
    "#5D7092",
    "#F6BD16",
    "#E86452",
    "#6DC8EC",
    "#945FB9",
    "#FF9845",
    "#1E9493",
    "#FF99C3"
  ];
  var QUALITATIVE_202 = [
    "#5B8FF9",
    "#CDDDFD",
    "#5AD8A6",
    "#CDF3E4",
    "#5D7092",
    "#CED4DE",
    "#F6BD16",
    "#FCEBB9",
    "#E86452",
    "#F8D0CB",
    "#6DC8EC",
    "#D3EEF9",
    "#945FB9",
    "#DECFEA",
    "#FF9845",
    "#FFE0C7",
    "#1E9493",
    "#BBDEDE",
    "#FF99C3",
    "#FFE0ED"
  ];
  var SINGLE_SEQUENCE2 = [
    "#B8E1FF",
    "#9AC5FF",
    "#7DAAFF",
    "#5B8FF9",
    "#3D76DD",
    "#085EC0",
    "#0047A5",
    "#00318A",
    "#001D70"
  ];
  var createDarkStyleSheet = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var _a4 = cfg.backgroundColor, backgroundColor = _a4 === void 0 ? "#141414" : _a4, _b = cfg.subColor, subColor = _b === void 0 ? "rgba(255,255,255,0.05)" : _b, _c = cfg.paletteQualitative10, paletteQualitative10 = _c === void 0 ? QUALITATIVE_102 : _c, _d = cfg.paletteQualitative20, paletteQualitative20 = _d === void 0 ? QUALITATIVE_202 : _d, _e = cfg.paletteSemanticRed, paletteSemanticRed = _e === void 0 ? "#F4664A" : _e, _f = cfg.paletteSemanticGreen, paletteSemanticGreen = _f === void 0 ? "#30BF78" : _f, _g = cfg.paletteSemanticYellow, paletteSemanticYellow = _g === void 0 ? "#FAAD14" : _g, _h = cfg.paletteSequence, paletteSequence = _h === void 0 ? SINGLE_SEQUENCE2 : _h, _j = cfg.fontFamily, fontFamily = _j === void 0 ? '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"' : _j;
    var _k = cfg.brandColor, brandColor = _k === void 0 ? paletteQualitative10[0] : _k;
    return {
      backgroundColor,
      brandColor,
      subColor,
      paletteQualitative10,
      paletteQualitative20,
      paletteSemanticRed,
      paletteSemanticGreen,
      paletteSemanticYellow,
      paletteSequence,
      fontFamily,
      axisLineBorderColor: BLACK_COLORS2[25],
      axisLineBorder: 1,
      axisLineDash: null,
      axisTitleTextFillColor: BLACK_COLORS2[65],
      axisTitleTextFontSize: 12,
      axisTitleTextLineHeight: 12,
      axisTitleTextFontWeight: "normal",
      axisTitleSpacing: 12,
      axisTickLineBorderColor: BLACK_COLORS2[25],
      axisTickLineLength: 4,
      axisTickLineBorder: 1,
      axisSubTickLineBorderColor: BLACK_COLORS2[15],
      axisSubTickLineLength: 2,
      axisSubTickLineBorder: 1,
      axisLabelFillColor: BLACK_COLORS2[45],
      axisLabelFontSize: 12,
      axisLabelLineHeight: 12,
      axisLabelFontWeight: "normal",
      axisLabelOffset: 8,
      axisGridBorderColor: BLACK_COLORS2[15],
      axisGridBorder: 1,
      axisGridLineDash: null,
      legendTitleTextFillColor: BLACK_COLORS2[45],
      legendTitleTextFontSize: 12,
      legendTitleTextLineHeight: 21,
      legendTitleTextFontWeight: "normal",
      legendMarkerColor: QUALITATIVE_102[0],
      legendMarkerSpacing: 8,
      legendMarkerSize: 4,
      legendCircleMarkerSize: 4,
      legendSquareMarkerSize: 4,
      legendLineMarkerSize: 5,
      legendItemNameFillColor: BLACK_COLORS2[65],
      legendItemNameFontSize: 12,
      legendItemNameLineHeight: 12,
      legendItemNameFontWeight: "normal",
      legendItemSpacing: 24,
      legendItemMarginBottom: 12,
      legendSpacing: 16,
      legendPadding: [8, 8, 8, 8],
      legendHorizontalPadding: [8, 0, 8, 0],
      legendVerticalPadding: [0, 8, 0, 8],
      legendPageNavigatorMarkerSize: 12,
      legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS2[45],
      legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
      legendPageNavigatorMarkerFillColor: BLACK_COLORS2[45],
      legendPageNavigatorMarkerFillOpacity: 1,
      legendPageNavigatorTextFillColor: BLACK_COLORS2[65],
      legendPageNavigatorTextFontSize: 12,
      sliderRailFillColor: BLACK_COLORS2[15],
      sliderRailBorder: 0,
      sliderRailBorderColor: null,
      sliderRailWidth: 100,
      sliderRailHeight: 12,
      sliderLabelTextFillColor: BLACK_COLORS2[45],
      sliderLabelTextFontSize: 12,
      sliderLabelTextLineHeight: 12,
      sliderLabelTextFontWeight: "normal",
      sliderHandlerFillColor: WHITE_COLORS2[6],
      sliderHandlerWidth: 10,
      sliderHandlerHeight: 14,
      sliderHandlerBorder: 1,
      sliderHandlerBorderColor: WHITE_COLORS2[25],
      annotationArcBorderColor: BLACK_COLORS2[15],
      annotationArcBorder: 1,
      annotationLineBorderColor: BLACK_COLORS2[25],
      annotationLineBorder: 1,
      annotationLineDash: null,
      annotationTextFillColor: BLACK_COLORS2[65],
      annotationTextFontSize: 12,
      annotationTextLineHeight: 12,
      annotationTextFontWeight: "normal",
      annotationTextBorderColor: null,
      annotationTextBorder: 0,
      annotationRegionFillColor: BLACK_COLORS2[100],
      annotationRegionFillOpacity: 0.06,
      annotationRegionBorder: 0,
      annotationRegionBorderColor: null,
      annotationDataMarkerLineLength: 16,
      tooltipCrosshairsBorderColor: BLACK_COLORS2[25],
      tooltipCrosshairsBorder: 1,
      tooltipCrosshairsLineDash: null,
      tooltipContainerFillColor: "#1f1f1f",
      tooltipContainerFillOpacity: 0.95,
      tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
      tooltipContainerBorderRadius: 3,
      tooltipTextFillColor: BLACK_COLORS2[65],
      tooltipTextFontSize: 12,
      tooltipTextLineHeight: 12,
      tooltipTextFontWeight: "bold",
      labelFillColor: BLACK_COLORS2[65],
      labelFillColorDark: "#2c3542",
      labelFillColorLight: "#ffffff",
      labelFontSize: 12,
      labelLineHeight: 12,
      labelFontWeight: "normal",
      labelBorderColor: null,
      labelBorder: 0,
      innerLabelFillColor: WHITE_COLORS2[100],
      innerLabelFontSize: 12,
      innerLabelLineHeight: 12,
      innerLabelFontWeight: "normal",
      innerLabelBorderColor: null,
      innerLabelBorder: 0,
      overflowLabelFillColor: BLACK_COLORS2[65],
      overflowLabelFillColorDark: "#2c3542",
      overflowLabelFillColorLight: "#ffffff",
      overflowLabelFontSize: 12,
      overflowLabelLineHeight: 12,
      overflowLabelFontWeight: "normal",
      overflowLabelBorderColor: WHITE_COLORS2[100],
      overflowLabelBorder: 1,
      labelLineBorder: 1,
      labelLineBorderColor: BLACK_COLORS2[25],
      cSliderRailHieght: 16,
      cSliderBackgroundFillColor: "#416180",
      cSliderBackgroundFillOpacity: 0.05,
      cSliderForegroundFillColor: "#5B8FF9",
      cSliderForegroundFillOpacity: 0.15,
      cSliderHandlerHeight: 24,
      cSliderHandlerWidth: 10,
      cSliderHandlerFillColor: "#F7F7F7",
      cSliderHandlerFillOpacity: 1,
      cSliderHandlerHighlightFillColor: "#FFF",
      cSliderHandlerBorderColor: "#BFBFBF",
      cSliderHandlerBorder: 1,
      cSliderHandlerBorderRadius: 2,
      cSliderTextFillColor: "#fff",
      cSliderTextFillOpacity: 0.45,
      cSliderTextFontSize: 12,
      cSliderTextLineHeight: 12,
      cSliderTextFontWeight: "normal",
      cSliderTextBorderColor: null,
      cSliderTextBorder: 0,
      scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
      scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
      scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
      pointFillColor: QUALITATIVE_102[0],
      pointFillOpacity: 0.95,
      pointSize: 4,
      pointBorder: 1,
      pointBorderColor: WHITE_COLORS2[100],
      pointBorderOpacity: 1,
      pointActiveBorderColor: BLACK_COLORS2[100],
      pointSelectedBorder: 2,
      pointSelectedBorderColor: BLACK_COLORS2[100],
      pointInactiveFillOpacity: 0.3,
      pointInactiveBorderOpacity: 0.3,
      hollowPointSize: 4,
      hollowPointBorder: 1,
      hollowPointBorderColor: QUALITATIVE_102[0],
      hollowPointBorderOpacity: 0.95,
      hollowPointFillColor: WHITE_COLORS2[100],
      hollowPointActiveBorder: 1,
      hollowPointActiveBorderColor: BLACK_COLORS2[100],
      hollowPointActiveBorderOpacity: 1,
      hollowPointSelectedBorder: 2,
      hollowPointSelectedBorderColor: BLACK_COLORS2[100],
      hollowPointSelectedBorderOpacity: 1,
      hollowPointInactiveBorderOpacity: 0.3,
      lineBorder: 2,
      lineBorderColor: QUALITATIVE_102[0],
      lineBorderOpacity: 1,
      lineActiveBorder: 3,
      lineSelectedBorder: 3,
      lineInactiveBorderOpacity: 0.3,
      areaFillColor: QUALITATIVE_102[0],
      areaFillOpacity: 0.25,
      areaActiveFillColor: QUALITATIVE_102[0],
      areaActiveFillOpacity: 0.5,
      areaSelectedFillColor: QUALITATIVE_102[0],
      areaSelectedFillOpacity: 0.5,
      areaInactiveFillOpacity: 0.3,
      hollowAreaBorderColor: QUALITATIVE_102[0],
      hollowAreaBorder: 2,
      hollowAreaBorderOpacity: 1,
      hollowAreaActiveBorder: 3,
      hollowAreaActiveBorderColor: BLACK_COLORS2[100],
      hollowAreaSelectedBorder: 3,
      hollowAreaSelectedBorderColor: BLACK_COLORS2[100],
      hollowAreaInactiveBorderOpacity: 0.3,
      intervalFillColor: QUALITATIVE_102[0],
      intervalFillOpacity: 0.95,
      intervalActiveBorder: 1,
      intervalActiveBorderColor: BLACK_COLORS2[100],
      intervalActiveBorderOpacity: 1,
      intervalSelectedBorder: 2,
      intervalSelectedBorderColor: BLACK_COLORS2[100],
      intervalSelectedBorderOpacity: 1,
      intervalInactiveBorderOpacity: 0.3,
      intervalInactiveFillOpacity: 0.3,
      hollowIntervalBorder: 2,
      hollowIntervalBorderColor: QUALITATIVE_102[0],
      hollowIntervalBorderOpacity: 1,
      hollowIntervalFillColor: WHITE_COLORS2[100],
      hollowIntervalActiveBorder: 2,
      hollowIntervalActiveBorderColor: BLACK_COLORS2[100],
      hollowIntervalSelectedBorder: 3,
      hollowIntervalSelectedBorderColor: BLACK_COLORS2[100],
      hollowIntervalSelectedBorderOpacity: 1,
      hollowIntervalInactiveBorderOpacity: 0.3
    };
  };
  var antvDark = createDarkStyleSheet();

  // node_modules/@antv/g-canvas/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    AbstractCanvas: () => canvas_default,
    AbstractGroup: () => group_default2,
    AbstractShape: () => shape_default,
    Base: () => base_default2,
    Canvas: () => canvas_default3,
    Event: () => graph_event_default,
    Group: () => group_default4,
    PathUtil: () => path_exports,
    Shape: () => shape_exports,
    assembleFont: () => assembleFont,
    getArcParams: () => getArcParams2,
    getBBoxMethod: () => getMethod,
    getOffScreenContext: () => getOffScreenContext,
    getTextHeight: () => getTextHeight,
    invert: () => invert2,
    isAllowCapture: () => isAllowCapture,
    multiplyVec2: () => multiplyVec2,
    version: () => version2
  });

  // node_modules/@antv/g-canvas/esm/shape/index.js
  var shape_exports = {};
  __export(shape_exports, {
    Base: () => base_default16,
    Circle: () => circle_default6,
    Ellipse: () => ellipse_default4,
    Image: () => image_default2,
    Line: () => line_default8,
    Marker: () => marker_default,
    Path: () => path_default3,
    Polygon: () => polygon_default4,
    Polyline: () => polyline_default4,
    Rect: () => rect_default3,
    Text: () => text_default4
  });

  // node_modules/@antv/g-canvas/node_modules/tslib/modules/index.js
  var import_tslib99 = __toModule(require_tslib8());
  var {
    __extends: __extends8,
    __assign: __assign8,
    __rest: __rest8,
    __decorate: __decorate8,
    __param: __param8,
    __metadata: __metadata8,
    __awaiter: __awaiter8,
    __generator: __generator8,
    __exportStar: __exportStar8,
    __createBinding: __createBinding8,
    __values: __values8,
    __read: __read8,
    __spread: __spread8,
    __spreadArrays: __spreadArrays8,
    __spreadArray: __spreadArray7,
    __await: __await8,
    __asyncGenerator: __asyncGenerator8,
    __asyncDelegator: __asyncDelegator8,
    __asyncValues: __asyncValues8,
    __makeTemplateObject: __makeTemplateObject8,
    __importStar: __importStar8,
    __importDefault: __importDefault8,
    __classPrivateFieldGet: __classPrivateFieldGet8,
    __classPrivateFieldSet: __classPrivateFieldSet8
  } = import_tslib99.default;

  // node_modules/@antv/g-canvas/esm/util/util.js
  function getPixelRatio() {
    return window ? window.devicePixelRatio : 1;
  }
  function distance7(x1, y1, x2, y2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function inBox(minX, minY, width, height, x, y) {
    return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
  }
  function intersectRect2(box1, box2) {
    return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
  }
  function mergeRegion(region1, region2) {
    if (!region1 || !region2) {
      return region1 || region2;
    }
    return {
      minX: Math.min(region1.minX, region2.minX),
      minY: Math.min(region1.minY, region2.minY),
      maxX: Math.max(region1.maxX, region2.maxX),
      maxY: Math.max(region1.maxY, region2.maxY)
    };
  }
  function isSamePoint2(point1, point2) {
    return point1[0] === point2[0] && point1[1] === point2[1];
  }

  // node_modules/@antv/g-canvas/esm/util/parse.js
  var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var regexColorStop2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  function addStop(steps, gradient2) {
    var arr = steps.match(regexColorStop2);
    each_default(arr, function(item) {
      var itemArr = item.split(":");
      gradient2.addColorStop(itemArr[0], itemArr[1]);
    });
  }
  function parseLineGradient(context, element, gradientStr) {
    var arr = regexLG2.exec(gradientStr);
    var angle3 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
    var steps = arr[2];
    var box2 = element.getBBox();
    var start;
    var end;
    if (angle3 >= 0 && angle3 < 1 / 2 * Math.PI) {
      start = {
        x: box2.minX,
        y: box2.minY
      };
      end = {
        x: box2.maxX,
        y: box2.maxY
      };
    } else if (1 / 2 * Math.PI <= angle3 && angle3 < Math.PI) {
      start = {
        x: box2.maxX,
        y: box2.minY
      };
      end = {
        x: box2.minX,
        y: box2.maxY
      };
    } else if (Math.PI <= angle3 && angle3 < 3 / 2 * Math.PI) {
      start = {
        x: box2.maxX,
        y: box2.maxY
      };
      end = {
        x: box2.minX,
        y: box2.minY
      };
    } else {
      start = {
        x: box2.minX,
        y: box2.maxY
      };
      end = {
        x: box2.maxX,
        y: box2.minY
      };
    }
    var tanTheta = Math.tan(angle3);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
    var gradient2 = context.createLinearGradient(start.x, start.y, x, y);
    addStop(steps, gradient2);
    return gradient2;
  }
  function parseRadialGradient(context, element, gradientStr) {
    var arr = regexRG2.exec(gradientStr);
    var fx = parseFloat(arr[1]);
    var fy = parseFloat(arr[2]);
    var fr = parseFloat(arr[3]);
    var steps = arr[4];
    if (fr === 0) {
      var colors = steps.match(regexColorStop2);
      return colors[colors.length - 1].split(":")[1];
    }
    var box2 = element.getBBox();
    var width = box2.maxX - box2.minX;
    var height = box2.maxY - box2.minY;
    var r = Math.sqrt(width * width + height * height) / 2;
    var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
    addStop(steps, gradient2);
    return gradient2;
  }
  function parsePattern(context, element, patternStr) {
    if (element.get("patternSource") && element.get("patternSource") === patternStr) {
      return element.get("pattern");
    }
    var pattern;
    var img;
    var arr = regexPR.exec(patternStr);
    var repeat2 = arr[1];
    var source = arr[2];
    function onload() {
      pattern = context.createPattern(img, repeat2);
      element.set("pattern", pattern);
      element.set("patternSource", patternStr);
    }
    switch (repeat2) {
      case "a":
        repeat2 = "repeat";
        break;
      case "x":
        repeat2 = "repeat-x";
        break;
      case "y":
        repeat2 = "repeat-y";
        break;
      case "n":
        repeat2 = "no-repeat";
        break;
      default:
        repeat2 = "no-repeat";
    }
    img = new Image();
    if (!source.match(/^data:/i)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = source;
    if (img.complete) {
      onload();
    } else {
      img.onload = onload;
      img.src = img.src;
    }
    return pattern;
  }
  function parseStyle(context, element, color2) {
    var bbox = element.getBBox();
    if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
      return color2;
    }
    if (is_string_default(color2)) {
      if (color2[1] === "(" || color2[2] === "(") {
        if (color2[0] === "l") {
          return parseLineGradient(context, element, color2);
        }
        if (color2[0] === "r") {
          return parseRadialGradient(context, element, color2);
        }
        if (color2[0] === "p") {
          return parsePattern(context, element, color2);
        }
      }
      return color2;
    }
    if (color2 instanceof CanvasPattern) {
      return color2;
    }
  }
  function parseRadius(radius) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }
    return [r1, r2, r3, r4];
  }

  // node_modules/@antv/g-canvas/esm/util/arc-params.js
  function vMag2(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio2(u, v) {
    return vMag2(u) * vMag2(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag2(u) * vMag2(v)) : 1;
  }
  function vAngle2(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio2(u, v));
  }
  function getArcParams2(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x1 = startPoint[0];
    var y1 = startPoint[1];
    var x2 = params[6];
    var y2 = params[7];
    var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
    var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle2([1, 0], u);
    var dTheta = vAngle2(u, v);
    if (vRatio2(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio2(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return {
      cx,
      cy,
      rx: isSamePoint2(startPoint, [x2, y2]) ? 0 : rx,
      ry: isSamePoint2(startPoint, [x2, y2]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }

  // node_modules/@antv/g-canvas/esm/util/arrow.js
  var sin = Math.sin;
  var cos = Math.cos;
  var atan2 = Math.atan2;
  var PI = Math.PI;
  function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
    var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
    var x = x1 - x2;
    var y = y1 - y2;
    var rad = atan2(y, x);
    var arrowShape = new path_default3({
      type: "path",
      canvas: shape.get("canvas"),
      isArrowShape: true,
      attrs: {
        path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
        stroke,
        lineWidth
      }
    });
    arrowShape.translate(x2, y2);
    arrowShape.rotateAtPoint(x2, y2, rad);
    shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
  }
  function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
    var arrowAttrs = isStart ? startArrow : endArrow;
    var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest8(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
    var x = x1 - x2;
    var y = y1 - y2;
    var rad = atan2(y, x);
    if (d) {
      x2 = x2 - cos(rad) * d;
      y2 = y2 - sin(rad) * d;
    }
    var arrowShape = new path_default3({
      type: "path",
      canvas: shape.get("canvas"),
      isArrowShape: true,
      attrs: __assign8(__assign8({}, restAttrs), {
        stroke: arrowStroke || stroke,
        lineWidth: arrowLineWidth || lineWidth,
        fill: arrowFill
      })
    });
    arrowShape.translate(x2, y2);
    arrowShape.rotateAtPoint(x2, y2, rad);
    shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
  }
  function getShortenOffset(x1, y1, x2, y2, d) {
    var rad = atan2(y2 - y1, x2 - x1);
    return {
      dx: cos(rad) * d,
      dy: sin(rad) * d
    };
  }
  function addStartArrow(shape, attrs, x1, y1, x2, y2) {
    if (typeof attrs.startArrow === "object") {
      _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
    } else if (attrs.startArrow) {
      _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
    } else {
      shape.set("startArrowShape", null);
    }
  }
  function addEndArrow(shape, attrs, x1, y1, x2, y2) {
    if (typeof attrs.endArrow === "object") {
      _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
    } else if (attrs.endArrow) {
      _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
    } else {
      shape.set("startArrowShape", null);
    }
  }

  // node_modules/@antv/g-canvas/esm/util/draw.js
  var SHAPE_ATTRS_MAP = {
    fill: "fillStyle",
    stroke: "strokeStyle",
    opacity: "globalAlpha"
  };
  function applyAttrsToContext(context, element) {
    var attrs = element.attr();
    for (var k in attrs) {
      var v = attrs[k];
      var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
      if (name_1 === "matrix" && v) {
        context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
      } else if (name_1 === "lineDash" && context.setLineDash) {
        is_array_default(v) && context.setLineDash(v);
      } else {
        if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
          v = parseStyle(context, element, v);
        } else if (name_1 === "globalAlpha") {
          v = v * context.globalAlpha;
        }
        context[name_1] = v;
      }
    }
  }
  function drawChildren(context, children, region) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.cfg.visible) {
        child.draw(context, region);
      } else {
        child.skipDraw();
      }
    }
  }
  function checkRefresh(canvas, children, region) {
    var refreshElements = canvas.get("refreshElements");
    each_default(refreshElements, function(el) {
      if (el !== canvas) {
        var parent_1 = el.cfg.parent;
        while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
          parent_1.cfg.refresh = true;
          parent_1 = parent_1.cfg.parent;
        }
      }
    });
    if (refreshElements[0] === canvas) {
      setChildrenRefresh(children, region);
    } else {
      checkChildrenRefresh(children, region);
    }
  }
  function checkChildrenRefresh(children, region) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.cfg.visible) {
        if (child.cfg.hasChanged) {
          child.cfg.refresh = true;
          if (child.isGroup()) {
            setChildrenRefresh(child.cfg.children, region);
          }
        } else if (child.cfg.refresh) {
          if (child.isGroup()) {
            checkChildrenRefresh(child.cfg.children, region);
          }
        } else {
          var refresh = checkElementRefresh(child, region);
          child.cfg.refresh = refresh;
          if (refresh && child.isGroup()) {
            checkChildrenRefresh(child.cfg.children, region);
          }
        }
      }
    }
  }
  function clearChanged(elements) {
    for (var i = 0; i < elements.length; i++) {
      var el = elements[i];
      el.cfg.hasChanged = false;
      if (el.isGroup() && !el.destroyed) {
        clearChanged(el.cfg.children);
      }
    }
  }
  function setChildrenRefresh(children, region) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      child.cfg.refresh = true;
      if (child.isGroup()) {
        setChildrenRefresh(child.get("children"), region);
      }
    }
  }
  function checkElementRefresh(shape, region) {
    var bbox = shape.cfg.cacheCanvasBBox;
    var isAllow = shape.cfg.isInView && bbox && intersectRect2(bbox, region);
    return isAllow;
  }
  function drawPath(shape, context, attrs, arcParamsCache) {
    var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (!path) {
      return;
    }
    var currentPoint = [0, 0];
    var startMovePoint = [0, 0];
    var distance8 = {
      dx: 0,
      dy: 0
    };
    context.beginPath();
    for (var i = 0; i < path.length; i++) {
      var params = path[i];
      var command = params[0];
      if (i === 0 && startArrow && startArrow.d) {
        var tangent = shape.getStartTangent();
        distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
      } else if (i === path.length - 2 && path[i + 1][0] === "Z" && endArrow && endArrow.d) {
        var lastPath = path[i + 1];
        if (lastPath[0] === "Z") {
          var tangent = shape.getEndTangent();
          distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
        }
      } else if (i === path.length - 1 && endArrow && endArrow.d) {
        if (path[0] !== "Z") {
          var tangent = shape.getEndTangent();
          distance8 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
        }
      }
      var dx = distance8.dx, dy = distance8.dy;
      switch (command) {
        case "M":
          context.moveTo(params[1] - dx, params[2] - dy);
          startMovePoint = [params[1], params[2]];
          break;
        case "L":
          context.lineTo(params[1] - dx, params[2] - dy);
          break;
        case "Q":
          context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
          break;
        case "C":
          context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
          break;
        case "A": {
          var arcParams = void 0;
          if (arcParamsCache) {
            arcParams = arcParamsCache[i];
            if (!arcParams) {
              arcParams = getArcParams2(currentPoint, params);
              arcParamsCache[i] = arcParams;
            }
          } else {
            arcParams = getArcParams2(currentPoint, params);
          }
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          break;
        }
        case "Z":
          context.closePath();
          break;
        default:
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
      } else {
        var len3 = params.length;
        currentPoint = [params[len3 - 2], params[len3 - 1]];
      }
    }
  }
  function refreshElement(element, changeType) {
    var canvas = element.get("canvas");
    if (canvas) {
      if (changeType === "remove") {
        element._cacheCanvasBBox = element.get("cacheCanvasBBox");
      }
      if (!element.get("hasChanged")) {
        element.set("hasChanged", true);
        if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
          canvas.refreshElement(element, changeType, canvas);
          if (canvas.get("autoDraw")) {
            canvas.draw();
          }
        }
      }
    }
  }
  function getRefreshRegion(element) {
    var region;
    if (!element.destroyed) {
      var cacheBox = element.get("cacheCanvasBBox");
      var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
      var bbox = element.getCanvasBBox();
      var validBBox = bbox && !!(bbox.width && bbox.height);
      if (validCache && validBBox) {
        region = mergeRegion(cacheBox, bbox);
      } else if (validCache) {
        region = cacheBox;
      } else if (validBBox) {
        region = bbox;
      }
    } else {
      region = element["_cacheCanvasBBox"];
    }
    return region;
  }
  function getMergedRegion(elements) {
    if (!elements.length) {
      return null;
    }
    var minXArr = [];
    var minYArr = [];
    var maxXArr = [];
    var maxYArr = [];
    each_default(elements, function(el) {
      var region = getRefreshRegion(el);
      if (region) {
        minXArr.push(region.minX);
        minYArr.push(region.minY);
        maxXArr.push(region.maxX);
        maxYArr.push(region.maxY);
      }
    });
    return {
      minX: min_default(minXArr),
      minY: min_default(minYArr),
      maxX: max_default(maxXArr),
      maxY: max_default(maxYArr)
    };
  }
  function mergeView(region, viewRegion) {
    if (!region || !viewRegion) {
      return null;
    }
    if (!intersectRect2(region, viewRegion)) {
      return null;
    }
    return {
      minX: Math.max(region.minX, viewRegion.minX),
      minY: Math.max(region.minY, viewRegion.minY),
      maxX: Math.min(region.maxX, viewRegion.maxX),
      maxY: Math.min(region.maxY, viewRegion.maxY)
    };
  }

  // node_modules/@antv/g-canvas/esm/group.js
  var Group = function(_super) {
    __extends8(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype._applyClip = function(context, clip2) {
      if (clip2) {
        context.save();
        applyAttrsToContext(context, clip2);
        clip2.createPath(context);
        context.restore();
        context.clip();
        clip2._afterDraw();
      }
    };
    Group3.prototype.cacheCanvasBBox = function() {
      var children = this.cfg.children;
      var xArr = [];
      var yArr = [];
      each_default(children, function(child) {
        var bbox2 = child.cfg.cacheCanvasBBox;
        if (bbox2 && child.cfg.isInView) {
          xArr.push(bbox2.minX, bbox2.maxX);
          yArr.push(bbox2.minY, bbox2.maxY);
        }
      });
      var bbox = null;
      if (xArr.length) {
        var minX = min_default(xArr);
        var maxX = max_default(xArr);
        var minY = min_default(yArr);
        var maxY = max_default(yArr);
        bbox = {
          minX,
          minY,
          x: minX,
          y: minY,
          maxX,
          maxY,
          width: maxX - minX,
          height: maxY - minY
        };
        var canvas = this.cfg.canvas;
        if (canvas) {
          var viewRange = canvas.getViewRange();
          this.set("isInView", intersectRect2(bbox, viewRange));
        }
      } else {
        this.set("isInView", false);
      }
      this.set("cacheCanvasBBox", bbox);
    };
    Group3.prototype.draw = function(context, region) {
      var children = this.cfg.children;
      var allowDraw = region ? this.cfg.refresh : true;
      if (children.length && allowDraw) {
        context.save();
        applyAttrsToContext(context, this);
        this._applyClip(context, this.getClip());
        drawChildren(context, children, region);
        context.restore();
        this.cacheCanvasBBox();
      }
      this.cfg.refresh = null;
      this.set("hasChanged", false);
    };
    Group3.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("hasChanged", false);
    };
    return Group3;
  }(group_default2);
  var group_default4 = Group;

  // node_modules/@antv/g-canvas/esm/shape/base.js
  var ShapeBase2 = function(_super) {
    __extends8(ShapeBase4, _super);
    function ShapeBase4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase4.prototype.getShapeBase = function() {
      return shape_exports;
    };
    ShapeBase4.prototype.getGroupBase = function() {
      return group_default4;
    };
    ShapeBase4.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase4.prototype.calculateBBox = function() {
      var type = this.get("type");
      var lineWidth = this.getHitLineWidth();
      var bboxMethod = getMethod(type);
      var box2 = bboxMethod(this);
      var halfLineWidth = lineWidth / 2;
      var minX = box2.x - halfLineWidth;
      var minY = box2.y - halfLineWidth;
      var maxX = box2.x + box2.width + halfLineWidth;
      var maxY = box2.y + box2.height + halfLineWidth;
      return {
        x: minX,
        minX,
        y: minY,
        minY,
        width: box2.width + lineWidth,
        height: box2.height + lineWidth,
        maxX,
        maxY
      };
    };
    ShapeBase4.prototype.isFill = function() {
      return !!this.attrs["fill"] || this.isClipShape();
    };
    ShapeBase4.prototype.isStroke = function() {
      return !!this.attrs["stroke"];
    };
    ShapeBase4.prototype._applyClip = function(context, clip2) {
      if (clip2) {
        context.save();
        applyAttrsToContext(context, clip2);
        clip2.createPath(context);
        context.restore();
        context.clip();
        clip2._afterDraw();
      }
    };
    ShapeBase4.prototype.draw = function(context, region) {
      var clip2 = this.cfg.clipShape;
      if (region) {
        if (this.cfg.refresh === false) {
          this.set("hasChanged", false);
          return;
        }
        var bbox = this.getCanvasBBox();
        if (!intersectRect2(region, bbox)) {
          this.set("hasChanged", false);
          if (this.cfg.isInView) {
            this._afterDraw();
          }
          return;
        }
      }
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, clip2);
      this.drawPath(context);
      context.restore();
      this._afterDraw();
    };
    ShapeBase4.prototype.getCanvasViewBox = function() {
      var canvas = this.cfg.canvas;
      if (canvas) {
        return canvas.getViewRange();
      }
      return null;
    };
    ShapeBase4.prototype.cacheCanvasBBox = function() {
      var canvasBBox = this.getCanvasViewBox();
      if (canvasBBox) {
        var bbox = this.getCanvasBBox();
        var isInView = intersectRect2(bbox, canvasBBox);
        this.set("isInView", isInView);
        if (isInView) {
          this.set("cacheCanvasBBox", bbox);
        } else {
          this.set("cacheCanvasBBox", null);
        }
      }
    };
    ShapeBase4.prototype._afterDraw = function() {
      this.cacheCanvasBBox();
      this.set("hasChanged", false);
      this.set("refresh", null);
    };
    ShapeBase4.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("isInView", null);
      this.set("hasChanged", false);
    };
    ShapeBase4.prototype.drawPath = function(context) {
      this.createPath(context);
      this.strokeAndFill(context);
      this.afterDrawPath(context);
    };
    ShapeBase4.prototype.fill = function(context) {
      context.fill();
    };
    ShapeBase4.prototype.stroke = function(context) {
      context.stroke();
    };
    ShapeBase4.prototype.strokeAndFill = function(context) {
      var _a4 = this.attrs, lineWidth = _a4.lineWidth, opacity = _a4.opacity, strokeOpacity = _a4.strokeOpacity, fillOpacity = _a4.fillOpacity;
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = strokeOpacity;
          }
          this.stroke(context);
        }
      }
      this.afterDrawPath(context);
    };
    ShapeBase4.prototype.createPath = function(context) {
    };
    ShapeBase4.prototype.afterDrawPath = function(context) {
    };
    ShapeBase4.prototype.isInShape = function(refX, refY) {
      var isStroke = this.isStroke();
      var isFill = this.isFill();
      var lineWidth = this.getHitLineWidth();
      return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    ShapeBase4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      return false;
    };
    ShapeBase4.prototype.getHitLineWidth = function() {
      if (!this.isStroke()) {
        return 0;
      }
      var attrs = this.attrs;
      return attrs["lineWidth"] + attrs["lineAppendWidth"];
    };
    return ShapeBase4;
  }(shape_default);
  var base_default16 = ShapeBase2;

  // node_modules/@antv/g-canvas/esm/shape/circle.js
  var Circle3 = function(_super) {
    __extends8(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      var halfLineWidth = lineWidth / 2;
      var absDistance = distance7(cx, cy, x, y);
      if (isFill && isStroke) {
        return absDistance <= r + halfLineWidth;
      }
      if (isFill) {
        return absDistance <= r;
      }
      if (isStroke) {
        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
      }
      return false;
    };
    Circle6.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      context.beginPath();
      context.arc(cx, cy, r, 0, Math.PI * 2, false);
      context.closePath();
    };
    return Circle6;
  }(base_default16);
  var circle_default6 = Circle3;

  // node_modules/@antv/g-canvas/esm/shape/ellipse.js
  function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
  }
  var Ellipse = function(_super) {
    __extends8(Ellipse3, _super);
    function Ellipse3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var halfLineWith = lineWidth / 2;
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx, ry = attrs.ry;
      var squareX = (x - cx) * (x - cx);
      var squareY = (y - cy) * (y - cy);
      if (isFill && isStroke) {
        return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      if (isFill) {
        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
      }
      if (isStroke) {
        return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      return false;
    };
    Ellipse3.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx;
      var ry = attrs.ry;
      context.beginPath();
      if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
      } else {
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.translate(cx, cy);
        context.scale(scaleX, scaleY);
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.restore();
        context.closePath();
      }
    };
    return Ellipse3;
  }(base_default16);
  var ellipse_default4 = Ellipse;

  // node_modules/@antv/g-canvas/esm/shape/image.js
  function isCanvas(dom) {
    return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
  }
  var ImageShape = function(_super) {
    __extends8(ImageShape2, _super);
    function ImageShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape2.prototype.initAttrs = function(attrs) {
      this._setImage(attrs.img);
    };
    ImageShape2.prototype.isStroke = function() {
      return false;
    };
    ImageShape2.prototype.isOnlyHitBox = function() {
      return true;
    };
    ImageShape2.prototype._afterLoading = function() {
      if (this.get("toDraw") === true) {
        var canvas = this.get("canvas");
        if (canvas) {
          canvas.draw();
        } else {
          this.createPath(this.get("context"));
        }
      }
    };
    ImageShape2.prototype._setImage = function(img) {
      var _this = this;
      var attrs = this.attrs;
      if (is_string_default(img)) {
        var image_1 = new Image();
        image_1.onload = function() {
          if (_this.destroyed) {
            return false;
          }
          _this.attr("img", image_1);
          _this.set("loading", false);
          _this._afterLoading();
          var callback = _this.get("callback");
          if (callback) {
            callback.call(_this);
          }
        };
        image_1.crossOrigin = "Anonymous";
        image_1.src = img;
        this.set("loading", true);
      } else if (img instanceof Image) {
        if (!attrs.width) {
          attrs.width = img.width;
        }
        if (!attrs.height) {
          attrs.height = img.height;
        }
      } else if (isCanvas(img)) {
        if (!attrs.width) {
          attrs.width = Number(img.getAttribute("width"));
        }
        if (!attrs.height) {
          attrs.height, Number(img.getAttribute("height"));
        }
      }
    };
    ImageShape2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "img") {
        this._setImage(value);
      }
    };
    ImageShape2.prototype.createPath = function(context) {
      if (this.get("loading")) {
        this.set("toDraw", true);
        this.set("context", context);
        return;
      }
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
      var img = attrs.img;
      if (img instanceof Image || isCanvas(img)) {
        if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
          context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
        } else {
          context.drawImage(img, x, y, width, height);
        }
      }
    };
    return ImageShape2;
  }(base_default16);
  var image_default2 = ImageShape;

  // node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
  function inLine(x1, y1, x2, y2, lineWidth, x, y) {
    var minX = Math.min(x1, x2);
    var maxX = Math.max(x1, x2);
    var minY = Math.min(y1, y2);
    var maxY = Math.max(y1, y2);
    var halfWidth = lineWidth / 2;
    if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
      return false;
    }
    return line_default.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
  }

  // node_modules/@antv/g-canvas/esm/shape/line.js
  var Line3 = function(_super) {
    __extends8(Line6, _super);
    function Line6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line6.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    Line6.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
    };
    Line6.prototype.setArrow = function() {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        addStartArrow(this, attrs, x2, y2, x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, x1, y1, x2, y2);
      }
    };
    Line6.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return inLine(x1, y1, x2, y2, lineWidth, x, y);
    };
    Line6.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      var startArrowDistance = {
        dx: 0,
        dy: 0
      };
      var endArrowDistance = {
        dx: 0,
        dy: 0
      };
      if (startArrow && startArrow.d) {
        startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
      }
      if (endArrow && endArrow.d) {
        endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
      }
      context.beginPath();
      context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
      context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
    };
    Line6.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Line6.prototype.getTotalLength = function() {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line6.prototype.getPoint = function(ratio) {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line6;
  }(base_default16);
  var line_default8 = Line3;

  // node_modules/@antv/g-canvas/esm/shape/marker.js
  var Symbols = {
    circle: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["A", r, r, 0, 1, 0, x + r, y],
        ["A", r, r, 0, 1, 0, x - r, y]
      ];
    },
    square: function(x, y, r) {
      return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
    },
    diamond: function(x, y, r) {
      return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
    },
    triangle: function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
    },
    "triangle-down": function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
    }
  };
  var Marker = function(_super) {
    __extends8(Marker3, _super);
    function Marker3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker3.prototype.initAttrs = function(attrs) {
      this._resetParamsCache();
    };
    Marker3.prototype._resetParamsCache = function() {
      this.set("paramsCache", {});
    };
    Marker3.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
        this._resetParamsCache();
      }
    };
    Marker3.prototype.isOnlyHitBox = function() {
      return true;
    };
    Marker3.prototype._getR = function(attrs) {
      return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var symbol = attrs.symbol || "circle";
      var r = this._getR(attrs);
      var method;
      var path;
      if (is_function_default(symbol)) {
        method = symbol;
        path = method(x, y, r);
        path = pathToAbsolute2(path);
      } else {
        method = Marker3.Symbols[symbol];
        if (!method) {
          console.warn(symbol + " marker is not supported.");
          return null;
        }
        path = method(x, y, r);
      }
      return path;
    };
    Marker3.prototype.createPath = function(context) {
      var path = this._getPath();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, { path }, paramsCache);
    };
    Marker3.Symbols = Symbols;
    return Marker3;
  }(base_default16);
  var marker_default = Marker;

  // node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
  function isPointInPath(shape, x, y) {
    var ctx3 = getOffScreenContext();
    shape.createPath(ctx3);
    return ctx3.isPointInPath(x, y);
  }

  // node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
  var tolerance2 = 1e-6;
  function dcmp2(x) {
    if (Math.abs(x) < tolerance2) {
      return 0;
    }
    return x < 0 ? -1 : 1;
  }
  function onSegment2(p1, p22, q) {
    if ((q[0] - p1[0]) * (p22[1] - p1[1]) === (p22[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p22[0]) <= q[0] && q[0] <= Math.max(p1[0], p22[0]) && Math.min(p1[1], p22[1]) <= q[1] && q[1] <= Math.max(p1[1], p22[1])) {
      return true;
    }
    return false;
  }
  function isInPolygon2(points, x, y) {
    var isHit = false;
    var n = points.length;
    if (n <= 2) {
      return false;
    }
    for (var i = 0; i < n; i++) {
      var p1 = points[i];
      var p22 = points[(i + 1) % n];
      if (onSegment2(p1, p22, [x, y])) {
        return true;
      }
      if (dcmp2(p1[1] - y) > 0 !== dcmp2(p22[1] - y) > 0 && dcmp2(x - (y - p1[1]) * (p1[0] - p22[0]) / (p1[1] - p22[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }

  // node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
  function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
    var angle3 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
    if (angle3 < startAngle || angle3 > endAngle) {
      return false;
    }
    var point = {
      x: cx + r * Math.cos(angle3),
      y: cy + r * Math.sin(angle3)
    };
    return distance7(point.x, point.y, x, y) <= lineWidth / 2;
  }

  // node_modules/@antv/g-canvas/esm/util/path.js
  var transform5 = ext_exports.transform;
  function hasArc(path) {
    var hasArc2 = false;
    var count2 = path.length;
    for (var i = 0; i < count2; i++) {
      var params = path[i];
      var cmd = params[0];
      if (cmd === "C" || cmd === "A" || cmd === "Q") {
        hasArc2 = true;
        break;
      }
    }
    return hasArc2;
  }
  function isPointInStroke(segments, lineWidth, x, y, length3) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
      if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
        continue;
      }
      switch (segment.command) {
        case "L":
        case "Z":
          isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
          break;
        case "Q":
          var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
          isHit = qDistance <= lineWidth / 2;
          break;
        case "C":
          var cDistance = cubic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], x, y, length3);
          isHit = cDistance <= lineWidth / 2;
          break;
        case "A":
          var arcParams = segment.arcParams;
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
          var p3 = [x, y, 1];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var m = transform5(null, [
            ["t", -cx, -cy],
            ["r", -xRotation],
            ["s", 1 / scaleX, 1 / scaleY]
          ]);
          transformMat3(p3, p3, m);
          isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p3[0], p3[1]);
          break;
        default:
          break;
      }
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  function extractPolygons(path) {
    var count2 = path.length;
    var polygons = [];
    var polylines = [];
    var points = [];
    for (var i = 0; i < count2; i++) {
      var params = path[i];
      var cmd = params[0];
      if (cmd === "M") {
        if (points.length) {
          polylines.push(points);
          points = [];
        }
        points.push([params[1], params[2]]);
      } else if (cmd === "Z") {
        if (points.length) {
          polygons.push(points);
          points = [];
        }
      } else {
        points.push([params[1], params[2]]);
      }
    }
    if (points.length > 0) {
      polylines.push(points);
    }
    return {
      polygons,
      polylines
    };
  }
  var path_default4 = __assign8({ hasArc, extractPolygons, isPointInStroke }, path_exports);

  // node_modules/@antv/g-canvas/esm/shape/path.js
  function isInPolygons(polygons, x, y) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i];
      isHit = isInPolygon2(points, x, y);
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  var Path = function(_super) {
    __extends8(Path4, _super);
    function Path4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Path4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { startArrow: false, endArrow: false });
    };
    Path4.prototype.initAttrs = function(attrs) {
      this._setPathArr(attrs.path);
      this.setArrow();
    };
    Path4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name === "path") {
        this._setPathArr(value);
      }
      this.setArrow();
    };
    Path4.prototype._setPathArr = function(path) {
      this.attrs.path = pathToAbsolute2(path);
      var hasArc2 = path_default4.hasArc(path);
      this.set("hasArc", hasArc2);
      this.set("paramsCache", {});
      this.set("segments", null);
      this.set("curve", null);
      this.set("tCache", null);
      this.set("totalLength", null);
    };
    Path4.prototype.getSegments = function() {
      var segments = this.get("segements");
      if (!segments) {
        segments = getSegments(this.attr("path"));
        this.set("segments", segments);
      }
      return segments;
    };
    Path4.prototype.setArrow = function() {
      var attrs = this.attr();
      var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        var tangent = this.getStartTangent();
        addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
      if (endArrow) {
        var tangent = this.getEndTangent();
        addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
    };
    Path4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var segments = this.getSegments();
      var hasArc2 = this.get("hasArc");
      var isHit = false;
      if (isStroke) {
        var length_1 = this.getTotalLength();
        isHit = path_default4.isPointInStroke(segments, lineWidth, x, y, length_1);
      }
      if (!isHit && isFill) {
        if (hasArc2) {
          isHit = isPointInPath(this, x, y);
        } else {
          var path = this.attr("path");
          var extractResutl = path_default4.extractPolygons(path);
          isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
        }
      }
      return isHit;
    };
    Path4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, attrs, paramsCache);
    };
    Path4.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Path4.prototype.getTotalLength = function() {
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this._calculateCurve();
      this._setTcache();
      return this.get("totalLength");
    };
    Path4.prototype.getPoint = function(ratio) {
      var tCache = this.get("tCache");
      if (!tCache) {
        this._calculateCurve();
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      var curve = this.get("curve");
      if (!tCache || tCache.length === 0) {
        if (curve) {
          return {
            x: curve[0][1],
            y: curve[0][2]
          };
        }
        return null;
      }
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      var seg = curve[index];
      if (is_nil_default(seg) || is_nil_default(index)) {
        return null;
      }
      var l = seg.length;
      var nextSeg = curve[index + 1];
      return cubic_default.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path4.prototype._calculateCurve = function() {
      var path = this.attr().path;
      this.set("curve", path_default4.pathToCurve(path));
    };
    Path4.prototype._setTcache = function() {
      var totalLength = 0;
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      var segmentN;
      var l;
      var curve = this.get("curve");
      if (!curve) {
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          totalLength += cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
        }
      });
      this.set("totalLength", totalLength);
      if (totalLength === 0) {
        this.set("tCache", []);
        return;
      }
      each_default(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = cubic_default.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
          tempLength += segmentL || 0;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Path4.prototype.getStartTangent = function() {
      var segments = this.getSegments();
      var result;
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    };
    Path4.prototype.getEndTangent = function() {
      var segments = this.getSegments();
      var length3 = segments.length;
      var result;
      if (length3 > 1) {
        var startPoint = segments[length3 - 2].currentPoint;
        var endPoint = segments[length3 - 1].currentPoint;
        var tangent = segments[length3 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    };
    return Path4;
  }(base_default16);
  var path_default3 = Path;

  // node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
  function inPolyline(points, lineWidth, x, y, isClose) {
    var count2 = points.length;
    if (count2 < 2) {
      return false;
    }
    for (var i = 0; i < count2 - 1; i++) {
      var x1 = points[i][0];
      var y1 = points[i][1];
      var x2 = points[i + 1][0];
      var y2 = points[i + 1][1];
      if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
        return true;
      }
    }
    if (isClose) {
      var first = points[0];
      var last2 = points[count2 - 1];
      if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
        return true;
      }
    }
    return false;
  }

  // node_modules/@antv/g-canvas/esm/shape/polygon.js
  var Polygon = function(_super) {
    __extends8(Polygon4, _super);
    function Polygon4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var points = this.attr().points;
      var isHit = false;
      if (isStroke) {
        isHit = inPolyline(points, lineWidth, x, y, true);
      }
      if (!isHit && isFill) {
        isHit = isInPolygon2(points, x, y);
      }
      return isHit;
    };
    Polygon4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var points = attrs.points;
      if (points.length < 2) {
        return;
      }
      context.beginPath();
      for (var i = 0; i < points.length; i++) {
        var point = points[i];
        if (i === 0) {
          context.moveTo(point[0], point[1]);
        } else {
          context.lineTo(point[0], point[1]);
        }
      }
      context.closePath();
    };
    return Polygon4;
  }(base_default16);
  var polygon_default4 = Polygon;

  // node_modules/@antv/g-canvas/esm/shape/polyline.js
  var PolyLine = function(_super) {
    __extends8(PolyLine2, _super);
    function PolyLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    PolyLine2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      this.setArrow();
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    PolyLine2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    PolyLine2.prototype.setArrow = function() {
      var attrs = this.attr();
      var _a4 = this.attrs, points = _a4.points, startArrow = _a4.startArrow, endArrow = _a4.endArrow;
      var length3 = points.length;
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x2 = points[length3 - 1][0];
      var y2 = points[length3 - 1][1];
      if (startArrow) {
        addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, points[length3 - 2][0], points[length3 - 2][1], x2, y2);
      }
    };
    PolyLine2.prototype.isFill = function() {
      return false;
    };
    PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var points = this.attr().points;
      return inPolyline(points, lineWidth, x, y, false);
    };
    PolyLine2.prototype.isStroke = function() {
      return true;
    };
    PolyLine2.prototype.createPath = function(context) {
      var _a4 = this.attr(), points = _a4.points, startArrow = _a4.startArrow, endArrow = _a4.endArrow;
      var length3 = points.length;
      if (points.length < 2) {
        return;
      }
      var x1 = points[0][0];
      var y1 = points[0][1];
      var x2 = points[length3 - 1][0];
      var y2 = points[length3 - 1][1];
      if (startArrow && startArrow.d) {
        var distance8 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
        x1 += distance8.dx;
        y1 += distance8.dy;
      }
      if (endArrow && endArrow.d) {
        var distance8 = getShortenOffset(points[length3 - 2][0], points[length3 - 2][1], x2, y2, endArrow.d);
        x2 -= distance8.dx;
        y2 -= distance8.dy;
      }
      context.beginPath();
      context.moveTo(x1, y1);
      for (var i = 0; i < length3 - 1; i++) {
        var point = points[i];
        context.lineTo(point[0], point[1]);
      }
      context.lineTo(x2, y2);
    };
    PolyLine2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    PolyLine2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    PolyLine2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    PolyLine2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p3, i) {
        if (points[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p3[0], p3[1], points[i + 1][0], points[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    PolyLine2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    PolyLine2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return PolyLine2;
  }(base_default16);
  var polyline_default4 = PolyLine;

  // node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
  function inRect(minX, minY, width, height, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
  }

  // node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
  function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
    var halfWidth = lineWidth / 2;
    return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
  }

  // node_modules/@antv/g-canvas/esm/shape/rect.js
  var Rect = function(_super) {
    __extends8(Rect4, _super);
    function Rect4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect4.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var minX = attrs.x;
      var minY = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        var halfWidth = lineWidth / 2;
        if (isFill && isStroke) {
          return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
        }
        if (isFill) {
          return inBox(minX, minY, width, height, x, y);
        }
        if (isStroke) {
          return inRect(minX, minY, width, height, lineWidth, x, y);
        }
      } else {
        var isHit = false;
        if (isStroke) {
          isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
        }
        if (!isHit && isFill) {
          isHit = isPointInPath(this, x, y);
        }
        return isHit;
      }
    };
    Rect4.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      context.beginPath();
      if (radius === 0) {
        context.rect(x, y, width, height);
      } else {
        var _a4 = parseRadius(radius), r1 = _a4[0], r2 = _a4[1], r3 = _a4[2], r4 = _a4[3];
        context.moveTo(x + r1, y);
        context.lineTo(x + width - r2, y);
        r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
        context.lineTo(x + width, y + height - r3);
        r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
        context.lineTo(x + r4, y + height);
        r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
        context.lineTo(x, y + r1);
        r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
        context.closePath();
      }
    };
    return Rect4;
  }(base_default16);
  var rect_default3 = Rect;

  // node_modules/@antv/g-canvas/esm/shape/text.js
  var Text2 = function(_super) {
    __extends8(Text4, _super);
    function Text4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Text4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign8(__assign8({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text4.prototype.isOnlyHitBox = function() {
      return true;
    };
    Text4.prototype.initAttrs = function(attrs) {
      this._assembleFont();
      if (attrs.text) {
        this._setText(attrs.text);
      }
    };
    Text4.prototype._assembleFont = function() {
      var attrs = this.attrs;
      attrs.font = assembleFont(attrs);
    };
    Text4.prototype._setText = function(text) {
      var textArr = null;
      if (is_string_default(text) && text.indexOf("\n") !== -1) {
        textArr = text.split("\n");
      }
      this.set("textArr", textArr);
    };
    Text4.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (name.startsWith("font")) {
        this._assembleFont();
      }
      if (name === "text") {
        this._setText(value);
      }
    };
    Text4.prototype._getSpaceingY = function() {
      var attrs = this.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    Text4.prototype._drawTextArr = function(context, textArr, isFill) {
      var attrs = this.attrs;
      var textBaseline = attrs.textBaseline;
      var x = attrs.x;
      var y = attrs.y;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
      var subY;
      each_default(textArr, function(subText, index) {
        subY = y + index * (spaceingY + fontSize) - height + fontSize;
        if (textBaseline === "middle")
          subY += height - fontSize - (height - fontSize) / 2;
        if (textBaseline === "top")
          subY += height - fontSize;
        if (!is_nil_default(subText)) {
          if (isFill) {
            context.fillText(subText, x, subY);
          } else {
            context.strokeText(subText, x, subY);
          }
        }
      });
    };
    Text4.prototype._drawText = function(context, isFill) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var textArr = this.get("textArr");
      if (textArr) {
        this._drawTextArr(context, textArr, isFill);
      } else {
        var text = attrs.text;
        if (!is_nil_default(text)) {
          if (isFill) {
            context.fillText(text, x, y);
          } else {
            context.strokeText(text, x, y);
          }
        }
      }
    };
    Text4.prototype.strokeAndFill = function(context) {
      var _a4 = this.attrs, lineWidth = _a4.lineWidth, opacity = _a4.opacity, strokeOpacity = _a4.strokeOpacity, fillOpacity = _a4.fillOpacity;
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = opacity;
          }
          this.stroke(context);
        }
      }
      if (this.isFill()) {
        if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      this.afterDrawPath(context);
    };
    Text4.prototype.fill = function(context) {
      this._drawText(context, true);
    };
    Text4.prototype.stroke = function(context) {
      this._drawText(context, false);
    };
    return Text4;
  }(base_default16);
  var text_default4 = Text2;

  // node_modules/@antv/g-canvas/esm/util/hit.js
  function invertFromMatrix(v, matrix) {
    if (matrix) {
      var invertMatrix = invert2(matrix);
      return multiplyVec2(invertMatrix, v);
    }
    return v;
  }
  function getRefXY(element, x, y) {
    var totalMatrix = element.getTotalMatrix();
    if (totalMatrix) {
      var _a4 = invertFromMatrix([x, y, 1], totalMatrix), refX = _a4[0], refY = _a4[1];
      return [refX, refY];
    }
    return [x, y];
  }
  function preTest(element, x, y) {
    if (element.isCanvas && element.isCanvas()) {
      return true;
    }
    if (!isAllowCapture(element) || element.cfg.isInView === false) {
      return false;
    }
    if (element.cfg.clipShape) {
      var _a4 = getRefXY(element, x, y), refX = _a4[0], refY = _a4[1];
      if (element.isClipped(refX, refY)) {
        return false;
      }
    }
    var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
    if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
      return false;
    }
    return true;
  }
  function getShape(container, x, y) {
    if (!preTest(container, x, y)) {
      return null;
    }
    var shape = null;
    var children = container.getChildren();
    var count2 = children.length;
    for (var i = count2 - 1; i >= 0; i--) {
      var child = children[i];
      if (child.isGroup()) {
        shape = getShape(child, x, y);
      } else if (preTest(child, x, y)) {
        var curShape = child;
        var _a4 = getRefXY(child, x, y), refX = _a4[0], refY = _a4[1];
        if (curShape.isInShape(refX, refY)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  }

  // node_modules/@antv/g-canvas/esm/canvas.js
  var Canvas3 = function(_super) {
    __extends8(Canvas5, _super);
    function Canvas5() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas5.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["renderer"] = "canvas";
      cfg["autoDraw"] = true;
      cfg["localRefresh"] = true;
      cfg["refreshElements"] = [];
      cfg["clipView"] = true;
      cfg["quickHit"] = false;
      return cfg;
    };
    Canvas5.prototype.onCanvasChange = function(changeType) {
      if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
        this.set("refreshElements", [this]);
        this.draw();
      }
    };
    Canvas5.prototype.getShapeBase = function() {
      return shape_exports;
    };
    Canvas5.prototype.getGroupBase = function() {
      return group_default4;
    };
    Canvas5.prototype.getPixelRatio = function() {
      var pixelRatio = this.get("pixelRatio") || getPixelRatio();
      return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas5.prototype.getViewRange = function() {
      return {
        minX: 0,
        minY: 0,
        maxX: this.cfg.width,
        maxY: this.cfg.height
      };
    };
    Canvas5.prototype.createDom = function() {
      var element = document.createElement("canvas");
      var context = element.getContext("2d");
      this.set("context", context);
      return element;
    };
    Canvas5.prototype.setDOMSize = function(width, height) {
      _super.prototype.setDOMSize.call(this, width, height);
      var context = this.get("context");
      var el = this.get("el");
      var pixelRatio = this.getPixelRatio();
      el.width = pixelRatio * width;
      el.height = pixelRatio * height;
      if (pixelRatio > 1) {
        context.scale(pixelRatio, pixelRatio);
      }
    };
    Canvas5.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this._clearFrame();
      var context = this.get("context");
      var element = this.get("el");
      context.clearRect(0, 0, element.width, element.height);
    };
    Canvas5.prototype.getShape = function(x, y) {
      var shape;
      if (this.get("quickHit")) {
        shape = getShape(this, x, y);
      } else {
        shape = _super.prototype.getShape.call(this, x, y, null);
      }
      return shape;
    };
    Canvas5.prototype._getRefreshRegion = function() {
      var elements = this.get("refreshElements");
      var viewRegion = this.getViewRange();
      var region;
      if (elements.length && elements[0] === this) {
        region = viewRegion;
      } else {
        region = getMergedRegion(elements);
        if (region) {
          region.minX = Math.floor(region.minX);
          region.minY = Math.floor(region.minY);
          region.maxX = Math.ceil(region.maxX);
          region.maxY = Math.ceil(region.maxY);
          region.maxY += 1;
          var clipView = this.get("clipView");
          if (clipView) {
            region = mergeView(region, viewRegion);
          }
        }
      }
      return region;
    };
    Canvas5.prototype.refreshElement = function(element) {
      var refreshElements = this.get("refreshElements");
      refreshElements.push(element);
    };
    Canvas5.prototype._clearFrame = function() {
      var drawFrame = this.get("drawFrame");
      if (drawFrame) {
        cancelAnimationFrame(drawFrame);
        this.set("drawFrame", null);
        this.set("refreshElements", []);
      }
    };
    Canvas5.prototype.draw = function() {
      var drawFrame = this.get("drawFrame");
      if (this.get("autoDraw") && drawFrame) {
        return;
      }
      this._startDraw();
    };
    Canvas5.prototype._drawAll = function() {
      var context = this.get("context");
      var element = this.get("el");
      var children = this.getChildren();
      context.clearRect(0, 0, element.width, element.height);
      applyAttrsToContext(context, this);
      drawChildren(context, children);
      this.set("refreshElements", []);
    };
    Canvas5.prototype._drawRegion = function() {
      var context = this.get("context");
      var refreshElements = this.get("refreshElements");
      var children = this.getChildren();
      var region = this._getRefreshRegion();
      if (region) {
        context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.save();
        context.beginPath();
        context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.clip();
        applyAttrsToContext(context, this);
        checkRefresh(this, children, region);
        drawChildren(context, children, region);
        context.restore();
      } else if (refreshElements.length) {
        clearChanged(refreshElements);
      }
      each_default(refreshElements, function(element) {
        if (element.get("hasChanged")) {
          element.set("hasChanged", false);
        }
      });
      this.set("refreshElements", []);
    };
    Canvas5.prototype._startDraw = function() {
      var _this = this;
      var drawFrame = this.get("drawFrame");
      if (!drawFrame) {
        drawFrame = requestAnimationFrame2(function() {
          if (_this.get("localRefresh")) {
            _this._drawRegion();
          } else {
            _this._drawAll();
          }
          _this.set("drawFrame", null);
        });
        this.set("drawFrame", drawFrame);
      }
    };
    Canvas5.prototype.skipDraw = function() {
    };
    Canvas5.prototype.removeDom = function() {
      var el = this.get("el");
      el.width = 0;
      el.height = 0;
      el.parentNode.removeChild(el);
    };
    return Canvas5;
  }(canvas_default);
  var canvas_default3 = Canvas3;

  // node_modules/@antv/g-canvas/esm/index.js
  var version2 = "0.5.12";

  // node_modules/@antv/g-svg/esm/index.js
  var esm_exports2 = {};
  __export(esm_exports2, {
    AbstractCanvas: () => canvas_default,
    AbstractGroup: () => group_default2,
    AbstractShape: () => shape_default,
    Base: () => base_default2,
    Canvas: () => canvas_default4,
    Event: () => graph_event_default,
    Group: () => group_default5,
    PathUtil: () => path_exports,
    Shape: () => shape_exports2,
    assembleFont: () => assembleFont,
    getBBoxMethod: () => getMethod,
    getOffScreenContext: () => getOffScreenContext,
    getTextHeight: () => getTextHeight,
    invert: () => invert2,
    isAllowCapture: () => isAllowCapture,
    multiplyVec2: () => multiplyVec2,
    version: () => version3
  });

  // node_modules/@antv/g-svg/esm/shape/index.js
  var shape_exports2 = {};
  __export(shape_exports2, {
    Base: () => base_default17,
    Circle: () => circle_default7,
    Dom: () => dom_default,
    Ellipse: () => ellipse_default5,
    Image: () => image_default3,
    Line: () => line_default9,
    Marker: () => marker_default2,
    Path: () => path_default5,
    Polygon: () => polygon_default5,
    Polyline: () => polyline_default5,
    Rect: () => rect_default4,
    Text: () => text_default5
  });

  // node_modules/@antv/g-svg/node_modules/tslib/modules/index.js
  var import_tslib115 = __toModule(require_tslib9());
  var {
    __extends: __extends9,
    __assign: __assign9,
    __rest: __rest9,
    __decorate: __decorate9,
    __param: __param9,
    __metadata: __metadata9,
    __awaiter: __awaiter9,
    __generator: __generator9,
    __exportStar: __exportStar9,
    __createBinding: __createBinding9,
    __values: __values9,
    __read: __read9,
    __spread: __spread9,
    __spreadArrays: __spreadArrays9,
    __spreadArray: __spreadArray8,
    __await: __await9,
    __asyncGenerator: __asyncGenerator9,
    __asyncDelegator: __asyncDelegator9,
    __asyncValues: __asyncValues9,
    __makeTemplateObject: __makeTemplateObject9,
    __importStar: __importStar9,
    __importDefault: __importDefault9,
    __classPrivateFieldGet: __classPrivateFieldGet9,
    __classPrivateFieldSet: __classPrivateFieldSet9
  } = import_tslib115.default;

  // node_modules/@antv/g-svg/esm/constant.js
  var SHAPE_TO_TAGS = {
    rect: "path",
    circle: "circle",
    line: "line",
    path: "path",
    marker: "path",
    text: "text",
    polyline: "polyline",
    polygon: "polygon",
    image: "image",
    ellipse: "ellipse",
    dom: "foreignObject"
  };
  var SVG_ATTR_MAP = {
    opacity: "opacity",
    fillStyle: "fill",
    fill: "fill",
    fillOpacity: "fill-opacity",
    strokeStyle: "stroke",
    strokeOpacity: "stroke-opacity",
    stroke: "stroke",
    x: "x",
    y: "y",
    r: "r",
    rx: "rx",
    ry: "ry",
    width: "width",
    height: "height",
    x1: "x1",
    x2: "x2",
    y1: "y1",
    y2: "y2",
    lineCap: "stroke-linecap",
    lineJoin: "stroke-linejoin",
    lineWidth: "stroke-width",
    lineDash: "stroke-dasharray",
    lineDashOffset: "stroke-dashoffset",
    miterLimit: "stroke-miterlimit",
    font: "font",
    fontSize: "font-size",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    fontFamily: "font-family",
    startArrow: "marker-start",
    endArrow: "marker-end",
    path: "d",
    class: "class",
    id: "id",
    style: "style",
    preserveAspectRatio: "preserveAspectRatio"
  };

  // node_modules/@antv/g-svg/esm/util/dom.js
  function createSVGElement(type) {
    return document.createElementNS("http://www.w3.org/2000/svg", type);
  }
  function createDom2(shape) {
    var type = SHAPE_TO_TAGS[shape.type];
    var parent = shape.getParent();
    if (!type) {
      throw new Error("the type " + shape.type + " is not supported by svg");
    }
    var element = createSVGElement(type);
    if (shape.get("id")) {
      element.id = shape.get("id");
    }
    shape.set("el", element);
    shape.set("attrs", {});
    if (parent) {
      var parentNode = parent.get("el");
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        parentNode = parent.createDom();
        parent.set("el", parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  }
  function sortDom(element, sorter) {
    var el = element.get("el");
    var childList = to_array_default(el.children).sort(sorter);
    var fragment = document.createDocumentFragment();
    childList.forEach(function(child) {
      fragment.appendChild(child);
    });
    el.appendChild(fragment);
  }
  function moveTo(element, targetIndex) {
    var parentNode = element.parentNode;
    var siblings = Array.from(parentNode.childNodes).filter(function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    });
    var target = siblings[targetIndex];
    var currentIndex = siblings.indexOf(element);
    if (target) {
      if (currentIndex > targetIndex) {
        parentNode.insertBefore(element, target);
      } else if (currentIndex < targetIndex) {
        var targetNext = siblings[targetIndex + 1];
        if (targetNext) {
          parentNode.insertBefore(element, targetNext);
        } else {
          parentNode.appendChild(element);
        }
      }
    } else {
      parentNode.appendChild(element);
    }
  }

  // node_modules/@antv/g-svg/esm/util/svg.js
  function setShadow(model2, context) {
    var el = model2.cfg.el;
    var attrs = model2.attr();
    var cfg = {
      dx: attrs.shadowOffsetX,
      dy: attrs.shadowOffsetY,
      blur: attrs.shadowBlur,
      color: attrs.shadowColor
    };
    if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
      el.removeAttribute("filter");
    } else {
      var id = context.find("filter", cfg);
      if (!id) {
        id = context.addShadow(cfg);
      }
      el.setAttribute("filter", "url(#" + id + ")");
    }
  }
  function setTransform(model2) {
    var matrix = model2.attr().matrix;
    if (matrix) {
      var el = model2.cfg.el;
      var transform9 = [];
      for (var i = 0; i < 9; i += 3) {
        transform9.push(matrix[i] + "," + matrix[i + 1]);
      }
      transform9 = transform9.join(",");
      if (transform9.indexOf("NaN") === -1) {
        el.setAttribute("transform", "matrix(" + transform9 + ")");
      } else {
        console.warn("invalid matrix:", matrix);
      }
    }
  }
  function setClip(model2, context) {
    var clip2 = model2.getClip();
    var el = model2.get("el");
    if (!clip2) {
      el.removeAttribute("clip-path");
    } else if (clip2 && !el.hasAttribute("clip-path")) {
      createDom2(clip2);
      clip2.createPath(context);
      var id = context.addClip(clip2);
      el.setAttribute("clip-path", "url(#" + id + ")");
    }
  }

  // node_modules/@antv/g-svg/esm/util/draw.js
  function drawChildren2(context, children) {
    children.forEach(function(child) {
      child.draw(context);
    });
  }
  function refreshElement2(element, changeType) {
    var canvas = element.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      var parent_1 = element.getParent();
      var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
      var el = element.get("el");
      if (changeType === "remove") {
        var isClipShape = element.get("isClipShape");
        if (isClipShape) {
          var clipPathEl = el && el.parentNode;
          var defsEl = clipPathEl && clipPathEl.parentNode;
          if (clipPathEl && defsEl) {
            defsEl.removeChild(clipPathEl);
          }
        } else if (el && el.parentNode) {
          el.parentNode.removeChild(el);
        }
      } else if (changeType === "show") {
        el.setAttribute("visibility", "visible");
      } else if (changeType === "hide") {
        el.setAttribute("visibility", "hidden");
      } else if (changeType === "zIndex") {
        moveTo(el, parentChildren.indexOf(element));
      } else if (changeType === "sort") {
        var children_1 = element.get("children");
        if (children_1 && children_1.length) {
          sortDom(element, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
        }
      } else if (changeType === "matrix") {
        setTransform(element);
      } else if (changeType === "clip") {
        setClip(element, context);
      } else if (changeType === "attr") {
      } else if (changeType === "add") {
        element.draw(context);
      }
    }
  }

  // node_modules/@antv/g-svg/esm/group.js
  var Group2 = function(_super) {
    __extends9(Group3, _super);
    function Group3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group3.prototype.isEntityGroup = function() {
      return true;
    };
    Group3.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent = this.getParent();
      if (parent) {
        var parentNode = parent.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent.createDom();
          parent.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group3.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group3.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    Group3.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Group3.prototype.getGroupBase = function() {
      return Group3;
    };
    Group3.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren2(context, children);
        }
      }
    };
    Group3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      setTransform(this);
    };
    return Group3;
  }(group_default2);
  var group_default5 = Group2;

  // node_modules/@antv/g-svg/esm/shape/base.js
  var ShapeBase3 = function(_super) {
    __extends9(ShapeBase4, _super);
    function ShapeBase4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase4.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase4.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    ShapeBase4.prototype.getGroupBase = function() {
      return group_default5;
    };
    ShapeBase4.prototype.onCanvasChange = function(changeType) {
      refreshElement2(this, changeType);
    };
    ShapeBase4.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x - halfWidth;
        var minY = y - halfWidth;
        var maxX = x + width + halfWidth;
        var maxY = y + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY,
          width: width + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase4.prototype.isFill = function() {
      var _a4 = this.attr(), fill4 = _a4.fill, fillStyle = _a4.fillStyle;
      return (fill4 || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase4.prototype.isStroke = function() {
      var _a4 = this.attr(), stroke = _a4.stroke, strokeStyle = _a4.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase4.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom2(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase4.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase4.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill4 = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill4 || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill4);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase4.prototype._setColor = function(context, attr, value) {
      var el = this.get("el");
      if (!value) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value = value.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
        var id = context.find("gradient", value);
        if (!id) {
          id = context.addGradient(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
        var id = context.find("pattern", value);
        if (!id) {
          id = context.addPattern(value);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    };
    ShapeBase4.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a4 = targetAttrs || attrs, shadowOffsetX = _a4.shadowOffsetX, shadowOffsetY = _a4.shadowOffsetY, shadowBlur = _a4.shadowBlur, shadowColor = _a4.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase4.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase4.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase4.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase4.prototype.getHitLineWidth = function() {
      var _a4 = this.attrs, lineWidth = _a4.lineWidth, lineAppendWidth = _a4.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase4;
  }(shape_default);
  var base_default17 = ShapeBase3;

  // node_modules/@antv/g-svg/esm/shape/circle.js
  var Circle4 = function(_super) {
    __extends9(Circle6, _super);
    function Circle6() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle6.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Circle6;
  }(base_default17);
  var circle_default7 = Circle4;

  // node_modules/@antv/g-svg/esm/shape/dom.js
  var Dom = function(_super) {
    __extends9(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i = children.length - 1; i >= 0; i--) {
            el.removeChild(children[i]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(base_default17);
  var dom_default = Dom;

  // node_modules/@antv/g-svg/esm/shape/ellipse.js
  var Ellipse2 = function(_super) {
    __extends9(Ellipse3, _super);
    function Ellipse3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse3.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Ellipse3;
  }(base_default17);
  var ellipse_default5 = Ellipse2;

  // node_modules/@antv/g-svg/esm/shape/image.js
  var Image2 = function(_super) {
    __extends9(Image3, _super);
    function Image3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image3.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image3.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Image3.prototype.setAttr = function(name, value) {
      this.attrs[name] = value;
      if (name === "img") {
        this._setImage(value);
      }
    };
    Image3.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (is_string_default(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image3;
  }(base_default17);
  var image_default3 = Image2;

  // node_modules/@antv/g-svg/esm/shape/line.js
  var Line4 = function(_super) {
    __extends9(Line6, _super);
    function Line6() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line6.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line6.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Line6.prototype.getTotalLength = function() {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.length(x1, y1, x2, y2);
    };
    Line6.prototype.getPoint = function(ratio) {
      var _a4 = this.attr(), x1 = _a4.x1, y1 = _a4.y1, x2 = _a4.x2, y2 = _a4.y2;
      return line_default.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line6;
  }(base_default17);
  var line_default9 = Line4;

  // node_modules/@antv/g-svg/esm/shape/marker/symbols.js
  var Symbols2 = {
    circle: function(x, y, r) {
      return [
        ["M", x, y],
        ["m", -r, 0],
        ["a", r, r, 0, 1, 0, r * 2, 0],
        ["a", r, r, 0, 1, 0, -r * 2, 0]
      ];
    },
    square: function(x, y, r) {
      return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
    },
    diamond: function(x, y, r) {
      return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
    },
    triangle: function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
    },
    triangleDown: function(x, y, r) {
      var diffY = r * Math.sin(1 / 3 * Math.PI);
      return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
    }
  };
  var symbols_default = {
    get: function(type) {
      return Symbols2[type];
    },
    register: function(type, func2) {
      Symbols2[type] = func2;
    },
    remove: function(type) {
      delete Symbols2[type];
    },
    getAll: function() {
      return Symbols2;
    }
  };

  // node_modules/@antv/g-svg/esm/shape/marker/index.js
  var Marker2 = function(_super) {
    __extends9(Marker3, _super);
    function Marker3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker3.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker3.prototype._assembleMarker = function() {
      var d = this._getPath();
      if (is_array_default(d)) {
        return d.map(function(path) {
          return path.join(" ");
        }).join("");
      }
      return d;
    };
    Marker3.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var r = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method;
      if (is_function_default(symbol)) {
        method = symbol;
      } else {
        method = symbols_default.get(symbol);
      }
      if (!method) {
        console.warn(method + " symbol is not exist.");
        return null;
      }
      return method(x, y, r);
    };
    Marker3.symbolsFactory = symbols_default;
    return Marker3;
  }(base_default17);
  var marker_default2 = Marker2;

  // node_modules/@antv/g-svg/esm/shape/path.js
  var Path2 = function(_super) {
    __extends9(Path4, _super);
    function Path4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { startArrow: false, endArrow: false });
    };
    Path4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "path" && is_array_default(value)) {
          el.setAttribute("d", _this._formatPath(value));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value) {
            var id = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Path4.prototype._formatPath = function(value) {
      var newValue = value.map(function(path) {
        return path.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path4.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path4.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point ? {
        x: point.x,
        y: point.y
      } : null;
    };
    return Path4;
  }(base_default17);
  var path_default5 = Path2;

  // node_modules/@antv/g-svg/esm/shape/polygon.js
  var Polygon2 = function(_super) {
    __extends9(Polygon4, _super);
    function Polygon4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon4.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    return Polygon4;
  }(base_default17);
  var polygon_default5 = Polygon2;

  // node_modules/@antv/g-svg/esm/shape/polyline.js
  var Polyline = function(_super) {
    __extends9(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value, originValue) {
      _super.prototype.onAttrChange.call(this, name, value, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "points" && is_array_default(value) && value.length >= 2) {
          el.setAttribute("points", value.map(function(point) {
            return point[0] + "," + point[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!is_nil_default(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", polyline_default.length(points));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index;
      each_default(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index = i;
        }
      });
      return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points = this.attr().points;
      if (!points || points.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each_default(points, function(p3, i) {
        if (points[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = line_default.length(p3[0], p3[1], points[i + 1][0], points[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points = this.attr().points;
      var result = [];
      result.push([points[1][0], points[1][1]]);
      result.push([points[0][0], points[0][1]]);
      return result;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points = this.attr().points;
      var l = points.length - 1;
      var result = [];
      result.push([points[l - 1][0], points[l - 1][1]]);
      result.push([points[l][0], points[l][1]]);
      return result;
    };
    return Polyline2;
  }(base_default17);
  var polyline_default5 = Polyline;

  // node_modules/@antv/g-svg/esm/util/format.js
  function parseRadius2(radius) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }
    return {
      r1,
      r2,
      r3,
      r4
    };
  }

  // node_modules/@antv/g-svg/esm/shape/rect.js
  var Rect2 = function(_super) {
    __extends9(Rect4, _super);
    function Rect4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each_default(targetAttrs || attrs, function(value, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
    };
    Rect4.prototype._assembleRect = function(attrs) {
      var x = attrs.x;
      var y = attrs.y;
      var w = attrs.width;
      var h2 = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x + "," + y + " l " + w + ",0 l 0," + h2 + " l" + -w + " 0 z";
      }
      var r = parseRadius2(radius);
      if (is_array_default(radius)) {
        if (radius.length === 1) {
          r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
        } else if (radius.length === 2) {
          r.r1 = r.r3 = radius[0];
          r.r2 = r.r4 = radius[1];
        } else if (radius.length === 3) {
          r.r1 = radius[0];
          r.r2 = r.r4 = radius[1];
          r.r3 = radius[2];
        } else {
          r.r1 = radius[0];
          r.r2 = radius[1];
          r.r3 = radius[2];
          r.r4 = radius[3];
        }
      } else {
        r.r1 = r.r2 = r.r3 = r.r4 = radius;
      }
      var d = [
        ["M " + (x + r.r1) + "," + y],
        ["l " + (w - r.r1 - r.r2) + ",0"],
        ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
        ["l 0," + (h2 - r.r2 - r.r3)],
        ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
        ["l " + (r.r3 + r.r4 - w) + ",0"],
        ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
        ["l 0," + (r.r4 + r.r1 - h2)],
        ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
        ["z"]
      ];
      return d.join(" ");
    };
    return Rect4;
  }(base_default17);
  var rect_default4 = Rect2;

  // node_modules/@antv/g-svg/esm/shape/text.js
  var LETTER_SPACING = 0.3;
  var BASELINE_MAP = {
    top: "before-edge",
    middle: "central",
    bottom: "after-edge",
    alphabetic: "baseline",
    hanging: "hanging"
  };
  var BASELINE_MAP_FOR_FIREFOX = {
    top: "text-before-edge",
    middle: "central",
    bottom: "text-after-edge",
    alphabetic: "alphabetic",
    hanging: "hanging"
  };
  var ANCHOR_MAP = {
    left: "left",
    start: "left",
    center: "middle",
    right: "end",
    end: "end"
  };
  var Text3 = function(_super) {
    __extends9(Text4, _super);
    function Text4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text4.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign9(__assign9({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text4.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each_default(targetAttrs || attrs, function(value, attr) {
        if (attr === "text") {
          _this._setText("" + value);
        } else if (attr === "matrix" && value) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text4.prototype._setFont = function() {
      var el = this.get("el");
      var _a4 = this.attr(), textBaseline = _a4.textBaseline, textAlign = _a4.textAlign;
      var browser3 = detect();
      if (browser3 && browser3.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text4.prototype._setText = function(text) {
      var el = this.get("el");
      var _a4 = this.attr(), x = _a4.x, _b = _a4.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text) {
        el.innerHTML = "";
      } else if (~text.indexOf("\n")) {
        var textArr = text.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each_default(textArr, function(segment, i) {
          if (i === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text;
      }
    };
    return Text4;
  }(base_default17);
  var text_default5 = Text3;

  // node_modules/@antv/g-svg/esm/defs/gradient.js
  var regexLG3 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG3 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexColorStop3 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
  function addStop2(steps) {
    var arr = steps.match(regexColorStop3);
    if (!arr) {
      return "";
    }
    var stops = "";
    arr.sort(function(a, b) {
      a = a.split(":");
      b = b.split(":");
      return Number(a[0]) - Number(b[0]);
    });
    each_default(arr, function(item) {
      item = item.split(":");
      stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
    });
    return stops;
  }
  function parseLineGradient2(color2, el) {
    var arr = regexLG3.exec(color2);
    var angle3 = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
    var steps = arr[2];
    var start;
    var end;
    if (angle3 >= 0 && angle3 < 0.5 * Math.PI) {
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 1
      };
    } else if (0.5 * Math.PI <= angle3 && angle3 < Math.PI) {
      start = {
        x: 1,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
    } else if (Math.PI <= angle3 && angle3 < 1.5 * Math.PI) {
      start = {
        x: 1,
        y: 1
      };
      end = {
        x: 0,
        y: 0
      };
    } else {
      start = {
        x: 0,
        y: 1
      };
      end = {
        x: 1,
        y: 0
      };
    }
    var tanTheta = Math.tan(angle3);
    var tanTheta2 = tanTheta * tanTheta;
    var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
    var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
    el.setAttribute("x1", start.x);
    el.setAttribute("y1", start.y);
    el.setAttribute("x2", x);
    el.setAttribute("y2", y);
    el.innerHTML = addStop2(steps);
  }
  function parseRadialGradient2(color2, self2) {
    var arr = regexRG3.exec(color2);
    var cx = parseFloat(arr[1]);
    var cy = parseFloat(arr[2]);
    var r = parseFloat(arr[3]);
    var steps = arr[4];
    self2.setAttribute("cx", cx);
    self2.setAttribute("cy", cy);
    self2.setAttribute("r", r);
    self2.innerHTML = addStop2(steps);
  }
  var Gradient = function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id = unique_id_default("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient2(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient2(cfg, el);
      }
      el.setAttribute("id", id);
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }();
  var gradient_default = Gradient;

  // node_modules/@antv/g-svg/esm/defs/shadow.js
  var ATTR_MAP = {
    shadowColor: "color",
    shadowOpacity: "opacity",
    shadowBlur: "blur",
    shadowOffsetX: "dx",
    shadowOffsetY: "dy"
  };
  var SHADOW_DIMENSION = {
    x: "-40%",
    y: "-40%",
    width: "200%",
    height: "200%"
  };
  var Shadow = function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each_default(SHADOW_DIMENSION, function(v, k) {
        el.setAttribute(k, v);
      });
      this.el = el;
      this.id = unique_id_default("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config = this.cfg;
      each_default(Object.keys(config), function(attr) {
        if (config[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value) {
      var config = this.cfg;
      config[ATTR_MAP[name]] = value;
      this._parseShadow(config, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config, el) {
      var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }();
  var shadow_default = Shadow;

  // node_modules/@antv/g-svg/esm/defs/arrow.js
  var Arrow = function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id = unique_id_default("marker_");
      el.setAttribute("id", id);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent.setAttribute("refY", "" + 5);
    };
    Arrow2.prototype._setMarker = function(r, el) {
      var parent = this.el;
      var path = this.cfg.path;
      var d = this.cfg.d;
      if (is_array_default(path)) {
        path = path.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path);
      parent.appendChild(el);
      if (d) {
        parent.setAttribute("refX", "" + d / r);
      }
    };
    Arrow2.prototype.update = function(fill4) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill4);
      } else {
        child.setAttribute("fill", fill4);
      }
    };
    return Arrow2;
  }();
  var arrow_default = Arrow;

  // node_modules/@antv/g-svg/esm/defs/clip.js
  var Clip = function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = unique_id_default("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }();
  var clip_default = Clip;

  // node_modules/@antv/g-svg/esm/defs/pattern.js
  var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var Pattern = function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id = unique_id_default("pattern_");
      el.id = id;
      this.el = el;
      this.id = id;
      this.cfg = cfg;
      var arr = regexPR2.exec(cfg);
      var source = arr[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }();
  var pattern_default = Pattern;

  // node_modules/@antv/g-svg/esm/defs/index.js
  var Defs = function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id = unique_id_default("defs_");
      el.id = id;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].match(type, attr)) {
          result = children[i].id;
          break;
        }
      }
      return result;
    };
    Defs2.prototype.findById = function(id) {
      var children = this.children;
      var flag = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].id === id) {
          flag = children[i];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new arrow_default(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient2 = new gradient_default(cfg);
      this.el.appendChild(gradient2.el);
      this.add(gradient2);
      return gradient2.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new arrow_default(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new shadow_default(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern = new pattern_default(cfg);
      this.el.appendChild(pattern.el);
      this.add(pattern);
      return pattern.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip2 = new clip_default(cfg);
      this.el.appendChild(clip2.el);
      this.add(clip2);
      return clip2.id;
    };
    return Defs2;
  }();
  var defs_default = Defs;

  // node_modules/@antv/g-svg/esm/canvas.js
  var Canvas4 = function(_super) {
    __extends9(Canvas5, _super);
    function Canvas5(cfg) {
      return _super.call(this, __assign9(__assign9({}, cfg), {
        autoDraw: true,
        renderer: "svg"
      })) || this;
    }
    Canvas5.prototype.getShapeBase = function() {
      return shape_exports2;
    };
    Canvas5.prototype.getGroupBase = function() {
      return group_default5;
    };
    Canvas5.prototype.getShape = function(x, y, ev) {
      var target = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target.tagName]) {
        var parent_1 = target.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target;
      });
    };
    Canvas5.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new defs_default(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas5.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas5.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren2(context, children);
      }
    };
    return Canvas5;
  }(canvas_default);
  var canvas_default4 = Canvas4;

  // node_modules/@antv/g-svg/esm/index.js
  var version3 = "0.5.6";

  // node_modules/@antv/g2/esm/geometry/shape/util/get-path-points.js
  function isValueEmpty(value) {
    if (value) {
      return false;
    }
    return value === null || value === void 0 || isNaN(value);
  }
  function isYNil(point) {
    if (is_array_default(point)) {
      return isValueEmpty(point[1].y);
    }
    var value = point.y;
    return is_array_default(value) ? isValueEmpty(value[0]) : isValueEmpty(value);
  }
  function getPathPoints(points, connectNulls, showSinglePoint) {
    if (connectNulls === void 0) {
      connectNulls = false;
    }
    if (showSinglePoint === void 0) {
      showSinglePoint = true;
    }
    if (!points.length || points.length === 1 && !showSinglePoint) {
      return [];
    }
    if (connectNulls) {
      var filtered = [];
      for (var i = 0, len3 = points.length; i < len3; i++) {
        var point = points[i];
        if (!isYNil(point)) {
          filtered.push(point);
        }
      }
      return [filtered];
    }
    var result = [];
    var tmp = [];
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var point = points[i];
      if (isYNil(point)) {
        if (tmp.length) {
          if (!(tmp.length === 1 && !showSinglePoint)) {
            result.push(tmp);
          }
          tmp = [];
        }
      } else {
        tmp.push(point);
      }
    }
    if (tmp.length) {
      result.push(tmp);
    }
    return result;
  }
  function getViolinPath(points) {
    var path = [];
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      if (point) {
        var action = i === 0 ? "M" : "L";
        path.push([action, point.x, point.y]);
      }
    }
    var first = points[0];
    if (first) {
      path.push(["L", first.x, first.y]);
      path.push(["z"]);
    }
    return path;
  }
  function getSmoothViolinPath(points) {
    var half = points.length / 2;
    var leftPoints = [];
    var rightPoints = [];
    for (var i = 0; i < points.length; i++) {
      if (i < half) {
        leftPoints.push(points[i]);
      } else {
        rightPoints.push(points[i]);
      }
    }
    var leftPath = getSplinePath(leftPoints, false);
    var rightPath = getSplinePath(rightPoints, false);
    if (rightPoints.length) {
      leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
    }
    rightPath.shift();
    var path = leftPath.concat(rightPath);
    if (leftPoints.length) {
      path.push(["L", leftPoints[0].x, leftPoints[0].y]);
    }
    path.push(["z"]);
    return path;
  }

  // node_modules/@antv/g2/esm/geometry/shape/util/get-style.js
  function getStyle2(cfg, isStroke, isFill, sizeName) {
    if (sizeName === void 0) {
      sizeName = "";
    }
    var _a4 = cfg.style, style = _a4 === void 0 ? {} : _a4, defaultStyle = cfg.defaultStyle, color2 = cfg.color, size3 = cfg.size;
    var attrs = __assign(__assign({}, defaultStyle), style);
    if (color2) {
      if (isStroke) {
        if (!style.stroke) {
          attrs.stroke = color2;
        }
      }
      if (isFill) {
        if (!style.fill) {
          attrs.fill = color2;
        }
      }
    }
    if (sizeName && is_nil_default(style[sizeName]) && !is_nil_default(size3)) {
      attrs[sizeName] = size3;
    }
    return attrs;
  }
  function getBackgroundRectStyle(cfg) {
    return deep_mix_default({}, {
      fill: "#CCD6EC",
      fillOpacity: 0.3
    }, get_default(cfg, ["background", "style"]));
  }

  // node_modules/@antv/g2/esm/geometry/shape/util/split-points.js
  function splitPoints(obj) {
    var x = obj.x;
    var y = is_array_default(obj.y) ? obj.y : [obj.y];
    return y.map(function(eachY, index) {
      return {
        x: is_array_default(x) ? x[index] : x,
        y: eachY
      };
    });
  }

  // node_modules/@antv/g2/esm/geometry/shape/line/util.js
  var LineSymbols = {
    line: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    dot: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    dash: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["L", x + r, y]
      ];
    },
    smooth: function(x, y, r) {
      return [
        ["M", x - r, y],
        ["A", r / 2, r / 2, 0, 1, 1, x, y],
        ["A", r / 2, r / 2, 0, 1, 0, x + r, y]
      ];
    },
    hv: function(x, y, r) {
      return [
        ["M", x - r - 1, y - 2.5],
        ["L", x, y - 2.5],
        ["L", x, y + 2.5],
        ["L", x + r + 1, y + 2.5]
      ];
    },
    vh: function(x, y, r) {
      return [
        ["M", x - r - 1, y + 2.5],
        ["L", x, y + 2.5],
        ["L", x, y - 2.5],
        ["L", x + r + 1, y - 2.5]
      ];
    },
    hvh: function(x, y, r) {
      return [
        ["M", x - (r + 1), y + 2.5],
        ["L", x - r / 2, y + 2.5],
        ["L", x - r / 2, y - 2.5],
        ["L", x + r / 2, y - 2.5],
        ["L", x + r / 2, y + 2.5],
        ["L", x + r + 1, y + 2.5]
      ];
    },
    vhv: function(x, y) {
      return [
        ["M", x - 5, y + 2.5],
        ["L", x - 5, y],
        ["L", x, y],
        ["L", x, y - 3],
        ["L", x, y + 3],
        ["L", x + 6.5, y + 3]
      ];
    }
  };
  function getLineMarker(markerCfg, shapeType) {
    var color2 = markerCfg.color;
    return {
      symbol: LineSymbols[shapeType],
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color2
      }
    };
  }

  // node_modules/@antv/g2/esm/geometry/shape/line/index.js
  function getShapeAttrs(cfg, smooth, constraint) {
    var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
    var shapeAttrs = getStyle2(cfg, true, false, "lineWidth");
    var points = getPathPoints(cfg.points, connectNulls, showSinglePoint);
    var path = [];
    for (var i = 0, len3 = points.length; i < len3; i++) {
      var eachLinePoints = points[i];
      path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
    }
    shapeAttrs.path = path;
    return shapeAttrs;
  }
  function getSinglePath(points, isInCircle, smooth, constraint, style) {
    if (points.length === 1) {
      return [
        ["M", points[0].x, points[0].y - style.lineWidth / 2],
        ["L", points[0].x, points[0].y],
        ["L", points[0].x, points[0].y + style.lineWidth / 2]
      ];
    }
    var path;
    if (!smooth) {
      path = getLinePath2(points, false);
      if (isInCircle) {
        path.push(["Z"]);
      }
    } else {
      if (isInCircle && points.length) {
        points.push({ x: points[0].x, y: points[0].y });
      }
      path = getSplinePath(points, false, constraint);
    }
    return path;
  }
  function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
    var topPoints = [];
    var bottomPoints = [];
    each_default(points, function(point) {
      var result = splitPoints(point);
      topPoints.push(result[1]);
      bottomPoints.push(result[0]);
    });
    var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
    var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
    if (isStack) {
      return topPath;
    }
    return topPath.concat(bottomPath);
  }
  function getPath(points, isInCircle, isStack, smooth, constraint, style) {
    if (points.length) {
      var first = points[0];
      return is_array_default(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
    }
    return [];
  }
  var LineShapeFactory = registerShapeFactory("line", {
    defaultShapeType: "line"
  });
  each_default(["line", "dot", "dash", "smooth"], function(shapeType) {
    registerShape("line", shapeType, {
      draw: function(cfg, container) {
        var smooth = shapeType === "smooth";
        var constraint;
        if (smooth) {
          var _a4 = this.coordinate, start = _a4.start, end = _a4.end;
          constraint = [
            [start.x, end.y],
            [end.x, start.y]
          ];
        }
        var attrs = getShapeAttrs(cfg, smooth, constraint);
        var shape = container.addShape({
          type: "path",
          attrs,
          name: "line",
          capture: !smooth
        });
        return shape;
      },
      getMarker: function(markerCfg) {
        return getLineMarker(markerCfg, shapeType);
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/path.js
  var Path3 = function(_super) {
    __extends(Path4, _super);
    function Path4(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "path";
      _this.shapeType = "line";
      var _a4 = cfg.connectNulls, connectNulls = _a4 === void 0 ? false : _a4, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
      _this.connectNulls = connectNulls;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Path4.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyData = new Map();
      var keyIndex = new Map();
      var keys2 = [];
      var index = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var key = this.getElementId(mappingData);
        keys2.push(key);
        keyData.set(key, mappingData);
        keyIndex.set(key, index);
        index++;
      }
      this.elements = new Array(index);
      var _a4 = diff(this.lastElementsMap, keys2), added = _a4.added, updated = _a4.updated, removed = _a4.removed;
      for (var _i = 0, added_1 = added; _i < added_1.length; _i++) {
        var key = added_1[_i];
        var mappingData = keyData.get(key);
        var shapeFactory = this.getShapeFactory();
        var shapeCfg = this.getShapeInfo(mappingData);
        var i = keyIndex.get(key);
        var element = new element_default3({
          shapeFactory,
          container: this.container,
          offscreenGroup: this.getOffscreenGroup(),
          elementIndex: i
        });
        element.geometry = this;
        element.animate = this.animateOption;
        element.draw(shapeCfg, isUpdate);
        this.elementsMap[key] = element;
        this.elements[i] = element;
      }
      for (var _b = 0, updated_1 = updated; _b < updated_1.length; _b++) {
        var key = updated_1[_b];
        var mappingData = keyData.get(key);
        var element = this.lastElementsMap[key];
        var i = keyIndex.get(key);
        var shapeCfg = this.getShapeInfo(mappingData);
        var preShapeCfg = element.getModel();
        if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
          element.animate = this.animateOption;
          element.update(shapeCfg);
        }
        this.elementsMap[key] = element;
        this.elements[i] = element;
      }
      for (var _c = 0, removed_1 = removed; _c < removed_1.length; _c++) {
        var key = removed_1[_c];
        var element = this.lastElementsMap[key];
        element.animate = this.animateOption;
        element.destroy();
      }
    };
    Path4.prototype.getPointsAndData = function(mappingData) {
      var points = [];
      var data = [];
      for (var i = 0, len3 = mappingData.length; i < len3; i++) {
        var obj = mappingData[i];
        points.push({
          x: obj.x,
          y: obj.y
        });
        data.push(obj[FIELD_ORIGIN]);
      }
      return {
        points,
        data
      };
    };
    Path4.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var _a4 = this.getPointsAndData(mappingData), points = _a4.points, data = _a4.data;
      shapeCfg.mappingData = mappingData;
      shapeCfg.data = data;
      shapeCfg.isStack = !!this.getAdjust("stack");
      shapeCfg.points = points;
      shapeCfg.connectNulls = this.connectNulls;
      shapeCfg.showSinglePoint = this.showSinglePoint;
      return shapeCfg;
    };
    return Path4;
  }(base_default14);
  var path_default6 = Path3;

  // node_modules/@antv/g2/esm/geometry/shape/area/util.js
  function getPath2(points, isInCircle, smooth, registeredShape, constraint) {
    var path = [];
    if (points.length) {
      var topLinePoints_1 = [];
      var bottomLinePoints_1 = [];
      for (var i = 0, len3 = points.length; i < len3; i++) {
        var point = points[i];
        topLinePoints_1.push(point[1]);
        bottomLinePoints_1.push(point[0]);
      }
      bottomLinePoints_1 = bottomLinePoints_1.reverse();
      each_default([topLinePoints_1, bottomLinePoints_1], function(pointsData, index) {
        var subPath = [];
        var parsedPoints = registeredShape.parsePoints(pointsData);
        var p1 = parsedPoints[0];
        if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
          subPath = index === 0 ? [
            ["M", p1.x - 0.5, p1.y],
            ["L", p1.x + 0.5, p1.y]
          ] : [
            ["L", p1.x + 0.5, p1.y],
            ["L", p1.x - 0.5, p1.y]
          ];
        } else {
          if (isInCircle) {
            parsedPoints.push({ x: p1.x, y: p1.y });
          }
          if (smooth) {
            subPath = getSplinePath(parsedPoints, false, constraint);
          } else {
            subPath = getLinePath2(parsedPoints, false);
          }
          if (index > 0) {
            subPath[0][0] = "L";
          }
        }
        path = path.concat(subPath);
      });
      path.push(["Z"]);
    }
    return path;
  }
  function getShapeAttrs2(cfg, isStroke, smooth, registeredShape, constraint) {
    var attrs = getStyle2(cfg, isStroke, !isStroke, "lineWidth");
    var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points = cfg.points, showSinglePoint = cfg.showSinglePoint;
    var pathPoints = getPathPoints(points, connectNulls, showSinglePoint);
    var path = [];
    for (var i = 0, len3 = pathPoints.length; i < len3; i++) {
      var eachPoints = pathPoints[i];
      path = path.concat(getPath2(eachPoints, isInCircle, smooth, registeredShape, constraint));
    }
    attrs.path = path;
    return attrs;
  }
  function getConstraint(coordinate) {
    var start = coordinate.start, end = coordinate.end;
    return [
      [start.x, end.y],
      [end.x, start.y]
    ];
  }

  // node_modules/@antv/g2/esm/geometry/shape/area/index.js
  var AreaShapeFactory = registerShapeFactory("area", {
    defaultShapeType: "area",
    getDefaultPoints: function(pointInfo) {
      var x = pointInfo.x, y0 = pointInfo.y0;
      var y = is_array_default(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
      return y.map(function(yItem) {
        return {
          x,
          y: yItem
        };
      });
    }
  });
  registerShape("area", "area", {
    draw: function(cfg, container) {
      var attrs = getShapeAttrs2(cfg, false, false, this);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/area.js
  var Area = function(_super) {
    __extends(Area2, _super);
    function Area2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "area";
      _this.shapeType = "area";
      _this.generatePoints = true;
      _this.startOnZero = true;
      var _a4 = cfg.startOnZero, startOnZero = _a4 === void 0 ? true : _a4, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
      _this.startOnZero = startOnZero;
      _this.sortable = sortable;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Area2.prototype.getPointsAndData = function(mappingData) {
      var points = [];
      var data = [];
      for (var i = 0, len3 = mappingData.length; i < len3; i++) {
        var obj = mappingData[i];
        points.push(obj.points);
        data.push(obj[FIELD_ORIGIN]);
      }
      return {
        points,
        data
      };
    };
    Area2.prototype.getYMinValue = function() {
      if (this.startOnZero) {
        return _super.prototype.getYMinValue.call(this);
      }
      var yScale = this.getYScale();
      return yScale.min;
    };
    return Area2;
  }(path_default6);
  var area_default = Area;

  // node_modules/@antv/g2/esm/geometry/shape/edge/index.js
  var EdgeShapeFactory = registerShapeFactory("edge", {
    defaultShapeType: "line",
    getDefaultPoints: function(pointInfo) {
      return splitPoints(pointInfo);
    }
  });
  registerShape("edge", "line", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var path = getLinePath2(this.parsePoints(cfg.points), this.coordinate.isPolar);
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/edge.js
  var Edge = function(_super) {
    __extends(Edge2, _super);
    function Edge2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "edge";
      _this.shapeType = "edge";
      _this.generatePoints = true;
      return _this;
    }
    return Edge2;
  }(base_default14);
  var edge_default = Edge;

  // node_modules/@antv/g2/esm/geometry/heatmap.js
  var Heatmap = function(_super) {
    __extends(Heatmap2, _super);
    function Heatmap2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      _this.paletteCache = {};
      return _this;
    }
    Heatmap2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var range5 = this.prepareRange(mappingData);
        var radius = this.prepareSize();
        var blur_1 = get_default(this.styleOption, ["cfg", "shadowBlur"]);
        if (!is_number_default(blur_1)) {
          blur_1 = radius / 2;
        }
        this.prepareGreyScaleBlurredCircle(radius, blur_1);
        this.drawWithRange(mappingData, range5, radius, blur_1);
      }
    };
    Heatmap2.prototype.color = function(field, cfg) {
      this.createAttrOption("color", field, typeof cfg !== "function" ? cfg : "");
      return this;
    };
    Heatmap2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.clearShadowCanvasCtx();
      this.paletteCache = {};
    };
    Heatmap2.prototype.prepareRange = function(data) {
      var colorAttr = this.getAttribute("color");
      var colorField = colorAttr.getFields()[0];
      var min7 = Infinity;
      var max7 = -Infinity;
      data.forEach(function(row) {
        var value = row[FIELD_ORIGIN][colorField];
        if (value > max7) {
          max7 = value;
        }
        if (value < min7) {
          min7 = value;
        }
      });
      if (min7 === max7) {
        min7 = max7 - 1;
      }
      return [min7, max7];
    };
    Heatmap2.prototype.prepareSize = function() {
      var radius = this.getDefaultValue("size");
      if (!is_number_default(radius)) {
        radius = this.getDefaultSize();
      }
      return radius;
    };
    Heatmap2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      var r2 = radius + blur;
      var ctx3 = grayScaleBlurredCanvas.getContext("2d");
      grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
      ctx3.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
      ctx3.shadowOffsetX = ctx3.shadowOffsetY = r2 * 2;
      ctx3.shadowBlur = blur;
      ctx3.shadowColor = "black";
      ctx3.beginPath();
      ctx3.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
      ctx3.closePath();
      ctx3.fill();
    };
    Heatmap2.prototype.drawWithRange = function(data, range5, radius, blur) {
      var _a4 = this.coordinate, start = _a4.start, end = _a4.end;
      var width = this.coordinate.getWidth();
      var height = this.coordinate.getHeight();
      var colorAttr = this.getAttribute("color");
      var valueField = colorAttr.getFields()[0];
      this.clearShadowCanvasCtx();
      var ctx3 = this.getShadowCanvasCtx();
      if (range5) {
        data = data.filter(function(row) {
          return row[FIELD_ORIGIN][valueField] <= range5[1] && row[FIELD_ORIGIN][valueField] >= range5[0];
        });
      }
      var scale5 = this.scales[valueField];
      for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
        var obj = data_1[_i];
        var _b = this.getDrawCfg(obj), x = _b.x, y = _b.y;
        var alpha = scale5.scale(obj[FIELD_ORIGIN][valueField]);
        this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx3);
      }
      var colored = ctx3.getImageData(0, 0, width, height);
      this.clearShadowCanvasCtx();
      this.colorize(colored);
      ctx3.putImageData(colored, 0, 0);
      var imageShape = this.getImageShape();
      imageShape.attr("x", start.x);
      imageShape.attr("y", end.y);
      imageShape.attr("width", width);
      imageShape.attr("height", height);
      imageShape.attr("img", ctx3.canvas);
      imageShape.set("origin", this.getShapeInfo(data));
    };
    Heatmap2.prototype.getDefaultSize = function() {
      var position = this.getAttribute("position");
      var coordinate = this.coordinate;
      return Math.min(coordinate.getWidth() / (position.scales[0].ticks.length * 4), coordinate.getHeight() / (position.scales[1].ticks.length * 4));
    };
    Heatmap2.prototype.clearShadowCanvasCtx = function() {
      var ctx3 = this.getShadowCanvasCtx();
      ctx3.clearRect(0, 0, ctx3.canvas.width, ctx3.canvas.height);
    };
    Heatmap2.prototype.getShadowCanvasCtx = function() {
      var canvas = this.shadowCanvas;
      if (!canvas) {
        canvas = document.createElement("canvas");
        this.shadowCanvas = canvas;
      }
      canvas.width = this.coordinate.getWidth();
      canvas.height = this.coordinate.getHeight();
      return canvas.getContext("2d");
    };
    Heatmap2.prototype.getGrayScaleBlurredCanvas = function() {
      if (!this.grayScaleBlurredCanvas) {
        this.grayScaleBlurredCanvas = document.createElement("canvas");
      }
      return this.grayScaleBlurredCanvas;
    };
    Heatmap2.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx3) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      ctx3.globalAlpha = alpha;
      ctx3.drawImage(grayScaleBlurredCanvas, x - r, y - r);
    };
    Heatmap2.prototype.colorize = function(img) {
      var colorAttr = this.getAttribute("color");
      var pixels = img.data;
      var paletteCache = this.paletteCache;
      for (var i = 3; i < pixels.length; i += 4) {
        var alpha = pixels[i];
        if (is_number_default(alpha)) {
          var palette = paletteCache[alpha] ? paletteCache[alpha] : esm_default2.rgb2arr(colorAttr.gradient(alpha / 256));
          pixels[i - 3] = palette[0];
          pixels[i - 2] = palette[1];
          pixels[i - 1] = palette[2];
          pixels[i] = alpha;
        }
      }
    };
    Heatmap2.prototype.getImageShape = function() {
      var imageShape = this.imageShape;
      if (imageShape) {
        return imageShape;
      }
      var container = this.container;
      imageShape = container.addShape({
        type: "image",
        attrs: {}
      });
      this.imageShape = imageShape;
      return imageShape;
    };
    Heatmap2.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var data = mappingData.map(function(obj) {
        return obj[FIELD_ORIGIN];
      });
      return __assign(__assign({}, shapeCfg), { mappingData, data });
    };
    return Heatmap2;
  }(base_default14);
  var heatmap_default = Heatmap;

  // node_modules/@antv/g2/esm/geometry/shape/interval/util.js
  function getRectPoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
    var yMin;
    var yMax;
    if (is_array_default(y)) {
      yMin = y[0], yMax = y[1];
    } else {
      yMin = y0;
      yMax = y;
    }
    var xMin;
    var xMax;
    if (is_array_default(x)) {
      xMin = x[0], xMax = x[1];
    } else {
      xMin = x - size3 / 2;
      xMax = x + size3 / 2;
    }
    var points = [
      { x: xMin, y: yMin },
      { x: xMin, y: yMax }
    ];
    points.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
    return points;
  }
  function getRectPath(points, isClosed) {
    if (isClosed === void 0) {
      isClosed = true;
    }
    var path = [];
    var firstPoint = points[0];
    path.push(["M", firstPoint.x, firstPoint.y]);
    for (var i = 1, len3 = points.length; i < len3; i++) {
      path.push(["L", points[i].x, points[i].y]);
    }
    if (isClosed) {
      path.push(["L", firstPoint.x, firstPoint.y]);
      path.push(["z"]);
    }
    return path;
  }
  function parseRadius3(radius, minLength) {
    var r1 = 0;
    var r2 = 0;
    var r3 = 0;
    var r4 = 0;
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r1 = r2 = r3 = r4 = radius[0];
      } else if (radius.length === 2) {
        r1 = r3 = radius[0];
        r2 = r4 = radius[1];
      } else if (radius.length === 3) {
        r1 = radius[0];
        r2 = r4 = radius[1];
        r3 = radius[2];
      } else {
        r1 = radius[0];
        r2 = radius[1];
        r3 = radius[2];
        r4 = radius[3];
      }
    } else {
      r1 = r2 = r3 = r4 = radius;
    }
    if (r1 + r2 > minLength) {
      r1 = r1 ? minLength / (1 + r2 / r1) : 0;
      r2 = minLength - r1;
    }
    if (r3 + r4 > minLength) {
      r3 = r3 ? minLength / (1 + r4 / r3) : 0;
      r4 = minLength - r3;
    }
    return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
  }
  function getBackgroundRectPath(cfg, points, coordinate) {
    var path = [];
    if (coordinate.isRect) {
      var p0 = coordinate.isTransposed ? { x: coordinate.start.x, y: points[0].y } : { x: points[0].x, y: coordinate.start.y };
      var p1 = coordinate.isTransposed ? { x: coordinate.end.x, y: points[2].y } : { x: points[3].x, y: coordinate.end.y };
      var radius = get_default(cfg, ["background", "style", "radius"]);
      if (radius) {
        var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
        var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();
        var _a4 = parseRadius3(radius, Math.min(width, height)), r1 = _a4[0], r2 = _a4[1], r3 = _a4[2], r4 = _a4[3];
        path.push(["M", p0.x, p1.y + r1]);
        r1 !== 0 && path.push(["A", r1, r1, 0, 0, 1, p0.x + r1, p1.y]);
        path.push(["L", p1.x - r2, p1.y]);
        r2 !== 0 && path.push(["A", r2, r2, 0, 0, 1, p1.x, p1.y + r2]);
        path.push(["L", p1.x, p0.y - r3]);
        r3 !== 0 && path.push(["A", r3, r3, 0, 0, 1, p1.x - r3, p0.y]);
        path.push(["L", p0.x + r4, p0.y]);
        r4 !== 0 && path.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
      } else {
        path.push(["M", p0.x, p0.y]);
        path.push(["L", p1.x, p0.y]);
        path.push(["L", p1.x, p1.y]);
        path.push(["L", p0.x, p1.y]);
        path.push(["L", p0.x, p0.y]);
      }
      path.push(["z"]);
    }
    if (coordinate.isPolar) {
      var center = coordinate.getCenter();
      var _b = getAngle2(cfg, coordinate), startAngle = _b.startAngle, endAngle = _b.endAngle;
      if (coordinate.type !== "theta" && !coordinate.isTransposed) {
        path = getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);
      } else {
        var pow4 = function(v) {
          return Math.pow(v, 2);
        };
        var r1 = Math.sqrt(pow4(center.x - points[0].x) + pow4(center.y - points[0].y));
        var r2 = Math.sqrt(pow4(center.x - points[2].x) + pow4(center.y - points[2].y));
        path = getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);
      }
    }
    return path;
  }
  function getIntervalRectPath(points, lineCap, coor) {
    var width = coor.getWidth();
    var height = coor.getHeight();
    var isRect = coor.type === "rect";
    var path = [];
    var r = (points[2].x - points[1].x) / 2;
    var ry = coor.isTransposed ? r * height / width : r * width / height;
    if (lineCap === "round") {
      if (isRect) {
        path.push(["M", points[0].x, points[0].y + ry]);
        path.push(["L", points[1].x, points[1].y - ry]);
        path.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
        path.push(["L", points[3].x, points[3].y + ry]);
        path.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
      } else {
        path.push(["M", points[0].x, points[0].y]);
        path.push(["L", points[1].x, points[1].y]);
        path.push(["A", r, r, 0, 0, 1, points[2].x, points[2].y]);
        path.push(["L", points[3].x, points[3].y]);
        path.push(["A", r, r, 0, 0, 1, points[0].x, points[0].y]);
      }
      path.push(["z"]);
    } else {
      path = getRectPath(points);
    }
    return path;
  }
  function getFunnelPath(points, nextPoints, isPyramid) {
    var path = [];
    if (!is_nil_default(nextPoints)) {
      path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
    } else if (isPyramid) {
      path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", (points[2].x + points[3].x) / 2, (points[2].y + points[3].y) / 2], ["Z"]);
    } else {
      path.push(["M", points[0].x, points[0].y], ["L", points[1].x, points[1].y], ["L", points[2].x, points[2].y], ["L", points[3].x, points[3].y], ["Z"]);
    }
    return path;
  }
  function getRectWithCornerRadius(points, coordinate, radius) {
    var _a4, _b, _c, _d;
    var p0 = points[0], p1 = points[1], p22 = points[2], p3 = points[3];
    var _e = [0, 0, 0, 0], r1 = _e[0], r2 = _e[1], r3 = _e[2], r4 = _e[3];
    if (p0.y < p1.y) {
      p1 = points[0], p0 = points[1], p3 = points[2], p22 = points[3];
      _a4 = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r4 = _a4[0], r3 = _a4[1], r2 = _a4[2], r1 = _a4[3];
    } else {
      _b = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _b[0], r2 = _b[1], r3 = _b[2], r4 = _b[3];
    }
    if (coordinate.isTransposed) {
      p0 = points[0], p3 = points[1], p22 = points[2], p1 = points[3];
      if (points[0].x > points[1].x) {
        p3 = points[0], p0 = points[1], p1 = points[2], p22 = points[3];
        _c = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _c[0], r4 = _c[1], r3 = _c[2], r2 = _c[3];
      } else {
        _d = parseRadius3(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r2 = _d[0], r3 = _d[1], r4 = _d[2], r1 = _d[3];
      }
    }
    var path = [];
    path.push(["M", p1.x, p1.y + r1]);
    r1 !== 0 && path.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
    path.push(["L", p22.x - r2, p22.y]);
    r2 !== 0 && path.push(["A", r2, r2, 0, 0, 1, p22.x, p22.y + r2]);
    path.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
    path.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    path.push(["L", p1.x, p1.y + r1]);
    path.push(["z"]);
    return path;
  }

  // node_modules/@antv/g2/esm/geometry/shape/interval/index.js
  var IntervalShapeFactory = registerShapeFactory("interval", {
    defaultShapeType: "rect",
    getDefaultPoints: function(pointInfo) {
      return getRectPoints(pointInfo);
    }
  });
  registerShape("interval", "rect", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, false, true);
      var group2 = container;
      var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
      if (backgroundCfg) {
        group2 = container.addGroup();
        var backgroundStyle = getBackgroundRectStyle(cfg);
        var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
        group2.addShape("path", {
          attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
          zIndex: -1,
          name: BACKGROUND_SHAPE
        });
      }
      var path;
      if (style.radius && this.coordinate.isRect) {
        path = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
      } else {
        path = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
      }
      var shape = group2.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return backgroundCfg ? group2 : shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
      if (isInPolar) {
        return {
          symbol: "circle",
          style: {
            r: 4.5,
            fill: color2
          }
        };
      }
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/util/shape-size.js
  function findMinDistance(arr, scale5) {
    var count2 = arr.length;
    var sourceArr = arr;
    if (is_string_default(sourceArr[0])) {
      sourceArr = arr.map(function(v) {
        return scale5.translate(v);
      });
    }
    var distance8 = sourceArr[1] - sourceArr[0];
    for (var i = 2; i < count2; i++) {
      var tmp = sourceArr[i] - sourceArr[i - 1];
      if (distance8 > tmp) {
        distance8 = tmp;
      }
    }
    return distance8;
  }
  function getDodgeCount(dataArray, dodgeBy) {
    if (dodgeBy) {
      var mergeData = flatten_default(dataArray);
      var values2 = values_of_key_default(mergeData, dodgeBy);
      return values2.length;
    }
    return dataArray.length;
  }
  function getDefaultSize(geometry) {
    var theme = geometry.theme;
    var coordinate = geometry.coordinate;
    var xScale = geometry.getXScale();
    var xValues = xScale.values;
    var dataArray = geometry.beforeMappingData;
    var count2 = xValues.length;
    var xDimensionLength = getXDimensionLength(geometry.coordinate);
    var intervalPadding = geometry.intervalPadding, dodgePadding = geometry.dodgePadding;
    var maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;
    var minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;
    var columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;
    var multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;
    var roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio;
    if (xScale.isLinear && xValues.length > 1) {
      xValues.sort();
      var interval2 = findMinDistance(xValues, xScale);
      count2 = (xScale.max - xScale.min) / interval2;
      if (xValues.length > count2) {
        count2 = xValues.length;
      }
    }
    var range5 = xScale.range;
    var normalizedSize = 1 / count2;
    var wr = 1;
    if (coordinate.isPolar) {
      if (coordinate.isTransposed && count2 > 1) {
        wr = multiplePieWidthRatio;
      } else {
        wr = roseWidthRatio;
      }
    } else {
      if (xScale.isLinear) {
        normalizedSize *= range5[1] - range5[0];
      }
      wr = columnWidthRatio;
    }
    if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
      var normalizedIntervalPadding = intervalPadding / xDimensionLength;
      normalizedSize = (1 - (count2 - 1) * normalizedIntervalPadding) / count2;
    } else {
      normalizedSize *= wr;
    }
    if (geometry.getAdjust("dodge")) {
      var dodgeAdjust = geometry.getAdjust("dodge");
      var dodgeBy = dodgeAdjust.dodgeBy;
      var dodgeCount = getDodgeCount(dataArray, dodgeBy);
      if (!is_nil_default(dodgePadding) && dodgePadding >= 0) {
        var normalizedDodgePadding = dodgePadding / xDimensionLength;
        normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
      } else if (!is_nil_default(intervalPadding) && intervalPadding >= 0) {
        normalizedSize *= wr;
        normalizedSize = normalizedSize / dodgeCount;
      } else {
        normalizedSize = normalizedSize / dodgeCount;
      }
      normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
    }
    if (!is_nil_default(maxColumnWidth) && maxColumnWidth >= 0) {
      var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
      if (normalizedSize > normalizedMaxColumnWidth) {
        normalizedSize = normalizedMaxColumnWidth;
      }
    }
    if (!is_nil_default(minColumnWidth) && minColumnWidth >= 0) {
      var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
      if (normalizedSize < normalizedMinColumnWidth) {
        normalizedSize = normalizedMinColumnWidth;
      }
    }
    return normalizedSize;
  }

  // node_modules/@antv/g2/esm/geometry/interval.js
  var Interval = function(_super) {
    __extends(Interval2, _super);
    function Interval2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "interval";
      _this.shapeType = "interval";
      _this.generatePoints = true;
      var background = cfg.background;
      _this.background = background;
      return _this;
    }
    Interval2.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, obj)[0];
        var coordinate = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      return cfg;
    };
    Interval2.prototype.adjustScale = function() {
      _super.prototype.adjustScale.call(this);
      var yScale = this.getYScale();
      if (this.coordinate.type === "theta") {
        yScale.change({
          nice: false,
          min: 0,
          max: getMaxScale(yScale)
        });
      } else {
        var scaleDefs = this.scaleDefs;
        var field = yScale.field, min7 = yScale.min, max7 = yScale.max, type = yScale.type;
        if (type !== "time") {
          if (min7 > 0 && !get_default(scaleDefs, [field, "min"])) {
            yScale.change({
              min: 0
            });
          }
          if (max7 <= 0 && !get_default(scaleDefs, [field, "max"])) {
            yScale.change({
              max: 0
            });
          }
        }
      }
    };
    Interval2.prototype.getDrawCfg = function(mappingData) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
      shapeCfg.background = this.background;
      return shapeCfg;
    };
    return Interval2;
  }(base_default14);
  var interval_default = Interval;

  // node_modules/@antv/g2/esm/geometry/line.js
  var Line5 = function(_super) {
    __extends(Line6, _super);
    function Line6(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "line";
      var _a4 = cfg.sortable, sortable = _a4 === void 0 ? false : _a4;
      _this.sortable = sortable;
      return _this;
    }
    return Line6;
  }(path_default6);
  var line_default10 = Line5;

  // node_modules/@antv/g2/esm/geometry/shape/point/util.js
  var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
  var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
  function drawPoints(shape, cfg, container, shapeName, isStroke) {
    var style = getStyle2(cfg, isStroke, !isStroke, "r");
    var points = shape.parsePoints(cfg.points);
    var pointPosition = points[0];
    if (cfg.isStack) {
      pointPosition = points[1];
    } else if (points.length > 1) {
      var group2 = container.addGroup();
      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        group2.addShape({
          type: "marker",
          attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point)
        });
      }
      return group2;
    }
    return container.addShape({
      type: "marker",
      attrs: __assign(__assign(__assign({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
    });
  }

  // node_modules/@antv/g2/esm/geometry/shape/point/index.js
  var PointShapeFactory = registerShapeFactory("point", {
    defaultShapeType: "hollow-circle",
    getDefaultPoints: function(pointInfo) {
      return splitPoints(pointInfo);
    }
  });
  each_default(SHAPES, function(shapeName) {
    registerShape("point", "hollow-" + shapeName, {
      draw: function(cfg, container) {
        return drawPoints(this, cfg, container, shapeName, true);
      },
      getMarker: function(markerCfg) {
        var color2 = markerCfg.color;
        return {
          symbol: MarkerSymbols[shapeName] || shapeName,
          style: {
            r: 4.5,
            stroke: color2,
            fill: null
          }
        };
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/point.js
  var Point = function(_super) {
    __extends(Point2, _super);
    function Point2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "point";
      _this.shapeType = "point";
      _this.generatePoints = true;
      return _this;
    }
    Point2.prototype.getDrawCfg = function(mappingDatum) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
      return __assign(__assign({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
    };
    return Point2;
  }(base_default14);
  var point_default = Point;

  // node_modules/@antv/g2/esm/geometry/shape/polygon/index.js
  function getPath3(points) {
    var flag = points[0];
    var i = 1;
    var path = [["M", flag.x, flag.y]];
    while (i < points.length) {
      var c = points[i];
      if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
        path.push(["L", c.x, c.y]);
        if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
          flag = points[i + 1];
          path.push(["Z"]);
          path.push(["M", flag.x, flag.y]);
          i++;
        }
      }
      i++;
    }
    if (!is_equal_default(last(path), flag)) {
      path.push(["L", flag.x, flag.y]);
    }
    path.push(["Z"]);
    return path;
  }
  var PolygonShapeFactory = registerShapeFactory("polygon", {
    defaultShapeType: "polygon",
    getDefaultPoints: function(pointInfo) {
      var points = [];
      each_default(pointInfo.x, function(subX, index) {
        var subY = pointInfo.y[index];
        points.push({
          x: subX,
          y: subY
        });
      });
      return points;
    }
  });
  registerShape("polygon", "polygon", {
    draw: function(cfg, container) {
      if (!is_empty_default(cfg.points)) {
        var shapeAttrs = getStyle2(cfg, true, true);
        var path = this.parsePath(getPath3(cfg.points));
        return container.addShape("path", {
          attrs: __assign(__assign({}, shapeAttrs), { path }),
          name: "polygon"
        });
      }
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/polygon.js
  var Polygon3 = function(_super) {
    __extends(Polygon4, _super);
    function Polygon4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.shapeType = "polygon";
      _this.generatePoints = true;
      return _this;
    }
    Polygon4.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var x = cfg.x;
      var y = cfg.y;
      var temp;
      if (!(is_array_default(x) && is_array_default(y))) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xCount = xScale.values.length;
        var yCount = yScale.values.length;
        var xOffset = 0.5 * 1 / xCount;
        var yOffset = 0.5 * 1 / yCount;
        if (xScale.isCategory && yScale.isCategory) {
          x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
          y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
        } else if (is_array_default(x)) {
          temp = x;
          x = [temp[0], temp[0], temp[1], temp[1]];
          y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
        } else if (is_array_default(y)) {
          temp = y;
          y = [temp[0], temp[1], temp[1], temp[0]];
          x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
        }
        cfg.x = x;
        cfg.y = y;
      }
      return cfg;
    };
    return Polygon4;
  }(base_default14);
  var polygon_default6 = Polygon3;

  // node_modules/@antv/g2/esm/geometry/shape/schema/index.js
  var SchemaShapeFactory = registerShapeFactory("schema", {
    defaultShapeType: ""
  });

  // node_modules/@antv/g2/esm/geometry/schema.js
  var Schema = function(_super) {
    __extends(Schema2, _super);
    function Schema2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "schema";
      _this.shapeType = "schema";
      _this.generatePoints = true;
      return _this;
    }
    Schema2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      return cfg;
    };
    return Schema2;
  }(base_default14);
  var schema_default = Schema;

  // node_modules/@antv/g2/esm/geometry/shape/violin/index.js
  function normalizeSize(arr) {
    if (!is_array_default(arr)) {
      return [];
    }
    var maxValue = max_default(arr);
    return map_default(arr, function(num) {
      return num / maxValue;
    });
  }
  var ViolinShapeFactory = registerShapeFactory("violin", {
    defaultShapeType: "violin",
    getDefaultPoints: function(pointInfo) {
      var radius = pointInfo.size / 2;
      var points = [];
      var sizeArr = normalizeSize(pointInfo._size);
      each_default(pointInfo.y, function(y, index) {
        var offset = sizeArr[index] * radius;
        var isMin = index === 0;
        var isMax = index === pointInfo.y.length - 1;
        points.push({
          isMin,
          isMax,
          x: pointInfo.x - offset,
          y
        });
        points.unshift({
          isMin,
          isMax,
          x: pointInfo.x + offset,
          y
        });
      });
      return points;
    }
  });
  registerShape("violin", "violin", {
    draw: function(cfg, container) {
      var shapeAttrs = getStyle2(cfg, true, true);
      var path = this.parsePath(getViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, shapeAttrs), { path }),
        name: "violin"
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/violin.js
  var Violin = function(_super) {
    __extends(Violin2, _super);
    function Violin2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      _this.shapeType = "violin";
      _this.generatePoints = true;
      return _this;
    }
    Violin2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size3;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size3 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate);
        size3 = size3 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size3 = this.defaultSize;
      }
      cfg.size = size3;
      cfg._size = get_default(record[FIELD_ORIGIN], [this._sizeField]);
      return cfg;
    };
    Violin2.prototype.initAttributes = function() {
      var attributeOption = this.attributeOption;
      var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
      this._sizeField = sizeField;
      delete attributeOption.size;
      _super.prototype.initAttributes.call(this);
    };
    return Violin2;
  }(base_default14);
  var violin_default = Violin;

  // node_modules/@antv/g2/esm/geometry/shape/area/line.js
  registerShape("area", "line", {
    draw: function(cfg, container) {
      var attrs = getShapeAttrs2(cfg, true, false, this);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          stroke: color2,
          fill: null
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/area/smooth.js
  registerShape("area", "smooth", {
    draw: function(cfg, container) {
      var coordinate = this.coordinate;
      var attrs = getShapeAttrs2(cfg, false, true, this, getConstraint(coordinate));
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/area/smooth-line.js
  registerShape("area", "smooth-line", {
    draw: function(cfg, container) {
      var coordinate = this.coordinate;
      var attrs = getShapeAttrs2(cfg, true, true, this, getConstraint(coordinate));
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "area"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          if (r === void 0) {
            r = 5.5;
          }
          return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
        },
        style: {
          r: 5,
          stroke: color2,
          fill: null
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/edge/util.js
  function getCPath(from, to) {
    return [
      "C",
      from.x * 1 / 2 + to.x * 1 / 2,
      from.y,
      from.x * 1 / 2 + to.x * 1 / 2,
      to.y,
      to.x,
      to.y
    ];
  }
  function getQPath(to, center) {
    var points = [];
    points.push({
      x: center.x,
      y: center.y
    });
    points.push(to);
    var sub7 = ["Q"];
    each_default(points, function(point) {
      sub7.push(point.x, point.y);
    });
    return sub7;
  }

  // node_modules/@antv/g2/esm/geometry/shape/edge/arc.js
  function getArcShapePath(from, to, center) {
    var sub7 = getQPath(to, center);
    var path = [["M", from.x, from.y]];
    path.push(sub7);
    return path;
  }
  function getArcShapeWeightPath(points, center) {
    var arc1 = getQPath(points[1], center);
    var arc2 = getQPath(points[3], center);
    var path = [["M", points[0].x, points[0].y]];
    path.push(arc2);
    path.push(["L", points[3].x, points[3].y]);
    path.push(["L", points[2].x, points[2].y]);
    path.push(arc1);
    path.push(["L", points[1].x, points[1].y]);
    path.push(["L", points[0].x, points[0].y]);
    path.push(["Z"]);
    return path;
  }
  registerShape("edge", "arc", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var points = cfg.points;
      var type = points.length > 2 ? "weight" : "normal";
      var path;
      if (cfg.isInCircle) {
        var center = { x: 0, y: 1 };
        if (type === "normal") {
          path = getArcShapePath(points[0], points[1], center);
        } else {
          style.fill = style.stroke;
          path = getArcShapeWeightPath(points, center);
        }
        path = this.parsePath(path);
        return container.addShape("path", {
          attrs: __assign(__assign({}, style), { path })
        });
      } else {
        if (type === "normal") {
          points = this.parsePoints(points);
          path = getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
          return container.addShape("path", {
            attrs: __assign(__assign({}, style), { path })
          });
        } else {
          var c1 = getCPath(points[1], points[3]);
          var c2 = getCPath(points[2], points[0]);
          path = [
            ["M", points[0].x, points[0].y],
            ["L", points[1].x, points[1].y],
            c1,
            ["L", points[3].x, points[3].y],
            ["L", points[2].x, points[2].y],
            c2,
            ["Z"]
          ];
          path = this.parsePath(path);
          style.fill = style.stroke;
          return container.addShape("path", {
            attrs: __assign(__assign({}, style), { path })
          });
        }
      }
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/edge/smooth.js
  function getSmoothPath(from, to) {
    var sub7 = getCPath(from, to);
    var path = [["M", from.x, from.y]];
    path.push(sub7);
    return path;
  }
  registerShape("edge", "smooth", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var points = cfg.points;
      var path = this.parsePath(getSmoothPath(points[0], points[1]));
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/edge/vhv.js
  var CORNER_PERCENT = 1 / 3;
  function getVHVPath(from, to) {
    var points = [];
    points.push({
      x: from.x,
      y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
    });
    points.push({
      x: to.x,
      y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
    });
    points.push(to);
    var path = [["M", from.x, from.y]];
    each_default(points, function(point) {
      path.push(["L", point.x, point.y]);
    });
    return path;
  }
  registerShape("edge", "vhv", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var points = cfg.points;
      var path = this.parsePath(getVHVPath(points[0], points[1]));
      return container.addShape("path", {
        attrs: __assign(__assign({}, style), { path })
      });
    },
    getMarker: function(markerCfg) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: markerCfg.color
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/funnel.js
  registerShape("interval", "funnel", {
    getPoints: function(shapePoint) {
      shapePoint.size = shapePoint.size * 2;
      return getRectPoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, false, true);
      var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/hollow-rect.js
  registerShape("interval", "hollow-rect", {
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false);
      var group2 = container;
      var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
      if (backgroundCfg) {
        group2 = container.addGroup();
        var backgroundStyle = getBackgroundRectStyle(cfg);
        var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
        group2.addShape("path", {
          attrs: __assign(__assign({}, backgroundStyle), { path: backgroundPath }),
          zIndex: -1,
          name: BACKGROUND_SHAPE
        });
      }
      var path = this.parsePath(getRectPath(cfg.points));
      var shape = group2.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return backgroundCfg ? group2 : shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
      if (isInPolar) {
        return {
          symbol: "circle",
          style: {
            r: 4.5,
            stroke: color2,
            fill: null
          }
        };
      }
      return {
        symbol: "square",
        style: {
          r: 4,
          stroke: color2,
          fill: null
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/line.js
  function getLinePoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
    if (is_array_default(y)) {
      return y.map(function(yItem, idx) {
        return {
          x: is_array_default(x) ? x[idx] : x,
          y: yItem
        };
      });
    }
    return [
      { x, y: y0 },
      { x, y }
    ];
  }
  registerShape("interval", "line", {
    getPoints: function(shapePoint) {
      return getLinePoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false, "lineWidth");
      var newStyle = omit(__assign({}, style), ["fill"]);
      var path = this.parsePath(getRectPath(cfg.points, false));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, newStyle), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          return [
            ["M", x, y - r],
            ["L", x, y + r]
          ];
        },
        style: {
          r: 5,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/pyramid.js
  registerShape("interval", "pyramid", {
    getPoints: function(shapePoint) {
      shapePoint.size = shapePoint.size * 2;
      return getRectPoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, false, true);
      var path = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/interval/tick.js
  function getTickPoints(pointInfo) {
    var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size3 = pointInfo.size;
    var yMin;
    var yMax;
    if (is_array_default(y)) {
      yMin = y[0], yMax = y[1];
    } else {
      yMin = y0;
      yMax = y;
    }
    var xMax = x + size3 / 2;
    var xMin = x - size3 / 2;
    return [
      { x, y: yMin },
      { x, y: yMax },
      { x: xMin, y: yMin },
      { x: xMax, y: yMin },
      { x: xMin, y: yMax },
      { x: xMax, y: yMax }
    ];
  }
  function getTickPath(points) {
    return [
      ["M", points[0].x, points[0].y],
      ["L", points[1].x, points[1].y],
      ["M", points[2].x, points[2].y],
      ["L", points[3].x, points[3].y],
      ["M", points[4].x, points[4].y],
      ["L", points[5].x, points[5].y]
    ];
  }
  registerShape("interval", "tick", {
    getPoints: function(shapePoint) {
      return getTickPoints(shapePoint);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false);
      var path = this.parsePath(getTickPath(cfg.points));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path }),
        name: "interval"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          return [
            ["M", x - r / 2, y - r],
            ["L", x + r / 2, y - r],
            ["M", x, y - r],
            ["L", x, y + r],
            ["M", x - r / 2, y + r],
            ["L", x + r / 2, y + r]
          ];
        },
        style: {
          r: 5,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/line/step.js
  var interpolateCallback = function(point, nextPoint, shapeType) {
    var x = point.x;
    var y = point.y;
    var nextX = nextPoint.x;
    var nextY = nextPoint.y;
    var result;
    switch (shapeType) {
      case "hv":
        result = [{ x: nextX, y }];
        break;
      case "vh":
        result = [{ x, y: nextY }];
        break;
      case "hvh":
        var middleX = (nextX + x) / 2;
        result = [
          { x: middleX, y },
          { x: middleX, y: nextY }
        ];
        break;
      case "vhv":
        var middleY = (y + nextY) / 2;
        result = [
          { x, y: middleY },
          { x: nextX, y: middleY }
        ];
        break;
      default:
        break;
    }
    return result;
  };
  function getInterpolatePoints(points, shapeType) {
    var result = [];
    each_default(points, function(point, index) {
      var nextPoint = points[index + 1];
      result.push(point);
      if (nextPoint) {
        var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);
        result = result.concat(interpolatePoint);
      }
    });
    return result;
  }
  function getInterpolatePath(points) {
    return points.map(function(point, index) {
      return index === 0 ? ["M", point.x, point.y] : ["L", point.x, point.y];
    });
  }
  function getInterpolateShapeAttrs(cfg, shapeType) {
    var points = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
    var path = [];
    each_default(points, function(eachLinePoints) {
      var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
      path = path.concat(getInterpolatePath(interpolatePoints));
    });
    return __assign(__assign({}, getStyle2(cfg, true, false, "lineWidth")), { path });
  }
  each_default(["hv", "vh", "hvh", "vhv"], function(shapeType) {
    registerShape("line", shapeType, {
      draw: function(cfg, container) {
        var attrs = getInterpolateShapeAttrs(cfg, shapeType);
        var shape = container.addShape({
          type: "path",
          attrs,
          name: "line"
        });
        return shape;
      },
      getMarker: function(markerCfg) {
        return getLineMarker(markerCfg, shapeType);
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/shape/point/hollow.js
  each_default(HOLLOW_SHAPES, function(shapeName) {
    registerShape("point", shapeName, {
      draw: function(cfg, container) {
        return drawPoints(this, cfg, container, shapeName, true);
      },
      getMarker: function(markerCfg) {
        var color2 = markerCfg.color;
        return {
          symbol: MarkerSymbols[shapeName],
          style: {
            r: 4.5,
            stroke: color2,
            fill: null
          }
        };
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/shape/point/image.js
  registerShape("point", "image", {
    draw: function(cfg, container) {
      var size3 = getStyle2(cfg, false, false, "r").r;
      var points = this.parsePoints(cfg.points);
      var pointPosition = points[0];
      if (cfg.isStack) {
        pointPosition = points[1];
      } else if (points.length > 1) {
        var group2 = container.addGroup();
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
          var point = points_1[_i];
          group2.addShape("image", {
            attrs: {
              x: point.x - size3 / 2,
              y: point.y - size3,
              width: size3,
              height: size3,
              img: cfg.shape[1]
            }
          });
        }
        return group2;
      }
      return container.addShape("image", {
        attrs: {
          x: pointPosition.x - size3 / 2,
          y: pointPosition.y - size3,
          width: size3,
          height: size3,
          img: cfg.shape[1]
        }
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/point/solid.js
  each_default(SHAPES, function(shapeName) {
    registerShape("point", shapeName, {
      draw: function(cfg, container) {
        return drawPoints(this, cfg, container, shapeName, false);
      },
      getMarker: function(markerCfg) {
        var color2 = markerCfg.color;
        return {
          symbol: MarkerSymbols[shapeName] || shapeName,
          style: {
            r: 4.5,
            fill: color2
          }
        };
      }
    });
  });

  // node_modules/@antv/g2/esm/geometry/shape/schema/box.js
  function parseValue(value) {
    var array2 = !is_array_default(value) ? [value] : value;
    var min7 = array2[0];
    var max7 = array2[array2.length - 1];
    var min1 = array2.length > 1 ? array2[1] : min7;
    var max1 = array2.length > 3 ? array2[3] : max7;
    var median = array2.length > 2 ? array2[2] : min1;
    return {
      min: min7,
      max: max7,
      min1,
      max1,
      median
    };
  }
  function getBoxPoints(x, y, size3) {
    var halfSize = size3 / 2;
    var pointsArray;
    if (is_array_default(y)) {
      var _a4 = parseValue(y), min7 = _a4.min, max7 = _a4.max, median = _a4.median, min1 = _a4.min1, max1 = _a4.max1;
      var minX = x - halfSize;
      var maxX = x + halfSize;
      pointsArray = [
        [minX, max7],
        [maxX, max7],
        [x, max7],
        [x, max1],
        [minX, min1],
        [minX, max1],
        [maxX, max1],
        [maxX, min1],
        [x, min1],
        [x, min7],
        [minX, min7],
        [maxX, min7],
        [minX, median],
        [maxX, median]
      ];
    } else {
      y = is_nil_default(y) ? 0.5 : y;
      var _b = parseValue(x), min7 = _b.min, max7 = _b.max, median = _b.median, min1 = _b.min1, max1 = _b.max1;
      var minY = y - halfSize;
      var maxY = y + halfSize;
      pointsArray = [
        [min7, minY],
        [min7, maxY],
        [min7, y],
        [min1, y],
        [min1, minY],
        [min1, maxY],
        [max1, maxY],
        [max1, minY],
        [max1, y],
        [max7, y],
        [max7, minY],
        [max7, maxY],
        [median, minY],
        [median, maxY]
      ];
    }
    return pointsArray.map(function(arr) {
      return {
        x: arr[0],
        y: arr[1]
      };
    });
  }
  function getBoxPath(points) {
    return [
      ["M", points[0].x, points[0].y],
      ["L", points[1].x, points[1].y],
      ["M", points[2].x, points[2].y],
      ["L", points[3].x, points[3].y],
      ["M", points[4].x, points[4].y],
      ["L", points[5].x, points[5].y],
      ["L", points[6].x, points[6].y],
      ["L", points[7].x, points[7].y],
      ["L", points[4].x, points[4].y],
      ["Z"],
      ["M", points[8].x, points[8].y],
      ["L", points[9].x, points[9].y],
      ["M", points[10].x, points[10].y],
      ["L", points[11].x, points[11].y],
      ["M", points[12].x, points[12].y],
      ["L", points[13].x, points[13].y]
    ];
  }
  registerShape("schema", "box", {
    getPoints: function(shapePoint) {
      var x = shapePoint.x, y = shapePoint.y, size3 = shapePoint.size;
      return getBoxPoints(x, y, size3);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, false);
      var path = this.parsePath(getBoxPath(cfg.points));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path, name: "schema" })
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          var yValues = [y - 6, y - 3, y, y + 3, y + 6];
          var points = getBoxPoints(x, yValues, r);
          return [
            ["M", points[0].x + 1, points[0].y],
            ["L", points[1].x - 1, points[1].y],
            ["M", points[2].x, points[2].y],
            ["L", points[3].x, points[3].y],
            ["M", points[4].x, points[4].y],
            ["L", points[5].x, points[5].y],
            ["L", points[6].x, points[6].y],
            ["L", points[7].x, points[7].y],
            ["L", points[4].x, points[4].y],
            ["Z"],
            ["M", points[8].x, points[8].y],
            ["L", points[9].x, points[9].y],
            ["M", points[10].x + 1, points[10].y],
            ["L", points[11].x - 1, points[11].y],
            ["M", points[12].x, points[12].y],
            ["L", points[13].x, points[13].y]
          ];
        },
        style: {
          r: 6,
          lineWidth: 1,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/schema/candle.js
  function getCandleYValues(value) {
    var array2 = !is_array_default(value) ? [value] : value;
    var sorted = array2.sort(function(a, b) {
      return b - a;
    });
    return padEnd(sorted, 4, sorted[sorted.length - 1]);
  }
  function getCandlePoints(x, y, size3) {
    var yValues = getCandleYValues(y);
    return [
      { x, y: yValues[0] },
      { x, y: yValues[1] },
      { x: x - size3 / 2, y: yValues[2] },
      { x: x - size3 / 2, y: yValues[1] },
      { x: x + size3 / 2, y: yValues[1] },
      { x: x + size3 / 2, y: yValues[2] },
      { x, y: yValues[2] },
      { x, y: yValues[3] }
    ];
  }
  function getCandlePath(points) {
    return [
      ["M", points[0].x, points[0].y],
      ["L", points[1].x, points[1].y],
      ["M", points[2].x, points[2].y],
      ["L", points[3].x, points[3].y],
      ["L", points[4].x, points[4].y],
      ["L", points[5].x, points[5].y],
      ["Z"],
      ["M", points[6].x, points[6].y],
      ["L", points[7].x, points[7].y]
    ];
  }
  registerShape("schema", "candle", {
    getPoints: function(shapePoint) {
      var x = shapePoint.x, y = shapePoint.y, size3 = shapePoint.size;
      return getCandlePoints(x, y, size3);
    },
    draw: function(cfg, container) {
      var style = getStyle2(cfg, true, true);
      var path = this.parsePath(getCandlePath(cfg.points));
      var shape = container.addShape("path", {
        attrs: __assign(__assign({}, style), { path, name: "schema" })
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: function(x, y, r) {
          var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
          var points = getCandlePoints(x, yValues, r);
          return [
            ["M", points[0].x, points[0].y],
            ["L", points[1].x, points[1].y],
            ["M", points[2].x, points[2].y],
            ["L", points[3].x, points[3].y],
            ["L", points[4].x, points[4].y],
            ["L", points[5].x, points[5].y],
            ["Z"],
            ["M", points[6].x, points[6].y],
            ["L", points[7].x, points[7].y]
          ];
        },
        style: {
          lineWidth: 1,
          stroke: color2,
          fill: color2,
          r: 6
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/polygon/square.js
  function getRectAttrs(points, size3) {
    var width = Math.abs(points[0].x - points[2].x);
    var height = Math.abs(points[0].y - points[2].y);
    var len3 = Math.min(width, height);
    if (size3) {
      len3 = clamp_default(size3, 0, Math.min(width, height));
    }
    len3 = len3 / 2;
    var centerX = (points[0].x + points[2].x) / 2;
    var centerY = (points[0].y + points[2].y) / 2;
    return {
      x: centerX - len3,
      y: centerY - len3,
      width: len3 * 2,
      height: len3 * 2
    };
  }
  registerShape("polygon", "square", {
    draw: function(cfg, container) {
      if (!is_empty_default(cfg.points)) {
        var shapeAttrs = getStyle2(cfg, true, true);
        var points = this.parsePoints(cfg.points);
        return container.addShape("rect", {
          attrs: __assign(__assign({}, shapeAttrs), getRectAttrs(points, cfg.size)),
          name: "polygon"
        });
      }
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "square",
        style: {
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/violin/smooth.js
  registerShape("violin", "smooth", {
    draw: function(cfg, container) {
      var attrs = getStyle2(cfg, true, true);
      var path = this.parsePath(getSmoothViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, attrs), { path })
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          stroke: null,
          r: 4,
          fill: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/shape/violin/hollow.js
  registerShape("violin", "hollow", {
    draw: function(cfg, container) {
      var attrs = getStyle2(cfg, true, false);
      var path = this.parsePath(getViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, attrs), { path })
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4,
          fill: null,
          stroke: color2
        }
      };
    }
  });
  registerShape("violin", "hollow-smooth", {
    draw: function(cfg, container) {
      var attrs = getStyle2(cfg, true, false);
      var path = this.parsePath(getSmoothViolinPath(cfg.points));
      return container.addShape("path", {
        attrs: __assign(__assign({}, attrs), { path })
      });
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: "circle",
        style: {
          r: 4,
          fill: null,
          stroke: color2
        }
      };
    }
  });

  // node_modules/@antv/g2/esm/geometry/label/interval.js
  var IntervalLabel = function(_super) {
    __extends(IntervalLabel2, _super);
    function IntervalLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
      var dim = "y";
      var points = mappingData.points;
      return points[0][dim] <= points[2][dim] ? 1 : -1;
    };
    IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index, total, position) {
      var _a4;
      var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);
      var coordinate = this.getCoordinate();
      var transposed = coordinate.isTransposed;
      var dim = transposed ? "x" : "y";
      var dir = this.getLabelValueDir(labelCfg.mappingData);
      point = __assign(__assign({}, point), (_a4 = {}, _a4[dim] = point[dim] * dir, _a4));
      if (coordinate.isReflect("x")) {
        point = __assign(__assign({}, point), { x: point.x * -1 });
      }
      if (coordinate.isReflect("y")) {
        point = __assign(__assign({}, point), { y: point.y * -1 });
      }
      return point;
    };
    IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var theme = geometry.theme;
      return deep_mix_default({}, defaultLabelCfg, theme.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
    };
    IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index, position) {
      var coordinate = this.getCoordinate();
      var transposed = coordinate.isTransposed;
      var shapePoints = mappingData.points;
      var point0 = coordinate.convert(shapePoints[0]);
      var point2 = coordinate.convert(shapePoints[2]);
      var dir = this.getLabelValueDir(mappingData);
      var top;
      var right;
      var bottom;
      var left;
      var shape = is_array_default(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      if (shape === "funnel" || shape === "pyramid") {
        var nextPoints = get_default(mappingData, "nextPoints");
        var points = get_default(mappingData, "points");
        if (nextPoints) {
          var p0 = coordinate.convert(points[0]);
          var p1 = coordinate.convert(points[1]);
          var nextP0 = coordinate.convert(nextPoints[0]);
          var nextP1 = coordinate.convert(nextPoints[1]);
          if (transposed) {
            top = Math.min(nextP0.y, p0.y);
            bottom = Math.max(nextP0.y, p0.y);
            right = (p1.x + nextP1.x) / 2;
            left = (p0.x + nextP0.x) / 2;
          } else {
            top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            right = nextP1.x;
            left = p0.x;
          }
        } else {
          top = Math.min(point2.y, point0.y);
          bottom = Math.max(point2.y, point0.y);
          right = point2.x;
          left = point0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right = point2.x;
        left = point0.x;
      }
      switch (position) {
        case "right":
          labelPointCfg.x = right;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "left":
          labelPointCfg.x = left;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "bottom":
          if (transposed) {
            labelPointCfg.x = (right + left) / 2;
          }
          labelPointCfg.y = bottom;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        case "middle":
          if (transposed) {
            labelPointCfg.x = (right + left) / 2;
          }
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", "middle");
          break;
        case "top":
          if (transposed) {
            labelPointCfg.x = (right + left) / 2;
          }
          labelPointCfg.y = top;
          labelPointCfg.textAlign = get_default(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get_default(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        default:
          break;
      }
    };
    return IntervalLabel2;
  }(base_default15);
  var interval_default2 = IntervalLabel;

  // node_modules/@antv/g2/esm/geometry/label/polar.js
  var HALF_PI = Math.PI / 2;
  var PolarLabel = function(_super) {
    __extends(PolarLabel2, _super);
    function PolarLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate = this.getCoordinate();
      var actualOffset = 0;
      if (is_number_default(offset)) {
        actualOffset = offset;
      } else if (is_string_default(offset) && offset.indexOf("%") !== -1) {
        var r = coordinate.getRadius();
        if (coordinate.innerRadius > 0) {
          r = r * (1 - coordinate.innerRadius);
        }
        actualOffset = parseFloat(offset) * 0.01 * r;
      }
      return actualOffset;
    };
    PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
      var items = _super.prototype.getLabelItems.call(this, mapppingArray);
      var yScale = this.geometry.getYScale();
      return map_default(items, function(item) {
        if (item && yScale) {
          var percent = yScale.scale(get_default(item.data, yScale.field));
          return __assign(__assign({}, item), { percent });
        }
        return item;
      });
    };
    PolarLabel2.prototype.getLabelAlign = function(point) {
      var coordinate = this.getCoordinate();
      var align;
      if (point.labelEmit) {
        align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? "left" : "right";
      } else if (!coordinate.isTransposed) {
        align = "center";
      } else {
        var center = coordinate.getCenter();
        var offset = point.offset;
        if (Math.abs(point.x - center.x) < 1) {
          align = "center";
        } else if (point.angle > Math.PI || point.angle <= 0) {
          align = offset > 0 ? "left" : "right";
        } else {
          align = offset > 0 ? "right" : "left";
        }
      }
      return align;
    };
    PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index) {
      var factor = 1;
      var arcPoint;
      var content = labelCfg.content[index];
      if (this.isToMiddle(mappingData)) {
        arcPoint = this.getMiddlePoint(mappingData.points);
      } else {
        if (labelCfg.content.length === 1 && index === 0) {
          index = 1;
        } else if (index === 0) {
          factor = -1;
        }
        arcPoint = this.getArcPoint(mappingData, index);
      }
      var offset = labelCfg.offset * factor;
      var middleAngle = this.getPointAngle(arcPoint);
      var isLabelEmit = labelCfg.labelEmit;
      var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
      if (labelPositionCfg.r === 0) {
        labelPositionCfg.content = "";
      } else {
        labelPositionCfg.content = content;
        labelPositionCfg.angle = middleAngle;
        labelPositionCfg.color = mappingData.color;
      }
      labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
      labelPositionCfg.start = {
        x: arcPoint.x,
        y: arcPoint.y
      };
      return labelPositionCfg;
    };
    PolarLabel2.prototype.getArcPoint = function(mappingData, index) {
      if (index === void 0) {
        index = 0;
      }
      if (!is_array_default(mappingData.x) && !is_array_default(mappingData.y)) {
        return {
          x: mappingData.x,
          y: mappingData.y
        };
      }
      return {
        x: is_array_default(mappingData.x) ? mappingData.x[index] : mappingData.x,
        y: is_array_default(mappingData.y) ? mappingData.y[index] : mappingData.y
      };
    };
    PolarLabel2.prototype.getPointAngle = function(point) {
      return getAngleByPoint(this.getCoordinate(), point);
    };
    PolarLabel2.prototype.getCirclePoint = function(angle3, offset, point, isLabelEmit) {
      var coordinate = this.getCoordinate();
      var center = coordinate.getCenter();
      var r = getDistanceToCenter(coordinate, point);
      if (r === 0) {
        return __assign(__assign({}, center), { r });
      }
      var labelAngle = angle3;
      if (coordinate.isTransposed && r > offset && !isLabelEmit) {
        var appendAngle = Math.asin(offset / (2 * r));
        labelAngle = angle3 + appendAngle * 2;
      } else {
        r = r + offset;
      }
      return {
        x: center.x + r * Math.cos(labelAngle),
        y: center.y + r * Math.sin(labelAngle),
        r
      };
    };
    PolarLabel2.prototype.getLabelRotate = function(angle3, offset, isLabelEmit) {
      var rotate5 = angle3 + HALF_PI;
      if (isLabelEmit) {
        rotate5 -= HALF_PI;
      }
      if (rotate5) {
        if (rotate5 > HALF_PI) {
          rotate5 = rotate5 - Math.PI;
        } else if (rotate5 < -HALF_PI) {
          rotate5 = rotate5 + Math.PI;
        }
      }
      return rotate5;
    };
    PolarLabel2.prototype.getMiddlePoint = function(points) {
      var coordinate = this.getCoordinate();
      var count2 = points.length;
      var middlePoint = {
        x: 0,
        y: 0
      };
      each_default(points, function(point) {
        middlePoint.x += point.x;
        middlePoint.y += point.y;
      });
      middlePoint.x /= count2;
      middlePoint.y /= count2;
      middlePoint = coordinate.convert(middlePoint);
      return middlePoint;
    };
    PolarLabel2.prototype.isToMiddle = function(mappingData) {
      return mappingData.x.length > 2;
    };
    return PolarLabel2;
  }(base_default15);
  var polar_default2 = PolarLabel;

  // node_modules/@antv/g2/esm/geometry/label/pie.js
  var PieLabel = function(_super) {
    __extends(PieLabel2, _super);
    function PieLabel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.defaultLayout = "distribute";
      return _this;
    }
    PieLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
      return deep_mix_default({}, cfg, get_default(this.geometry.theme, "pieLabels", {}));
    };
    PieLabel2.prototype.getLabelOffset = function(offset) {
      return _super.prototype.getLabelOffset.call(this, offset) || 0;
    };
    PieLabel2.prototype.getLabelRotate = function(angle3, offset, isLabelLimit) {
      var rotate5;
      if (offset < 0) {
        rotate5 = angle3;
        if (rotate5 > Math.PI / 2) {
          rotate5 = rotate5 - Math.PI;
        }
        if (rotate5 < -Math.PI / 2) {
          rotate5 = rotate5 + Math.PI;
        }
      }
      return rotate5;
    };
    PieLabel2.prototype.getLabelAlign = function(point) {
      var coordinate = this.getCoordinate();
      var center = coordinate.getCenter();
      var align;
      if (point.angle <= Math.PI / 2 && point.x >= center.x) {
        align = "left";
      } else {
        align = "right";
      }
      if (point.offset <= 0) {
        if (align === "right") {
          align = "left";
        } else {
          align = "right";
        }
      }
      return align;
    };
    PieLabel2.prototype.getArcPoint = function(point) {
      return point;
    };
    PieLabel2.prototype.getPointAngle = function(point) {
      var coordinate = this.getCoordinate();
      var startPoint = {
        x: is_array_default(point.x) ? point.x[0] : point.x,
        y: point.y[0]
      };
      var endPoint = {
        x: is_array_default(point.x) ? point.x[1] : point.x,
        y: point.y[1]
      };
      var angle3;
      var startAngle = getAngleByPoint(coordinate, startPoint);
      if (point.points && point.points[0].y === point.points[1].y) {
        angle3 = startAngle;
      } else {
        var endAngle = getAngleByPoint(coordinate, endPoint);
        if (startAngle >= endAngle) {
          endAngle = endAngle + Math.PI * 2;
        }
        angle3 = startAngle + (endAngle - startAngle) / 2;
      }
      return angle3;
    };
    PieLabel2.prototype.getCirclePoint = function(angle3, offset) {
      var coordinate = this.getCoordinate();
      var center = coordinate.getCenter();
      var r = coordinate.getRadius() + offset;
      return __assign(__assign({}, polarToCartesian(center.x, center.y, r, angle3)), { angle: angle3, r });
    };
    return PieLabel2;
  }(polar_default2);
  var pie_default = PieLabel;

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/distribute.js
  var MARGIN = 4;
  function antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {
    var overlapping = true;
    var start = plotRange.start;
    var end = plotRange.end;
    var startY = Math.min(start.y, end.y);
    var totalHeight = Math.abs(start.y - end.y);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function(label) {
      if (label.y > maxY) {
        maxY = label.y;
      }
      if (label.y < minY) {
        minY = label.y;
      }
      return {
        size: lineHeight,
        targets: [label.y - startY]
      };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
      totalHeight = maxY - startY;
    }
    while (overlapping) {
      boxes.forEach(function(box3) {
        var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
        box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
      });
      overlapping = false;
      i = boxes.length;
      while (i--) {
        if (i > 0) {
          var previousBox = boxes[i - 1];
          var box2 = boxes[i];
          if (previousBox.pos + previousBox.size > box2.pos) {
            previousBox.size += box2.size;
            previousBox.targets = previousBox.targets.concat(box2.targets);
            if (previousBox.pos + previousBox.size > totalHeight) {
              previousBox.pos = totalHeight - previousBox.size;
            }
            boxes.splice(i, 1);
            overlapping = true;
          }
        }
      }
    }
    i = 0;
    boxes.forEach(function(b) {
      var posInCompositeBox = startY + lineHeight / 2;
      b.targets.forEach(function() {
        labels[i].y = b.pos + posInCompositeBox;
        posInCompositeBox += lineHeight;
        i++;
      });
    });
    var labelsMap = {};
    for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {
      var labelShape = labelShapes_1[_i];
      labelsMap[labelShape.get("id")] = labelShape;
    }
    labels.forEach(function(label) {
      var rPow2 = label.r * label.r;
      var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);
      if (rPow2 < dyPow2) {
        label.x = center.x;
      } else {
        var dx = Math.sqrt(rPow2 - dyPow2);
        if (!isRight) {
          label.x = center.x - dx;
        } else {
          label.x = center.x + dx;
        }
      }
      var labelShape2 = labelsMap[label.id];
      labelShape2.attr("x", label.x);
      labelShape2.attr("y", label.y);
      var textShape = find_default(labelShape2.getChildren(), function(ele) {
        return ele.get("type") === "text";
      });
      if (textShape) {
        textShape.attr("y", label.y);
        textShape.attr("x", label.x);
      }
    });
  }
  function distribute(items, labels, shapes, region) {
    if (!items.length || !labels.length) {
      return;
    }
    var offset = items[0] ? items[0].offset : 0;
    var coordinate = labels[0].get("coordinate");
    var radius = coordinate.getRadius();
    var center = coordinate.getCenter();
    if (offset > 0) {
      var lineHeight_1 = 14;
      var totalR = radius + offset;
      var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
      var plotRange_1 = {
        start: coordinate.start,
        end: coordinate.end
      };
      var halves_1 = [
        [],
        []
      ];
      items.forEach(function(labelItem) {
        if (!labelItem) {
          return;
        }
        if (labelItem.textAlign === "right") {
          halves_1[0].push(labelItem);
        } else {
          halves_1[1].push(labelItem);
        }
      });
      halves_1.forEach(function(half, index) {
        var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
        if (half.length > maxLabelsCountForOneSide) {
          half.sort(function(a, b) {
            return b["..percent"] - a["..percent"];
          });
          half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
        }
        half.sort(function(a, b) {
          return a.y - b.y;
        });
        antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);
      });
    }
    each_default(items, function(item) {
      if (item && item.labelLine) {
        var distance8 = item.offset;
        var angle3 = item.angle;
        var startPoint = polarToCartesian(center.x, center.y, radius, angle3);
        var innerPoint = polarToCartesian(center.x, center.y, radius + distance8 / 2, angle3);
        var itemX = item.x + get_default(item, "offsetX", 0);
        var itemY = item.y + get_default(item, "offsetY", 0);
        var endPoint = {
          x: itemX - Math.cos(angle3) * MARGIN,
          y: itemY - Math.sin(angle3) * MARGIN
        };
        if (!is_object_default(item.labelLine)) {
          item.labelLine = {};
        }
        item.labelLine.path = [
          "M " + startPoint.x,
          startPoint.y + " Q" + innerPoint.x,
          innerPoint.y + " " + endPoint.x,
          endPoint.y
        ].join(",");
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/util.js
  function antiCollision2(items, labelHeight, plotRange) {
    var labels = items.filter(function(item) {
      return !item.invisible;
    });
    labels.sort(function(a, b) {
      return a.y - b.y;
    });
    var overlapping = true;
    var startY = plotRange.minY;
    var endY = plotRange.maxY;
    var totalHeight = Math.abs(startY - endY);
    var i;
    var maxY = 0;
    var minY = Number.MIN_VALUE;
    var boxes = labels.map(function(label) {
      if (label.y > maxY) {
        maxY = label.y;
      }
      if (label.y < minY) {
        minY = label.y;
      }
      return {
        content: label.content,
        size: labelHeight,
        targets: [label.y - startY],
        pos: null
      };
    });
    minY -= startY;
    if (maxY - startY > totalHeight) {
      totalHeight = maxY - startY;
    }
    while (overlapping) {
      boxes.forEach(function(box3) {
        var target = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
        box3.pos = Math.min(Math.max(minY, target - box3.size / 2), totalHeight - box3.size);
        box3.pos = Math.max(0, box3.pos);
      });
      overlapping = false;
      i = boxes.length;
      while (i--) {
        if (i > 0) {
          var previousBox = boxes[i - 1];
          var box2 = boxes[i];
          if (previousBox.pos + previousBox.size > box2.pos) {
            previousBox.size += box2.size;
            previousBox.targets = previousBox.targets.concat(box2.targets);
            if (previousBox.pos + previousBox.size > totalHeight) {
              previousBox.pos = totalHeight - previousBox.size;
            }
            boxes.splice(i, 1);
            overlapping = true;
          }
        }
      }
    }
    i = 0;
    boxes.forEach(function(b) {
      var posInCompositeBox = startY + labelHeight / 2;
      b.targets.forEach(function() {
        labels[i].y = b.pos + posInCompositeBox;
        posInCompositeBox += labelHeight;
        i++;
      });
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/outer.js
  var MARGIN2 = 4;
  function drawLabelline(item, coordinate) {
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    if (item && item.labelLine) {
      var angle3 = item.angle, labelOffset = item.offset;
      var startPoint = polarToCartesian(center.x, center.y, radius, angle3);
      var itemX = item.x + get_default(item, "offsetX", 0) * (Math.cos(angle3) > 0 ? 1 : -1);
      var itemY = item.y + get_default(item, "offsetY", 0) * (Math.sin(angle3) > 0 ? 1 : -1);
      var endPoint = {
        x: itemX - Math.cos(angle3) * MARGIN2,
        y: itemY - Math.sin(angle3) * MARGIN2
      };
      var smoothConnector = item.labelLine.smooth;
      var path = [];
      var dx = endPoint.x - center.x;
      var dy = endPoint.y - center.y;
      var endAngle = Math.atan(dy / dx);
      if (dx < 0) {
        endAngle += Math.PI;
      }
      if (smoothConnector === false) {
        if (!is_object_default(item.labelLine)) {
          item.labelLine = {};
        }
        var sweepFlag = 0;
        if (angle3 < 0 && angle3 > -Math.PI / 2 || angle3 > Math.PI * 1.5) {
          if (endPoint.y > startPoint.y) {
            sweepFlag = 1;
          }
        }
        if (angle3 >= 0 && angle3 < Math.PI / 2) {
          if (endPoint.y > startPoint.y) {
            sweepFlag = 1;
          }
        }
        if (angle3 >= Math.PI / 2 && angle3 < Math.PI) {
          if (startPoint.y > endPoint.y) {
            sweepFlag = 1;
          }
        }
        if (angle3 < -Math.PI / 2 || angle3 >= Math.PI && angle3 < Math.PI * 1.5) {
          if (startPoint.y > endPoint.y) {
            sweepFlag = 1;
          }
        }
        var distance8 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
        var breakPoint = polarToCartesian(center.x, center.y, radius + distance8, angle3);
        var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);
        var largeArcFlag = 0;
        path.push("M " + startPoint.x + " " + startPoint.y);
        path.push("L " + breakPoint.x + " " + breakPoint.y);
        path.push("A " + center.x + " " + center.y + " 0 " + largeArcFlag + " " + sweepFlag + " " + breakPoint3.x + " " + breakPoint3.y);
        path.push("L " + endPoint.x + " " + endPoint.y);
      } else {
        var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle3);
        var xSign = startPoint.x < center.x ? 1 : -1;
        path.push("M " + endPoint.x + " " + endPoint.y);
        var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);
        var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);
        if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
          path.push.apply(path, [
            "C",
            endPoint.x + xSign * 4,
            endPoint.y,
            2 * breakPoint.x - startPoint.x,
            2 * breakPoint.y - startPoint.y,
            startPoint.x,
            startPoint.y
          ]);
        }
        path.push("L " + startPoint.x + " " + startPoint.y);
      }
      item.labelLine.path = path.join(" ");
    }
  }
  function pieOuterLabelLayout(originalItems, labels, shapes, region) {
    var items = filter_default(originalItems, function(item) {
      return !is_nil_default(item);
    });
    var coordinate = labels[0] && labels[0].get("coordinate");
    if (!coordinate) {
      return;
    }
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    var labelsMap = {};
    for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
      var labelShape = labels_1[_i];
      labelsMap[labelShape.get("id")] = labelShape;
    }
    var labelHeight = get_default(items[0], "labelHeight", 14);
    var labelOffset = get_default(items[0], "offset", 0);
    if (labelOffset <= 0) {
      return;
    }
    var LEFT_HALF_KEY = "left";
    var RIGHT_HALF_KEY = "right";
    var separateLabels = group_by_default(items, function(item) {
      return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
    });
    var start = coordinate.start, end = coordinate.end;
    var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());
    var totalR = totalHeight / 2;
    var labelsContainerRange = {
      minX: start.x,
      maxX: end.x,
      minY: center.y - totalR,
      maxY: center.y + totalR
    };
    each_default(separateLabels, function(half, key) {
      var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b.percent - a.percent;
        });
        each_default(half, function(labelItem, idx) {
          if (idx + 1 > maxLabelsCountForOneSide) {
            labelsMap[labelItem.id].set("visible", false);
            labelItem.invisible = true;
          }
        });
      }
      antiCollision2(half, labelHeight, labelsContainerRange);
    });
    each_default(separateLabels, function(half, key) {
      each_default(half, function(item) {
        var isRight = key === RIGHT_HALF_KEY;
        var labelShape2 = labelsMap[item.id];
        var content = labelShape2.getChildByIndex(0);
        if (content) {
          var r = radius + labelOffset;
          var dy = item.y - center.y;
          var rPow2 = Math.pow(r, 2);
          var dyPow2 = Math.pow(dy, 2);
          var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
          var dx = Math.sqrt(dxPow2);
          var dx_offset = Math.abs(Math.cos(item.angle) * r);
          if (!isRight) {
            item.x = center.x - Math.max(dx, dx_offset);
          } else {
            item.x = center.x + Math.max(dx, dx_offset);
          }
        }
        if (content) {
          content.attr("y", item.y);
          content.attr("x", item.x);
        }
        drawLabelline(item, coordinate);
      });
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/pie/spider.js
  var INFLECTION_OFFSET = 4;
  var LABEL_OFFSET_X = 4;
  var LABEL_TEXT_LINE_OFFSET = 4;
  function drawLabelline2(item, coordinate, inRight) {
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    var startPoint = {
      x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
      y: item.y
    };
    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
    var p1 = { x: startPoint.x, y: startPoint.y };
    var p22 = { x: inflectionPoint.x, y: inflectionPoint.y };
    var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);
    var path = "";
    if (startPoint.y !== inflectionPoint.y) {
      var offset = inRight ? 4 : -4;
      p1.y = startPoint.y;
      if (item.angle < 0 && item.angle >= -Math.PI / 2) {
        p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y < inflectionPoint.y) {
          p22.y = p1.y;
        } else {
          p22.y = inflectionPoint.y;
          p22.x = Math.max(p22.x, p1.x - offset);
        }
      }
      if (item.angle > 0 && item.angle < Math.PI / 2) {
        p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y > inflectionPoint.y) {
          p22.y = p1.y;
        } else {
          p22.y = inflectionPoint.y;
          p22.x = Math.max(p22.x, p1.x - offset);
        }
      }
      if (item.angle > Math.PI / 2) {
        p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y > inflectionPoint.y) {
          p22.y = p1.y;
        } else {
          p22.y = inflectionPoint.y;
          p22.x = Math.min(p22.x, p1.x - offset);
        }
      }
      if (item.angle < -Math.PI / 2) {
        p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
        if (startPoint.y < inflectionPoint.y) {
          p22.y = p1.y;
        } else {
          p22.y = inflectionPoint.y;
          p22.x = Math.min(p22.x, p1.x - offset);
        }
      }
    }
    path = [
      "M " + startPoint.x + "," + startPoint.y,
      "L " + p1.x + "," + p1.y,
      "L " + p22.x + "," + p22.y,
      "L " + inflectionPoint.x + "," + inflectionPoint.y,
      "L " + endPoint.x + "," + endPoint.y
    ].join(" ");
    item.labelLine = deep_mix_default({}, item.labelLine, { path });
  }
  function pieSpiderLabelLayout(items, labels, shapes, region) {
    var coordinate = labels[0] && labels[0].get("coordinate");
    if (!coordinate) {
      return;
    }
    var center = coordinate.getCenter();
    var radius = coordinate.getRadius();
    var labelsMap = {};
    for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
      var labelShape = labels_1[_i];
      labelsMap[labelShape.get("id")] = labelShape;
    }
    var labelHeight = get_default(items[0], "labelHeight", 14);
    var labelOffset = Math.max(get_default(items[0], "offset", 0), INFLECTION_OFFSET);
    each_default(items, function(item) {
      var label = get_default(labelsMap, [item.id]);
      if (!label) {
        return;
      }
      var inRight = item.x > center.x || item.x === center.x && item.y > center.y;
      var offsetX = !is_nil_default(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
      var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
      var totalOffset = labelOffset + offsetX;
      item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);
      item.y = inflectionPoint.y;
    });
    var start = coordinate.start, end = coordinate.end;
    var LEFT_HALF_KEY = "left";
    var RIGHT_HALF_KEY = "right";
    var seperateLabels = group_by_default(items, function(item) {
      return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
    });
    var totalHeight = (radius + labelOffset) * 2 + labelHeight;
    each_default(seperateLabels, function(half) {
      var halfHeight = half.length * labelHeight;
      if (halfHeight > totalHeight) {
        totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
      }
    });
    var labelsContainerRange = {
      minX: start.x,
      maxX: end.x,
      minY: center.y - totalHeight / 2,
      maxY: center.y + totalHeight / 2
    };
    each_default(seperateLabels, function(half, key) {
      var maxLabelsCountForOneSide = totalHeight / labelHeight;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b.percent - a.percent;
        });
        each_default(half, function(labelItem, idx) {
          if (idx > maxLabelsCountForOneSide) {
            labelsMap[labelItem.id].set("visible", false);
            labelItem.invisible = true;
          }
        });
      }
      antiCollision2(half, labelHeight, labelsContainerRange);
    });
    var startY = labelsContainerRange.minY;
    var endY = labelsContainerRange.maxY;
    each_default(seperateLabels, function(half, key) {
      var inRight = key === RIGHT_HALF_KEY;
      each_default(half, function(item) {
        var label = get_default(labelsMap, item && [item.id]);
        if (!label) {
          return;
        }
        if (item.y < startY || item.y > endY) {
          label.set("visible", false);
          return;
        }
        var labelContent = label.getChildByIndex(0);
        var box2 = labelContent.getCanvasBBox();
        var originalPos = { x: inRight ? box2.x : box2.maxX, y: box2.y + box2.height / 2 };
        translate2(labelContent, item.x - originalPos.x, item.y - originalPos.y);
        if (item.labelLine) {
          drawLabelline2(item, coordinate, inRight);
        }
      });
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/limit-in-canvas.js
  function limitInCanvas(items, labels, shapes, region) {
    each_default(labels, function(label) {
      var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
      var _a4 = label.getCanvasBBox(), minX = _a4.minX, minY = _a4.minY, maxX = _a4.maxX, maxY = _a4.maxY, x = _a4.x, y = _a4.y, width = _a4.width, height = _a4.height;
      var finalX = x;
      var finalY = y;
      if (minX < regionMinX || maxX < regionMinX) {
        finalX = regionMinX;
      }
      if (minY < regionMinY || maxY < regionMinY) {
        finalY = regionMinY;
      }
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY > regionMaxY) {
        finalY = finalY - (maxY - regionMaxY);
      }
      if (finalX !== x || finalY !== y) {
        translate2(label, finalX - x, finalY - y);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/limit-in-shape.js
  function limitInShape(items, labels, shapes, region) {
    each_default(labels, function(label, index) {
      var labelBBox = label.getCanvasBBox();
      var shapeBBox = shapes[index].getBBox();
      if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
        label.remove(true);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/overlap.js
  var MAX_TIMES = 100;
  var Greedy = function() {
    function Greedy2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.bitmap = {};
      var _a4 = cfg.xGap, xGap = _a4 === void 0 ? 1 : _a4, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
      this.xGap = xGap;
      this.yGap = yGap;
    }
    Greedy2.prototype.hasGap = function(bbox) {
      var hasGap = true;
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
          continue;
        }
        if (i === minX || i === maxX) {
          for (var j = minY; j <= maxY; j++) {
            if (bitmap[i][j]) {
              hasGap = false;
              break;
            }
          }
        } else {
          if (bitmap[i][minY] || bitmap[i][maxY]) {
            hasGap = false;
            break;
          }
        }
      }
      return hasGap;
    };
    Greedy2.prototype.fillGap = function(bbox) {
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
        }
      }
      for (var i = minX; i <= maxX; i += this.xGap) {
        for (var j = minY; j <= maxY; j += this.yGap) {
          bitmap[i][j] = true;
        }
        bitmap[i][maxY] = true;
      }
      if (this.yGap !== 1) {
        for (var i = minY; i <= maxY; i += 1) {
          bitmap[minX][i] = true;
          bitmap[maxX][i] = true;
        }
      }
      if (this.xGap !== 1) {
        for (var i = minX; i <= maxX; i += 1) {
          bitmap[i][minY] = true;
          bitmap[i][maxY] = true;
        }
      }
    };
    Greedy2.prototype.destroy = function() {
      this.bitmap = {};
    };
    return Greedy2;
  }();
  function spiralFill(label, greedy, maxTimes) {
    if (maxTimes === void 0) {
      maxTimes = MAX_TIMES;
    }
    var dt = -1;
    var _a4 = label.attr(), x = _a4.x, y = _a4.y;
    var bbox = label.getCanvasBBox();
    var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
    var dxdy;
    var t = -dt;
    var dx = 0;
    var dy = 0;
    var f = function(param) {
      var nt = param * 0.1;
      return [nt * Math.cos(nt), nt * Math.sin(nt)];
    };
    if (greedy.hasGap(bbox)) {
      greedy.fillGap(bbox);
      return true;
    }
    var canFill = false;
    var times = 0;
    var accessedCache = {};
    while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
      dxdy = f(t += dt);
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (!dx && !dy || accessedCache[dx + "-" + dy]) {
        continue;
      }
      label.attr({ x: x + dx, y: y + dy });
      if (dx + dy < 0) {
        label.attr("textAlign", "right");
      }
      times++;
      if (greedy.hasGap(label.getCanvasBBox())) {
        greedy.fillGap(label.getCanvasBBox());
        canFill = true;
        accessedCache[dx + "-" + dy] = true;
        break;
      }
    }
    return canFill;
  }
  function adjustLabelPosition(label, x, y, index) {
    var _a4 = label.getCanvasBBox(), width = _a4.width, height = _a4.height;
    var attrs = {
      x,
      y,
      textAlign: "center"
    };
    switch (index) {
      case 0:
        attrs.y -= height + 1;
        attrs.x += 1;
        attrs.textAlign = "left";
        break;
      case 1:
        attrs.y -= height + 1;
        attrs.x -= 1;
        attrs.textAlign = "right";
        break;
      case 2:
        attrs.y += height + 1;
        attrs.x -= 1;
        attrs.textAlign = "right";
        break;
      case 3:
        attrs.y += height + 1;
        attrs.x += 1;
        attrs.textAlign = "left";
        break;
      case 5:
        attrs.y -= height * 2 + 2;
        break;
      case 6:
        attrs.y += height * 2 + 2;
        break;
      case 7:
        attrs.x += width + 1;
        attrs.textAlign = "left";
        break;
      case 8:
        attrs.x -= width + 1;
        attrs.textAlign = "right";
        break;
      default:
        break;
    }
    label.attr(attrs);
    return label.getCanvasBBox();
  }
  function fixedOverlap(items, labels, shapes, region) {
    var greedy = new Greedy();
    each_default(labels, function(label) {
      var labelShape = label.find(function(shape) {
        return shape.get("type") === "text";
      });
      if (!spiralFill(labelShape, greedy)) {
        label.remove(true);
      }
    });
    greedy.destroy();
  }
  function overlap(items, labels, shapes, region) {
    var greedy = new Greedy();
    each_default(labels, function(label) {
      var labelShape = label.find(function(shape) {
        return shape.get("type") === "text";
      });
      var _a4 = labelShape.attr(), x = _a4.x, y = _a4.y;
      var canFill = false;
      for (var i = 0; i <= 8; i++) {
        var bbox = adjustLabelPosition(labelShape, x, y, i);
        if (greedy.hasGap(bbox)) {
          greedy.fillGap(bbox);
          canFill = true;
          break;
        }
      }
      if (!canFill) {
        label.remove(true);
      }
    });
    greedy.destroy();
  }

  // node_modules/@antv/g2/esm/util/collision-detect.js
  var dot3 = vec2_exports.dot;
  function getAxes(points) {
    if (points.length > 4) {
      return [];
    }
    var vector = function(start, end) {
      return [end.x - start.x, end.y - start.y];
    };
    var AB = vector(points[0], points[1]);
    var BC = vector(points[1], points[2]);
    return [AB, BC];
  }
  function rotateAtPoint(point, deg, origin) {
    if (deg === void 0) {
      deg = 0;
    }
    if (origin === void 0) {
      origin = { x: 0, y: 0 };
    }
    var x = point.x, y = point.y;
    return {
      x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
      y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
    };
  }
  function getRectPoints2(box2) {
    var points = [
      { x: box2.x, y: box2.y },
      { x: box2.x + box2.width, y: box2.y },
      { x: box2.x + box2.width, y: box2.y + box2.height },
      { x: box2.x, y: box2.y + box2.height }
    ];
    var rotation = box2.rotation;
    if (rotation) {
      return [
        rotateAtPoint(points[0], rotation, points[0]),
        rotateAtPoint(points[1], rotation, points[0]),
        rotateAtPoint(points[2], rotation, points[0]),
        rotateAtPoint(points[3], rotation, points[0])
      ];
    }
    return points;
  }
  function getProjection(points, axis) {
    if (points.length > 4) {
      return { min: 0, max: 0 };
    }
    var scalars = [];
    points.forEach(function(point) {
      scalars.push(dot3([point.x, point.y], axis));
    });
    return { min: Math.min.apply(Math, scalars), max: Math.max.apply(Math, scalars) };
  }
  function isProjectionOverlap(projection1, projection2) {
    return projection1.max > projection2.min && projection1.min < projection2.max;
  }
  function isValidNumber(d) {
    return is_number_default(d) && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
  }
  function isValidBox(box2) {
    return Object.values(box2).every(isValidNumber);
  }
  function isIntersectRect(box1, box2, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
  }
  function isIntersect(box1, box2) {
    if (!isValidBox(box1) || !isValidBox(box2))
      return false;
    if (!box1.rotation && !box2.rotation) {
      return isIntersectRect(box1, box2);
    }
    var rect1Points = getRectPoints2(box1);
    var rect2Points = getRectPoints2(box2);
    var axes = __spreadArray(__spreadArray([], getAxes(rect1Points), true), getAxes(rect2Points), true);
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var projection1 = getProjection(rect1Points, axis);
      var projection2 = getProjection(rect2Points, axis);
      if (!isProjectionOverlap(projection1, projection2))
        return false;
    }
    return true;
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/hide-overlap.js
  function hideOverlap(items, labels, shapes, region) {
    for (var i = 0; i < labels.length; i++) {
      var label1 = labels[i];
      if (labels[i].get("visible")) {
        for (var j = i + 1; j < labels.length; j++) {
          var label2 = labels[j];
          if (label1 && label2 && label1 !== label2 && label2.get("visible")) {
            var box1 = getlLabelBackgroundInfo(label1, items[i], get_default(items[i], "background.padding"));
            var box2 = getlLabelBackgroundInfo(label2, items[j], get_default(items[j], "background.padding"));
            if (isIntersect(box1, box2)) {
              labels[j].set("visible", false);
            }
          }
        }
      }
    }
  }

  // node_modules/@antv/g2/esm/util/color.js
  var preset = {
    "#5B8FF9": true
  };
  var isContrastColorWhite = function(color2) {
    var rgb2 = esm_default2.toRGB(color2).toUpperCase();
    if (preset[rgb2]) {
      return preset[rgb2];
    }
    var _a4 = esm_default2.rgb2arr(rgb2), r = _a4[0], g = _a4[1], b = _a4[2];
    var isDark = (r * 299 + g * 587 + b * 114) / 1e3 < 128;
    return isDark;
  };

  // node_modules/@antv/g2/esm/geometry/label/layout/adjust-color.js
  function adjustColor(items, labels, shapes) {
    if (shapes.length === 0) {
      return;
    }
    var element = shapes[0].get("element");
    var theme = element.geometry.theme;
    var _a4 = theme.labels || {}, fillColorLight = _a4.fillColorLight, fillColorDark = _a4.fillColorDark;
    shapes.forEach(function(shape, index) {
      var label = labels[index];
      var textShape = label.find(function(el) {
        return el.get("type") === "text";
      });
      var shapeBBox = BBox.fromObject(shape.getBBox());
      var textBBox = BBox.fromObject(textShape.getCanvasBBox());
      var overflow = !shapeBBox.contains(textBBox);
      var bgColor = shape.attr("fill");
      var fillWhite = isContrastColorWhite(bgColor);
      if (!overflow) {
        if (fillWhite) {
          if (fillColorLight) {
            textShape.attr("fill", fillColorLight);
          }
        } else {
          if (fillColorDark) {
            textShape.attr("fill", fillColorDark);
          }
        }
      } else {
        textShape.attr(theme.overflowLabels.style);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/interval/adjust-position.js
  function shouldInShapeSingle(geometry, label, shape) {
    var coordinate = geometry.coordinate;
    var textShape = findLabelTextShape(label);
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var shapeBBox = BBox.fromObject(shape.getBBox());
    return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
  }
  function shouldInShape(geometry, labels, shapes) {
    var isStack = !!geometry.getAdjust("stack");
    return isStack || labels.every(function(label, index) {
      var shape = shapes[index];
      return shouldInShapeSingle(geometry, label, shape);
    });
  }
  function moveInShape(geometry, label, shape) {
    var coordinate = geometry.coordinate;
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textShape = findLabelTextShape(label);
    if (coordinate.isTransposed) {
      textShape.attr({
        x: shapeBBox.minX + shapeBBox.width / 2,
        textAlign: "center"
      });
    } else {
      textShape.attr({
        y: shapeBBox.minY + shapeBBox.height / 2,
        textBaseline: "middle"
      });
    }
  }
  function intervalAdjustPosition(items, labels, shapes) {
    var _a4;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== "interval") {
      return;
    }
    var inShape = shouldInShape(geometry, labels, shapes);
    if (inShape) {
      shapes.forEach(function(shape, index) {
        var label = labels[index];
        moveInShape(geometry, label, shape);
      });
    }
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/interval/hide-overlap.js
  function filterLabel(labels) {
    var MAX_CNT = 500;
    var filteredLabels = [];
    var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
    each_default(labels, function(label, idx) {
      if (idx % pages === 0) {
        filteredLabels.push(label);
      } else {
        label.set("visible", false);
      }
    });
    return filteredLabels;
  }
  function intervalHideOverlap(items, labels, shapes) {
    var _a4;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== "interval") {
      return;
    }
    var filteredLabels = filterLabel(labels);
    var xField = geometry.getXYFields()[0];
    var dones = [];
    var todo = [];
    var groupedLabels = group_by_default(filteredLabels, function(label) {
      return label.get("data")[xField];
    });
    var xValues = uniq(map_default(filteredLabels, function(label) {
      return label.get("data")[xField];
    }));
    var xValue;
    filteredLabels.forEach(function(label) {
      label.set("visible", true);
    });
    var addCurrentGroup = function(curItems) {
      if (curItems) {
        if (curItems.length) {
          todo.push(curItems.pop());
        }
        todo.push.apply(todo, curItems);
      }
    };
    if (size2(xValues) > 0) {
      xValue = xValues.shift();
      addCurrentGroup(groupedLabels[xValue]);
    }
    if (size2(xValues) > 0) {
      xValue = xValues.pop();
      addCurrentGroup(groupedLabels[xValue]);
    }
    each_default(xValues.reverse(), function(val) {
      addCurrentGroup(groupedLabels[val]);
    });
    while (todo.length > 0) {
      var cur = todo.shift();
      if (cur.get("visible")) {
        if (checkShapeOverlap(cur, dones)) {
          cur.set("visible", false);
        } else {
          dones.push(cur);
        }
      }
    }
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/point/adjust-position.js
  function sortLabels(geometry, labels) {
    var yField = geometry.getXYFields()[1];
    var result = [];
    var sortedLabels = labels.sort(function(left, right) {
      return left.get("data")[yField] - left.get("data")[yField];
    });
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.shift());
    }
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.pop());
    }
    result.push.apply(result, sortedLabels);
    return result;
  }
  function hasSome(dones, current, compare) {
    return dones.some(function(done) {
      return compare(done, current);
    });
  }
  function getOverlapArea2(a, b, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
  }
  function checkShapeOverlap2(dones, current) {
    return hasSome(dones, current, function(left, right) {
      var leftText = findLabelTextShape(left);
      var rightText = findLabelTextShape(right);
      return getOverlapArea2(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
    });
  }
  function pointAdjustPosition(items, labels, shapes, region, cfg) {
    var _a4, _b;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || geometry.type !== "point") {
      return;
    }
    var _c = geometry.getXYFields(), xField = _c[0], yField = _c[1];
    var groupedLabels = group_by_default(labels, function(label) {
      return label.get("data")[xField];
    });
    var dones = [];
    var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
    map_default(keys_default(groupedLabels).reverse(), function(xValue) {
      var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);
      while (sortedCollections.length) {
        var current = sortedCollections.shift();
        var textShape = findLabelTextShape(current);
        if (hasSome(dones, current, function(left, right) {
          return left.get("data")[xField] === right.get("data")[xField] && left.get("data")[yField] === right.get("data")[yField];
        })) {
          textShape.set("visible", false);
          continue;
        }
        var upFail = checkShapeOverlap2(dones, current);
        var downFail = false;
        if (upFail) {
          textShape.attr("y", textShape.attr("y") + 2 * offset);
          downFail = checkShapeOverlap2(dones, current);
        }
        if (downFail) {
          textShape.set("visible", false);
          continue;
        }
        dones.push(current);
      }
    });
  }

  // node_modules/@antv/g2/esm/geometry/label/layout/path/adjust-position.js
  function sortLabels2(geometry, labels) {
    var yField = geometry.getXYFields()[1];
    var result = [];
    var sortedLabels = labels.sort(function(left, right) {
      return left.get("data")[yField] - left.get("data")[yField];
    });
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.shift());
    }
    if (sortedLabels.length > 0) {
      result.push(sortedLabels.pop());
    }
    result.push.apply(result, sortedLabels);
    return result;
  }
  function hasSome2(dones, current, compare) {
    return dones.some(function(done) {
      return compare(done, current);
    });
  }
  function getOverlapArea3(a, b, margin) {
    if (margin === void 0) {
      margin = 0;
    }
    var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
    var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
    return xOverlap * yOverlap;
  }
  function checkShapeOverlap3(dones, current) {
    return hasSome2(dones, current, function(left, right) {
      var leftText = findLabelTextShape(left);
      var rightText = findLabelTextShape(right);
      return getOverlapArea3(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
    });
  }
  function pathAdjustPosition(items, labels, shapes, region, cfg) {
    var _a4, _b;
    if (shapes.length === 0) {
      return;
    }
    var element = (_a4 = shapes[0]) === null || _a4 === void 0 ? void 0 : _a4.get("element");
    var geometry = element === null || element === void 0 ? void 0 : element.geometry;
    if (!geometry || ["path", "line", "area"].indexOf(geometry.type) < 0) {
      return;
    }
    var _c = geometry.getXYFields(), xField = _c[0], yField = _c[1];
    var groupedLabels = group_by_default(labels, function(label) {
      return label.get("data")[xField];
    });
    var dones = [];
    var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
    map_default(keys_default(groupedLabels).reverse(), function(xValue) {
      var sortedCollections = sortLabels2(geometry, groupedLabels[xValue]);
      while (sortedCollections.length) {
        var current = sortedCollections.shift();
        var textShape = findLabelTextShape(current);
        if (hasSome2(dones, current, function(left, right) {
          return left.get("data")[xField] === right.get("data")[xField] && left.get("data")[yField] === right.get("data")[yField];
        })) {
          textShape.set("visible", false);
          continue;
        }
        var upFail = checkShapeOverlap3(dones, current);
        var downFail = false;
        if (upFail) {
          textShape.attr("y", textShape.attr("y") + 2 * offset);
          downFail = checkShapeOverlap3(dones, current);
        }
        if (downFail) {
          textShape.set("visible", false);
          continue;
        }
        dones.push(current);
      }
    });
  }

  // node_modules/@antv/g2/esm/util/context.js
  var ctx2;
  function getCanvasContext() {
    if (!ctx2) {
      ctx2 = document.createElement("canvas").getContext("2d");
    }
    return ctx2;
  }

  // node_modules/@antv/g2/esm/util/text.js
  var measureTextWidth = memoize_default(function(text, font) {
    if (font === void 0) {
      font = {};
    }
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    var ctx3 = getCanvasContext();
    ctx3.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
    return ctx3.measureText(is_string_default(text) ? text : "").width;
  }, function(text, font) {
    if (font === void 0) {
      font = {};
    }
    return __spreadArray([text], values_default(font), true).join("");
  });
  var getEllipsisText = function(text, maxWidth, font) {
    var STEP = 16;
    var DOT_WIDTH = measureTextWidth("...", font);
    var leftText;
    if (!is_string_default(text)) {
      leftText = to_string_default(text);
    } else {
      leftText = text;
    }
    var leftWidth = maxWidth;
    var r = [];
    var currentText;
    var currentWidth;
    if (measureTextWidth(text, font) <= maxWidth) {
      return text;
    }
    while (true) {
      currentText = leftText.substr(0, STEP);
      currentWidth = measureTextWidth(currentText, font);
      if (currentWidth + DOT_WIDTH > leftWidth) {
        if (currentWidth > leftWidth) {
          break;
        }
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(STEP);
      if (!leftText) {
        return r.join("");
      }
    }
    while (true) {
      currentText = leftText.substr(0, 1);
      currentWidth = measureTextWidth(currentText, font);
      if (currentWidth + DOT_WIDTH > leftWidth) {
        break;
      }
      r.push(currentText);
      leftWidth -= currentWidth;
      leftText = leftText.substr(1);
      if (!leftText) {
        return r.join("");
      }
    }
    return r.join("") + "...";
  };

  // node_modules/@antv/g2/esm/geometry/label/layout/limit-in-plot.js
  function limitInPlot(items, labels, shapes, region, cfg) {
    if (labels.length <= 0) {
      return;
    }
    var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
    var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
    var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
    var coordinate = labels[0].get("coordinate");
    if (!coordinate) {
      return;
    }
    var _a4 = getCoordinateBBox(coordinate, margin), regionMinX = _a4.minX, regionMinY = _a4.minY, regionMaxX = _a4.maxX, regionMaxY = _a4.maxY;
    each_default(labels, function(label) {
      var _a5 = label.getCanvasBBox(), minX = _a5.minX, minY = _a5.minY, maxX = _a5.maxX, maxY = _a5.maxY, x = _a5.x, y = _a5.y, width = _a5.width, height = _a5.height;
      var finalX = x;
      var finalY = y;
      if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
        finalX = regionMinX;
      }
      if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY < regionMinY)) {
        finalY = regionMinY;
      }
      if (direction2.indexOf("right") >= 0) {
        if (minX > regionMaxX) {
          finalX = regionMaxX - width;
        } else if (maxX > regionMaxX) {
          finalX = finalX - (maxX - regionMaxX);
        }
      }
      if (direction2.indexOf("bottom") >= 0) {
        if (minY > regionMaxY) {
          finalY = regionMaxY - height;
        } else if (maxY > regionMaxY) {
          finalY = finalY - (maxY - regionMaxY);
        }
      }
      if (finalX !== x || finalY !== y) {
        var translateX_1 = finalX - x;
        if (action === "translate") {
          translate2(label, translateX_1, finalY - y);
        } else if (action === "ellipsis") {
          var textShapes = label.findAll(function(shape) {
            return shape.get("type") === "text";
          });
          textShapes.forEach(function(textShape) {
            var style = pick_default(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
            var textBox = textShape.getCanvasBBox();
            var text = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
            textShape.attr("text", text);
          });
        } else {
          label.hide();
        }
      }
    });
  }

  // node_modules/@antv/g2/esm/animate/animation/fade.js
  function fadeIn(shape, animateCfg, cfg) {
    var endState = {
      fillOpacity: is_nil_default(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
      strokeOpacity: is_nil_default(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
      opacity: is_nil_default(shape.attr("opacity")) ? 1 : shape.attr("opacity")
    };
    shape.attr({
      fillOpacity: 0,
      strokeOpacity: 0,
      opacity: 0
    });
    shape.animate(endState, animateCfg);
  }
  function fadeOut(shape, animateCfg, cfg) {
    var endState = {
      fillOpacity: 0,
      strokeOpacity: 0,
      opacity: 0
    };
    var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
    shape.animate(endState, duration, easing, function() {
      shape.remove(true);
    }, delay);
  }

  // node_modules/@antv/g2/esm/animate/animation/util.js
  function transformShape(shape, vector, direct) {
    var scaledMatrix;
    var x = vector[0], y = vector[1];
    shape.applyToMatrix([x, y, 1]);
    if (direct === "x") {
      shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 1],
        ["t", x, y]
      ]));
      scaledMatrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 100, 1],
        ["t", x, y]
      ]);
    } else if (direct === "y") {
      shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 1, 0.01],
        ["t", x, y]
      ]));
      scaledMatrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 1, 100],
        ["t", x, y]
      ]);
    } else if (direct === "xy") {
      shape.setMatrix(ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 0.01],
        ["t", x, y]
      ]));
      scaledMatrix = ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 100, 100],
        ["t", x, y]
      ]);
    }
    return scaledMatrix;
  }
  function doScaleAnimate(element, animateCfg, coordinate, yMinPoint, type) {
    var start = coordinate.start, end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var x;
    var y;
    if (type === "y") {
      x = start.x + width / 2;
      y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
    } else if (type === "x") {
      x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
      y = start.y + height / 2;
    } else if (type === "xy") {
      if (coordinate.isPolar) {
        x = coordinate.getCenter().x;
        y = coordinate.getCenter().y;
      } else {
        x = (start.x + end.x) / 2;
        y = (start.y + end.y) / 2;
      }
    }
    var endMatrix = transformShape(element, [x, y], type);
    element.animate({
      matrix: endMatrix
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/grow-in.js
  function growInX(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, "x");
  }
  function growInY(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, "y");
  }
  function growInXY(element, animateCfg, cfg) {
    var coordinate = cfg.coordinate, minYPoint = cfg.minYPoint;
    doScaleAnimate(element, animateCfg, coordinate, minYPoint, "xy");
  }

  // node_modules/@antv/g2/esm/animate/animation/path-in.js
  function pathIn(element, animateCfg, cfg) {
    var length3 = element.getTotalLength();
    element.attr("lineDash", [length3]);
    element.animate(function(ratio) {
      return {
        lineDashOffset: (1 - ratio) * length3
      };
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/position-update.js
  function positionUpdate(shape, animateCfg, cfg) {
    var toAttrs = cfg.toAttrs;
    var x = toAttrs.x;
    var y = toAttrs.y;
    delete toAttrs.x;
    delete toAttrs.y;
    shape.attr(toAttrs);
    shape.animate({
      x,
      y
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/scale-in.js
  function scaleInX(shape, animateCfg, cfg) {
    var box2 = shape.getBBox();
    var mappingData = shape.get("origin").mappingData;
    var points = mappingData.points;
    var x = points[0].y - points[1].y > 0 ? box2.maxX : box2.minX;
    var y = (box2.minY + box2.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    var matrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 1],
      ["t", x, y]
    ]);
    shape.setMatrix(matrix);
    shape.animate({
      matrix: ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 100, 1],
        ["t", x, y]
      ])
    }, animateCfg);
  }
  function scaleInY(shape, animateCfg, cfg) {
    var box2 = shape.getBBox();
    var mappingData = shape.get("origin").mappingData;
    var x = (box2.minX + box2.maxX) / 2;
    var points = mappingData.points;
    var y = points[0].y - points[1].y <= 0 ? box2.maxY : box2.minY;
    shape.applyToMatrix([x, y, 1]);
    var matrix = ext_exports.transform(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 0.01],
      ["t", x, y]
    ]);
    shape.setMatrix(matrix);
    shape.animate({
      matrix: ext_exports.transform(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 1, 100],
        ["t", x, y]
      ])
    }, animateCfg);
  }

  // node_modules/@antv/g2/esm/animate/animation/sector-path-update.js
  function getAngle3(startPoint, arcPath) {
    var _a4;
    var _b = getArcParams2(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (!isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
      startAngle += Math.PI * 2;
    }
    if (!isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
      endAngle += Math.PI * 2;
    }
    if (arcPath[5] === 0) {
      _a4 = [endAngle, startAngle], startAngle = _a4[0], endAngle = _a4[1];
    }
    if (isNumberEqual(startAngle, Math.PI * 1.5)) {
      startAngle = Math.PI * -0.5;
    }
    if (isNumberEqual(endAngle, Math.PI * -0.5)) {
      endAngle = Math.PI * 1.5;
    }
    return {
      startAngle,
      endAngle
    };
  }
  function getArcStartPoint(path) {
    var startPoint;
    if (path[0] === "M" || path[0] === "L") {
      startPoint = [path[1], path[2]];
    } else if (path[0] === "a" || path[0] === "A" || path[0] === "C") {
      startPoint = [path[path.length - 2], path[path.length - 1]];
    }
    return startPoint;
  }
  function getArcInfo(path) {
    var _a4;
    var startAngle;
    var endAngle;
    var arcPaths = path.filter(function(command) {
      return command[0] === "A" || command[0] === "a";
    });
    if (arcPaths.length === 0) {
      return {
        startAngle: 0,
        endAngle: 0,
        radius: 0,
        innerRadius: 0
      };
    }
    var firstArcPathCommand = arcPaths[0];
    var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
    var firstIndex = path.indexOf(firstArcPathCommand);
    var lastIndex = path.indexOf(lastArcPathCommand);
    var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
    var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);
    var _b = getAngle3(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
    var _c = getAngle3(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
    if (isNumberEqual(firstStartAngle, lastStartAngle) && isNumberEqual(firstEndAngle, lastEndAngle)) {
      startAngle = firstStartAngle;
      endAngle = firstEndAngle;
    } else {
      startAngle = Math.min(firstStartAngle, lastStartAngle);
      endAngle = Math.max(firstEndAngle, lastEndAngle);
    }
    var radius = firstArcPathCommand[1];
    var innerRadius = arcPaths[arcPaths.length - 1][1];
    if (radius < innerRadius) {
      _a4 = [innerRadius, radius], radius = _a4[0], innerRadius = _a4[1];
    } else if (radius === innerRadius) {
      innerRadius = 0;
    }
    return {
      startAngle,
      endAngle,
      radius,
      innerRadius
    };
  }
  function sectorPathUpdate(shape, animateCfg, cfg) {
    var toAttrs = cfg.toAttrs, coordinate = cfg.coordinate;
    var path = toAttrs.path || [];
    var pathCommands = path.map(function(command) {
      return command[0];
    });
    if (path.length < 1)
      return;
    var _a4 = getArcInfo(path), curStartAngle = _a4.startAngle, curEndAngle = _a4.endAngle, radius = _a4.radius, innerRadius = _a4.innerRadius;
    var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
    var center = coordinate.getCenter();
    var diffStartAngle = curStartAngle - preStartAngle;
    var diffEndAngle = curEndAngle - preEndAngle;
    if (diffStartAngle === 0 && diffEndAngle === 0) {
      shape.attr("path", path);
      return;
    }
    shape.animate(function(ratio) {
      var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
      var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
      return __assign(__assign({}, toAttrs), { path: is_equal_default(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius) });
    }, __assign(__assign({}, animateCfg), { callback: function() {
      shape.attr("path", path);
    } }));
  }

  // node_modules/@antv/g2/esm/animate/animation/wave-in.js
  function waveIn(element, animateCfg, cfg) {
    var _a4 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a4.type, startState = _a4.startState, endState = _a4.endState;
    var clipShape = element.setClip({
      type,
      attrs: startState
    });
    clipShape.animate(endState, __assign(__assign({}, animateCfg), { callback: function() {
      if (element && !element.get("destroyed")) {
        element.set("clipShape", null);
      }
      clipShape.remove(true);
    } }));
  }

  // node_modules/@antv/g2/esm/animate/animation/zoom.js
  function doShapeZoom(shape, animateCfg, type) {
    if (shape.isGroup()) {
      each_default(shape.getChildren(), function(child) {
        doShapeZoom(child, animateCfg, type);
      });
    } else {
      var bbox = shape.getBBox();
      var x = (bbox.minX + bbox.maxX) / 2;
      var y = (bbox.minY + bbox.maxY) / 2;
      shape.applyToMatrix([x, y, 1]);
      if (type === "zoomIn") {
        var matrix = ext_exports.transform(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 0.01, 0.01],
          ["t", x, y]
        ]);
        shape.setMatrix(matrix);
        shape.animate({
          matrix: ext_exports.transform(shape.getMatrix(), [
            ["t", -x, -y],
            ["s", 100, 100],
            ["t", x, y]
          ])
        }, animateCfg);
      } else {
        shape.animate({
          matrix: ext_exports.transform(shape.getMatrix(), [
            ["t", -x, -y],
            ["s", 0.01, 0.01],
            ["t", x, y]
          ])
        }, __assign(__assign({}, animateCfg), { callback: function() {
          shape.remove(true);
        } }));
      }
    }
  }
  function zoomIn(shape, animateCfg, cfg) {
    doShapeZoom(shape, animateCfg, "zoomIn");
  }
  function zoomOut(shape, animateCfg, cfg) {
    doShapeZoom(shape, animateCfg, "zoomOut");
  }

  // node_modules/@antv/g2/esm/util/facet.js
  function getFactTitleConfig(direction2) {
    if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
      return {
        offsetX: 0,
        offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
        style: {
          textAlign: "center",
          textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
        }
      };
    }
    if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
      return {
        offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
        offsetY: 0,
        style: {
          textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
          textBaseline: "middle",
          rotate: Math.PI / 2
        }
      };
    }
    return {};
  }
  function getAnglePoint(center, r, angle3) {
    return {
      x: center.x + r * Math.cos(angle3),
      y: center.y + r * Math.sin(angle3)
    };
  }

  // node_modules/@antv/g2/esm/facet/circle.js
  var Circle5 = function(_super) {
    __extends(Circle6, _super);
    function Circle6() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle6.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "circle",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Circle6.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Circle6.prototype.getRegion = function(count2, index) {
      var r = 1 / 2;
      var center = { x: 0.5, y: 0.5 };
      var avgAngle = Math.PI * 2 / count2;
      var angle3 = -1 * Math.PI / 2 + avgAngle * index;
      var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
      var middle = getAnglePoint(center, r - facetR, angle3);
      var startAngle = Math.PI * 5 / 4;
      var endAngle = Math.PI * 1 / 4;
      return {
        start: getAnglePoint(middle, facetR, startAngle),
        end: getAnglePoint(middle, facetR, endAngle)
      };
    };
    Circle6.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Circle6.prototype.beforeEachView = function(view, facet) {
    };
    Circle6.prototype.generateFacets = function(data) {
      var _this = this;
      var _a4 = this.cfg, fields = _a4.fields, type = _a4.type;
      var field = fields[0];
      if (!field) {
        throw new Error("No `fields` specified!");
      }
      var values2 = this.getFieldValues(data, field);
      var count2 = values2.length;
      var rst = [];
      values2.forEach(function(value, index) {
        var conditions = [{ field, value, values: values2 }];
        var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type,
          data: facetData,
          region: _this.getRegion(count2, index),
          columnValue: value,
          columnField: field,
          columnIndex: index,
          columnValuesLength: count2,
          rowValue: null,
          rowField: null,
          rowIndex: 0,
          rowValuesLength: 1
        };
        rst.push(facet);
      });
      return rst;
    };
    Circle6.prototype.getXAxisOption = function(x, axes, option, facet) {
      return option;
    };
    Circle6.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Circle6.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    return Circle6;
  }(Facet);
  var circle_default8 = Circle5;

  // node_modules/@antv/g2/esm/facet/list.js
  var List = function(_super) {
    __extends(List2, _super);
    function List2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    List2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "list",
        cols: null,
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    List2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    List2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    List2.prototype.beforeEachView = function(view, facet) {
    };
    List2.prototype.generateFacets = function(data) {
      var _this = this;
      var fields = this.cfg.fields;
      var cols = this.cfg.cols;
      var columnField = fields[0];
      if (!columnField) {
        throw new Error("No `fields` specified!");
      }
      var colValues = this.getFieldValues(data, columnField);
      var count2 = colValues.length;
      cols = cols || count2;
      var rows = this.getPageCount(count2, cols);
      var rst = [];
      colValues.forEach(function(val, index) {
        var _a4 = _this.getRowCol(index, cols), row = _a4.row, col = _a4.col;
        var conditions = [{ field: columnField, value: val, values: colValues }];
        var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rows, cols, col, row),
          columnValue: val,
          rowValue: val,
          columnField,
          rowField: null,
          columnIndex: col,
          rowIndex: row,
          columnValuesLength: cols,
          rowValuesLength: rows,
          total: count2
        };
        rst.push(facet);
      });
      return rst;
    };
    List2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    List2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    List2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    List2.prototype.getPageCount = function(total, pageSize) {
      return Math.floor((total + pageSize - 1) / pageSize);
    };
    List2.prototype.getRowCol = function(index, pageSize) {
      var row = Math.floor(index / pageSize);
      var col = index % pageSize;
      return { row, col };
    };
    return List2;
  }(Facet);
  var list_default = List;

  // node_modules/@antv/g2/esm/facet/matrix.js
  var Matrix = function(_super) {
    __extends(Matrix2, _super);
    function Matrix2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Matrix2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "matrix",
        showTitle: false,
        columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Matrix2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Matrix2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Matrix2.prototype.beforeEachView = function(view, facet) {
    };
    Matrix2.prototype.generateFacets = function(data) {
      var _a4 = this.cfg, fields = _a4.fields, type = _a4.type;
      var rowValuesLength = fields.length;
      var columnValuesLength = rowValuesLength;
      var rst = [];
      for (var i = 0; i < columnValuesLength; i++) {
        var columnField = fields[i];
        for (var j = 0; j < rowValuesLength; j++) {
          var rowField = fields[j];
          var facet = {
            type,
            data,
            region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
            columnValue: columnField,
            rowValue: rowField,
            columnField,
            rowField,
            columnIndex: i,
            rowIndex: j,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        }
      }
      return rst;
    };
    Matrix2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    Matrix2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    Matrix2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, rowValuesLength = facet.rowValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get_default(_this.cfg.columnTitle, "formatter");
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get_default(_this.cfg.rowTitle, "formatter");
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    return Matrix2;
  }(Facet);
  var matrix_default = Matrix;

  // node_modules/@antv/g2/esm/facet/mirror.js
  var Mirror = function(_super) {
    __extends(Mirror2, _super);
    function Mirror2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Mirror2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "mirror",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this),
        transpose: false
      });
    };
    Mirror2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Mirror2.prototype.beforeEachView = function(view, facet) {
      if (this.cfg.transpose) {
        if (facet.columnIndex % 2 === 0) {
          view.coordinate().transpose().reflect("x");
        } else {
          view.coordinate().transpose();
        }
      } else {
        if (facet.rowIndex % 2 !== 0) {
          view.coordinate().reflect("y");
        }
      }
    };
    Mirror2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Mirror2.prototype.generateFacets = function(data) {
      var _this = this;
      var f = this.cfg.fields[0];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      var columnField;
      var rowField;
      if (this.cfg.transpose) {
        columnField = f;
        columnValues = this.getFieldValues(data, columnField).slice(0, 2);
        columnValuesLength = columnValues.length;
      } else {
        rowField = f;
        rowValues = this.getFieldValues(data, rowField).slice(0, 2);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Mirror2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.columnIndex === 1 || facet.rowIndex === 1) {
        return __assign(__assign({}, option), { label: null, title: null });
      }
      return option;
    };
    Mirror2.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Mirror2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        if (_this.cfg.transpose) {
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
          view.annotation().text(config);
        } else {
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
          view.annotation().text(config);
        }
      });
    };
    return Mirror2;
  }(Facet);
  var mirror_default = Mirror;

  // node_modules/@antv/g2/esm/facet/rect.js
  var Rect3 = function(_super) {
    __extends(Rect4, _super);
    function Rect4() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect4.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Rect4.prototype.beforeEachView = function(view, facet) {
    };
    Rect4.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "rect",
        columnTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Rect4.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Rect4.prototype.generateFacets = function(data) {
      var _this = this;
      var _a4 = this.cfg.fields, columnField = _a4[0], rowField = _a4[1];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      if (columnField) {
        columnValues = this.getFieldValues(data, columnField);
        columnValuesLength = columnValues.length;
      }
      if (rowField) {
        rowValues = this.getFieldValues(data, rowField);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter_default(data, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Rect4.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get_default(_this.cfg.columnTitle, "formatter");
          var config = deep_mix_default({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get_default(_this.cfg.rowTitle, "formatter");
          var config = deep_mix_default({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    Rect4.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { title: null, label: null });
      } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
        return __assign(__assign({}, option), { title: null });
      }
      return option;
    };
    Rect4.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
        return __assign(__assign({}, option), { title: null });
      }
      return option;
    };
    return Rect4;
  }(Facet);
  var rect_default5 = Rect3;

  // node_modules/@antv/g2/esm/facet/tree.js
  var Tree = function(_super) {
    __extends(Tree2, _super);
    function Tree2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.afterChartRender = function() {
        if (_this.facets && _this.cfg.line) {
          _this.container.clear();
          _this.drawLines(_this.facets);
        }
      };
      return _this;
    }
    Tree2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Tree2.prototype.beforeEachView = function(view, facet) {
    };
    Tree2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
    };
    Tree2.prototype.getDefaultCfg = function() {
      return deep_mix_default({}, _super.prototype.getDefaultCfg.call(this), {
        type: "tree",
        line: {
          style: {
            lineWidth: 1,
            stroke: "#ddd"
          },
          smooth: false
        },
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Tree2.prototype.generateFacets = function(data) {
      var fields = this.cfg.fields;
      if (!fields.length) {
        throw new Error("Please specify for the fields for rootFacet!");
      }
      var rst = [];
      var rootFacet = {
        type: this.cfg.type,
        data,
        region: null,
        rowValuesLength: this.getRows(),
        columnValuesLength: 1,
        rowIndex: 0,
        columnIndex: 0,
        rowField: "",
        columnField: "",
        rowValue: "",
        columnValue: ""
      };
      rst.push(rootFacet);
      rootFacet.children = this.getChildFacets(data, 1, rst);
      this.setRegion(rst);
      return rst;
    };
    Tree2.prototype.setRegion = function(facets) {
      var _this = this;
      this.forceColIndex(facets);
      facets.forEach(function(facet) {
        facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
      });
    };
    Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var xWidth = 1 / cols;
      var yWidth = 1 / rows;
      var start = {
        x: xWidth * xIndex,
        y: yWidth * yIndex
      };
      var end = {
        x: start.x + xWidth,
        y: start.y + yWidth * 2 / 3
      };
      return {
        start,
        end
      };
    };
    Tree2.prototype.forceColIndex = function(facets) {
      var _this = this;
      var leafs = [];
      var index = 0;
      facets.forEach(function(facet2) {
        if (_this.isLeaf(facet2)) {
          leafs.push(facet2);
          facet2.columnIndex = index;
          index++;
        }
      });
      leafs.forEach(function(facet2) {
        facet2.columnValuesLength = leafs.length;
      });
      var maxLevel = this.cfg.fields.length;
      for (var i = maxLevel - 1; i >= 0; i--) {
        var levelFacets = this.getFacetsByLevel(facets, i);
        for (var _i = 0, levelFacets_1 = levelFacets; _i < levelFacets_1.length; _i++) {
          var facet = levelFacets_1[_i];
          if (!this.isLeaf(facet)) {
            facet.originColIndex = facet.columnIndex;
            facet.columnIndex = this.getRegionIndex(facet.children);
            facet.columnValuesLength = leafs.length;
          }
        }
      }
    };
    Tree2.prototype.getFacetsByLevel = function(facets, level) {
      var rst = [];
      facets.forEach(function(facet) {
        if (facet.rowIndex === level) {
          rst.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.getRegionIndex = function(children) {
      var first = children[0];
      var last2 = children[children.length - 1];
      return (last2.columnIndex - first.columnIndex) / 2 + first.columnIndex;
    };
    Tree2.prototype.isLeaf = function(facet) {
      return !facet.children || !facet.children.length;
    };
    Tree2.prototype.getRows = function() {
      return this.cfg.fields.length + 1;
    };
    Tree2.prototype.getChildFacets = function(data, level, arr) {
      var _this = this;
      var fields = this.cfg.fields;
      var length3 = fields.length;
      if (length3 < level) {
        return;
      }
      var rst = [];
      var field = fields[level - 1];
      var values2 = this.getFieldValues(data, field);
      values2.forEach(function(value, index) {
        var conditions = [{ field, value, values: values2 }];
        var subData = data.filter(_this.getFacetDataFilter(conditions));
        if (subData.length) {
          var facet = {
            type: _this.cfg.type,
            data: subData,
            region: null,
            columnValue: value,
            rowValue: "",
            columnField: field,
            rowField: "",
            columnIndex: index,
            rowValuesLength: _this.getRows(),
            columnValuesLength: 1,
            rowIndex: level,
            children: _this.getChildFacets(subData, level + 1, arr)
          };
          rst.push(facet);
          arr.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Tree2.prototype.renderTitle = function() {
      var _this = this;
      each_default(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get_default(_this.cfg.title, "formatter");
        var config = deep_mix_default({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    Tree2.prototype.drawLines = function(facets) {
      var _this = this;
      facets.forEach(function(facet) {
        if (!_this.isLeaf(facet)) {
          var children = facet.children;
          _this.addFacetLines(facet, children);
        }
      });
    };
    Tree2.prototype.addFacetLines = function(facet, children) {
      var _this = this;
      var view = facet.view;
      var region = view.coordinateBBox;
      var start = {
        x: region.x + region.width / 2,
        y: region.y + region.height
      };
      children.forEach(function(subFacet) {
        var subRegion = subFacet.view.coordinateBBox;
        var end = {
          x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
          y: subRegion.tr.y
        };
        var middle1 = {
          x: start.x,
          y: start.y + (end.y - start.y) / 2
        };
        var middle2 = {
          x: end.x,
          y: middle1.y
        };
        _this.drawLine([start, middle1, middle2, end]);
      });
    };
    Tree2.prototype.getPath = function(points) {
      var path = [];
      var smooth = this.cfg.line.smooth;
      if (smooth) {
        path.push(["M", points[0].x, points[0].y]);
        path.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
      } else {
        points.forEach(function(point, index) {
          if (index === 0) {
            path.push(["M", point.x, point.y]);
          } else {
            path.push(["L", point.x, point.y]);
          }
        });
      }
      return path;
    };
    Tree2.prototype.drawLine = function(points) {
      var path = this.getPath(points);
      var line = this.cfg.line.style;
      this.container.addShape("path", {
        attrs: mix({
          path
        }, line)
      });
    };
    Tree2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    Tree2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
        return __assign(__assign({}, option), { title: null, label: null });
      }
      return option;
    };
    return Tree2;
  }(Facet);
  var tree_default = Tree;

  // node_modules/@antv/g2/esm/util/stat.js
  function getMedian(array2) {
    var arr = __spreadArray([], array2, true);
    arr.sort(function(a, b) {
      return a - b;
    });
    var len3 = arr.length;
    if (len3 === 0) {
      return 0;
    }
    if (len3 % 2 === 1) {
      return arr[(len3 - 1) / 2];
    }
    return (arr[len3 / 2] + arr[len3 / 2 - 1]) / 2;
  }
  function getMean(array2) {
    var sum5 = reduce_default(array2, function(r, num) {
      return r += isNaN(num) || !is_number_default(num) ? 0 : num;
    }, 0);
    return array2.length === 0 ? 0 : sum5 / array2.length;
  }

  // node_modules/@antv/g2/esm/util/annotation.js
  function getNormalizedValue(val, scale5) {
    if (!scale5) {
      return null;
    }
    var scaled;
    switch (val) {
      case "start":
        return 0;
      case "center":
        return 0.5;
      case "end":
        return 1;
      case "median": {
        scaled = scale5.isCategory ? getMedian(scale5.values.map(function(_6, idx) {
          return idx;
        })) : getMedian(scale5.values);
        break;
      }
      case "mean": {
        scaled = scale5.isCategory ? (scale5.values.length - 1) / 2 : getMean(scale5.values);
        break;
      }
      case "min":
        scaled = scale5.isCategory ? 0 : scale5[val];
        break;
      case "max":
        scaled = scale5.isCategory ? scale5.values.length - 1 : scale5[val];
        break;
      default:
        scaled = val;
        break;
    }
    return scale5.scale(scaled);
  }

  // node_modules/@antv/g2/esm/chart/controller/annotation.js
  var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
  var Annotation = function(_super) {
    __extends(Annotation2, _super);
    function Annotation2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = new Map();
      _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.option = [];
      return _this;
    }
    Object.defineProperty(Annotation2.prototype, "name", {
      get: function() {
        return "annotation";
      },
      enumerable: false,
      configurable: true
    });
    Annotation2.prototype.init = function() {
    };
    Annotation2.prototype.layout = function() {
      this.update();
    };
    Annotation2.prototype.render = function() {
    };
    Annotation2.prototype.update = function() {
      var _this = this;
      this.onAfterRender(function() {
        var updated = new Map();
        each_default(_this.option, function(option) {
          if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
            var co = _this.updateOrCreate(option);
            if (co) {
              updated.set(_this.getCacheKey(option), co);
            }
          }
        });
        _this.cache = _this.syncCache(updated);
      });
      var updateCache = new Map();
      each_default(this.option, function(option) {
        if (!contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updateCache.set(_this.getCacheKey(option), co);
          }
        }
      });
      this.cache = this.syncCache(updateCache);
    };
    Annotation2.prototype.clear = function(includeOption) {
      if (includeOption === void 0) {
        includeOption = false;
      }
      _super.prototype.clear.call(this);
      this.clearComponents();
      this.foregroundContainer.clear();
      this.backgroundContainer.clear();
      if (includeOption) {
        this.option = [];
      }
    };
    Annotation2.prototype.destroy = function() {
      this.clear(true);
      this.foregroundContainer.remove(true);
      this.backgroundContainer.remove(true);
    };
    Annotation2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value) {
        co.push(value);
      });
      return co;
    };
    Annotation2.prototype.clearComponents = function() {
      this.getComponents().forEach(function(co) {
        co.component.destroy();
      });
      this.cache.clear();
    };
    Annotation2.prototype.onAfterRender = function(doWhat) {
      if (this.view.getOptions().animate) {
        this.view.geometries.forEach(function(g) {
          if (g.animateOption) {
            g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
              doWhat();
            });
          }
        });
      } else {
        this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
          doWhat();
        });
      }
    };
    Annotation2.prototype.createAnnotation = function(option) {
      var type = option.type;
      var Ctor = annotation_exports[upper_first_default(type)];
      if (Ctor) {
        var theme = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme);
        var annotation = new Ctor(cfg);
        return {
          component: annotation,
          layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.ANNOTATION,
          extra: option
        };
      }
    };
    Annotation2.prototype.annotation = function(option) {
      this.option.push(option);
    };
    Annotation2.prototype.arc = function(option) {
      this.annotation(__assign({ type: "arc" }, option));
      return this;
    };
    Annotation2.prototype.image = function(option) {
      this.annotation(__assign({ type: "image" }, option));
      return this;
    };
    Annotation2.prototype.line = function(option) {
      this.annotation(__assign({ type: "line" }, option));
      return this;
    };
    Annotation2.prototype.region = function(option) {
      this.annotation(__assign({ type: "region" }, option));
      return this;
    };
    Annotation2.prototype.text = function(option) {
      this.annotation(__assign({ type: "text" }, option));
      return this;
    };
    Annotation2.prototype.dataMarker = function(option) {
      this.annotation(__assign({ type: "dataMarker" }, option));
      return this;
    };
    Annotation2.prototype.dataRegion = function(option) {
      this.annotation(__assign({ type: "dataRegion" }, option));
    };
    Annotation2.prototype.regionFilter = function(option) {
      this.annotation(__assign({ type: "regionFilter" }, option));
    };
    Annotation2.prototype.shape = function(option) {
      this.annotation(__assign({ type: "shape" }, option));
    };
    Annotation2.prototype.html = function(option) {
      this.annotation(__assign({ type: "html" }, option));
    };
    Annotation2.prototype.parsePosition = function(p3) {
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var position = is_function_default(p3) ? p3.call(null, xScale, yScales) : p3;
      var x = 0;
      var y = 0;
      if (is_array_default(position)) {
        var xPos = position[0], yPos = position[1];
        if (is_string_default(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
          return this.parsePercentPosition(position);
        }
        x = getNormalizedValue(xPos, xScale);
        y = getNormalizedValue(yPos, Object.values(yScales)[0]);
      } else if (!is_nil_default(position)) {
        for (var _i = 0, _a4 = keys_default(position); _i < _a4.length; _i++) {
          var key = _a4[_i];
          var value = position[key];
          if (key === xScale.field) {
            x = getNormalizedValue(value, xScale);
          }
          if (yScales[key]) {
            y = getNormalizedValue(value, yScales[key]);
          }
        }
      }
      return this.view.getCoordinate().convert({ x, y });
    };
    Annotation2.prototype.getRegionPoints = function(start, end) {
      var _this = this;
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var yScale = Object.values(yScales)[0];
      var xField = xScale.field;
      var viewData = this.view.getData();
      var startXValue = is_array_default(start) ? start[0] : start[xField];
      var endXValue = is_array_default(end) ? end[0] : end[xField];
      var arr = [];
      var startIndex;
      each_default(viewData, function(item, idx) {
        if (item[xField] === startXValue) {
          startIndex = idx;
        }
        if (idx >= startIndex) {
          var point = _this.parsePosition([item[xField], item[yScale.field]]);
          if (point) {
            arr.push(point);
          }
        }
        if (item[xField] === endXValue) {
          return false;
        }
      });
      return arr;
    };
    Annotation2.prototype.parsePercentPosition = function(position) {
      var xPercent = parseFloat(position[0]) / 100;
      var yPercent = parseFloat(position[1]) / 100;
      var coordinate = this.view.getCoordinate();
      var start = coordinate.start, end = coordinate.end;
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      var x = coordinate.getWidth() * xPercent + topLeft.x;
      var y = coordinate.getHeight() * yPercent + topLeft.y;
      return { x, y };
    };
    Annotation2.prototype.getCoordinateBBox = function() {
      var coordinate = this.view.getCoordinate();
      var start = coordinate.start, end = coordinate.end;
      var width = coordinate.getWidth();
      var height = coordinate.getHeight();
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      return {
        x: topLeft.x,
        y: topLeft.y,
        minX: topLeft.x,
        minY: topLeft.y,
        maxX: topLeft.x + width,
        maxY: topLeft.y + height,
        width,
        height
      };
    };
    Annotation2.prototype.getAnnotationCfg = function(type, option, theme) {
      var _this = this;
      var coordinate = this.view.getCoordinate();
      var canvas = this.view.getCanvas();
      var o = {};
      if (is_nil_default(option)) {
        return null;
      }
      if (type === "arc") {
        var _a4 = option, start = _a4.start, end = _a4.end, rest = __rest(_a4, ["start", "end"]);
        var sp = this.parsePosition(start);
        var ep = this.parsePosition(end);
        var startAngle = getAngleByPoint(coordinate, sp);
        var endAngle = getAngleByPoint(coordinate, ep);
        if (startAngle > endAngle) {
          endAngle = Math.PI * 2 + endAngle;
        }
        o = __assign(__assign({}, rest), { center: coordinate.getCenter(), radius: getDistanceToCenter(coordinate, sp), startAngle, endAngle });
      } else if (type === "image") {
        var _b = option, start = _b.start, end = _b.end, rest = __rest(_b, ["start", "end"]);
        o = __assign(__assign({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end), src: option.src });
      } else if (type === "line") {
        var _c = option, start = _c.start, end = _c.end, rest = __rest(_c, ["start", "end"]);
        o = __assign(__assign({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end), text: get_default(option, "text", null) });
      } else if (type === "region") {
        var _d = option, start = _d.start, end = _d.end, rest = __rest(_d, ["start", "end"]);
        o = __assign(__assign({}, rest), { start: this.parsePosition(start), end: this.parsePosition(end) });
      } else if (type === "text") {
        var filteredData = this.view.getData();
        var _e = option, position = _e.position, content = _e.content, rest = __rest(_e, ["position", "content"]);
        var textContent = content;
        if (is_function_default(content)) {
          textContent = content(filteredData);
        }
        o = __assign(__assign(__assign({}, this.parsePosition(position)), rest), { content: textContent });
      } else if (type === "dataMarker") {
        var _f = option, position = _f.position, point = _f.point, line = _f.line, text = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest = __rest(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
        o = __assign(__assign(__assign({}, rest), this.parsePosition(position)), { coordinateBBox: this.getCoordinateBBox(), point, line, text, autoAdjust, direction: direction2 });
      } else if (type === "dataRegion") {
        var _g = option, start = _g.start, end = _g.end, region = _g.region, text = _g.text, lineLength = _g.lineLength, rest = __rest(_g, ["start", "end", "region", "text", "lineLength"]);
        o = __assign(__assign({}, rest), { points: this.getRegionPoints(start, end), region, text, lineLength });
      } else if (type === "regionFilter") {
        var _h = option, start = _h.start, end = _h.end, apply_1 = _h.apply, color2 = _h.color, rest = __rest(_h, ["start", "end", "apply", "color"]);
        var geometries = this.view.geometries;
        var shapes_1 = [];
        var addShapes_1 = function(item) {
          if (!item) {
            return;
          }
          if (item.isGroup()) {
            item.getChildren().forEach(function(child) {
              return addShapes_1(child);
            });
          } else {
            shapes_1.push(item);
          }
        };
        each_default(geometries, function(geom) {
          if (apply_1) {
            if (contains_default(apply_1, geom.type)) {
              each_default(geom.elements, function(elem) {
                addShapes_1(elem.shape);
              });
            }
          } else {
            each_default(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        });
        o = __assign(__assign({}, rest), { color: color2, shapes: shapes_1, start: this.parsePosition(start), end: this.parsePosition(end) });
      } else if (type === "shape") {
        var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
        var wrappedRender = function(container) {
          if (is_function_default(option.render)) {
            return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
          }
        };
        o = __assign(__assign({}, restOptions), { render: wrappedRender });
      } else if (type === "html") {
        var _k = option, html_1 = _k.html, position = _k.position, restOptions = __rest(_k, ["html", "position"]);
        var wrappedHtml = function(container) {
          if (is_function_default(html_1)) {
            return html_1(container, _this.view);
          }
          return html_1;
        };
        o = __assign(__assign(__assign({}, restOptions), this.parsePosition(position)), {
          parent: canvas.get("el").parentNode,
          html: wrappedHtml
        });
      }
      var cfg = deep_mix_default({}, theme, __assign(__assign({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
      if (type !== "html") {
        cfg.container = this.getComponentContainer(cfg);
      }
      cfg.animate = this.view.getOptions().animate && cfg.animate && get_default(option, "animate", cfg.animate);
      cfg.animateOption = deep_mix_default({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
      return cfg;
    };
    Annotation2.prototype.isTop = function(option) {
      return get_default(option, "top", true);
    };
    Annotation2.prototype.getComponentContainer = function(option) {
      return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
    };
    Annotation2.prototype.getAnnotationTheme = function(type) {
      return get_default(this.view.getTheme(), ["components", "annotation", type], {});
    };
    Annotation2.prototype.updateOrCreate = function(option) {
      var co = this.cache.get(this.getCacheKey(option));
      if (co) {
        var type = option.type;
        var theme = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme);
        omit(cfg, ["container"]);
        co.component.update(cfg);
        if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      } else {
        co = this.createAnnotation(option);
        if (co) {
          co.component.init();
          if (contains_default(ANNOTATIONS_AFTER_RENDER, option.type)) {
            co.component.render();
          }
        }
      }
      return co;
    };
    Annotation2.prototype.syncCache = function(updated) {
      var _this = this;
      var newCache = new Map(this.cache);
      updated.forEach(function(co, key) {
        newCache.set(key, co);
      });
      newCache.forEach(function(co, key) {
        if (!find_default(_this.option, function(option) {
          return key === _this.getCacheKey(option);
        })) {
          co.component.destroy();
          newCache.delete(key);
        }
      });
      return newCache;
    };
    Annotation2.prototype.getCacheKey = function(option) {
      return option;
    };
    return Annotation2;
  }(Controller);
  var annotation_default = Annotation;

  // node_modules/@antv/g2/esm/util/grid.js
  function getGridThemeCfg(theme, direction2) {
    var axisTheme = deep_mix_default({}, get_default(theme, ["components", "axis", "common"]), get_default(theme, ["components", "axis", direction2]));
    return get_default(axisTheme, ["grid"], {});
  }
  function getLineGridItems(coordinate, scale5, dim, alignTick) {
    var items = [];
    var ticks = scale5.getTicks();
    if (coordinate.isPolar) {
      ticks.push({
        value: 1,
        text: "",
        tickValue: ""
      });
    }
    ticks.reduce(function(preTick, currentTick, currentIndex) {
      var currentValue = currentTick.value;
      if (alignTick) {
        items.push({
          points: [
            coordinate.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
            coordinate.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
          ]
        });
      } else {
        if (currentIndex) {
          var preValue = preTick.value;
          var middleValue = (preValue + currentValue) / 2;
          items.push({
            points: [
              coordinate.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
              coordinate.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
            ]
          });
        }
      }
      return currentTick;
    }, ticks[0]);
    return items;
  }
  function getCircleGridItems(coordinate, xScale, yScale, alignTick, dim) {
    var count2 = xScale.values.length;
    var items = [];
    var ticks = yScale.getTicks();
    ticks.reduce(function(preTick, currentTick) {
      var preValue = preTick ? preTick.value : currentTick.value;
      var currentValue = currentTick.value;
      var middleValue = (preValue + currentValue) / 2;
      if (dim === "x") {
        items.push({
          points: [
            coordinate.convert({
              x: alignTick ? currentValue : middleValue,
              y: 0
            }),
            coordinate.convert({
              x: alignTick ? currentValue : middleValue,
              y: 1
            })
          ]
        });
      } else {
        items.push({
          points: map_default(Array(count2 + 1), function(__, idx) {
            return coordinate.convert({
              x: idx / count2,
              y: alignTick ? currentValue : middleValue
            });
          })
        });
      }
      return currentTick;
    }, ticks[0]);
    return items;
  }
  function showGrid(axisTheme, axisOption) {
    var userGrid = get_default(axisOption, "grid");
    if (userGrid === null) {
      return false;
    }
    var themeGrid = get_default(axisTheme, "grid");
    return !(userGrid === void 0 && themeGrid === null);
  }

  // node_modules/@antv/g2/esm/chart/controller/axis.js
  var OMIT_CFG = ["container"];
  var AXIS_DEFAULT_ANIMATE_CFG = __assign(__assign({}, DEFAULT_ANIMATE_CFG), { appear: null });
  var Axis = function(_super) {
    __extends(Axis2, _super);
    function Axis2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = new Map();
      _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Axis2.prototype, "name", {
      get: function() {
        return "axis";
      },
      enumerable: false,
      configurable: true
    });
    Axis2.prototype.init = function() {
    };
    Axis2.prototype.render = function() {
      this.update();
    };
    Axis2.prototype.layout = function() {
      var _this = this;
      var coordinate = this.view.getCoordinate();
      each_default(this.getComponents(), function(co) {
        var component = co.component, direction2 = co.direction, type = co.type, extra = co.extra;
        var dim = extra.dim, scale5 = extra.scale, alignTick = extra.alignTick;
        var updated;
        if (type === COMPONENT_TYPE.AXIS) {
          if (coordinate.isPolar) {
            if (dim === "x") {
              updated = coordinate.isTransposed ? getAxisRegion(coordinate, direction2) : getCircleAxisCenterRadius(coordinate);
            } else if (dim === "y") {
              updated = coordinate.isTransposed ? getCircleAxisCenterRadius(coordinate) : getAxisRegion(coordinate, direction2);
            }
          } else {
            updated = getAxisRegion(coordinate, direction2);
          }
        } else if (type === COMPONENT_TYPE.GRID) {
          if (coordinate.isPolar) {
            var items = void 0;
            if (coordinate.isTransposed) {
              items = dim === "x" ? getCircleGridItems(coordinate, _this.view.getYScales()[0], scale5, alignTick, dim) : getLineGridItems(coordinate, scale5, dim, alignTick);
            } else {
              items = dim === "x" ? getLineGridItems(coordinate, scale5, dim, alignTick) : getCircleGridItems(coordinate, _this.view.getXScale(), scale5, alignTick, dim);
            }
            updated = {
              items,
              center: _this.view.getCoordinate().getCenter()
            };
          } else {
            updated = { items: getLineGridItems(coordinate, scale5, dim, alignTick) };
          }
        }
        component.update(updated);
      });
    };
    Axis2.prototype.update = function() {
      this.option = this.view.getOptions().axes;
      var updatedCache = new Map();
      this.updateXAxes(updatedCache);
      this.updateYAxes(updatedCache);
      var newCache = new Map();
      this.cache.forEach(function(co, key) {
        if (updatedCache.has(key)) {
          newCache.set(key, co);
        } else {
          co.component.destroy();
        }
      });
      this.cache = newCache;
    };
    Axis2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.cache.clear();
      this.gridContainer.clear();
      this.gridForeContainer.clear();
      this.axisContainer.clear();
      this.axisForeContainer.clear();
    };
    Axis2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.gridContainer.remove(true);
      this.gridForeContainer.remove(true);
      this.axisContainer.remove(true);
      this.axisForeContainer.remove(true);
    };
    Axis2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value) {
        co.push(value);
      });
      return co;
    };
    Axis2.prototype.updateXAxes = function(updatedCache) {
      var scale5 = this.view.getXScale();
      if (!scale5 || scale5.isIdentity) {
        return;
      }
      var xAxisOption = getAxisOption(this.option, scale5.field);
      if (xAxisOption === false) {
        return;
      }
      var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
      var layer = LAYER.BG;
      var dim = "x";
      var coordinate = this.view.getCoordinate();
      var axisId = this.getId("axis", scale5.field);
      var gridId = this.getId("grid", scale5.field);
      if (coordinate.isRect) {
        var axis = this.cache.get(axisId);
        if (axis) {
          var cfg = this.getLineAxisCfg(scale5, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis.component.update(cfg);
          updatedCache.set(axisId, axis);
        } else {
          axis = this.createLineAxis(scale5, xAxisOption, layer, direction2, dim);
          this.cache.set(axisId, axis);
          updatedCache.set(axisId, axis);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = this.getLineGridCfg(scale5, xAxisOption, direction2, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          grid = this.createLineGrid(scale5, xAxisOption, layer, direction2, dim);
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else if (coordinate.isPolar) {
        var axis = this.cache.get(axisId);
        if (axis) {
          var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale5, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale5, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis.component.update(cfg);
          updatedCache.set(axisId, axis);
        } else {
          if (coordinate.isTransposed) {
            if (is_undefined_default(xAxisOption)) {
              return;
            } else {
              axis = this.createLineAxis(scale5, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            axis = this.createCircleAxis(scale5, xAxisOption, layer, direction2, dim);
          }
          this.cache.set(axisId, axis);
          updatedCache.set(axisId, axis);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale5, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale5, xAxisOption, DIRECTION.CIRCLE, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          if (coordinate.isTransposed) {
            if (is_undefined_default(xAxisOption)) {
              return;
            } else {
              grid = this.createCircleGrid(scale5, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            grid = this.createLineGrid(scale5, xAxisOption, layer, DIRECTION.CIRCLE, dim);
          }
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else {
      }
    };
    Axis2.prototype.updateYAxes = function(updatedCache) {
      var _this = this;
      var yScales = this.view.getYScales();
      each_default(yScales, function(scale5, idx) {
        if (!scale5 || scale5.isIdentity) {
          return;
        }
        var field = scale5.field;
        var yAxisOption = getAxisOption(_this.option, field);
        if (yAxisOption !== false) {
          var layer = LAYER.BG;
          var dim = "y";
          var axisId = _this.getId("axis", field);
          var gridId = _this.getId("grid", field);
          var coordinate = _this.view.getCoordinate();
          if (coordinate.isRect) {
            var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
            var axis = _this.cache.get(axisId);
            if (axis) {
              var cfg = _this.getLineAxisCfg(scale5, yAxisOption, direction2);
              omit(cfg, OMIT_CFG);
              axis.component.update(cfg);
              updatedCache.set(axisId, axis);
            } else {
              axis = _this.createLineAxis(scale5, yAxisOption, layer, direction2, dim);
              _this.cache.set(axisId, axis);
              updatedCache.set(axisId, axis);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = _this.getLineGridCfg(scale5, yAxisOption, direction2, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              grid = _this.createLineGrid(scale5, yAxisOption, layer, direction2, dim);
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else if (coordinate.isPolar) {
            var axis = _this.cache.get(axisId);
            if (axis) {
              var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale5, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale5, yAxisOption, DIRECTION.RADIUS);
              omit(cfg, OMIT_CFG);
              axis.component.update(cfg);
              updatedCache.set(axisId, axis);
            } else {
              if (coordinate.isTransposed) {
                if (is_undefined_default(yAxisOption)) {
                  return;
                } else {
                  axis = _this.createCircleAxis(scale5, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                axis = _this.createLineAxis(scale5, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              _this.cache.set(axisId, axis);
              updatedCache.set(axisId, axis);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale5, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale5, yAxisOption, DIRECTION.RADIUS, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              if (coordinate.isTransposed) {
                if (is_undefined_default(yAxisOption)) {
                  return;
                } else {
                  grid = _this.createLineGrid(scale5, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                grid = _this.createCircleGrid(scale5, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else {
          }
        }
      });
    };
    Axis2.prototype.createLineAxis = function(scale5, option, layer, direction2, dim) {
      var axis = {
        component: new LineAxis(this.getLineAxisCfg(scale5, option, direction2)),
        layer,
        direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale5 }
      };
      axis.component.set("field", scale5.field);
      axis.component.init();
      return axis;
    };
    Axis2.prototype.createLineGrid = function(scale5, option, layer, direction2, dim) {
      var cfg = this.getLineGridCfg(scale5, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new LineGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale5,
            alignTick: get_default(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.createCircleAxis = function(scale5, option, layer, direction2, dim) {
      var axis = {
        component: new CircleAxis(this.getCircleAxisCfg(scale5, option, direction2)),
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale5 }
      };
      axis.component.set("field", scale5.field);
      axis.component.init();
      return axis;
    };
    Axis2.prototype.createCircleGrid = function(scale5, option, layer, direction2, dim) {
      var cfg = this.getCircleGridCfg(scale5, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new CircleGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale5,
            alignTick: get_default(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.getLineAxisCfg = function(scale5, axisOption, direction2) {
      var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate = this.view.getCoordinate();
      var region = getAxisRegion(coordinate, direction2);
      var titleText = getAxisTitleText(scale5, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
      var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deep_mix_default(__assign(__assign({ container }, region), { ticks: scale5.getTicks().map(function(tick2) {
        return { id: "" + tick2.tickValue, name: tick2.text, value: tick2.value };
      }), verticalFactor: coordinate.isPolar ? getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a4 = this.getAnimateCfg(cfg), animate = _a4.animate, animateOption = _a4.animateOption;
      cfg.animateOption = animateOption;
      cfg.animate = animate;
      var isAxisVertical = isVertical(region);
      var verticalLimitLength = get_default(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
      if (verticalLimitLength <= 1) {
        var canvasWidth = this.view.getCanvas().get("width");
        var canvasHeight = this.view.getCanvas().get("height");
        cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
      }
      return cfg;
    };
    Axis2.prototype.getLineGridCfg = function(scale5, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
      var gridCfg = deep_mix_default({
        container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
      }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
      gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale5, dim, get_default(gridCfg, "alignTick", true));
      return gridCfg;
    };
    Axis2.prototype.getCircleAxisCfg = function(scale5, axisOption, direction2) {
      var container = get_default(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate = this.view.getCoordinate();
      var ticks = scale5.getTicks().map(function(tick2) {
        return { id: "" + tick2.tickValue, name: tick2.text, value: tick2.value };
      });
      if (!scale5.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
        ticks.pop();
      }
      var titleText = getAxisTitleText(scale5, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
      var optionWithTitle = get_default(axisOption, ["title"]) ? deep_mix_default({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deep_mix_default(__assign(__assign({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a4 = this.getAnimateCfg(cfg), animate = _a4.animate, animateOption = _a4.animateOption;
      cfg.animate = animate;
      cfg.animateOption = animateOption;
      return cfg;
    };
    Axis2.prototype.getCircleGridCfg = function(scale5, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
      var gridCfg = deep_mix_default({
        container: get_default(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
        center: this.view.getCoordinate().getCenter()
      }, gridThemeCfg, get_default(axisOption, "grid"), this.getAnimateCfg(axisOption));
      var alignTick = get_default(gridCfg, "alignTick", true);
      var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
      gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale5, alignTick, dim);
      return gridCfg;
    };
    Axis2.prototype.getId = function(name, key) {
      var coordinate = this.view.getCoordinate();
      return name + "-" + key + "-" + coordinate.type;
    };
    Axis2.prototype.getAnimateCfg = function(cfg) {
      return {
        animate: this.view.getOptions().animate && get_default(cfg, "animate"),
        animateOption: cfg && cfg.animateOption ? deep_mix_default({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
      };
    };
    return Axis2;
  }(Controller);
  var axis_default = Axis;

  // node_modules/@antv/g2/esm/util/direction.js
  function directionToPosition(parentBBox, bbox, direction2) {
    if (direction2 === DIRECTION.TOP) {
      return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
    }
    if (direction2 === DIRECTION.BOTTOM) {
      return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
    }
    if (direction2 === DIRECTION.LEFT) {
      return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
    }
    if (direction2 === DIRECTION.RIGHT) {
      return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
    }
    if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
      return [parentBBox.tl.x, parentBBox.tl.y];
    }
    if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
      return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
    }
    if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
      return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
    }
    if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
      return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
    }
    return [0, 0];
  }

  // node_modules/@antv/g2/esm/chart/controller/legend.js
  function getLegendOption(legends, field) {
    if (is_boolean_default(legends)) {
      return legends === false ? false : {};
    }
    return get_default(legends, [field], legends);
  }
  function getDirection(legendOption) {
    return get_default(legendOption, "position", DIRECTION.BOTTOM);
  }
  var Legend = function(_super) {
    __extends(Legend2, _super);
    function Legend2(view) {
      var _this = _super.call(this, view) || this;
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Legend2.prototype, "name", {
      get: function() {
        return "legend";
      },
      enumerable: false,
      configurable: true
    });
    Legend2.prototype.init = function() {
    };
    Legend2.prototype.render = function() {
      this.update();
    };
    Legend2.prototype.layout = function() {
      var _this = this;
      this.layoutBBox = this.view.viewBBox;
      each_default(this.components, function(co) {
        var component = co.component, direction2 = co.direction;
        var layout = getLegendLayout(direction2);
        var maxWidthRatio = component.get("maxWidthRatio");
        var maxHeightRatio = component.get("maxHeightRatio");
        var maxSize = _this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
        var maxWidth = component.get("maxWidth");
        var maxHeight = component.get("maxHeight");
        component.update({
          maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
          maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
        });
        var padding = component.get("padding");
        var bboxObject = component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);
        var _a4 = directionToPosition(_this.view.viewBBox, bbox, direction2), x1 = _a4[0], y1 = _a4[1];
        var _b = directionToPosition(_this.layoutBBox, bbox, direction2), x2 = _b[0], y2 = _b[1];
        var x = 0;
        var y = 0;
        if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
          x = x1;
          y = y2;
        } else {
          x = x2;
          y = y1;
        }
        component.setLocation({ x: x + padding[3], y: y + padding[0] });
        _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
      });
    };
    Legend2.prototype.update = function() {
      var _this = this;
      this.option = this.view.getOptions().legends;
      var updated = {};
      var eachLegend = function(geometry, attr, scale5) {
        var id2 = _this.getId(scale5.field);
        var existCo2 = _this.getComponentById(id2);
        if (existCo2) {
          var cfg = void 0;
          var legendOption = getLegendOption(_this.option, scale5.field);
          if (legendOption !== false) {
            if (get_default(legendOption, "custom")) {
              cfg = _this.getCategoryCfg(geometry, attr, scale5, legendOption, true);
            } else {
              if (scale5.isLinear) {
                cfg = _this.getContinuousCfg(geometry, attr, scale5, legendOption);
              } else if (scale5.isCategory) {
                cfg = _this.getCategoryCfg(geometry, attr, scale5, legendOption);
              }
            }
          }
          if (cfg) {
            omit(cfg, ["container"]);
            existCo2.direction = getDirection(legendOption);
            existCo2.component.update(cfg);
            updated[id2] = true;
          }
        } else {
          var legend = _this.createFieldLegend(geometry, attr, scale5);
          if (legend) {
            legend.component.init();
            _this.components.push(legend);
            updated[id2] = true;
          }
        }
      };
      if (get_default(this.option, "custom")) {
        var id = "global-custom";
        var existCo = this.getComponentById(id);
        if (existCo) {
          var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
          omit(customCfg, ["container"]);
          existCo.component.update(customCfg);
          updated[id] = true;
        } else {
          var component = this.createCustomLegend(void 0, void 0, void 0, this.option);
          if (component) {
            component.init();
            var layer = LAYER.FORE;
            var direction2 = getDirection(this.option);
            this.components.push({
              id,
              component,
              layer,
              direction: direction2,
              type: COMPONENT_TYPE.LEGEND,
              extra: void 0
            });
            updated[id] = true;
          }
        }
      } else {
        this.loopLegends(eachLegend);
      }
      var components = [];
      each_default(this.getComponents(), function(co) {
        if (updated[co.id]) {
          components.push(co);
        } else {
          co.component.destroy();
        }
      });
      this.components = components;
    };
    Legend2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.container.clear();
    };
    Legend2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.container.remove(true);
    };
    Legend2.prototype.getGeometries = function(view) {
      var _this = this;
      var geometries = view.geometries;
      each_default(view.views, function(v) {
        geometries = geometries.concat(_this.getGeometries(v));
      });
      return geometries;
    };
    Legend2.prototype.loopLegends = function(doEach) {
      var isRootView = this.view.getRootView() === this.view;
      if (!isRootView) {
        return;
      }
      var geometries = this.getGeometries(this.view);
      var looped = {};
      each_default(geometries, function(geometry) {
        var attributes = geometry.getGroupAttributes();
        each_default(attributes, function(attr) {
          var scale5 = attr.getScale(attr.type);
          if (!scale5 || scale5.type === "identity" || looped[scale5.field]) {
            return;
          }
          doEach(geometry, attr, scale5);
          looped[scale5.field] = true;
        });
      });
    };
    Legend2.prototype.createFieldLegend = function(geometry, attr, scale5) {
      var component;
      var legendOption = getLegendOption(this.option, scale5.field);
      var layer = LAYER.FORE;
      var direction2 = getDirection(legendOption);
      if (legendOption !== false) {
        if (get_default(legendOption, "custom")) {
          component = this.createCustomLegend(geometry, attr, scale5, legendOption);
        } else {
          if (scale5.isLinear) {
            component = this.createContinuousLegend(geometry, attr, scale5, legendOption);
          } else if (scale5.isCategory) {
            component = this.createCategoryLegend(geometry, attr, scale5, legendOption);
          }
        }
      }
      if (component) {
        component.set("field", scale5.field);
        return {
          id: this.getId(scale5.field),
          component,
          layer,
          direction: direction2,
          type: COMPONENT_TYPE.LEGEND,
          extra: { scale: scale5 }
        };
      }
    };
    Legend2.prototype.createCustomLegend = function(geometry, attr, scale5, legendOption) {
      var cfg = this.getCategoryCfg(geometry, attr, scale5, legendOption, true);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.createContinuousLegend = function(geometry, attr, scale5, legendOption) {
      var cfg = this.getContinuousCfg(geometry, attr, scale5, omit(legendOption, ["value"]));
      return new ContinuousLegend(cfg);
    };
    Legend2.prototype.createCategoryLegend = function(geometry, attr, scale5, legendOption) {
      var cfg = this.getCategoryCfg(geometry, attr, scale5, legendOption);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.getContinuousCfg = function(geometry, attr, scale5, legendOption) {
      var ticks = scale5.getTicks();
      var containMin = find_default(ticks, function(tick2) {
        return tick2.value === 0;
      });
      var containMax = find_default(ticks, function(tick2) {
        return tick2.value === 1;
      });
      var items = ticks.map(function(tick2) {
        var value = tick2.value, tickValue = tick2.tickValue;
        var attrValue = attr.mapping(scale5.invert(value)).join("");
        return {
          value: tickValue,
          attrValue,
          color: attrValue,
          scaleValue: value
        };
      });
      if (!containMin) {
        items.push({
          value: scale5.min,
          attrValue: attr.mapping(scale5.invert(0)).join(""),
          color: attr.mapping(scale5.invert(0)).join(""),
          scaleValue: 0
        });
      }
      if (!containMax) {
        items.push({
          value: scale5.max,
          attrValue: attr.mapping(scale5.invert(1)).join(""),
          color: attr.mapping(scale5.invert(1)).join(""),
          scaleValue: 1
        });
      }
      items.sort(function(a, b) {
        return a.value - b.value;
      });
      var attrLegendCfg = {
        min: head(items).value,
        max: last(items).value,
        colors: [],
        rail: {
          type: attr.type
        },
        track: {}
      };
      if (attr.type === "size") {
        attrLegendCfg.track = {
          style: {
            fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
          }
        };
      }
      if (attr.type === "color") {
        attrLegendCfg.colors = items.map(function(item) {
          return item.attrValue;
        });
      }
      var container = this.container;
      var direction2 = getDirection(legendOption);
      var layout = getLegendLayout(direction2);
      var title = get_default(legendOption, "title");
      if (title) {
        title = deep_mix_default({
          text: getName(scale5)
        }, title);
      }
      attrLegendCfg.container = container;
      attrLegendCfg.layout = layout;
      attrLegendCfg.title = title;
      attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
      return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
    };
    Legend2.prototype.getCategoryCfg = function(geometry, attr, scale5, legendOption, custom10) {
      var container = this.container;
      var direction2 = get_default(legendOption, "position", DIRECTION.BOTTOM);
      var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
      var themeMarker = get_default(legendTheme, ["marker"]);
      var userMarker = get_default(legendOption, "marker");
      var layout = getLegendLayout(direction2);
      var themePageNavigator = get_default(legendTheme, ["pageNavigator"]);
      var userPageNavigator = get_default(legendOption, "pageNavigator");
      var items = custom10 ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry, attr, themeMarker, userMarker);
      var title = get_default(legendOption, "title");
      if (title) {
        title = deep_mix_default({
          text: scale5 ? getName(scale5) : ""
        }, title);
      }
      var maxWidthRatio = get_default(legendOption, "maxWidthRatio");
      var maxHeightRatio = get_default(legendOption, "maxHeightRatio");
      var baseCfg = this.getCategoryLegendSizeCfg(layout, maxWidthRatio, maxHeightRatio);
      baseCfg.container = container;
      baseCfg.layout = layout;
      baseCfg.items = items;
      baseCfg.title = title;
      baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
      baseCfg.pageNavigator = deep_mix_default({}, themePageNavigator, userPageNavigator);
      var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
      if (categoryCfg.reversed) {
        categoryCfg.items.reverse();
      }
      var maxItemWidth = get_default(categoryCfg, "maxItemWidth");
      if (maxItemWidth && maxItemWidth <= 1) {
        categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
      }
      return categoryCfg;
    };
    Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
      var position = direction2.split("-")[0];
      var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
      return deep_mix_default({}, themeObject, baseCfg, legendOption);
    };
    Legend2.prototype.getId = function(key) {
      return this.name + "-" + key;
    };
    Legend2.prototype.getComponentById = function(id) {
      return find_default(this.components, function(co) {
        return co.id === id;
      });
    };
    Legend2.prototype.getCategoryLegendSizeCfg = function(layout, maxWidthRatio, maxHeightRatio) {
      if (maxWidthRatio === void 0) {
        maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      if (maxHeightRatio === void 0) {
        maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      var _a4 = this.view.viewBBox, vw = _a4.width, vh = _a4.height;
      return layout === "vertical" ? {
        maxWidth: vw * maxWidthRatio,
        maxHeight: vh
      } : {
        maxWidth: vw,
        maxHeight: vh * maxHeightRatio
      };
    };
    return Legend2;
  }(Controller);
  var legend_default = Legend;

  // node_modules/@antv/g2/esm/chart/controller/slider.js
  var Slider2 = function(_super) {
    __extends(Slider3, _super);
    function Slider3(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop_default;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(v) {
        var min7 = v[0], max7 = v[1];
        _this.start = min7;
        _this.end = max7;
        _this.changeViewData(min7, max7);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
        leading: true
      });
      _this.width = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Slider3.prototype, "name", {
      get: function() {
        return "slider";
      },
      enumerable: false,
      configurable: true
    });
    Slider3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Slider3.prototype.init = function() {
    };
    Slider3.prototype.render = function() {
      this.option = this.view.getOptions().slider;
      var _a4 = this.getSliderCfg(), start = _a4.start, end = _a4.end;
      if (is_nil_default(this.start)) {
        this.start = start;
        this.end = end;
      }
      var viewData = this.view.getOptions().data;
      if (this.option && !is_empty_default(viewData)) {
        if (this.slider) {
          this.slider = this.updateSlider();
        } else {
          this.slider = this.createSlider();
          this.slider.component.on("sliderchange", this.onChangeFn);
        }
      } else {
        if (this.slider) {
          this.slider.component.destroy();
          this.slider = void 0;
        } else {
        }
      }
    };
    Slider3.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.width) {
        this.measureSlider();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.start, _this.end);
          }
        }, 0);
      }
      if (this.slider) {
        var width = this.view.coordinateBBox.width;
        var padding = this.slider.component.get("padding");
        var paddingTop = padding[0], paddingRight = padding[1], paddingBottom = padding[2], paddingLeft = padding[3];
        var bboxObject = this.slider.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
        var _a4 = this.getMinMaxText(this.start, this.end), minText = _a4.minText, maxText = _a4.maxText;
        var _b = directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), x1 = _b[0], y1 = _b[1];
        var _c = directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), x2 = _c[0], y2 = _c[1];
        this.slider.component.update(__assign(__assign({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
        this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
      }
    };
    Slider3.prototype.update = function() {
      this.render();
    };
    Slider3.prototype.createSlider = function() {
      var cfg = this.getSliderCfg();
      var component = new Slider(__assign({ container: this.container }, cfg));
      component.init();
      return {
        component,
        layer: LAYER.FORE,
        direction: DIRECTION.BOTTOM,
        type: COMPONENT_TYPE.SLIDER
      };
    };
    Slider3.prototype.updateSlider = function() {
      var cfg = this.getSliderCfg();
      if (this.width) {
        var _a4 = this.getMinMaxText(this.start, this.end), minText = _a4.minText, maxText = _a4.maxText;
        cfg = __assign(__assign({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
      }
      this.slider.component.update(cfg);
      return this.slider;
    };
    Slider3.prototype.measureSlider = function() {
      var width = this.getSliderCfg().width;
      this.width = width;
    };
    Slider3.prototype.getSliderCfg = function() {
      var cfg = {
        height: 16,
        start: 0,
        end: 1,
        minText: "",
        maxText: "",
        x: 0,
        y: 0,
        width: this.view.coordinateBBox.width
      };
      if (is_object_default(this.option)) {
        var trendCfg = __assign({ data: this.getData() }, get_default(this.option, "trendCfg", {}));
        cfg = deep_mix_default({}, cfg, this.getThemeOptions(), this.option);
        cfg = __assign(__assign({}, cfg), { trendCfg });
      }
      cfg.start = clamp_default(Math.min(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
      cfg.end = clamp_default(Math.max(is_nil_default(cfg.start) ? 0 : cfg.start, is_nil_default(cfg.end) ? 1 : cfg.end), 0, 1);
      return cfg;
    };
    Slider3.prototype.getData = function() {
      var data = this.view.getOptions().data;
      var yScale = this.view.getYScales()[0];
      var groupScales = this.view.getGroupScales();
      if (groupScales.length) {
        var _a4 = groupScales[0], field_1 = _a4.field, ticks_1 = _a4.ticks;
        return data.reduce(function(pre, cur) {
          if (cur[field_1] === ticks_1[0]) {
            pre.push(cur[yScale.field]);
          }
          return pre;
        }, []);
      }
      return data.map(function(datum) {
        return datum[yScale.field] || 0;
      });
    };
    Slider3.prototype.getThemeOptions = function() {
      var theme = this.view.getTheme();
      return get_default(theme, ["components", "slider", "common"], {});
    };
    Slider3.prototype.getMinMaxText = function(min7, max7) {
      var data = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var isHorizontal = true;
      var values2 = values_of_key_default(data, xScale.field);
      var xValues = isHorizontal ? values2 : values2.reverse();
      var dataSize = size2(data);
      if (!xScale || !dataSize) {
        return {};
      }
      var xTickCount = size2(xValues);
      var minIndex = Math.floor(min7 * (xTickCount - 1));
      var maxIndex = Math.floor(max7 * (xTickCount - 1));
      var minText = get_default(xValues, [minIndex]);
      var maxText = get_default(xValues, [maxIndex]);
      var formatter = this.getSliderCfg().formatter;
      if (formatter) {
        minText = formatter(minText, data[minIndex], minIndex);
        maxText = formatter(maxText, data[maxIndex], maxIndex);
      }
      return {
        minText,
        maxText
      };
    };
    Slider3.prototype.changeViewData = function(min7, max7) {
      var data = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var dataSize = size2(data);
      if (!xScale || !dataSize) {
        return;
      }
      var isHorizontal = true;
      var values2 = values_of_key_default(data, xScale.field);
      var xValues = isHorizontal ? values2 : values2.reverse();
      var xTickCount = size2(xValues);
      var minIndex = Math.floor(min7 * (xTickCount - 1));
      var maxIndex = Math.floor(max7 * (xTickCount - 1));
      this.view.filter(xScale.field, function(value, datum) {
        var idx = xValues.indexOf(value);
        return idx > -1 ? isBetween2(idx, minIndex, maxIndex) : true;
      });
      this.view.render(true);
    };
    Slider3.prototype.getComponents = function() {
      return this.slider ? [this.slider] : [];
    };
    Slider3.prototype.clear = function() {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      }
      this.width = 0;
      this.start = void 0;
      this.end = void 0;
    };
    return Slider3;
  }(Controller);
  var slider_default = Slider2;

  // node_modules/@antv/g2/esm/chart/controller/scrollbar.js
  var DEFAULT_PADDING = 0;
  var DEFAULT_SIZE = 8;
  var DEFAULT_CATEGORY_SIZE = 32;
  var MIN_THUMB_LENGTH = 20;
  var Scrollbar2 = function(_super) {
    __extends(Scrollbar3, _super);
    function Scrollbar3(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop_default;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(_a4) {
        var ratio = _a4.ratio;
        var animate = _this.getValidScrollbarCfg().animate;
        _this.ratio = clamp_default(ratio, 0, 1);
        var originalAnimate = _this.view.getOptions().animate;
        if (!animate) {
          _this.view.animate(false);
        }
        _this.changeViewData(_this.getScrollRange(), true);
        _this.view.animate(originalAnimate);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle_default(_this.onValueChange, 20, {
        leading: true
      });
      _this.trackLen = 0;
      _this.thumbLen = 0;
      _this.ratio = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Scrollbar3.prototype, "name", {
      get: function() {
        return "scrollbar";
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar3.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Scrollbar3.prototype.init = function() {
    };
    Scrollbar3.prototype.render = function() {
      this.option = this.view.getOptions().scrollbar;
      if (this.option) {
        if (this.scrollbar) {
          this.scrollbar = this.updateScrollbar();
        } else {
          this.scrollbar = this.createScrollbar();
          this.scrollbar.component.on("scrollchange", this.onChangeFn);
        }
      } else {
        if (this.scrollbar) {
          this.scrollbar.component.destroy();
          this.scrollbar = void 0;
        }
      }
    };
    Scrollbar3.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.trackLen) {
        this.measureScrollbar();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.getScrollRange(), true);
          }
        });
      }
      if (this.scrollbar) {
        var width = this.view.coordinateBBox.width;
        var padding = this.scrollbar.component.get("padding");
        var bboxObject = this.scrollbar.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
        var cfg = this.getScrollbarComponentCfg();
        var x = void 0;
        var y = void 0;
        if (cfg.isHorizontal) {
          var _a4 = directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), x1 = _a4[0], y1 = _a4[1];
          var _b = directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), x2 = _b[0], y2 = _b[1];
          x = x2;
          y = y1;
        } else {
          var _c = directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), x1 = _c[0], y1 = _c[1];
          var _d = directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), x2 = _d[0], y2 = _d[1];
          x = x2;
          y = y1;
        }
        x += padding[3];
        y += padding[0];
        if (this.trackLen) {
          this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
        } else {
          this.scrollbar.component.update(__assign(__assign({}, cfg), { x, y }));
        }
        this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
      }
    };
    Scrollbar3.prototype.update = function() {
      this.render();
    };
    Scrollbar3.prototype.getComponents = function() {
      return this.scrollbar ? [this.scrollbar] : [];
    };
    Scrollbar3.prototype.clear = function() {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
      this.trackLen = 0;
      this.thumbLen = 0;
      this.ratio = 0;
      this.cnt = 0;
      this.step = 0;
      this.data = void 0;
      this.xScaleCfg = void 0;
      this.yScalesCfg = [];
    };
    Scrollbar3.prototype.setValue = function(ratio) {
      this.onValueChange({ ratio });
    };
    Scrollbar3.prototype.getValue = function() {
      return this.ratio;
    };
    Scrollbar3.prototype.getThemeOptions = function() {
      var theme = this.view.getTheme();
      return get_default(theme, ["components", "scrollbar", "common"], {});
    };
    Scrollbar3.prototype.getScrollbarTheme = function(style) {
      var theme = get_default(this.view.getTheme(), ["components", "scrollbar"]);
      var _a4 = style || {}, thumbHighlightColor = _a4.thumbHighlightColor, restStyles = __rest(_a4, ["thumbHighlightColor"]);
      return {
        default: deep_mix_default({}, get_default(theme, ["default", "style"], {}), restStyles),
        hover: deep_mix_default({}, get_default(theme, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
      };
    };
    Scrollbar3.prototype.measureScrollbar = function() {
      var xScale = this.view.getXScale();
      var yScales = this.view.getYScales().slice();
      this.data = this.getScrollbarData();
      this.step = this.getStep();
      this.cnt = this.getCnt();
      var _a4 = this.getScrollbarComponentCfg(), trackLen = _a4.trackLen, thumbLen = _a4.thumbLen;
      this.trackLen = trackLen;
      this.thumbLen = thumbLen;
      this.xScaleCfg = {
        field: xScale.field,
        values: xScale.values || []
      };
      this.yScalesCfg = yScales;
    };
    Scrollbar3.prototype.getScrollRange = function() {
      var startIdx = Math.floor((this.cnt - this.step) * clamp_default(this.ratio, 0, 1));
      var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
      return [startIdx, endIdx];
    };
    Scrollbar3.prototype.changeViewData = function(_a4, render) {
      var _this = this;
      var startIdx = _a4[0], endIdx = _a4[1];
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal = type !== "vertical";
      var values2 = values_of_key_default(this.data, this.xScaleCfg.field);
      var xValues = isHorizontal ? values2 : values2.reverse();
      this.yScalesCfg.forEach(function(cfg) {
        _this.view.scale(cfg.field, {
          formatter: cfg.formatter,
          type: cfg.type,
          min: cfg.min,
          max: cfg.max
        });
      });
      this.view.filter(this.xScaleCfg.field, function(val) {
        var idx = xValues.indexOf(val);
        return idx > -1 ? isBetween2(idx, startIdx, endIdx) : true;
      });
      this.view.render(true);
    };
    Scrollbar3.prototype.createScrollbar = function() {
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal = type !== "vertical";
      var component = new Scrollbar(__assign(__assign({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
      component.init();
      return {
        component,
        layer: LAYER.FORE,
        direction: isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
        type: COMPONENT_TYPE.SCROLLBAR
      };
    };
    Scrollbar3.prototype.updateScrollbar = function() {
      var config = this.getScrollbarComponentCfg();
      var realConfig3 = this.trackLen ? __assign(__assign({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign({}, config);
      this.scrollbar.component.update(realConfig3);
      return this.scrollbar;
    };
    Scrollbar3.prototype.getStep = function() {
      if (this.step) {
        return this.step;
      }
      var coordinateBBox = this.view.coordinateBBox;
      var _a4 = this.getValidScrollbarCfg(), type = _a4.type, categorySize = _a4.categorySize;
      var isHorizontal = type !== "vertical";
      return Math.floor((isHorizontal ? coordinateBBox.width : coordinateBBox.height) / categorySize);
    };
    Scrollbar3.prototype.getCnt = function() {
      if (this.cnt) {
        return this.cnt;
      }
      var xScale = this.view.getXScale();
      var data = this.getScrollbarData();
      var values2 = values_of_key_default(data, xScale.field);
      return size2(values2);
    };
    Scrollbar3.prototype.getScrollbarComponentCfg = function() {
      var _a4 = this.view, coordinateBBox = _a4.coordinateBBox, viewBBox = _a4.viewBBox;
      var _b = this.getValidScrollbarCfg(), type = _b.type, padding = _b.padding, width = _b.width, height = _b.height, style = _b.style;
      var isHorizontal = type !== "vertical";
      var paddingTop = padding[0], paddingRight = padding[1], paddingBottom = padding[2], paddingLeft = padding[3];
      var position = isHorizontal ? {
        x: coordinateBBox.minX + paddingLeft,
        y: viewBBox.maxY - height - paddingBottom
      } : {
        x: viewBBox.maxX - width - paddingRight,
        y: coordinateBBox.minY + paddingTop
      };
      var step4 = this.getStep();
      var cnt = this.getCnt();
      var trackLen = isHorizontal ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
      var thumbLen = Math.max(trackLen * clamp_default(step4 / cnt, 0, 1), MIN_THUMB_LENGTH);
      return __assign(__assign({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal ? height : width, isHorizontal, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
    };
    Scrollbar3.prototype.getValidScrollbarCfg = function() {
      var cfg = {
        type: "horizontal",
        categorySize: DEFAULT_CATEGORY_SIZE,
        width: DEFAULT_SIZE,
        height: DEFAULT_SIZE,
        padding: [0, 0, 0, 0],
        animate: true,
        style: {}
      };
      if (is_object_default(this.option)) {
        cfg = __assign(__assign({}, cfg), this.option);
      }
      if (!is_object_default(this.option) || !this.option.padding) {
        cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
      }
      return cfg;
    };
    Scrollbar3.prototype.getScrollbarData = function() {
      var coordinate = this.view.getCoordinate();
      var cfg = this.getValidScrollbarCfg();
      var data = this.view.getOptions().data || [];
      if (coordinate.isReflect("y") && cfg.type === "vertical") {
        data = __spreadArray([], data, true).reverse();
      }
      return data;
    };
    return Scrollbar3;
  }(Controller);
  var scrollbar_default = Scrollbar2;

  // node_modules/@antv/g2/esm/interaction/action/active-region.js
  var DEFAULT_REGION_PATH_STYLE = {
    fill: "#CCD6EC",
    opacity: 0.3
  };
  function getItemsOfView(view, point, tooltipCfg) {
    var items = findItemsFromViewRecurisive(view, point, tooltipCfg);
    if (items.length) {
      items = flatten_default(items);
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var itemArr = items_1[_i];
        for (var _a4 = 0, itemArr_1 = itemArr; _a4 < itemArr_1.length; _a4++) {
          var item = itemArr_1[_a4];
          var _b = item.mappingData, x = _b.x, y = _b.y;
          item.x = is_array_default(x) ? x[x.length - 1] : x;
          item.y = is_array_default(y) ? y[y.length - 1] : y;
        }
      }
      var shared = tooltipCfg.shared;
      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min7 = Math.abs(point.y - snapItem[0].y);
        for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
          var aItem = items_2[_c];
          var yDistance = Math.abs(point.y - aItem[0].y);
          if (yDistance <= min7) {
            snapItem = aItem;
            min7 = yDistance;
          }
        }
        items = [snapItem];
      }
      return uniq(flatten_default(items));
    }
    return [];
  }
  var ActiveRegion = function(_super) {
    __extends(ActiveRegion2, _super);
    function ActiveRegion2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActiveRegion2.prototype.show = function(args) {
      var view = this.context.view;
      var ev = this.context.event;
      var tooltipCfg = view.getController("tooltip").getTooltipCfg();
      var tooltipItems = getItemsOfView(view, {
        x: ev.x,
        y: ev.y
      }, tooltipCfg);
      if (is_equal_default(tooltipItems, this.items)) {
        return;
      }
      this.items = tooltipItems;
      if (tooltipItems.length) {
        var xField_1 = view.getXScale().field;
        var xValue_1 = tooltipItems[0].data[xField_1];
        var elements_1 = [];
        var geometries = view.geometries;
        each_default(geometries, function(geometry) {
          if (geometry.type === "interval" || geometry.type === "schema") {
            var result = geometry.getElementsBy(function(ele) {
              var eleData = ele.getData();
              return eleData[xField_1] === xValue_1;
            });
            elements_1 = elements_1.concat(result);
          }
        });
        if (elements_1.length) {
          var coordinate_1 = view.getCoordinate();
          var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
          var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
          var groupBBox_1 = firstBBox_1;
          each_default(elements_1, function(ele) {
            var bbox = ele.shape.getCanvasBBox();
            if (coordinate_1.isTransposed) {
              if (bbox.minY < firstBBox_1.minY) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxY > lastBBox_1.maxY) {
                lastBBox_1 = bbox;
              }
            } else {
              if (bbox.minX < firstBBox_1.minX) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxX > lastBBox_1.maxX) {
                lastBBox_1 = bbox;
              }
            }
            groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
            groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
            groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
            groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
          });
          var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
          var path = void 0;
          if (coordinate_1.isRect) {
            var xScale = view.getXScale();
            var _a4 = args || {}, appendRatio = _a4.appendRatio, appendWidth = _a4.appendWidth;
            if (is_nil_default(appendWidth)) {
              appendRatio = is_nil_default(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
              appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
            }
            var minX = void 0;
            var minY = void 0;
            var width = void 0;
            var height = void 0;
            if (coordinate_1.isTransposed) {
              minX = coordinateBBox.minX;
              minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
              width = coordinateBBox.width;
              height = groupBBox_1.height + appendWidth * 2;
            } else {
              minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
              minY = coordinateBBox.minY;
              width = groupBBox_1.width + appendWidth * 2;
              height = coordinateBBox.height;
            }
            path = [
              ["M", minX, minY],
              ["L", minX + width, minY],
              ["L", minX + width, minY + height],
              ["L", minX, minY + height],
              ["Z"]
            ];
          } else {
            var firstElement = head(elements_1);
            var lastElement = last(elements_1);
            var startAngle = getAngle2(firstElement.getModel(), coordinate_1).startAngle;
            var endAngle = getAngle2(lastElement.getModel(), coordinate_1).endAngle;
            var center = coordinate_1.getCenter();
            var radius = coordinate_1.getRadius();
            var innterRadius = coordinate_1.innerRadius * radius;
            path = getSectorPath(center.x, center.y, radius, startAngle, endAngle, innterRadius);
          }
          if (this.regionPath) {
            this.regionPath.attr("path", path);
            this.regionPath.show();
          } else {
            var style = get_default(args, "style", DEFAULT_REGION_PATH_STYLE);
            this.regionPath = backgroundGroup.addShape({
              type: "path",
              name: "active-region",
              capture: false,
              attrs: __assign(__assign({}, style), { path })
            });
          }
        }
      }
    };
    ActiveRegion2.prototype.hide = function() {
      if (this.regionPath) {
        this.regionPath.hide();
      }
      this.items = null;
    };
    ActiveRegion2.prototype.destroy = function() {
      this.hide();
      if (this.regionPath) {
        this.regionPath.remove(true);
      }
      _super.prototype.destroy.call(this);
    };
    return ActiveRegion2;
  }(base_default13);
  var active_region_default = ActiveRegion;

  // node_modules/@antv/g2/esm/interaction/action/component/tooltip/geometry.js
  var TooltipAction = function(_super) {
    __extends(TooltipAction2, _super);
    function TooltipAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    TooltipAction2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var view = context.view;
      var isTooltipLocked = view.isTooltipLocked();
      if (isTooltipLocked) {
        return;
      }
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +new Date();
      var showDelay = get_default(context.view.getOptions(), "tooltip.showDelay", 16);
      if (timeStamp - lastTimeStamp > showDelay) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(view, curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    TooltipAction2.prototype.hide = function() {
      var view = this.context.view;
      var tooltip = view.getController("tooltip");
      var _a4 = this.context.event, clientX = _a4.clientX, clientY = _a4.clientY;
      if (tooltip.isCursorEntered({ x: clientX, y: clientY })) {
        return;
      }
      if (view.isTooltipLocked()) {
        return;
      }
      this.hideTooltip(view);
      this.location = null;
    };
    TooltipAction2.prototype.showTooltip = function(view, point) {
      view.showTooltip(point);
    };
    TooltipAction2.prototype.hideTooltip = function(view) {
      view.hideTooltip();
    };
    return TooltipAction2;
  }(base_default13);
  var geometry_default = TooltipAction;

  // node_modules/@antv/g2/esm/interaction/action/component/tooltip/sibling.js
  var SiblingTooltip = function(_super) {
    __extends(SiblingTooltip2, _super);
    function SiblingTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingTooltip2.prototype.showTooltip = function(view, point) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var siblingPoint = getSiblingPoint(view, sibling, point);
        sibling.showTooltip(siblingPoint);
      });
    };
    SiblingTooltip2.prototype.hideTooltip = function(view) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.hideTooltip();
      });
    };
    return SiblingTooltip2;
  }(geometry_default);
  var sibling_default = SiblingTooltip;

  // node_modules/@antv/g2/esm/interaction/action/component/tooltip/ellipsis-text.js
  var EllipsisText = function(_super) {
    __extends(EllipsisText2, _super);
    function EllipsisText2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    EllipsisText2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    EllipsisText2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +new Date();
      if (timeStamp - lastTimeStamp > 16) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !is_equal_default(preLoc, curLoc)) {
          this.showTooltip(curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    EllipsisText2.prototype.hide = function() {
      this.hideTooltip();
      this.location = null;
    };
    EllipsisText2.prototype.showTooltip = function(curLoc) {
      var context = this.context;
      var ev = context.event;
      var target = ev.target;
      if (target && target.get("tip")) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        var tipContent = target.get("tip");
        this.tooltip.update(__assign({ title: tipContent }, curLoc));
        this.tooltip.show();
      }
    };
    EllipsisText2.prototype.hideTooltip = function() {
      this.tooltip && this.tooltip.hide();
    };
    EllipsisText2.prototype.renderTooltip = function() {
      var _a4;
      var view = this.context.view;
      var canvas = view.canvas;
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var theme = view.getTheme();
      var tooltipStyles = get_default(theme, ["components", "tooltip", "domStyles"], {});
      var tooltip = new HtmlTooltip({
        parent: canvas.get("el").parentNode,
        region,
        visible: false,
        crosshairs: null,
        domStyles: __assign({}, deep_mix_default({}, tooltipStyles, (_a4 = {}, _a4[css_const_exports.CONTAINER_CLASS] = { "max-width": "50%" }, _a4[css_const_exports.TITLE_CLASS] = { "word-break": "break-all" }, _a4)))
      });
      tooltip.init();
      tooltip.setCapture(false);
      this.tooltip = tooltip;
    };
    return EllipsisText2;
  }(base_default13);
  var ellipsis_text_default = EllipsisText;

  // node_modules/@antv/g2/esm/interaction/action/element/state-base.js
  var StateBase = function(_super) {
    __extends(StateBase2, _super);
    function StateBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      return _this;
    }
    StateBase2.prototype.hasState = function(element) {
      return element.hasState(this.stateName);
    };
    StateBase2.prototype.setElementState = function(element, enable) {
      element.setState(this.stateName, enable);
    };
    StateBase2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    StateBase2.prototype.clear = function() {
      var view = this.context.view;
      this.clearViewState(view);
    };
    StateBase2.prototype.clearViewState = function(view) {
      var _this = this;
      var elements = getElementsByState(view, this.stateName);
      each_default(elements, function(el) {
        _this.setElementState(el, false);
      });
    };
    return StateBase2;
  }(base_default13);
  var state_base_default = StateBase;

  // node_modules/@antv/g2/esm/interaction/action/element/state.js
  function getItem(shape) {
    return get_default(shape.get("delegateObject"), "item");
  }
  var ElementState = function(_super) {
    __extends(ElementState2, _super);
    function ElementState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.ignoreListItemStates = ["unchecked"];
      return _this;
    }
    ElementState2.prototype.isItemIgnore = function(item, list) {
      var states = this.ignoreListItemStates;
      var filtered = states.filter(function(state) {
        return list.hasState(item, state);
      });
      return !!filtered.length;
    };
    ElementState2.prototype.setStateByComponent = function(component, item, enable) {
      var view = this.context.view;
      var field = component.get("field");
      var elements = getElements(view);
      this.setElementsStateByItem(elements, field, item, enable);
    };
    ElementState2.prototype.setStateByElement = function(element, enable) {
      this.setElementState(element, enable);
    };
    ElementState2.prototype.isMathItem = function(element, field, item) {
      var view = this.context.view;
      var scale5 = getScaleByField(view, field);
      var value = getElementValue(element, field);
      return !is_nil_default(value) && item.name === scale5.getText(value);
    };
    ElementState2.prototype.setElementsStateByItem = function(elements, field, item, enable) {
      var _this = this;
      each_default(elements, function(el) {
        if (_this.isMathItem(el, field, item)) {
          el.setState(_this.stateName, enable);
        }
      });
    };
    ElementState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement(this.context);
      if (element) {
        if (isElementChange(this.context)) {
          this.setStateByElement(element, enable);
        }
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component = delegateObject.component;
          if (item && component && !this.isItemIgnore(item, component)) {
            var event_1 = this.context.event.gEvent;
            if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
              return;
            }
            this.setStateByComponent(component, item, enable);
          }
        }
      }
    };
    ElementState2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setElementState(element, !hasState);
      }
    };
    ElementState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementState2;
  }(state_base_default);
  var state_default = ElementState;

  // node_modules/@antv/g2/esm/interaction/action/element/active.js
  var ElementActive = function(_super) {
    __extends(ElementActive2, _super);
    function ElementActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementActive2.prototype.active = function() {
      this.setState();
    };
    return ElementActive2;
  }(state_default);
  var active_default = ElementActive;

  // node_modules/@antv/g2/esm/interaction/action/element/link-by-color.js
  var LinkByColor = function(_super) {
    __extends(LinkByColor2, _super);
    function LinkByColor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = {};
      return _this;
    }
    LinkByColor2.prototype.getColorScale = function(view, element) {
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return null;
      }
      var scale5 = view.getScaleByField(colorAttr.getFields()[0]);
      return scale5;
    };
    LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
      var view = this.context.view;
      var isTransposed = view.getCoordinate().isTransposed;
      var bbox = element.shape.getCanvasBBox();
      var nextBBox = nextElement.shape.getCanvasBBox();
      var path = isTransposed ? [
        ["M", bbox.minX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", nextBBox.maxX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.minY],
        ["Z"]
      ] : [
        ["M", bbox.maxX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.maxY],
        ["Z"]
      ];
      return path;
    };
    LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
      var style = {
        opacity: 0.4,
        fill: element.shape.attr("fill")
      };
      group2.addShape({
        type: "path",
        attrs: __assign(__assign({}, deep_mix_default({}, style, is_function_default(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
      });
    };
    LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
      var _this = this;
      var view = this.context.view;
      var scale5 = this.getColorScale(view, element);
      if (!scale5) {
        return;
      }
      var value = getElementValue(element, scale5.field);
      if (!this.cache[value]) {
        var elements_1 = getElementsByField(view, scale5.field, value);
        var linkGroup = this.linkGroup;
        var group_1 = linkGroup.addGroup();
        this.cache[value] = group_1;
        var count_1 = elements_1.length;
        each_default(elements_1, function(el, index) {
          if (index < count_1 - 1) {
            var nextEl = elements_1[index + 1];
            _this.addLinkShape(group_1, el, nextEl, activeStyle);
          }
        });
      }
    };
    LinkByColor2.prototype.removeLink = function(element) {
      var scale5 = this.getColorScale(this.context.view, element);
      if (!scale5) {
        return;
      }
      var value = getElementValue(element, scale5.field);
      if (this.cache[value]) {
        this.cache[value].remove();
        this.cache[value] = null;
      }
    };
    LinkByColor2.prototype.link = function(args) {
      var context = this.context;
      if (!this.linkGroup) {
        this.linkGroup = context.view.foregroundGroup.addGroup({
          id: "link-by-color-group",
          capture: false
        });
      }
      var element = getCurrentElement(context);
      if (element) {
        this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
      }
    };
    LinkByColor2.prototype.unlink = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        this.removeLink(element);
      }
    };
    LinkByColor2.prototype.clear = function() {
      if (this.linkGroup) {
        this.linkGroup.clear();
      }
      this.cache = {};
    };
    LinkByColor2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.linkGroup) {
        this.linkGroup.remove();
      }
    };
    return LinkByColor2;
  }(base_default13);
  var link_by_color_default = LinkByColor;

  // node_modules/@antv/g2/esm/interaction/action/element/range-state.js
  var ElementRangeState = function(_super) {
    __extends(ElementRangeState2, _super);
    function ElementRangeState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.endPoint = null;
      _this.isStarted = false;
      _this.effectSiblings = false;
      _this.effectByRecord = false;
      return _this;
    }
    ElementRangeState2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    ElementRangeState2.prototype.start = function() {
      this.clear();
      this.startPoint = this.getCurrentPoint();
      this.isStarted = true;
    };
    ElementRangeState2.prototype.getIntersectElements = function() {
      var elements = null;
      if (isMask(this.context)) {
        elements = getMaskedElements(this.context, 10);
      } else {
        var startPoint = this.startPoint;
        var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
        if (!startPoint || !endPoint) {
          return;
        }
        var box2 = {
          minX: Math.min(startPoint.x, endPoint.x),
          minY: Math.min(startPoint.y, endPoint.y),
          maxX: Math.max(startPoint.x, endPoint.x),
          maxY: Math.max(startPoint.y, endPoint.y)
        };
        var view = this.context.view;
        elements = getIntersectElements(view, box2);
      }
      return elements;
    };
    ElementRangeState2.prototype.setStateEnable = function(enable) {
      if (this.effectSiblings && !this.effectByRecord) {
        this.setSiblingsState(enable);
      } else {
        var allElements = getElements(this.context.view);
        var elements = this.getIntersectElements();
        if (elements && elements.length) {
          if (this.effectByRecord) {
            this.setSiblingsStateByRecord(elements, enable);
          } else {
            this.setElementsState(elements, enable, allElements);
          }
        } else {
          this.clear();
        }
      }
    };
    ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      var records = elements.map(function(el) {
        return el.getModel().data;
      });
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      each_default(siblings, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = allElements.filter(function(el) {
          var record = el.getModel().data;
          return isInRecords(records, record, xFiled, yField);
        });
        _this.setElementsState(effectElements, enable, allElements);
      });
    };
    ElementRangeState2.prototype.setSiblingsState = function(enable) {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      if (isMask(this.context)) {
        each_default(siblings, function(sibling) {
          var allElements = getElements(sibling);
          var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
          if (effectElements && effectElements.length) {
            _this.setElementsState(effectElements, enable, allElements);
          } else {
            _this.clearViewState(sibling);
          }
        });
      }
    };
    ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
      var _this = this;
      each_default(allElements, function(el) {
        if (!elements.includes(el)) {
          _this.setElementState(el, false);
        } else {
          _this.setElementState(el, enable);
        }
      });
    };
    ElementRangeState2.prototype.end = function() {
      this.isStarted = false;
      this.endPoint = this.getCurrentPoint();
    };
    ElementRangeState2.prototype.clear = function() {
      var _this = this;
      var view = this.context.view;
      if (this.effectSiblings) {
        var siblings = getSilbings(view);
        each_default(siblings, function(sibling) {
          _this.clearViewState(sibling);
        });
      } else {
        this.clearViewState(view);
      }
    };
    return ElementRangeState2;
  }(state_base_default);
  var range_state_default = ElementRangeState;

  // node_modules/@antv/g2/esm/interaction/action/element/range-active.js
  var ElementRangeActive = function(_super) {
    __extends(ElementRangeActive2, _super);
    function ElementRangeActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeActive2.prototype.active = function() {
      this.setState();
    };
    return ElementRangeActive2;
  }(range_state_default);
  var range_active_default = ElementRangeActive;

  // node_modules/@antv/g2/esm/interaction/action/element/single-state.js
  var ElementSingleState = function(_super) {
    __extends(ElementSingleState2, _super);
    function ElementSingleState2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementSingleState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement(this.context);
      if (element) {
        if (!isElementChange(this.context)) {
          return;
        }
        if (enable) {
          this.clear();
          this.setElementState(element, true);
        } else if (this.hasState(element)) {
          this.setElementState(element, false);
        }
      }
    };
    ElementSingleState2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = this.hasState(element);
        if (!hasState) {
          this.clear();
        }
        this.setElementState(element, !hasState);
      }
    };
    ElementSingleState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementSingleState2;
  }(state_base_default);
  var single_state_default = ElementSingleState;

  // node_modules/@antv/g2/esm/interaction/action/element/single-active.js
  var ElementSingleActive = function(_super) {
    __extends(ElementSingleActive2, _super);
    function ElementSingleActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleActive2.prototype.active = function() {
      this.setState();
    };
    return ElementSingleActive2;
  }(single_state_default);
  var single_active_default = ElementSingleActive;

  // node_modules/@antv/g2/esm/interaction/action/element/highlight-util.js
  var STATUS_UNACTIVE = "inactive";
  var STATUS_ACTIVE = "active";
  function clearHighlight(view) {
    var elements = getElements(view);
    each_default(elements, function(el) {
      if (el.hasState(STATUS_ACTIVE)) {
        el.setState(STATUS_ACTIVE, false);
      }
      if (el.hasState(STATUS_UNACTIVE)) {
        el.setState(STATUS_UNACTIVE, false);
      }
    });
  }
  function setHighlightBy(elements, callback, enable) {
    each_default(elements, function(el) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE)) {
          el.setState(STATUS_UNACTIVE, false);
        }
        el.setState(STATUS_ACTIVE, enable);
      } else {
        if (el.hasState(STATUS_ACTIVE)) {
          el.setState(STATUS_ACTIVE, false);
        }
        el.setState(STATUS_UNACTIVE, enable);
      }
    });
  }

  // node_modules/@antv/g2/esm/interaction/action/element/highlight.js
  var STATUS_UNACTIVE2 = ELEMENT_STATE.INACTIVE;
  var STATUS_ACTIVE2 = ELEMENT_STATE.ACTIVE;
  var ElementHighlight = function(_super) {
    __extends(ElementHighlight2, _super);
    function ElementHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE2;
      return _this;
    }
    ElementHighlight2.prototype.setElementsStateByItem = function(elements, field, item, enable) {
      var _this = this;
      var callback = function(el) {
        return _this.isMathItem(el, field, item);
      };
      this.setHighlightBy(elements, callback, enable);
    };
    ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE2)) {
          el.setState(STATUS_UNACTIVE2, false);
        }
        el.setState(STATUS_ACTIVE2, true);
      } else if (!el.hasState(STATUS_ACTIVE2)) {
        el.setState(STATUS_UNACTIVE2, true);
      }
    };
    ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
      var _this = this;
      if (enable) {
        each_default(elements, function(el) {
          _this.setElementHighlight(el, callback);
        });
      } else {
        var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE2);
        var allCancel_1 = true;
        each_default(activeElements, function(el) {
          if (!callback(el)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each_default(elements, function(el) {
            if (callback(el)) {
              if (el.hasState(STATUS_ACTIVE2)) {
                el.setState(STATUS_ACTIVE2, false);
              }
              el.setState(STATUS_UNACTIVE2, true);
            }
          });
        }
      }
    };
    ElementHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      this.setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight(view);
    };
    return ElementHighlight2;
  }(state_default);
  var highlight_default = ElementHighlight;

  // node_modules/@antv/g2/esm/interaction/action/element/highlight-by-color.js
  var HighlightColor = function(_super) {
    __extends(HighlightColor2, _super);
    function HighlightColor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightColor2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return;
      }
      var scale5 = view.getScaleByField(colorAttr.getFields()[0]);
      var value = getElementValue(element, scale5.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue(el, scale5.field) === value;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    return HighlightColor2;
  }(highlight_default);
  var highlight_by_color_default = HighlightColor;

  // node_modules/@antv/g2/esm/interaction/action/element/highlight-by-x.js
  var HighlightX = function(_super) {
    __extends(HighlightX2, _super);
    function HighlightX2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightX2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE2)) {
          el.setState(STATUS_UNACTIVE2, false);
        }
        el.setState(STATUS_ACTIVE2, true);
      } else {
        el.setState(STATUS_UNACTIVE2, true);
        if (el.hasState(STATUS_ACTIVE2)) {
          el.setState(STATUS_ACTIVE2, false);
        }
      }
    };
    HighlightX2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var scale5 = view.getXScale();
      var value = getElementValue(element, scale5.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue(el, scale5.field) === value;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    HighlightX2.prototype.toggle = function() {
      var element = getCurrentElement(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setStateByElement(element, !hasState);
      }
    };
    return HighlightX2;
  }(highlight_default);
  var highlight_by_x_default = HighlightX;

  // node_modules/@antv/g2/esm/interaction/action/element/range-highlight.js
  var EVENTS3;
  (function(EVENTS5) {
    EVENTS5["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
    EVENTS5["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
    EVENTS5["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
    EVENTS5["AFTER_CLEAR"] = "element-range-highlight:afterclear";
  })(EVENTS3 || (EVENTS3 = {}));
  var ElementRangeHighlight = function(_super) {
    __extends(ElementRangeHighlight2, _super);
    function ElementRangeHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeHighlight2.prototype.clearViewState = function(view) {
      clearHighlight(view);
    };
    ElementRangeHighlight2.prototype.highlight = function() {
      var _a4 = this.context, view = _a4.view, event = _a4.event;
      var elements = this.getIntersectElements();
      var payload = { view, event, highlightElements: elements };
      view.emit(EVENTS3.BEFORE_HIGHLIGHT, event_default.fromData(view, EVENTS3.BEFORE_HIGHLIGHT, payload));
      this.setState();
      view.emit(EVENTS3.AFTER_HIGHLIGHT, event_default.fromData(view, EVENTS3.AFTER_HIGHLIGHT, payload));
    };
    ElementRangeHighlight2.prototype.clear = function() {
      var view = this.context.view;
      view.emit(EVENTS3.BEFORE_CLEAR, event_default.fromData(view, EVENTS3.BEFORE_CLEAR, {}));
      _super.prototype.clear.call(this);
      view.emit(EVENTS3.AFTER_CLEAR, event_default.fromData(view, EVENTS3.AFTER_CLEAR, {}));
    };
    ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
      setHighlightBy(allElements, function(el) {
        return elements.indexOf(el) >= 0;
      }, enable);
    };
    return ElementRangeHighlight2;
  }(range_state_default);
  var range_highlight_default = ElementRangeHighlight;

  // node_modules/@antv/g2/esm/interaction/action/element/single-highlight.js
  var ElementSingleHighlight = function(_super) {
    __extends(ElementSingleHighlight2, _super);
    function ElementSingleHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementSingleHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight(view);
    };
    return ElementSingleHighlight2;
  }(single_state_default);
  var single_highlight_default = ElementSingleHighlight;

  // node_modules/@antv/g2/esm/interaction/action/element/range-selected.js
  var ElementRangeSelected = function(_super) {
    __extends(ElementRangeSelected2, _super);
    function ElementRangeSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementRangeSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementRangeSelected2;
  }(range_state_default);
  var range_selected_default = ElementRangeSelected;

  // node_modules/@antv/g2/esm/interaction/action/element/selected.js
  var ElementMultipleSelected = function(_super) {
    __extends(ElementMultipleSelected2, _super);
    function ElementMultipleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementMultipleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementMultipleSelected2;
  }(state_default);
  var selected_default = ElementMultipleSelected;

  // node_modules/@antv/g2/esm/interaction/action/element/single-selected.js
  var ElementSingleSelected = function(_super) {
    __extends(ElementSingleSelected2, _super);
    function ElementSingleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementSingleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementSingleSelected2;
  }(single_state_default);
  var single_selected_default = ElementSingleSelected;

  // node_modules/@antv/g2/esm/interaction/action/component/list-state.js
  var ListState = function(_super) {
    __extends(ListState2, _super);
    function ListState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      _this.ignoreItemStates = [];
      return _this;
    }
    ListState2.prototype.getTriggerListInfo = function() {
      var delegateObject = getDelegationObject(this.context);
      var info = null;
      if (isList(delegateObject)) {
        info = {
          item: delegateObject.item,
          list: delegateObject.component
        };
      }
      return info;
    };
    ListState2.prototype.getAllowComponents = function() {
      var _this = this;
      var view = this.context.view;
      var components = getComponents(view);
      var rst = [];
      each_default(components, function(component) {
        if (component.isList() && _this.allowSetStateByElement(component)) {
          rst.push(component);
        }
      });
      return rst;
    };
    ListState2.prototype.hasState = function(list, item) {
      return list.hasState(item, this.stateName);
    };
    ListState2.prototype.clearAllComponentsState = function() {
      var _this = this;
      var components = this.getAllowComponents();
      each_default(components, function(component) {
        component.clearItemsState(_this.stateName);
      });
    };
    ListState2.prototype.allowSetStateByElement = function(component) {
      var field = component.get("field");
      if (!field) {
        return false;
      }
      if (this.cfg && this.cfg.componentNames) {
        var name_1 = component.get("name");
        if (this.cfg.componentNames.indexOf(name_1) === -1) {
          return false;
        }
      }
      var view = this.context.view;
      var scale5 = getScaleByField(view, field);
      return scale5 && scale5.isCategory;
    };
    ListState2.prototype.allowSetStateByItem = function(item, list) {
      var ignoreStates = this.ignoreItemStates;
      if (ignoreStates.length) {
        var filterStates = ignoreStates.filter(function(state) {
          return list.hasState(item, state);
        });
        return filterStates.length === 0;
      }
      return true;
    };
    ListState2.prototype.setStateByElement = function(component, element, enable) {
      var field = component.get("field");
      var view = this.context.view;
      var scale5 = getScaleByField(view, field);
      var value = getElementValue(element, field);
      var text = scale5.getText(value);
      this.setItemsState(component, text, enable);
    };
    ListState2.prototype.setStateEnable = function(enable) {
      var _this = this;
      var element = getCurrentElement(this.context);
      if (element) {
        var components = this.getAllowComponents();
        each_default(components, function(component2) {
          _this.setStateByElement(component2, element, enable);
        });
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component = delegateObject.component;
          if (this.allowSetStateByElement(component) && this.allowSetStateByItem(item, component)) {
            this.setItemState(component, item, enable);
          }
        }
      }
    };
    ListState2.prototype.setItemsState = function(list, name, enable) {
      var _this = this;
      var items = list.getItems();
      each_default(items, function(item) {
        if (item.name === name) {
          _this.setItemState(list, item, enable);
        }
      });
    };
    ListState2.prototype.setItemState = function(list, item, enable) {
      list.setItemState(item, this.stateName, enable);
    };
    ListState2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    ListState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    ListState2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        var enable = this.hasState(list, item);
        this.setItemState(list, item, !enable);
      }
    };
    ListState2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        triggerInfo.list.clearItemsState(this.stateName);
      } else {
        this.clearAllComponentsState();
      }
    };
    return ListState2;
  }(base_default13);
  var list_state_default = ListState;

  // node_modules/@antv/g2/esm/interaction/action/component/list-active.js
  var ListActive = function(_super) {
    __extends(ListActive2, _super);
    function ListActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ListActive2.prototype.active = function() {
      this.setState();
    };
    return ListActive2;
  }(list_state_default);
  var list_active_default = ListActive;

  // node_modules/@antv/g2/esm/interaction/action/component/list-highlight-util.js
  var STATUS_UNACTIVE3 = "inactive";
  var STATUS_ACTIVE3 = "active";
  function clearList(list) {
    var items = list.getItems();
    each_default(items, function(item) {
      if (list.hasState(item, STATUS_ACTIVE3)) {
        list.setItemState(item, STATUS_ACTIVE3, false);
      }
      if (list.hasState(item, STATUS_UNACTIVE3)) {
        list.setItemState(item, STATUS_UNACTIVE3, false);
      }
    });
  }

  // node_modules/@antv/g2/esm/interaction/action/component/list-highlight.js
  var STATUS_UNACTIVE4 = "inactive";
  var STATUS_ACTIVE4 = "active";
  var ListHighlight = function(_super) {
    __extends(ListHighlight2, _super);
    function ListHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE4;
      _this.ignoreItemStates = ["unchecked"];
      return _this;
    }
    ListHighlight2.prototype.setItemsState = function(list, name, enable) {
      this.setHighlightBy(list, function(item) {
        return item.name === name;
      }, enable);
    };
    ListHighlight2.prototype.setItemState = function(list, item, enable) {
      var items = list.getItems();
      this.setHighlightBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNACTIVE4)) {
              list.setItemState(item, STATUS_UNACTIVE4, false);
            }
            list.setItemState(item, STATUS_ACTIVE4, true);
          } else if (!list.hasState(item, STATUS_ACTIVE4)) {
            list.setItemState(item, STATUS_UNACTIVE4, true);
          }
        });
      } else {
        var activeItems = list.getItemsByState(STATUS_ACTIVE4);
        var allCancel_1 = true;
        each_default(activeItems, function(item) {
          if (!callback(item)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each_default(items, function(item) {
            if (callback(item)) {
              if (list.hasState(item, STATUS_ACTIVE4)) {
                list.setItemState(item, STATUS_ACTIVE4, false);
              }
              list.setItemState(item, STATUS_UNACTIVE4, true);
            }
          });
        }
      }
    };
    ListHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ListHighlight2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        clearList(triggerInfo.list);
      } else {
        var components = this.getAllowComponents();
        each_default(components, function(component) {
          component.clearItemsState(STATUS_ACTIVE4);
          component.clearItemsState(STATUS_UNACTIVE4);
        });
      }
    };
    return ListHighlight2;
  }(list_state_default);
  var list_highlight_default = ListHighlight;

  // node_modules/@antv/g2/esm/interaction/action/component/list-selected.js
  var ListSelected = function(_super) {
    __extends(ListSelected2, _super);
    function ListSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ListSelected2.prototype.selected = function() {
      this.setState();
    };
    return ListSelected2;
  }(list_state_default);
  var list_selected_default = ListSelected;

  // node_modules/@antv/g2/esm/interaction/action/component/list-unchecked.js
  var ListUnchecked = function(_super) {
    __extends(ListUnchecked2, _super);
    function ListUnchecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "unchecked";
      return _this;
    }
    ListUnchecked2.prototype.unchecked = function() {
      this.setState();
    };
    return ListUnchecked2;
  }(list_state_default);
  var list_unchecked_default = ListUnchecked;

  // node_modules/@antv/g2/esm/interaction/action/component/list-checked.js
  var STATUS_UNCHECKED = "unchecked";
  var STATUS_CHECKED = "checked";
  var ListChecked = function(_super) {
    __extends(ListChecked2, _super);
    function ListChecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_CHECKED;
      return _this;
    }
    ListChecked2.prototype.setItemState = function(list, item, enable) {
      this.setCheckedBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each_default(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNCHECKED)) {
              list.setItemState(item, STATUS_UNCHECKED, false);
            }
            list.setItemState(item, STATUS_CHECKED, true);
          } else if (!list.hasState(item, STATUS_CHECKED)) {
            list.setItemState(item, STATUS_UNCHECKED, true);
          }
        });
      }
    };
    ListChecked2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list_1 = triggerInfo.list, item = triggerInfo.item;
        var allChecked = !some_default(list_1.getItems(), function(t) {
          return list_1.hasState(t, STATUS_UNCHECKED);
        });
        if (allChecked || list_1.hasState(item, STATUS_UNCHECKED)) {
          this.setItemState(list_1, item, true);
        } else {
          this.reset();
        }
      }
    };
    ListChecked2.prototype.checked = function() {
      this.setState();
    };
    ListChecked2.prototype.reset = function() {
      var components = this.getAllowComponents();
      each_default(components, function(component) {
        component.clearItemsState(STATUS_CHECKED);
        component.clearItemsState(STATUS_UNCHECKED);
      });
    };
    return ListChecked2;
  }(list_state_default);
  var list_checked_default = ListChecked;

  // node_modules/@antv/g2/esm/interaction/action/mask/base.js
  var MaskBase = function(_super) {
    __extends(MaskBase2, _super);
    function MaskBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.maskShape = null;
      _this.points = [];
      _this.starting = false;
      _this.moving = false;
      _this.preMovePoint = null;
      _this.shapeType = "path";
      return _this;
    }
    MaskBase2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    MaskBase2.prototype.emitEvent = function(type) {
      var eventName = "mask:" + type;
      var view = this.context.view;
      var event = this.context.event;
      view.emit(eventName, {
        target: this.maskShape,
        shape: this.maskShape,
        points: this.points,
        x: event.x,
        y: event.y
      });
    };
    MaskBase2.prototype.createMask = function() {
      var view = this.context.view;
      var maskAttrs = this.getMaskAttrs();
      var maskShape = view.foregroundGroup.addShape({
        type: this.shapeType,
        name: "mask",
        draggable: true,
        attrs: __assign({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
      });
      return maskShape;
    };
    MaskBase2.prototype.getMaskPath = function() {
      return [];
    };
    MaskBase2.prototype.show = function() {
      if (this.maskShape) {
        this.maskShape.show();
        this.emitEvent("show");
      }
    };
    MaskBase2.prototype.start = function(arg) {
      this.starting = true;
      this.moving = false;
      this.points = [this.getCurrentPoint()];
      if (!this.maskShape) {
        this.maskShape = this.createMask();
        this.maskShape.set("capture", false);
      }
      this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
      this.emitEvent("start");
    };
    MaskBase2.prototype.moveStart = function() {
      this.moving = true;
      this.preMovePoint = this.getCurrentPoint();
    };
    MaskBase2.prototype.move = function() {
      if (!this.moving || !this.maskShape) {
        return;
      }
      var currentPoint = this.getCurrentPoint();
      var preMovePoint = this.preMovePoint;
      var dx = currentPoint.x - preMovePoint.x;
      var dy = currentPoint.y - preMovePoint.y;
      var points = this.points;
      each_default(points, function(point) {
        point.x += dx;
        point.y += dy;
      });
      this.updateMask();
      this.emitEvent("change");
      this.preMovePoint = currentPoint;
    };
    MaskBase2.prototype.updateMask = function(maskStyle) {
      var attrs = deep_mix_default({}, this.getMaskAttrs(), maskStyle);
      this.maskShape.attr(attrs);
    };
    MaskBase2.prototype.moveEnd = function() {
      this.moving = false;
      this.preMovePoint = null;
    };
    MaskBase2.prototype.end = function() {
      this.starting = false;
      this.emitEvent("end");
      if (this.maskShape) {
        this.maskShape.set("capture", true);
      }
    };
    MaskBase2.prototype.hide = function() {
      if (this.maskShape) {
        this.maskShape.hide();
        this.emitEvent("hide");
      }
    };
    MaskBase2.prototype.resize = function() {
      if (this.starting && this.maskShape) {
        this.points.push(this.getCurrentPoint());
        this.updateMask();
        this.emitEvent("change");
      }
    };
    MaskBase2.prototype.destroy = function() {
      this.points = [];
      if (this.maskShape) {
        this.maskShape.remove();
      }
      this.maskShape = null;
      this.preMovePoint = null;
      _super.prototype.destroy.call(this);
    };
    return MaskBase2;
  }(base_default13);
  var base_default18 = MaskBase;

  // node_modules/@antv/g2/esm/interaction/action/mask/circle.js
  var CircleMask = function(_super) {
    __extends(CircleMask2, _super);
    function CircleMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "circle";
      return _this;
    }
    CircleMask2.prototype.getMaskAttrs = function() {
      var points = this.points;
      var currentPoint = last(this.points);
      var r = 0;
      var x = 0;
      var y = 0;
      if (points.length) {
        var first = points[0];
        r = distance6(first, currentPoint) / 2;
        x = (currentPoint.x + first.x) / 2;
        y = (currentPoint.y + first.y) / 2;
      }
      return {
        x,
        y,
        r
      };
    };
    return CircleMask2;
  }(base_default18);
  var circle_default9 = CircleMask;

  // node_modules/@antv/g2/esm/interaction/action/mask/rect.js
  var RectMask = function(_super) {
    __extends(RectMask2, _super);
    function RectMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "rect";
      return _this;
    }
    RectMask2.prototype.getRegion = function() {
      var points = this.points;
      return {
        start: head(points),
        end: last(points)
      };
    };
    RectMask2.prototype.getMaskAttrs = function() {
      var _a4 = this.getRegion(), start = _a4.start, end = _a4.end;
      var x = Math.min(start.x, end.x);
      var y = Math.min(start.y, end.y);
      var width = Math.abs(end.x - start.x);
      var height = Math.abs(end.y - start.y);
      return {
        x,
        y,
        width,
        height
      };
    };
    return RectMask2;
  }(base_default18);
  var rect_default6 = RectMask;

  // node_modules/@antv/g2/esm/interaction/action/mask/dim-rect.js
  function clampPoint(point) {
    point.x = clamp_default(point.x, 0, 1);
    point.y = clamp_default(point.y, 0, 1);
  }
  var DimRect = function(_super) {
    __extends(DimRect2, _super);
    function DimRect2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dim = "x";
      _this.inPlot = true;
      return _this;
    }
    DimRect2.prototype.getRegion = function() {
      var start = null;
      var end = null;
      var points = this.points;
      var dim = this.dim;
      var coord = this.context.view.getCoordinate();
      var normalStart = coord.invert(head(points));
      var normalEnd = coord.invert(last(points));
      if (this.inPlot) {
        clampPoint(normalStart);
        clampPoint(normalEnd);
      }
      if (dim === "x") {
        start = coord.convert({
          x: normalStart.x,
          y: 0
        });
        end = coord.convert({
          x: normalEnd.x,
          y: 1
        });
      } else {
        start = coord.convert({
          x: 0,
          y: normalStart.y
        });
        end = coord.convert({
          x: 1,
          y: normalEnd.y
        });
      }
      return {
        start,
        end
      };
    };
    return DimRect2;
  }(rect_default6);
  var dim_rect_default = DimRect;

  // node_modules/@antv/g2/esm/interaction/action/mask/path.js
  var PathMask = function(_super) {
    __extends(PathMask2, _super);
    function PathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PathMask2.prototype.getMaskPath = function() {
      var points = this.points;
      var path = [];
      if (points.length) {
        each_default(points, function(point, index) {
          if (index === 0) {
            path.push(["M", point.x, point.y]);
          } else {
            path.push(["L", point.x, point.y]);
          }
        });
        path.push(["L", points[0].x, points[0].y]);
      }
      return path;
    };
    PathMask2.prototype.getMaskAttrs = function() {
      return {
        path: this.getMaskPath()
      };
    };
    PathMask2.prototype.addPoint = function() {
      this.resize();
    };
    return PathMask2;
  }(base_default18);
  var path_default7 = PathMask;

  // node_modules/@antv/g2/esm/interaction/action/mask/smooth-path.js
  var SmoothPathMask = function(_super) {
    __extends(SmoothPathMask2, _super);
    function SmoothPathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SmoothPathMask2.prototype.getMaskPath = function() {
      var points = this.points;
      return getSpline(points, true);
    };
    return SmoothPathMask2;
  }(path_default7);
  var smooth_path_default = SmoothPathMask;

  // node_modules/@antv/g2/esm/interaction/action/cursor.js
  var CursorAction = function(_super) {
    __extends(CursorAction2, _super);
    function CursorAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CursorAction2.prototype.setCursor = function(cursor) {
      var view = this.context.view;
      view.getCanvas().setCursor(cursor);
    };
    CursorAction2.prototype.default = function() {
      this.setCursor("default");
    };
    CursorAction2.prototype.pointer = function() {
      this.setCursor("pointer");
    };
    CursorAction2.prototype.move = function() {
      this.setCursor("move");
    };
    CursorAction2.prototype.crosshair = function() {
      this.setCursor("crosshair");
    };
    CursorAction2.prototype.wait = function() {
      this.setCursor("wait");
    };
    CursorAction2.prototype.help = function() {
      this.setCursor("help");
    };
    CursorAction2.prototype.text = function() {
      this.setCursor("text");
    };
    CursorAction2.prototype.eResize = function() {
      this.setCursor("e-resize");
    };
    CursorAction2.prototype.wResize = function() {
      this.setCursor("w-resize");
    };
    CursorAction2.prototype.nResize = function() {
      this.setCursor("n-resize");
    };
    CursorAction2.prototype.sResize = function() {
      this.setCursor("s-resize");
    };
    CursorAction2.prototype.neResize = function() {
      this.setCursor("ne-resize");
    };
    CursorAction2.prototype.nwResize = function() {
      this.setCursor("nw-resize");
    };
    CursorAction2.prototype.seResize = function() {
      this.setCursor("se-resize");
    };
    CursorAction2.prototype.swResize = function() {
      this.setCursor("sw-resize");
    };
    CursorAction2.prototype.nsResize = function() {
      this.setCursor("ns-resize");
    };
    CursorAction2.prototype.ewResize = function() {
      this.setCursor("ew-resize");
    };
    return CursorAction2;
  }(base_default13);
  var cursor_default = CursorAction;

  // node_modules/@antv/g2/esm/interaction/action/data/filter.js
  var DataFilter = function(_super) {
    __extends(DataFilter2, _super);
    function DataFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataFilter2.prototype.filterView = function(view, field, filter2) {
      var _this = this;
      if (view.getScaleByField(field)) {
        view.filter(field, filter2);
      }
      if (view.views && view.views.length) {
        each_default(view.views, function(subView) {
          _this.filterView(subView, field, filter2);
        });
      }
    };
    DataFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      if (delegateObject) {
        var view = this.context.view;
        var component = delegateObject.component;
        var field = component.get("field");
        if (isList(delegateObject)) {
          if (field) {
            var unCheckedItems = component.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            if (names_1.length) {
              this.filterView(view, field, function(value) {
                var text = scale_1.getText(value);
                return !names_1.includes(text);
              });
            } else {
              this.filterView(view, field, null);
            }
            view.render(true);
          }
        } else if (isSlider(delegateObject)) {
          var range5 = component.getValue();
          var min_1 = range5[0], max_1 = range5[1];
          this.filterView(view, field, function(value) {
            return value >= min_1 && value <= max_1;
          });
          view.render(true);
        }
      }
    };
    return DataFilter2;
  }(base_default13);
  var filter_default2 = DataFilter;

  // node_modules/@antv/g2/esm/interaction/action/data/range-filter.js
  function getFilter(scale5, dim, point1, point2) {
    var min7 = Math.min(point1[dim], point2[dim]);
    var max7 = Math.max(point1[dim], point2[dim]);
    var _a4 = scale5.range, rangeMin = _a4[0], rangeMax = _a4[1];
    if (min7 < rangeMin) {
      min7 = rangeMin;
    }
    if (max7 > rangeMax) {
      max7 = rangeMax;
    }
    if (min7 === rangeMax && max7 === rangeMax) {
      return null;
    }
    var minValue = scale5.invert(min7);
    var maxValue = scale5.invert(max7);
    if (scale5.isCategory) {
      var minIndex = scale5.values.indexOf(minValue);
      var maxIndex = scale5.values.indexOf(maxValue);
      var arr_1 = scale5.values.slice(minIndex, maxIndex + 1);
      return function(value) {
        return arr_1.includes(value);
      };
    } else {
      return function(value) {
        return value >= minValue && value <= maxValue;
      };
    }
  }
  var EVENTS4;
  (function(EVENTS5) {
    EVENTS5["FILTER"] = "brush-filter-processing";
    EVENTS5["RESET"] = "brush-filter-reset";
    EVENTS5["BEFORE_FILTER"] = "brush-filter:beforefilter";
    EVENTS5["AFTER_FILTER"] = "brush-filter:afterfilter";
    EVENTS5["BEFORE_RESET"] = "brush-filter:beforereset";
    EVENTS5["AFTER_RESET"] = "brush-filter:afterreset";
  })(EVENTS4 || (EVENTS4 = {}));
  var RangeFilter = function(_super) {
    __extends(RangeFilter2, _super);
    function RangeFilter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = ["x", "y"];
      _this.startPoint = null;
      _this.isStarted = false;
      return _this;
    }
    RangeFilter2.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    RangeFilter2.prototype.start = function() {
      var context = this.context;
      this.isStarted = true;
      this.startPoint = context.getCurrentPoint();
    };
    RangeFilter2.prototype.filter = function() {
      var startPoint;
      var currentPoint;
      if (isMask(this.context)) {
        var maskShape = this.context.event.target;
        var bbox = maskShape.getCanvasBBox();
        startPoint = { x: bbox.x, y: bbox.y };
        currentPoint = { x: bbox.maxX, y: bbox.maxY };
      } else {
        if (!this.isStarted) {
          return;
        }
        startPoint = this.startPoint;
        currentPoint = this.context.getCurrentPoint();
      }
      if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
        return;
      }
      var _a4 = this.context, view = _a4.view, event = _a4.event;
      var payload = { view, event, dims: this.dims };
      view.emit(EVENTS4.BEFORE_FILTER, event_default.fromData(view, EVENTS4.BEFORE_FILTER, payload));
      var coord = view.getCoordinate();
      var normalCurrent = coord.invert(currentPoint);
      var normalStart = coord.invert(startPoint);
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        var filter2 = getFilter(xScale, "x", normalCurrent, normalStart);
        this.filterView(view, xScale.field, filter2);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        var filter2 = getFilter(yScale, "y", normalCurrent, normalStart);
        this.filterView(view, yScale.field, filter2);
      }
      this.reRender(view, { source: EVENTS4.FILTER });
      view.emit(EVENTS4.AFTER_FILTER, event_default.fromData(view, EVENTS4.AFTER_FILTER, payload));
    };
    RangeFilter2.prototype.end = function() {
      this.isStarted = false;
    };
    RangeFilter2.prototype.reset = function() {
      var view = this.context.view;
      view.emit(EVENTS4.BEFORE_RESET, event_default.fromData(view, EVENTS4.BEFORE_RESET, {}));
      this.isStarted = false;
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        this.filterView(view, xScale.field, null);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        this.filterView(view, yScale.field, null);
      }
      this.reRender(view, { source: EVENTS4.RESET });
      view.emit(EVENTS4.AFTER_RESET, event_default.fromData(view, EVENTS4.AFTER_RESET, {}));
    };
    RangeFilter2.prototype.filterView = function(view, field, filter2) {
      view.filter(field, filter2);
    };
    RangeFilter2.prototype.reRender = function(view, payload) {
      view.render(true, payload);
    };
    return RangeFilter2;
  }(base_default13);
  var range_filter_default = RangeFilter;

  // node_modules/@antv/g2/esm/interaction/action/data/sibling-filter.js
  var SiblingFilter = function(_super) {
    __extends(SiblingFilter3, _super);
    function SiblingFilter3() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingFilter3.prototype.filterView = function(view, field, filter2) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.filter(field, filter2);
      });
    };
    SiblingFilter3.prototype.reRender = function(view) {
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        sibling.render(true);
      });
    };
    return SiblingFilter3;
  }(range_filter_default);
  var sibling_filter_default = SiblingFilter;

  // node_modules/@antv/g2/esm/interaction/action/element/filter.js
  var ElementFilter = function(_super) {
    __extends(ElementFilter2, _super);
    function ElementFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      var view = this.context.view;
      var elements = getElements(view);
      if (isMask(this.context)) {
        var maskElements_1 = getMaskedElements(this.context, 10);
        if (maskElements_1) {
          each_default(elements, function(el) {
            if (maskElements_1.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      } else if (delegateObject) {
        var component = delegateObject.component;
        var field_1 = component.get("field");
        if (isList(delegateObject)) {
          if (field_1) {
            var unCheckedItems = component.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field_1);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            each_default(elements, function(el) {
              var value = getElementValue(el, field_1);
              var text = scale_1.getText(value);
              if (names_1.indexOf(text) >= 0) {
                el.hide();
              } else {
                el.show();
              }
            });
          }
        } else if (isSlider(delegateObject)) {
          var range5 = component.getValue();
          var min_1 = range5[0], max_1 = range5[1];
          each_default(elements, function(el) {
            var value = getElementValue(el, field_1);
            if (value >= min_1 && value <= max_1) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      }
    };
    ElementFilter2.prototype.clear = function() {
      var elements = getElements(this.context.view);
      each_default(elements, function(el) {
        el.show();
      });
    };
    ElementFilter2.prototype.reset = function() {
      this.clear();
    };
    return ElementFilter2;
  }(base_default13);
  var filter_default3 = ElementFilter;

  // node_modules/@antv/g2/esm/interaction/action/element/sibling-filter.js
  var SiblingFilter2 = function(_super) {
    __extends(SiblingFilter3, _super);
    function SiblingFilter3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.byRecord = false;
      return _this;
    }
    SiblingFilter3.prototype.filter = function() {
      if (isMask(this.context)) {
        if (this.byRecord) {
          this.filterByRecord();
        } else {
          this.filterByBBox();
        }
      }
    };
    SiblingFilter3.prototype.filterByRecord = function() {
      var view = this.context.view;
      var maskElements = getMaskedElements(this.context, 10);
      if (!maskElements) {
        return;
      }
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      var records = maskElements.map(function(el) {
        return el.getModel().data;
      });
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var elements = getElements(sibling);
        each_default(elements, function(el) {
          var record = el.getModel().data;
          if (isInRecords(records, record, xFiled, yField)) {
            el.show();
          } else {
            el.hide();
          }
        });
      });
    };
    SiblingFilter3.prototype.filterByBBox = function() {
      var _this = this;
      var view = this.context.view;
      var siblings = getSilbings(view);
      each_default(siblings, function(sibling) {
        var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
        var elements = getElements(sibling);
        if (maskElements) {
          each_default(elements, function(el) {
            if (maskElements.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      });
    };
    SiblingFilter3.prototype.reset = function() {
      var siblings = getSilbings(this.context.view);
      each_default(siblings, function(sibling) {
        var elements = getElements(sibling);
        each_default(elements, function(el) {
          el.show();
        });
      });
    };
    return SiblingFilter3;
  }(base_default13);
  var sibling_filter_default2 = SiblingFilter2;

  // node_modules/@antv/g2/esm/interaction/action/view/button.js
  var PADDING_RIGHT = 10;
  var PADDING_TOP = 5;
  var ButtonAction = function(_super) {
    __extends(ButtonAction2, _super);
    function ButtonAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonGroup = null;
      _this.buttonCfg = {
        name: "button",
        text: "button",
        textStyle: {
          x: 0,
          y: 0,
          fontSize: 12,
          fill: "#333333",
          cursor: "pointer"
        },
        padding: [8, 10],
        style: {
          fill: "#f7f7f7",
          stroke: "#cccccc",
          cursor: "pointer"
        },
        activeStyle: {
          fill: "#e6e6e6"
        }
      };
      return _this;
    }
    ButtonAction2.prototype.getButtonCfg = function() {
      return deep_mix_default(this.buttonCfg, this.cfg);
    };
    ButtonAction2.prototype.drawButton = function() {
      var config = this.getButtonCfg();
      var group2 = this.context.view.foregroundGroup.addGroup({
        name: config.name
      });
      var textShape = group2.addShape({
        type: "text",
        name: "button-text",
        attrs: __assign({ text: config.text }, config.textStyle)
      });
      var textBBox = textShape.getBBox();
      var padding = parsePadding(config.padding);
      var buttonShape = group2.addShape({
        type: "rect",
        name: "button-rect",
        attrs: __assign({ x: textBBox.x - padding[3], y: textBBox.y - padding[0], width: textBBox.width + padding[1] + padding[3], height: textBBox.height + padding[0] + padding[2] }, config.style)
      });
      buttonShape.toBack();
      group2.on("mouseenter", function() {
        buttonShape.attr(config.activeStyle);
      });
      group2.on("mouseleave", function() {
        buttonShape.attr(config.style);
      });
      this.buttonGroup = group2;
    };
    ButtonAction2.prototype.resetPosition = function() {
      var view = this.context.view;
      var coord = view.getCoordinate();
      var point = coord.convert({ x: 1, y: 1 });
      var buttonGroup = this.buttonGroup;
      var bbox = buttonGroup.getBBox();
      var matrix = ext_exports.transform(null, [
        ["t", point.x - bbox.width - PADDING_RIGHT, point.y + bbox.height + PADDING_TOP]
      ]);
      buttonGroup.setMatrix(matrix);
    };
    ButtonAction2.prototype.show = function() {
      if (!this.buttonGroup) {
        this.drawButton();
      }
      this.resetPosition();
      this.buttonGroup.show();
    };
    ButtonAction2.prototype.hide = function() {
      if (this.buttonGroup) {
        this.buttonGroup.hide();
      }
    };
    ButtonAction2.prototype.destroy = function() {
      var buttonGroup = this.buttonGroup;
      if (buttonGroup) {
        buttonGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return ButtonAction2;
  }(base_default13);
  var button_default = ButtonAction;

  // node_modules/@antv/g2/esm/interaction/action/view/drag.js
  var DISTANCE = 4;
  var Drag = function(_super) {
    __extends(Drag2, _super);
    function Drag2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.dragStart = false;
      return _this;
    }
    Drag2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
    };
    Drag2.prototype.drag = function() {
      if (!this.startPoint) {
        return;
      }
      var current = this.context.getCurrentPoint();
      var view = this.context.view;
      var event = this.context.event;
      if (!this.dragStart) {
        if (distance6(current, this.startPoint) > DISTANCE) {
          view.emit("dragstart", {
            target: event.target,
            x: event.x,
            y: event.y
          });
          this.dragStart = true;
        }
      } else {
        view.emit("drag", {
          target: event.target,
          x: event.x,
          y: event.y
        });
      }
    };
    Drag2.prototype.end = function() {
      if (this.dragStart) {
        var view = this.context.view;
        var event_1 = this.context.event;
        view.emit("dragend", {
          target: event_1.target,
          x: event_1.x,
          y: event_1.y
        });
      }
      this.starting = false;
      this.dragStart = false;
    };
    return Drag2;
  }(base_default13);
  var drag_default = Drag;

  // node_modules/@antv/g2/esm/interaction/action/view/move.js
  var MIN_DISTANCE = 5;
  var Move = function(_super) {
    __extends(Move2, _super);
    function Move2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.isMoving = false;
      _this.startPoint = null;
      _this.startMatrix = null;
      return _this;
    }
    Move2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
      this.startMatrix = this.context.view.middleGroup.getMatrix();
    };
    Move2.prototype.move = function() {
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var currentPoint = this.context.getCurrentPoint();
      var d = distance6(startPoint, currentPoint);
      if (d > MIN_DISTANCE && !this.isMoving) {
        this.isMoving = true;
      }
      if (this.isMoving) {
        var view = this.context.view;
        var matrix = ext_exports.transform(this.startMatrix, [
          ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
        ]);
        view.backgroundGroup.setMatrix(matrix);
        view.foregroundGroup.setMatrix(matrix);
        view.middleGroup.setMatrix(matrix);
      }
    };
    Move2.prototype.end = function() {
      if (this.isMoving) {
        this.isMoving = false;
      }
      this.startMatrix = null;
      this.starting = false;
      this.startPoint = null;
    };
    Move2.prototype.reset = function() {
      this.starting = false;
      this.startPoint = null;
      this.isMoving = false;
      var view = this.context.view;
      view.backgroundGroup.resetMatrix();
      view.foregroundGroup.resetMatrix();
      view.middleGroup.resetMatrix();
      this.isMoving = false;
    };
    return Move2;
  }(base_default13);
  var move_default = Move;

  // node_modules/@antv/g2/esm/interaction/action/view/scale-transform.js
  var DIM_X = "x";
  var DIM_Y = "y";
  var ScaleTranslate = function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = [DIM_X, DIM_Y];
      _this.cfgFields = ["dims"];
      _this.cacheScaleDefs = {};
      return _this;
    }
    ScaleTranslate4.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    ScaleTranslate4.prototype.getScale = function(dim) {
      var view = this.context.view;
      if (dim === "x") {
        return view.getXScale();
      } else {
        return view.getYScales()[0];
      }
    };
    ScaleTranslate4.prototype.resetDim = function(dim) {
      var view = this.context.view;
      if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
        var scale5 = this.getScale(dim);
        view.scale(scale5.field, this.cacheScaleDefs[dim]);
        this.cacheScaleDefs[dim] = null;
      }
    };
    ScaleTranslate4.prototype.reset = function() {
      this.resetDim(DIM_X);
      this.resetDim(DIM_Y);
      var view = this.context.view;
      view.render(true);
    };
    return ScaleTranslate4;
  }(base_default13);
  var scale_transform_default = ScaleTranslate;

  // node_modules/@antv/g2/esm/interaction/action/view/scale-translate.js
  var ScaleTranslate2 = function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.starting = false;
      _this.startCache = {};
      return _this;
    }
    ScaleTranslate4.prototype.start = function() {
      var _this = this;
      this.startPoint = this.context.getCurrentPoint();
      this.starting = true;
      var dims = this.dims;
      each_default(dims, function(dim) {
        var scale5 = _this.getScale(dim);
        var min7 = scale5.min, max7 = scale5.max, values2 = scale5.values;
        _this.startCache[dim] = { min: min7, max: max7, values: values2 };
      });
    };
    ScaleTranslate4.prototype.end = function() {
      this.startPoint = null;
      this.starting = false;
      this.startCache = {};
    };
    ScaleTranslate4.prototype.translate = function() {
      var _this = this;
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var coord = this.context.view.getCoordinate();
      var currentPoint = this.context.getCurrentPoint();
      var normalStart = coord.invert(startPoint);
      var noramlCurrent = coord.invert(currentPoint);
      var dx = noramlCurrent.x - normalStart.x;
      var dy = noramlCurrent.y - normalStart.y;
      var view = this.context.view;
      var dims = this.dims;
      each_default(dims, function(dim) {
        _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
      });
      view.render(true);
    };
    ScaleTranslate4.prototype.translateDim = function(dim, normalPoint) {
      if (this.hasDim(dim)) {
        var scale5 = this.getScale(dim);
        if (scale5.isLinear) {
          this.translateLinear(dim, scale5, normalPoint);
        }
      }
    };
    ScaleTranslate4.prototype.translateLinear = function(dim, scale5, normalPoint) {
      var view = this.context.view;
      var _a4 = this.startCache[dim], min7 = _a4.min, max7 = _a4.max;
      var range5 = max7 - min7;
      var d = normalPoint[dim] * range5;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          nice: scale5.nice,
          min: min7,
          max: max7
        };
      }
      view.scale(scale5.field, {
        nice: false,
        min: min7 + d,
        max: max7 + d
      });
    };
    ScaleTranslate4.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.startPoint = null;
      this.starting = false;
    };
    return ScaleTranslate4;
  }(scale_transform_default);
  var scale_translate_default = ScaleTranslate2;

  // node_modules/@antv/g2/esm/interaction/action/view/scale-zoom.js
  var ScaleTranslate3 = function(_super) {
    __extends(ScaleTranslate4, _super);
    function ScaleTranslate4() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.zoomRatio = 0.05;
      return _this;
    }
    ScaleTranslate4.prototype.zoomIn = function() {
      this.zoom(this.zoomRatio);
    };
    ScaleTranslate4.prototype.zoom = function(scale5) {
      var _this = this;
      var dims = this.dims;
      each_default(dims, function(dim) {
        _this.zoomDim(dim, scale5);
      });
      this.context.view.render(true);
    };
    ScaleTranslate4.prototype.zoomOut = function() {
      this.zoom(-1 * this.zoomRatio);
    };
    ScaleTranslate4.prototype.zoomDim = function(dim, dRatio) {
      if (this.hasDim(dim)) {
        var scale5 = this.getScale(dim);
        if (scale5.isLinear) {
          this.zoomLinear(dim, scale5, dRatio);
        }
      }
    };
    ScaleTranslate4.prototype.zoomLinear = function(dim, scale5, dRatio) {
      var view = this.context.view;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          nice: scale5.nice,
          min: scale5.min,
          max: scale5.max
        };
      }
      var scaleDef = this.cacheScaleDefs[dim];
      var range5 = scaleDef.max - scaleDef.min;
      var min7 = scale5.min, max7 = scale5.max;
      var d = dRatio * range5;
      var toMin = min7 - d;
      var toMax = max7 + d;
      var curRange = toMax - toMin;
      var scaled = curRange / range5;
      if (toMax > toMin && scaled < 100 && scaled > 0.01) {
        view.scale(scale5.field, {
          nice: false,
          min: min7 - d,
          max: max7 + d
        });
      }
    };
    return ScaleTranslate4;
  }(scale_transform_default);
  var scale_zoom_default = ScaleTranslate3;

  // node_modules/@antv/g2/esm/interaction/action/view/mousewheel-scroll.js
  function isWheelDown(event) {
    var wheelEvent = event.gEvent.originalEvent;
    return wheelEvent.deltaY > 0;
  }
  var DEFAULT_WHEELDELTA = 1;
  var MousewheelScroll = function(_super) {
    __extends(MousewheelScroll2, _super);
    function MousewheelScroll2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MousewheelScroll2.prototype.scroll = function(arg) {
      var _a4 = this.context, view = _a4.view, event = _a4.event;
      if (!view.getOptions().scrollbar) {
        return;
      }
      var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
      var scrollbarController = view.getController("scrollbar");
      var xScale = view.getXScale();
      var data = view.getOptions().data;
      var dataSize = size2(values_of_key_default(data, xScale.field));
      var step4 = size2(xScale.values);
      var currentRatio = scrollbarController.getValue();
      var currentStart = Math.floor((dataSize - step4) * currentRatio);
      var nextStart = currentStart + (isWheelDown(event) ? wheelDelta : -wheelDelta);
      var correction = wheelDelta / (dataSize - step4) / 1e4;
      var nextRatio = clamp_default(nextStart / (dataSize - step4) + correction, 0, 1);
      scrollbarController.setValue(nextRatio);
    };
    return MousewheelScroll2;
  }(base_default13);
  var mousewheel_scroll_default = MousewheelScroll;

  // node_modules/@antv/g2/esm/index.js
  registerTheme("dark", createThemeByStyleSheet(antvDark));
  registerEngine("canvas", esm_exports);
  registerEngine("svg", esm_exports2);
  registerGeometry("Polygon", polygon_default6);
  registerGeometry("Interval", interval_default);
  registerGeometry("Schema", schema_default);
  registerGeometry("Path", path_default6);
  registerGeometry("Point", point_default);
  registerGeometry("Line", line_default10);
  registerGeometry("Area", area_default);
  registerGeometry("Edge", edge_default);
  registerGeometry("Heatmap", heatmap_default);
  registerGeometry("Violin", violin_default);
  registerGeometryLabel("base", base_default15);
  registerGeometryLabel("interval", interval_default2);
  registerGeometryLabel("pie", pie_default);
  registerGeometryLabel("polar", polar_default2);
  registerGeometryLabelLayout("overlap", overlap);
  registerGeometryLabelLayout("distribute", distribute);
  registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
  registerGeometryLabelLayout("hide-overlap", hideOverlap);
  registerGeometryLabelLayout("limit-in-shape", limitInShape);
  registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
  registerGeometryLabelLayout("limit-in-plot", limitInPlot);
  registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
  registerGeometryLabelLayout("adjust-color", adjustColor);
  registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
  registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
  registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
  registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
  registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
  registerAnimation("fade-in", fadeIn);
  registerAnimation("fade-out", fadeOut);
  registerAnimation("grow-in-x", growInX);
  registerAnimation("grow-in-xy", growInXY);
  registerAnimation("grow-in-y", growInY);
  registerAnimation("scale-in-x", scaleInX);
  registerAnimation("scale-in-y", scaleInY);
  registerAnimation("wave-in", waveIn);
  registerAnimation("zoom-in", zoomIn);
  registerAnimation("zoom-out", zoomOut);
  registerAnimation("position-update", positionUpdate);
  registerAnimation("sector-path-update", sectorPathUpdate);
  registerAnimation("path-in", pathIn);
  registerFacet("rect", rect_default5);
  registerFacet("mirror", mirror_default);
  registerFacet("list", list_default);
  registerFacet("matrix", matrix_default);
  registerFacet("circle", circle_default8);
  registerFacet("tree", tree_default);
  registerComponentController("axis", axis_default);
  registerComponentController("legend", legend_default);
  registerComponentController("tooltip", tooltip_default);
  registerComponentController("annotation", annotation_default);
  registerComponentController("slider", slider_default);
  registerComponentController("scrollbar", scrollbar_default);
  registerAction("tooltip", geometry_default);
  registerAction("sibling-tooltip", sibling_default);
  registerAction("ellipsis-text", ellipsis_text_default);
  registerAction("element-active", active_default);
  registerAction("element-single-active", single_active_default);
  registerAction("element-range-active", range_active_default);
  registerAction("element-highlight", highlight_default);
  registerAction("element-highlight-by-x", highlight_by_x_default);
  registerAction("element-highlight-by-color", highlight_by_color_default);
  registerAction("element-single-highlight", single_highlight_default);
  registerAction("element-range-highlight", range_highlight_default);
  registerAction("element-sibling-highlight", range_highlight_default, {
    effectSiblings: true,
    effectByRecord: true
  });
  registerAction("element-selected", selected_default);
  registerAction("element-single-selected", single_selected_default);
  registerAction("element-range-selected", range_selected_default);
  registerAction("element-link-by-color", link_by_color_default);
  registerAction("active-region", active_region_default);
  registerAction("list-active", list_active_default);
  registerAction("list-selected", list_selected_default);
  registerAction("list-highlight", list_highlight_default);
  registerAction("list-unchecked", list_unchecked_default);
  registerAction("list-checked", list_checked_default);
  registerAction("legend-item-highlight", list_highlight_default, {
    componentNames: ["legend"]
  });
  registerAction("axis-label-highlight", list_highlight_default, {
    componentNames: ["axis"]
  });
  registerAction("rect-mask", rect_default6);
  registerAction("x-rect-mask", dim_rect_default, { dim: "x" });
  registerAction("y-rect-mask", dim_rect_default, { dim: "y" });
  registerAction("circle-mask", circle_default9);
  registerAction("path-mask", path_default7);
  registerAction("smooth-path-mask", smooth_path_default);
  registerAction("cursor", cursor_default);
  registerAction("data-filter", filter_default2);
  registerAction("brush", range_filter_default);
  registerAction("brush-x", range_filter_default, { dims: ["x"] });
  registerAction("brush-y", range_filter_default, { dims: ["y"] });
  registerAction("sibling-filter", sibling_filter_default);
  registerAction("sibling-x-filter", sibling_filter_default);
  registerAction("sibling-y-filter", sibling_filter_default);
  registerAction("element-filter", filter_default3);
  registerAction("element-sibling-filter", sibling_filter_default2);
  registerAction("element-sibling-filter-record", sibling_filter_default2, { byRecord: true });
  registerAction("view-drag", drag_default);
  registerAction("view-move", move_default);
  registerAction("scale-translate", scale_translate_default);
  registerAction("scale-zoom", scale_zoom_default);
  registerAction("reset-button", button_default, {
    name: "reset-button",
    text: "reset"
  });
  registerAction("mousewheel-scroll", mousewheel_scroll_default);
  function isPointInView(context) {
    return context.isInPlot();
  }
  registerInteraction("tooltip", {
    start: [
      { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
      { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
    ],
    end: [
      { trigger: "plot:mouseleave", action: "tooltip:hide" },
      { trigger: "plot:leave", action: "tooltip:hide" },
      { trigger: "plot:touchend", action: "tooltip:hide" }
    ]
  });
  registerInteraction("ellipsis-text", {
    start: [
      {
        trigger: "legend-item-name:mousemove",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      },
      {
        trigger: "legend-item-name:touchstart",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      },
      {
        trigger: "axis-label:mousemove",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      },
      {
        trigger: "axis-label:touchstart",
        action: "ellipsis-text:show",
        throttle: { wait: 50, leading: true, trailing: false }
      }
    ],
    end: [
      { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
      { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
      { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
      { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
    ]
  });
  registerInteraction("element-active", {
    start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
    end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
  });
  registerInteraction("element-selected", {
    start: [{ trigger: "element:click", action: "element-selected:toggle" }]
  });
  registerInteraction("element-highlight", {
    start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
    end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
  });
  registerInteraction("element-highlight-by-x", {
    start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
    end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
  });
  registerInteraction("element-highlight-by-color", {
    start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
    end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
  });
  registerInteraction("legend-active", {
    start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
    end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
  });
  registerInteraction("legend-highlight", {
    start: [
      { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
    ],
    end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
  });
  registerInteraction("axis-label-highlight", {
    start: [
      { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
    ],
    end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
  });
  registerInteraction("element-list-highlight", {
    start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
    end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
  });
  registerInteraction("element-range-highlight", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "mask:mouseenter", action: "cursor:move" },
      { trigger: "plot:mouseleave", action: "cursor:default" },
      { trigger: "mask:mouseleave", action: "cursor:crosshair" }
    ],
    start: [
      {
        trigger: "plot:mousedown",
        isEnable: function(context) {
          return !context.isInShape("mask");
        },
        action: ["rect-mask:start", "rect-mask:show"]
      },
      {
        trigger: "mask:dragstart",
        action: ["rect-mask:moveStart"]
      }
    ],
    processing: [
      {
        trigger: "plot:mousemove",
        action: ["rect-mask:resize"]
      },
      {
        trigger: "mask:drag",
        action: ["rect-mask:move"]
      },
      {
        trigger: "mask:change",
        action: ["element-range-highlight:highlight"]
      }
    ],
    end: [
      { trigger: "plot:mouseup", action: ["rect-mask:end"] },
      { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
      {
        trigger: "document:mouseup",
        isEnable: function(context) {
          return !context.isInPlot();
        },
        action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
      }
    ],
    rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
  });
  registerInteraction("brush", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      {
        trigger: "mousedown",
        isEnable: isPointInView,
        action: ["brush:start", "rect-mask:start", "rect-mask:show"]
      }
    ],
    processing: [
      {
        trigger: "mousemove",
        isEnable: isPointInView,
        action: ["rect-mask:resize"]
      }
    ],
    end: [
      {
        trigger: "mouseup",
        isEnable: isPointInView,
        action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
      }
    ],
    rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
  });
  registerInteraction("brush-visible", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      {
        trigger: "plot:mousedown",
        action: ["rect-mask:start", "rect-mask:show"]
      }
    ],
    processing: [
      {
        trigger: "plot:mousemove",
        action: ["rect-mask:resize"]
      },
      { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
    ],
    end: [
      {
        trigger: "plot:mouseup",
        action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
      }
    ],
    rollback: [
      {
        trigger: "dblclick",
        action: ["element-filter:clear"]
      }
    ]
  });
  registerInteraction("brush-x", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      {
        trigger: "mousedown",
        isEnable: isPointInView,
        action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
      }
    ],
    processing: [
      {
        trigger: "mousemove",
        isEnable: isPointInView,
        action: ["x-rect-mask:resize"]
      }
    ],
    end: [
      {
        trigger: "mouseup",
        isEnable: isPointInView,
        action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
      }
    ],
    rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
  });
  registerInteraction("element-path-highlight", {
    showEnable: [
      { trigger: "plot:mouseenter", action: "cursor:crosshair" },
      { trigger: "plot:mouseleave", action: "cursor:default" }
    ],
    start: [
      { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:start" },
      { trigger: "mousedown", isEnable: isPointInView, action: "path-mask:show" }
    ],
    processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
    end: [{ trigger: "mouseup", action: "path-mask:end" }],
    rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
  });
  registerInteraction("element-single-selected", {
    start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
  });
  registerInteraction("legend-filter", {
    showEnable: [
      { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
      { trigger: "legend-item:mouseleave", action: "cursor:default" }
    ],
    start: [{ trigger: "legend-item:click", action: ["list-unchecked:toggle", "data-filter:filter"] }]
  });
  registerInteraction("continuous-filter", {
    start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
  });
  registerInteraction("continuous-visible-filter", {
    start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
  });
  registerInteraction("legend-visible-filter", {
    showEnable: [
      { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
      { trigger: "legend-item:mouseleave", action: "cursor:default" }
    ],
    start: [{ trigger: "legend-item:click", action: ["list-unchecked:toggle", "element-filter:filter"] }]
  });
  registerInteraction("active-region", {
    start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
    end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
  });
  function isWheelDown2(event) {
    event.gEvent.preventDefault();
    return event.gEvent.originalEvent.deltaY > 0;
  }
  registerInteraction("view-zoom", {
    start: [
      {
        trigger: "plot:mousewheel",
        isEnable: function(context) {
          return isWheelDown2(context.event);
        },
        action: "scale-zoom:zoomOut",
        throttle: { wait: 100, leading: true, trailing: false }
      },
      {
        trigger: "plot:mousewheel",
        isEnable: function(context) {
          return !isWheelDown2(context.event);
        },
        action: "scale-zoom:zoomIn",
        throttle: { wait: 100, leading: true, trailing: false }
      }
    ]
  });
  registerInteraction("sibling-tooltip", {
    start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
    end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
  });
  registerInteraction("plot-mousewheel-scroll", {
    start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
  });

  // hw3/client/dev/utils.ts
  var parserVector = (tsv) => {
    return tsv.split("\n").map((v) => v.split("	").map((x) => Number(x)));
  };
  var parserMetadata = (tsv) => {
    return tsv.split("\n");
  };
  var levenshteinDistance3 = (source, target) => {
    let distances = [
      [
        0,
        ...Array(target.length).fill(0).map((_6, idx) => idx + 1)
      ]
    ];
    for (let [i, c1] of source.split("").entries()) {
      distances.push([i + 1]);
      for (let [j, c2] of target.split("").entries()) {
        let ins = distances[i + 1][j] + 1;
        let del = distances[i][j + 1] + 1;
        let sub7 = distances[i][j] + (c1 == c2 ? 0 : 1);
        distances[i + 1].push(Math.min(ins, del, sub7));
      }
    }
    return distances?.at(-1)?.at(-1) ?? NaN;
  };

  // node_modules/@tensorflow/tfjs-core/dist/backends/backend.js
  var EPSILON_FLOAT32 = 1e-7;
  var EPSILON_FLOAT16 = 1e-4;
  var DataStorage = class {
    constructor(backend2, dataMover) {
      this.backend = backend2;
      this.dataMover = dataMover;
      this.data = new WeakMap();
      this.dataIdsCount = 0;
    }
    get(dataId) {
      if (!this.data.has(dataId)) {
        this.dataMover.moveData(this.backend, dataId);
      }
      return this.data.get(dataId);
    }
    set(dataId, value) {
      this.dataIdsCount++;
      this.data.set(dataId, value);
    }
    has(dataId) {
      return this.data.has(dataId);
    }
    delete(dataId) {
      this.dataIdsCount--;
      return this.data.delete(dataId);
    }
    numDataIds() {
      return this.dataIdsCount;
    }
  };
  var KernelBackend = class {
    refCount(dataId) {
      return notYetImplemented("refCount");
    }
    incRef(dataId) {
      return notYetImplemented("incRef");
    }
    timerAvailable() {
      return true;
    }
    time(f) {
      return notYetImplemented("time");
    }
    read(dataId) {
      return notYetImplemented("read");
    }
    readSync(dataId) {
      return notYetImplemented("readSync");
    }
    numDataIds() {
      return notYetImplemented("numDataIds");
    }
    disposeData(dataId, force) {
      return notYetImplemented("disposeData");
    }
    write(values2, shape, dtype) {
      return notYetImplemented("write");
    }
    move(dataId, values2, shape, dtype, refCount) {
      return notYetImplemented("move");
    }
    memory() {
      return notYetImplemented("memory");
    }
    floatPrecision() {
      return notYetImplemented("floatPrecision");
    }
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
    }
    dispose() {
      return notYetImplemented("dispose");
    }
  };
  function notYetImplemented(kernelName) {
    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
  }

  // node_modules/@tensorflow/tfjs-core/dist/util_base.js
  function shuffle(array2) {
    let counter = array2.length;
    let index = 0;
    while (counter > 0) {
      index = Math.random() * counter | 0;
      counter--;
      swap(array2, counter, index);
    }
  }
  function shuffleCombo(array2, array22) {
    if (array2.length !== array22.length) {
      throw new Error(`Array sizes must match to be shuffled together First array length was ${array2.length}Second array length was ${array22.length}`);
    }
    let counter = array2.length;
    let index = 0;
    while (counter > 0) {
      index = Math.random() * counter | 0;
      counter--;
      swap(array2, counter, index);
      swap(array22, counter, index);
    }
  }
  function clamp2(min7, x, max7) {
    return Math.max(min7, Math.min(x, max7));
  }
  function nearestLargerEven(val) {
    return val % 2 === 0 ? val : val + 1;
  }
  function swap(object, left, right) {
    const temp = object[left];
    object[left] = object[right];
    object[right] = temp;
  }
  function sum(arr) {
    let sum5 = 0;
    for (let i = 0; i < arr.length; i++) {
      sum5 += arr[i];
    }
    return sum5;
  }
  function randUniform(a, b) {
    const r = Math.random();
    return b * r + (1 - r) * a;
  }
  function distSquared(a, b) {
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      const diff2 = Number(a[i]) - Number(b[i]);
      result += diff2 * diff2;
    }
    return result;
  }
  function assert(expr, msg) {
    if (!expr) {
      throw new Error(typeof msg === "string" ? msg : msg());
    }
  }
  function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
    assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  }
  function assertNonNull(a) {
    assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
  }
  function flatten2(arr, result = [], skipTypedArray = false) {
    if (result == null) {
      result = [];
    }
    if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {
      for (let i = 0; i < arr.length; ++i) {
        flatten2(arr[i], result, skipTypedArray);
      }
    } else {
      result.push(arr);
    }
    return result;
  }
  function sizeFromShape(shape) {
    if (shape.length === 0) {
      return 1;
    }
    let size3 = shape[0];
    for (let i = 1; i < shape.length; i++) {
      size3 *= shape[i];
    }
    return size3;
  }
  function isScalarShape(shape) {
    return shape.length === 0;
  }
  function arraysEqual(n1, n2) {
    if (n1 === n2) {
      return true;
    }
    if (n1 == null || n2 == null) {
      return false;
    }
    if (n1.length !== n2.length) {
      return false;
    }
    for (let i = 0; i < n1.length; i++) {
      if (n1[i] !== n2[i]) {
        return false;
      }
    }
    return true;
  }
  function isInt(a) {
    return a % 1 === 0;
  }
  function tanh(x) {
    if (Math.tanh != null) {
      return Math.tanh(x);
    }
    if (x === Infinity) {
      return 1;
    } else if (x === -Infinity) {
      return -1;
    } else {
      const e2x = Math.exp(2 * x);
      return (e2x - 1) / (e2x + 1);
    }
  }
  function sizeToSquarishShape(size3) {
    const width = Math.ceil(Math.sqrt(size3));
    return [width, Math.ceil(size3 / width)];
  }
  function createShuffledIndices(n) {
    const shuffledIndices = new Uint32Array(n);
    for (let i = 0; i < n; ++i) {
      shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
  }
  function rightPad(a, size3) {
    if (size3 <= a.length) {
      return a;
    }
    return a + " ".repeat(size3 - a.length);
  }
  function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter) {
    return new Promise((resolve, reject) => {
      let tryCount = 0;
      const tryFn = () => {
        if (checkFn()) {
          resolve();
          return;
        }
        tryCount++;
        const nextBackoff = delayFn(tryCount);
        if (maxCounter != null && tryCount >= maxCounter) {
          reject();
          return;
        }
        setTimeout(tryFn, nextBackoff);
      };
      tryFn();
    });
  }
  function inferFromImplicitShape(shape, size3) {
    let shapeProd = 1;
    let implicitIdx = -1;
    for (let i = 0; i < shape.length; ++i) {
      if (shape[i] >= 0) {
        shapeProd *= shape[i];
      } else if (shape[i] === -1) {
        if (implicitIdx !== -1) {
          throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);
        }
        implicitIdx = i;
      } else if (shape[i] < 0) {
        throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
      }
    }
    if (implicitIdx === -1) {
      if (size3 > 0 && size3 !== shapeProd) {
        throw Error(`Size(${size3}) must match the product of shape ${shape}`);
      }
      return shape;
    }
    if (shapeProd === 0) {
      throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
    }
    if (size3 % shapeProd !== 0) {
      throw Error(`The implicit shape can't be a fractional number. Got ${size3} / ${shapeProd}`);
    }
    const newShape = shape.slice();
    newShape[implicitIdx] = size3 / shapeProd;
    return newShape;
  }
  function parseAxisParam(axis, shape) {
    const rank = shape.length;
    axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
    assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
    assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
    return axis.map((a) => a < 0 ? rank + a : a);
  }
  function squeezeShape(shape, axis) {
    const newShape = [];
    const keptDims = [];
    const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
    const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
    let j = 0;
    for (let i = 0; i < shape.length; ++i) {
      if (axes != null) {
        if (axes[j] === i && shape[i] !== 1) {
          throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
        }
        if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
          newShape.push(shape[i]);
          keptDims.push(i);
        }
        if (axes[j] <= i) {
          j++;
        }
      }
      if (shape[i] !== 1) {
        newShape.push(shape[i]);
        keptDims.push(i);
      }
    }
    return { newShape, keptDims };
  }
  function getTypedArrayFromDType(dtype, size3) {
    let values2 = null;
    if (dtype == null || dtype === "float32") {
      values2 = new Float32Array(size3);
    } else if (dtype === "int32") {
      values2 = new Int32Array(size3);
    } else if (dtype === "bool") {
      values2 = new Uint8Array(size3);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    return values2;
  }
  function getArrayFromDType(dtype, size3) {
    let values2 = null;
    if (dtype == null || dtype === "float32") {
      values2 = new Float32Array(size3);
    } else if (dtype === "int32") {
      values2 = new Int32Array(size3);
    } else if (dtype === "bool") {
      values2 = new Uint8Array(size3);
    } else if (dtype === "string") {
      values2 = new Array(size3);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
    return values2;
  }
  function checkConversionForErrors(vals, dtype) {
    for (let i = 0; i < vals.length; i++) {
      const num = vals[i];
      if (isNaN(num) || !isFinite(num)) {
        throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
      }
    }
  }
  function isValidDtype(dtype) {
    return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
  }
  function hasEncodingLoss(oldType, newType) {
    if (newType === "complex64") {
      return false;
    }
    if (newType === "float32" && oldType !== "complex64") {
      return false;
    }
    if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
      return false;
    }
    if (newType === "bool" && oldType === "bool") {
      return false;
    }
    return true;
  }
  function isTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array || a instanceof Uint8ClampedArray;
  }
  function bytesPerElement(dtype) {
    if (dtype === "float32" || dtype === "int32") {
      return 4;
    } else if (dtype === "complex64") {
      return 8;
    } else if (dtype === "bool") {
      return 1;
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }
  function bytesFromStringArray(arr) {
    if (arr == null) {
      return 0;
    }
    let bytes = 0;
    arr.forEach((x) => bytes += x.length);
    return bytes;
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isBoolean3(value) {
    return typeof value === "boolean";
  }
  function isNumber3(value) {
    return typeof value === "number";
  }
  function inferDtype(values2) {
    if (Array.isArray(values2)) {
      return inferDtype(values2[0]);
    }
    if (values2 instanceof Float32Array) {
      return "float32";
    } else if (values2 instanceof Int32Array || values2 instanceof Uint8Array || values2 instanceof Uint8ClampedArray) {
      return "int32";
    } else if (isNumber3(values2)) {
      return "float32";
    } else if (isString2(values2)) {
      return "string";
    } else if (isBoolean3(values2)) {
      return "bool";
    }
    return "float32";
  }
  function isFunction2(f) {
    return !!(f && f.constructor && f.call && f.apply);
  }
  function nearestDivisor(size3, start) {
    for (let i = start; i < size3; ++i) {
      if (size3 % i === 0) {
        return i;
      }
    }
    return size3;
  }
  function computeStrides(shape) {
    const rank = shape.length;
    if (rank < 2) {
      return [];
    }
    const strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (let i = rank - 3; i >= 0; --i) {
      strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
  }
  function createNestedArray(offset, shape, a, isComplex = false) {
    const ret = new Array();
    if (shape.length === 1) {
      const d = shape[0] * (isComplex ? 2 : 1);
      for (let i = 0; i < d; i++) {
        ret[i] = a[offset + i];
      }
    } else {
      const d = shape[0];
      const rest = shape.slice(1);
      const len3 = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
      for (let i = 0; i < d; i++) {
        ret[i] = createNestedArray(offset + i * len3, rest, a, isComplex);
      }
    }
    return ret;
  }
  function toNestedArray(shape, a, isComplex = false) {
    if (shape.length === 0) {
      return a[0];
    }
    const size3 = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
    if (size3 === 0) {
      return [];
    }
    if (size3 !== a.length) {
      throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? " for a complex tensor" : ""}.`);
    }
    return createNestedArray(0, shape, a, isComplex);
  }
  function makeOnesTypedArray(size3, dtype) {
    const array2 = makeZerosTypedArray(size3, dtype);
    for (let i = 0; i < array2.length; i++) {
      array2[i] = 1;
    }
    return array2;
  }
  function makeZerosTypedArray(size3, dtype) {
    if (dtype == null || dtype === "float32" || dtype === "complex64") {
      return new Float32Array(size3);
    } else if (dtype === "int32") {
      return new Int32Array(size3);
    } else if (dtype === "bool") {
      return new Uint8Array(size3);
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function makeZerosNestedTypedArray(shape, dtype) {
    const size3 = shape.reduce((prev, curr) => prev * curr, 1);
    if (dtype == null || dtype === "float32") {
      return toNestedArray(shape, new Float32Array(size3));
    } else if (dtype === "int32") {
      return toNestedArray(shape, new Int32Array(size3));
    } else if (dtype === "bool") {
      return toNestedArray(shape, new Uint8Array(size3));
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function assertNonNegativeIntegerDimensions(shape) {
    shape.forEach((dimSize) => {
      assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
    });
  }
  function locToIndex(locs, rank, strides) {
    if (rank === 0) {
      return 0;
    } else if (rank === 1) {
      return locs[0];
    }
    let index = locs[locs.length - 1];
    for (let i = 0; i < locs.length - 1; ++i) {
      index += strides[i] * locs[i];
    }
    return index;
  }
  function indexToLoc(index, rank, strides) {
    if (rank === 0) {
      return [];
    } else if (rank === 1) {
      return [index];
    }
    const locs = new Array(rank);
    for (let i = 0; i < locs.length - 1; ++i) {
      locs[i] = Math.floor(index / strides[i]);
      index -= locs[i] * strides[i];
    }
    locs[locs.length - 1] = index;
    return locs;
  }
  function isPromise2(object) {
    return object && object.then && typeof object.then === "function";
  }

  // node_modules/@tensorflow/tfjs-core/dist/log.js
  function warn3(...msg) {
    if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
      console.warn(...msg);
    }
  }
  function log2(...msg) {
    if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
      console.log(...msg);
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/environment.js
  var TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
  var Environment = class {
    constructor(global2) {
      this.global = global2;
      this.flags = {};
      this.flagRegistry = {};
      this.urlFlags = {};
      this.getQueryParams = getQueryParams;
      this.populateURLFlags();
    }
    setPlatform(platformName, platform) {
      if (this.platform != null) {
        warn3(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platform}.`);
      }
      this.platformName = platformName;
      this.platform = platform;
    }
    registerFlag(flagName, evaluationFn, setHook) {
      this.flagRegistry[flagName] = { evaluationFn, setHook };
      if (this.urlFlags[flagName] != null) {
        const flagValue = this.urlFlags[flagName];
        warn3(`Setting feature override from URL ${flagName}: ${flagValue}.`);
        this.set(flagName, flagValue);
      }
    }
    async getAsync(flagName) {
      if (flagName in this.flags) {
        return this.flags[flagName];
      }
      this.flags[flagName] = await this.evaluateFlag(flagName);
      return this.flags[flagName];
    }
    get(flagName) {
      if (flagName in this.flags) {
        return this.flags[flagName];
      }
      const flagValue = this.evaluateFlag(flagName);
      if (isPromise2(flagValue)) {
        throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
      }
      this.flags[flagName] = flagValue;
      return this.flags[flagName];
    }
    getNumber(flagName) {
      return this.get(flagName);
    }
    getBool(flagName) {
      return this.get(flagName);
    }
    getFlags() {
      return this.flags;
    }
    get features() {
      return this.flags;
    }
    set(flagName, value) {
      if (this.flagRegistry[flagName] == null) {
        throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
      }
      this.flags[flagName] = value;
      if (this.flagRegistry[flagName].setHook != null) {
        this.flagRegistry[flagName].setHook(value);
      }
    }
    evaluateFlag(flagName) {
      if (this.flagRegistry[flagName] == null) {
        throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
      }
      return this.flagRegistry[flagName].evaluationFn();
    }
    setFlags(flags) {
      this.flags = Object.assign({}, flags);
    }
    reset() {
      this.flags = {};
      this.urlFlags = {};
      this.populateURLFlags();
    }
    populateURLFlags() {
      if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
        return;
      }
      const urlParams = this.getQueryParams(this.global.location.search);
      if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
        const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
        keyValues.forEach((keyValue) => {
          const [key, value] = keyValue.split(":");
          this.urlFlags[key] = parseValue2(key, value);
        });
      }
    }
  };
  function getQueryParams(queryString) {
    const params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
      decodeParam(params, t[0], t[1]);
      return t.join("=");
    });
    return params;
  }
  function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || "");
  }
  function parseValue2(flagName, value) {
    value = value.toLowerCase();
    if (value === "true" || value === "false") {
      return value === "true";
    } else if (`${+value}` === value) {
      return +value;
    }
    throw new Error(`Could not parse value flag value ${value} for flag ${flagName}.`);
  }
  function env() {
    return ENV;
  }
  var ENV = null;
  function setEnvironmentGlobal(environment) {
    ENV = environment;
  }

  // node_modules/@tensorflow/tfjs-core/dist/global_util.js
  var globalNameSpace;
  function getGlobalNamespace() {
    if (globalNameSpace == null) {
      let ns;
      if (typeof window !== "undefined") {
        ns = window;
      } else if (typeof global !== "undefined") {
        ns = global;
      } else if (typeof process !== "undefined") {
        ns = process;
      } else if (typeof self !== "undefined") {
        ns = self;
      } else {
        throw new Error("Could not find a global object");
      }
      globalNameSpace = ns;
    }
    return globalNameSpace;
  }
  function getGlobalMap() {
    const ns = getGlobalNamespace();
    if (ns._tfGlobals == null) {
      ns._tfGlobals = new Map();
    }
    return ns._tfGlobals;
  }
  function getGlobal(key, init) {
    const globalMap = getGlobalMap();
    if (globalMap.has(key)) {
      return globalMap.get(key);
    } else {
      const singleton = init();
      globalMap.set(key, singleton);
      return globalMap.get(key);
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/kernel_names.js
  var Abs = "Abs";
  var Acos = "Acos";
  var Acosh = "Acosh";
  var Add = "Add";
  var AddN = "AddN";
  var All = "All";
  var Any = "Any";
  var ArgMax = "ArgMax";
  var ArgMin = "ArgMin";
  var Asin = "Asin";
  var Asinh = "Asinh";
  var Atan = "Atan";
  var Atanh = "Atanh";
  var Atan2 = "Atan2";
  var AvgPool = "AvgPool";
  var AvgPoolGrad = "AvgPoolGrad";
  var AvgPool3D = "AvgPool3D";
  var AvgPool3DGrad = "AvgPool3DGrad";
  var BatchMatMul = "BatchMatMul";
  var BatchToSpaceND = "BatchToSpaceND";
  var Bincount = "Bincount";
  var BroadcastTo = "BroadcastTo";
  var BroadcastArgs = "BroadcastArgs";
  var Cast = "Cast";
  var Ceil = "Ceil";
  var ClipByValue = "ClipByValue";
  var Complex = "Complex";
  var ComplexAbs = "ComplexAbs";
  var Concat = "Concat";
  var Conv2D = "Conv2D";
  var Conv2DBackpropFilter = "Conv2DBackpropFilter";
  var Conv2DBackpropInput = "Conv2DBackpropInput";
  var Conv3D = "Conv3D";
  var Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
  var Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
  var Cos = "Cos";
  var Cosh = "Cosh";
  var Cumsum = "Cumsum";
  var CropAndResize = "CropAndResize";
  var DenseBincount = "DenseBincount";
  var DepthToSpace = "DepthToSpace";
  var DepthwiseConv2dNative = "DepthwiseConv2dNative";
  var DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
  var DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
  var Diag = "Diag";
  var Dilation2D = "Dilation2D";
  var Dilation2DBackpropInput = "Dilation2DBackpropInput";
  var Dilation2DBackpropFilter = "Dilation2DBackpropFilter";
  var RealDiv = "RealDiv";
  var Einsum = "Einsum";
  var Elu = "Elu";
  var EluGrad = "EluGrad";
  var Erf = "Erf";
  var Equal = "Equal";
  var Exp = "Exp";
  var ExpandDims = "ExpandDims";
  var Expm1 = "Expm1";
  var FFT = "FFT";
  var Fill = "Fill";
  var FlipLeftRight = "FlipLeftRight";
  var Floor = "Floor";
  var FloorDiv = "FloorDiv";
  var FusedBatchNorm = "FusedBatchNorm";
  var GatherV2 = "GatherV2";
  var GatherNd = "GatherNd";
  var Greater = "Greater";
  var GreaterEqual = "GreaterEqual";
  var Identity2 = "Identity";
  var IFFT = "IFFT";
  var Imag = "Imag";
  var IsFinite = "IsFinite";
  var IsInf = "IsInf";
  var IsNan = "IsNan";
  var LeakyRelu = "LeakyRelu";
  var Less = "Less";
  var LessEqual = "LessEqual";
  var LinSpace = "LinSpace";
  var Log2 = "Log";
  var Log1p = "Log1p";
  var LogicalAnd = "LogicalAnd";
  var LogicalNot = "LogicalNot";
  var LogicalOr = "LogicalOr";
  var LogSoftmax = "LogSoftmax";
  var LRN = "LRN";
  var LRNGrad = "LRNGrad";
  var Max = "Max";
  var Maximum = "Maximum";
  var MaxPool = "MaxPool";
  var MaxPoolGrad = "MaxPoolGrad";
  var MaxPool3D = "MaxPool3D";
  var MaxPool3DGrad = "MaxPool3DGrad";
  var MaxPoolWithArgmax = "MaxPoolWithArgmax";
  var Mean = "Mean";
  var Min = "Min";
  var Minimum = "Minimum";
  var MirrorPad = "MirrorPad";
  var Mod = "Mod";
  var Multinomial = "Multinomial";
  var Multiply = "Multiply";
  var Neg = "Neg";
  var NotEqual = "NotEqual";
  var NonMaxSuppressionV3 = "NonMaxSuppressionV3";
  var NonMaxSuppressionV4 = "NonMaxSuppressionV4";
  var NonMaxSuppressionV5 = "NonMaxSuppressionV5";
  var OnesLike = "OnesLike";
  var OneHot = "OneHot";
  var Pack = "Pack";
  var PadV2 = "PadV2";
  var Pow2 = "Pow";
  var Prelu = "Prelu";
  var Prod = "Prod";
  var Range = "Range";
  var Real = "Real";
  var Reciprocal = "Reciprocal";
  var Relu = "Relu";
  var Reshape = "Reshape";
  var ResizeNearestNeighbor = "ResizeNearestNeighbor";
  var ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
  var ResizeBilinear = "ResizeBilinear";
  var ResizeBilinearGrad = "ResizeBilinearGrad";
  var Relu6 = "Relu6";
  var Reverse = "Reverse";
  var Round = "Round";
  var Rsqrt = "Rsqrt";
  var ScatterNd = "ScatterNd";
  var Select = "Select";
  var Selu = "Selu";
  var Slice = "Slice";
  var Sin = "Sin";
  var Sinh = "Sinh";
  var Sign = "Sign";
  var Sigmoid = "Sigmoid";
  var Softplus = "Softplus";
  var Sqrt = "Sqrt";
  var Sum = "Sum";
  var SpaceToBatchND = "SpaceToBatchND";
  var SplitV = "SplitV";
  var Softmax = "Softmax";
  var SparseFillEmptyRows = "SparseFillEmptyRows";
  var SparseReshape = "SparseReshape";
  var SparseSegmentMean = "SparseSegmentMean";
  var SparseSegmentSum = "SparseSegmentSum";
  var SparseToDense = "SparseToDense";
  var SquaredDifference = "SquaredDifference";
  var Square = "Square";
  var StridedSlice = "StridedSlice";
  var StringNGrams = "StringNGrams";
  var StringSplit = "StringSplit";
  var StringToHashBucketFast = "StringToHashBucketFast";
  var Sub = "Sub";
  var Tan = "Tan";
  var Tanh = "Tanh";
  var Tile = "Tile";
  var TopK = "TopK";
  var Transform = "Transform";
  var Transpose = "Transpose";
  var Unique = "Unique";
  var Unpack = "Unpack";
  var UnsortedSegmentSum = "UnsortedSegmentSum";
  var ZerosLike = "ZerosLike";
  var Step = "Step";
  var FromPixels = "FromPixels";
  var RotateWithOffset = "RotateWithOffset";
  var _FusedMatMul = "_FusedMatMul";
  var FusedConv2D = "FusedConv2D";
  var FusedDepthwiseConv2D = "FusedDepthwiseConv2D";

  // node_modules/@tensorflow/tfjs-core/dist/kernel_registry.js
  var kernelRegistry = getGlobal("kernelRegistry", () => new Map());
  var gradRegistry = getGlobal("gradRegistry", () => new Map());
  function getKernel(kernelName, backendName) {
    const key = makeKey(kernelName, backendName);
    return kernelRegistry.get(key);
  }
  function getGradient(kernelName) {
    return gradRegistry.get(kernelName);
  }
  function getKernelsForBackend(backendName) {
    const it = kernelRegistry.entries();
    const result = [];
    while (true) {
      const { done, value } = it.next();
      if (done) {
        break;
      }
      const [key, config] = value;
      const [backend2] = key.split("_");
      if (backend2 === backendName) {
        result.push(config);
      }
    }
    return result;
  }
  function registerKernel(config) {
    const { kernelName, backendName } = config;
    const key = makeKey(kernelName, backendName);
    if (kernelRegistry.has(key)) {
      warn3(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
    }
    kernelRegistry.set(key, config);
  }
  function registerGradient(config) {
    const { kernelName } = config;
    if (gradRegistry.has(kernelName)) {
      if (env().getBool("DEBUG")) {
        warn3(`Overriding the gradient for '${kernelName}'`);
      }
    }
    gradRegistry.set(kernelName, config);
  }
  function makeKey(kernelName, backendName) {
    return `${backendName}_${kernelName}`;
  }

  // node_modules/@tensorflow/tfjs-core/dist/util.js
  var util_exports2 = {};
  __export(util_exports2, {
    arraysEqual: () => arraysEqual,
    assert: () => assert,
    assertNonNegativeIntegerDimensions: () => assertNonNegativeIntegerDimensions,
    assertNonNull: () => assertNonNull,
    assertShapesMatch: () => assertShapesMatch,
    bytesFromStringArray: () => bytesFromStringArray,
    bytesPerElement: () => bytesPerElement,
    checkConversionForErrors: () => checkConversionForErrors,
    clamp: () => clamp2,
    computeStrides: () => computeStrides,
    createScalarValue: () => createScalarValue,
    createShuffledIndices: () => createShuffledIndices,
    decodeString: () => decodeString,
    distSquared: () => distSquared,
    encodeString: () => encodeString,
    fetch: () => fetch3,
    fingerPrint64: () => fingerPrint64,
    flatten: () => flatten2,
    getArrayFromDType: () => getArrayFromDType,
    getTypedArrayFromDType: () => getTypedArrayFromDType,
    hasEncodingLoss: () => hasEncodingLoss,
    hexToLong: () => hexToLong,
    indexToLoc: () => indexToLoc,
    inferDtype: () => inferDtype,
    inferFromImplicitShape: () => inferFromImplicitShape,
    isBoolean: () => isBoolean3,
    isFunction: () => isFunction2,
    isInt: () => isInt,
    isNumber: () => isNumber3,
    isPromise: () => isPromise2,
    isScalarShape: () => isScalarShape,
    isString: () => isString2,
    isTypedArray: () => isTypedArray,
    isValidDtype: () => isValidDtype,
    locToIndex: () => locToIndex,
    makeOnesTypedArray: () => makeOnesTypedArray,
    makeZerosNestedTypedArray: () => makeZerosNestedTypedArray,
    makeZerosTypedArray: () => makeZerosTypedArray,
    nearestDivisor: () => nearestDivisor,
    nearestLargerEven: () => nearestLargerEven,
    now: () => now2,
    parseAxisParam: () => parseAxisParam,
    randUniform: () => randUniform,
    repeatedTry: () => repeatedTry,
    rightPad: () => rightPad,
    shuffle: () => shuffle,
    shuffleCombo: () => shuffleCombo,
    sizeFromShape: () => sizeFromShape,
    sizeToSquarishShape: () => sizeToSquarishShape,
    squeezeShape: () => squeezeShape,
    sum: () => sum,
    swap: () => swap,
    tanh: () => tanh,
    toNestedArray: () => toNestedArray,
    toTypedArray: () => toTypedArray
  });

  // node_modules/@tensorflow/tfjs-core/dist/hash_util.js
  var LongExports = __toModule(require_long());
  var Long = LongExports.default || LongExports;
  function hexToLong(hex2) {
    return Long.fromString(hex2, true, 16);
  }
  var k0 = hexToLong("c3a5c85c97cb3127");
  var k1 = hexToLong("b492b66fbe98f273");
  var k2 = hexToLong("9ae16a3b2f90404f");
  function shiftMix(val) {
    return val.xor(val.shru(47));
  }
  function fetch2(s, offset, numBytes) {
    const bytes = s.slice(offset, offset + numBytes);
    return Long.fromBytes(Array.from(bytes), true, true);
  }
  function fetch64(s, offset) {
    return fetch2(s, offset, 8);
  }
  function fetch32(s, offset) {
    return fetch2(s, offset, 4);
  }
  function rotate64(val, shift) {
    return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
  }
  function hashLen16(u, v, mul5 = hexToLong("9ddfea08eb382d69")) {
    let a = u.xor(v).mul(mul5);
    a = a.xor(a.shru(47));
    let b = v.xor(a).mul(mul5);
    b = b.xor(b.shru(47));
    b = b.mul(mul5);
    return b;
  }
  function weakHashLen32WithSeeds(w, x, y, z, a, b) {
    a = a.add(w);
    b = rotate64(b.add(a).add(z), 21);
    const c = a;
    a = a.add(x);
    a = a.add(y);
    b = b.add(rotate64(a, 44));
    return [a.add(z), b.add(c)];
  }
  function weakHashLen32WithSeedsStr(s, offset, a, b) {
    return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);
  }
  function hashLen0to16(s, len3 = s.length) {
    if (len3 >= 8) {
      const mul5 = k2.add(len3 * 2);
      const a = fetch64(s, 0).add(k2);
      const b = fetch64(s, len3 - 8);
      const c = rotate64(b, 37).mul(mul5).add(a);
      const d = rotate64(a, 25).add(b).mul(mul5);
      return hashLen16(c, d, mul5);
    }
    if (len3 >= 4) {
      const mul5 = k2.add(len3 * 2);
      const a = fetch32(s, 0);
      return hashLen16(a.shl(3).add(len3), fetch32(s, len3 - 4), mul5);
    }
    if (len3 > 0) {
      const a = s[0];
      const b = s[len3 >> 1];
      const c = s[len3 - 1];
      const y = a + (b << 8);
      const z = len3 + (c << 2);
      return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);
    }
    return k2;
  }
  function hashLen17to32(s, len3 = s.length) {
    const mul5 = k2.add(len3 * 2);
    const a = fetch64(s, 0).mul(k1);
    const b = fetch64(s, 8);
    const c = fetch64(s, len3 - 8).mul(mul5);
    const d = fetch64(s, len3 - 16).mul(k2);
    return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul5);
  }
  function hashLen33to64(s, len3 = s.length) {
    const mul5 = k2.add(len3 * 2);
    const a = fetch64(s, 0).mul(k2);
    const b = fetch64(s, 8);
    const c = fetch64(s, len3 - 8).mul(mul5);
    const d = fetch64(s, len3 - 16).mul(k2);
    const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);
    const z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul5);
    const e = fetch64(s, 16).mul(mul5);
    const f = fetch64(s, 24);
    const g = y.add(fetch64(s, len3 - 32)).mul(mul5);
    const h2 = z.add(fetch64(s, len3 - 24)).mul(mul5);
    return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h2), e.add(rotate64(f.add(a), 18)).add(g), mul5);
  }
  function fingerPrint64(s, len3 = s.length) {
    const seed = Long.fromNumber(81, true);
    if (len3 <= 32) {
      if (len3 <= 16) {
        return hashLen0to16(s, len3);
      } else {
        return hashLen17to32(s, len3);
      }
    } else if (len3 <= 64) {
      return hashLen33to64(s, len3);
    }
    let x = seed;
    let y = seed.mul(k1).add(113);
    let z = shiftMix(y.mul(k2).add(113)).mul(k2);
    let v = [Long.UZERO, Long.UZERO];
    let w = [Long.UZERO, Long.UZERO];
    x = x.mul(k2).add(fetch64(s, 0));
    let offset = 0;
    const end = (len3 - 1 >> 6) * 64;
    const last64 = end + (len3 - 1 & 63) - 63;
    do {
      x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);
      y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);
      x = x.xor(w[1]);
      y = y.add(v[0]).add(fetch64(s, offset + 40));
      z = rotate64(z.add(w[0]), 33).mul(k1);
      v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));
      w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
      [z, x] = [x, z];
      offset += 64;
    } while (offset !== end);
    const mul5 = k1.add(z.and(255).shl(1));
    offset = last64;
    w[0] = w[0].add(len3 - 1 & 63);
    v[0] = v[0].add(w[0]);
    w[0] = w[0].add(v[0]);
    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul5);
    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul5);
    x = x.xor(w[1].mul(9));
    y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));
    z = rotate64(z.add(w[0]), 33).mul(mul5);
    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul5), x.add(w[0]));
    w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
    [z, x] = [x, z];
    return hashLen16(hashLen16(v[0], w[0], mul5).add(shiftMix(y).mul(k0)).add(z), hashLen16(v[1], w[1], mul5).add(x), mul5);
  }

  // node_modules/@tensorflow/tfjs-core/dist/util.js
  function createScalarValue(value, dtype) {
    if (dtype === "string") {
      return encodeString(value);
    }
    return toTypedArray([value], dtype);
  }
  function noConversionNeeded(a, dtype) {
    return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
  }
  function toTypedArray(a, dtype) {
    if (dtype === "string") {
      throw new Error("Cannot convert a string[] to a TypedArray");
    }
    if (Array.isArray(a)) {
      a = flatten2(a);
    }
    if (env().getBool("DEBUG")) {
      checkConversionForErrors(a, dtype);
    }
    if (noConversionNeeded(a, dtype)) {
      return a;
    }
    if (dtype == null || dtype === "float32" || dtype === "complex64") {
      return new Float32Array(a);
    } else if (dtype === "int32") {
      return new Int32Array(a);
    } else if (dtype === "bool") {
      const bool = new Uint8Array(a.length);
      for (let i = 0; i < bool.length; ++i) {
        if (Math.round(a[i]) !== 0) {
          bool[i] = 1;
        }
      }
      return bool;
    } else {
      throw new Error(`Unknown data type ${dtype}`);
    }
  }
  function now2() {
    return env().platform.now();
  }
  function fetch3(path, requestInits) {
    return env().platform.fetch(path, requestInits);
  }
  function encodeString(s, encoding = "utf-8") {
    encoding = encoding || "utf-8";
    return env().platform.encode(s, encoding);
  }
  function decodeString(bytes, encoding = "utf-8") {
    encoding = encoding || "utf-8";
    return env().platform.decode(bytes, encoding);
  }

  // node_modules/@tensorflow/tfjs-core/dist/profiler.js
  var Profiler = class {
    constructor(backendTimer, logger) {
      this.backendTimer = backendTimer;
      this.logger = logger;
      if (logger == null) {
        this.logger = new Logger();
      }
    }
    profileKernel(kernelName, inputs, f) {
      let outputs;
      const holdResultWrapperFn = () => {
        outputs = f();
      };
      let timer2;
      const start = now2();
      if (this.backendTimer.timerAvailable()) {
        timer2 = this.backendTimer.time(holdResultWrapperFn);
      } else {
        holdResultWrapperFn();
        for (const output of outputs) {
          output.dataSync();
        }
        timer2 = Promise.resolve({ kernelMs: now2() - start });
      }
      if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
        for (let i = 0; i < outputs.length; i++) {
          const output = outputs[i];
          output.data().then((tensorVals) => {
            checkComputationForErrors(tensorVals, output.dtype, kernelName);
          });
        }
      }
      const kernelProfile = {
        kernelName,
        outputs,
        inputs,
        timeMs: timer2.then((timing) => timing.kernelMs),
        extraInfo: timer2.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
      };
      return kernelProfile;
    }
    logKernelProfile(kernelProfile) {
      const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
      outputs.forEach((result) => {
        Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
          this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
        });
      });
    }
  };
  function checkComputationForErrors(vals, dtype, kernelName) {
    if (dtype !== "float32") {
      return false;
    }
    for (let i = 0; i < vals.length; i++) {
      const num = vals[i];
      if (isNaN(num) || !isFinite(num)) {
        console.warn(`Found ${num} in the result of '${kernelName}'`);
        return true;
      }
    }
    return false;
  }
  var Logger = class {
    logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
      const time = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
      const paddedName = rightPad(name, 25);
      const rank = result.rank;
      const size3 = result.size;
      const shape = rightPad(result.shape.toString(), 14);
      let inputShapesDescription = "";
      for (const name2 in inputs) {
        const input2 = inputs[name2];
        if (input2 != null) {
          const inputShape = input2.shape || result.shape;
          const inputRank = inputShape.length;
          inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
        }
      }
      console.log(`%c${paddedName}	%c${time}	%c${rank}D ${shape}	%c${size3}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/tape.js
  function getFilteredNodesXToY(tape, xs, y) {
    const tensorsFromX = {};
    const nodesFromX = {};
    for (let i = 0; i < xs.length; i++) {
      tensorsFromX[xs[i].id] = true;
    }
    for (let i = 0; i < tape.length; i++) {
      const node = tape[i];
      const nodeInputs = node.inputs;
      for (const inputName in nodeInputs) {
        const input2 = nodeInputs[inputName];
        let anyInputFromX = false;
        for (let j = 0; j < xs.length; j++) {
          if (tensorsFromX[input2.id]) {
            node.outputs.forEach((output) => tensorsFromX[output.id] = true);
            anyInputFromX = true;
            nodesFromX[node.id] = true;
            break;
          }
        }
        if (anyInputFromX) {
          break;
        }
      }
    }
    const tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    const nodesToY = {};
    for (let i = tape.length - 1; i >= 0; i--) {
      const node = tape[i];
      const nodeInputs = node.inputs;
      for (let j = 0; j < node.outputs.length; j++) {
        if (tensorsLeadToY[node.outputs[j].id]) {
          for (const inputName in nodeInputs) {
            tensorsLeadToY[nodeInputs[inputName].id] = true;
            nodesToY[node.id] = true;
          }
          break;
        }
      }
    }
    const filteredTape = [];
    for (let i = 0; i < tape.length; i++) {
      const node = tape[i];
      if (nodesFromX[node.id] && nodesToY[node.id]) {
        const prunedInputs = {};
        for (const inputName in node.inputs) {
          const nodeInput = node.inputs[inputName];
          if (tensorsFromX[nodeInput.id]) {
            prunedInputs[inputName] = nodeInput;
          }
        }
        const prunedNode = Object.assign({}, node);
        prunedNode.inputs = prunedInputs;
        prunedNode.outputs = node.outputs;
        filteredTape.push(prunedNode);
      }
    }
    return filteredTape;
  }
  function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy2, add8) {
    for (let i = filteredTape.length - 1; i >= 0; i--) {
      const node = filteredTape[i];
      const dys = [];
      node.outputs.forEach((o) => {
        const gradTensor = tensorAccumulatedGradientMap[o.id];
        if (gradTensor != null) {
          dys.push(gradTensor);
        } else {
          dys.push(null);
        }
      });
      if (node.gradient == null) {
        throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
      }
      const inputGradients = node.gradient(dys);
      for (const inputName in node.inputs) {
        if (!(inputName in inputGradients)) {
          throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
        }
        const dx = tidy2(() => inputGradients[inputName]());
        if (dx.dtype !== "float32") {
          throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
        }
        const x = node.inputs[inputName];
        if (!arraysEqual(dx.shape, x.shape)) {
          throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);
        }
        if (tensorAccumulatedGradientMap[x.id] == null) {
          tensorAccumulatedGradientMap[x.id] = dx;
        } else {
          const curGradient = tensorAccumulatedGradientMap[x.id];
          tensorAccumulatedGradientMap[x.id] = add8(curGradient, dx);
          curGradient.dispose();
        }
      }
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/tensor_format.js
  var FORMAT_LIMIT_NUM_VALS = 20;
  var FORMAT_NUM_FIRST_LAST_VALS = 3;
  var FORMAT_NUM_SIG_DIGITS = 7;
  function tensorToString(vals, shape, dtype, verbose) {
    const strides = computeStrides(shape);
    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
    const rank = shape.length;
    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
    const lines = ["Tensor"];
    if (verbose) {
      lines.push(`  dtype: ${dtype}`);
      lines.push(`  rank: ${rank}`);
      lines.push(`  shape: [${shape}]`);
      lines.push(`  values:`);
    }
    lines.push(valsLines.map((l) => "    " + l).join("\n"));
    return lines.join("\n");
  }
  function computeMaxSizePerColumn(vals, shape, dtype, strides) {
    const n = sizeFromShape(shape);
    const numCols = strides[strides.length - 1];
    const padPerCol = new Array(numCols).fill(0);
    const rank = shape.length;
    const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
    if (rank > 1) {
      for (let row = 0; row < n / numCols; row++) {
        const offset = row * numCols;
        for (let j = 0; j < numCols; j++) {
          padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
        }
      }
    }
    return padPerCol;
  }
  function valToString(val, pad3, dtype) {
    let valStr;
    if (Array.isArray(val)) {
      valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
    } else if (isString2(val)) {
      valStr = `'${val}'`;
    } else if (dtype === "bool") {
      valStr = boolNumToString(val);
    } else {
      valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
    }
    return rightPad(valStr, pad3);
  }
  function boolNumToString(v) {
    return v === 0 ? "false" : "true";
  }
  function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
    const storagePerElement = dtype === "complex64" ? 2 : 1;
    const size3 = shape[0];
    const rank = shape.length;
    if (rank === 0) {
      if (dtype === "complex64") {
        const complexTuple = createComplexTuples(vals);
        return [valToString(complexTuple[0], 0, dtype)];
      }
      if (dtype === "bool") {
        return [boolNumToString(vals[0])];
      }
      return [vals[0].toString()];
    }
    if (rank === 1) {
      if (size3 > FORMAT_LIMIT_NUM_VALS) {
        const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
        let firstVals = Array.from(vals.slice(0, firstValsSize));
        let lastVals = Array.from(vals.slice((size3 - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size3 * storagePerElement));
        if (dtype === "complex64") {
          firstVals = createComplexTuples(firstVals);
          lastVals = createComplexTuples(lastVals);
        }
        return [
          "[" + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString(x, padPerCol[size3 - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(", ") + "]"
        ];
      }
      const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
      return [
        "[" + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + "]"
      ];
    }
    const subshape = shape.slice(1);
    const substrides = strides.slice(1);
    const stride = strides[0] * storagePerElement;
    const lines = [];
    if (size3 > FORMAT_LIMIT_NUM_VALS) {
      for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
        const start = i * stride;
        const end = start + stride;
        lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
      }
      lines.push("...");
      for (let i = size3 - FORMAT_NUM_FIRST_LAST_VALS; i < size3; i++) {
        const start = i * stride;
        const end = start + stride;
        lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size3 - 1));
      }
    } else {
      for (let i = 0; i < size3; i++) {
        const start = i * stride;
        const end = start + stride;
        lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size3 - 1));
      }
    }
    const sep = rank === 2 ? "," : "";
    lines[0] = "[" + lines[0] + sep;
    for (let i = 1; i < lines.length - 1; i++) {
      lines[i] = " " + lines[i] + sep;
    }
    let newLineSep = ",\n";
    for (let i = 2; i < rank; i++) {
      newLineSep += "\n";
    }
    lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
    return lines;
  }
  function createComplexTuples(vals) {
    const complexTuples = [];
    for (let i = 0; i < vals.length; i += 2) {
      complexTuples.push([vals[i], vals[i + 1]]);
    }
    return complexTuples;
  }

  // node_modules/@tensorflow/tfjs-core/dist/tensor.js
  var TensorBuffer = class {
    constructor(shape, dtype, values2) {
      this.dtype = dtype;
      this.shape = shape.slice();
      this.size = sizeFromShape(shape);
      if (values2 != null) {
        const n = values2.length;
        assert(n === this.size, () => `Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`);
      }
      if (dtype === "complex64") {
        throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
      }
      this.values = values2 || getArrayFromDType(dtype, this.size);
      this.strides = computeStrides(shape);
    }
    set(value, ...locs) {
      if (locs.length === 0) {
        locs = [0];
      }
      assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
      const index = this.locToIndex(locs);
      this.values[index] = value;
    }
    get(...locs) {
      if (locs.length === 0) {
        locs = [0];
      }
      let i = 0;
      for (const loc of locs) {
        if (loc < 0 || loc >= this.shape[i]) {
          const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
          throw new Error(msg);
        }
        i++;
      }
      let index = locs[locs.length - 1];
      for (let i2 = 0; i2 < locs.length - 1; ++i2) {
        index += this.strides[i2] * locs[i2];
      }
      return this.values[index];
    }
    locToIndex(locs) {
      if (this.rank === 0) {
        return 0;
      } else if (this.rank === 1) {
        return locs[0];
      }
      let index = locs[locs.length - 1];
      for (let i = 0; i < locs.length - 1; ++i) {
        index += this.strides[i] * locs[i];
      }
      return index;
    }
    indexToLoc(index) {
      if (this.rank === 0) {
        return [];
      } else if (this.rank === 1) {
        return [index];
      }
      const locs = new Array(this.shape.length);
      for (let i = 0; i < locs.length - 1; ++i) {
        locs[i] = Math.floor(index / this.strides[i]);
        index -= locs[i] * this.strides[i];
      }
      locs[locs.length - 1] = index;
      return locs;
    }
    get rank() {
      return this.shape.length;
    }
    toTensor() {
      return trackerFn().makeTensor(this.values, this.shape, this.dtype);
    }
  };
  var trackerFn = null;
  var opHandler = null;
  var deprecationWarningFn = null;
  function setTensorTracker(fn) {
    trackerFn = fn;
  }
  function setOpHandler(handler) {
    opHandler = handler;
  }
  function setDeprecationWarningFn(fn) {
    deprecationWarningFn = fn;
  }
  var Tensor = class {
    constructor(shape, dtype, dataId, id) {
      this.kept = false;
      this.isDisposedInternal = false;
      this.shape = shape.slice();
      this.dtype = dtype || "float32";
      this.size = sizeFromShape(shape);
      this.strides = computeStrides(shape);
      this.dataId = dataId;
      this.id = id;
      this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
      return this.shape.length;
    }
    async buffer() {
      const vals = await this.data();
      return opHandler.buffer(this.shape, this.dtype, vals);
    }
    bufferSync() {
      return opHandler.buffer(this.shape, this.dtype, this.dataSync());
    }
    async array() {
      const vals = await this.data();
      return toNestedArray(this.shape, vals, this.dtype === "complex64");
    }
    arraySync() {
      return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    async data() {
      this.throwIfDisposed();
      const data = trackerFn().read(this.dataId);
      if (this.dtype === "string") {
        const bytes = await data;
        try {
          return bytes.map((b) => decodeString(b));
        } catch (_a4) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return data;
    }
    dataSync() {
      this.throwIfDisposed();
      const data = trackerFn().readSync(this.dataId);
      if (this.dtype === "string") {
        try {
          return data.map((b) => decodeString(b));
        } catch (_a4) {
          throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
      }
      return data;
    }
    async bytes() {
      this.throwIfDisposed();
      const data = await trackerFn().read(this.dataId);
      if (this.dtype === "string") {
        return data;
      } else {
        return new Uint8Array(data.buffer);
      }
    }
    dispose() {
      if (this.isDisposed) {
        return;
      }
      trackerFn().disposeTensor(this);
      this.isDisposedInternal = true;
    }
    get isDisposed() {
      return this.isDisposedInternal;
    }
    throwIfDisposed() {
      if (this.isDisposed) {
        throw new Error(`Tensor is disposed.`);
      }
    }
    print(verbose = false) {
      return opHandler.print(this, verbose);
    }
    clone() {
      this.throwIfDisposed();
      return opHandler.clone(this);
    }
    toString(verbose = false) {
      const vals = this.dataSync();
      return tensorToString(vals, this.shape, this.dtype, verbose);
    }
    cast(dtype) {
      this.throwIfDisposed();
      return opHandler.cast(this, dtype);
    }
    variable(trainable = true, name, dtype) {
      this.throwIfDisposed();
      return trackerFn().makeVariable(this, trainable, name, dtype);
    }
  };
  Object.defineProperty(Tensor, Symbol.hasInstance, {
    value: (instance) => {
      return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
    }
  });
  function getGlobalTensorClass() {
    return getGlobal("Tensor", () => {
      return Tensor;
    });
  }
  getGlobalTensorClass();
  var Variable = class extends Tensor {
    constructor(initialValue, trainable, name, tensorId) {
      super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
      this.trainable = trainable;
      this.name = name;
    }
    assign(newValue) {
      if (newValue.dtype !== this.dtype) {
        throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
      }
      if (!arraysEqual(newValue.shape, this.shape)) {
        throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
      }
      trackerFn().disposeTensor(this);
      this.dataId = newValue.dataId;
      trackerFn().incRef(this, null);
    }
    dispose() {
      trackerFn().disposeVariable(this);
      this.isDisposedInternal = true;
    }
  };
  Object.defineProperty(Variable, Symbol.hasInstance, {
    value: (instance) => {
      return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
    }
  });

  // node_modules/@tensorflow/tfjs-core/dist/tensor_util.js
  var tensor_util_exports = {};
  __export(tensor_util_exports, {
    assertTypesMatch: () => assertTypesMatch,
    getTensorsInContainer: () => getTensorsInContainer,
    isTensorInList: () => isTensorInList,
    makeTypesMatch: () => makeTypesMatch
  });

  // node_modules/@tensorflow/tfjs-core/dist/types.js
  var Rank;
  (function(Rank2) {
    Rank2["R0"] = "R0";
    Rank2["R1"] = "R1";
    Rank2["R2"] = "R2";
    Rank2["R3"] = "R3";
    Rank2["R4"] = "R4";
    Rank2["R5"] = "R5";
    Rank2["R6"] = "R6";
  })(Rank || (Rank = {}));
  var UpcastInt32AndMap;
  (function(UpcastInt32AndMap2) {
    UpcastInt32AndMap2["float32"] = "float32";
    UpcastInt32AndMap2["int32"] = "int32";
    UpcastInt32AndMap2["bool"] = "int32";
    UpcastInt32AndMap2["complex64"] = "complex64";
  })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
  var UpcastBoolAndMap;
  (function(UpcastBoolAndMap2) {
    UpcastBoolAndMap2["float32"] = "float32";
    UpcastBoolAndMap2["int32"] = "int32";
    UpcastBoolAndMap2["bool"] = "bool";
    UpcastBoolAndMap2["complex64"] = "complex64";
  })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
  var UpcastFloat32AndMap;
  (function(UpcastFloat32AndMap2) {
    UpcastFloat32AndMap2["float32"] = "float32";
    UpcastFloat32AndMap2["int32"] = "float32";
    UpcastFloat32AndMap2["bool"] = "float32";
    UpcastFloat32AndMap2["complex64"] = "complex64";
  })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
  var UpcastComplex64AndMap;
  (function(UpcastComplex64AndMap2) {
    UpcastComplex64AndMap2["float32"] = "complex64";
    UpcastComplex64AndMap2["int32"] = "complex64";
    UpcastComplex64AndMap2["bool"] = "complex64";
    UpcastComplex64AndMap2["complex64"] = "complex64";
  })(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
  var upcastTypeMap = {
    "float32": UpcastFloat32AndMap,
    "int32": UpcastInt32AndMap,
    "bool": UpcastBoolAndMap,
    "complex64": UpcastComplex64AndMap
  };
  function upcastType(typeA, typeB) {
    if (typeA === "string" || typeB === "string") {
      if (typeA === "string" && typeB === "string") {
        return "string";
      }
      throw new Error(`Can not upcast ${typeA} with ${typeB}`);
    }
    return upcastTypeMap[typeA][typeB];
  }
  function sumOutType(type) {
    return upcastType(type, "int32");
  }

  // node_modules/@tensorflow/tfjs-core/dist/tensor_util.js
  function makeTypesMatch(a, b) {
    if (a.dtype === b.dtype) {
      return [a, b];
    }
    const dtype = upcastType(a.dtype, b.dtype);
    return [a.cast(dtype), b.cast(dtype)];
  }
  function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`);
  }
  function isTensorInList(tensor2, tensorList) {
    return tensorList.some((x) => x.id === tensor2.id);
  }
  function getTensorsInContainer(result) {
    const list = [];
    const seen = new Set();
    walkTensorContainer(result, list, seen);
    return list;
  }
  function walkTensorContainer(container, list, seen) {
    if (container == null) {
      return;
    }
    if (container instanceof Tensor) {
      list.push(container);
      return;
    }
    if (!isIterable(container)) {
      return;
    }
    const iterable = container;
    for (const k in iterable) {
      const val = iterable[k];
      if (!seen.has(val)) {
        seen.add(val);
        walkTensorContainer(val, list, seen);
      }
    }
  }
  function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === "object";
  }

  // node_modules/@tensorflow/tfjs-core/dist/engine.js
  function isRegisteredKernelInvocation(kernelInvocation) {
    return kernelInvocation.kernelName != null;
  }
  var EngineState = class {
    constructor() {
      this.registeredVariables = {};
      this.nextTapeNodeId = 0;
      this.numBytes = 0;
      this.numTensors = 0;
      this.numStringTensors = 0;
      this.numDataBuffers = 0;
      this.gradientDepth = 0;
      this.kernelDepth = 0;
      this.scopeStack = [];
      this.numDataMovesStack = [];
      this.nextScopeId = 0;
      this.tensorInfo = new WeakMap();
      this.profiling = false;
      this.activeProfile = {
        newBytes: 0,
        newTensors: 0,
        peakBytes: 0,
        kernels: [],
        result: null,
        get kernelNames() {
          return Array.from(new Set(this.kernels.map((k) => k.name)));
        }
      };
    }
    dispose() {
      for (const variableName in this.registeredVariables) {
        this.registeredVariables[variableName].dispose();
      }
    }
  };
  var Engine = class {
    constructor(ENV4) {
      this.ENV = ENV4;
      this.registry = {};
      this.registryFactory = {};
      this.pendingBackendInitId = 0;
      this.state = new EngineState();
    }
    async ready() {
      if (this.pendingBackendInit != null) {
        return this.pendingBackendInit.then(() => {
        });
      }
      if (this.backendInstance != null) {
        return;
      }
      const sortedBackends = this.getSortedBackends();
      for (let i = 0; i < sortedBackends.length; i++) {
        const backendName = sortedBackends[i];
        const success = await this.initializeBackend(backendName).success;
        if (success) {
          await this.setBackend(backendName);
          return;
        }
      }
      throw new Error(`Could not initialize any backends, all backend initializations failed.`);
    }
    get backend() {
      if (this.pendingBackendInit != null) {
        throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      }
      if (this.backendInstance == null) {
        const { name, asyncInit } = this.initializeBackendsAndReturnBest();
        if (asyncInit) {
          throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        }
        this.setBackend(name);
      }
      return this.backendInstance;
    }
    backendNames() {
      return Object.keys(this.registryFactory);
    }
    findBackend(backendName) {
      if (!(backendName in this.registry)) {
        if (backendName in this.registryFactory) {
          const { asyncInit } = this.initializeBackend(backendName);
          if (asyncInit) {
            return null;
          }
        } else {
          return null;
        }
      }
      return this.registry[backendName];
    }
    findBackendFactory(backendName) {
      if (!(backendName in this.registryFactory)) {
        return null;
      }
      return this.registryFactory[backendName].factory;
    }
    registerBackend(backendName, factory, priority = 1) {
      if (backendName in this.registryFactory) {
        warn3(`${backendName} backend was already registered. Reusing existing backend factory.`);
        return false;
      }
      this.registryFactory[backendName] = { factory, priority };
      return true;
    }
    async setBackend(backendName) {
      if (this.registryFactory[backendName] == null) {
        throw new Error(`Backend name '${backendName}' not found in registry`);
      }
      this.backendName = backendName;
      if (this.registry[backendName] == null) {
        this.backendInstance = null;
        const { success, asyncInit } = this.initializeBackend(backendName);
        const result = asyncInit ? await success : success;
        if (!result) {
          return false;
        }
      }
      this.backendInstance = this.registry[backendName];
      this.setupRegisteredKernels();
      this.profiler = new Profiler(this.backendInstance);
      return true;
    }
    setupRegisteredKernels() {
      const kernels = getKernelsForBackend(this.backendName);
      kernels.forEach((kernel) => {
        if (kernel.setupFunc != null) {
          kernel.setupFunc(this.backendInstance);
        }
      });
    }
    disposeRegisteredKernels(backendName) {
      const kernels = getKernelsForBackend(backendName);
      kernels.forEach((kernel) => {
        if (kernel.disposeFunc != null) {
          kernel.disposeFunc(this.registry[backendName]);
        }
      });
    }
    initializeBackend(backendName) {
      const registryFactoryEntry = this.registryFactory[backendName];
      if (registryFactoryEntry == null) {
        throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
      }
      try {
        const backend2 = registryFactoryEntry.factory();
        if (backend2 && !(backend2 instanceof KernelBackend) && typeof backend2.then === "function") {
          const promiseId = ++this.pendingBackendInitId;
          const success = backend2.then((backendInstance) => {
            if (promiseId < this.pendingBackendInitId) {
              return false;
            }
            this.registry[backendName] = backendInstance;
            this.pendingBackendInit = null;
            return true;
          }).catch((err) => {
            if (promiseId < this.pendingBackendInitId) {
              return false;
            }
            this.pendingBackendInit = null;
            warn3(`Initialization of backend ${backendName} failed`);
            warn3(err.stack || err.message);
            return false;
          });
          this.pendingBackendInit = success;
          return { success, asyncInit: true };
        } else {
          this.registry[backendName] = backend2;
          return { success: true, asyncInit: false };
        }
      } catch (err) {
        warn3(`Initialization of backend ${backendName} failed`);
        warn3(err.stack || err.message);
        return { success: false, asyncInit: false };
      }
    }
    removeBackend(backendName) {
      if (!(backendName in this.registryFactory)) {
        throw new Error(`${backendName} backend not found in registry`);
      }
      if (this.backendName === backendName && this.pendingBackendInit != null) {
        this.pendingBackendInitId++;
      }
      if (backendName in this.registry) {
        this.disposeRegisteredKernels(backendName);
        this.registry[backendName].dispose();
        delete this.registry[backendName];
      }
      delete this.registryFactory[backendName];
      if (this.backendName === backendName) {
        this.pendingBackendInit = null;
        this.backendName = null;
        this.backendInstance = null;
      }
    }
    getSortedBackends() {
      if (Object.keys(this.registryFactory).length === 0) {
        throw new Error("No backend found in registry.");
      }
      return Object.keys(this.registryFactory).sort((a, b) => {
        return this.registryFactory[b].priority - this.registryFactory[a].priority;
      });
    }
    initializeBackendsAndReturnBest() {
      const sortedBackends = this.getSortedBackends();
      for (let i = 0; i < sortedBackends.length; i++) {
        const backendName = sortedBackends[i];
        const { success, asyncInit } = this.initializeBackend(backendName);
        if (asyncInit || success) {
          return { name: backendName, asyncInit };
        }
      }
      throw new Error(`Could not initialize any backends, all backend initializations failed.`);
    }
    moveData(backend2, dataId) {
      const info = this.state.tensorInfo.get(dataId);
      const srcBackend = info.backend;
      const values2 = this.readSync(dataId);
      const refCount = srcBackend.refCount(dataId);
      srcBackend.disposeData(dataId, true);
      info.backend = backend2;
      backend2.move(dataId, values2, info.shape, info.dtype, refCount);
      if (this.shouldCheckForMemLeaks()) {
        this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
      }
    }
    tidy(nameOrFn, fn) {
      let name = null;
      if (fn == null) {
        if (typeof nameOrFn !== "function") {
          throw new Error("Please provide a function to tidy()");
        }
        fn = nameOrFn;
      } else {
        if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
          throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
        }
        if (typeof fn !== "function") {
          throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
        }
        name = nameOrFn;
      }
      let result;
      return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
        result = fn();
        if (result instanceof Promise) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        return result;
      });
    }
    scopedRun(start, end, f) {
      start();
      try {
        const res = f();
        end();
        return res;
      } catch (ex) {
        end();
        throw ex;
      }
    }
    nextTensorId() {
      return Engine.nextTensorId++;
    }
    nextVariableId() {
      return Engine.nextVariableId++;
    }
    clone(x) {
      const y = ENGINE.runKernel(Identity2, { x });
      const inputs = { x };
      const grad = (dy) => ({
        x: () => {
          const dtype = "float32";
          const gradInputs = { x: dy };
          const attrs = { dtype };
          return ENGINE.runKernel(Cast, gradInputs, attrs);
        }
      });
      const saved = [];
      this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});
      return y;
    }
    runKernel(kernelName, inputs, attrs) {
      if (this.backendName == null) {
        this.backend;
      }
      const hasKernel = getKernel(kernelName, this.backendName) != null;
      if (!hasKernel) {
        throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
      }
      return this.runKernelFunc({ kernelName, inputs, attrs });
    }
    shouldCheckForMemLeaks() {
      return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
      const numDataIdsAfter = this.backend.numDataIds();
      let numOutputDataIds = 0;
      outInfos.forEach((info) => {
        numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
      });
      const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
      const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
      if (dataIdsLeaked > 0) {
        throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
      }
    }
    runKernelFunc(kernelParams) {
      let outputs;
      let saved = [];
      const isTapeOn = this.isTapeOn();
      const startingBytecount = this.state.numBytes;
      const startingNumTensors = this.state.numTensors;
      if (this.shouldCheckForMemLeaks()) {
        this.state.numDataMovesStack.push(0);
      }
      let kernelFunc;
      if (this.backendName == null) {
        this.backend;
      }
      let out;
      const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
      if (isRegisteredKernelInvocation(kernelParams)) {
        const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
        if (this.backendName == null) {
          this.backend;
        }
        const kernel = getKernel(kernelName, this.backendName);
        assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
        kernelFunc = () => {
          const numDataIdsBefore = this.backend.numDataIds();
          out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
          const outInfos = Array.isArray(out) ? out : [out];
          if (this.shouldCheckForMemLeaks()) {
            this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
          }
          const outTensors = outInfos.map((outInfo) => {
            if (outInfo.rank != null) {
              return outInfo;
            }
            const { dataId, shape, dtype } = outInfo;
            return this.makeTensorFromDataId(dataId, shape, dtype);
          });
          if (isTapeOn) {
            const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
            saved = this.saveTensorsForBackwardMode(tensorsToSave);
          }
          return outTensors;
        };
      } else {
        const { forwardFunc } = kernelParams;
        const saveFunc = (tensors) => {
          if (!isTapeOn) {
            return;
          }
          saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
        };
        kernelFunc = () => {
          const numDataIdsBefore = this.backend.numDataIds();
          out = this.tidy(() => forwardFunc(this.backend, saveFunc));
          const outs = Array.isArray(out) ? out : [out];
          if (this.shouldCheckForMemLeaks()) {
            this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
          }
          return outs;
        };
      }
      const { inputs, attrs } = kernelParams;
      const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
      let kernelProfile;
      this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
        if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
          outputs = kernelFunc();
        } else {
          kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
          if (this.ENV.getBool("DEBUG")) {
            this.profiler.logKernelProfile(kernelProfile);
          }
          outputs = kernelProfile.outputs;
        }
      });
      if (isTapeOn) {
        this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
      }
      if (this.state.profiling) {
        this.state.activeProfile.kernels.push({
          name: kernelOrScopeName,
          bytesAdded: this.state.numBytes - startingBytecount,
          totalBytesSnapshot: this.state.numBytes,
          tensorsAdded: this.state.numTensors - startingNumTensors,
          totalTensorsSnapshot: this.state.numTensors,
          inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
          outputShapes: outputs.map((item) => item.shape),
          kernelTimeMs: kernelProfile.timeMs,
          extraInfo: kernelProfile.extraInfo
        });
      }
      return Array.isArray(out) ? outputs : outputs[0];
    }
    saveTensorsForBackwardMode(tensors) {
      const saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
      return saved;
    }
    getTensorsForGradient(kernelName, inputs, outputs) {
      const gradConfig = getGradient(kernelName);
      if (gradConfig != null) {
        const inputsToSave = gradConfig.inputsToSave || [];
        const outputsToSave = gradConfig.outputsToSave || [];
        let inputTensorsToSave;
        if (gradConfig.saveAllInputs) {
          assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
          inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
        } else {
          inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
        }
        const outputTensorsToSave = outputs.filter((_6, i) => outputsToSave[i]);
        return inputTensorsToSave.concat(outputTensorsToSave);
      }
      return [];
    }
    makeTensor(values2, shape, dtype, backend2) {
      if (values2 == null) {
        throw new Error("Values passed to engine.makeTensor() are null");
      }
      dtype = dtype || "float32";
      backend2 = backend2 || this.backend;
      let backendVals = values2;
      if (dtype === "string" && isString2(values2[0])) {
        backendVals = values2.map((d) => encodeString(d));
      }
      const dataId = backend2.write(backendVals, shape, dtype);
      const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
      this.trackTensor(t, backend2);
      if (dtype === "string") {
        const info = this.state.tensorInfo.get(dataId);
        const newBytes = bytesFromStringArray(backendVals);
        this.state.numBytes += newBytes - info.bytes;
        info.bytes = newBytes;
      }
      return t;
    }
    makeTensorFromDataId(dataId, shape, dtype, backend2) {
      dtype = dtype || "float32";
      const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
      this.trackTensor(t, backend2);
      return t;
    }
    makeVariable(initialValue, trainable = true, name, dtype) {
      name = name || this.nextVariableId().toString();
      if (dtype != null && dtype !== initialValue.dtype) {
        initialValue = initialValue.cast(dtype);
      }
      const v = new Variable(initialValue, trainable, name, this.nextTensorId());
      if (this.state.registeredVariables[v.name] != null) {
        throw new Error(`Variable with name ${v.name} was already registered`);
      }
      this.state.registeredVariables[v.name] = v;
      this.incRef(v, this.backend);
      return v;
    }
    trackTensor(a, backend2) {
      this.state.numTensors++;
      if (a.dtype === "string") {
        this.state.numStringTensors++;
      }
      let bytes = 0;
      if (a.dtype !== "complex64" && a.dtype !== "string") {
        bytes = a.size * bytesPerElement(a.dtype);
      }
      this.state.numBytes += bytes;
      if (!this.state.tensorInfo.has(a.dataId)) {
        this.state.numDataBuffers++;
        this.state.tensorInfo.set(a.dataId, {
          backend: backend2 || this.backend,
          dtype: a.dtype,
          shape: a.shape,
          bytes
        });
      }
      if (!(a instanceof Variable)) {
        this.track(a);
      }
    }
    incRef(a, backend2) {
      this.trackTensor(a, backend2);
      this.backend.incRef(a.dataId);
    }
    removeDataId(dataId, backend2) {
      if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend2) {
        this.state.tensorInfo.delete(dataId);
        this.state.numDataBuffers--;
      }
    }
    disposeTensor(a) {
      if (!this.state.tensorInfo.has(a.dataId)) {
        return;
      }
      const info = this.state.tensorInfo.get(a.dataId);
      this.state.numTensors--;
      if (a.dtype === "string") {
        this.state.numStringTensors--;
        this.state.numBytes -= info.bytes;
      }
      if (a.dtype !== "complex64" && a.dtype !== "string") {
        const bytes = a.size * bytesPerElement(a.dtype);
        this.state.numBytes -= bytes;
      }
      if (info.backend.disposeData(a.dataId)) {
        this.removeDataId(a.dataId, info.backend);
      }
    }
    disposeVariables() {
      for (const varName in this.state.registeredVariables) {
        const v = this.state.registeredVariables[varName];
        this.disposeVariable(v);
      }
    }
    disposeVariable(v) {
      this.disposeTensor(v);
      if (this.state.registeredVariables[v.name] != null) {
        delete this.state.registeredVariables[v.name];
      }
    }
    memory() {
      const info = this.backend.memory();
      info.numTensors = this.state.numTensors;
      info.numDataBuffers = this.state.numDataBuffers;
      info.numBytes = this.state.numBytes;
      if (this.state.numStringTensors > 0) {
        info.unreliable = true;
        if (info.reasons == null) {
          info.reasons = [];
        }
        info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
      }
      return info;
    }
    async profile(query) {
      this.state.profiling = true;
      const startBytes = this.state.numBytes;
      const startNumTensors = this.state.numTensors;
      this.state.activeProfile.kernels = [];
      this.state.activeProfile.result = await query();
      this.state.profiling = false;
      this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
      this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
      this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
      for (const kernel of this.state.activeProfile.kernels) {
        kernel.kernelTimeMs = await kernel.kernelTimeMs;
        kernel.extraInfo = await kernel.extraInfo;
      }
      return this.state.activeProfile;
    }
    isTapeOn() {
      return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
      const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
      const gradConfig = getGradient(kernelName);
      if (gradConfig != null) {
        gradientsFunc = gradConfig.gradFunc;
      }
      if (gradientsFunc != null) {
        tapeNode.gradient = (dys) => {
          dys = dys.map((dy, i) => {
            if (dy == null) {
              const output = outputs[i];
              const vals = makeZerosTypedArray(output.size, output.dtype);
              return this.makeTensor(vals, output.shape, output.dtype);
            }
            return dy;
          });
          return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
        };
      }
      this.state.activeTape.push(tapeNode);
    }
    keep(result) {
      result.kept = true;
      return result;
    }
    startTape() {
      if (this.state.gradientDepth === 0) {
        this.state.activeTape = [];
      }
      this.state.gradientDepth++;
    }
    endTape() {
      this.state.gradientDepth--;
    }
    startScope(name) {
      const scopeInfo = {
        track: [],
        name: "unnamed scope",
        id: this.state.nextScopeId++
      };
      if (name) {
        scopeInfo.name = name;
      }
      this.state.scopeStack.push(scopeInfo);
      this.state.activeScope = scopeInfo;
    }
    endScope(result) {
      const tensorsToTrackInParent = getTensorsInContainer(result);
      const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
      for (let i = 0; i < this.state.activeScope.track.length; i++) {
        const tensor2 = this.state.activeScope.track[i];
        if (!tensor2.kept && !tensorsToTrackInParentSet.has(tensor2.id)) {
          tensor2.dispose();
        }
      }
      const oldScope = this.state.scopeStack.pop();
      this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
      tensorsToTrackInParent.forEach((tensor2) => {
        if (!tensor2.kept && tensor2.scopeId === oldScope.id) {
          this.track(tensor2);
        }
      });
    }
    gradients(f, xs, dy, allowNoGradients = false) {
      assert(xs.length > 0, () => "gradients() received an empty list of xs.");
      if (dy != null && dy.dtype !== "float32") {
        throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
      }
      const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
      assert(y instanceof Tensor, () => "The result y returned by f() must be a tensor.");
      const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
      if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
      }
      return this.tidy("backward", () => {
        const accumulatedGradientMap = {};
        accumulatedGradientMap[y.id] = dy == null ? ones(y.shape) : dy;
        backpropagateGradients(accumulatedGradientMap, filteredTape, (f2) => this.tidy(f2), add5);
        const grads = xs.map((x) => accumulatedGradientMap[x.id]);
        if (this.state.gradientDepth === 0) {
          this.state.activeTape.forEach((node) => {
            for (const tensor2 of node.saved) {
              tensor2.dispose();
            }
          });
          this.state.activeTape = null;
        }
        return { value: y, grads };
      });
    }
    customGrad(f) {
      assert(isFunction2(f), () => "The f passed in customGrad(f) must be a function.");
      return (...inputs) => {
        assert(inputs.every((t) => t instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
        let res;
        const inputMap = {};
        inputs.forEach((input2, i) => {
          inputMap[i] = input2;
        });
        const forwardFunc = (_6, save) => {
          res = f(...[...inputs, save]);
          assert(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
          assert(isFunction2(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
          return res.value;
        };
        const backwardsFunc = (dy, saved) => {
          const gradRes = res.gradFunc(dy, saved);
          const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
          assert(grads.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
          assert(grads.every((t) => t instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
          const gradMap = {};
          grads.forEach((grad, i) => {
            gradMap[i] = () => grad;
          });
          return gradMap;
        };
        return this.runKernelFunc({
          forwardFunc,
          backwardsFunc,
          inputs: inputMap
        });
      };
    }
    readSync(dataId) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.readSync(dataId);
    }
    read(dataId) {
      const info = this.state.tensorInfo.get(dataId);
      return info.backend.read(dataId);
    }
    async time(query) {
      const start = now2();
      const timingInfo = await this.backend.time(query);
      timingInfo.wallMs = now2() - start;
      return timingInfo;
    }
    track(result) {
      if (this.state.activeScope != null) {
        result.scopeId = this.state.activeScope.id;
        this.state.activeScope.track.push(result);
      }
      return result;
    }
    get registeredVariables() {
      return this.state.registeredVariables;
    }
    reset() {
      this.pendingBackendInitId++;
      this.state.dispose();
      this.ENV.reset();
      this.state = new EngineState();
      for (const backendName in this.registry) {
        this.disposeRegisteredKernels(backendName);
        this.registry[backendName].dispose();
        delete this.registry[backendName];
      }
      this.backendName = null;
      this.backendInstance = null;
      this.pendingBackendInit = null;
    }
  };
  Engine.nextTensorId = 0;
  Engine.nextVariableId = 0;
  function ones(shape) {
    const values2 = makeOnesTypedArray(sizeFromShape(shape), "float32");
    return ENGINE.makeTensor(values2, shape, "float32");
  }
  function getOrMakeEngine() {
    const ns = getGlobalNamespace();
    if (ns._tfengine == null) {
      const environment = new Environment(ns);
      ns._tfengine = new Engine(environment);
    }
    setEnvironmentGlobal(ns._tfengine.ENV);
    setTensorTracker(() => ns._tfengine);
    return ns._tfengine;
  }
  var ENGINE = getOrMakeEngine();
  function add5(a, b) {
    const inputs = { a, b };
    return ENGINE.runKernel(Add, inputs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/device_util.js
  var device_util_exports = {};
  __export(device_util_exports, {
    isBrowser: () => isBrowser3,
    isMobile: () => isMobile,
    mockIsMobile: () => mockIsMobile
  });
  function _isNavigatorDefined() {
    return typeof navigator !== "undefined" && navigator != null;
  }
  var isMobileMockValue;
  function mockIsMobile(value) {
    isMobileMockValue = value;
  }
  function isMobile(nav) {
    if (isMobileMockValue !== void 0) {
      return isMobileMockValue;
    }
    if (nav || _isNavigatorDefined()) {
      if (!nav) {
        nav = navigator;
      }
      if (nav.product === "ReactNative") {
        return true;
      }
      const a = nav.userAgent || nav.vendor || (typeof window !== "undefined" ? window.opera : "");
      if (!a) {
        const navAny = nav;
        return navAny.userAgentData && navAny.userAgentData.mobile;
      }
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
    }
    return false;
  }
  function isBrowser3() {
    return typeof window !== "undefined" && window.document != null || typeof WorkerGlobalScope !== "undefined";
  }

  // node_modules/@tensorflow/tfjs-core/dist/flags.js
  var ENV2 = env();
  ENV2.registerFlag("DEBUG", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
    }
  });
  ENV2.registerFlag("IS_BROWSER", () => isBrowser3());
  ENV2.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
  ENV2.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  ENV2.registerFlag("PROD", () => false);
  ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV2.getBool("DEBUG"));
  ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  ENV2.registerFlag("IS_TEST", () => false);
  ENV2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => true);
  ENV2.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);

  // node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js
  function inferShape(val, dtype) {
    let firstElem = val;
    if (isTypedArray(val)) {
      return dtype === "string" ? [] : [val.length];
    }
    if (!Array.isArray(val)) {
      return [];
    }
    const shape = [];
    while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
      shape.push(firstElem.length);
      firstElem = firstElem[0];
    }
    if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
      deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
  }
  function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!Array.isArray(val) && !isTypedArray(val)) {
      assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
      return;
    }
    assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
    assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
    const subShape = shape.slice(1);
    for (let i = 0; i < val.length; ++i) {
      deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
    }
  }
  function assertDtype(expectedDtype, actualDType, argName, functionName) {
    if (expectedDtype === "string_or_numeric") {
      return;
    }
    if (expectedDtype == null) {
      throw new Error(`Expected dtype cannot be null.`);
    }
    if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
      throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
    }
  }
  function convertToTensor(x, argName, functionName, parseAsDtype = "numeric") {
    if (x instanceof Tensor) {
      assertDtype(parseAsDtype, x.dtype, argName, functionName);
      return x;
    }
    let inferredDtype = inferDtype(x);
    if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
      inferredDtype = parseAsDtype;
    }
    assertDtype(parseAsDtype, inferredDtype, argName, functionName);
    if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
      const type = x == null ? "null" : x.constructor.name;
      throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
    }
    const inferredShape = inferShape(x, inferredDtype);
    if (!isTypedArray(x) && !Array.isArray(x)) {
      x = [x];
    }
    const skipTypedArray = true;
    const values2 = inferredDtype !== "string" ? toTypedArray(x, inferredDtype) : flatten2(x, [], skipTypedArray);
    return ENGINE.makeTensor(values2, inferredShape, inferredDtype);
  }
  function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
    if (!Array.isArray(arg)) {
      throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);
    }
    const tensors = arg;
    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/operation.js
  var OP_SCOPE_SUFFIX = "__op";
  function op(f) {
    const keys2 = Object.keys(f);
    if (keys2.length !== 1) {
      throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys2.length} keys.`);
    }
    let opName = keys2[0];
    const fn = f[opName];
    if (opName.endsWith("_")) {
      opName = opName.substring(0, opName.length - 1);
    }
    opName = opName + OP_SCOPE_SUFFIX;
    const f2 = (...args) => {
      ENGINE.startScope(opName);
      try {
        const result = fn(...args);
        if (isPromise2(result)) {
          console.error("Cannot return a Promise inside of tidy.");
        }
        ENGINE.endScope(result);
        return result;
      } catch (ex) {
        ENGINE.endScope(null);
        throw ex;
      }
    };
    Object.defineProperty(f2, "name", { value: opName, configurable: true });
    return f2;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/complex.js
  function complex_(real4, imag4) {
    const $real = convertToTensor(real4, "real", "complex");
    const $imag = convertToTensor(imag4, "imag", "complex");
    assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
    const inputs = { real: $real, imag: $imag };
    return ENGINE.runKernel(Complex, inputs);
  }
  var complex = op({ complex_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js
  function makeTensor(values2, shape, inferredShape, dtype) {
    if (dtype == null) {
      dtype = inferDtype(values2);
    }
    if (dtype === "complex64") {
      throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
    }
    if (!isTypedArray(values2) && !Array.isArray(values2) && typeof values2 !== "number" && typeof values2 !== "boolean" && typeof values2 !== "string") {
      throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    }
    if (shape != null) {
      assertNonNegativeIntegerDimensions(shape);
      const providedSize = sizeFromShape(shape);
      const inferredSize = sizeFromShape(inferredShape);
      assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
      for (let i = 0; i < inferredShape.length; ++i) {
        const inferred = inferredShape[i];
        const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;
        assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
      }
    }
    if (!isTypedArray(values2) && !Array.isArray(values2)) {
      values2 = [values2];
    }
    shape = shape || inferredShape;
    values2 = dtype !== "string" ? toTypedArray(values2, dtype) : flatten2(values2, [], true);
    return ENGINE.makeTensor(values2, shape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor.js
  function tensor(values2, shape, dtype) {
    const inferredShape = inferShape(values2, dtype);
    return makeTensor(values2, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/types.js
  var DTYPE_VALUE_SIZE_MAP = {
    "float32": 4,
    "float16": 2,
    "int32": 4,
    "uint16": 2,
    "uint8": 1,
    "bool": 1,
    "complex64": 8
  };

  // node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js
  var NUM_BYTES_STRING_LENGTH = 4;
  async function encodeWeights(tensors, group2) {
    const specs = [];
    const dataPromises = [];
    const names = Array.isArray(tensors) ? tensors.map((tensor2) => tensor2.name) : Object.keys(tensors);
    for (let i = 0; i < names.length; ++i) {
      const name = names[i];
      const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];
      if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool" && t.dtype !== "string" && t.dtype !== "complex64") {
        throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
      }
      const spec = { name, shape: t.shape, dtype: t.dtype };
      if (t.dtype === "string") {
        const utf8bytes = new Promise(async (resolve) => {
          const vals = await t.bytes();
          const totalNumBytes = vals.reduce((p3, c) => p3 + c.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
          const bytes = new Uint8Array(totalNumBytes);
          let offset = 0;
          for (let i2 = 0; i2 < vals.length; i2++) {
            const val = vals[i2];
            const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
            bytes.set(bytesOfLength, offset);
            offset += NUM_BYTES_STRING_LENGTH;
            bytes.set(val, offset);
            offset += val.length;
          }
          resolve(bytes);
        });
        dataPromises.push(utf8bytes);
      } else {
        dataPromises.push(t.data());
      }
      if (group2 != null) {
        spec.group = group2;
      }
      specs.push(spec);
    }
    const tensorValues = await Promise.all(dataPromises);
    return { data: concatenateTypedArrays(tensorValues), specs };
  }
  function decodeWeights(buffer3, specs) {
    const out = {};
    let float16Decode;
    let offset = 0;
    for (const spec of specs) {
      const name = spec.name;
      const dtype = spec.dtype;
      const shape = spec.shape;
      const size3 = sizeFromShape(shape);
      let values2;
      if ("quantization" in spec) {
        const quantization = spec.quantization;
        if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
          if (!("min" in quantization && "scale" in quantization)) {
            throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`);
          }
        } else if (quantization.dtype === "float16") {
          if (dtype !== "float32") {
            throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`);
          }
        } else {
          throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
        }
        const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
        const byteBuffer = buffer3.slice(offset, offset + size3 * quantizationSizeFactor);
        const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
        if (dtype === "float32") {
          if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
            values2 = new Float32Array(quantizedArray.length);
            for (let i = 0; i < quantizedArray.length; i++) {
              const v = quantizedArray[i];
              values2[i] = v * quantization.scale + quantization.min;
            }
          } else if (quantization.dtype === "float16") {
            if (float16Decode === void 0) {
              float16Decode = getFloat16Decoder();
            }
            values2 = float16Decode(quantizedArray);
          } else {
            throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);
          }
        } else if (dtype === "int32") {
          if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
            throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);
          }
          values2 = new Int32Array(quantizedArray.length);
          for (let i = 0; i < quantizedArray.length; i++) {
            const v = quantizedArray[i];
            values2[i] = Math.round(v * quantization.scale + quantization.min);
          }
        } else {
          throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
        }
        offset += size3 * quantizationSizeFactor;
      } else if (dtype === "string") {
        const size4 = sizeFromShape(spec.shape);
        values2 = [];
        for (let i = 0; i < size4; i++) {
          const byteLength = new Uint32Array(buffer3.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
          offset += NUM_BYTES_STRING_LENGTH;
          const bytes = new Uint8Array(buffer3.slice(offset, offset + byteLength));
          values2.push(bytes);
          offset += byteLength;
        }
      } else {
        const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
        const byteBuffer = buffer3.slice(offset, offset + size3 * dtypeFactor);
        if (dtype === "float32") {
          values2 = new Float32Array(byteBuffer);
        } else if (dtype === "int32") {
          values2 = new Int32Array(byteBuffer);
        } else if (dtype === "bool") {
          values2 = new Uint8Array(byteBuffer);
        } else if (dtype === "complex64") {
          values2 = new Float32Array(byteBuffer);
          const real4 = new Float32Array(values2.length / 2);
          const image3 = new Float32Array(values2.length / 2);
          for (let i = 0; i < real4.length; i++) {
            real4[i] = values2[i * 2];
            image3[i] = values2[i * 2 + 1];
          }
          const realTensor = tensor(real4, shape, "float32");
          const imageTensor = tensor(image3, shape, "float32");
          out[name] = complex(realTensor, imageTensor);
          realTensor.dispose();
          imageTensor.dispose();
        } else {
          throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
        }
        offset += size3 * dtypeFactor;
      }
      if (dtype !== "complex64") {
        out[name] = tensor(values2, shape, dtype);
      }
    }
    return out;
  }
  function concatenateTypedArrays(xs) {
    if (xs === null) {
      throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
    }
    let totalByteLength = 0;
    const normalizedXs = [];
    xs.forEach((x) => {
      totalByteLength += x.byteLength;
      normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
      if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {
        throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
      }
    });
    const y = new Uint8Array(totalByteLength);
    let offset = 0;
    normalizedXs.forEach((x) => {
      y.set(new Uint8Array(x.buffer), offset);
      offset += x.byteLength;
    });
    return y.buffer;
  }
  var useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
  function stringByteLength(str4) {
    if (useNodeBuffer) {
      return Buffer.byteLength(str4);
    }
    return new Blob([str4]).size;
  }
  function arrayBufferToBase64String(buffer3) {
    if (useNodeBuffer) {
      return Buffer.from(buffer3).toString("base64");
    }
    const buf = new Uint8Array(buffer3);
    let s = "";
    for (let i = 0, l = buf.length; i < l; i++) {
      s += String.fromCharCode(buf[i]);
    }
    return btoa(s);
  }
  function base64StringToArrayBuffer(str4) {
    if (useNodeBuffer) {
      const buf = Buffer.from(str4, "base64");
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    const s = atob(str4);
    const buffer3 = new Uint8Array(s.length);
    for (let i = 0; i < s.length; ++i) {
      buffer3.set([s.charCodeAt(i)], i);
    }
    return buffer3.buffer;
  }
  function concatenateArrayBuffers(buffers) {
    if (buffers.length === 1) {
      return buffers[0];
    }
    let totalByteLength = 0;
    buffers.forEach((buffer3) => {
      totalByteLength += buffer3.byteLength;
    });
    const temp = new Uint8Array(totalByteLength);
    let offset = 0;
    buffers.forEach((buffer3) => {
      temp.set(new Uint8Array(buffer3), offset);
      offset += buffer3.byteLength;
    });
    return temp.buffer;
  }
  function basename(path) {
    const SEPARATOR = "/";
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
      path = path.slice(0, path.length - 1);
    }
    const items = path.split(SEPARATOR);
    return items[items.length - 1];
  }
  function getModelJSONForModelArtifacts(artifacts, manifest) {
    const result = {
      modelTopology: artifacts.modelTopology,
      format: artifacts.format,
      generatedBy: artifacts.generatedBy,
      convertedBy: artifacts.convertedBy,
      weightsManifest: manifest
    };
    if (artifacts.signature != null) {
      result.signature = artifacts.signature;
    }
    if (artifacts.userDefinedMetadata != null) {
      result.userDefinedMetadata = artifacts.userDefinedMetadata;
    }
    if (artifacts.modelInitializer != null) {
      result.modelInitializer = artifacts.modelInitializer;
    }
    if (artifacts.trainingConfig != null) {
      result.trainingConfig = artifacts.trainingConfig;
    }
    return result;
  }
  async function getModelArtifactsForJSON(modelJSON, loadWeights2) {
    const modelArtifacts = {
      modelTopology: modelJSON.modelTopology,
      format: modelJSON.format,
      generatedBy: modelJSON.generatedBy,
      convertedBy: modelJSON.convertedBy
    };
    if (modelJSON.trainingConfig != null) {
      modelArtifacts.trainingConfig = modelJSON.trainingConfig;
    }
    if (modelJSON.weightsManifest != null) {
      const [weightSpecs, weightData] = await loadWeights2(modelJSON.weightsManifest);
      modelArtifacts.weightSpecs = weightSpecs;
      modelArtifacts.weightData = weightData;
    }
    if (modelJSON.signature != null) {
      modelArtifacts.signature = modelJSON.signature;
    }
    if (modelJSON.userDefinedMetadata != null) {
      modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
    }
    if (modelJSON.modelInitializer != null) {
      modelArtifacts.modelInitializer = modelJSON.modelInitializer;
    }
    return modelArtifacts;
  }
  function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("Expected JSON model topology, received ArrayBuffer.");
    }
    return {
      dateSaved: new Date(),
      modelTopologyType: "JSON",
      modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
      weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
      weightDataBytes: modelArtifacts.weightData == null ? 0 : modelArtifacts.weightData.byteLength
    };
  }
  function computeFloat16MantisaTable() {
    const convertMantissa = (i) => {
      let m = i << 13;
      let e = 0;
      while ((m & 8388608) === 0) {
        e -= 8388608;
        m <<= 1;
      }
      m &= ~8388608;
      e += 947912704;
      return m | e;
    };
    const mantisaTable = new Uint32Array(2048);
    mantisaTable[0] = 0;
    for (let i = 1; i < 1024; i++) {
      mantisaTable[i] = convertMantissa(i);
    }
    for (let i = 1024; i < 2048; i++) {
      mantisaTable[i] = 939524096 + (i - 1024 << 13);
    }
    return mantisaTable;
  }
  function computeFloat16ExponentTable() {
    const exponentTable = new Uint32Array(64);
    exponentTable[0] = 0;
    exponentTable[31] = 1199570944;
    exponentTable[32] = 2147483648;
    exponentTable[63] = 3347054592;
    for (let i = 1; i < 31; i++) {
      exponentTable[i] = i << 23;
    }
    for (let i = 33; i < 63; i++) {
      exponentTable[i] = 2147483648 + (i - 32 << 23);
    }
    return exponentTable;
  }
  function computeFloat16OffsetTable() {
    const offsetTable = new Uint32Array(64);
    for (let i = 0; i < 64; i++) {
      offsetTable[i] = 1024;
    }
    offsetTable[0] = offsetTable[32] = 0;
    return offsetTable;
  }
  function getFloat16Decoder() {
    const mantisaTable = computeFloat16MantisaTable();
    const exponentTable = computeFloat16ExponentTable();
    const offsetTable = computeFloat16OffsetTable();
    return (quantizedArray) => {
      const buffer3 = new ArrayBuffer(4 * quantizedArray.length);
      const bufferUint32View = new Uint32Array(buffer3);
      for (let index = 0; index < quantizedArray.length; index++) {
        const float16Bits = quantizedArray[index];
        const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
        bufferUint32View[index] = float32Bits;
      }
      return new Float32Array(buffer3);
    };
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/router_registry.js
  var IORouterRegistry = class {
    constructor() {
      this.saveRouters = [];
      this.loadRouters = [];
    }
    static getInstance() {
      if (IORouterRegistry.instance == null) {
        IORouterRegistry.instance = new IORouterRegistry();
      }
      return IORouterRegistry.instance;
    }
    static registerSaveRouter(saveRouter) {
      IORouterRegistry.getInstance().saveRouters.push(saveRouter);
    }
    static registerLoadRouter(loadRouter) {
      IORouterRegistry.getInstance().loadRouters.push(loadRouter);
    }
    static getSaveHandlers(url) {
      return IORouterRegistry.getHandlers(url, "save");
    }
    static getLoadHandlers(url, loadOptions) {
      return IORouterRegistry.getHandlers(url, "load", loadOptions);
    }
    static getHandlers(url, handlerType, loadOptions) {
      const validHandlers = [];
      const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
      routers.forEach((router) => {
        const handler = router(url, loadOptions);
        if (handler !== null) {
          validHandlers.push(handler);
        }
      });
      return validHandlers;
    }
  };
  var registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);
  var registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);
  var getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);
  var getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);

  // node_modules/@tensorflow/tfjs-core/dist/io/indexed_db.js
  var DATABASE_NAME = "tensorflowjs";
  var DATABASE_VERSION = 1;
  var MODEL_STORE_NAME = "models_store";
  var INFO_STORE_NAME = "model_info_store";
  function getIndexedDBFactory() {
    if (!env().getBool("IS_BROWSER")) {
      throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    }
    const theWindow = typeof window === "undefined" ? self : window;
    const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
    if (factory == null) {
      throw new Error("The current browser does not appear to support IndexedDB.");
    }
    return factory;
  }
  function setUpDatabase(openRequest) {
    const db = openRequest.result;
    db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
    db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
  }
  var BrowserIndexedDB = class {
    constructor(modelPath) {
      this.indexedDB = getIndexedDBFactory();
      if (modelPath == null || !modelPath) {
        throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = modelPath;
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      }
      return this.databaseAction(this.modelPath, modelArtifacts);
    }
    async load() {
      return this.databaseAction(this.modelPath);
    }
    databaseAction(modelPath, modelArtifacts) {
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          if (modelArtifacts == null) {
            const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
            const getRequest = modelStore.get(this.modelPath);
            getRequest.onsuccess = () => {
              if (getRequest.result == null) {
                db.close();
                return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
              } else {
                resolve(getRequest.result.modelArtifacts);
              }
            };
            getRequest.onerror = (error) => {
              db.close();
              return reject(getRequest.error);
            };
            modelTx.oncomplete = () => db.close();
          } else {
            const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
            const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
            let infoStore = infoTx.objectStore(INFO_STORE_NAME);
            const putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
            let modelTx;
            putInfoRequest.onsuccess = () => {
              modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const putModelRequest = modelStore.put({
                modelPath: this.modelPath,
                modelArtifacts,
                modelArtifactsInfo
              });
              putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
              putModelRequest.onerror = (error) => {
                infoStore = infoTx.objectStore(INFO_STORE_NAME);
                const deleteInfoRequest = infoStore.delete(this.modelPath);
                deleteInfoRequest.onsuccess = () => {
                  db.close();
                  return reject(putModelRequest.error);
                };
                deleteInfoRequest.onerror = (error2) => {
                  db.close();
                  return reject(putModelRequest.error);
                };
              };
            };
            putInfoRequest.onerror = (error) => {
              db.close();
              return reject(putInfoRequest.error);
            };
            infoTx.oncomplete = () => {
              if (modelTx == null) {
                db.close();
              } else {
                modelTx.oncomplete = () => db.close();
              }
            };
          }
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
  };
  BrowserIndexedDB.URL_SCHEME = "indexeddb://";
  var indexedDBRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
        return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(indexedDBRouter);
  IORouterRegistry.registerLoadRouter(indexedDBRouter);
  function browserIndexedDB(modelPath) {
    return new BrowserIndexedDB(modelPath);
  }
  function maybeStripScheme(key) {
    return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
  }
  var BrowserIndexedDBManager = class {
    constructor() {
      this.indexedDB = getIndexedDBFactory();
    }
    async listModels() {
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          const tx = db.transaction(INFO_STORE_NAME, "readonly");
          const store = tx.objectStore(INFO_STORE_NAME);
          const getAllInfoRequest = store.getAll();
          getAllInfoRequest.onsuccess = () => {
            const out = {};
            for (const item of getAllInfoRequest.result) {
              out[item.modelPath] = item.modelArtifactsInfo;
            }
            resolve(out);
          };
          getAllInfoRequest.onerror = (error) => {
            db.close();
            return reject(getAllInfoRequest.error);
          };
          tx.oncomplete = () => db.close();
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
    async removeModel(path) {
      path = maybeStripScheme(path);
      return new Promise((resolve, reject) => {
        const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
        openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
        openRequest.onsuccess = () => {
          const db = openRequest.result;
          const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
          const infoStore = infoTx.objectStore(INFO_STORE_NAME);
          const getInfoRequest = infoStore.get(path);
          let modelTx;
          getInfoRequest.onsuccess = () => {
            if (getInfoRequest.result == null) {
              db.close();
              return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
            } else {
              const deleteInfoRequest = infoStore.delete(path);
              const deleteModelData = () => {
                modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
                const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
                const deleteModelRequest = modelStore.delete(path);
                deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
                deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
              };
              deleteInfoRequest.onsuccess = deleteModelData;
              deleteInfoRequest.onerror = (error) => {
                deleteModelData();
                db.close();
                return reject(getInfoRequest.error);
              };
            }
          };
          getInfoRequest.onerror = (error) => {
            db.close();
            return reject(getInfoRequest.error);
          };
          infoTx.oncomplete = () => {
            if (modelTx == null) {
              db.close();
            } else {
              modelTx.oncomplete = () => db.close();
            }
          };
        };
        openRequest.onerror = (error) => reject(openRequest.error);
      });
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/io/local_storage.js
  var PATH_SEPARATOR = "/";
  var PATH_PREFIX = "tensorflowjs_models";
  var INFO_SUFFIX = "info";
  var MODEL_TOPOLOGY_SUFFIX = "model_topology";
  var WEIGHT_SPECS_SUFFIX = "weight_specs";
  var WEIGHT_DATA_SUFFIX = "weight_data";
  var MODEL_METADATA_SUFFIX = "model_metadata";
  function getModelKeys(path) {
    return {
      info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
      topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
      weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
      weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
      modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
    };
  }
  function removeItems(keys2) {
    for (const key of Object.values(keys2)) {
      window.localStorage.removeItem(key);
    }
  }
  function getModelPathFromKey(key) {
    const items = key.split(PATH_SEPARATOR);
    if (items.length < 3) {
      throw new Error(`Invalid key format: ${key}`);
    }
    return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
  }
  function maybeStripScheme2(key) {
    return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
  }
  var BrowserLocalStorage = class {
    constructor(modelPath) {
      if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
        throw new Error("The current environment does not support local storage.");
      }
      this.LS = window.localStorage;
      if (modelPath == null || !modelPath) {
        throw new Error("For local storage, modelPath must not be null, undefined or empty.");
      }
      this.modelPath = modelPath;
      this.keys = getModelKeys(this.modelPath);
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
      } else {
        const topology = JSON.stringify(modelArtifacts.modelTopology);
        const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
        const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
        try {
          this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
          this.LS.setItem(this.keys.topology, topology);
          this.LS.setItem(this.keys.weightSpecs, weightSpecs);
          this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(modelArtifacts.weightData));
          const metadata = {
            format: modelArtifacts.format,
            generatedBy: modelArtifacts.generatedBy,
            convertedBy: modelArtifacts.convertedBy,
            signature: modelArtifacts.signature != null ? modelArtifacts.signature : void 0,
            userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : void 0,
            modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : void 0,
            trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : void 0
          };
          this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
          return { modelArtifactsInfo };
        } catch (err) {
          removeItems(this.keys);
          throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
        }
      }
    }
    async load() {
      const info = JSON.parse(this.LS.getItem(this.keys.info));
      if (info == null) {
        throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
      }
      if (info.modelTopologyType !== "JSON") {
        throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
      }
      const out = {};
      const topology = JSON.parse(this.LS.getItem(this.keys.topology));
      if (topology == null) {
        throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
      }
      out.modelTopology = topology;
      const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
      if (weightSpecs == null) {
        throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
      }
      out.weightSpecs = weightSpecs;
      const metadataString = this.LS.getItem(this.keys.modelMetadata);
      if (metadataString != null) {
        const metadata = JSON.parse(metadataString);
        out.format = metadata.format;
        out.generatedBy = metadata.generatedBy;
        out.convertedBy = metadata.convertedBy;
        if (metadata.signature != null) {
          out.signature = metadata.signature;
        }
        if (metadata.userDefinedMetadata != null) {
          out.userDefinedMetadata = metadata.userDefinedMetadata;
        }
        if (metadata.modelInitializer != null) {
          out.modelInitializer = metadata.modelInitializer;
        }
        if (metadata.trainingConfig != null) {
          out.trainingConfig = metadata.trainingConfig;
        }
      }
      const weightDataBase64 = this.LS.getItem(this.keys.weightData);
      if (weightDataBase64 == null) {
        throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
      }
      out.weightData = base64StringToArrayBuffer(weightDataBase64);
      return out;
    }
  };
  BrowserLocalStorage.URL_SCHEME = "localstorage://";
  var localStorageRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
        return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(localStorageRouter);
  IORouterRegistry.registerLoadRouter(localStorageRouter);
  function browserLocalStorage(modelPath) {
    return new BrowserLocalStorage(modelPath);
  }
  var BrowserLocalStorageManager = class {
    constructor() {
      assert(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
      assert(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
      this.LS = window.localStorage;
    }
    async listModels() {
      const out = {};
      const prefix = PATH_PREFIX + PATH_SEPARATOR;
      const suffix = PATH_SEPARATOR + INFO_SUFFIX;
      for (let i = 0; i < this.LS.length; ++i) {
        const key = this.LS.key(i);
        if (key.startsWith(prefix) && key.endsWith(suffix)) {
          const modelPath = getModelPathFromKey(key);
          out[modelPath] = JSON.parse(this.LS.getItem(key));
        }
      }
      return out;
    }
    async removeModel(path) {
      path = maybeStripScheme2(path);
      const keys2 = getModelKeys(path);
      if (this.LS.getItem(keys2.info) == null) {
        throw new Error(`Cannot find model at path '${path}'`);
      }
      const info = JSON.parse(this.LS.getItem(keys2.info));
      removeItems(keys2);
      return info;
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/io/model_management.js
  var URL_SCHEME_SUFFIX = "://";
  var ModelStoreManagerRegistry = class {
    constructor() {
      this.managers = {};
    }
    static getInstance() {
      if (ModelStoreManagerRegistry.instance == null) {
        ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
      }
      return ModelStoreManagerRegistry.instance;
    }
    static registerManager(scheme, manager) {
      assert(scheme != null, () => "scheme must not be undefined or null.");
      if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
        scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
      }
      assert(scheme.length > 0, () => "scheme must not be an empty string.");
      const registry = ModelStoreManagerRegistry.getInstance();
      assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
      registry.managers[scheme] = manager;
    }
    static getManager(scheme) {
      const manager = this.getInstance().managers[scheme];
      if (manager == null) {
        throw new Error(`Cannot find model manager for scheme '${scheme}'`);
      }
      return manager;
    }
    static getSchemes() {
      return Object.keys(this.getInstance().managers);
    }
  };
  function parseURL(url) {
    if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
      throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);
    }
    return {
      scheme: url.split(URL_SCHEME_SUFFIX)[0],
      path: url.split(URL_SCHEME_SUFFIX)[1]
    };
  }
  async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
    assert(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
    const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
    assert(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
    assert(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);
    const loadHandler = loadHandlers[0];
    const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
    assert(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination URL ${destURL}.`);
    assert(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);
    const saveHandler = saveHandlers[0];
    const sourceScheme = parseURL(sourceURL).scheme;
    const sourcePath = parseURL(sourceURL).path;
    const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
    const modelArtifacts = await loadHandler.load();
    if (deleteSource && sameMedium) {
      await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
    }
    const saveResult = await saveHandler.save(modelArtifacts);
    if (deleteSource && !sameMedium) {
      await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
    }
    return saveResult.modelArtifactsInfo;
  }
  async function listModels() {
    const schemes = ModelStoreManagerRegistry.getSchemes();
    const out = {};
    for (const scheme of schemes) {
      const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
      for (const path in schemeOut) {
        const url = scheme + URL_SCHEME_SUFFIX + path;
        out[url] = schemeOut[path];
      }
    }
    return out;
  }
  async function removeModel(url) {
    const schemeAndPath = parseURL(url);
    const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
    return manager.removeModel(schemeAndPath.path);
  }
  async function copyModel(sourceURL, destURL) {
    const deleteSource = false;
    return cloneModelInternal(sourceURL, destURL, deleteSource);
  }
  async function moveModel(sourceURL, destURL) {
    const deleteSource = true;
    return cloneModelInternal(sourceURL, destURL, deleteSource);
  }

  // node_modules/@tensorflow/tfjs-core/dist/platforms/platform_browser.js
  var PlatformBrowser = class {
    fetch(path, init) {
      return fetch(path, init);
    }
    now() {
      return performance.now();
    }
    encode(text, encoding) {
      if (encoding !== "utf-8" && encoding !== "utf8") {
        throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
      }
      if (this.textEncoder == null) {
        this.textEncoder = new TextEncoder();
      }
      return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
      return new TextDecoder(encoding).decode(bytes);
    }
  };
  if (env().get("IS_BROWSER")) {
    env().setPlatform("browser", new PlatformBrowser());
    try {
      ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
    } catch (err) {
    }
    try {
      ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
    } catch (err) {
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/platforms/platform_node.js
  var getNodeFetch = {
    importFetch: () => require_browser()
  };
  var systemFetch;
  var PlatformNode = class {
    constructor() {
      this.util = require_util();
      this.textEncoder = new this.util.TextEncoder();
    }
    fetch(path, requestInits) {
      if (env().global.fetch != null) {
        return env().global.fetch(path, requestInits);
      }
      if (systemFetch == null) {
        systemFetch = getNodeFetch.importFetch();
      }
      return systemFetch(path, requestInits);
    }
    now() {
      const time = process.hrtime();
      return time[0] * 1e3 + time[1] / 1e6;
    }
    encode(text, encoding) {
      if (encoding !== "utf-8" && encoding !== "utf8") {
        throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
      }
      return this.textEncoder.encode(text);
    }
    decode(bytes, encoding) {
      if (bytes.length === 0) {
        return "";
      }
      return new this.util.TextDecoder(encoding).decode(bytes);
    }
  };
  if (env().get("IS_NODE")) {
    env().setPlatform("node", new PlatformNode());
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/buffer.js
  function buffer2(shape, dtype = "float32", values2) {
    dtype = dtype || "float32";
    assertNonNegativeIntegerDimensions(shape);
    return new TensorBuffer(shape, dtype, values2);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/cast.js
  function cast_(x, dtype) {
    const $x = convertToTensor(x, "x", "cast");
    if (!isValidDtype(dtype)) {
      throw new Error(`Failed to cast to unknown dtype ${dtype}`);
    }
    if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
      throw new Error("Only strings can be casted to strings");
    }
    const inputs = { x: $x };
    const attrs = { dtype };
    return ENGINE.runKernel(Cast, inputs, attrs);
  }
  var cast = op({ cast_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/clone.js
  function clone_(x) {
    const $x = convertToTensor(x, "x", "clone", "string_or_numeric");
    const inputs = { x: $x };
    return ENGINE.runKernel(Identity2, inputs);
  }
  var clone5 = op({ clone_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/print.js
  function print(x, verbose = false) {
    console.log(x.toString(verbose));
  }

  // node_modules/@tensorflow/tfjs-core/dist/base_side_effects.js
  getOrMakeEngine();
  var opHandler2 = {
    buffer: buffer2,
    cast,
    clone: clone5,
    print
  };
  setOpHandler(opHandler2);

  // node_modules/@tensorflow/tfjs-core/dist/io/io.js
  var io_exports = {};
  __export(io_exports, {
    browserFiles: () => browserFiles,
    browserHTTPRequest: () => browserHTTPRequest,
    concatenateArrayBuffers: () => concatenateArrayBuffers,
    copyModel: () => copyModel,
    decodeWeights: () => decodeWeights,
    encodeWeights: () => encodeWeights,
    fromMemory: () => fromMemory,
    getLoadHandlers: () => getLoadHandlers,
    getModelArtifactsForJSON: () => getModelArtifactsForJSON,
    getModelArtifactsInfoForJSON: () => getModelArtifactsInfoForJSON,
    getSaveHandlers: () => getSaveHandlers,
    http: () => http,
    isHTTPScheme: () => isHTTPScheme,
    listModels: () => listModels,
    loadWeights: () => loadWeights,
    moveModel: () => moveModel,
    registerLoadRouter: () => registerLoadRouter,
    registerSaveRouter: () => registerSaveRouter,
    removeModel: () => removeModel,
    weightsLoaderFactory: () => weightsLoaderFactory,
    withSaveHandler: () => withSaveHandler
  });

  // node_modules/@tensorflow/tfjs-core/dist/io/browser_files.js
  var DEFAULT_FILE_NAME_PREFIX = "model";
  var DEFAULT_JSON_EXTENSION_NAME = ".json";
  var DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
  function defer(f) {
    return new Promise((resolve) => setTimeout(resolve)).then(f);
  }
  var BrowserDownloads = class {
    constructor(fileNamePrefix) {
      if (!env().getBool("IS_BROWSER")) {
        throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
      }
      if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
        fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
      }
      if (fileNamePrefix == null || fileNamePrefix.length === 0) {
        fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
      }
      this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
      this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
    }
    async save(modelArtifacts) {
      if (typeof document === "undefined") {
        throw new Error("Browser downloads are not supported in this environment since `document` is not present");
      }
      const weightsURL = window.URL.createObjectURL(new Blob([modelArtifacts.weightData], { type: "application/octet-stream" }));
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
      } else {
        const weightsManifest = [{
          paths: ["./" + this.weightDataFileName],
          weights: modelArtifacts.weightSpecs
        }];
        const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
        const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: "application/json" }));
        const jsonAnchor = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
        jsonAnchor.download = this.modelJsonFileName;
        jsonAnchor.href = modelJsonURL;
        await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
        if (modelArtifacts.weightData != null) {
          const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
          weightDataAnchor.download = this.weightDataFileName;
          weightDataAnchor.href = weightsURL;
          await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
        }
        return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
      }
    }
  };
  BrowserDownloads.URL_SCHEME = "downloads://";
  var BrowserFiles = class {
    constructor(files) {
      if (files == null || files.length < 1) {
        throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);
      }
      this.jsonFile = files[0];
      this.weightsFiles = files.slice(1);
    }
    async load() {
      return new Promise((resolve, reject) => {
        const jsonReader = new FileReader();
        jsonReader.onload = (event) => {
          const modelJSON = JSON.parse(event.target.result);
          const modelTopology = modelJSON.modelTopology;
          if (modelTopology == null) {
            reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
            return;
          }
          const weightsManifest = modelJSON.weightsManifest;
          if (weightsManifest == null) {
            reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
            return;
          }
          if (this.weightsFiles.length === 0) {
            resolve({ modelTopology });
            return;
          }
          const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
          resolve(modelArtifactsPromise);
        };
        jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
        jsonReader.readAsText(this.jsonFile);
      });
    }
    loadWeights(weightsManifest) {
      const weightSpecs = [];
      const paths = [];
      for (const entry of weightsManifest) {
        weightSpecs.push(...entry.weights);
        paths.push(...entry.paths);
      }
      const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
      const promises = paths.map((path) => this.loadWeightsFile(path, pathToFile[path]));
      return Promise.all(promises).then((buffers) => [weightSpecs, concatenateArrayBuffers(buffers)]);
    }
    loadWeightsFile(path, file) {
      return new Promise((resolve, reject) => {
        const weightFileReader = new FileReader();
        weightFileReader.onload = (event) => {
          const weightData = event.target.result;
          resolve(weightData);
        };
        weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
        weightFileReader.readAsArrayBuffer(file);
      });
    }
    checkManifestAndWeightFiles(manifest) {
      const basenames = [];
      const fileNames = this.weightsFiles.map((file) => basename(file.name));
      const pathToFile = {};
      for (const group2 of manifest) {
        group2.paths.forEach((path) => {
          const pathBasename = basename(path);
          if (basenames.indexOf(pathBasename) !== -1) {
            throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);
          }
          basenames.push(pathBasename);
          if (fileNames.indexOf(pathBasename) === -1) {
            throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
          } else {
            pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
          }
        });
      }
      if (basenames.length !== this.weightsFiles.length) {
        throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
      }
      return pathToFile;
    }
  };
  var browserDownloadsRouter = (url) => {
    if (!env().getBool("IS_BROWSER")) {
      return null;
    } else {
      if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
        return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
      } else {
        return null;
      }
    }
  };
  IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
  function browserDownloads(fileNamePrefix = "model") {
    return new BrowserDownloads(fileNamePrefix);
  }
  function browserFiles(files) {
    return new BrowserFiles(files);
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/progress.js
  function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
    checkPromises(promises);
    startFraction = startFraction == null ? 0 : startFraction;
    endFraction = endFraction == null ? 1 : endFraction;
    checkFraction(startFraction, endFraction);
    let resolvedPromise2 = 0;
    const registerMonitor = (promise) => {
      promise.then((value) => {
        const fraction = startFraction + ++resolvedPromise2 / promises.length * (endFraction - startFraction);
        onProgress(fraction);
        return value;
      });
      return promise;
    };
    function checkPromises(promises2) {
      assert(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
    }
    function checkFraction(startFraction2, endFraction2) {
      assert(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
      assert(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
      assert(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
    }
    return Promise.all(promises.map(registerMonitor));
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/weights_loader.js
  async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
    if (loadOptions == null) {
      loadOptions = {};
    }
    const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
    const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
    const fetchStartFraction = 0;
    const fetchEndFraction = 0.5;
    const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
    const bufferPromises = responses.map((response) => response.arrayBuffer());
    const bufferStartFraction = 0.5;
    const bufferEndFraction = 1;
    const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
    return buffers;
  }
  async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
    const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });
    const loadWeights2 = weightsLoaderFactory(fetchWeights);
    return loadWeights2(manifest, filePathPrefix, weightNames);
  }
  function weightsLoaderFactory(fetchWeightsFunction) {
    return async (manifest, filePathPrefix = "", weightNames) => {
      const groupIndicesToFetchMap = manifest.map(() => false);
      const groupWeightsToFetch = {};
      const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
      const allManifestWeightNames = [];
      manifest.forEach((manifestGroupConfig, groupIndex) => {
        let groupOffset = 0;
        manifestGroupConfig.weights.forEach((weightsEntry) => {
          const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
          const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape(weightsEntry.shape);
          const enqueueWeightsForFetchingFn = () => {
            groupIndicesToFetchMap[groupIndex] = true;
            if (groupWeightsToFetch[groupIndex] == null) {
              groupWeightsToFetch[groupIndex] = [];
            }
            groupWeightsToFetch[groupIndex].push({
              manifestEntry: weightsEntry,
              groupOffset,
              sizeBytes: weightsBytes
            });
          };
          if (weightNames != null) {
            weightNames.forEach((weightName, weightIndex) => {
              if (weightName === weightsEntry.name) {
                enqueueWeightsForFetchingFn();
                weightsFound[weightIndex] = true;
              }
            });
          } else {
            enqueueWeightsForFetchingFn();
          }
          allManifestWeightNames.push(weightsEntry.name);
          groupOffset += weightsBytes;
        });
      });
      if (!weightsFound.every((found) => found)) {
        const weightsNotFound = weightNames.filter((_6, i) => !weightsFound[i]);
        throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`);
      }
      const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {
        if (shouldFetch) {
          accumulator.push(i);
        }
        return accumulator;
      }, []);
      const fetchUrls = [];
      groupIndicesToFetch.forEach((i) => {
        manifest[i].paths.forEach((filepath) => {
          const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
          fetchUrls.push(fetchUrl);
        });
      });
      const buffers = await fetchWeightsFunction(fetchUrls);
      const weightsTensorMap = {};
      let bufferIndexOffset = 0;
      groupIndicesToFetch.forEach((i) => {
        const numBuffers = manifest[i].paths.length;
        let groupBytes = 0;
        for (let i2 = 0; i2 < numBuffers; i2++) {
          groupBytes += buffers[bufferIndexOffset + i2].byteLength;
        }
        const groupBuffer = new ArrayBuffer(groupBytes);
        const groupByteBuffer = new Uint8Array(groupBuffer);
        let groupBufferOffset = 0;
        for (let i2 = 0; i2 < numBuffers; i2++) {
          const buffer3 = new Uint8Array(buffers[bufferIndexOffset + i2]);
          groupByteBuffer.set(buffer3, groupBufferOffset);
          groupBufferOffset += buffer3.byteLength;
        }
        const weightsEntries = groupWeightsToFetch[i];
        weightsEntries.forEach((weightsEntry) => {
          const byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
          const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
          for (const name in nameToTensorMap) {
            weightsTensorMap[name] = nameToTensorMap[name];
          }
        });
        bufferIndexOffset += numBuffers;
      });
      return weightsTensorMap;
    };
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/http.js
  var OCTET_STREAM_MIME_TYPE = "application/octet-stream";
  var JSON_TYPE = "application/json";
  var HTTPRequest = class {
    constructor(path, loadOptions) {
      this.DEFAULT_METHOD = "POST";
      if (loadOptions == null) {
        loadOptions = {};
      }
      this.weightPathPrefix = loadOptions.weightPathPrefix;
      this.onProgress = loadOptions.onProgress;
      this.weightUrlConverter = loadOptions.weightUrlConverter;
      if (loadOptions.fetchFunc != null) {
        assert(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
        this.fetch = loadOptions.fetchFunc;
      } else {
        this.fetch = env().platform.fetch;
      }
      assert(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
      if (Array.isArray(path)) {
        assert(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
      }
      this.path = path;
      if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
        throw new Error("requestInit is expected to have no pre-existing body, but has one.");
      }
      this.requestInit = loadOptions.requestInit || {};
    }
    async save(modelArtifacts) {
      if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
      }
      const init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
      init.body = new FormData();
      const weightsManifest = [{
        paths: ["./model.weights.bin"],
        weights: modelArtifacts.weightSpecs
      }];
      const modelTopologyAndWeightManifest = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
      init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
      if (modelArtifacts.weightData != null) {
        init.body.append("model.weights.bin", new Blob([modelArtifacts.weightData], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
      }
      const response = await this.fetch(this.path, init);
      if (response.ok) {
        return {
          modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
          responses: [response]
        };
      } else {
        throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
      }
    }
    async load() {
      const modelConfigRequest = await this.fetch(this.path, this.requestInit);
      if (!modelConfigRequest.ok) {
        throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
      }
      let modelJSON;
      try {
        modelJSON = await modelConfigRequest.json();
      } catch (e) {
        let message = `Failed to parse model JSON of response from ${this.path}.`;
        if (this.path.endsWith(".pb")) {
          message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
        } else {
          message += " Please make sure the server is serving valid JSON for this request.";
        }
        throw new Error(message);
      }
      const modelTopology = modelJSON.modelTopology;
      const weightsManifest = modelJSON.weightsManifest;
      if (modelTopology == null && weightsManifest == null) {
        throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
      }
      return getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
    }
    async loadWeights(weightsManifest) {
      const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
      const [prefix, suffix] = parseUrl(weightPath);
      const pathPrefix = this.weightPathPrefix || prefix;
      const weightSpecs = [];
      for (const entry of weightsManifest) {
        weightSpecs.push(...entry.weights);
      }
      const fetchURLs = [];
      const urlPromises = [];
      for (const weightsGroup of weightsManifest) {
        for (const path of weightsGroup.paths) {
          if (this.weightUrlConverter != null) {
            urlPromises.push(this.weightUrlConverter(path));
          } else {
            fetchURLs.push(pathPrefix + path + suffix);
          }
        }
      }
      if (this.weightUrlConverter) {
        fetchURLs.push(...await Promise.all(urlPromises));
      }
      const buffers = await loadWeightsAsArrayBuffer(fetchURLs, {
        requestInit: this.requestInit,
        fetchFunc: this.fetch,
        onProgress: this.onProgress
      });
      return [weightSpecs, concatenateArrayBuffers(buffers)];
    }
  };
  HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
  function parseUrl(url) {
    const lastSlash = url.lastIndexOf("/");
    const lastSearchParam = url.lastIndexOf("?");
    const prefix = url.substring(0, lastSlash);
    const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
    return [prefix + "/", suffix];
  }
  function isHTTPScheme(url) {
    return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
  }
  var httpRouter = (url, loadOptions) => {
    if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
      return null;
    } else {
      let isHTTP = true;
      if (Array.isArray(url)) {
        isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
      } else {
        isHTTP = isHTTPScheme(url);
      }
      if (isHTTP) {
        return http(url, loadOptions);
      }
    }
    return null;
  };
  IORouterRegistry.registerSaveRouter(httpRouter);
  IORouterRegistry.registerLoadRouter(httpRouter);
  function http(path, loadOptions) {
    return new HTTPRequest(path, loadOptions);
  }
  function browserHTTPRequest(path, loadOptions) {
    return http(path, loadOptions);
  }

  // node_modules/@tensorflow/tfjs-core/dist/io/passthrough.js
  var PassthroughLoader = class {
    constructor(modelArtifacts) {
      this.modelArtifacts = modelArtifacts;
    }
    async load() {
      return this.modelArtifacts;
    }
  };
  var PassthroughSaver = class {
    constructor(saveHandler) {
      this.saveHandler = saveHandler;
    }
    async save(modelArtifacts) {
      return this.saveHandler(modelArtifacts);
    }
  };
  function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
    if (arguments.length === 1) {
      const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
      if (isModelArtifacts) {
        return new PassthroughLoader(modelArtifacts);
      } else {
        console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
        return new PassthroughLoader({ modelTopology: modelArtifacts });
      }
    } else {
      console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
      return new PassthroughLoader({
        modelTopology: modelArtifacts,
        weightSpecs,
        weightData,
        trainingConfig
      });
    }
  }
  function withSaveHandler(saveHandler) {
    return new PassthroughSaver(saveHandler);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/mat_mul.js
  function matMul_(a, b, transposeA = false, transposeB = false) {
    let $a = convertToTensor(a, "a", "matMul");
    let $b = convertToTensor(b, "b", "matMul");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    const attrs = { transposeA, transposeB };
    return ENGINE.runKernel(BatchMatMul, inputs, attrs);
  }
  var matMul = op({ matMul_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/one_hot.js
  function oneHot_(indices, depth, onValue = 1, offValue = 0) {
    if (depth < 2) {
      throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
    }
    const $indices = convertToTensor(indices, "indices", "oneHot", "int32");
    const inputs = { indices: $indices };
    const attrs = { depth, onValue, offValue };
    return ENGINE.runKernel(OneHot, inputs, attrs);
  }
  var oneHot = op({ oneHot_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/transpose.js
  function transpose_(x, perm) {
    const $x = convertToTensor(x, "x", "transpose");
    if (perm == null) {
      perm = $x.shape.map((s, i) => i).reverse();
    }
    assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
    perm.forEach((axis) => {
      assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
    });
    if ($x.rank <= 1) {
      return $x.clone();
    }
    const inputs = { x: $x };
    const attrs = { perm };
    return ENGINE.runKernel(Transpose, inputs, attrs);
  }
  var transpose2 = op({ transpose_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd_util.js
  function prepareAndValidate(tensor2, indices) {
    const tensorRank = tensor2.shape.length;
    const indicesRank = indices.shape.length;
    if (tensorRank < 1) {
      throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensorRank}.`);
    }
    if (indicesRank < 1) {
      throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indicesRank}.`);
    }
    if (indices.dtype !== "int32") {
      throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
    }
    if (indices.shape[indicesRank - 1] > tensorRank) {
      throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
    }
    if (sizeFromShape(tensor2.shape) === 0) {
      throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor2.shape}.`);
    }
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    let nResult = 1;
    for (let i = 0; i < indicesShape.length - 1; ++i) {
      nResult *= indicesShape[i];
    }
    const inputShape = tensor2.shape;
    const resultShape = indicesShape.slice();
    resultShape.pop();
    let sliceSize = 1;
    for (let i = sliceRank; i < tensorRank; ++i) {
      sliceSize *= inputShape[i];
      resultShape.push(inputShape[i]);
    }
    const strides = [
      ...computeStrides(tensor2.shape).map((stride) => stride / sliceSize),
      1
    ].slice(0, sliceRank);
    return [resultShape, nResult, sliceSize, strides];
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd_util.js
  function validateUpdateShape(shape, indices, updates) {
    const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
    const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
    const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
    if (updates.rank < batchDim) {
      throw new Error(shapeError + ` update.rank < ${batchDim}. `);
    }
    if (shape.length < sliceDim + (updates.rank - batchDim)) {
      throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
    }
    if (updates.rank !== batchDim + shape.length - sliceDim) {
      throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
    }
    for (let d = 0; d < batchDim; ++d) {
      if (updates.shape[d] !== indices.shape[d]) {
        throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
      }
    }
    for (let d = 0; d < updates.rank - batchDim; ++d) {
      if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
        throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
      }
    }
  }
  function validateInput(updates, indices, shape) {
    if (indices.rank < 1) {
      throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
    }
    if (updates.rank < 1) {
      throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
    }
    if (indices.dtype !== "int32") {
      throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
    }
    if (shape.length < 1) {
      throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
    }
    if (shape.length === 0) {
      if (indices.size === 0) {
        throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
      }
      if (updates.size === 0) {
        throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
      }
    }
    validateUpdateShape(shape, indices, updates);
  }
  function calculateShapes(updates, indices, shape) {
    const indicesRank = indices.shape.length;
    const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
    const totalNd = shape.length;
    let sliceSize = 1;
    for (let i = sliceRank; i < totalNd; ++i) {
      sliceSize *= shape[i];
    }
    const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
    const outputSize = sizeFromShape(shape);
    return { sliceRank, numUpdates, sliceSize, strides, outputSize };
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice_util.js
  var slice_util_exports = {};
  __export(slice_util_exports, {
    assertParamsValid: () => assertParamsValid,
    computeFlatOffset: () => computeFlatOffset,
    computeOutShape: () => computeOutShape,
    getNormalizedAxes: () => getNormalizedAxes,
    isSliceContinous: () => isSliceContinous,
    maskToAxes: () => maskToAxes,
    parseSliceParams: () => parseSliceParams,
    sliceInfo: () => sliceInfo,
    startForAxis: () => startForAxis,
    startIndicesWithElidedDims: () => startIndicesWithElidedDims,
    stopForAxis: () => stopForAxis,
    stopIndicesWithElidedDims: () => stopIndicesWithElidedDims,
    stridesForAxis: () => stridesForAxis,
    stridesWithElidedDims: () => stridesWithElidedDims
  });
  var NEW_AXIS = -2;
  var SHRINK_AXIS = -1;
  function assertParamsValid(input2, begin, size3) {
    const inputRank = input2.shape.length;
    assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
    assert(inputRank === size3.length, () => `Error in slice${inputRank}D: Length of size ${size3} must match the rank of the array (${inputRank}).`);
    for (let i = 0; i < inputRank; ++i) {
      assert(begin[i] + size3[i] <= input2.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i] + size3[i]}) would overflow input.shape[${i}] (${input2.shape[i]})`);
    }
  }
  function maskToAxes(mask) {
    const axes = [];
    let axis = 0;
    while (mask > 0) {
      if (mask & 1) {
        axes.push(axis);
      }
      mask /= 2;
      axis++;
    }
    return axes;
  }
  function computeOutShape(begin, end, strides) {
    const size3 = [];
    for (let axis = 0; axis < begin.length; axis++) {
      size3[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
    }
    return size3;
  }
  function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
    const newStrides = [...strides];
    for (let i = newStrides.length; i < inputShape.length; i++) {
      newStrides.push(1);
    }
    for (let i = 0; i < numElidedAxes; i++) {
      if (i === 0) {
        newStrides[ellipsisInsertionIndex] = 1;
      } else {
        newStrides.splice(ellipsisInsertionIndex, 0, 1);
        newStrides.pop();
      }
    }
    return newStrides;
  }
  function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
    if (normalizedAxis <= ellipsisInsertionIndex) {
      return normalizedAxis;
    }
    return normalizedAxis - (numElidedAxes - 1);
  }
  function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
    const elidedAxes = [];
    for (let i = 0; i < numElidedAxes; i++) {
      elidedAxes.push(ellipsisInsertionIndex + i);
    }
    return elidedAxes;
  }
  function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
    const inputRank = inputShape.length;
    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
    if (ellipsisAxes.length && numInterpolatedAxes > 0) {
      const fullIndex = ellipsisAxes[0];
      const numElidedAxes = numInterpolatedAxes + 1;
      normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
      normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
      normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
    } else {
      for (let axis = 0; axis < inputRank; axis++) {
        normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
        normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
        normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
      }
    }
    return {
      begin: normalizedBegin,
      end: normalizedEnd,
      strides: normalizedStrides
    };
  }
  function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
      if (elidedAxes.indexOf(axis) > -1) {
        newIndices[axis] = 0;
      } else {
        const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalBegin[originalAxis];
        if (beginMask & 1 << originalAxis) {
          originalValue = 0;
        }
        newIndices[axis] = originalValue;
      }
    }
    return newIndices;
  }
  function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
    const newIndices = [...inputShape];
    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
    for (let axis = 0; axis < newIndices.length; axis++) {
      if (elidedAxes.indexOf(axis) > -1) {
        newIndices[axis] = Number.MAX_SAFE_INTEGER;
      } else {
        const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
        let originalValue = originalEnd[originalAxis];
        if (endMask & 1 << originalAxis) {
          originalValue = Number.MAX_SAFE_INTEGER;
        }
        newIndices[axis] = originalValue;
      }
    }
    for (let i = 0; i < newIndices.length; i++) {
      const axisSize = inputShape[i];
      if (newIndices[i] < 0) {
        newIndices[i] += axisSize;
      }
      newIndices[i] = clamp2(0, newIndices[i], inputShape[i]);
    }
    return newIndices;
  }
  function stridesForAxis(strides, axis, ellipsisMask) {
    let stride = strides[axis];
    if (ellipsisMask & 1 << axis || stride == null) {
      stride = 1;
    }
    return stride;
  }
  function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
    let start = startIndices[axis];
    const stride = strides[axis] || 1;
    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
      if (stride > 0) {
        start = Number.MIN_SAFE_INTEGER;
      } else {
        start = Number.MAX_SAFE_INTEGER;
      }
    }
    const axisSize = inputShape[axis];
    if (start < 0) {
      start += axisSize;
    }
    start = clamp2(0, start, axisSize - 1);
    return start;
  }
  function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
    let stop2 = stopIndices[axis];
    const stride = strides[axis] || 1;
    if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop2 == null) {
      if (stride > 0) {
        stop2 = Number.MAX_SAFE_INTEGER;
      } else {
        stop2 = Number.MIN_SAFE_INTEGER;
      }
    }
    const axisSize = inputShape[axis];
    if (stop2 < 0) {
      stop2 += axisSize;
    }
    if (stride > 0) {
      stop2 = clamp2(0, stop2, axisSize);
    } else {
      stop2 = clamp2(-1, stop2, axisSize - 1);
    }
    return stop2;
  }
  function isSliceContinous(shape, begin, size3) {
    let firstNonOneAxis = size3.length;
    for (let i = 0; i < size3.length; i++) {
      if (size3[i] > 1) {
        firstNonOneAxis = i;
        break;
      }
    }
    for (let i = firstNonOneAxis + 1; i < size3.length; i++) {
      if (begin[i] > 0 || size3[i] !== shape[i]) {
        return false;
      }
    }
    return true;
  }
  function computeFlatOffset(begin, strides) {
    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
    for (let i = 0; i < begin.length - 1; i++) {
      flatOffset += begin[i] * strides[i];
    }
    return flatOffset;
  }
  function parseSliceParams(x, begin, size3) {
    let begin_;
    const xRank = x.shape.length;
    if (typeof begin === "number") {
      begin_ = [begin, ...new Array(xRank - 1).fill(0)];
    } else if (begin.length < xRank) {
      begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
    } else {
      begin_ = begin.slice();
    }
    begin_.forEach((d) => {
      assert(d !== -1, () => "slice() does not support negative begin indexing.");
    });
    let size_;
    if (size3 == null) {
      size_ = new Array(xRank).fill(-1);
    } else if (typeof size3 === "number") {
      size_ = [size3, ...new Array(xRank - 1).fill(-1)];
    } else if (size3.length < xRank) {
      size_ = size3.concat(new Array(xRank - size3.length).fill(-1));
    } else {
      size_ = size3;
    }
    size_ = size_.map((d, i) => {
      if (d >= 0) {
        return d;
      } else {
        assert(d === -1, () => `Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`);
        return x.shape[i] - begin_[i];
      }
    });
    return [begin_, size_];
  }
  function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    let stridesNonNull;
    if (strides == null) {
      stridesNonNull = new Array(begin.length);
      stridesNonNull.fill(1);
    } else {
      stridesNonNull = strides;
    }
    if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {
      throw new Error("Multiple ellipses in slice is not allowed.");
    }
    let ellipsisSeen = false;
    const sparseSpec = {
      dims: stridesNonNull.length,
      numAddAxisAfterEllipsis: 0,
      begin: begin.slice(),
      end: end.slice(),
      strides: stridesNonNull.slice(),
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask
    };
    for (let i = 0; i < sparseSpec.dims; i++) {
      if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {
        sparseSpec.numAddAxisAfterEllipsis++;
      }
      if (1 << i & ellipsisMask) {
        ellipsisSeen = true;
      }
    }
    if (!ellipsisSeen) {
      sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;
      sparseSpec.dims++;
    }
    const denseSpec = {
      dims: xShape.length,
      beginMask: 0,
      endMask: 0,
      beginValid: false,
      endValid: false
    };
    buildDenseSpec(sparseSpec, denseSpec);
    let isIdentity = true;
    let sliceDim0 = true;
    let isSimpleSlice = true;
    const processingShape = [];
    const finalShape = [];
    for (let i = 0; i < xShape.length; ++i) {
      if (denseSpec.strides[i] === 0) {
        throw Error(`strides[${i}] must be non-zero`);
      }
      const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i);
      const dimI = xShape[i];
      if (dimI === -1) {
        processingShape.push(shrinkI ? 1 : -1);
        continue;
      }
      const masks = [denseSpec.beginMask & 1 << i, denseSpec.endMask & 1 << i];
      const validRange = [
        denseSpec.strides[i] > 0 ? 0 : -1,
        denseSpec.strides[i] > 0 ? dimI : dimI - 1
      ];
      if (shrinkI && denseSpec.strides[i] <= 0) {
        throw Error("only stride 1 allowed on non-range indexing.");
      }
      isSimpleSlice = isSimpleSlice && denseSpec.strides[i] === 1;
      const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i && denseSpec.endMask & 1 << i);
      if (denseSpec.beginValid && denseSpec.endValid) {
        if (shrinkI) {
          const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] : denseSpec.begin[i];
          denseSpec.begin[i] = xFwd;
          denseSpec.end[i] = denseSpec.begin[i] + 1;
          if (xFwd < 0 || xFwd >= dimI) {
            throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);
          }
        } else {
          denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);
          denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);
        }
        const takeAllInDimension = denseSpec.strides[i] === 1 && denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;
        isIdentity = isIdentity && takeAllInDimension;
        sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || takeAllInDimension);
      } else {
        isIdentity = isIdentity && (denseSpec.strides[i] === 1 && beginAndEndMasked);
        sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || beginAndEndMasked);
      }
      let intervalLength;
      let knownInterval = false;
      if (denseSpec.beginValid && denseSpec.endValid) {
        intervalLength = denseSpec.end[i] - denseSpec.begin[i];
        knownInterval = true;
      } else if (shrinkI) {
        intervalLength = 1;
        knownInterval = true;
      } else if (beginAndEndMasked) {
        if (dimI >= 0) {
          if (denseSpec.strides[i] < 0) {
            intervalLength = -dimI;
          } else {
            intervalLength = dimI;
          }
          knownInterval = true;
        }
      }
      if (knownInterval) {
        let sizeI;
        if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i] < 0) {
          sizeI = 0;
        } else {
          sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) + (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);
        }
        processingShape.push(sizeI);
      } else {
        processingShape.push(-1);
      }
    }
    for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {
      const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];
      if (gatherIndex >= 0) {
        finalShape.push(processingShape[gatherIndex]);
      } else if (gatherIndex === NEW_AXIS) {
        finalShape.push(1);
      }
    }
    const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);
    return {
      finalShapeSparse,
      finalShape,
      isIdentity,
      sliceDim0,
      isSimpleSlice,
      begin: denseSpec.begin,
      end: denseSpec.end,
      strides: denseSpec.strides
    };
  }
  function buildDenseSpec(sparse2, dense) {
    dense.beginMask = 0;
    dense.endMask = 0;
    dense.shrinkAxisMask = 0;
    let fullIndex = 0;
    dense.beginValid = sparse2.begin != null;
    dense.endValid = sparse2.end != null;
    dense.begin = new Array(dense.dims);
    dense.end = new Array(dense.dims);
    dense.strides = new Array(dense.dims);
    dense.finalShapeGatherIndices = [];
    dense.finalShapeGatherIndicesSparse = [];
    dense.inputShapeGatherIndicesSparse = new Array(dense.dims);
    for (let i = 0; i < sparse2.dims; i++) {
      if (1 << i & sparse2.ellipsisMask) {
        const nextIndex = Math.min(dense.dims - (sparse2.dims - i) + 1 + sparse2.numAddAxisAfterEllipsis, dense.dims);
        for (; fullIndex < nextIndex; fullIndex++) {
          dense.begin[fullIndex] = 0;
          dense.end[fullIndex] = 0;
          dense.strides[fullIndex] = 1;
          dense.beginMask |= 1 << fullIndex;
          dense.endMask |= 1 << fullIndex;
          dense.finalShapeGatherIndices.push(fullIndex);
          dense.finalShapeGatherIndicesSparse.push(-1);
          dense.inputShapeGatherIndicesSparse[fullIndex] = i;
        }
      } else if (1 << i & sparse2.newAxisMask) {
        dense.finalShapeGatherIndices.push(NEW_AXIS);
        dense.finalShapeGatherIndicesSparse.push(-1);
      } else {
        if (fullIndex === dense.begin.length) {
          throw Error(`Index out of range using input dim ${fullIndex}; input has only ${dense.dims} dims, ${dense.begin.length}.`);
        }
        if (sparse2.begin != null) {
          dense.begin[fullIndex] = sparse2.begin[i];
        }
        if (sparse2.end != null) {
          dense.end[fullIndex] = sparse2.end[i];
        }
        dense.strides[fullIndex] = sparse2.strides[i];
        if (sparse2.beginMask & 1 << i) {
          dense.beginMask |= 1 << fullIndex;
        }
        if (sparse2.endMask & 1 << i) {
          dense.endMask |= 1 << fullIndex;
        }
        if (sparse2.shrinkAxisMask & 1 << i) {
          dense.finalShapeGatherIndices.push(SHRINK_AXIS);
          dense.finalShapeGatherIndicesSparse.push(-1);
          dense.shrinkAxisMask |= 1 << fullIndex;
        } else {
          dense.finalShapeGatherIndices.push(fullIndex);
          dense.finalShapeGatherIndicesSparse.push(i);
        }
        dense.inputShapeGatherIndicesSparse[fullIndex] = i;
        fullIndex++;
      }
    }
  }
  function canonical(x, c, strideI, dimI, masks, validRange) {
    if (masks[c]) {
      return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];
    } else {
      const xFwd = x < 0 ? dimI + x : x;
      return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/serialization.js
  var serialization_exports = {};
  __export(serialization_exports, {
    Serializable: () => Serializable,
    SerializationMap: () => SerializationMap,
    registerClass: () => registerClass2
  });
  var Serializable = class {
    getClassName() {
      return this.constructor.className;
    }
    static fromConfig(cls, config) {
      return new cls(config);
    }
  };
  var SerializationMap = class {
    constructor() {
      this.classNameMap = {};
    }
    static getMap() {
      if (SerializationMap.instance == null) {
        SerializationMap.instance = new SerializationMap();
      }
      return SerializationMap.instance;
    }
    static register(cls) {
      SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
    }
  };
  function registerClass2(cls) {
    assert(cls.className != null, () => `Class being registered does not have the static className property defined.`);
    assert(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
    assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, which is disallowed.`);
    SerializationMap.register(cls);
  }

  // node_modules/@tensorflow/tfjs-core/dist/globals.js
  function deprecationWarn(msg) {
    if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
      console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
    }
  }
  setDeprecationWarningFn(deprecationWarn);
  function engine() {
    return ENGINE;
  }
  function memory() {
    return ENGINE.memory();
  }
  function tidy(nameOrFn, fn) {
    return ENGINE.tidy(nameOrFn, fn);
  }
  function dispose(container) {
    const tensors = getTensorsInContainer(container);
    tensors.forEach((tensor2) => tensor2.dispose());
  }
  function keep(result) {
    return ENGINE.keep(result);
  }
  function registerBackend(name, factory, priority = 1) {
    return ENGINE.registerBackend(name, factory, priority);
  }
  function backend() {
    return ENGINE.backend;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/add.js
  function add_(a, b) {
    let $a = convertToTensor(a, "a", "add");
    let $b = convertToTensor(b, "b", "add");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Add, inputs);
  }
  var add6 = op({ add_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/floorDiv.js
  function floorDiv_(a, b) {
    let $a = convertToTensor(a, "a", "floorDiv");
    let $b = convertToTensor(b, "b", "floorDiv");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(FloorDiv, inputs);
  }
  var floorDiv = op({ floorDiv_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/div.js
  function div_(a, b) {
    let $a = convertToTensor(a, "a", "div");
    let $b = convertToTensor(b, "b", "div");
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === "int32" && $b.dtype === "int32") {
      return floorDiv($a, $b);
    }
    const inputs = { a: $a, b: $b };
    const attrs = {};
    return ENGINE.runKernel(RealDiv, inputs, attrs);
  }
  var div3 = op({ div_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mul.js
  function mul_(a, b) {
    let $a = convertToTensor(a, "a", "mul");
    let $b = convertToTensor(b, "b", "mul");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Multiply, inputs);
  }
  var mul4 = op({ mul_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/abs.js
  function abs_(x) {
    const $x = convertToTensor(x, "x", "abs");
    if ($x.dtype === "complex64") {
      const inputs = { x: $x };
      return ENGINE.runKernel(ComplexAbs, inputs);
    } else {
      const inputs = { x: $x };
      return ENGINE.runKernel(Abs, inputs);
    }
  }
  var abs = op({ abs_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/acos.js
  function acos_(x) {
    const $x = convertToTensor(x, "x", "acos");
    const inputs = { x: $x };
    return ENGINE.runKernel(Acos, inputs);
  }
  var acos = op({ acos_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/acosh.js
  function acosh_(x) {
    const $x = convertToTensor(x, "x", "acosh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Acosh, inputs);
  }
  var acosh = op({ acosh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/all.js
  function all_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "all", "bool");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(All, inputs, attrs);
  }
  var all = op({ all_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/any.js
  function any_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "any", "bool");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Any, inputs, attrs);
  }
  var any = op({ any_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/arg_max.js
  function argMax_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "argMax");
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMax, inputs, attrs);
  }
  var argMax = op({ argMax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/arg_min.js
  function argMin_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "argMin");
    const inputs = { x: $x };
    const attrs = { axis };
    return ENGINE.runKernel(ArgMin, inputs, attrs);
  }
  var argMin = op({ argMin_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/asin.js
  function asin_(x) {
    const $x = convertToTensor(x, "x", "asin");
    const inputs = { x: $x };
    return ENGINE.runKernel(Asin, inputs);
  }
  var asin = op({ asin_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/asinh.js
  function asinh_(x) {
    const $x = convertToTensor(x, "x", "asinh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Asinh, inputs);
  }
  var asinh = op({ asinh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/atan.js
  function atan_(x) {
    const $x = convertToTensor(x, "x", "atan");
    const inputs = { x: $x };
    return ENGINE.runKernel(Atan, inputs);
  }
  var atan = op({ atan_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/atan2.js
  function atan2_(a, b) {
    let $a = convertToTensor(a, "a", "atan2");
    let $b = convertToTensor(b, "b", "atan2");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Atan2, inputs);
  }
  var atan22 = op({ atan2_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/atanh.js
  function atanh_(x) {
    const $x = convertToTensor(x, "x", "atanh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Atanh, inputs);
  }
  var atanh = op({ atanh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv_util.js
  function computeDilation2DInfo(inputShape, filterShape, strides, pad3, dataFormat = "NHWC", dilations) {
    const inputChannels = inputShape[3];
    const $filterShape = [...filterShape, inputChannels];
    const $dataFormat = convertConv2DDataFormat(dataFormat);
    return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad3, null, null, $dataFormat);
  }
  function computePool2DInfo(inShape, filterSize, strides, dilations, pad3, roundingMode, dataFormat = "channelsLast") {
    const [filterHeight, filterWidth] = parseTupleParam(filterSize);
    let filterShape;
    if (dataFormat === "channelsLast") {
      filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    } else if (dataFormat === "channelsFirst") {
      filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad3, roundingMode, false, dataFormat);
  }
  function computePool3DInfo(inShape, filterSize, strides, dilations, pad3, roundingMode, dataFormat = "NDHWC") {
    const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
    let filterShape;
    let $dataFormat;
    if (dataFormat === "NDHWC") {
      $dataFormat = "channelsLast";
      filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
    } else if (dataFormat === "NCDHW") {
      $dataFormat = "channelsFirst";
      filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    return computeConv3DInfo(inShape, filterShape, strides, dilations, pad3, false, $dataFormat, roundingMode);
  }
  function computeConv2DInfo(inShape, filterShape, strides, dilations, pad3, roundingMode, depthwise = false, dataFormat = "channelsLast") {
    let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
    if (dataFormat === "channelsLast") {
      [batchSize, inHeight, inWidth, inChannels] = inShape;
    } else if (dataFormat === "channelsFirst") {
      [batchSize, inChannels, inHeight, inWidth] = inShape;
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideHeight, strideWidth] = parseTupleParam(strides);
    const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad3, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === "channelsFirst") {
      outShape = [batchSize, outChannels, outHeight, outWidth];
    } else if (dataFormat === "channelsLast") {
      outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
      batchSize,
      dataFormat,
      inHeight,
      inWidth,
      inChannels,
      outHeight,
      outWidth,
      outChannels,
      padInfo,
      strideHeight,
      strideWidth,
      filterHeight,
      filterWidth,
      effectiveFilterHeight,
      effectiveFilterWidth,
      dilationHeight,
      dilationWidth,
      inShape,
      outShape,
      filterShape
    };
  }
  function computeConv3DInfo(inShape, filterShape, strides, dilations, pad3, depthwise = false, dataFormat = "channelsLast", roundingMode) {
    let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
    if (dataFormat === "channelsLast") {
      [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
    } else if (dataFormat === "channelsFirst") {
      [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
    const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
    const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
    const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
    const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
    const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad3, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
    const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    let outShape;
    if (dataFormat === "channelsFirst") {
      outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
    } else if (dataFormat === "channelsLast") {
      outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
    }
    return {
      batchSize,
      dataFormat,
      inDepth,
      inHeight,
      inWidth,
      inChannels,
      outDepth,
      outHeight,
      outWidth,
      outChannels,
      padInfo,
      strideDepth,
      strideHeight,
      strideWidth,
      filterDepth,
      filterHeight,
      filterWidth,
      effectiveFilterDepth,
      effectiveFilterHeight,
      effectiveFilterWidth,
      dilationDepth,
      dilationHeight,
      dilationWidth,
      inShape,
      outShape,
      filterShape
    };
  }
  function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
      zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    const inputRows = inShape[0];
    const inputCols = inShape[1];
    const outputRows = round4((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = round4((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [outputRows, outputCols];
  }
  function computeOutputShape4D(inShape, fieldSize, outChannels, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
      zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    const inputDepth = inShape[0];
    const inputRows = inShape[1];
    const inputCols = inShape[2];
    const outputDepths = round4((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputRows = round4((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    const outputCols = round4((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    return [outputDepths, outputRows, outputCols, outChannels];
  }
  function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
    const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
    return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
  }
  function parseTupleParam(param) {
    if (typeof param === "number") {
      return [param, param, param];
    }
    if (param.length === 2) {
      return [param[0], param[1], 1];
    }
    return param;
  }
  function parse3TupleParam(param) {
    return typeof param === "number" ? [param, param, param] : param;
  }
  function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
      return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
  }
  function getPadAndOutInfo(pad3, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
    let padInfo;
    let outHeight;
    let outWidth;
    if (typeof pad3 === "number") {
      const padType = pad3 === 0 ? "VALID" : "NUMBER";
      padInfo = { top: pad3, bottom: pad3, left: pad3, right: pad3, type: padType };
      const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad3, roundingMode);
      outHeight = outShape[0];
      outWidth = outShape[1];
    } else if (pad3 === "same") {
      outHeight = Math.ceil(inHeight / strideHeight);
      outWidth = Math.ceil(inWidth / strideWidth);
      const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
      const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
      const top = Math.floor(padAlongHeight / 2);
      const bottom = padAlongHeight - top;
      const left = Math.floor(padAlongWidth / 2);
      const right = padAlongWidth - left;
      padInfo = { top, bottom, left, right, type: "SAME" };
    } else if (pad3 === "valid") {
      padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
      outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
      outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    } else if (typeof pad3 === "object") {
      const top = dataFormat === "channelsLast" ? pad3[1][0] : pad3[2][0];
      const bottom = dataFormat === "channelsLast" ? pad3[1][1] : pad3[2][1];
      const left = dataFormat === "channelsLast" ? pad3[2][0] : pad3[3][0];
      const right = dataFormat === "channelsLast" ? pad3[2][1] : pad3[3][1];
      const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
      padInfo = { top, bottom, left, right, type: padType };
      outHeight = round4((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
      outWidth = round4((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
    } else {
      throw Error(`Unknown padding parameter: ${pad3}`);
    }
    return { padInfo, outHeight, outWidth };
  }
  function get3DPadAndOutInfo(pad3, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
    let padInfo;
    let outDepth;
    let outHeight;
    let outWidth;
    if (typeof pad3 === "number") {
      const padType = pad3 === 0 ? "VALID" : "NUMBER";
      padInfo = {
        top: pad3,
        bottom: pad3,
        left: pad3,
        right: pad3,
        front: pad3,
        back: pad3,
        type: padType
      };
      const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad3, roundingMode);
      outDepth = outShape[0];
      outHeight = outShape[1];
      outWidth = outShape[2];
    } else if (pad3 === "same") {
      outDepth = Math.ceil(inDepth / strideDepth);
      outHeight = Math.ceil(inHeight / strideHeight);
      outWidth = Math.ceil(inWidth / strideWidth);
      const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
      const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
      const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
      const front = Math.floor(padAlongDepth / 2);
      const back = padAlongDepth - front;
      const top = Math.floor(padAlongHeight / 2);
      const bottom = padAlongHeight - top;
      const left = Math.floor(padAlongWidth / 2);
      const right = padAlongWidth - left;
      padInfo = { top, bottom, left, right, front, back, type: "SAME" };
    } else if (pad3 === "valid") {
      padInfo = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        front: 0,
        back: 0,
        type: "VALID"
      };
      outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);
      outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
      outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    } else {
      throw Error(`Unknown padding parameter: ${pad3}`);
    }
    return { padInfo, outDepth, outHeight, outWidth };
  }
  function round4(value, roundingMode) {
    if (!roundingMode) {
      return Math.trunc(value);
    }
    switch (roundingMode) {
      case "round":
        return Math.round(value);
      case "ceil":
        return Math.ceil(value);
      case "floor":
        return Math.floor(value);
      default:
        throw new Error(`Unknown roundingMode ${roundingMode}`);
    }
  }
  function tupleValuesAreOne(param) {
    const [dimA, dimB, dimC] = parseTupleParam(param);
    return dimA === 1 && dimB === 1 && dimC === 1;
  }
  function eitherStridesOrDilationsAreOne(strides, dilations) {
    return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
  }
  function convertConv2DDataFormat(dataFormat) {
    if (dataFormat === "NHWC") {
      return "channelsLast";
    } else if (dataFormat === "NCHW") {
      return "channelsFirst";
    } else {
      throw new Error(`Unknown dataFormat ${dataFormat}`);
    }
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/reshape.js
  function reshape_(x, shape) {
    const $x = convertToTensor(x, "x", "reshape", "string_or_numeric");
    const inputs = { x: $x };
    const attrs = { shape };
    return ENGINE.runKernel(Reshape, inputs, attrs);
  }
  var reshape = op({ reshape_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool.js
  function avgPool_(x, filterSize, strides, pad3, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "avgPool", "float32");
    const dilations = 1;
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in avgPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
    let res = ENGINE.runKernel(AvgPool, inputs, attrs);
    res = cast(res, $x.dtype);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var avgPool = op({ avgPool_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_3d.js
  function avgPool3d_(x, filterSize, strides, pad3, dimRoundingMode, dataFormat = "NDHWC") {
    const $x = convertToTensor(x, "x", "avgPool3d", "float32");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat };
    let res = ENGINE.runKernel(AvgPool3D, inputs, attrs);
    res = cast(res, x5D.dtype);
    if (reshapedTo5D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var avgPool3d = op({ avgPool3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat.js
  function concat_(tensors, axis = 0) {
    assert(tensors.length >= 1, () => "Pass at least one tensor to concat");
    const $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
    if ($tensors[0].dtype === "complex64") {
      $tensors.forEach((tensor2) => {
        if (tensor2.dtype !== "complex64") {
          throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor2.dtype}. `);
        }
      });
    }
    if ($tensors.length === 1) {
      return clone5($tensors[0]);
    }
    const inputs = $tensors;
    const attr = { axis };
    return ENGINE.runKernel(Concat, inputs, attr);
  }
  var concat = op({ concat_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sigmoid.js
  function sigmoid_(x) {
    const $x = convertToTensor(x, "x", "sigmoid", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sigmoid, inputs);
  }
  var sigmoid = op({ sigmoid_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice.js
  function slice_(x, begin, size3) {
    const $x = convertToTensor(x, "x", "slice", "string_or_numeric");
    if ($x.rank === 0) {
      throw new Error("Slicing scalar is not possible");
    }
    const inputs = { x: $x };
    const attrs = { begin, size: size3 };
    return ENGINE.runKernel(Slice, inputs, attrs);
  }
  var slice = op({ slice_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tanh.js
  function tanh_(x) {
    const $x = convertToTensor(x, "x", "tanh", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Tanh, inputs);
  }
  var tanh2 = op({ tanh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batch_to_space_nd.js
  function batchToSpaceND_(x, blockShape, crops) {
    const $x = convertToTensor(x, "x", "batchToSpaceND");
    const prod4 = blockShape.reduce((a, b) => a * b);
    assert($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
    assert(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
    assert($x.shape[0] % prod4 === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod4}`);
    const inputs = { x: $x };
    const attrs = { blockShape, crops };
    return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
  }
  var batchToSpaceND = op({ batchToSpaceND_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm_util.js
  function xAs4D(x) {
    let x4D;
    if (x.rank === 0 || x.rank === 1) {
      x4D = reshape(x, [1, 1, 1, x.size]);
    } else if (x.rank === 2) {
      x4D = reshape(x, [1, 1, x.shape[0], x.shape[1]]);
    } else if (x.rank === 3) {
      x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    } else {
      x4D = x;
    }
    return x4D;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm.js
  function batchNorm_(x, mean3, variance, offset, scale5, varianceEpsilon) {
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean3, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale5 != null) {
      $scale = convertToTensor(scale5, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    assert($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    assert($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    const x4D = xAs4D($x);
    const inputs = {
      x: x4D,
      scale: $scale,
      offset: $offset,
      mean: $mean,
      variance: $variance
    };
    const attrs = { varianceEpsilon };
    const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
    return reshape(res, $x.shape);
  }
  var batchNorm = op({ batchNorm_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm2d.js
  function batchNorm2d_(x, mean3, variance, offset, scale5, varianceEpsilon) {
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean3, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale5 != null) {
      $scale = convertToTensor(scale5, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`);
    assert($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`);
    assert($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  var batchNorm2d = op({ batchNorm2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm3d.js
  function batchNorm3d_(x, mean3, variance, offset, scale5, varianceEpsilon) {
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean3, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale5 != null) {
      $scale = convertToTensor(scale5, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`);
    assert($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`);
    assert($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  var batchNorm3d = op({ batchNorm3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm4d.js
  function batchNorm4d_(x, mean3, variance, offset, scale5, varianceEpsilon) {
    const $x = convertToTensor(x, "x", "batchNorm");
    const $mean = convertToTensor(mean3, "mean", "batchNorm");
    const $variance = convertToTensor(variance, "variance", "batchNorm");
    let $scale;
    if (scale5 != null) {
      $scale = convertToTensor(scale5, "scale", "batchNorm");
    }
    let $offset;
    if (offset != null) {
      $offset = convertToTensor(offset, "offset", "batchNorm");
    }
    assert($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`);
    assert($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`);
    assert($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`);
    if ($scale != null) {
      assert($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`);
    }
    if ($offset != null) {
      assert($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`);
    }
    return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
  }
  var batchNorm4d = op({ batchNorm4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/bincount.js
  function bincount_(x, weights, size3) {
    const $x = convertToTensor(x, "x", "bincount");
    const $weights = convertToTensor(weights, "weights", "bincount");
    assert($x.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${$x.dtype}`);
    assert(size3 >= 0, () => `size must be non-negative, but got ${size3}.`);
    assert($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
    const inputs = { x: $x, weights: $weights };
    const attrs = { size: size3 };
    return ENGINE.runKernel(Bincount, inputs, attrs);
  }
  var bincount = op({ bincount_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_to.js
  function broadcastTo_(x, shape) {
    let input2 = convertToTensor(x, "broadcastTo", "x");
    const xShape = input2.shape;
    if (shape.some((d) => !(d > 0) || d % 1 !== 0)) {
      throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);
    }
    if (shape.length < input2.rank) {
      throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input2.rank}.`);
    }
    if (shape.length > input2.rank) {
      const newShape = input2.shape.slice();
      while (newShape.length < shape.length) {
        newShape.unshift(1);
      }
      input2 = reshape(input2, newShape);
    }
    const inputShape = input2.shape;
    const reps = Array.from(shape);
    for (let i = shape.length - 1; i >= 0; i--) {
      if (inputShape[i] === shape[i]) {
        reps[i] = 1;
      } else if (input2.shape[i] !== 1) {
        throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
      }
    }
    const axes = reps.map((n, i) => n > 1 ? i : -1).filter((i) => i >= 0);
    if (axes.length === 0) {
      return clone5(input2);
    }
    const inputs = { x: input2 };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
  }
  var broadcastTo = op({ broadcastTo_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ceil.js
  function ceil_(x) {
    const $x = convertToTensor(x, "x", "ceil", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Ceil, inputs);
  }
  var ceil3 = op({ ceil_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/clip_by_value.js
  function clipByValue_(x, clipValueMin, clipValueMax) {
    const $x = convertToTensor(x, "x", "clipByValue");
    assert(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);
    const inputs = { x: $x };
    const attrs = { clipValueMin, clipValueMax };
    return ENGINE.runKernel(ClipByValue, inputs, attrs);
  }
  var clipByValue = op({ clipByValue_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_1d.js
  function concat1d_(tensors) {
    return concat(tensors, 0);
  }
  var concat1d = op({ concat1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_2d.js
  function concat2d_(tensors, axis) {
    return concat(tensors, axis);
  }
  var concat2d = op({ concat2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_3d.js
  function concat3d_(tensors, axis) {
    return concat(tensors, axis);
  }
  var concat3d = op({ concat3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_4d.js
  function concat4d_(tensors, axis) {
    return concat(tensors, axis);
  }
  var concat4d = op({ concat4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d.js
  function conv2d_(x, filter2, strides, pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x, "x", "conv2d", "float32");
    const $filter = convertToTensor(filter2, "filter", "conv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    assert(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad3, dataFormat, dilations, dimRoundingMode };
    const res = ENGINE.runKernel(Conv2D, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var conv2d = op({ conv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv1d.js
  function conv1d_(x, filter2, stride, pad3, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "conv1d");
    const $filter = convertToTensor(filter2, "filter", "conv1d");
    let x3D = $x;
    let reshapedTo3D = false;
    if ($x.rank === 2) {
      reshapedTo3D = true;
      x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);
    }
    assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
    assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in conv1d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`);
    assert(eitherStridesOrDilationsAreOne(stride, dilation), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`);
    assert(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
    const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
    const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
    const strides = [1, stride];
    const dilations = [1, dilation];
    const conv2dDataFormat = "NHWC";
    const res = conv2d(input4D, filter4D, strides, pad3, conv2dDataFormat, dilations, dimRoundingMode);
    if (reshapedTo3D) {
      return reshape(res, [res.shape[2], res.shape[3]]);
    }
    return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);
  }
  var conv1d = op({ conv1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_backprop_input.js
  function conv2DBackpropInput_(xShape, dy, filter2, strides, pad3, dataFormat = "NHWC", dimRoundingMode) {
    assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape4D = xShape;
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
      reshapedTo4D = true;
      dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
      xShape4D = [1, xShape[0], xShape[1], xShape[2]];
    }
    assert(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`);
    assert(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`);
    assert(filter2.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${filter2.rank}`);
    const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
    const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
    assert(inDepth === filter2.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter2.shape[2]}.`);
    assert(outDepth === filter2.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter2.shape[3]}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { dy: dy4D, filter: filter2 };
    const attrs = { strides, pad: pad3, dataFormat, dimRoundingMode, inputShape: xShape4D };
    const res = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var conv2DBackpropInput = op({ conv2DBackpropInput_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_transpose.js
  function conv2dTranspose_(x, filter2, outputShape, strides, pad3, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "conv2dTranspose");
    const $filter = convertToTensor(filter2, "filter", "conv2dTranspose");
    return conv2DBackpropInput(outputShape, $x, $filter, strides, pad3, "NHWC", dimRoundingMode);
  }
  var conv2dTranspose = op({ conv2dTranspose_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d.js
  function conv3d_(x, filter2, strides, pad3, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
    const $x = convertToTensor(x, "x", "conv3d");
    const $filter = convertToTensor(filter2, "filter", "conv3d");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
    assert($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`);
    assert(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    assert(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
    const inputs = { x: x5D, filter: $filter };
    const attrs = { strides, pad: pad3, dataFormat, dilations };
    const res = ENGINE.runKernel(Conv3D, inputs, attrs);
    if (reshapedTo5D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var conv3d = op({ conv3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_backprop_input.js
  function conv3DBackpropInput_(xShape, dy, filter2, strides, pad3) {
    assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
    let xShape5D = xShape;
    let dy5D = dy;
    let reshapedTo5D = false;
    if (dy.rank === 4) {
      reshapedTo5D = true;
      dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
      xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
    }
    const inDepth = xShape5D[4];
    const outDepth = dy5D.shape[4];
    assert(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`);
    assert(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`);
    assert(filter2.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${filter2.rank}`);
    assert(inDepth === filter2.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter2.shape[3]}.`);
    assert(outDepth === filter2.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter2.shape[4]}.`);
    const inputs = { dy: dy5D, filter: filter2 };
    const attrs = { pad: pad3, strides, inputShape: xShape5D };
    const res = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
    if (reshapedTo5D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var conv3DBackpropInput = op({ conv3DBackpropInput_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_transpose.js
  function conv3dTranspose_(x, filter2, outputShape, strides, pad3) {
    const $x = convertToTensor(x, "x", "conv3dTranspose");
    const $filter = convertToTensor(filter2, "filter", "conv3dTranspose");
    return conv3DBackpropInput(outputShape, $x, $filter, strides, pad3);
  }
  var conv3dTranspose = op({ conv3dTranspose_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cos.js
  function cos_(x) {
    const $x = convertToTensor(x, "x", "cos", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Cos, inputs);
  }
  var cos2 = op({ cos_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cosh.js
  function cosh_(x) {
    const $x = convertToTensor(x, "x", "cosh", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Cosh, inputs);
  }
  var cosh = op({ cosh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/cumsum.js
  function cumsum_(x, axis = 0, exclusive = false, reverse4 = false) {
    const $x = convertToTensor(x, "x", "cumsum");
    const inputs = { x: $x };
    const attrs = { axis, exclusive, reverse: reverse4 };
    return ENGINE.runKernel(Cumsum, inputs, attrs);
  }
  var cumsum = op({ cumsum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depth_to_space.js
  function depthToSpace_(x, blockSize, dataFormat = "NHWC") {
    const $x = convertToTensor(x, "x", "depthToSpace", "float32");
    const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
    const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
    const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
    assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
    assert(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
    assert(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
    assert(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
    const inputs = { x: $x };
    const attrs = { blockSize, dataFormat };
    return ENGINE.runKernel(DepthToSpace, inputs, attrs);
  }
  var depthToSpace = op({ depthToSpace_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d.js
  function depthwiseConv2d_(x, filter2, strides, pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
    const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
    const $filter = convertToTensor(filter2, "filter", "depthwiseConv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    assert(x4D.shape[3] === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad3, dataFormat, dilations, dimRoundingMode };
    const res = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var depthwiseConv2d = op({ depthwiseConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dilation2d.js
  function dilation2d_(x, filter2, strides, pad3, dilations = [1, 1], dataFormat = "NHWC") {
    const $x = convertToTensor(x, "x", "dilation2d");
    const $filter = convertToTensor(filter2, "filter", "dilation2d");
    assert($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`);
    assert($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`);
    assert(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
      reshapedTo4D = true;
    }
    const inputs = { x: x4D, filter: $filter };
    const attrs = { strides, pad: pad3, dilations };
    const res = ENGINE.runKernel(Dilation2D, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var dilation2d = op({ dilation2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_util.js
  function getBroadcastDims(inShape, outShape) {
    const inRank = inShape.length;
    const dims = [];
    for (let i = 0; i < inRank; i++) {
      const dim = inRank - 1 - i;
      const a = inShape[dim] || 1;
      const b = outShape[outShape.length - 1 - i] || 1;
      if (b > 1 && a === 1) {
        dims.unshift(dim);
      }
    }
    return dims;
  }
  function getReductionAxes(inShape, outShape) {
    const result = [];
    for (let i = 0; i < outShape.length; i++) {
      const inDim = inShape[inShape.length - i - 1];
      const outAxis = outShape.length - i - 1;
      const outDim = outShape[outAxis];
      if (inDim == null || inDim === 1 && outDim > 1) {
        result.unshift(outAxis);
      }
    }
    return result;
  }
  function assertAndGetBroadcastShape(shapeA, shapeB) {
    const result = [];
    const l = Math.max(shapeA.length, shapeB.length);
    for (let i = 0; i < l; i++) {
      let a = shapeA[shapeA.length - i - 1];
      if (a == null) {
        a = 1;
      }
      let b = shapeB[shapeB.length - i - 1];
      if (b == null) {
        b = 1;
      }
      if (a === 1) {
        result.unshift(b);
      } else if (b === 1) {
        result.unshift(a);
      } else if (a !== b) {
        const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
        throw Error(errMsg);
      } else {
        result.unshift(a);
      }
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/equal.js
  function equal_(a, b) {
    let $a = convertToTensor(a, "a", "equal", "string_or_numeric");
    let $b = convertToTensor(b, "b", "equal", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Equal, inputs);
  }
  var equal = op({ equal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/where.js
  function where_(condition, a, b) {
    const $a = convertToTensor(a, "a", "where");
    const $b = convertToTensor(b, "b", "where");
    const $condition = convertToTensor(condition, "condition", "where", "bool");
    const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);
    const $broadcastedCondition = broadcastTo($condition, broadcastShape);
    const $broadcastedA = broadcastTo($a, broadcastShape);
    const $broadcastedB = broadcastTo($b, broadcastShape);
    const inputs = {
      condition: $broadcastedCondition,
      t: $broadcastedA,
      e: $broadcastedB
    };
    return ENGINE.runKernel(Select, inputs);
  }
  var where = op({ where_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/zeros_like.js
  function zerosLike_(x) {
    const $x = convertToTensor(x, "x", "zerosLike");
    const inputs = { x: $x };
    return ENGINE.runKernel(ZerosLike, inputs);
  }
  var zerosLike = op({ zerosLike_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/div_no_nan.js
  function divNoNan_(a, b) {
    let $a = convertToTensor(a, "a", "div");
    let $b = convertToTensor(b, "b", "div");
    [$a, $b] = makeTypesMatch($a, $b);
    const divResult = div3($a, $b);
    const zeros3 = zerosLike(divResult);
    const bEqualsZero = equal($b, zeros3);
    return where(bEqualsZero, zeros3, divResult);
  }
  var divNoNan = op({ divNoNan_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dot.js
  function dot_(t1, t2) {
    const $t1 = convertToTensor(t1, "t1", "dot");
    const $t2 = convertToTensor(t2, "t2", "dot");
    assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t2.rank}.`);
    const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
    const t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
    assert(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`);
    if ($t1.rank === 1 && $t2.rank === 1) {
      const t12D = reshape($t1, [1, -1]);
      const t22D = reshape($t2, [-1, 1]);
      const t1t2 = matMul(t12D, t22D);
      return reshape(t1t2, []);
    } else if ($t1.rank === 1 && $t2.rank === 2) {
      const t12D = reshape($t1, [1, -1]);
      const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
      const t1t2 = matMul(t12D, t22D);
      return reshape(t1t2, [t1t2.size]);
    } else if ($t1.rank === 2 && $t2.rank === 1) {
      const t22D = reshape($t2, [-1, 1]);
      const t1t2 = matMul($t1, t22D);
      return reshape(t1t2, [t1t2.size]);
    } else {
      const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
      const t1t2 = matMul($t1, t22D);
      return t1t2;
    }
  }
  var dot4 = op({ dot_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/elu.js
  function elu_(x) {
    const $x = convertToTensor(x, "x", "elu", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Elu, inputs);
  }
  var elu = op({ elu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/erf.js
  function erf_(x) {
    let $x = convertToTensor(x, "x", "erf");
    assert($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
    if ($x.dtype === "int32") {
      $x = cast($x, "float32");
    }
    const inputs = { x: $x };
    return ENGINE.runKernel(Erf, inputs);
  }
  var erf = op({ erf_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/exp.js
  function exp_(x) {
    const $x = convertToTensor(x, "x", "exp");
    const inputs = { x: $x };
    return ENGINE.runKernel(Exp, inputs);
  }
  var exp = op({ exp_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/expand_dims.js
  function expandDims_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "expandDims", "string_or_numeric");
    assert(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
    const inputs = { input: $x };
    const attrs = { dim: axis };
    return ENGINE.runKernel(ExpandDims, inputs, attrs);
  }
  var expandDims = op({ expandDims_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/expm1.js
  function expm1_(x) {
    const $x = convertToTensor(x, "x", "expm1");
    const inputs = { x: $x };
    return ENGINE.runKernel(Expm1, inputs);
  }
  var expm1 = op({ expm1_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tile.js
  function tile_(x, reps) {
    const $x = convertToTensor(x, "x", "tile", "string_or_numeric");
    assert($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);
    const inputs = { x: $x };
    const attrs = { reps };
    return ENGINE.runKernel(Tile, inputs, attrs);
  }
  var tile = op({ tile_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/eye.js
  function eye_(numRows, numColumns, batchShape, dtype = "float32") {
    if (numColumns == null) {
      numColumns = numRows;
    }
    const buff = buffer2([numRows, numColumns], dtype);
    const n = numRows <= numColumns ? numRows : numColumns;
    for (let i = 0; i < n; ++i) {
      buff.set(1, i, i);
    }
    const out = reshape(buff.toTensor(), [numRows, numColumns]);
    if (batchShape == null) {
      return out;
    } else {
      if (batchShape.length === 1) {
        return tile(expandDims(out, 0), [batchShape[0], 1, 1]);
      } else if (batchShape.length === 2) {
        return tile(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
      } else if (batchShape.length === 3) {
        return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [
          batchShape[0],
          batchShape[1],
          batchShape[2],
          1,
          1
        ]);
      } else {
        throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`);
      }
    }
  }
  var eye = op({ eye_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fill.js
  function fill(shape, value, dtype) {
    const attrs = { shape, value, dtype };
    return ENGINE.runKernel(Fill, {}, attrs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/floor.js
  function floor_(x) {
    const $x = convertToTensor(x, "x", "floor", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Floor, inputs);
  }
  var floor3 = op({ floor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/gather.js
  function gather_(x, indices, axis = 0, batchDims = 0) {
    const $x = convertToTensor(x, "x", "gather");
    const $indices = convertToTensor(indices, "indices", "gather", "int32");
    const inputs = { x: $x, indices: $indices };
    const attrs = { axis, batchDims };
    return ENGINE.runKernel(GatherV2, inputs, attrs);
  }
  var gather = op({ gather_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/greater.js
  function greater_(a, b) {
    let $a = convertToTensor(a, "a", "greater", "string_or_numeric");
    let $b = convertToTensor(b, "b", "greater", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Greater, inputs);
  }
  var greater = op({ greater_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/greater_equal.js
  function greaterEqual_(a, b) {
    let $a = convertToTensor(a, "a", "greaterEqual", "string_or_numeric");
    let $b = convertToTensor(b, "b", "greaterEqual", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(GreaterEqual, inputs);
  }
  var greaterEqual = op({ greaterEqual_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/imag.js
  function imag_(input2) {
    const $input = convertToTensor(input2, "input", "imag");
    const inputs = { input: $input };
    return ENGINE.runKernel(Imag, inputs);
  }
  var imag = op({ imag_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/is_finite.js
  function isFinite_(x) {
    const $x = convertToTensor(x, "x", "isFinite");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsFinite, inputs);
  }
  var isFinite2 = op({ isFinite_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/is_inf.js
  function isInf_(x) {
    const $x = convertToTensor(x, "x", "isInf");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsInf, inputs);
  }
  var isInf = op({ isInf_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/is_nan.js
  function isNaN_(x) {
    const $x = convertToTensor(x, "x", "isNaN");
    const inputs = { x: $x };
    return ENGINE.runKernel(IsNan, inputs);
  }
  var isNaN2 = op({ isNaN_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/leaky_relu.js
  function leakyRelu_(x, alpha = 0.2) {
    const $x = convertToTensor(x, "x", "leakyRelu");
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(LeakyRelu, inputs, attrs);
  }
  var leakyRelu = op({ leakyRelu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/less.js
  function less_(a, b) {
    let $a = convertToTensor(a, "a", "less", "string_or_numeric");
    let $b = convertToTensor(b, "b", "less", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Less, inputs);
  }
  var less = op({ less_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/less_equal.js
  function lessEqual_(a, b) {
    let $a = convertToTensor(a, "a", "lessEqual", "string_or_numeric");
    let $b = convertToTensor(b, "b", "lessEqual", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LessEqual, inputs);
  }
  var lessEqual = op({ lessEqual_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/local_response_normalization.js
  function localResponseNormalization_(x, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
    const $x = convertToTensor(x, "x", "localResponseNormalization");
    assert($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
    assert(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    const inputs = { x: x4D };
    const attrs = { depthRadius, bias, alpha, beta };
    const res = ENGINE.runKernel(LRN, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    } else {
      return res;
    }
  }
  var localResponseNormalization = op({ localResponseNormalization_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log.js
  function log_(x) {
    const $x = convertToTensor(x, "x", "log", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Log2, inputs);
  }
  var log6 = op({ log_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log1p.js
  function log1p_(x) {
    const $x = convertToTensor(x, "x", "log1p");
    const inputs = { x: $x };
    return ENGINE.runKernel(Log1p, inputs);
  }
  var log1p = op({ log1p_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients.js
  function variableGrads(f, varList) {
    assert(isFunction2(f), () => "The f passed in variableGrads(f) must be a function");
    assert(varList == null || Array.isArray(varList) && varList.every((v) => v instanceof Variable), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    const specifiedVarList = varList != null;
    if (!specifiedVarList) {
      varList = [];
      for (const varName in ENGINE.registeredVariables) {
        varList.push(ENGINE.registeredVariables[varName]);
      }
    }
    const specifiedNonTrainable = specifiedVarList ? varList.filter((variable2) => !variable2.trainable) : null;
    const originalVarCount = varList.length;
    varList = varList.filter((variable2) => variable2.trainable);
    assert(varList.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);
    const allowNoGradients = true;
    const { value, grads } = ENGINE.gradients(f, varList, null, allowNoGradients);
    assert(grads.some((g) => g != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().");
    assert(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);
    const namedGrads = {};
    varList.forEach((v, i) => {
      if (grads[i] != null) {
        namedGrads[v.name] = grads[i];
      }
    });
    if (specifiedNonTrainable != null) {
      specifiedNonTrainable.forEach((v) => namedGrads[v.name] = null);
    }
    return { value, grads: namedGrads };
  }
  function customGrad(f) {
    return ENGINE.customGrad(f);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/neg.js
  function neg_(x) {
    const $x = convertToTensor(x, "x", "neg");
    const inputs = { x: $x };
    return ENGINE.runKernel(Neg, inputs);
  }
  var neg = op({ neg_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/softplus.js
  function softplus_(x) {
    const $x = convertToTensor(x, "x", "softplus");
    const inputs = { x: $x };
    return ENGINE.runKernel(Softplus, inputs);
  }
  var softplus = op({ softplus_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log_sigmoid.js
  function logSigmoid_(x) {
    const $x = convertToTensor(x, "x", "logSigmoid");
    const customOp = customGrad((x2) => {
      const value = neg(softplus(neg(x2)));
      const gradFunc = (dy) => {
        const derX = mul4(dy, sigmoid(neg(x2)));
        return derX;
      };
      return { value, gradFunc };
    });
    return customOp($x);
  }
  var logSigmoid = op({ logSigmoid_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/max.js
  function max_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "max");
    const inputs = { x: $x };
    const attrs = { reductionIndices: axis, keepDims };
    return ENGINE.runKernel(Max, inputs, attrs);
  }
  var max3 = op({ max_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sub.js
  function sub_(a, b) {
    let $a = convertToTensor(a, "a", "sub");
    let $b = convertToTensor(b, "b", "sub");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Sub, inputs);
  }
  var sub4 = op({ sub_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sum.js
  function sum_(x, axis = null, keepDims = false) {
    let $x = convertToTensor(x, "x", "sum");
    if ($x.dtype === "bool") {
      $x = cast($x, "int32");
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Sum, inputs, attrs);
  }
  var sum2 = op({ sum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/log_softmax.js
  function logSoftmax_(logits, axis = -1) {
    const $logits = convertToTensor(logits, "logits", "logSoftmax");
    if (axis === -1) {
      axis = $logits.rank - 1;
    }
    if (axis !== $logits.rank - 1) {
      throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);
    }
    const customOp = customGrad((logits2, save) => {
      const keepDims = true;
      const xMax = max3(logits2, axis, true);
      const shifted = sub4(logits2, xMax);
      const value = sub4(cast(shifted, "float32"), log6(sum2(exp(shifted), axis, keepDims)));
      save([value]);
      const gradFunc = (dy, saved) => {
        const [value2] = saved;
        const keepDims2 = true;
        const softmax4 = exp(value2);
        return sub4(dy, mul4(sum2(dy, axis, keepDims2), softmax4));
      };
      return { value, gradFunc };
    });
    return customOp($logits);
  }
  var logSoftmax = op({ logSoftmax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/axis_util.js
  function axesAreInnerMostDims(axes, rank) {
    for (let i = 0; i < axes.length; ++i) {
      if (axes[axes.length - i - 1] !== rank - 1 - i) {
        return false;
      }
    }
    return true;
  }
  function combineLocations(outputLoc, reduceLoc, axes) {
    const rank = outputLoc.length + reduceLoc.length;
    const loc = [];
    let outIdx = 0;
    let reduceIdx = 0;
    for (let dim = 0; dim < rank; dim++) {
      if (axes.indexOf(dim) === -1) {
        loc.push(outputLoc[outIdx++]);
      } else {
        loc.push(reduceLoc[reduceIdx++]);
      }
    }
    return loc;
  }
  function computeOutAndReduceShapes(aShape, axes) {
    const outShape = [];
    const rank = aShape.length;
    for (let dim = 0; dim < rank; dim++) {
      if (axes.indexOf(dim) === -1) {
        outShape.push(aShape[dim]);
      }
    }
    const reduceShape = axes.map((dim) => aShape[dim]);
    return [outShape, reduceShape];
  }
  function expandShapeToKeepDim(shape, axes) {
    const reduceSubShape = axes.map((x) => 1);
    return combineLocations(shape, reduceSubShape, axes);
  }
  function assertAxesAreInnerMostDims(msg, axes, rank) {
    assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
  }
  function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
      return null;
    }
    const result = [];
    for (let i = 0; i < rank; ++i) {
      if (axes.indexOf(i) === -1) {
        result.push(i);
      }
    }
    axes.forEach((axis) => result.push(axis));
    return result;
  }
  function getUndoAxesPermutation(axes) {
    return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
  }
  function getInnerMostAxes(numAxes, rank) {
    const res = [];
    for (let i = rank - numAxes; i < rank; ++i) {
      res.push(i);
    }
    return res;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/log_sum_exp.js
  function logSumExp_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "logSumExp");
    const axes = parseAxisParam(axis, $x.shape);
    const xMax = max3($x, axes, true);
    const a = sub4($x, xMax);
    const b = exp(a);
    const c = sum2(b, axes);
    const d = log6(c);
    const res = add6(reshape(xMax, d.shape), d);
    if (keepDims) {
      const newShape = expandShapeToKeepDim(res.shape, axes);
      return reshape(res, newShape);
    }
    return res;
  }
  var logSumExp = op({ logSumExp_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_and.js
  function logicalAnd_(a, b) {
    const $a = convertToTensor(a, "a", "logicalAnd", "bool");
    const $b = convertToTensor(b, "b", "logicalAnd", "bool");
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LogicalAnd, inputs);
  }
  var logicalAnd = op({ logicalAnd_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_not.js
  function logicalNot_(x) {
    const $x = convertToTensor(x, "x", "logicalNot", "bool");
    const inputs = { x: $x };
    return ENGINE.runKernel(LogicalNot, inputs);
  }
  var logicalNot = op({ logicalNot_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_or.js
  function logicalOr_(a, b) {
    const $a = convertToTensor(a, "a", "logicalOr", "bool");
    const $b = convertToTensor(b, "b", "logicalOr", "bool");
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(LogicalOr, inputs);
  }
  var logicalOr = op({ logicalOr_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/logical_xor.js
  function logicalXor_(a, b) {
    const $a = convertToTensor(a, "a", "logicalXor", "bool");
    const $b = convertToTensor(b, "b", "logicalXor", "bool");
    assertAndGetBroadcastShape($a.shape, $b.shape);
    return logicalAnd(logicalOr(a, b), logicalNot(logicalAnd(a, b)));
  }
  var logicalXor = op({ logicalXor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool.js
  function maxPool_(x, filterSize, strides, pad3, dimRoundingMode) {
    const $x = convertToTensor(x, "x", "maxPool");
    const dilations = 1;
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in maxPool: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { x: x4D };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
    const res = ENGINE.runKernel(MaxPool, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var maxPool = op({ maxPool_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_3d.js
  function maxPool3d_(x, filterSize = [1, 1, 1], strides, pad3, dimRoundingMode, dataFormat = "NDHWC") {
    const $x = convertToTensor(x, "x", "maxPool3d");
    let x5D = $x;
    let reshapedTo5D = false;
    if ($x.rank === 4) {
      reshapedTo5D = true;
      x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
    assert(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { x: x5D };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat };
    const res = ENGINE.runKernel(MaxPool3D, inputs, attrs);
    if (reshapedTo5D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var maxPool3d = op({ maxPool3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/maximum.js
  function maximum_(a, b) {
    let $a = convertToTensor(a, "a", "maximum");
    let $b = convertToTensor(b, "b", "maximum");
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === "bool") {
      $a = cast($a, "int32");
      $b = cast($b, "int32");
    }
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Maximum, inputs);
  }
  var maximum = op({ maximum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mean.js
  function mean_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "mean");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Mean, inputs, attrs);
  }
  var mean = op({ mean_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/zeros.js
  function zeros(shape, dtype = "float32") {
    if (dtype === "complex64") {
      const real4 = zeros(shape, "float32");
      const imag4 = zeros(shape, "float32");
      return complex(real4, imag4);
    }
    const values2 = makeZerosTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values2, shape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/ones.js
  function ones2(shape, dtype = "float32") {
    if (dtype === "complex64") {
      const real4 = ones2(shape, "float32");
      const imag4 = zeros(shape, "float32");
      return complex(real4, imag4);
    }
    const values2 = makeOnesTypedArray(sizeFromShape(shape), dtype);
    return ENGINE.makeTensor(values2, shape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/min.js
  function min_(x, axis = null, keepDims = false) {
    const $x = convertToTensor(x, "x", "min");
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Min, inputs, attrs);
  }
  var min3 = op({ min_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/minimum.js
  function minimum_(a, b) {
    let $a = convertToTensor(a, "a", "minimum");
    let $b = convertToTensor(b, "b", "minimum");
    [$a, $b] = makeTypesMatch($a, $b);
    if ($a.dtype === "bool") {
      $a = cast($a, "int32");
      $b = cast($b, "int32");
    }
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Minimum, inputs);
  }
  var minimum = op({ minimum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mirror_pad.js
  function mirrorPad_(x, paddings, mode) {
    assert(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);
    const $x = convertToTensor(x, "x", "mirrorPad");
    if ($x.rank === 0) {
      throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
    }
    assert(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);
    const shapeOffset = mode === "reflect" ? 1 : 0;
    for (let i = 0; i < $x.rank; i++) {
      assert(paddings[i].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
      assert(paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset && paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset, () => `Padding in dimension ${i} cannot be greater than or equal to ${$x.shape[i] - shapeOffset} or less than 0 for input of shape ${$x.shape}`);
    }
    const attrs = { paddings, mode };
    const inputs = { x: $x };
    return ENGINE.runKernel(MirrorPad, inputs, attrs);
  }
  var mirrorPad = op({ mirrorPad_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/mod.js
  function mod_(a, b) {
    let $a = convertToTensor(a, "a", "mod");
    let $b = convertToTensor(b, "b", "mod");
    [$a, $b] = makeTypesMatch($a, $b);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(Mod, inputs);
  }
  var mod3 = op({ mod_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/square.js
  function square_(x) {
    const $x = convertToTensor(x, "x", "square");
    const attrs = {};
    return ENGINE.runKernel("Square", { x: $x }, attrs);
  }
  var square = op({ square_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/moments.js
  function moments_(x, axis = null, keepDims = false) {
    x = convertToTensor(x, "x", "moments");
    const axes = parseAxisParam(axis, x.shape);
    const xMean = mean(x, axes, keepDims);
    let keepDimsShape = xMean.shape;
    if (!keepDims) {
      keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
    }
    const devSquared = square(sub4(cast(x, "float32"), reshape(xMean, keepDimsShape)));
    const variance = mean(devSquared, axes, keepDims);
    return { mean: xMean, variance };
  }
  var moments = op({ moments_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/not_equal.js
  function notEqual_(a, b) {
    let $a = convertToTensor(a, "a", "notEqual", "string_or_numeric");
    let $b = convertToTensor(b, "b", "notEqual", "string_or_numeric");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    return ENGINE.runKernel(NotEqual, inputs);
  }
  var notEqual = op({ notEqual_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ones_like.js
  function onesLike_(x) {
    const $x = convertToTensor(x, "x", "onesLike");
    const inputs = { x: $x };
    return ENGINE.runKernel(OnesLike, inputs);
  }
  var onesLike = op({ onesLike_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pad.js
  function pad_(x, paddings, constantValue = 0) {
    const $x = convertToTensor(x, "x", "pad");
    if ($x.rank === 0) {
      throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
    }
    const attrs = { paddings, constantValue };
    const inputs = { x: $x };
    return ENGINE.runKernel(PadV2, inputs, attrs);
  }
  var pad2 = op({ pad_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js
  function spaceToBatchND_(x, blockShape, paddings) {
    const $x = convertToTensor(x, "x", "spaceToBatchND");
    assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
    assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
    assert($x.shape.reduce((a, b, i) => {
      if (i > 0 && i <= blockShape.length) {
        return a && (b + paddings[i - 1][0] + paddings[i - 1][1]) % blockShape[i - 1] === 0;
      }
      return a;
    }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
    const inputs = { x: $x };
    const attrs = { blockShape, paddings };
    return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
  }
  var spaceToBatchND = op({ spaceToBatchND_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pool.js
  function pool_(input2, windowShape, poolingType, pad3, dilations, strides) {
    if (dilations == null) {
      dilations = [1, 1];
    }
    if (strides == null) {
      strides = 1;
    }
    if (pad3 === 0) {
      pad3 = "valid";
    }
    const $x = convertToTensor(input2, "x", "maxPool");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad3);
    const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
    let basePadding;
    if (pad3 === "same") {
      basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
    } else {
      basePadding = [[0, 0], [0, 0]];
    }
    const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
    const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
    const convertedPad = isDilationOne ? pad3 : "valid";
    const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
    const forwardOp = poolingType === "avg" ? () => avgPool(convertedX, windowShape, strides, convertedPad) : () => maxPool(convertedX, windowShape, strides, convertedPad);
    const y = forwardOp();
    const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
    const padStart = basePadding.map((b) => b[0]);
    const origPadEnd = basePadding.map((b) => b[1]);
    const fullInputShape = inputShape.concat(padStart, origPadEnd);
    const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);
    const padEnd2 = origPadEnd.map((s, i) => s + padEndExtra[i]);
    const paddings = blockShape.map((_6, i) => [padStart[i], padEnd2[i]]);
    const crops = blockShape.map((_6, i) => [0, padEndExtra[i]]);
    return [paddings, crops];
  }
  function withSpaceToBatchBasePaddings(filterShape, dilation) {
    const dilatedFilterShape = filterShape.map((s, i) => {
      return s + (s - 1) * (dilation[i] - 1);
    });
    const padExtraShape = dilatedFilterShape.map((s) => s - 1);
    const padExtraStart = padExtraShape.map((s) => Math.floor(s / 2));
    const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);
    return padExtraShape.map((_6, i) => {
      return [padExtraStart[i], padExtraEnd[i]];
    });
  }
  var pool = op({ pool_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/pow.js
  function pow_(base2, exp4) {
    let $base = convertToTensor(base2, "base", "pow");
    let $exp = convertToTensor(exp4, "exp", "pow");
    [$base, $exp] = makeTypesMatch($base, $exp);
    const inputs = { a: $base, b: $exp };
    return ENGINE.runKernel(Pow2, inputs);
  }
  var pow = op({ pow_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/prelu.js
  function prelu_(x, alpha) {
    const $x = convertToTensor(x, "x", "prelu");
    const $alpha = convertToTensor(alpha, "alpha", "prelu");
    const inputs = { x: $x, alpha: $alpha };
    return ENGINE.runKernel(Prelu, inputs);
  }
  var prelu = op({ prelu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/prod.js
  function prod_(x, axis = null, keepDims = false) {
    let $x = convertToTensor(x, "x", "prod");
    if ($x.dtype === "bool") {
      $x = cast($x, "int32");
    }
    const inputs = { x: $x };
    const attrs = { axis, keepDims };
    return ENGINE.runKernel(Prod, inputs, attrs);
  }
  var prod = op({ prod_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/rand_util.js
  var seedrandom = __toModule(require_seedrandom2());
  var MPRandGauss = class {
    constructor(mean3, stdDeviation, dtype, truncated, seed) {
      this.mean = mean3;
      this.stdDev = stdDeviation;
      this.dtype = dtype;
      this.nextVal = NaN;
      this.truncated = truncated;
      if (this.truncated) {
        this.upper = this.mean + this.stdDev * 2;
        this.lower = this.mean - this.stdDev * 2;
      }
      const seedValue = seed ? seed : Math.random();
      this.random = seedrandom.alea(seedValue.toString());
    }
    nextValue() {
      if (!isNaN(this.nextVal)) {
        const value = this.nextVal;
        this.nextVal = NaN;
        return value;
      }
      let resultX, resultY;
      let isValid = false;
      while (!isValid) {
        let v1, v2, s;
        do {
          v1 = 2 * this.random() - 1;
          v2 = 2 * this.random() - 1;
          s = v1 * v1 + v2 * v2;
        } while (s >= 1 || s === 0);
        const mul5 = Math.sqrt(-2 * Math.log(s) / s);
        resultX = this.mean + this.stdDev * v1 * mul5;
        resultY = this.mean + this.stdDev * v2 * mul5;
        if (!this.truncated || this.isValidTruncated(resultX)) {
          isValid = true;
        }
      }
      if (!this.truncated || this.isValidTruncated(resultY)) {
        this.nextVal = this.convertValue(resultY);
      }
      return this.convertValue(resultX);
    }
    convertValue(value) {
      if (this.dtype == null || this.dtype === "float32") {
        return value;
      }
      return Math.round(value);
    }
    isValidTruncated(value) {
      return value <= this.upper && value >= this.lower;
    }
  };
  var UniformRandom = class {
    constructor(min7 = 0, max7 = 1, dtype, seed) {
      this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
      this.min = min7;
      this.range = max7 - min7;
      this.dtype = dtype;
      if (seed == null) {
        seed = Math.random();
      }
      if (typeof seed === "number") {
        seed = seed.toString();
      }
      if (!this.canReturnFloat() && this.range <= 1) {
        throw new Error(`The difference between ${min7} - ${max7} <= 1 and dtype is not float`);
      }
      this.random = seedrandom.alea(seed);
    }
    convertValue(value) {
      if (this.canReturnFloat()) {
        return value;
      }
      return Math.round(value);
    }
    nextValue() {
      return this.convertValue(this.min + this.range * this.random());
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/random_normal.js
  function randomNormal_(shape, mean3 = 0, stdDev = 1, dtype, seed) {
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type ${dtype}`);
    }
    const randGauss = new MPRandGauss(mean3, stdDev, dtype, false, seed);
    const res = buffer2(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
  }
  var randomNormal = op({ randomNormal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/random_uniform.js
  function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
    const res = buffer2(shape, dtype);
    const random3 = new UniformRandom(minval, maxval, null, seed);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = random3.nextValue();
    }
    return res.toTensor();
  }
  var randomUniform = op({ randomUniform_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/range.js
  function range(start, stop2, step4 = 1, dtype = "float32") {
    if (step4 === 0) {
      throw new Error("Cannot have a step of zero");
    }
    const attrs = { start, stop: stop2, step: step4, dtype };
    return ENGINE.runKernel(Range, {}, attrs);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/real.js
  function real_(input2) {
    const $input = convertToTensor(input2, "input", "real");
    const inputs = { input: $input };
    return ENGINE.runKernel(Real, inputs);
  }
  var real = op({ real_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reciprocal.js
  function reciprocal_(x) {
    const $x = convertToTensor(x, "x", "reciprocal");
    const inputs = { x: $x };
    return ENGINE.runKernel(Reciprocal, inputs);
  }
  var reciprocal = op({ reciprocal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/relu.js
  function relu_(x) {
    const $x = convertToTensor(x, "x", "relu");
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu, inputs);
  }
  var relu = op({ relu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/relu6.js
  function relu6_(x) {
    const $x = convertToTensor(x, "x", "relu6");
    const inputs = { x: $x };
    return ENGINE.runKernel(Relu6, inputs);
  }
  var relu6 = op({ relu6_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/reverse.js
  function reverse_(x, axis) {
    const $x = convertToTensor(x, "x", "reverse");
    const inputs = { x: $x };
    const attrs = { dims: axis };
    return ENGINE.runKernel(Reverse, inputs, attrs);
  }
  var reverse = op({ reverse_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/round.js
  function round_(x) {
    const $x = convertToTensor(x, "x", "round");
    const inputs = { x: $x };
    return ENGINE.runKernel(Round, inputs);
  }
  var round5 = op({ round_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/rsqrt.js
  function rsqrt_(x) {
    const $x = convertToTensor(x, "x", "rsqrt", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Rsqrt, inputs);
  }
  var rsqrt = op({ rsqrt_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/scalar.js
  function scalar(value, dtype) {
    if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
      throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    }
    if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
      throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    }
    const shape = [];
    const inferredShape = [];
    return makeTensor(value, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/selu.js
  function selu_(x) {
    const $x = convertToTensor(x, "x", "selu");
    const inputs = { x: $x };
    return ENGINE.runKernel(Selu, inputs);
  }
  var selu = op({ selu_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/separable_conv2d.js
  function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad3, dilation = [1, 1], dataFormat = "NHWC") {
    const $x = convertToTensor(x, "x", "separableConv2d");
    const $depthwiseFilter = convertToTensor(depthwiseFilter, "depthwiseFilter", "separableConv2d");
    const $pointwiseFilter = convertToTensor(pointwiseFilter, "pointwiseFilter", "separableConv2d");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    if (dataFormat === "NCHW") {
      throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
    }
    assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
    assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
    assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`);
    assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
    const inChannels = $depthwiseFilter.shape[2];
    const channelMultiplier = $depthwiseFilter.shape[3];
    assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels * channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);
    const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad3, dataFormat, dilation);
    const pointwiseStride = 1;
    const res = conv2d(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var separableConv2d = op({ separableConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sign.js
  function sign_(x) {
    const $x = convertToTensor(x, "x", "sign");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sign, inputs);
  }
  var sign = op({ sign_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sin.js
  function sin_(x) {
    const $x = convertToTensor(x, "x", "sin", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sin, inputs);
  }
  var sin2 = op({ sin_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sinh.js
  function sinh_(x) {
    const $x = convertToTensor(x, "x", "sinh");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sinh, inputs);
  }
  var sinh = op({ sinh_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice1d.js
  function slice1d_(x, begin, size3) {
    const $x = convertToTensor(x, "x", "slice1d");
    assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, [begin], [size3]);
  }
  var slice1d = op({ slice1d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice2d.js
  function slice2d_(x, begin, size3) {
    const $x = convertToTensor(x, "x", "slice2d");
    assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size3);
  }
  var slice2d = op({ slice2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice3d.js
  function slice3d_(x, begin, size3) {
    const $x = convertToTensor(x, "x", "slice3d");
    assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size3);
  }
  var slice3d = op({ slice3d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/slice4d.js
  function slice4d_(x, begin, size3) {
    const $x = convertToTensor(x, "x", "slice4d");
    assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
    return slice($x, begin, size3);
  }
  var slice4d = op({ slice4d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/softmax.js
  function softmax_(logits, dim = -1) {
    const $logits = convertToTensor(logits, "logits", "softmax", "float32");
    if (dim === -1) {
      dim = $logits.rank - 1;
    }
    if (dim !== $logits.rank - 1) {
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);
    }
    const inputs = { logits: $logits };
    const attrs = { dim };
    return ENGINE.runKernel(Softmax, inputs, attrs);
  }
  var softmax = op({ softmax_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/fft.js
  function fft_(input2) {
    assert(input2.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${input2.dtype}.`);
    const inputs = { input: input2 };
    return ENGINE.runKernel(FFT, inputs);
  }
  var fft = op({ fft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/ifft.js
  function ifft_(input2) {
    assert(input2.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${input2.dtype}.`);
    const inputs = { input: input2 };
    return ENGINE.runKernel(IFFT, inputs);
  }
  var ifft = op({ ifft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/irfft.js
  function irfft_(input2) {
    const innerDimensionSize = input2.shape[input2.shape.length - 1];
    const batch = input2.size / innerDimensionSize;
    let ret;
    if (innerDimensionSize <= 2) {
      const complexInput = reshape(input2, [batch, innerDimensionSize]);
      ret = ifft(complexInput);
    } else {
      const outputShape = [batch, 2 * (innerDimensionSize - 1)];
      const realInput = reshape(real(input2), [batch, innerDimensionSize]);
      const imagInput = reshape(imag(input2), [batch, innerDimensionSize]);
      const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
      const imagConjugate = mul4(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
      const r = concat([realInput, realConjugate], 1);
      const i = concat([imagInput, imagConjugate], 1);
      const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);
      ret = ifft(complexInput);
    }
    ret = real(ret);
    if (input2.rank === 3 && input2.shape[0] !== 0) {
      const temp = ret;
      const batch2 = input2.shape[0];
      ret = reshape(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
      temp.dispose();
    }
    return ret;
  }
  var irfft = op({ irfft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/split.js
  function split_(x, numOrSizeSplits, axis = 0) {
    const $x = convertToTensor(x, "x", "split");
    const inputs = { x: $x };
    const attr = { numOrSizeSplits, axis };
    return ENGINE.runKernel(SplitV, inputs, attr);
  }
  var split = op({ split_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/spectral/rfft.js
  function rfft_(input2, fftLength) {
    assert(input2.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input2.dtype}`);
    let innerDimensionSize = input2.shape[input2.shape.length - 1];
    const batch = input2.size / innerDimensionSize;
    let adjustedInput;
    if (fftLength != null && fftLength < innerDimensionSize) {
      const begin = input2.shape.map((v) => 0);
      const size3 = input2.shape.map((v) => v);
      size3[input2.shape.length - 1] = fftLength;
      adjustedInput = slice(input2, begin, size3);
      innerDimensionSize = fftLength;
    } else if (fftLength != null && fftLength > innerDimensionSize) {
      const zerosShape = input2.shape.map((v) => v);
      zerosShape[input2.shape.length - 1] = fftLength - innerDimensionSize;
      adjustedInput = concat([input2, zeros(zerosShape)], input2.shape.length - 1);
      innerDimensionSize = fftLength;
    } else {
      adjustedInput = input2;
    }
    const zerosInput = zerosLike(adjustedInput);
    const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);
    const ret = fft(complexInput);
    const half = Math.floor(innerDimensionSize / 2) + 1;
    const realValues = real(ret);
    const imagValues = imag(ret);
    const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
    const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
    const outputShape = adjustedInput.shape.slice();
    outputShape[adjustedInput.shape.length - 1] = half;
    return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
  }
  var rfft = op({ rfft_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/sqrt.js
  function sqrt_(x) {
    const $x = convertToTensor(x, "x", "sqrt", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Sqrt, inputs);
  }
  var sqrt = op({ sqrt_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/squared_difference.js
  function squaredDifference_(a, b) {
    let $a = convertToTensor(a, "a", "squaredDifference");
    let $b = convertToTensor(b, "b", "squaredDifference");
    [$a, $b] = makeTypesMatch($a, $b);
    assertAndGetBroadcastShape($a.shape, $b.shape);
    const inputs = { a: $a, b: $b };
    const attrs = {};
    return ENGINE.runKernel(SquaredDifference, inputs, attrs);
  }
  var squaredDifference = op({ squaredDifference_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/squeeze.js
  function squeeze_(x, axis) {
    const $x = convertToTensor(x, "x", "squeeze");
    return reshape($x, squeezeShape($x.shape, axis).newShape);
  }
  var squeeze = op({ squeeze_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/stack.js
  function stack_(tensors, axis = 0) {
    const $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
    assert($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
    if ($tensors.length > 0) {
      assert(axis <= $tensors[0].rank, () => "Axis must be <= rank of the tensor");
    }
    const inputs = $tensors;
    const attrs = { axis };
    return ENGINE.runKernel(Pack, inputs, attrs);
  }
  var stack2 = op({ stack_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/step.js
  function step_(x, alpha = 0) {
    const $x = convertToTensor(x, "x", "step");
    const inputs = { x: $x };
    const attrs = { alpha };
    return ENGINE.runKernel(Step, inputs, attrs);
  }
  var step = op({ step_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/strided_slice.js
  function stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
    const $x = convertToTensor(x, "x", "stridedSlice", "string_or_numeric");
    const inputs = { x: $x };
    const attrs = {
      begin,
      end,
      strides,
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask
    };
    return ENGINE.runKernel(StridedSlice, inputs, attrs);
  }
  var stridedSlice = op({ stridedSlice_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tan.js
  function tan_(x) {
    const $x = convertToTensor(x, "x", "tan", "float32");
    const inputs = { x: $x };
    return ENGINE.runKernel(Tan, inputs);
  }
  var tan = op({ tan_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor1d.js
  function tensor1d(values2, dtype) {
    assertNonNull(values2);
    const inferredShape = inferShape(values2, dtype);
    if (inferredShape.length !== 1) {
      throw new Error("tensor1d() requires values to be a flat/TypedArray");
    }
    const shape = null;
    return makeTensor(values2, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/tensor2d.js
  function tensor2d(values2, shape, dtype) {
    assertNonNull(values2);
    if (shape != null && shape.length !== 2) {
      throw new Error("tensor2d() requires shape to have two numbers");
    }
    const inferredShape = inferShape(values2, dtype);
    if (inferredShape.length !== 2 && inferredShape.length !== 1) {
      throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    }
    if (inferredShape.length === 1 && shape == null) {
      throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    }
    return makeTensor(values2, shape, inferredShape, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/topk.js
  function topk_(x, k = 1, sorted = true) {
    const $x = convertToTensor(x, "x", "topk");
    if ($x.rank === 0) {
      throw new Error("topk() expects the input to be of rank 1 or higher");
    }
    const lastDim = $x.shape[$x.shape.length - 1];
    if (k < 0) {
      throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);
    }
    if (k > lastDim) {
      throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k}`);
    }
    const inputs = { x: $x };
    const attrs = { k, sorted };
    const [values2, indices] = ENGINE.runKernel(TopK, inputs, attrs);
    return { values: values2, indices };
  }
  var topk = op({ topk_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/truncated_normal.js
  function truncatedNormal_(shape, mean3 = 0, stdDev = 1, dtype, seed) {
    if (dtype != null && dtype === "bool") {
      throw new Error(`Unsupported data type $ { dtype }`);
    }
    const randGauss = new MPRandGauss(mean3, stdDev, dtype, true, seed);
    const res = buffer2(shape, dtype);
    for (let i = 0; i < res.values.length; i++) {
      res.values[i] = randGauss.nextValue();
    }
    return res.toTensor();
  }
  var truncatedNormal = op({ truncatedNormal_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/unique.js
  function unique_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "unique", "string_or_numeric");
    assert($x.rank > 0, () => "The input tensor must be at least 1D");
    const inputs = { x: $x };
    const attrs = { axis };
    const [values2, indices] = ENGINE.runKernel(Unique, inputs, attrs);
    return { values: values2, indices };
  }
  var unique = op({ unique_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/unsorted_segment_sum.js
  function unsortedSegmentSum_(x, segmentIds, numSegments) {
    const $x = convertToTensor(x, "x", "unsortedSegmentSum");
    const $segmentIds = convertToTensor(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
    assert(isInt(numSegments), () => "numSegments must be of dtype int");
    const inputs = { x: $x, segmentIds: $segmentIds };
    const attrs = { numSegments };
    return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
  }
  var unsortedSegmentSum = op({ unsortedSegmentSum_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/unstack.js
  function unstack_(x, axis = 0) {
    const $x = convertToTensor(x, "x", "unstack", "string_or_numeric");
    assert(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
    const inputs = { value: $x };
    const attrs = { axis };
    return ENGINE.runKernel(Unpack, inputs, attrs);
  }
  var unstack = op({ unstack_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/variable.js
  function variable(initialValue, trainable = true, name, dtype) {
    return ENGINE.makeVariable(initialValue, trainable, name, dtype);
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/where_impl.js
  function whereImpl(condShape, condVals) {
    const indices = [];
    for (let i = 0; i < condVals.length; i++) {
      if (condVals[i]) {
        indices.push(i);
      }
    }
    const inBuffer = buffer2(condShape, "int32");
    const out = buffer2([indices.length, condShape.length], "int32");
    for (let i = 0; i < indices.length; i++) {
      const loc = inBuffer.indexToLoc(indices[i]);
      const offset = i * condShape.length;
      out.values.set(loc, offset);
    }
    return out.toTensor();
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/norm.js
  function norm_(x, ord = "euclidean", axis = null, keepDims = false) {
    x = convertToTensor(x, "x", "norm");
    const norm2 = normImpl(x, ord, axis);
    let keepDimsShape = norm2.shape;
    if (keepDims) {
      const axes = parseAxisParam(axis, x.shape);
      keepDimsShape = expandShapeToKeepDim(norm2.shape, axes);
    }
    return reshape(norm2, keepDimsShape);
  }
  function normImpl(x, p3, axis = null) {
    if (x.rank === 0) {
      return abs(x);
    }
    if (x.rank !== 1 && axis === null) {
      return normImpl(reshape(x, [-1]), p3, axis);
    }
    if (x.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
      if (p3 === 1) {
        return sum2(abs(x), axis);
      }
      if (p3 === Infinity) {
        return max3(abs(x), axis);
      }
      if (p3 === -Infinity) {
        return min3(abs(x), axis);
      }
      if (p3 === "euclidean" || p3 === 2) {
        return sqrt(sum2(pow(abs(x), scalar(2, "int32")), axis));
      }
      throw new Error(`Error in norm: invalid ord value: ${p3}`);
    }
    if (Array.isArray(axis) && axis.length === 2) {
      if (p3 === 1) {
        return max3(sum2(abs(x), axis[0]), axis[1] - 1);
      }
      if (p3 === Infinity) {
        return max3(sum2(abs(x), axis[1]), axis[0]);
      }
      if (p3 === -Infinity) {
        return min3(sum2(abs(x), axis[1]), axis[0]);
      }
      if (p3 === "fro" || p3 === "euclidean") {
        return sqrt(sum2(square(x), axis));
      }
      throw new Error(`Error in norm: invalid ord value: ${p3}`);
    }
    throw new Error(`Error in norm: invalid axis: ${axis}`);
  }
  var norm = op({ norm_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/dropout_util.js
  function getNoiseShape(x, noiseShape) {
    if (noiseShape == null) {
      return x.shape.slice();
    }
    if (arraysEqual(x.shape, noiseShape)) {
      return noiseShape;
    }
    if (x.shape.length === noiseShape.length) {
      const newDimension = [];
      for (let i = 0; i < x.shape.length; i++) {
        if (noiseShape[i] == null && x.shape[i] != null) {
          newDimension.push(x.shape[i]);
        } else {
          newDimension.push(noiseShape[i]);
        }
      }
      return newDimension;
    }
    return noiseShape;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/dropout.js
  function dropout_(x, rate, noiseShape, seed) {
    const $x = convertToTensor(x, "x", "dropout");
    assert($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`);
    assert(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
    if (rate === 0) {
      return x instanceof Tensor ? $x.clone() : $x;
    }
    const $noiseShape = getNoiseShape($x, noiseShape);
    const keepProb = 1 - rate;
    const multiplier = div3(floor3(add6(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
    return mul4($x, multiplier);
  }
  var dropout = op({ dropout_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused_ops.js
  var fused_ops_exports = {};
  __export(fused_ops_exports, {
    conv2d: () => conv2d2,
    depthwiseConv2d: () => depthwiseConv2d2,
    matMul: () => matMul2
  });

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_backprop_filter.js
  function conv2DBackpropFilter_(x, dy, filterShape, strides, pad3, dataFormat = "NHWC", dimRoundingMode) {
    let x4D = x;
    if (x.rank === 3) {
      x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
      dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`);
    assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`);
    assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);
    const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
    const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
    assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`);
    assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad: pad3, dataFormat, dimRoundingMode, filterShape };
    return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
  }
  var conv2DBackpropFilter = op({ conv2DBackpropFilter_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused_util.js
  function getFusedDyActivation(dy, y, activation) {
    if (activation == null || activation === "linear") {
      return dy;
    }
    if (activation === "relu") {
      return mul4(dy, step(y));
    }
    throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
  }
  function getFusedBiasGradient(bias, dyActivation) {
    let res = dyActivation;
    const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
    if (reduceAxes.length > 0) {
      res = sum2(res, reduceAxes);
    }
    return reshape(res, bias.shape);
  }
  function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {
    if (activation === "linear") {
      return x;
    } else if (activation === "relu") {
      return relu(x);
    } else if (activation === "elu") {
      return elu(x);
    } else if (activation === "relu6") {
      return relu6(x);
    } else if (activation === "prelu") {
      return prelu(x, preluActivationWeights);
    } else if (activation === "leakyrelu") {
      return leakyRelu(x, leakyreluAlpha);
    } else if (activation === "sigmoid") {
      return sigmoid(x);
    }
    throw new Error(`Unknown fused activation ${activation}.`);
  }
  var shouldFuse = (gradientDepth, activation) => {
    const gradientMode = gradientDepth > 0;
    return !gradientMode || activation === "linear";
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused/conv2d.js
  function fusedConv2d_({ x, filter: filter2, strides, pad: pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
    activation = activation || "linear";
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
      let result = conv2d(x, filter2, strides, pad3, dataFormat, dilations, dimRoundingMode);
      if (bias != null) {
        result = add6(result, bias);
      }
      return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, "x", "conv2d", "float32");
    const $filter = convertToTensor(filter2, "filter", "conv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    assert(x4D.shape[3] === $filter.shape[2], () => `Error in conv2d: depth of input (${x4D.shape[3]}) must match input depth for filter ${$filter.shape[2]}.`);
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    assert(dataFormat === "NHWC", () => `Error in conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
    const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused conv2d");
      [$bias] = makeTypesMatch($bias, $x);
      assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused conv2d");
    }
    const grad = (dy, saved) => {
      const [$filter2, x4D2, y, $bias2] = saved;
      const dyActivation = getFusedDyActivation(dy, y, activation);
      assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
      const xDer = conv2DBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad3);
      const filterDer = conv2DBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad3);
      const der = [xDer, filterDer];
      if ($bias2 != null) {
        const biasDer = getFusedBiasGradient($bias2, dyActivation);
        der.push(biasDer);
      }
      return der;
    };
    const inputs = {
      x: x4D,
      filter: $filter,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
      strides,
      pad: pad3,
      dataFormat,
      dilations,
      dimRoundingMode,
      activation,
      leakyreluAlpha
    };
    if (bias == null) {
      const customOp = customGrad((x4D2, filter3, save) => {
        let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
        save([filter3, x4D2, res]);
        if (reshapedTo4D) {
          res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOp(x4D, $filter);
    } else {
      const customOpWithBias = customGrad((x4D2, filter3, bias2, save) => {
        let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
        save([filter3, x4D2, res, bias2]);
        if (reshapedTo4D) {
          res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOpWithBias(x4D, $filter, $bias);
    }
  }
  var conv2d2 = op({ fusedConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_filter.js
  function depthwiseConv2dNativeBackpropFilter_(x, dy, filterShape, strides, pad3, dilations = [1, 1], dimRoundingMode) {
    let x4D = x;
    if (x.rank === 3) {
      x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
    }
    let dy4D = dy;
    if (dy4D.rank === 3) {
      dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { x: x4D, dy: dy4D };
    const attrs = { strides, pad: pad3, dimRoundingMode, dilations, filterShape };
    return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
  }
  var depthwiseConv2dNativeBackpropFilter = op({ depthwiseConv2dNativeBackpropFilter_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_input.js
  function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter2, strides, pad3, dilations = [1, 1], dimRoundingMode) {
    let dy4D = dy;
    let reshapedTo4D = false;
    if (dy.rank === 3) {
      reshapedTo4D = true;
      dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    }
    const inputs = { dy: dy4D, filter: filter2 };
    const attrs = { strides, pad: pad3, dimRoundingMode, dilations, inputShape: xShape };
    const res = ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var depthwiseConv2dNativeBackpropInput = op({ depthwiseConv2dNativeBackpropInput_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused/depthwise_conv2d.js
  function fusedDepthwiseConv2d_({ x, filter: filter2, strides, pad: pad3, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
      let result = depthwiseConv2d(x, filter2, strides, pad3, dataFormat, dilations, dimRoundingMode);
      if (bias != null) {
        result = add6(result, bias);
      }
      return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
    const $filter = convertToTensor(filter2, "filter", "depthwiseConv2d", "float32");
    let x4D = $x;
    let reshapedTo4D = false;
    if ($x.rank === 3) {
      reshapedTo4D = true;
      x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    }
    assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
    assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
    assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
    if (dilations == null) {
      dilations = [1, 1];
    }
    assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad3, dimRoundingMode, true);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused conv2d");
      [$bias] = makeTypesMatch($bias, $x);
      assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
    }
    const grad = (dy, saved) => {
      assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);
      const [$filter2, x4D2, y, bias2] = saved;
      const dyActivation = getFusedDyActivation(dy, y, activation);
      const xDer = depthwiseConv2dNativeBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad3, dilations, dimRoundingMode);
      const filterDer = depthwiseConv2dNativeBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad3, dilations, dimRoundingMode);
      if (bias2 != null) {
        const biasDer = getFusedBiasGradient($bias, dyActivation);
        return [xDer, filterDer, biasDer];
      }
      return [xDer, filterDer];
    };
    const inputs = {
      x: x4D,
      filter: $filter,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = {
      strides,
      pad: pad3,
      dataFormat,
      dilations,
      dimRoundingMode,
      activation,
      leakyreluAlpha
    };
    if (bias == null) {
      const customOp = customGrad((x4D2, filter3, save) => {
        let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
        save([filter3, x4D2, res]);
        if (reshapedTo4D) {
          res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOp(x4D, $filter);
    } else {
      const customOpWithBias = customGrad((x4D2, filter3, bias2, save) => {
        let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
        save([filter3, x4D2, res, bias2]);
        if (reshapedTo4D) {
          res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
        }
        return { value: res, gradFunc: grad };
      });
      return customOpWithBias(x4D, $filter, $bias);
    }
  }
  var depthwiseConv2d2 = op({ fusedDepthwiseConv2d_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/fused/mat_mul.js
  function fusedMatMul_({ a, b, transposeA = false, transposeB = false, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
      let result = matMul(a, b, transposeA, transposeB);
      if (bias != null) {
        result = add6(result, bias);
      }
      return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
    }
    let $a = convertToTensor(a, "a", "fused matMul");
    let $b = convertToTensor(b, "b", "fused matMul");
    [$a, $b] = makeTypesMatch($a, $b);
    const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
    const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
    const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
    const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
    const outerDimsA = $a.shape.slice(0, -2);
    const outerDimsB = $b.shape.slice(0, -2);
    const batchDimA = sizeFromShape(outerDimsA);
    const batchDimB = sizeFromShape(outerDimsB);
    assert($a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank, () => `Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${$a.rank} and ${$b.rank}.`);
    assert(arraysEqual(outerDimsA, outerDimsB), () => `Error in fused matMul: outer dimensions (${outerDimsA}) and (${outerDimsB}) of Tensors with shapes ${$a.shape} and ${$b.shape} must match.`);
    assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);
    const a3D = transposeA ? reshape($a, [batchDimA, innerShapeA, outerShapeA]) : reshape($a, [batchDimA, outerShapeA, innerShapeA]);
    const b3D = transposeB ? reshape($b, [batchDimB, outerShapeB, innerShapeB]) : reshape($b, [batchDimB, innerShapeB, outerShapeB]);
    let $bias;
    if (bias != null) {
      $bias = convertToTensor(bias, "bias", "fused matMul");
      [$bias] = makeTypesMatch($bias, $a);
      assertAndGetBroadcastShape(outShape, $bias.shape);
    }
    let $preluActivationWeights;
    if (preluActivationWeights != null) {
      $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused matMul");
    }
    const grad = (dy, saved) => {
      const [a3D2, b3D2, y, $bias2] = saved;
      const dyActivation = getFusedDyActivation(reshape(dy, y.shape), y, activation);
      let aDer;
      let bDer;
      if (!transposeA && !transposeB) {
        aDer = matMul(dyActivation, b3D2, false, true);
        bDer = matMul(a3D2, dyActivation, true, false);
      } else if (!transposeA && transposeB) {
        aDer = matMul(dyActivation, b3D2, false, false);
        bDer = matMul(dyActivation, a3D2, true, false);
      } else if (transposeA && !transposeB) {
        aDer = matMul(b3D2, dyActivation, false, true);
        bDer = matMul(a3D2, dyActivation, false, false);
      } else {
        aDer = matMul(b3D2, dyActivation, true, true);
        bDer = matMul(dyActivation, a3D2, true, true);
      }
      if (bias != null) {
        const biasDer = getFusedBiasGradient($bias2, dyActivation);
        return [aDer, bDer, biasDer];
      } else {
        return [aDer, bDer];
      }
    };
    const inputs = {
      a: a3D,
      b: b3D,
      bias: $bias,
      preluActivationWeights: $preluActivationWeights
    };
    const attrs = { transposeA, transposeB, activation, leakyreluAlpha };
    if (bias == null) {
      const customOp = customGrad((a3D2, b3D2, save) => {
        const res = ENGINE.runKernel(_FusedMatMul, inputs, attrs);
        save([a3D2, b3D2, res]);
        return { value: reshape(res, outShape), gradFunc: grad };
      });
      return customOp(a3D, b3D);
    } else {
      const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
        const res = ENGINE.runKernel(_FusedMatMul, inputs, attrs);
        save([a3D2, b3D2, res, $bias2]);
        return { value: reshape(res, outShape), gradFunc: grad };
      });
      return customOpWithBias(a3D, b3D, $bias);
    }
  }
  var matMul2 = op({ fusedMatMul_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/crop_and_resize.js
  function cropAndResize_(image3, boxes, boxInd, cropSize, method = "bilinear", extrapolationValue = 0) {
    const $image = convertToTensor(image3, "image", "cropAndResize");
    const $boxes = convertToTensor(boxes, "boxes", "cropAndResize", "float32");
    const $boxInd = convertToTensor(boxInd, "boxInd", "cropAndResize", "int32");
    const numBoxes = $boxes.shape[0];
    assert($image.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`);
    assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`);
    assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`);
    assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`);
    assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
    assert(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
    const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
    const attrs = { method, extrapolationValue, cropSize };
    const res = ENGINE.runKernel(CropAndResize, inputs, attrs);
    return res;
  }
  var cropAndResize = op({ cropAndResize_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/flip_left_right.js
  function flipLeftRight_(image3) {
    const $image = convertToTensor(image3, "image", "flipLeftRight", "float32");
    assert($image.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const res = ENGINE.runKernel(FlipLeftRight, inputs, {});
    return res;
  }
  var flipLeftRight = op({ flipLeftRight_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/grayscale_to_rgb.js
  function grayscaleToRGB_(image3) {
    const $image = convertToTensor(image3, "image", "grayscaleToRGB");
    const lastDimsIdx = $image.rank - 1;
    const lastDims = $image.shape[lastDimsIdx];
    assert($image.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${$image.rank}.`);
    assert(lastDims === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${lastDims}.`);
    const reps = new Array($image.rank);
    reps.fill(1, 0, lastDimsIdx);
    reps[lastDimsIdx] = 3;
    return tile($image, reps);
  }
  var grayscaleToRGB = op({ grayscaleToRGB_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/rotate_with_offset.js
  function rotateWithOffset_(image3, radians, fillValue = 0, center = 0.5) {
    const $image = convertToTensor(image3, "image", "rotateWithOffset", "float32");
    assert($image.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);
    const inputs = { image: $image };
    const attrs = { radians, fillValue, center };
    const res = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
    return res;
  }
  var rotateWithOffset = op({ rotateWithOffset_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/nonmax_util.js
  function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    if (iouThreshold == null) {
      iouThreshold = 0.5;
    }
    if (scoreThreshold == null) {
      scoreThreshold = Number.NEGATIVE_INFINITY;
    }
    if (softNmsSigma == null) {
      softNmsSigma = 0;
    }
    const numBoxes = boxes.shape[0];
    maxOutputSize = Math.min(maxOutputSize, numBoxes);
    assert(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
    assert(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
    assert(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
    assert(scores.rank === 1, () => "scores must be a 1D tensor");
    assert(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`);
    assert(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
    return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression.js
  function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression", "float32");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression", "float32");
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
    return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
  }
  var nonMaxSuppression = op({ nonMaxSuppression_ });

  // node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js
  function binaryInsert(arr, element, comparator) {
    const index = binarySearch(arr, element, comparator);
    const insertionPoint = index < 0 ? -(index + 1) : index;
    arr.splice(insertionPoint, 0, element);
  }
  function binarySearch(arr, target, comparator) {
    return binarySearch_(arr, target, comparator || defaultComparator);
  }
  function defaultComparator(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  function binarySearch_(arr, target, comparator) {
    let left = 0;
    let right = arr.length;
    let middle = 0;
    let found = false;
    while (left < right) {
      middle = left + (right - left >>> 1);
      const compareResult = comparator(target, arr[middle]);
      if (compareResult > 0) {
        left = middle + 1;
      } else {
        right = middle;
        found = !compareResult;
      }
    }
    return found ? left : -left - 1;
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js
  function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0);
  }
  function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);
  }
  function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
  }
  function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
    const candidates = [];
    for (let i = 0; i < scores.length; i++) {
      if (scores[i] > scoreThreshold) {
        candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });
      }
    }
    candidates.sort(ascendingComparator);
    const scale5 = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
    const selectedIndices = [];
    const selectedScores = [];
    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
      const candidate = candidates.pop();
      const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
      if (originalScore < scoreThreshold) {
        break;
      }
      let ignoreCandidate = false;
      for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {
        const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);
        if (iou >= iouThreshold) {
          ignoreCandidate = true;
          break;
        }
        candidate.score = candidate.score * suppressWeight(iouThreshold, scale5, iou);
        if (candidate.score <= scoreThreshold) {
          break;
        }
      }
      candidate.suppressBeginIndex = selectedIndices.length;
      if (!ignoreCandidate) {
        if (candidate.score === originalScore) {
          selectedIndices.push(boxIndex);
          selectedScores.push(candidate.score);
        } else if (candidate.score > scoreThreshold) {
          binaryInsert(candidates, candidate, ascendingComparator);
        }
      }
    }
    const validOutputs = selectedIndices.length;
    const elemsToPad = maxOutputSize - validOutputs;
    if (padToMaxOutputSize && elemsToPad > 0) {
      selectedIndices.push(...new Array(elemsToPad).fill(0));
      selectedScores.push(...new Array(elemsToPad).fill(0));
    }
    const result = { selectedIndices };
    if (returnScoresTensor) {
      result["selectedScores"] = selectedScores;
    }
    if (returnValidOutputs) {
      result["validOutputs"] = validOutputs;
    }
    return result;
  }
  function intersectionOverUnion(boxes, i, j) {
    const iCoord = boxes.subarray(i * 4, i * 4 + 4);
    const jCoord = boxes.subarray(j * 4, j * 4 + 4);
    const yminI = Math.min(iCoord[0], iCoord[2]);
    const xminI = Math.min(iCoord[1], iCoord[3]);
    const ymaxI = Math.max(iCoord[0], iCoord[2]);
    const xmaxI = Math.max(iCoord[1], iCoord[3]);
    const yminJ = Math.min(jCoord[0], jCoord[2]);
    const xminJ = Math.min(jCoord[1], jCoord[3]);
    const ymaxJ = Math.max(jCoord[0], jCoord[2]);
    const xmaxJ = Math.max(jCoord[1], jCoord[3]);
    const areaI = (ymaxI - yminI) * (xmaxI - xminI);
    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
    if (areaI <= 0 || areaJ <= 0) {
      return 0;
    }
    const intersectionYmin = Math.max(yminI, yminJ);
    const intersectionXmin = Math.max(xminI, xminJ);
    const intersectionYmax = Math.min(ymaxI, ymaxJ);
    const intersectionXmax = Math.min(xmaxI, xmaxJ);
    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
    return intersectionArea / (areaI + areaJ - intersectionArea);
  }
  function suppressWeight(iouThreshold, scale5, iou) {
    const weight = Math.exp(scale5 * iou * iou);
    return iou <= iouThreshold ? weight : 0;
  }
  function ascendingComparator(c1, c2) {
    return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_async.js
  async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
    maxOutputSize = inputs.maxOutputSize;
    iouThreshold = inputs.iouThreshold;
    scoreThreshold = inputs.scoreThreshold;
    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return tensor1d(selectedIndices, "int32");
  }
  var nonMaxSuppressionAsync = nonMaxSuppressionAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score.js
  function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
    const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
    return { selectedIndices: result[0], selectedScores: result[1] };
  }
  var nonMaxSuppressionWithScore = op({ nonMaxSuppressionWithScore_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score_async.js
  async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    maxOutputSize = params.maxOutputSize;
    iouThreshold = params.iouThreshold;
    scoreThreshold = params.scoreThreshold;
    softNmsSigma = params.softNmsSigma;
    const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
    const boxesVals = boxesAndScores[0];
    const scoresVals = boxesAndScores[1];
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return {
      selectedIndices: tensor1d(selectedIndices, "int32"),
      selectedScores: tensor1d(selectedScores)
    };
  }
  var nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded.js
  function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const inputs = { boxes: $boxes, scores: $scores };
    const attrs = {
      maxOutputSize: $maxOutputSize,
      iouThreshold: $iouThreshold,
      scoreThreshold: $scoreThreshold,
      padToMaxOutputSize
    };
    const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
    return { selectedIndices: result[0], validOutputs: result[1] };
  }
  var nonMaxSuppressionPadded = op({ nonMaxSuppressionPadded_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded_async.js
  async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
    const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
    const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
    const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
    const $maxOutputSize = params.maxOutputSize;
    const $iouThreshold = params.iouThreshold;
    const $scoreThreshold = params.scoreThreshold;
    const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
    if ($boxes !== boxes) {
      $boxes.dispose();
    }
    if ($scores !== scores) {
      $scores.dispose();
    }
    return {
      selectedIndices: tensor1d(selectedIndices, "int32"),
      validOutputs: scalar(validOutputs, "int32")
    };
  }
  var nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_bilinear.js
  function resizeBilinear_(images, size3, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, "images", "resizeBilinear");
    assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`);
    assert(size3.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${size3}.`);
    assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
      reshapedTo4D = true;
      batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const [] = size3;
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size: size3 };
    const res = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var resizeBilinear = op({ resizeBilinear_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_nearest_neighbor.js
  function resizeNearestNeighbor_(images, size3, alignCorners = false, halfPixelCenters = false) {
    const $images = convertToTensor(images, "images", "resizeNearestNeighbor");
    assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`);
    assert(size3.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size3}.`);
    assert($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
    assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);
    let batchImages = $images;
    let reshapedTo4D = false;
    if ($images.rank === 3) {
      reshapedTo4D = true;
      batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
    }
    const [] = size3;
    const inputs = { images: batchImages };
    const attrs = { alignCorners, halfPixelCenters, size: size3 };
    const res = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var resizeNearestNeighbor = op({ resizeNearestNeighbor_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/threshold.js
  function threshold_(image3, method = "binary", inverted = false, threshValue = 0.5) {
    const $image = convertToTensor(image3, "image", "threshold");
    const RED_INTENCITY_COEF = 0.2989;
    const GREEN_INTENCITY_COEF = 0.587;
    const BLUE_INTENCITY_COEF = 0.114;
    const totalPixelsInImage = $image.shape[0] * $image.shape[1];
    let $threshold = mul4(tensor1d([threshValue]), 255);
    let r, g, b, grayscale;
    assert($image.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${$image.rank}.`);
    assert($image.shape[2] === 3 || $image.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${$image.shape[2]}.`);
    assert($image.dtype === "int32" || $image.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${$image.dtype}.`);
    assert(method === "otsu" || method === "binary", () => `Method must be binary or otsu, but was ${method}`);
    if ($image.shape[2] === 3) {
      [r, g, b] = split($image, [1, 1, 1], -1);
      const $r = mul4(r, RED_INTENCITY_COEF);
      const $g = mul4(g, GREEN_INTENCITY_COEF);
      const $b = mul4(b, BLUE_INTENCITY_COEF);
      grayscale = add6(add6($r, $g), $b);
    } else {
      grayscale = image3;
    }
    if (method === "otsu") {
      const $histogram = bincount(cast(round5(grayscale), "int32"), tensor([]), 256);
      $threshold = otsu($histogram, totalPixelsInImage);
    }
    const invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);
    const result = cast(mul4(invCondition, 255), "int32");
    return result;
  }
  function otsu(histogram, total) {
    let bestThresh = tensor1d([-1]);
    let bestInBetVar = tensor1d([0]);
    let cInBetVar = tensor1d([0]);
    let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
    for (let index = 0; index < histogram.size - 1; index++) {
      classFirst = slice(histogram, 0, index + 1);
      classSecond = slice(histogram, index + 1);
      weightForeground = div3(sum2(classFirst), total);
      weightBack = div3(sum2(classSecond), total);
      const meanFirstDivA = sum2(mul4(classFirst, range(0, classFirst.size)));
      meanFirst = div3(meanFirstDivA, sum2(classFirst));
      const meanSecFill = fill(classSecond.shape, classFirst.size);
      const meanSecAdd = add6(range(0, classSecond.size), meanSecFill);
      const meanSecMul = mul4(classSecond, meanSecAdd);
      meanSec = div3(sum2(meanSecMul), sum2(classSecond));
      const cInBetVarSubA = sub4(meanFirst, meanSec);
      const cInBetVarSubB = sub4(meanFirst, meanSec);
      const cInBetVarMul = mul4(weightForeground, weightBack);
      cInBetVar = mul4(mul4(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
      const condition = greater(cInBetVar, bestInBetVar);
      bestInBetVar = where(condition, cInBetVar, bestInBetVar);
      bestThresh = where(condition, tensor1d([index]), bestThresh);
    }
    return bestThresh;
  }
  var threshold = op({ threshold_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/image/transform.js
  function transform_(image3, transforms, interpolation = "nearest", fillMode = "constant", fillValue = 0, outputShape) {
    const $image = convertToTensor(image3, "image", "transform", "float32");
    const $transforms = convertToTensor(transforms, "transforms", "transform", "float32");
    assert($image.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${$image.rank}.`);
    assert($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
    assert(outputShape == null || outputShape.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${outputShape}.`);
    const inputs = { image: $image, transforms: $transforms };
    const attrs = { interpolation, fillMode, fillValue, outputShape };
    return ENGINE.runKernel(Transform, inputs, attrs);
  }
  var transform6 = op({ transform_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linalg/band_part.js
  function bandPart_(a, numLower, numUpper) {
    assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
    assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
    const $a = convertToTensor(a, "a", "bandPart");
    assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
    const shape = $a.shape;
    const [M, N] = $a.shape.slice(-2);
    if (!(numLower <= M)) {
      throw new Error(`bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M}).`);
    }
    if (!(numUpper <= N)) {
      throw new Error(`bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N}).`);
    }
    if (numLower < 0) {
      numLower = M;
    }
    if (numUpper < 0) {
      numUpper = N;
    }
    const i = reshape(range(0, M, 1, "int32"), [-1, 1]);
    const j = range(0, N, 1, "int32");
    const ij = sub4(i, j);
    const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, "int32")), greaterEqual(ij, scalar(-numUpper, "int32")));
    const zero4 = zeros([M, N], $a.dtype);
    return reshape(stack2(unstack(reshape($a, [-1, M, N])).map((mat) => where(inBand, mat, zero4))), shape);
  }
  var bandPart = op({ bandPart_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linalg/gram_schmidt.js
  function gramSchmidt_(xs) {
    let inputIsTensor2D;
    if (Array.isArray(xs)) {
      inputIsTensor2D = false;
      assert(xs != null && xs.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
      const dim = xs[0].shape[0];
      for (let i = 1; i < xs.length; ++i) {
        assert(xs[i].shape[0] === dim, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs[i].shape[0]} vs. ${dim})`);
      }
    } else {
      inputIsTensor2D = true;
      xs = split(xs, xs.shape[0], 0).map((x) => squeeze(x, [0]));
    }
    assert(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds number of dimensions (${xs[0].shape[0]}).`);
    const ys = [];
    const xs1d = xs;
    for (let i = 0; i < xs.length; ++i) {
      ys.push(ENGINE.tidy(() => {
        let x = xs1d[i];
        if (i > 0) {
          for (let j = 0; j < i; ++j) {
            const proj = mul4(sum2(mul4(ys[j], x)), ys[j]);
            x = sub4(x, proj);
          }
        }
        return div3(x, norm(x, "euclidean"));
      }));
    }
    if (inputIsTensor2D) {
      return stack2(ys, 0);
    } else {
      return ys;
    }
  }
  var gramSchmidt = op({ gramSchmidt_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/linalg/qr.js
  function qr_(x, fullMatrices = false) {
    assert(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);
    if (x.rank === 2) {
      return qr2d(x, fullMatrices);
    } else {
      const outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce((value, prev) => value * prev);
      const x2ds = unstack(reshape(x, [
        outerDimsProd,
        x.shape[x.shape.length - 2],
        x.shape[x.shape.length - 1]
      ]), 0);
      const q2ds = [];
      const r2ds = [];
      x2ds.forEach((x2d) => {
        const [q2d, r2d] = qr2d(x2d, fullMatrices);
        q2ds.push(q2d);
        r2ds.push(r2d);
      });
      const q = reshape(stack2(q2ds, 0), x.shape);
      const r = reshape(stack2(r2ds, 0), x.shape);
      return [q, r];
    }
  }
  function qr2d(x, fullMatrices = false) {
    return ENGINE.tidy(() => {
      assert(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);
      const m = x.shape[0];
      const n = x.shape[1];
      let q = eye(m);
      let r = clone5(x);
      const one2D = tensor2d([[1]], [1, 1]);
      let w = clone5(one2D);
      const iters = m >= n ? n : m;
      for (let j = 0; j < iters; ++j) {
        const rTemp = r;
        const wTemp = w;
        const qTemp = q;
        [w, r, q] = ENGINE.tidy(() => {
          const rjEnd1 = slice(r, [j, j], [m - j, 1]);
          const normX = norm(rjEnd1);
          const rjj = slice(r, [j, j], [1, 1]);
          const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
          const u1 = sub4(rjj, mul4(s, normX));
          const wPre = div3(rjEnd1, u1);
          if (wPre.shape[0] === 1) {
            w = clone5(one2D);
          } else {
            w = concat([
              one2D,
              slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
            ], 0);
          }
          const tau2 = neg(div3(matMul(s, u1), normX));
          const rjEndAll = slice(r, [j, 0], [m - j, n]);
          const tauTimesW = mul4(tau2, w);
          const wT = transpose2(w);
          if (j === 0) {
            r = sub4(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
          } else {
            const rTimesTau = sub4(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
            r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);
          }
          const tawTimesWT = transpose2(tauTimesW);
          const qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);
          if (j === 0) {
            q = sub4(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
          } else {
            const qTimesTau = sub4(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
            q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);
          }
          return [w, r, q];
        });
        dispose([rTemp, wTemp, qTemp]);
      }
      if (!fullMatrices && m > n) {
        q = slice(q, [0, 0], [m, n]);
        r = slice(r, [0, 0], [n, n]);
      }
      return [q, r];
    });
  }
  var qr = op({ qr_ });

  // node_modules/@tensorflow/tfjs-core/dist/ops/ops.js
  var image = {
    flipLeftRight,
    grayscaleToRGB,
    resizeNearestNeighbor,
    resizeBilinear,
    rotateWithOffset,
    cropAndResize,
    nonMaxSuppression,
    nonMaxSuppressionAsync,
    nonMaxSuppressionWithScore,
    nonMaxSuppressionWithScoreAsync,
    nonMaxSuppressionPadded,
    nonMaxSuppressionPaddedAsync,
    threshold,
    transform: transform6
  };
  var linalg = {
    bandPart,
    gramSchmidt,
    qr
  };

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/optimizer.js
  var Optimizer = class extends Serializable {
    minimize(f, returnCost = false, varList) {
      const { value, grads } = this.computeGradients(f, varList);
      if (varList != null) {
        const gradArray = varList.map((v) => ({ name: v.name, tensor: grads[v.name] }));
        this.applyGradients(gradArray);
      } else {
        this.applyGradients(grads);
      }
      dispose(grads);
      if (returnCost) {
        return value;
      } else {
        value.dispose();
        return null;
      }
    }
    get iterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    computeGradients(f, varList) {
      return variableGrads(f, varList);
    }
    dispose() {
      if (this.iterations_ != null) {
        dispose(this.iterations_);
      }
    }
    async saveIterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return {
        name: "iter",
        tensor: scalar(this.iterations_, "int32")
      };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(weightValues) {
      throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    async extractIterations(weightValues) {
      this.iterations_ = (await weightValues[0].tensor.data())[0];
      return weightValues.slice(1);
    }
  };
  Object.defineProperty(Optimizer, Symbol.hasInstance, {
    value: (instance) => {
      return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
    }
  });

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adadelta_optimizer.js
  var AdadeltaOptimizer = class extends Optimizer {
    constructor(learningRate, rho, epsilon3 = null) {
      super();
      this.learningRate = learningRate;
      this.rho = rho;
      this.epsilon = epsilon3;
      this.accumulatedGrads = [];
      this.accumulatedUpdates = [];
      if (epsilon3 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedGrads[i] == null) {
          this.accumulatedGrads[i] = {
            originalName: `${name}/accum_grad`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedUpdates[i] == null) {
          this.accumulatedUpdates[i] = {
            originalName: `${name}/accum_var`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient2 == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i].variable;
        const accumulatedUpdate = this.accumulatedUpdates[i].variable;
        tidy(() => {
          const newAccumulatedGrad = add6(mul4(accumulatedGrad, this.rho), mul4(square(gradient2), 1 - this.rho));
          const updates = mul4(div3(sqrt(add6(accumulatedUpdate, this.epsilon)), sqrt(add6(accumulatedGrad, this.epsilon))), gradient2);
          const newAccumulatedUpdate = add6(mul4(accumulatedUpdate, this.rho), mul4(square(updates), 1 - this.rho));
          accumulatedGrad.assign(newAccumulatedGrad);
          accumulatedUpdate.assign(newAccumulatedUpdate);
          const newValue = add6(mul4(updates, -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedUpdates != null) {
        dispose(this.accumulatedGrads.map((v) => v.variable));
        dispose(this.accumulatedUpdates.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedGrads = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "rho": this.rho,
        "epsilon": this.epsilon
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["rho"], config["epsilon"]);
    }
  };
  AdadeltaOptimizer.className = "Adadelta";
  registerClass2(AdadeltaOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adagrad_optimizer.js
  var AdagradOptimizer = class extends Optimizer {
    constructor(learningRate, initialAccumulatorValue = 0.1) {
      super();
      this.learningRate = learningRate;
      this.initialAccumulatorValue = initialAccumulatorValue;
      this.accumulatedGrads = [];
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulatedGrads[i] == null) {
          const trainable = false;
          this.accumulatedGrads[i] = {
            originalName: `${name}/accumulator`,
            variable: tidy(() => fill(value.shape, this.initialAccumulatorValue).variable(trainable))
          };
        }
        const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient2 == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i].variable;
        tidy(() => {
          const newAccumulatedGrad = add6(accumulatedGrad, square(gradient2));
          accumulatedGrad.assign(newAccumulatedGrad);
          const newValue = add6(mul4(div3(gradient2, sqrt(add6(newAccumulatedGrad, ENGINE.backend.epsilon()))), -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedGrads != null) {
        dispose(this.accumulatedGrads.map((v) => v.variable));
      }
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulatedGrads.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulatedGrads = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "initialAccumulatorValue": this.initialAccumulatorValue
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["initialAccumulatorValue"]);
    }
  };
  AdagradOptimizer.className = "Adagrad";
  registerClass2(AdagradOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adam_optimizer.js
  var AdamOptimizer = class extends Optimizer {
    constructor(learningRate, beta1, beta2, epsilon3 = null) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon3;
      this.accumulatedFirstMoment = [];
      this.accumulatedSecondMoment = [];
      tidy(() => {
        this.accBeta1 = scalar(beta1).variable();
        this.accBeta2 = scalar(beta2).variable();
      });
      if (epsilon3 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub4(1, this.accBeta1);
        const oneMinusAccBeta2 = sub4(1, this.accBeta2);
        varNames.forEach((name, i) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i] == null) {
            this.accumulatedFirstMoment[i] = {
              originalName: `${name}/m`,
              variable: tidy(() => zerosLike(value).variable(trainable))
            };
          }
          if (this.accumulatedSecondMoment[i] == null) {
            this.accumulatedSecondMoment[i] = {
              originalName: `${name}/v`,
              variable: tidy(() => zerosLike(value).variable(trainable))
            };
          }
          const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient2 == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i].variable;
          const secondMoment = this.accumulatedSecondMoment[i].variable;
          const newFirstMoment = add6(mul4(firstMoment, this.beta1), mul4(gradient2, 1 - this.beta1));
          const newSecondMoment = add6(mul4(secondMoment, this.beta2), mul4(square(gradient2), 1 - this.beta2));
          const biasCorrectedFirstMoment = div3(newFirstMoment, oneMinusAccBeta1);
          const biasCorrectedSecondMoment = div3(newSecondMoment, oneMinusAccBeta2);
          firstMoment.assign(newFirstMoment);
          secondMoment.assign(newSecondMoment);
          const newValue = add6(mul4(div3(biasCorrectedFirstMoment, add6(sqrt(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
          value.assign(newValue);
        });
        this.accBeta1.assign(mul4(this.accBeta1, this.beta1));
        this.accBeta2.assign(mul4(this.accBeta2, this.beta2));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.accBeta2.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v) => v.variable));
      }
      if (this.accumulatedSecondMoment != null) {
        dispose(this.accumulatedSecondMoment.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      tidy(() => {
        this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));
        this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));
      });
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "beta1": this.beta1,
        "beta2": this.beta2,
        "epsilon": this.epsilon
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"]);
    }
  };
  AdamOptimizer.className = "Adam";
  registerClass2(AdamOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/adamax_optimizer.js
  var AdamaxOptimizer = class extends Optimizer {
    constructor(learningRate, beta1, beta2, epsilon3 = null, decay = 0) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon3;
      this.decay = decay;
      this.accumulatedFirstMoment = [];
      this.accumulatedWeightedInfNorm = [];
      tidy(() => {
        this.iteration = scalar(0).variable();
        this.accBeta1 = scalar(beta1).variable();
      });
      if (epsilon3 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub4(1, this.accBeta1);
        const lr = div3(-this.learningRate, add6(mul4(this.iteration, this.decay), 1));
        variableNames.forEach((name, i) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i] == null) {
            this.accumulatedFirstMoment[i] = {
              originalName: `${name}/m`,
              variable: zerosLike(value).variable(trainable)
            };
          }
          if (this.accumulatedWeightedInfNorm[i] == null) {
            this.accumulatedWeightedInfNorm[i] = {
              originalName: `${name}/v`,
              variable: zerosLike(value).variable(trainable)
            };
          }
          const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient2 == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i].variable;
          const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;
          const newFirstMoment = add6(mul4(firstMoment, this.beta1), mul4(gradient2, 1 - this.beta1));
          const ut0 = mul4(weightedInfNorm, this.beta2);
          const ut1 = abs(gradient2);
          const newWeightedInfNorm = maximum(ut0, ut1);
          firstMoment.assign(newFirstMoment);
          weightedInfNorm.assign(newWeightedInfNorm);
          const newValue = add6(mul4(div3(lr, oneMinusAccBeta1), div3(newFirstMoment, add6(newWeightedInfNorm, this.epsilon))), value);
          value.assign(newValue);
        });
        this.iteration.assign(add6(this.iteration, 1));
        this.accBeta1.assign(mul4(this.accBeta1, this.beta1));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.iteration.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v) => v.variable));
      }
      if (this.accumulatedWeightedInfNorm != null) {
        dispose(this.accumulatedWeightedInfNorm.map((v) => v.variable));
      }
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(weightValues) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "beta1": this.beta1,
        "beta2": this.beta2,
        "epsilon": this.epsilon,
        "decay": this.decay
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"], config["decay"]);
    }
  };
  AdamaxOptimizer.className = "Adamax";
  registerClass2(AdamaxOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/sgd_optimizer.js
  var SGDOptimizer = class extends Optimizer {
    constructor(learningRate) {
      super();
      this.learningRate = learningRate;
      this.setLearningRate(learningRate);
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
      varNames.forEach((name, i) => {
        const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient2 == null) {
          return;
        }
        const value = ENGINE.registeredVariables[name];
        tidy(() => {
          const newValue = add6(mul4(this.c, gradient2), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    setLearningRate(learningRate) {
      this.learningRate = learningRate;
      if (this.c != null) {
        this.c.dispose();
      }
      this.c = keep(scalar(-learningRate));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [await this.saveIterations()];
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      if (weightValues.length !== 0) {
        throw new Error("SGD optimizer does not have settable weights.");
      }
    }
    getConfig() {
      return { "learningRate": this.learningRate };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"]);
    }
  };
  SGDOptimizer.className = "SGD";
  registerClass2(SGDOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/momentum_optimizer.js
  var MomentumOptimizer = class extends SGDOptimizer {
    constructor(learningRate, momentum, useNesterov = false) {
      super(learningRate);
      this.learningRate = learningRate;
      this.momentum = momentum;
      this.useNesterov = useNesterov;
      this.accumulations = [];
      this.m = scalar(this.momentum);
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulations[i] == null) {
          const trainable = false;
          this.accumulations[i] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const accumulation = this.accumulations[i].variable;
        const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient2 == null) {
          return;
        }
        tidy(() => {
          let newValue;
          const newAccumulation = add6(mul4(this.m, accumulation), gradient2);
          if (this.useNesterov) {
            newValue = add6(mul4(this.c, add6(gradient2, mul4(newAccumulation, this.m))), value);
          } else {
            newValue = add6(mul4(this.c, newAccumulation), value);
          }
          accumulation.assign(newAccumulation);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      this.m.dispose();
      if (this.accumulations != null) {
        dispose(this.accumulations.map((v) => v.variable));
      }
    }
    setMomentum(momentum) {
      this.momentum = momentum;
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulations.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulations = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "momentum": this.momentum,
        "useNesterov": this.useNesterov
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["momentum"], config["useNesterov"]);
    }
  };
  MomentumOptimizer.className = "Momentum";
  registerClass2(MomentumOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/rmsprop_optimizer.js
  var RMSPropOptimizer = class extends Optimizer {
    constructor(learningRate, decay = 0.9, momentum = 0, epsilon3 = null, centered = false) {
      super();
      this.learningRate = learningRate;
      this.decay = decay;
      this.momentum = momentum;
      this.epsilon = epsilon3;
      this.accumulatedMeanSquares = [];
      this.accumulatedMoments = [];
      this.accumulatedMeanGrads = [];
      this.centered = centered;
      if (epsilon3 == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
      if (learningRate == null) {
        throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedMeanSquares[i] == null) {
          this.accumulatedMeanSquares[i] = {
            originalName: `${name}/rms`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedMoments[i] == null) {
          this.accumulatedMoments[i] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedMeanGrads[i] == null && this.centered) {
          this.accumulatedMeanGrads[i] = {
            originalName: `${name}/mg`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient2 = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient2 == null) {
          return;
        }
        const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;
        const accumulatedMoments = this.accumulatedMoments[i].variable;
        tidy(() => {
          const newAccumulatedMeanSquare = add6(mul4(accumulatedMeanSquare, this.decay), mul4(square(gradient2), 1 - this.decay));
          if (this.centered) {
            const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;
            const newAccumulatedMeanGrad = add6(mul4(accumulatedMeanGrad, this.decay), mul4(gradient2, 1 - this.decay));
            const gradContribution = div3(mul4(gradient2, this.learningRate), sqrt(sub4(newAccumulatedMeanSquare, add6(square(newAccumulatedMeanGrad), this.epsilon))));
            const newAccumulatedMoments = add6(mul4(accumulatedMoments, this.momentum), gradContribution);
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
            accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub4(value, newAccumulatedMoments);
            value.assign(newValue);
          } else {
            const newAccumulatedMeanSquare2 = add6(mul4(accumulatedMeanSquare, this.decay), mul4(square(gradient2), 1 - this.decay));
            const newAccumulatedMoments = add6(mul4(accumulatedMoments, this.momentum), div3(mul4(gradient2, this.learningRate), sqrt(add6(newAccumulatedMeanSquare2, this.epsilon))));
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub4(value, newAccumulatedMoments);
            value.assign(newValue);
          }
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedMeanSquares != null) {
        dispose(this.accumulatedMeanSquares.map((v) => v.variable));
      }
      if (this.accumulatedMeanGrads != null && this.centered) {
        dispose(this.accumulatedMeanGrads.map((v) => v.variable));
      }
      if (this.accumulatedMoments != null) {
        dispose(this.accumulatedMoments.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      if (this.centered) {
        variables.push(...this.accumulatedMeanGrads);
      }
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
      const trainable = false;
      this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      if (this.centered) {
        this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
      }
    }
    getConfig() {
      return {
        "learningRate": this.learningRate,
        "decay": this.decay,
        "momentum": this.momentum,
        "epsilon": this.epsilon,
        "centered": this.centered
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["decay"], config["momentum"], config["epsilon"], config["centered"]);
    }
  };
  RMSPropOptimizer.className = "RMSProp";
  registerClass2(RMSPropOptimizer);

  // node_modules/@tensorflow/tfjs-core/dist/optimizers/optimizer_constructors.js
  var OptimizerConstructors = class {
    static sgd(learningRate) {
      return new SGDOptimizer(learningRate);
    }
    static momentum(learningRate, momentum, useNesterov = false) {
      return new MomentumOptimizer(learningRate, momentum, useNesterov);
    }
    static rmsprop(learningRate, decay = 0.9, momentum = 0, epsilon3 = null, centered = false) {
      return new RMSPropOptimizer(learningRate, decay, momentum, epsilon3, centered);
    }
    static adam(learningRate = 1e-3, beta1 = 0.9, beta2 = 0.999, epsilon3 = null) {
      return new AdamOptimizer(learningRate, beta1, beta2, epsilon3);
    }
    static adadelta(learningRate = 1e-3, rho = 0.95, epsilon3 = null) {
      return new AdadeltaOptimizer(learningRate, rho, epsilon3);
    }
    static adamax(learningRate = 2e-3, beta1 = 0.9, beta2 = 0.999, epsilon3 = null, decay = 0) {
      return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon3, decay);
    }
    static adagrad(learningRate, initialAccumulatorValue = 0.1) {
      return new AdagradOptimizer(learningRate, initialAccumulatorValue);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/train.js
  var train = {
    sgd: OptimizerConstructors.sgd,
    momentum: OptimizerConstructors.momentum,
    adadelta: OptimizerConstructors.adadelta,
    adagrad: OptimizerConstructors.adagrad,
    rmsprop: OptimizerConstructors.rmsprop,
    adamax: OptimizerConstructors.adamax,
    adam: OptimizerConstructors.adam
  };

  // node_modules/@tensorflow/tfjs-core/dist/browser_util.js
  var delayCallback = (() => {
    if (typeof requestAnimationFrame !== "undefined") {
      return requestAnimationFrame;
    } else if (typeof setImmediate !== "undefined") {
      return setImmediate;
    }
    return (f) => f();
  })();
  function nextFrame2() {
    return new Promise((resolve) => delayCallback(() => resolve()));
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js
  var backend_util_exports = {};
  __export(backend_util_exports, {
    ERF_A1: () => ERF_A1,
    ERF_A2: () => ERF_A2,
    ERF_A3: () => ERF_A3,
    ERF_A4: () => ERF_A4,
    ERF_A5: () => ERF_A5,
    ERF_P: () => ERF_P,
    PARALLELIZE_THRESHOLD: () => PARALLELIZE_THRESHOLD,
    SELU_SCALE: () => SELU_SCALE,
    SELU_SCALEALPHA: () => SELU_SCALEALPHA,
    applyActivation: () => applyActivation,
    assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
    assertAxesAreInnerMostDims: () => assertAxesAreInnerMostDims,
    assertParamsConsistent: () => assertParamsConsistent,
    assignToTypedArray: () => assignToTypedArray,
    axesAreInnerMostDims: () => axesAreInnerMostDims,
    calculateShapes: () => calculateShapes,
    checkEinsumDimSizes: () => checkEinsumDimSizes,
    combineLocations: () => combineLocations,
    complexWithEvenIndex: () => complexWithEvenIndex,
    complexWithOddIndex: () => complexWithOddIndex,
    computeConv2DInfo: () => computeConv2DInfo,
    computeConv3DInfo: () => computeConv3DInfo,
    computeDefaultPad: () => computeDefaultPad,
    computeDilation2DInfo: () => computeDilation2DInfo,
    computeOptimalWindowSize: () => computeOptimalWindowSize,
    computeOutAndReduceShapes: () => computeOutAndReduceShapes,
    computeOutShape: () => computeOutShape2,
    computePool2DInfo: () => computePool2DInfo,
    computePool3DInfo: () => computePool3DInfo,
    convertConv2DDataFormat: () => convertConv2DDataFormat,
    decodeEinsumEquation: () => decodeEinsumEquation,
    eitherStridesOrDilationsAreOne: () => eitherStridesOrDilationsAreOne,
    expandShapeToKeepDim: () => expandShapeToKeepDim,
    exponent: () => exponent2,
    exponents: () => exponents,
    fromStringArrayToUint8: () => fromStringArrayToUint8,
    fromUint8ToStringArray: () => fromUint8ToStringArray,
    getAxesPermutation: () => getAxesPermutation,
    getBroadcastDims: () => getBroadcastDims,
    getComplexWithIndex: () => getComplexWithIndex,
    getEinsumComputePath: () => getEinsumComputePath,
    getEinsumPermutation: () => getEinsumPermutation,
    getFusedBiasGradient: () => getFusedBiasGradient,
    getFusedDyActivation: () => getFusedDyActivation,
    getImageCenter: () => getImageCenter,
    getInnerMostAxes: () => getInnerMostAxes,
    getPermuted: () => getPermuted,
    getReductionAxes: () => getReductionAxes,
    getReshaped: () => getReshaped,
    getReshapedPermuted: () => getReshapedPermuted,
    getSliceBeginCoords: () => getSliceBeginCoords,
    getSliceSize: () => getSliceSize,
    getUndoAxesPermutation: () => getUndoAxesPermutation,
    isIdentityPermutation: () => isIdentityPermutation,
    log: () => log2,
    mergeRealAndImagArrays: () => mergeRealAndImagArrays,
    prepareAndValidate: () => prepareAndValidate,
    prepareSplitSize: () => prepareSplitSize,
    segment_util: () => segment_util_exports,
    shouldFuse: () => shouldFuse,
    slice_util: () => slice_util_exports,
    splitRealAndImagArrays: () => splitRealAndImagArrays,
    tupleValuesAreOne: () => tupleValuesAreOne,
    upcastType: () => upcastType,
    validateInput: () => validateInput,
    validateUpdateShape: () => validateUpdateShape,
    warn: () => warn3
  });

  // node_modules/@tensorflow/tfjs-core/dist/ops/concat_util.js
  function assertParamsConsistent(shapes, axis) {
    const rank = shapes[0].length;
    shapes.forEach((shape, i) => {
      assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`);
    });
    assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
    const firstShape = shapes[0];
    shapes.forEach((shape, i) => {
      for (let r = 0; r < rank; r++) {
        assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`);
      }
    });
  }
  function computeOutShape2(shapes, axis) {
    const outputShape = shapes[0].slice();
    for (let i = 1; i < shapes.length; i++) {
      outputShape[axis] += shapes[i][axis];
    }
    return outputShape;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/reduce_util.js
  var PARALLELIZE_THRESHOLD = 30;
  function computeOptimalWindowSize(inSize) {
    if (inSize <= PARALLELIZE_THRESHOLD) {
      return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/rotate_util.js
  function getImageCenter(center, imageHeight, imageWidth) {
    const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
    const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
    return [centerX, centerY];
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/array_ops_util.js
  function getReshaped(inputShape, blockShape, prod4, batchToSpace = true) {
    let reshaped = [];
    if (batchToSpace) {
      reshaped = reshaped.concat(blockShape.slice(0));
      reshaped.push(inputShape[0] / prod4);
      reshaped = reshaped.concat(inputShape.slice(1));
    } else {
      reshaped = reshaped.concat(inputShape[0]);
      const spatialLength = blockShape.length;
      for (let i = 0; i < spatialLength; ++i) {
        reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
      }
      reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
    }
    return reshaped;
  }
  function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
    const permuted = [];
    if (batchToSpace) {
      permuted.push(blockShapeRank);
      for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {
        if (i <= 2 * blockShapeRank) {
          permuted.push(i);
          permuted.push(i - (blockShapeRank + 1));
        } else {
          permuted.push(i);
        }
      }
    } else {
      const permutedBeforeBatch = [];
      const permutedAfterBatch = [];
      for (let i = 1; i < reshapedRank; ++i) {
        if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
          permutedAfterBatch.push(i);
        } else {
          permutedBeforeBatch.push(i);
        }
      }
      permuted.push(...permutedBeforeBatch);
      permuted.push(0);
      permuted.push(...permutedAfterBatch);
    }
    return permuted;
  }
  function getReshapedPermuted(inputShape, blockShape, prod4, batchToSpace = true) {
    const reshapedPermuted = [];
    if (batchToSpace) {
      reshapedPermuted.push(inputShape[0] / prod4);
    } else {
      reshapedPermuted.push(inputShape[0] * prod4);
    }
    for (let i = 1; i < inputShape.length; ++i) {
      if (i <= blockShape.length) {
        if (batchToSpace) {
          reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
        } else {
          reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
        }
      } else {
        reshapedPermuted.push(inputShape[i]);
      }
    }
    return reshapedPermuted;
  }
  function getSliceBeginCoords(crops, blockShape) {
    const sliceBeginCoords = [0];
    for (let i = 0; i < blockShape; ++i) {
      sliceBeginCoords.push(crops[i][0]);
    }
    return sliceBeginCoords;
  }
  function getSliceSize(uncroppedShape, crops, blockShape) {
    const sliceSize = uncroppedShape.slice(0, 1);
    for (let i = 0; i < blockShape; ++i) {
      sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
    }
    return sliceSize;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/selu_util.js
  var SELU_SCALEALPHA = 1.7580993408473768;
  var SELU_SCALE = 1.0507009873554805;

  // node_modules/@tensorflow/tfjs-core/dist/ops/erf_util.js
  var ERF_P = 0.3275911;
  var ERF_A1 = 0.254829592;
  var ERF_A2 = -0.284496736;
  var ERF_A3 = 1.421413741;
  var ERF_A4 = -1.453152027;
  var ERF_A5 = 1.061405429;

  // node_modules/@tensorflow/tfjs-core/dist/backends/complex_util.js
  function mergeRealAndImagArrays(real4, imag4) {
    if (real4.length !== imag4.length) {
      throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real4.length}, imag: ${imag4.length}.`);
    }
    const result = new Float32Array(real4.length * 2);
    for (let i = 0; i < result.length; i += 2) {
      result[i] = real4[i / 2];
      result[i + 1] = imag4[i / 2];
    }
    return result;
  }
  function splitRealAndImagArrays(complex4) {
    const real4 = new Float32Array(complex4.length / 2);
    const imag4 = new Float32Array(complex4.length / 2);
    for (let i = 0; i < complex4.length; i += 2) {
      real4[i / 2] = complex4[i];
      imag4[i / 2] = complex4[i + 1];
    }
    return { real: real4, imag: imag4 };
  }
  function complexWithEvenIndex(complex4) {
    const len3 = Math.ceil(complex4.length / 4);
    const real4 = new Float32Array(len3);
    const imag4 = new Float32Array(len3);
    for (let i = 0; i < complex4.length; i += 4) {
      real4[Math.floor(i / 4)] = complex4[i];
      imag4[Math.floor(i / 4)] = complex4[i + 1];
    }
    return { real: real4, imag: imag4 };
  }
  function complexWithOddIndex(complex4) {
    const len3 = Math.floor(complex4.length / 4);
    const real4 = new Float32Array(len3);
    const imag4 = new Float32Array(len3);
    for (let i = 2; i < complex4.length; i += 4) {
      real4[Math.floor(i / 4)] = complex4[i];
      imag4[Math.floor(i / 4)] = complex4[i + 1];
    }
    return { real: real4, imag: imag4 };
  }
  function getComplexWithIndex(complex4, index) {
    const real4 = complex4[index * 2];
    const imag4 = complex4[index * 2 + 1];
    return { real: real4, imag: imag4 };
  }
  function assignToTypedArray(data, real4, imag4, index) {
    data[index * 2] = real4;
    data[index * 2 + 1] = imag4;
  }
  function exponents(n, inverse3) {
    const real4 = new Float32Array(n / 2);
    const imag4 = new Float32Array(n / 2);
    for (let i = 0; i < Math.ceil(n / 2); i++) {
      const x = (inverse3 ? 2 : -2) * Math.PI * (i / n);
      real4[i] = Math.cos(x);
      imag4[i] = Math.sin(x);
    }
    return { real: real4, imag: imag4 };
  }
  function exponent2(k, n, inverse3) {
    const x = (inverse3 ? 2 : -2) * Math.PI * (k / n);
    const real4 = Math.cos(x);
    const imag4 = Math.sin(x);
    return { real: real4, imag: imag4 };
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/einsum_util.js
  var ARROW = "->";
  var ARROW_REGEX = /->/g;
  var COMMA = ",";
  var ELLIPSIS = "...";
  function decodeEinsumEquation(equation, numTensors) {
    equation = equation.replace(/\s/g, "");
    const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
    if (numArrows < 1) {
      throw new Error("Equations without an arrow are not supported.");
    } else if (numArrows > 1) {
      throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
    }
    const [inputString, outputString] = equation.split(ARROW);
    assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
    const inputTerms = inputString.split(COMMA);
    const numInputs = inputTerms.length;
    if (numTensors !== numInputs) {
      throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
    }
    if (numInputs > 2) {
      throw new Error("Support for more than 2 input tensors is not implemented yet.");
    }
    const allDims = [];
    for (let i = 0; i < outputString.length; ++i) {
      const dimName = outputString[i];
      if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
        throw new Error(`Output subscripts contain the label ${dimName} not present in the input subscripts.`);
      }
      if (allDims.indexOf(dimName) === -1) {
        allDims.push(dimName);
      }
    }
    for (let i = 0; i < inputString.length; ++i) {
      const dimName = inputString[i];
      if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
        allDims.push(dimName);
      }
    }
    const idDims = new Array(inputTerms.length);
    for (let i = 0; i < numInputs; ++i) {
      if (new Set(inputTerms[i].split("")).size !== inputTerms[i].length) {
        throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. Support for duplicate axes in input is not implemented yet.`);
      }
      idDims[i] = [];
      for (let j = 0; j < inputTerms[i].length; ++j) {
        idDims[i].push(allDims.indexOf(inputTerms[i][j]));
      }
    }
    const numDims = allDims.length;
    const numOutDims = outputString.length;
    const summedDims = [];
    for (let i = numOutDims; i < numDims; ++i) {
      summedDims.push(i);
    }
    return { allDims, summedDims, idDims };
  }
  function getEinsumPermutation(nDims, idDims) {
    let permutationIndices = new Array(nDims);
    permutationIndices.fill(-1);
    for (let i = 0; i < idDims.length; ++i) {
      permutationIndices[idDims[i]] = i;
    }
    const expandDims5 = [];
    for (let i = 0; i < nDims; ++i) {
      if (permutationIndices[i] === -1) {
        expandDims5.push(i);
      }
    }
    permutationIndices = permutationIndices.filter((d) => d !== -1);
    return { permutationIndices, expandDims: expandDims5 };
  }
  function checkEinsumDimSizes(nDims, idDims, tensors) {
    const dimSizes = new Array(nDims);
    for (let i = 0; i < tensors.length; ++i) {
      const shape = tensors[i].shape;
      for (let j = 0; j < idDims[i].length; ++j) {
        if (dimSizes[idDims[i][j]] === void 0) {
          dimSizes[idDims[i][j]] = shape[j];
        } else {
          assert(dimSizes[idDims[i][j]] === shape[j], () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} of input shaped ${JSON.stringify(shape)}, but got dimension ${shape[j]}`);
        }
      }
    }
  }
  function getEinsumComputePath(summedDims, idDims) {
    const path = summedDims;
    const steps = [];
    let nSteps = 0;
    if (summedDims.length === 0) {
      path.push(-1);
    }
    nSteps = summedDims.length + 1;
    for (let i = 0; i < nSteps; ++i) {
      steps.push([]);
    }
    const computedTermIndices = [];
    for (let i = 0; i < path.length; ++i) {
      const summedDim = path[i];
      const termIndices = findTermsWithDim(idDims, summedDim);
      for (const termIndex of termIndices) {
        if (computedTermIndices.indexOf(termIndex) === -1) {
          steps[i].push(termIndex);
          computedTermIndices.push(termIndex);
        }
      }
    }
    return { path, steps };
  }
  function isIdentityPermutation(perm) {
    return perm.every((dim, index) => dim === index);
  }
  function findTermsWithDim(idDims, dim) {
    const termIndices = [];
    for (let i = 0; i < idDims.length; ++i) {
      if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {
        termIndices.push(i);
      }
    }
    return termIndices;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/split_util.js
  function prepareSplitSize(x, numOrSizeSplits, axis = 0) {
    let splitSizes = [];
    if (typeof numOrSizeSplits === "number") {
      assert(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
      splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
    } else {
      const numOfNegs = numOrSizeSplits.reduce((count2, value) => {
        if (value === -1) {
          count2 += 1;
        }
        return count2;
      }, 0);
      assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
      const negIndex = numOrSizeSplits.indexOf(-1);
      if (negIndex !== -1) {
        const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
        numOrSizeSplits[negIndex] = x.shape[axis] - total;
      }
      assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
      splitSizes = numOrSizeSplits;
    }
    return splitSizes;
  }

  // node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js
  var segment_util_exports = {};
  __export(segment_util_exports, {
    collectGatherOpShapeInfo: () => collectGatherOpShapeInfo,
    computeOutShape: () => computeOutShape3,
    segOpComputeOptimalWindowSize: () => segOpComputeOptimalWindowSize
  });
  function segOpComputeOptimalWindowSize(inSize, numSegments) {
    let done = false;
    let res;
    if (inSize <= PARALLELIZE_THRESHOLD) {
      res = inSize;
      done = true;
    } else {
      res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
    }
    while (!done) {
      if (res > numSegments || res === inSize) {
        done = true;
      } else {
        res = nearestDivisor(inSize, res + 1);
      }
    }
    return res;
  }
  function computeOutShape3(aShape, axis, numSegments) {
    const outShape = [];
    const rank = aShape.length;
    for (let dim = 0; dim < rank; dim++) {
      if (dim !== axis) {
        outShape.push(aShape[dim]);
      } else {
        outShape.push(numSegments);
      }
    }
    return outShape;
  }
  function collectGatherOpShapeInfo(x, indices, axis, batchDims) {
    const indicesRank = indices.shape.length;
    const xRank = x.shape.length;
    if (batchDims !== 0) {
      if (batchDims < -indicesRank || batchDims > indicesRank) {
        throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
      }
    }
    if (batchDims < 0) {
      batchDims += indicesRank;
    }
    if (batchDims > xRank) {
      throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
    }
    if (axis < batchDims) {
      throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
    }
    for (let i = 0; i < batchDims; ++i) {
      if (x.shape[i] !== indices.shape[i]) {
        throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);
      }
    }
    const dimSize = x.shape[axis];
    const outputShape = [];
    let batchSize = 1;
    let outerSize = 1;
    let sliceSize = 1;
    for (let i = 0; i < batchDims; ++i) {
      outputShape.push(x.shape[i]);
      batchSize *= x.shape[i];
    }
    for (let i = batchDims; i < axis; i++) {
      outputShape.push(x.shape[i]);
      outerSize *= x.shape[i];
    }
    for (let i = batchDims; i < indicesRank; i++) {
      outputShape.push(indices.shape[i]);
    }
    for (let i = axis + 1; i < xRank; i++) {
      outputShape.push(x.shape[i]);
      sliceSize *= x.shape[i];
    }
    return { batchSize, sliceSize, outerSize, dimSize, outputShape };
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js
  function fromUint8ToStringArray(vals) {
    try {
      return vals.map((val) => decodeString(val));
    } catch (err) {
      throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
    }
  }
  function fromStringArrayToUint8(strings) {
    return strings.map((s) => encodeString(s));
  }

  // node_modules/@tensorflow/tfjs-core/dist/backends/kernel_impls.js
  var kernel_impls_exports = {};
  __export(kernel_impls_exports, {
    nonMaxSuppressionV3Impl: () => nonMaxSuppressionV3Impl,
    nonMaxSuppressionV4Impl: () => nonMaxSuppressionV4Impl,
    nonMaxSuppressionV5Impl: () => nonMaxSuppressionV5Impl,
    whereImpl: () => whereImpl
  });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Abs_grad.js
  var absGradConfig = {
    kernelName: Abs,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(dy, step(cast(x, "float32"), -1)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Acos_grad.js
  var acosGradConfig = {
    kernelName: Acos,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const a = square(cast(x, "float32"));
          const b = sqrt(sub4(scalar(1), a));
          return neg(div3(dy, b));
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Acosh_grad.js
  var acoshGradConfig = {
    kernelName: Acosh,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const a = sqrt(sub4(square(cast(x, "float32")), 1));
          return div3(dy, a);
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Add_grad.js
  var addGradConfig = {
    kernelName: Add,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        let res = dy;
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, a.shape);
      };
      const derB = () => {
        let res = dy;
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, b.shape);
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/AddN_grad.js
  var addNGradConfig = {
    kernelName: AddN,
    saveAllInputs: true,
    gradFunc: (dy, saved) => {
      const ders = {};
      saved.forEach((_6, i) => {
        ders[i] = () => dy.clone();
      });
      return ders;
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ArgMax_grad.js
  var argMaxGradConfig = {
    kernelName: ArgMax,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => zerosLike(x) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ArgMin_grad.js
  var argMinGradConfig = {
    kernelName: ArgMin,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => zerosLike(x) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Asin_grad.js
  var asinGradConfig = {
    kernelName: Asin,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, sqrt(sub4(scalar(1), square(cast(x, "float32"))))) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Asinh_grad.js
  var asinhGradConfig = {
    kernelName: Asinh,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const a = sqrt(add6(scalar(1), square(cast(x, "float32"))));
          return div3(dy, a);
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Atan2_grad.js
  var atan2GradConfig = {
    kernelName: Atan2,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const d = add6(square(a), square(b));
        let res = mul4(dy, div3(b, d));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, a.shape);
      };
      const derB = () => {
        const d = add6(square(a), square(b));
        let res = neg(mul4(dy, div3(a, d)));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, b.shape);
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Atan_grad.js
  var atanGradConfig = {
    kernelName: Atan,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, add6(square(cast(x, "float32")), 1)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Atanh_grad.js
  var atanhGradConfig = {
    kernelName: Atanh,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, sub4(scalar(1), square(cast(x, "float32")))) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_3d_grad.js
  function avgPool3dGrad_(dy, input2, filterSize, strides, pad3, dimRoundingMode) {
    const $dy = convertToTensor(dy, "dy", "avgPool3dGrad");
    const $input = convertToTensor(input2, "input", "avgPool3dGrad");
    let dy5D = $dy;
    let input5D = $input;
    let reshapedTo5D = false;
    if ($input.rank === 4) {
      reshapedTo5D = true;
      dy5D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
      input5D = reshape($input, [
        1,
        $input.shape[0],
        $input.shape[1],
        $input.shape[2],
        $input.shape[3]
      ]);
    }
    assert(dy5D.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ${dy5D.rank}.`);
    assert(input5D.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ${input5D.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { dy: dy5D, input: input5D };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
    const res = ENGINE.runKernel(AvgPool3DGrad, inputs, attrs);
    if (reshapedTo5D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var avgPool3dGrad = op({ avgPool3dGrad_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/AvgPool3D_grad.js
  var avgPool3DGradConfig = {
    kernelName: AvgPool3D,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
      return {
        x: () => avgPool3dGrad(dy, x, filterSize, strides, pad3, dimRoundingMode)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_grad.js
  function avgPoolGrad_(dy, input2, filterSize, strides, pad3) {
    const $dy = convertToTensor(dy, "dy", "avgPoolGrad");
    const $input = convertToTensor(input2, "input", "avgPoolGrad");
    assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
    let input4D = $input;
    let dy4D = $dy;
    let reshapedTo4D = false;
    if ($input.rank === 3) {
      reshapedTo4D = true;
      input4D = reshape($input, [1, $input.shape[0], $input.shape[1], $input.shape[2]]);
      dy4D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2]]);
    }
    assert(dy4D.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ${dy4D.rank}.`);
    assert(input4D.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ${input4D.rank}.`);
    const inputs = { dy: dy4D, input: input4D };
    const attrs = { filterSize, strides, pad: pad3 };
    const res = ENGINE.runKernel(AvgPoolGrad, inputs, attrs);
    if (reshapedTo4D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
    }
    return res;
  }
  var avgPoolGrad = op({ avgPoolGrad_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/AvgPool_grad.js
  var avgPoolGradConfig = {
    kernelName: AvgPool,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { filterSize, strides, pad: pad3 } = attrs;
      return { x: () => avgPoolGrad(dy, x, filterSize, strides, pad3) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/BatchMatMul_grad.js
  var batchMatMulGradConfig = {
    kernelName: BatchMatMul,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved, attrs) => {
      const [a, b] = saved;
      const { transposeA, transposeB } = attrs;
      if (!transposeA && !transposeB) {
        return {
          a: () => matMul(dy, b, false, true),
          b: () => matMul(a, dy, true, false)
        };
      } else if (!transposeA && transposeB) {
        return {
          a: () => matMul(dy, b, false, false),
          b: () => matMul(dy, a, true, false)
        };
      } else if (transposeA && !transposeB) {
        return {
          a: () => matMul(b, dy, false, true),
          b: () => matMul(a, dy, false, false)
        };
      } else {
        return {
          a: () => matMul(b, dy, true, true),
          b: () => matMul(dy, a, true, true)
        };
      }
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/BatchToSpaceND_grad.js
  var batchToSpaceNDGradConfig = {
    kernelName: BatchToSpaceND,
    gradFunc: (dy, saved, attrs) => {
      const { blockShape, crops } = attrs;
      return { x: () => spaceToBatchND(dy, blockShape, crops) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/BroadcastTo_grad.js
  var broadcastToGradConfig = {
    kernelName: BroadcastTo,
    gradFunc: (dy, saved, attrs) => {
      const broadCastToAttrs = attrs;
      const inputShape = broadCastToAttrs.inputShape;
      const outputShape = broadCastToAttrs.shape;
      const reps = Array.from(outputShape);
      for (let i = inputShape.length - 1; i >= 0; i--) {
        if (inputShape[i] === outputShape[i]) {
          reps[i] = 1;
        } else if (inputShape[i] !== 1) {
          throw new Error(`broadcastTo(): [${inputShape}] cannot be broadcast to [${outputShape}].`);
        }
      }
      const axes = [];
      for (let i = 0; i < reps.length; i++) {
        if (reps[i] > 1) {
          axes.push(i);
        }
      }
      return { x: () => sum2(dy, axes, true) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Cast_grad.js
  var castGradConfig = {
    kernelName: Cast,
    gradFunc: (dy) => {
      return { x: () => dy.clone() };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Ceil_grad.js
  var ceilGradConfig = {
    kernelName: Ceil,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ClipByValue_grad.js
  var clipByValueGradConfig = {
    kernelName: ClipByValue,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { clipValueMin, clipValueMax } = attrs;
      return {
        x: () => where(logicalAnd(greaterEqual(x, clipValueMin), lessEqual(x, clipValueMax)), dy, zerosLike(dy))
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ComplexAbs_grad.js
  var complexAbsGradConfig = {
    kernelName: ComplexAbs,
    inputsToSave: ["x"],
    gradFunc: absGradConfig.gradFunc
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Concat_grad.js
  var concatGradConfig = {
    kernelName: Concat,
    saveAllInputs: true,
    gradFunc: (dy, saved, attrs) => {
      const shapes = saved.map((t) => t.shape);
      const { axis } = attrs;
      const $axis = parseAxisParam(axis, saved[0].shape)[0];
      const sizeSplits = shapes.map((s) => s[$axis]);
      const derTensors = split(dy, sizeSplits, $axis);
      return derTensors.map((t) => () => t);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Conv2D_grad.js
  var conv2DGradConfig = {
    kernelName: Conv2D,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy, saved, attrs) => {
      const [x4D, $filter] = saved;
      const { dilations, strides, pad: pad3, dataFormat } = attrs;
      assert(tupleValuesAreOne(dilations), () => `Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
      return {
        x: () => conv2DBackpropInput(x4D.shape, dy, $filter, strides, pad3, dataFormat),
        filter: () => conv2DBackpropFilter(x4D, dy, $filter.shape, strides, pad3, dataFormat)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Conv2DBackpropInput_grad.js
  var conv2DBackpropInputGradConfig = {
    kernelName: Conv2DBackpropInput,
    inputsToSave: ["dy", "filter"],
    gradFunc: (ddx, saved, attrs) => {
      const [dy, filter2] = saved;
      const { strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
      return {
        dy: () => conv2d(ddx, filter2, strides, pad3, dataFormat, 1, dimRoundingMode),
        filter: () => conv2DBackpropFilter(ddx, dy, filter2.shape, strides, pad3, dataFormat, dimRoundingMode)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_backprop_filter.js
  function conv3DBackpropFilter_(x, dy, filterShape, strides, pad3) {
    let x5D = x;
    if (x.rank === 4) {
      x5D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2], x.shape[3]]);
    }
    let dy5D = dy;
    if (dy5D.rank === 4) {
      dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
    }
    assert(x5D.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ${x5D.shape}.`);
    assert(dy5D.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ${dy5D.shape}.`);
    assert(filterShape.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ${filterShape}.`);
    assert(x5D.shape[4] === filterShape[3], () => `Error in conv3dDerFilter: depth of input ${x5D.shape[4]}) must match input depth in filter (${filterShape[3]}.`);
    assert(dy5D.shape[4] === filterShape[4], () => `Error in conv3dDerFilter: depth of dy (${dy5D.shape[4]}) must match output depth for filter (${filterShape[4]}).`);
    const inputs = { x: x5D, dy: dy5D };
    const attrs = { strides, pad: pad3, filterShape };
    return ENGINE.runKernel(Conv3DBackpropFilterV2, inputs, attrs);
  }
  var conv3DBackpropFilter = op({ conv3DBackpropFilter_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Conv3D_grad.js
  var conv3DGradConfig = {
    kernelName: Conv3D,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy, saved, attrs) => {
      const { dilations, strides, pad: pad3 } = attrs;
      assert(tupleValuesAreOne(dilations), () => `Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
      const [x5D, $filter] = saved;
      return {
        x: () => conv3DBackpropInput(x5D.shape, dy, $filter, strides, pad3),
        filter: () => conv3DBackpropFilter(x5D, dy, $filter.shape, strides, pad3)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Cos_grad.js
  var cosGradConfig = {
    kernelName: Cos,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(neg(sin2(cast(x, "float32"))), dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Cosh_grad.js
  var coshGradConfig = {
    kernelName: Cosh,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(sinh(cast(x, "float32")), dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Cumsum_grad.js
  var cumsumGradConfig = {
    kernelName: Cumsum,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { axis, exclusive, reverse: reverse4 } = attrs;
      return {
        x: () => {
          const permutation = getAxesPermutation([axis], x.rank);
          let out = cumsum(dy, axis, exclusive, !reverse4);
          if (permutation != null) {
            out = transpose2(out, permutation);
          }
          return out;
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/DepthwiseConv2dNative_grad.js
  var depthwiseConv2dNativeGradConfig = {
    kernelName: DepthwiseConv2dNative,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy, saved, attrs) => {
      const { dilations, strides, pad: pad3, dimRoundingMode } = attrs;
      const $dilations = dilations == null ? [1, 1] : dilations;
      assert(tupleValuesAreOne($dilations), () => `Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${$dilations}'`);
      const [x, filter2] = saved;
      assert(x.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${x.rank}.`);
      assert(filter2.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${filter2.rank}.`);
      assert(x.shape[3] === filter2.shape[2], () => `Error in gradient of depthwiseConv2d: number of input channels (${x.shape[3]}) must match the inChannels dimension in filter ${filter2.shape[2]}.`);
      assert(eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${strides} and dilations '${$dilations}'.`);
      if (dimRoundingMode != null) {
        assert(isInt(pad3), () => `Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
      }
      return {
        x: () => depthwiseConv2dNativeBackpropInput(x.shape, dy, filter2, strides, pad3, $dilations, dimRoundingMode),
        filter: () => depthwiseConv2dNativeBackpropFilter(x, dy, filter2.shape, strides, pad3, $dilations, dimRoundingMode)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Dilation2D_grad.js
  var dilation2dGradConfig = {
    kernelName: Dilation2D,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy, saved, attrs) => {
      const [x, filter2] = saved;
      const inputInputs = { x, filter: filter2, dy };
      const filterInputs = { x, filter: filter2, dy };
      return {
        x: () => ENGINE.runKernel(Dilation2DBackpropInput, inputInputs, attrs),
        filter: () => ENGINE.runKernel(Dilation2DBackpropFilter, filterInputs, attrs)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Elu_grad.js
  var eluGradConfig = {
    kernelName: Elu,
    outputsToSave: [true],
    gradFunc: (dy, saved) => {
      const [y] = saved;
      const inputs = { dy, y };
      return { x: () => ENGINE.runKernel(EluGrad, inputs) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Erf_grad.js
  var erfGradConfig = {
    kernelName: Erf,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      const a = mul4(exp(neg(square(x))), 2 / Math.sqrt(Math.PI));
      return { x: () => mul4(dy, a) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Exp_grad.js
  var expGradConfig = {
    kernelName: Exp,
    outputsToSave: [true],
    gradFunc: (dy, saved) => {
      const [y] = saved;
      return { x: () => mul4(dy, y) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ExpandDims_grad.js
  var expandDimsGradConfig = {
    kernelName: ExpandDims,
    inputsToSave: ["input"],
    gradFunc: (dy, saved) => {
      const [input2] = saved;
      return { input: () => reshape(dy, input2.shape) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Expm1_grad.js
  var expm1GradConfig = {
    kernelName: Expm1,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(dy, exp(x)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Floor_grad.js
  var floorGradConfig = {
    kernelName: Floor,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/FloorDiv_grad.js
  var floorDivGradConfig = {
    kernelName: FloorDiv,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const res = div3(dy, cast(b, "float32"));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), a.shape);
        }
        return res;
      };
      const derB = () => {
        let res = mul4(dy, cast(a, "float32"));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = reshape(sum2(res, reduceAxes), b.shape);
        }
        const tmp = square(b);
        return neg(div3(res, cast(tmp, "float32")));
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/FusedBatchNorm_grad.js
  var fusedBatchNormGradConfig = {
    kernelName: FusedBatchNorm,
    inputsToSave: ["x", "mean", "variance", "scale"],
    gradFunc: (dy, saved, attrs) => {
      const { varianceEpsilon } = attrs;
      const [x, mean3, variance, scale5] = saved;
      const scaleValue = scale5 == null ? scalar(1) : scale5;
      const reductionAxes = getReductionAxes(mean3.shape, x.shape);
      const tileShape = [];
      if (mean3.rank === 1) {
        for (let i = 0; i < x.shape.length - 1; ++i) {
          tileShape.push(x.shape[i]);
        }
        tileShape.push(1);
      }
      const xMinusMean = sub4(x, mean3);
      const dyTimesScaleValue = mul4(dy, scaleValue);
      const oneOverSqrtVariance = rsqrt(add6(variance, scalar(varianceEpsilon)));
      const minusHalfRCube = mul4(mul4(mul4(oneOverSqrtVariance, oneOverSqrtVariance), oneOverSqrtVariance), scalar(-0.5));
      const derX = () => {
        if (mean3.rank === 1) {
          return reshape(mul4(mul4(dy, tile(reshape(oneOverSqrtVariance, [1, 1, 1, mean3.shape[0]]), tileShape)), scaleValue), x.shape);
        } else {
          return reshape(mul4(mul4(dy, oneOverSqrtVariance), scaleValue), x.shape);
        }
      };
      const derMean = () => {
        let meanDer = mul4(mul4(oneOverSqrtVariance, scalar(-1)), dyTimesScaleValue);
        if (mean3.rank === 1) {
          meanDer = sum2(meanDer, reductionAxes);
        }
        return reshape(meanDer, mean3.shape);
      };
      const derVariance = () => {
        let varianceDer = mul4(mul4(minusHalfRCube, xMinusMean), dyTimesScaleValue);
        if (mean3.rank === 1) {
          varianceDer = sum2(varianceDer, reductionAxes);
        }
        return reshape(varianceDer, mean3.shape);
      };
      const derScale = () => {
        const xMinusMean2TimesRsqrt = mul4(xMinusMean, oneOverSqrtVariance);
        let scaleDer = mul4(dy, xMinusMean2TimesRsqrt);
        if (mean3.rank === 1) {
          scaleDer = sum2(scaleDer, reductionAxes);
        }
        return reshape(scaleDer, mean3.shape);
      };
      const derOffset = () => {
        let offsetDer = dy;
        if (mean3.rank === 1) {
          offsetDer = sum2(offsetDer, reductionAxes);
        }
        return reshape(offsetDer, mean3.shape);
      };
      return {
        x: derX,
        mean: derMean,
        variance: derVariance,
        scale: derScale,
        offset: derOffset
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/GatherV2_grad.js
  var gatherGradConfig = {
    kernelName: GatherV2,
    inputsToSave: ["x", "indices"],
    gradFunc: (dy, saved, attrs) => {
      const [x, indices] = saved;
      const { axis } = attrs;
      const parsedAxis = parseAxisParam(axis, x.shape)[0];
      const derX = () => {
        const paramsShape = x.shape;
        const indicesSize = indices.size;
        const outerShape = paramsShape.slice(0, parsedAxis);
        const outerDims = outerShape.length;
        const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);
        const innerDims = innerShape.length;
        const outerAxesIndices = arrayRange(0, outerDims);
        const innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);
        const valuesShape = arrayConcat([outerShape, [indicesSize], innerShape]);
        const values2 = reshape(dy, valuesShape);
        const reshapedIndices = reshape(indices, [indicesSize]);
        const transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);
        const valuesTranspose = transpose2(values2, transposeDims);
        let paramsGrad = unsortedSegmentSum(valuesTranspose, reshapedIndices, x.shape[parsedAxis]);
        const invertTransposeDims = getUndoAxesPermutation(transposeDims);
        paramsGrad = transpose2(paramsGrad, invertTransposeDims);
        return paramsGrad;
      };
      return { x: derX, indices: () => indices };
    }
  };
  function arrayRange(start, stop2) {
    const result = [];
    for (let i = start; i < stop2; ++i) {
      result.push(i);
    }
    return result;
  }
  function arrayConcat(arrays) {
    const result = [];
    for (let i = 0; i < arrays.length; ++i) {
      for (let j = 0; j < arrays[i].length; ++j) {
        result.push(arrays[i][j]);
      }
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-core/dist/gradients/GreaterEqual_grad.js
  var greaterEqualGradConfig = {
    kernelName: GreaterEqual,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      return { a: () => zerosLike(a), b: () => zerosLike(b) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Identity_grad.js
  var identityGradConfig = {
    kernelName: Identity2,
    gradFunc: (dy) => {
      return { x: () => cast(dy, "float32") };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/IsFinite_grad.js
  var isFiniteGradConfig = {
    kernelName: IsFinite,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/IsInf_grad.js
  var isInfGradConfig = {
    kernelName: IsInf,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/IsNan_grad.js
  var isNanGradConfig = {
    kernelName: IsNan,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/LeakyRelu_grad.js
  var leakyReluGradConfig = {
    kernelName: LeakyRelu,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { alpha } = attrs;
      const mask = greater(x, 0);
      return { x: () => where(mask, dy, mul4(dy, alpha)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Log1p_grad.js
  var log1pGradConfig = {
    kernelName: Log1p,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, add6(x, 1)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Log_grad.js
  var logGradConfig = {
    kernelName: Log2,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, cast(x, "float32")) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/LogSoftmax_grad.js
  var logSoftmaxGradConfig = {
    kernelName: LogSoftmax,
    inputsToSave: [],
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const [value] = saved;
      const { axis } = attrs;
      return {
        logits: () => {
          const keepDims = true;
          const softmax4 = exp(value);
          return sub4(dy, mul4(sum2(dy, axis, keepDims), softmax4));
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/local_response_normalization_backprop.js
  function localResponseNormalizationBackprop_(x, y, dy, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
    const inputs = { x, y, dy };
    const attrs = { depthRadius, bias, alpha, beta };
    return ENGINE.runKernel(LRNGrad, inputs, attrs);
  }
  var localResponseNormalizationBackprop = op({ localResponseNormalizationBackprop_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/LRN_grad.js
  var lrnGradConfig = {
    kernelName: LRN,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const [x, y] = saved;
      const { depthRadius, bias, alpha, beta } = attrs;
      return {
        x: () => localResponseNormalizationBackprop(x, y, dy, depthRadius, bias, alpha, beta)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/min_max_grad_util.js
  function gradForMinAndMax(dy, y, xOrig, origAxes) {
    if (y.rank < xOrig.rank) {
      y = reshape(y, expandShapeToKeepDim(y.shape, origAxes));
    }
    if (dy.rank < xOrig.rank) {
      dy = reshape(dy, expandShapeToKeepDim(dy.shape, origAxes));
    }
    return {
      x: () => {
        const dx = mul4(dy, cast(equal(xOrig, y), dy.dtype));
        return dx;
      }
    };
  }

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Max_grad.js
  var maxGradConfig = {
    kernelName: Max,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const maxAttrs = attrs;
      const { reductionIndices } = maxAttrs;
      const x = saved[0];
      const y = saved[1];
      const origAxes = parseAxisParam(reductionIndices, x.shape);
      const maxGrad = gradForMinAndMax(dy, y, x, origAxes);
      return {
        x: () => {
          return maxGrad["x"]();
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Maximum_grad.js
  var maximumGradConfig = {
    kernelName: Maximum,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const derA = () => mul4(dy, cast(greaterEqual(a, b), "float32"));
      const derB = () => mul4(dy, cast(less(a, b), "float32"));
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_3d_grad.js
  function maxPool3dGrad_(dy, input2, output, filterSize, strides, pad3, dimRoundingMode) {
    const $dy = convertToTensor(dy, "dy", "maxPool3dGrad");
    const $input = convertToTensor(input2, "input", "maxPool3dGrad");
    const $output = convertToTensor(output, "output", "maxPool3dGrad");
    let dy5D = $dy;
    let input5D = $input;
    let output5D = $output;
    let reshapedTo5D = false;
    if ($input.rank === 4) {
      reshapedTo5D = true;
      dy5D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
      input5D = reshape($input, [
        1,
        $input.shape[0],
        $input.shape[1],
        $input.shape[2],
        $input.shape[3]
      ]);
      output5D = reshape($output, [
        1,
        $output.shape[0],
        $output.shape[1],
        $output.shape[2],
        $output.shape[3]
      ]);
    }
    assert(dy5D.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ${dy5D.rank}.`);
    assert(input5D.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ${input5D.rank}.`);
    assert(output5D.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ${output5D.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { dy: dy5D, input: input5D, output: output5D };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
    const res = ENGINE.runKernel(MaxPool3DGrad, inputs, attrs);
    if (reshapedTo5D) {
      return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
    }
    return res;
  }
  var maxPool3dGrad = op({ maxPool3dGrad_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/MaxPool3D_grad.js
  var maxPool3DGradConfig = {
    kernelName: MaxPool3D,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const [x, y] = saved;
      const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
      return {
        x: () => maxPool3dGrad(dy, x, y, filterSize, strides, pad3, dimRoundingMode)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_grad.js
  function maxPoolGrad_(dy, input2, output, filterSize, strides, pad3, dimRoundingMode) {
    const $dy = convertToTensor(dy, "dy", "maxPoolGrad");
    const $input = convertToTensor(input2, "input", "maxPoolGrad");
    const $output = convertToTensor(output, "output", "maxPoolGrad");
    assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
    assert($dy.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ${$dy.rank}.`);
    assert($input.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ${$input.rank}.`);
    if (dimRoundingMode != null) {
      assert(isInt(pad3), () => `Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${dimRoundingMode} but got pad ${pad3}.`);
    }
    const inputs = { dy: $dy, input: $input, output: $output };
    const attrs = { filterSize, strides, pad: pad3, dimRoundingMode };
    return ENGINE.runKernel(MaxPoolGrad, inputs, attrs);
  }
  var maxPoolGrad = op({ maxPoolGrad_ });

  // node_modules/@tensorflow/tfjs-core/dist/gradients/MaxPool_grad.js
  var maxPoolGradConfig = {
    kernelName: MaxPool,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const [x, y] = saved;
      const { filterSize, strides, pad: pad3 } = attrs;
      return {
        x: () => maxPoolGrad(dy, x, y, filterSize, strides, pad3)
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Mean_grad.js
  var meanGradConfig = {
    kernelName: Mean,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { axis } = attrs;
      const axes = parseAxisParam(axis, x.shape);
      const shapes = computeOutAndReduceShapes(x.shape, axes);
      const reduceShape = shapes[1];
      const reduceSize = sizeFromShape(reduceShape);
      const derX = () => {
        const expandedDyShape = x.shape.slice();
        axes.forEach((axis2) => {
          expandedDyShape[axis2] = 1;
        });
        const expandedDy = reshape(dy, expandedDyShape);
        const res = div3(mul4(expandedDy, ones2(x.shape, "float32")), reduceSize);
        return res;
      };
      return { x: derX };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Min_grad.js
  var minGradConfig = {
    kernelName: Min,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const minAttrs = attrs;
      const { axis } = minAttrs;
      const [x, y] = saved;
      const origAxes = parseAxisParam(axis, x.shape);
      const minGrad = gradForMinAndMax(dy, y, x, origAxes);
      return {
        x: () => {
          return minGrad["x"]();
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Minimum_grad.js
  var minimumGradConfig = {
    kernelName: Minimum,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const derA = () => mul4(dy, cast(lessEqual(a, b), "float32"));
      const derB = () => mul4(dy, cast(greater(a, b), "float32"));
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/MirrorPad_grad.js
  var mirrorPadGradConfig = {
    kernelName: MirrorPad,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const x = saved[0];
      const { paddings } = attrs;
      const begin = paddings.map((p3) => p3[0]);
      return { x: () => slice(dy, begin, x.shape) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Mod_grad.js
  var modGradConfig = {
    kernelName: Mod,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(dy, reduceAxes), a.shape);
        }
        return dy;
      };
      const derB = () => {
        const res = mul4(dy, neg(floor3(div3(a, b))));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), b.shape);
        }
        return res;
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Multiply_grad.js
  var multiplyGradConfig = {
    kernelName: Multiply,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const res = mul4(dy, cast(b, "float32"));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), a.shape);
        }
        return res;
      };
      const derB = () => {
        const res = mul4(dy, cast(a, "float32"));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), b.shape);
        }
        return res;
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Neg_grad.js
  var negGradConfig = {
    kernelName: Neg,
    gradFunc: (dy) => {
      return { x: () => neg(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/OneHot_grad.js
  var oneHotGradConfig = {
    kernelName: OneHot,
    inputsToSave: ["indices"],
    gradFunc: (dy, saved) => {
      const indices = saved[0];
      return { indices: () => zeros(indices.shape, "float32") };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/OnesLike_grad.js
  var onesLikeGradConfig = {
    kernelName: OnesLike,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Pack_grad.js
  var packGradConfig = {
    kernelName: Pack,
    saveAllInputs: true,
    gradFunc: (dy, saved, attrs) => {
      const { axis } = attrs;
      const derTensors = unstack(dy, axis);
      return derTensors.map((t) => () => t);
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/PadV2_grad.js
  var padV2GradConfig = {
    kernelName: PadV2,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const x = saved[0];
      const { paddings } = attrs;
      const begin = paddings.map((p3) => p3[0]);
      return { x: () => slice(dy, begin, x.shape) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Pow_grad.js
  var powGradConfig = {
    kernelName: Pow2,
    inputsToSave: ["a", "b"],
    outputsToSave: [true],
    gradFunc: (dy, saved) => {
      const [a, b, y] = saved;
      const base2 = a;
      const exp4 = b;
      const outShape = assertAndGetBroadcastShape(base2.shape, exp4.shape);
      const derBase = () => {
        const expFloat = cast(exp4, "float32");
        let res = mul4(dy, mul4(expFloat, pow(base2, sub4(expFloat, scalar(1)))));
        const reduceAxes = getReductionAxes(base2.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, base2.shape);
      };
      const derExp = () => {
        const condition = greater(base2, 0);
        const logBase = where(condition, log6(base2), zerosLike(base2));
        let res = mul4(dy, mul4(y, logBase));
        const reduceAxes = getReductionAxes(exp4.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, exp4.shape);
      };
      return { a: derBase, b: derExp };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Prelu_grad.js
  var preluGradConfig = {
    kernelName: Prelu,
    inputsToSave: ["x", "alpha"],
    gradFunc: (dy, saved) => {
      const [x, alpha] = saved;
      const mask = greater(x, 0);
      return {
        x: () => where(mask, dy, mul4(dy, alpha)),
        alpha: () => {
          let res = where(mask, zerosLike(dy), mul4(dy, x));
          const reduceAxes = getReductionAxes(alpha.shape, dy.shape);
          if (reduceAxes.length > 0) {
            res = sum2(res, reduceAxes);
          }
          return reshape(res, alpha.shape);
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/RealDiv_grad.js
  var divGradConfig = {
    kernelName: RealDiv,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const res = div3(dy, cast(b, "float32"));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), a.shape);
        }
        return res;
      };
      const derB = () => {
        let res = mul4(dy, cast(a, "float32"));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = reshape(sum2(res, reduceAxes), b.shape);
        }
        const tmp = square(b);
        return neg(div3(res, cast(tmp, "float32")));
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Reciprocal_grad.js
  var reciprocalGradConfig = {
    kernelName: Reciprocal,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, neg(square(x))) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Relu6_grad.js
  var relu6GradConfig = {
    kernelName: Relu6,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      const mask = mul4(lessEqual(x, 6), step(x));
      return { x: () => mul4(dy, cast(mask, "float32")) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Relu_grad.js
  var reluGradConfig = {
    kernelName: Relu,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(dy, cast(step(x), "float32")) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Reshape_grad.js
  var reshapeGradConfig = {
    kernelName: Reshape,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => reshape(dy, x.shape) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ResizeBilinear_grad.js
  var resizeBilinearGradConfig = {
    kernelName: ResizeBilinear,
    inputsToSave: ["images"],
    gradFunc: (dy, saved, attrs) => {
      const [images] = saved;
      const inputs = { dy, images };
      const imagesDer = () => ENGINE.runKernel(ResizeBilinearGrad, inputs, attrs);
      return { images: imagesDer };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ResizeNearestNeighbor_grad.js
  var resizeNearestNeighborGradConfig = {
    kernelName: ResizeNearestNeighbor,
    inputsToSave: ["images"],
    gradFunc: (dy, saved, attrs) => {
      const [images] = saved;
      const inputs = { dy, images };
      const imagesDer = () => ENGINE.runKernel(ResizeNearestNeighborGrad, inputs, attrs);
      return { images: imagesDer };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Reverse_grad.js
  var reverseGradConfig = {
    kernelName: Reverse,
    gradFunc: (dy, saved, attrs) => {
      const { dims } = attrs;
      const axes = parseAxisParam(dims, dy.shape);
      return { x: () => reverse(dy, axes) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Round_grad.js
  var roundGradConfig = {
    kernelName: Round,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Rsqrt_grad.js
  var rsqrtGradConfig = {
    kernelName: Rsqrt,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => neg(div3(dy, mul4(pow(x, 1.5), 2))) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Select_grad.js
  var selectGradConfig = {
    kernelName: Select,
    inputsToSave: ["condition"],
    gradFunc: (dy, saved) => {
      const [condition] = saved;
      return {
        condition: () => cast(zerosLike(condition), "float32"),
        t: () => mul4(dy, cast(condition, dy.dtype)),
        e: () => mul4(dy, cast(logicalNot(condition), dy.dtype))
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Selu_grad.js
  var seluGradConfig = {
    kernelName: Selu,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const mask = greater(x, scalar(0));
          const scaleAlpha2 = scalar(SELU_SCALEALPHA);
          const scale5 = scalar(SELU_SCALE);
          const greaterThanZeroDer = mul4(dy, scale5);
          const lessEqualZeroDer = mul4(mul4(dy, scaleAlpha2), exp(cast(x, "float32")));
          return where(mask, greaterThanZeroDer, lessEqualZeroDer);
        }
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sigmoid_grad.js
  var sigmoidGradConfig = {
    kernelName: Sigmoid,
    outputsToSave: [true],
    gradFunc: (dy, saved) => {
      const [y] = saved;
      return { x: () => mul4(dy, mul4(y, sub4(scalar(1), y))) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sign_grad.js
  var signGradConfig = {
    kernelName: Sign,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sin_grad.js
  var sinGradConfig = {
    kernelName: Sin,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(cos2(cast(x, "float32")), dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sinh_grad.js
  var sinhGradConfig = {
    kernelName: Sinh,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(cosh(cast(x, "float32")), dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Slice_grad.js
  var sliceGradConfig = {
    kernelName: Slice,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { begin, size: size3 } = attrs;
      const inputShape = x.shape;
      const [begin_, size_] = parseSliceParams(x, begin, size3);
      const paddings = [];
      for (let i = 0; i < dy.rank; i++) {
        paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);
      }
      return { x: () => pad2(dy, paddings) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Softmax_grad.js
  var softmaxGradConfig = {
    kernelName: Softmax,
    outputsToSave: [true],
    gradFunc: (dy, saved, attrs) => {
      const [y] = saved;
      const { dim } = attrs;
      const keepDims = true;
      const dyTimesY = mul4(dy, y);
      return {
        logits: () => sub4(dyTimesY, mul4(sum2(dyTimesY, [dim], keepDims), y))
      };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Softplus_grad.js
  var softplusGradConfig = {
    kernelName: Softplus,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(dy, sigmoid(x)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/SpaceToBatchND_grad.js
  var spaceToBatchNDGradConfig = {
    kernelName: SpaceToBatchND,
    gradFunc: (dy, saved, attrs) => {
      const { blockShape, paddings } = attrs;
      return { x: () => batchToSpaceND(dy, blockShape, paddings) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/SplitV_grad.js
  var splitVGradConfig = {
    kernelName: SplitV,
    gradFunc: (dy, saved, attrs) => {
      const { axis } = attrs;
      return { x: () => concat(dy, axis) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sqrt_grad.js
  var sqrtGradConfig = {
    kernelName: Sqrt,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, mul4(sqrt(cast(x, "float32")), 2)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Square_grad.js
  var squareGradConfig = {
    kernelName: Square,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => mul4(dy, mul4(cast(x, "float32"), 2)) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/SquaredDifference_grad.js
  var squaredDifferenceGradConfig = {
    kernelName: SquaredDifference,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const two = scalar(2);
      const derA = () => mul4(dy, mul4(two, sub4(a, b)));
      const derB = () => mul4(dy, mul4(two, sub4(b, a)));
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Step_grad.js
  var stepGradConfig = {
    kernelName: Step,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sub_grad.js
  var subGradConfig = {
    kernelName: Sub,
    inputsToSave: ["a", "b"],
    gradFunc: (dy, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        let res = dy;
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, a.shape);
      };
      const derB = () => {
        let res = dy;
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(neg(res), b.shape);
      };
      return { a: derA, b: derB };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Sum_grad.js
  var sumGradConfig = {
    kernelName: Sum,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const expandedDyShape = x.shape.slice();
      const { axis } = attrs;
      const axes = parseAxisParam(axis, x.shape);
      axes.forEach((axis2) => {
        expandedDyShape[axis2] = 1;
      });
      const expandedDy = reshape(dy, expandedDyShape);
      const derX = mul4(expandedDy, ones2(x.shape, "float32"));
      return { x: () => derX };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Tan_grad.js
  var tanGradConfig = {
    kernelName: Tan,
    inputsToSave: ["x"],
    gradFunc: (dy, saved) => {
      const [x] = saved;
      return { x: () => div3(dy, square(cos2(x))) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Tanh_grad.js
  var tanhGradConfig = {
    kernelName: Tanh,
    outputsToSave: [true],
    gradFunc: (dy, saved) => {
      const [y] = saved;
      return { x: () => mul4(sub4(scalar(1), square(y)), dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Tile_grad.js
  var tileGradConfig = {
    kernelName: Tile,
    inputsToSave: ["x"],
    gradFunc: (dy, saved, attrs) => {
      const [x] = saved;
      const { reps } = attrs;
      const derX = () => {
        let xGrad = zerosLike(x);
        if (x.rank === 1) {
          for (let i = 0; i < reps[0]; ++i) {
            xGrad = add6(xGrad, slice(dy, [i * x.shape[0]], [x.shape[0]]));
          }
        } else if (x.rank === 2) {
          for (let i = 0; i < reps[0]; ++i) {
            for (let j = 0; j < reps[1]; ++j) {
              xGrad = add6(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1]], [
                x.shape[0],
                x.shape[1]
              ]));
            }
          }
        } else if (x.rank === 3) {
          for (let i = 0; i < reps[0]; ++i) {
            for (let j = 0; j < reps[1]; ++j) {
              for (let k = 0; k < reps[2]; ++k) {
                xGrad = add6(xGrad, slice(dy, [i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));
              }
            }
          }
        } else if (x.rank === 4) {
          for (let i = 0; i < reps[0]; ++i) {
            for (let j = 0; j < reps[1]; ++j) {
              for (let k = 0; k < reps[2]; ++k) {
                for (let l = 0; l < reps[3]; ++l) {
                  xGrad = add6(xGrad, slice(dy, [
                    i * x.shape[0],
                    j * x.shape[1],
                    k * x.shape[2],
                    l * x.shape[3]
                  ], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));
                }
              }
            }
          }
        } else {
          throw new Error(`Gradient for tile operation is not implemented for rank-${x.rank} tensors yet.`);
        }
        return xGrad;
      };
      return { x: derX };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Transpose_grad.js
  var transposeGradConfig = {
    kernelName: Transpose,
    gradFunc: (dy, saved, attrs) => {
      const transposeAttrs = attrs;
      const { perm } = transposeAttrs;
      const undoPerm = getUndoAxesPermutation(perm);
      return { x: () => transpose2(dy, undoPerm) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/Unpack_grad.js
  var unpackGradConfig = {
    kernelName: Unpack,
    gradFunc: (dy, saved, attrs) => {
      const unpackAttrs = attrs;
      const { axis } = unpackAttrs;
      return { value: () => stack2(dy, axis) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/gradients/UnsortedSegmentSum_grad.js
  var unsortedSegmentSumGradConfig = {
    kernelName: UnsortedSegmentSum,
    inputsToSave: ["segmentIds"],
    gradFunc: (dy, saved) => {
      const [segmentIds] = saved;
      const derX = () => {
        return gatherDropNegatives(dy, segmentIds);
      };
      return { x: derX };
    }
  };
  function gatherDropNegatives(x, indices) {
    const zeroClippedIndices = maximum(indices, zerosLike(indices));
    const gathered = gather(x, zeroClippedIndices);
    let isPositive = greaterEqual(indices, scalar(0, "int32"));
    const numIters = gathered.rank - isPositive.rank;
    for (let i = 0; i < numIters; ++i) {
      isPositive = expandDims(isPositive, i + 1);
    }
    isPositive = logicalAnd(isPositive, ones2(gathered.shape, "bool"));
    const zeroSlice = zerosLike(gathered);
    return where(isPositive, gathered, zeroSlice);
  }

  // node_modules/@tensorflow/tfjs-core/dist/gradients/ZerosLike_grad.js
  var zerosLikeGradConfig = {
    kernelName: ZerosLike,
    gradFunc: (dy) => {
      return { x: () => zerosLike(dy) };
    }
  };

  // node_modules/@tensorflow/tfjs-core/dist/register_all_gradients.js
  var gradConfigs = [
    absGradConfig,
    acosGradConfig,
    acoshGradConfig,
    addGradConfig,
    addNGradConfig,
    argMaxGradConfig,
    argMinGradConfig,
    asinGradConfig,
    asinhGradConfig,
    atan2GradConfig,
    atanGradConfig,
    atanhGradConfig,
    avgPool3DGradConfig,
    avgPoolGradConfig,
    batchMatMulGradConfig,
    batchToSpaceNDGradConfig,
    broadcastToGradConfig,
    castGradConfig,
    ceilGradConfig,
    clipByValueGradConfig,
    complexAbsGradConfig,
    concatGradConfig,
    conv2DBackpropInputGradConfig,
    conv2DGradConfig,
    conv3DGradConfig,
    cosGradConfig,
    coshGradConfig,
    cumsumGradConfig,
    depthwiseConv2dNativeGradConfig,
    dilation2dGradConfig,
    divGradConfig,
    eluGradConfig,
    erfGradConfig,
    expGradConfig,
    expandDimsGradConfig,
    expm1GradConfig,
    floorDivGradConfig,
    floorGradConfig,
    fusedBatchNormGradConfig,
    gatherGradConfig,
    greaterEqualGradConfig,
    identityGradConfig,
    isFiniteGradConfig,
    isInfGradConfig,
    isNanGradConfig,
    leakyReluGradConfig,
    log1pGradConfig,
    logGradConfig,
    logSoftmaxGradConfig,
    lrnGradConfig,
    maxGradConfig,
    maxGradConfig,
    maximumGradConfig,
    maxPool3DGradConfig,
    maxPoolGradConfig,
    meanGradConfig,
    minGradConfig,
    minimumGradConfig,
    mirrorPadGradConfig,
    modGradConfig,
    multiplyGradConfig,
    negGradConfig,
    oneHotGradConfig,
    onesLikeGradConfig,
    packGradConfig,
    padV2GradConfig,
    padV2GradConfig,
    powGradConfig,
    preluGradConfig,
    reciprocalGradConfig,
    relu6GradConfig,
    reluGradConfig,
    reshapeGradConfig,
    resizeBilinearGradConfig,
    resizeNearestNeighborGradConfig,
    reverseGradConfig,
    roundGradConfig,
    rsqrtGradConfig,
    selectGradConfig,
    seluGradConfig,
    sigmoidGradConfig,
    signGradConfig,
    sinGradConfig,
    sinhGradConfig,
    sliceGradConfig,
    softmaxGradConfig,
    softplusGradConfig,
    spaceToBatchNDGradConfig,
    spaceToBatchNDGradConfig,
    splitVGradConfig,
    splitVGradConfig,
    sqrtGradConfig,
    squaredDifferenceGradConfig,
    squareGradConfig,
    stepGradConfig,
    subGradConfig,
    sumGradConfig,
    tanGradConfig,
    tanhGradConfig,
    tileGradConfig,
    transposeGradConfig,
    unpackGradConfig,
    unsortedSegmentSumGradConfig,
    zerosLikeGradConfig
  ];
  for (const gradientConfig of gradConfigs) {
    registerGradient(gradientConfig);
  }

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/abs.js
  getGlobalTensorClass().prototype.abs = function() {
    this.throwIfDisposed();
    return abs(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/acos.js
  getGlobalTensorClass().prototype.acos = function() {
    this.throwIfDisposed();
    return acos(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/acosh.js
  getGlobalTensorClass().prototype.acosh = function() {
    this.throwIfDisposed();
    return acosh(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/add.js
  getGlobalTensorClass().prototype.add = function(b) {
    this.throwIfDisposed();
    return add6(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/all.js
  getGlobalTensorClass().prototype.all = function(axis, keepDims) {
    this.throwIfDisposed();
    return all(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/any.js
  getGlobalTensorClass().prototype.any = function(axis, keepDims) {
    this.throwIfDisposed();
    return any(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/arg_max.js
  getGlobalTensorClass().prototype.argMax = function(axis) {
    this.throwIfDisposed();
    return argMax(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/arg_min.js
  getGlobalTensorClass().prototype.argMin = function(axis) {
    this.throwIfDisposed();
    return argMin(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as_scalar.js
  getGlobalTensorClass().prototype.asScalar = function() {
    this.throwIfDisposed();
    assert(this.size === 1, () => "The array must have only 1 element.");
    return reshape(this, []);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as_type.js
  getGlobalTensorClass().prototype.asType = function(dtype) {
    this.throwIfDisposed();
    return cast(this, dtype);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as1d.js
  getGlobalTensorClass().prototype.as1D = function() {
    this.throwIfDisposed();
    return reshape(this, [this.size]);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as2d.js
  getGlobalTensorClass().prototype.as2D = function(rows, columns) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns]);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as3d.js
  getGlobalTensorClass().prototype.as3D = function(rows, columns, depth) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns, depth]);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as4d.js
  getGlobalTensorClass().prototype.as4D = function(rows, columns, depth, depth2) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns, depth, depth2]);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as5d.js
  getGlobalTensorClass().prototype.as5D = function(rows, columns, depth, depth2, depth3) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns, depth, depth2, depth3]);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/asin.js
  getGlobalTensorClass().prototype.asin = function() {
    this.throwIfDisposed();
    return asin(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/asinh.js
  getGlobalTensorClass().prototype.asinh = function() {
    this.throwIfDisposed();
    return asinh(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/atan.js
  getGlobalTensorClass().prototype.atan = function() {
    this.throwIfDisposed();
    return atan(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/atan2.js
  getGlobalTensorClass().prototype.atan2 = function(b) {
    this.throwIfDisposed();
    return atan22(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/atanh.js
  getGlobalTensorClass().prototype.atanh = function() {
    this.throwIfDisposed();
    return atanh(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/avg_pool.js
  getGlobalTensorClass().prototype.avgPool = function(filterSize, strides, pad3, dimRoundingMode) {
    this.throwIfDisposed();
    return avgPool(this, filterSize, strides, pad3, dimRoundingMode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/batch_to_space_nd.js
  getGlobalTensorClass().prototype.batchToSpaceND = function(blockShape, crops) {
    this.throwIfDisposed();
    return batchToSpaceND(this, blockShape, crops);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/batchnorm.js
  getGlobalTensorClass().prototype.batchNorm = function(mean3, variance, offset, scale5, varianceEpsilon) {
    this.throwIfDisposed();
    return batchNorm(this, mean3, variance, offset, scale5, varianceEpsilon);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/broadcast_to.js
  getGlobalTensorClass().prototype.broadcastTo = function(shape) {
    this.throwIfDisposed();
    return broadcastTo(this, shape);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cast.js
  getGlobalTensorClass().prototype.cast = function(dtype) {
    this.throwIfDisposed();
    return cast(this, dtype);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/ceil.js
  getGlobalTensorClass().prototype.ceil = function() {
    this.throwIfDisposed();
    return ceil3(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/clip_by_value.js
  getGlobalTensorClass().prototype.clipByValue = function(min7, max7) {
    this.throwIfDisposed();
    return clipByValue(this, min7, max7);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/concat.js
  getGlobalTensorClass().prototype.concat = function(x, axis) {
    this.throwIfDisposed();
    if (x instanceof Tensor) {
      x = [x];
    }
    return concat([this, ...x], axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/conv1d.js
  getGlobalTensorClass().prototype.conv1d = function(filter2, stride, pad3, dataFormat, dilation, dimRoundingMode) {
    this.throwIfDisposed();
    return conv1d(this, filter2, stride, pad3, dataFormat, dilation, dimRoundingMode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/conv2d_transpose.js
  getGlobalTensorClass().prototype.conv2dTranspose = function(filter2, outputShape, strides, pad3, dimRoundingMode) {
    this.throwIfDisposed();
    return conv2dTranspose(this, filter2, outputShape, strides, pad3, dimRoundingMode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/conv2d.js
  getGlobalTensorClass().prototype.conv2d = function(filter2, strides, pad3, dataFormat, dilations, dimRoundingMode) {
    this.throwIfDisposed();
    return conv2d(this, filter2, strides, pad3, dataFormat, dilations, dimRoundingMode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cos.js
  getGlobalTensorClass().prototype.cos = function() {
    this.throwIfDisposed();
    return cos2(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cosh.js
  getGlobalTensorClass().prototype.cosh = function() {
    this.throwIfDisposed();
    return cosh(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cumsum.js
  getGlobalTensorClass().prototype.cumsum = function(axis, exclusive, reverse4) {
    this.throwIfDisposed();
    return cumsum(this, axis, exclusive, reverse4);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/depth_to_space.js
  getGlobalTensorClass().prototype.depthToSpace = function(blockSize, dataFormat) {
    this.throwIfDisposed();
    return depthToSpace(this, blockSize, dataFormat);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/depthwise_conv2d.js
  getGlobalTensorClass().prototype.depthwiseConv2d = function(filter2, strides, pad3, dataFormat, dilations, dimRoundingMode) {
    this.throwIfDisposed();
    return depthwiseConv2d(this, filter2, strides, pad3, dataFormat, dilations, dimRoundingMode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/dilation2d.js
  getGlobalTensorClass().prototype.dilation2d = function(filter2, strides, pad3, dilations, dataFormat) {
    this.throwIfDisposed();
    return dilation2d(this, filter2, strides, pad3, dilations, dataFormat);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/div_no_nan.js
  getGlobalTensorClass().prototype.divNoNan = function(b) {
    this.throwIfDisposed();
    return divNoNan(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/div.js
  getGlobalTensorClass().prototype.div = function(b) {
    this.throwIfDisposed();
    return div3(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/dot.js
  getGlobalTensorClass().prototype.dot = function(b) {
    this.throwIfDisposed();
    return dot4(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/elu.js
  getGlobalTensorClass().prototype.elu = function() {
    this.throwIfDisposed();
    return elu(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/equal.js
  getGlobalTensorClass().prototype.equal = function(b) {
    this.throwIfDisposed();
    return equal(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/erf.js
  getGlobalTensorClass().prototype.erf = function() {
    this.throwIfDisposed();
    return erf(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/exp.js
  getGlobalTensorClass().prototype.exp = function() {
    this.throwIfDisposed();
    return exp(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/expand_dims.js
  getGlobalTensorClass().prototype.expandDims = function(axis) {
    this.throwIfDisposed();
    return expandDims(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/expm1.js
  getGlobalTensorClass().prototype.expm1 = function() {
    this.throwIfDisposed();
    return expm1(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/fft.js
  getGlobalTensorClass().prototype.fft = function() {
    this.throwIfDisposed();
    return fft(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/flatten.js
  getGlobalTensorClass().prototype.flatten = function() {
    this.throwIfDisposed();
    return reshape(this, [this.size]);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/floor.js
  getGlobalTensorClass().prototype.floor = function() {
    this.throwIfDisposed();
    return floor3(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/floorDiv.js
  getGlobalTensorClass().prototype.floorDiv = function(b) {
    this.throwIfDisposed();
    return floorDiv(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/gather.js
  getGlobalTensorClass().prototype.gather = function(indices, axis) {
    this.throwIfDisposed();
    return gather(this, indices, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/greater_equal.js
  getGlobalTensorClass().prototype.greaterEqual = function(b) {
    this.throwIfDisposed();
    return greaterEqual(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/greater.js
  getGlobalTensorClass().prototype.greater = function(b) {
    this.throwIfDisposed();
    return greater(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/ifft.js
  getGlobalTensorClass().prototype.ifft = function() {
    this.throwIfDisposed();
    return ifft(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/irfft.js
  getGlobalTensorClass().prototype.irfft = function() {
    this.throwIfDisposed();
    return irfft(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/is_finite.js
  getGlobalTensorClass().prototype.isFinite = function() {
    this.throwIfDisposed();
    return isFinite2(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/is_inf.js
  getGlobalTensorClass().prototype.isInf = function() {
    this.throwIfDisposed();
    return isInf(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/is_nan.js
  getGlobalTensorClass().prototype.isNaN = function() {
    this.throwIfDisposed();
    return isNaN2(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/leaky_relu.js
  getGlobalTensorClass().prototype.leakyRelu = function(alpha) {
    this.throwIfDisposed();
    return leakyRelu(this, alpha);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/less_equal.js
  getGlobalTensorClass().prototype.lessEqual = function(b) {
    this.throwIfDisposed();
    return lessEqual(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/less.js
  getGlobalTensorClass().prototype.less = function(b) {
    this.throwIfDisposed();
    return less(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/local_response_normalization.js
  getGlobalTensorClass().prototype.localResponseNormalization = function(depthRadius, bias, alpha, beta) {
    this.throwIfDisposed();
    return localResponseNormalization(this, depthRadius, bias, alpha, beta);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log_sigmoid.js
  getGlobalTensorClass().prototype.logSigmoid = function() {
    this.throwIfDisposed();
    return logSigmoid(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log_softmax.js
  getGlobalTensorClass().prototype.logSoftmax = function(axis) {
    this.throwIfDisposed();
    return logSoftmax(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log_sum_exp.js
  getGlobalTensorClass().prototype.logSumExp = function(axis, keepDims) {
    this.throwIfDisposed();
    return logSumExp(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log.js
  getGlobalTensorClass().prototype.log = function() {
    this.throwIfDisposed();
    return log6(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log1p.js
  getGlobalTensorClass().prototype.log1p = function() {
    this.throwIfDisposed();
    return log1p(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_and.js
  getGlobalTensorClass().prototype.logicalAnd = function(b) {
    this.throwIfDisposed();
    return logicalAnd(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_not.js
  getGlobalTensorClass().prototype.logicalNot = function() {
    this.throwIfDisposed();
    return logicalNot(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_or.js
  getGlobalTensorClass().prototype.logicalOr = function(b) {
    this.throwIfDisposed();
    return logicalOr(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_xor.js
  getGlobalTensorClass().prototype.logicalXor = function(b) {
    this.throwIfDisposed();
    return logicalXor(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mat_mul.js
  getGlobalTensorClass().prototype.matMul = function(b, transposeA, transposeB) {
    this.throwIfDisposed();
    return matMul(this, b, transposeA, transposeB);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/max_pool.js
  getGlobalTensorClass().prototype.maxPool = function(filterSize, strides, pad3, dimRoundingMode) {
    this.throwIfDisposed();
    return maxPool(this, filterSize, strides, pad3, dimRoundingMode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/max.js
  getGlobalTensorClass().prototype.max = function(axis, keepDims) {
    this.throwIfDisposed();
    return max3(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/maximum.js
  getGlobalTensorClass().prototype.maximum = function(b) {
    this.throwIfDisposed();
    return maximum(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mean.js
  getGlobalTensorClass().prototype.mean = function(axis, keepDims) {
    this.throwIfDisposed();
    return mean(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/min.js
  getGlobalTensorClass().prototype.min = function(axis, keepDims) {
    this.throwIfDisposed();
    return min3(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/minimum.js
  getGlobalTensorClass().prototype.minimum = function(b) {
    this.throwIfDisposed();
    return minimum(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mirror_pad.js
  getGlobalTensorClass().prototype.mirrorPad = function(paddings, mode) {
    this.throwIfDisposed();
    return mirrorPad(this, paddings, mode);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mod.js
  getGlobalTensorClass().prototype.mod = function(b) {
    this.throwIfDisposed();
    return mod3(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mul.js
  getGlobalTensorClass().prototype.mul = function(b) {
    this.throwIfDisposed();
    return mul4(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/neg.js
  getGlobalTensorClass().prototype.neg = function() {
    this.throwIfDisposed();
    return neg(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/norm.js
  getGlobalTensorClass().prototype.norm = function(ord, axis, keepDims) {
    this.throwIfDisposed();
    return norm(this, ord, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/not_equal.js
  getGlobalTensorClass().prototype.notEqual = function(b) {
    this.throwIfDisposed();
    return notEqual(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/one_hot.js
  getGlobalTensorClass().prototype.oneHot = function(depth, onValue = 1, offValue = 0) {
    this.throwIfDisposed();
    return oneHot(this, depth, onValue, offValue);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/ones_like.js
  getGlobalTensorClass().prototype.onesLike = function() {
    this.throwIfDisposed();
    return onesLike(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/pad.js
  getGlobalTensorClass().prototype.pad = function(paddings, constantValue) {
    this.throwIfDisposed();
    return pad2(this, paddings, constantValue);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/pool.js
  getGlobalTensorClass().prototype.pool = function(windowShape, poolingType, padding, dilationRate, strides) {
    this.throwIfDisposed();
    return pool(this, windowShape, poolingType, padding, dilationRate, strides);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/pow.js
  getGlobalTensorClass().prototype.pow = function(exp4) {
    this.throwIfDisposed();
    return pow(this, exp4);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/prelu.js
  getGlobalTensorClass().prototype.prelu = function(alpha) {
    this.throwIfDisposed();
    return prelu(this, alpha);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/prod.js
  getGlobalTensorClass().prototype.prod = function(axis, keepDims) {
    this.throwIfDisposed();
    return prod(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reciprocal.js
  getGlobalTensorClass().prototype.reciprocal = function() {
    this.throwIfDisposed();
    return reciprocal(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/relu.js
  getGlobalTensorClass().prototype.relu = function() {
    this.throwIfDisposed();
    return relu(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/relu6.js
  getGlobalTensorClass().prototype.relu6 = function() {
    this.throwIfDisposed();
    return relu6(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reshape_as.js
  getGlobalTensorClass().prototype.reshapeAs = function(x) {
    this.throwIfDisposed();
    return reshape(this, x.shape);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reshape.js
  getGlobalTensorClass().prototype.reshape = function(shape) {
    this.throwIfDisposed();
    return reshape(this, shape);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/resize_bilinear.js
  getGlobalTensorClass().prototype.resizeBilinear = function(newShape2D, alignCorners, halfPixelCenters) {
    this.throwIfDisposed();
    return resizeBilinear(this, newShape2D, alignCorners, halfPixelCenters);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/resize_nearest_neighbor.js
  getGlobalTensorClass().prototype.resizeNearestNeighbor = function(newShape2D, alignCorners, halfFloatCenters) {
    this.throwIfDisposed();
    return resizeNearestNeighbor(this, newShape2D, alignCorners, halfFloatCenters);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reverse.js
  getGlobalTensorClass().prototype.reverse = function(axis) {
    this.throwIfDisposed();
    return reverse(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/rfft.js
  getGlobalTensorClass().prototype.rfft = function() {
    this.throwIfDisposed();
    return rfft(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/round.js
  getGlobalTensorClass().prototype.round = function() {
    this.throwIfDisposed();
    return round5(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/rsqrt.js
  getGlobalTensorClass().prototype.rsqrt = function() {
    this.throwIfDisposed();
    return rsqrt(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/selu.js
  getGlobalTensorClass().prototype.selu = function() {
    this.throwIfDisposed();
    return selu(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/separable_conv2d.js
  getGlobalTensorClass().prototype.separableConv2d = function(depthwiseFilter, pointwiseFilter, strides, pad3, dilation, dataFormat) {
    this.throwIfDisposed();
    return separableConv2d(this, depthwiseFilter, pointwiseFilter, strides, pad3, dilation, dataFormat);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sigmoid.js
  getGlobalTensorClass().prototype.sigmoid = function() {
    this.throwIfDisposed();
    return sigmoid(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sign.js
  getGlobalTensorClass().prototype.sign = function() {
    this.throwIfDisposed();
    return sign(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sin.js
  getGlobalTensorClass().prototype.sin = function() {
    this.throwIfDisposed();
    return sin2(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sinh.js
  getGlobalTensorClass().prototype.sinh = function() {
    this.throwIfDisposed();
    return sinh(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/slice.js
  getGlobalTensorClass().prototype.slice = function(begin, size3) {
    this.throwIfDisposed();
    return slice(this, begin, size3);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/softmax.js
  getGlobalTensorClass().prototype.softmax = function(dim) {
    this.throwIfDisposed();
    return softmax(this, dim);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/softplus.js
  getGlobalTensorClass().prototype.softplus = function() {
    this.throwIfDisposed();
    return softplus(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/space_to_batch_nd.js
  getGlobalTensorClass().prototype.spaceToBatchND = function(blockShape, paddings) {
    this.throwIfDisposed();
    return spaceToBatchND(this, blockShape, paddings);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/split.js
  getGlobalTensorClass().prototype.split = function(numOrSizeSplits, axis) {
    this.throwIfDisposed();
    return split(this, numOrSizeSplits, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sqrt.js
  getGlobalTensorClass().prototype.sqrt = function() {
    this.throwIfDisposed();
    return sqrt(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/square.js
  getGlobalTensorClass().prototype.square = function() {
    this.throwIfDisposed();
    return square(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/squared_difference.js
  getGlobalTensorClass().prototype.squaredDifference = function(b) {
    this.throwIfDisposed();
    return squaredDifference(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/squeeze.js
  getGlobalTensorClass().prototype.squeeze = function(axis) {
    this.throwIfDisposed();
    return squeeze(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/stack.js
  getGlobalTensorClass().prototype.stack = function(x, axis) {
    this.throwIfDisposed();
    const tensorsToBeStacked = x instanceof Tensor ? [this, x] : [this, ...x];
    return stack2(tensorsToBeStacked, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/step.js
  getGlobalTensorClass().prototype.step = function(alpha) {
    this.throwIfDisposed();
    return step(this, alpha);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/strided_slice.js
  getGlobalTensorClass().prototype.stridedSlice = function(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    this.throwIfDisposed();
    return stridedSlice(this, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sub.js
  getGlobalTensorClass().prototype.sub = function(b) {
    this.throwIfDisposed();
    return sub4(this, b);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sum.js
  getGlobalTensorClass().prototype.sum = function(axis, keepDims) {
    this.throwIfDisposed();
    return sum2(this, axis, keepDims);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/tan.js
  getGlobalTensorClass().prototype.tan = function() {
    this.throwIfDisposed();
    return tan(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/tanh.js
  getGlobalTensorClass().prototype.tanh = function() {
    this.throwIfDisposed();
    return tanh2(this);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/tile.js
  getGlobalTensorClass().prototype.tile = function(reps) {
    this.throwIfDisposed();
    return tile(this, reps);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/to_bool.js
  getGlobalTensorClass().prototype.toBool = function() {
    this.throwIfDisposed();
    return cast(this, "bool");
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/to_float.js
  getGlobalTensorClass().prototype.toFloat = function() {
    this.throwIfDisposed();
    return cast(this, "float32");
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/to_int.js
  getGlobalTensorClass().prototype.toInt = function() {
    this.throwIfDisposed();
    return cast(this, "int32");
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/topk.js
  getGlobalTensorClass().prototype.topk = function(k, sorted) {
    this.throwIfDisposed();
    return topk(this, k, sorted);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/transpose.js
  getGlobalTensorClass().prototype.transpose = function(perm) {
    this.throwIfDisposed();
    return transpose2(this, perm);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/unique.js
  getGlobalTensorClass().prototype.unique = function(axis) {
    this.throwIfDisposed();
    return unique(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/unsorted_segment_sum.js
  getGlobalTensorClass().prototype.unsortedSegmentSum = function(segmentIds, numSegments) {
    this.throwIfDisposed();
    return unsortedSegmentSum(this, segmentIds, numSegments);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/unstack.js
  getGlobalTensorClass().prototype.unstack = function(axis) {
    this.throwIfDisposed();
    return unstack(this, axis);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/where.js
  getGlobalTensorClass().prototype.where = function(condition, x) {
    this.throwIfDisposed();
    return where(condition, this, x);
  };

  // node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/zeros_like.js
  getGlobalTensorClass().prototype.zerosLike = function() {
    this.throwIfDisposed();
    return zerosLike(this);
  };

  // node_modules/@tensorflow/tfjs-layers/dist/backend/common.js
  var _epsilon;
  function epsilon() {
    if (_epsilon == null) {
      _epsilon = backend().epsilon();
    }
    return _epsilon;
  }
  function imageDataFormat() {
    return "channelsLast";
  }

  // node_modules/@tensorflow/tfjs-layers/dist/errors.js
  var AttributeError = class extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, AttributeError.prototype);
    }
  };
  var RuntimeError = class extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, RuntimeError.prototype);
    }
  };
  var ValueError = class extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, ValueError.prototype);
    }
  };
  var NotImplementedError = class extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, NotImplementedError.prototype);
    }
  };
  var AssertionError = class extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, AssertionError.prototype);
    }
  };

  // node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js
  function pyListRepeat(value, numValues) {
    if (Array.isArray(value)) {
      let newArray = [];
      for (let i = 0; i < numValues; i++) {
        newArray = newArray.concat(value);
      }
      return newArray;
    } else {
      const newArray = new Array(numValues);
      newArray.fill(value);
      return newArray;
    }
  }
  function assert2(val, message) {
    if (!val) {
      throw new AssertionError(message);
    }
  }
  function count(array2, refernce) {
    let counter = 0;
    for (const item of array2) {
      if (item === refernce) {
        counter++;
      }
    }
    return counter;
  }
  function singletonOrArray(xs) {
    if (xs.length === 1) {
      return xs[0];
    }
    return xs;
  }
  function toList(x) {
    if (Array.isArray(x)) {
      return x;
    }
    return [x];
  }
  function toSnakeCase(name) {
    const intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2");
    const insecure = intermediate.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
    if (insecure[0] !== "_") {
      return insecure;
    }
    return "private" + insecure;
  }
  function toCamelCase(identifier) {
    if (identifier.length <= 1) {
      return identifier;
    }
    if (identifier.indexOf("_") === -1) {
      return identifier;
    }
    return identifier.replace(/[_]+(\w|$)/g, (m, p1) => p1.toUpperCase());
  }
  var _GLOBAL_CUSTOM_OBJECTS = {};
  function serializeKerasObject(instance) {
    if (instance === null || instance === void 0) {
      return null;
    }
    const dict = {};
    dict["className"] = instance.getClassName();
    dict["config"] = instance.getConfig();
    return dict;
  }
  function convertNDArrayScalarsInConfig(config) {
    if (config == null || typeof config !== "object") {
      return;
    } else if (Array.isArray(config)) {
      config.forEach((configItem) => convertNDArrayScalarsInConfig(configItem));
    } else {
      const fields = Object.keys(config);
      for (const field of fields) {
        const value = config[field];
        if (value != null && typeof value === "object") {
          if (!Array.isArray(value) && value["type"] === "ndarray" && typeof value["value"] === "number") {
            config[field] = value["value"];
          } else {
            convertNDArrayScalarsInConfig(value);
          }
        }
      }
    }
  }
  function deserializeKerasObject(identifier, moduleObjects = {}, customObjects = {}, printableModuleName = "object", fastWeightInit = false) {
    if (typeof identifier === "string") {
      const functionName = identifier;
      let fn;
      if (functionName in customObjects) {
        fn = customObjects[functionName];
      } else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
        fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
      } else {
        fn = moduleObjects[functionName];
        if (fn == null) {
          throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
        }
      }
      return fn;
    } else {
      const config = identifier;
      if (config["className"] == null || config["config"] == null) {
        throw new ValueError(`${printableModuleName}: Improper config format: ${JSON.stringify(config)}.
'className' and 'config' must set.`);
      }
      const className = config["className"];
      let cls, fromConfig;
      if (className in customObjects) {
        [cls, fromConfig] = customObjects[className];
      } else if (className in _GLOBAL_CUSTOM_OBJECTS) {
        [cls, fromConfig] = _GLOBAL_CUSTOM_OBJECTS["className"];
      } else if (className in moduleObjects) {
        [cls, fromConfig] = moduleObjects[className];
      }
      if (cls == null) {
        throw new ValueError(`Unknown ${printableModuleName}: ${className}. This may be due to one of the following reasons:
1. The ${printableModuleName} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${printableModuleName} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);
      }
      if (fromConfig != null) {
        const customObjectsCombined = {};
        for (const key of Object.keys(_GLOBAL_CUSTOM_OBJECTS)) {
          customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
        }
        for (const key of Object.keys(customObjects)) {
          customObjectsCombined[key] = customObjects[key];
        }
        const nestedConfig = config["config"];
        nestedConfig["customObjects"] = customObjectsCombined;
        const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
        for (const key of Object.keys(customObjects)) {
          _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
        }
        convertNDArrayScalarsInConfig(config["config"]);
        const returnObj = fromConfig(cls, config["config"], customObjects, fastWeightInit);
        _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
        return returnObj;
      } else {
        const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
        for (const key of Object.keys(customObjects)) {
          _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
        }
        const returnObj = new cls(config["config"]);
        _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
        return returnObj;
      }
    }
  }
  function numberCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function reverseNumberCompare(a, b) {
    return -1 * numberCompare(a, b);
  }
  function unique2(xs) {
    if (xs == null) {
      return xs;
    }
    const out = [];
    for (const x of xs) {
      if (out.indexOf(x) === -1) {
        out.push(x);
      }
    }
    return out;
  }
  function isObjectEmpty(obj) {
    if (obj == null) {
      throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }
  function checkStringTypeUnionValue(values2, label, value) {
    if (value == null) {
      return;
    }
    if (values2.indexOf(value) < 0) {
      throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values2} or null/undefined.`);
    }
  }
  function checkArrayTypeAndLength(x, expectedType, minLength = 0, maxLength = Infinity) {
    assert2(minLength >= 0);
    assert2(maxLength >= minLength);
    return Array.isArray(x) && x.length >= minLength && x.length <= maxLength && x.every((e) => typeof e === expectedType);
  }
  function assertPositiveInteger(value, name) {
    if (Array.isArray(value)) {
      util_exports2.assert(value.length > 0, () => `${name} is unexpectedly an empty array.`);
      value.forEach((v, i) => assertPositiveInteger(v, `element ${i + 1} of ${name}`));
    } else {
      util_exports2.assert(Number.isInteger(value) && value > 0, () => `Expected ${name} to be a positive integer, but got ${formatAsFriendlyString(value)}.`);
    }
  }
  function formatAsFriendlyString(value) {
    if (value === null) {
      return "null";
    } else if (Array.isArray(value)) {
      return "[" + value.map((v) => formatAsFriendlyString(v)).join(",") + "]";
    } else if (typeof value === "string") {
      return `"${value}"`;
    } else {
      return `${value}`;
    }
  }
  function debounce2(f, waitMs, nowFunc) {
    let lastTime = nowFunc != null ? nowFunc() : util_exports2.now();
    let lastResult;
    const f2 = (...args) => {
      const now3 = nowFunc != null ? nowFunc() : util_exports2.now();
      if (now3 - lastTime < waitMs) {
        return lastResult;
      }
      lastTime = now3;
      lastResult = f(...args);
      return lastResult;
    };
    return f2;
  }
  function mapActivationToFusedKernel(activationName) {
    if (activationName === "relu") {
      return "relu";
    }
    if (activationName === "linear") {
      return "linear";
    }
    if (activationName === "elu") {
      return "elu";
    }
    return null;
  }

  // node_modules/@tensorflow/tfjs-layers/dist/constraints.js
  function calcL2Norms(w, axis) {
    return tidy(() => sqrt(sum2(mul4(w, w), axis, true)));
  }
  var Constraint = class extends serialization_exports.Serializable {
    getConfig() {
      return {};
    }
  };
  var MaxNorm = class extends Constraint {
    constructor(args) {
      super();
      this.defaultMaxValue = 2;
      this.defaultAxis = 0;
      this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
      this.axis = args.axis != null ? args.axis : this.defaultAxis;
    }
    apply(w) {
      return tidy(() => {
        const norms = calcL2Norms(w, this.axis);
        const desired = clipByValue(norms, 0, this.maxValue);
        return mul4(w, div3(desired, add6(epsilon(), norms)));
      });
    }
    getConfig() {
      return { maxValue: this.maxValue, axis: this.axis };
    }
  };
  MaxNorm.className = "MaxNorm";
  serialization_exports.registerClass(MaxNorm);
  var UnitNorm = class extends Constraint {
    constructor(args) {
      super();
      this.defaultAxis = 0;
      this.axis = args.axis != null ? args.axis : this.defaultAxis;
    }
    apply(w) {
      return tidy(() => div3(w, add6(epsilon(), calcL2Norms(w, this.axis))));
    }
    getConfig() {
      return { axis: this.axis };
    }
  };
  UnitNorm.className = "UnitNorm";
  serialization_exports.registerClass(UnitNorm);
  var NonNeg = class extends Constraint {
    apply(w) {
      return relu(w);
    }
  };
  NonNeg.className = "NonNeg";
  serialization_exports.registerClass(NonNeg);
  var MinMaxNorm = class extends Constraint {
    constructor(args) {
      super();
      this.defaultMinValue = 0;
      this.defaultMaxValue = 1;
      this.defaultRate = 1;
      this.defaultAxis = 0;
      this.minValue = args.minValue != null ? args.minValue : this.defaultMinValue;
      this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
      this.rate = args.rate != null ? args.rate : this.defaultRate;
      this.axis = args.axis != null ? args.axis : this.defaultAxis;
    }
    apply(w) {
      return tidy(() => {
        const norms = calcL2Norms(w, this.axis);
        const desired = add6(mul4(this.rate, clipByValue(norms, this.minValue, this.maxValue)), mul4(1 - this.rate, norms));
        return mul4(w, div3(desired, add6(epsilon(), norms)));
      });
    }
    getConfig() {
      return {
        minValue: this.minValue,
        maxValue: this.maxValue,
        rate: this.rate,
        axis: this.axis
      };
    }
  };
  MinMaxNorm.className = "MinMaxNorm";
  serialization_exports.registerClass(MinMaxNorm);
  var CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    "maxNorm": "MaxNorm",
    "minMaxNorm": "MinMaxNorm",
    "nonNeg": "NonNeg",
    "unitNorm": "UnitNorm"
  };
  function serializeConstraint(constraint) {
    return serializeKerasObject(constraint);
  }
  function deserializeConstraint(config, customObjects = {}) {
    return deserializeKerasObject(config, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "constraint");
  }
  function getConstraint2(identifier) {
    if (identifier == null) {
      return null;
    }
    if (typeof identifier === "string") {
      const className = identifier in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
      const config = { className, config: {} };
      return deserializeConstraint(config);
    } else if (identifier instanceof Constraint) {
      return identifier;
    } else {
      return deserializeConstraint(identifier);
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/keras_format/common.js
  var VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"];
  var VALID_INTERPOLATION_FORMAT_VALUES = ["nearest", "bilinear"];
  var VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"];
  var VALID_POOL_MODE_VALUES = ["max", "avg"];
  var VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"];

  // node_modules/@tensorflow/tfjs-layers/dist/common.js
  var nameMap = new Map();
  function checkDataFormat(value) {
    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", value);
  }
  function checkInterpolationFormat(value) {
    checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, "InterpolationFormat", value);
  }
  function checkPaddingMode(value) {
    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", value);
  }
  function checkPoolMode(value) {
    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", value);
  }
  var _nameScopeStack = [];
  var _nameScopeDivider = "/";
  function nameScope(name, fn) {
    _nameScopeStack.push(name);
    try {
      const val = fn();
      _nameScopeStack.pop();
      return val;
    } catch (e) {
      _nameScopeStack.pop();
      throw e;
    }
  }
  function currentNameScopePrefix() {
    if (_nameScopeStack.length === 0) {
      return "";
    } else {
      return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
    }
  }
  function getScopedTensorName(tensorName) {
    if (!isValidTensorName(tensorName)) {
      throw new Error("Not a valid tensor name: '" + tensorName + "'");
    }
    return currentNameScopePrefix() + tensorName;
  }
  function getUniqueTensorName(scopedName) {
    if (!isValidTensorName(scopedName)) {
      throw new Error("Not a valid tensor name: '" + scopedName + "'");
    }
    if (!nameMap.has(scopedName)) {
      nameMap.set(scopedName, 0);
    }
    const index = nameMap.get(scopedName);
    nameMap.set(scopedName, nameMap.get(scopedName) + 1);
    if (index > 0) {
      const result = `${scopedName}_${index}`;
      nameMap.set(result, 1);
      return result;
    } else {
      return scopedName;
    }
  }
  var tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
  function isValidTensorName(name) {
    return !!name.match(tensorNameRegex);
  }

  // node_modules/@tensorflow/tfjs-layers/dist/utils/math_utils.js
  function isInteger2(x) {
    return x === parseInt(x.toString(), 10);
  }
  function arrayProd(array2, begin, end) {
    if (begin == null) {
      begin = 0;
    }
    if (end == null) {
      end = array2.length;
    }
    let prod4 = 1;
    for (let i = begin; i < end; ++i) {
      prod4 *= array2[i];
    }
    return prod4;
  }
  function min4(array2) {
    if (array2.length === 0) {
      return Number.NaN;
    }
    let min7 = Number.POSITIVE_INFINITY;
    for (let i = 0; i < array2.length; i++) {
      const value = array2[i];
      if (value < min7) {
        min7 = value;
      }
    }
    return min7;
  }
  function max4(array2) {
    if (array2.length === 0) {
      return Number.NaN;
    }
    let max7 = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < array2.length; i++) {
      const value = array2[i];
      if (value > max7) {
        max7 = value;
      }
    }
    return max7;
  }
  function range2(begin, end) {
    if (end < begin) {
      throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);
    }
    const out = [];
    for (let i = begin; i < end; ++i) {
      out.push(i);
    }
    return out;
  }

  // node_modules/@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js
  function cast2(x, dtype) {
    return cast(x, dtype);
  }
  function expandDims2(x, axis = -1) {
    const outShape = x.shape.slice();
    if (axis < 0) {
      axis = outShape.length + axis + 1;
    }
    outShape.splice(axis, 0, 1);
    return reshape(x, outShape);
  }
  function repeat(x, n) {
    return tidy(() => {
      if (x.shape.length !== 2) {
        throw new ValueError(`repeat() expects a rank-2 tensor, but received a rank-${x.shape.length} tensor.`);
      }
      const y = expandDims2(x, 1);
      return tile2(y, [1, n, 1]);
    });
  }
  function flatten3(x) {
    const newShape = [arrayProd(x.shape)];
    return reshape(x, newShape);
  }
  function batchFlatten(x) {
    if (x.rank <= 1) {
      throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${x.rank}.`);
    }
    const newShape = [x.shape[0], arrayProd(x.shape, 1)];
    return reshape(x, newShape);
  }
  function sliceAlongFirstAxis(array2, start, size3) {
    return tidy(() => {
      switch (array2.rank) {
        case 1:
          return slice1d(array2, start, size3);
        case 2:
          return slice2d(array2, [start, 0], [size3, array2.shape[1]]);
        case 3:
          return slice3d(array2, [start, 0, 0], [size3, array2.shape[1], array2.shape[2]]);
        case 4:
          return slice4d(array2, [start, 0, 0, 0], [size3, array2.shape[1], array2.shape[2], array2.shape[3]]);
        case 5:
          return slice(array2, [start, 0, 0, 0, 0], [
            size3,
            array2.shape[1],
            array2.shape[2],
            array2.shape[3],
            array2.shape[4]
          ]);
        case 6:
          return slice(array2, [start, 0, 0, 0, 0, 0], [
            size3,
            array2.shape[1],
            array2.shape[2],
            array2.shape[3],
            array2.shape[4],
            array2.shape[5]
          ]);
        default:
          throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ${array2.rank}`);
      }
    });
  }
  function sliceAlongLastAxis(array2, start, size3) {
    return tidy(() => {
      switch (array2.rank) {
        case 1:
          return slice1d(array2, start, size3);
        case 2:
          return slice2d(array2, [0, start], [array2.shape[0], size3]);
        case 3:
          return slice3d(array2, [0, 0, start], [array2.shape[0], array2.shape[1], size3]);
        case 4:
          return slice4d(array2, [0, 0, 0, start], [array2.shape[0], array2.shape[1], array2.shape[2], size3]);
        default:
          throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`);
      }
    });
  }
  function sliceAlongAxis(array2, start, size3, axis) {
    return tidy(() => {
      switch (array2.rank) {
        case 1:
          return slice1d(array2, start, size3);
        case 2:
          switch (axis) {
            case 1:
              return sliceAlongFirstAxis(array2, start, size3);
            case 2:
              return sliceAlongLastAxis(array2, start, size3);
            default:
              throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
          }
        case 3:
          switch (axis) {
            case 1:
              return sliceAlongFirstAxis(array2, start, size3);
            case 2:
              return slice3d(array2, [0, start, 0], [array2.shape[0], size3, array2.shape[2]]);
            case 3:
              return sliceAlongLastAxis(array2, start, size3);
            default:
              throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
          }
        case 4:
          switch (axis) {
            case 1:
              return sliceAlongFirstAxis(array2, start, size3);
            case 2:
              return slice4d(array2, [0, start, 0, 0], [array2.shape[0], size3, array2.shape[2], array2.shape[3]]);
            case 3:
              return slice4d(array2, [0, 0, start, 0], [array2.shape[0], array2.shape[1], size3, array2.shape[3]]);
            case 4:
              return sliceAlongLastAxis(array2, start, size3);
            default:
              throw new ValueError(`The axis is not within the rank of the tensor ${axis}`);
          }
        default:
          throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${array2.rank}`);
      }
    });
  }
  function concatenate(tensors, axis = -1) {
    let rank;
    if (axis < 0) {
      rank = tensors[0].rank;
      if (rank !== 0) {
        axis = rank;
      } else {
        axis = 0;
      }
    }
    if (axis === tensors[0].rank) {
      axis = -1;
    }
    return concat(tensors, axis);
  }
  function concatAlongFirstAxis(a, b) {
    switch (a.rank) {
      case 1:
        return concat1d([a, b]);
      case 2:
        return concat2d([a, b], 0);
      case 3:
        return concat3d([a, b], 0);
      case 4:
        return concat4d([a, b], 0);
      default:
        throw new ValueError(`concatAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`);
    }
  }
  function tile2(x, n) {
    if (!Array.isArray(n)) {
      n = [n];
    }
    if (x.rank !== n.length) {
      throw new ValueError(`The length of input n (${n.length}) does not match the number of dimensions in input x (${x.rank})`);
    }
    return tile(x, n);
  }
  function randomNormal2(shape, mean3 = 0, stddev = 1, dtype, seed) {
    return randomNormal(shape, mean3, stddev, dtype, seed);
  }
  function dot5(a, b, activation, bias) {
    if (a.rank < 2 || b.rank < 2) {
      throw new NotImplementedError(`dot requires both inputs to be rank >= 2 but got x shape = ${a.shape} and y shape = ${b.shape}`);
    }
    if (b.rank >= 3) {
      const xLastDim = a.shape.slice(-1)[0];
      const ySecondLastDim = b.shape.slice(-2)[0];
      if (xLastDim !== ySecondLastDim) {
        throw new NotImplementedError(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${a.shape} and  y shape = ${b.shape}`);
      }
    }
    if (a.rank === 2 && b.rank === 2) {
      const transposeA = false;
      const transposeB = false;
      return fused_ops_exports.matMul({
        a,
        b,
        transposeA,
        transposeB,
        bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,
        activation
      });
    } else {
      const aFirstDims = a.shape.slice();
      const aLastDim = aFirstDims.pop();
      a = reshape(a, [-1, aLastDim]);
      const bShape = b.shape.slice();
      const bLastDim = bShape.pop();
      const ySecondLastDim = bShape.pop();
      const yOtherDims = [...bShape, bLastDim];
      const perm = Array.from({ length: b.rank }, (_6, i) => {
        if (i === 0) {
          return b.rank - 2;
        } else if (i <= b.rank - 2) {
          return i - 1;
        }
        return i;
      });
      b = reshape(transpose2(b, perm), [ySecondLastDim, -1]);
      const outputShape = [...aFirstDims, ...yOtherDims];
      const transposeA = false;
      const transposeB = false;
      return reshape(fused_ops_exports.matMul({
        a,
        b,
        transposeA,
        transposeB,
        bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,
        activation
      }), outputShape);
    }
  }
  function gather2(reference, indices, axis) {
    return tidy(() => {
      if (Array.isArray(indices)) {
        indices = tensor1d(indices, "int32");
      } else {
        indices = cast(indices, "int32");
      }
      return gather(reference, indices, axis);
    });
  }
  function square2(x) {
    return mul4(x, x);
  }
  function reshapeBias(xRank, bias, dataFormat) {
    const biasShape = bias.shape;
    if (bias.rank !== 1 && bias.rank !== xRank) {
      throw new ValueError(`Unexpected bias dimensions: ${bias.rank}; expected it to be 1 or ${xRank}`);
    }
    if (xRank === 5) {
      if (dataFormat === "channelsFirst") {
        if (biasShape.length === 1) {
          return reshape(bias, [1, biasShape[0], 1, 1, 1]);
        } else {
          return reshape(bias, [1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);
        }
      } else if (dataFormat === "channelsLast") {
        if (biasShape.length === 1) {
          return reshape(bias, [1, 1, 1, 1, biasShape[0]]);
        } else {
          return reshape(bias, [1].concat(biasShape));
        }
      }
    } else if (xRank === 4) {
      if (dataFormat === "channelsFirst") {
        if (biasShape.length === 1) {
          return reshape(bias, [1, biasShape[0], 1, 1]);
        } else {
          return reshape(bias, [1, biasShape[2], biasShape[0], biasShape[1]]);
        }
      } else if (dataFormat === "channelsLast") {
        if (biasShape.length === 1) {
          return reshape(bias, [1, 1, 1, biasShape[0]]);
        } else {
          return reshape(bias, [1].concat(biasShape));
        }
      }
    } else if (xRank === 3) {
      if (dataFormat === "channelsFirst") {
        if (biasShape.length === 1) {
          return reshape(bias, [1, biasShape[0], 1]);
        } else {
          return reshape(bias, [1, biasShape[1], biasShape[0]]);
        }
      } else if (dataFormat === "channelsLast") {
        if (biasShape.length === 1) {
          return reshape(bias, [1, 1, biasShape[0]]);
        } else {
          return reshape(bias, [1].concat(biasShape));
        }
      }
    } else if (xRank < 3) {
      return bias;
    }
    throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`);
  }
  function biasAdd(x, bias, dataFormat) {
    return tidy(() => {
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      checkDataFormat(dataFormat);
      return add6(x, reshapeBias(x.rank, bias, dataFormat));
    });
  }
  function elu2(x, alpha = 1) {
    if (alpha !== 1) {
      throw new NotImplementedError(`Support for alpha values other than 1 (${alpha}) is not implemented yet.`);
    }
    return elu(x);
  }
  function softsign(x) {
    return tidy(() => div3(x, add6(abs(x), 1)));
  }
  function dropout2(x, level, noiseShape, seed) {
    return tidy(() => dropout(x, level, noiseShape, seed));
  }
  function hardSigmoid(x) {
    return tidy(() => {
      const y = add6(0.5, mul4(0.2, x));
      return clipByValue(y, 0, 1);
    });
  }
  function inTrainPhase(x, alt, training = false) {
    return training ? x() : alt();
  }

  // node_modules/@tensorflow/tfjs-layers/dist/keras_format/initializer_config.js
  var VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"];
  var VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];

  // node_modules/@tensorflow/tfjs-layers/dist/initializers.js
  function checkFanMode(value) {
    checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", value);
  }
  function checkDistribution(value) {
    checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", value);
  }
  var Initializer = class extends serialization_exports.Serializable {
    fromConfigUsesCustomObjects() {
      return false;
    }
    getConfig() {
      return {};
    }
  };
  var Zeros = class extends Initializer {
    apply(shape, dtype) {
      return zeros(shape, dtype);
    }
  };
  Zeros.className = "Zeros";
  serialization_exports.registerClass(Zeros);
  var Ones = class extends Initializer {
    apply(shape, dtype) {
      return ones2(shape, dtype);
    }
  };
  Ones.className = "Ones";
  serialization_exports.registerClass(Ones);
  var Constant = class extends Initializer {
    constructor(args) {
      super();
      if (typeof args !== "object") {
        throw new ValueError(`Expected argument of type ConstantConfig but got ${args}`);
      }
      if (args.value === void 0) {
        throw new ValueError(`config must have value set but got ${args}`);
      }
      this.value = args.value;
    }
    apply(shape, dtype) {
      return tidy(() => mul4(scalar(this.value), ones2(shape, dtype)));
    }
    getConfig() {
      return {
        value: this.value
      };
    }
  };
  Constant.className = "Constant";
  serialization_exports.registerClass(Constant);
  var RandomUniform = class extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_MINVAL = -0.05;
      this.DEFAULT_MAXVAL = 0.05;
      this.minval = args.minval || this.DEFAULT_MINVAL;
      this.maxval = args.maxval || this.DEFAULT_MAXVAL;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      return randomUniform(shape, this.minval, this.maxval, dtype);
    }
    getConfig() {
      return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    }
  };
  RandomUniform.className = "RandomUniform";
  serialization_exports.registerClass(RandomUniform);
  var RandomNormal = class extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_MEAN = 0;
      this.DEFAULT_STDDEV = 0.05;
      this.mean = args.mean || this.DEFAULT_MEAN;
      this.stddev = args.stddev || this.DEFAULT_STDDEV;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);
      }
      return randomNormal2(shape, this.mean, this.stddev, dtype, this.seed);
    }
    getConfig() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }
  };
  RandomNormal.className = "RandomNormal";
  serialization_exports.registerClass(RandomNormal);
  var TruncatedNormal = class extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_MEAN = 0;
      this.DEFAULT_STDDEV = 0.05;
      this.mean = args.mean || this.DEFAULT_MEAN;
      this.stddev = args.stddev || this.DEFAULT_STDDEV;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`truncatedNormal does not support dType ${dtype}.`);
      }
      return truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
    }
    getConfig() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }
  };
  TruncatedNormal.className = "TruncatedNormal";
  serialization_exports.registerClass(TruncatedNormal);
  var Identity3 = class extends Initializer {
    constructor(args) {
      super();
      this.gain = args.gain != null ? args.gain : 1;
    }
    apply(shape, dtype) {
      return tidy(() => {
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");
        } else {
          return mul4(this.gain, eye(shape[0]));
        }
      });
    }
    getConfig() {
      return { gain: this.gain };
    }
  };
  Identity3.className = "Identity";
  serialization_exports.registerClass(Identity3);
  function computeFans(shape, dataFormat = "channelsLast") {
    let fanIn;
    let fanOut;
    checkDataFormat(dataFormat);
    if (shape.length === 2) {
      fanIn = shape[0];
      fanOut = shape[1];
    } else if ([3, 4, 5].indexOf(shape.length) !== -1) {
      if (dataFormat === "channelsFirst") {
        const receptiveFieldSize = arrayProd(shape, 2);
        fanIn = shape[1] * receptiveFieldSize;
        fanOut = shape[0] * receptiveFieldSize;
      } else if (dataFormat === "channelsLast") {
        const receptiveFieldSize = arrayProd(shape, 0, shape.length - 2);
        fanIn = shape[shape.length - 2] * receptiveFieldSize;
        fanOut = shape[shape.length - 1] * receptiveFieldSize;
      }
    } else {
      const shapeProd = arrayProd(shape);
      fanIn = Math.sqrt(shapeProd);
      fanOut = Math.sqrt(shapeProd);
    }
    return [fanIn, fanOut];
  }
  var VarianceScaling = class extends Initializer {
    constructor(args) {
      super();
      if (args.scale < 0) {
        throw new ValueError(`scale must be a positive float. Got: ${args.scale}`);
      }
      this.scale = args.scale == null ? 1 : args.scale;
      this.mode = args.mode == null ? "fanIn" : args.mode;
      checkFanMode(this.mode);
      this.distribution = args.distribution == null ? "normal" : args.distribution;
      checkDistribution(this.distribution);
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      const fans = computeFans(shape);
      const fanIn = fans[0];
      const fanOut = fans[1];
      let scale5 = this.scale;
      if (this.mode === "fanIn") {
        scale5 /= Math.max(1, fanIn);
      } else if (this.mode === "fanOut") {
        scale5 /= Math.max(1, fanOut);
      } else {
        scale5 /= Math.max(1, (fanIn + fanOut) / 2);
      }
      if (this.distribution === "normal") {
        const stddev = Math.sqrt(scale5);
        dtype = dtype || "float32";
        if (dtype !== "float32" && dtype !== "int32") {
          throw new NotImplementedError(`${this.getClassName()} does not support dType ${dtype}.`);
        }
        return truncatedNormal(shape, 0, stddev, dtype, this.seed);
      } else {
        const limit = Math.sqrt(3 * scale5);
        return randomUniform(shape, -limit, limit, dtype);
      }
    }
    getConfig() {
      return {
        scale: this.scale,
        mode: this.mode,
        distribution: this.distribution,
        seed: this.seed
      };
    }
  };
  VarianceScaling.className = "VarianceScaling";
  serialization_exports.registerClass(VarianceScaling);
  var GlorotUniform = class extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "uniform",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  GlorotUniform.className = "GlorotUniform";
  serialization_exports.registerClass(GlorotUniform);
  var GlorotNormal = class extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "normal",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  GlorotNormal.className = "GlorotNormal";
  serialization_exports.registerClass(GlorotNormal);
  var HeNormal = class extends VarianceScaling {
    constructor(args) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "normal",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  HeNormal.className = "HeNormal";
  serialization_exports.registerClass(HeNormal);
  var HeUniform = class extends VarianceScaling {
    constructor(args) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "uniform",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  HeUniform.className = "HeUniform";
  serialization_exports.registerClass(HeUniform);
  var LeCunNormal = class extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "normal",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  LeCunNormal.className = "LeCunNormal";
  serialization_exports.registerClass(LeCunNormal);
  var LeCunUniform = class extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "uniform",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  LeCunUniform.className = "LeCunNormal";
  serialization_exports.registerClass(LeCunUniform);
  var Orthogonal = class extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_GAIN = 1;
      this.gain = args.gain == null ? this.DEFAULT_GAIN : args.gain;
      this.seed = args.seed;
      if (this.seed != null) {
        throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.");
      }
    }
    apply(shape, dtype) {
      return tidy(() => {
        if (shape.length < 2) {
          throw new NotImplementedError("Shape must be at least 2D.");
        }
        if (shape[0] * shape[1] > 2e3) {
          console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${shape[0] * shape[1]}) elements: Slowness may result.`);
        }
        const normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;
        const a = randomNormal2(normalizedShape, 0, 1, "float32");
        let q = linalg.gramSchmidt(a);
        if (shape[0] > shape[1]) {
          q = transpose2(q);
        }
        return mul4(this.gain, q);
      });
    }
    getConfig() {
      return {
        gain: this.gain,
        seed: this.seed
      };
    }
  };
  Orthogonal.className = "Orthogonal";
  serialization_exports.registerClass(Orthogonal);
  var INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    "constant": "Constant",
    "glorotNormal": "GlorotNormal",
    "glorotUniform": "GlorotUniform",
    "heNormal": "HeNormal",
    "heUniform": "HeUniform",
    "identity": "Identity",
    "leCunNormal": "LeCunNormal",
    "leCunUniform": "LeCunUniform",
    "ones": "Ones",
    "orthogonal": "Orthogonal",
    "randomNormal": "RandomNormal",
    "randomUniform": "RandomUniform",
    "truncatedNormal": "TruncatedNormal",
    "varianceScaling": "VarianceScaling",
    "zeros": "Zeros"
  };
  function deserializeInitializer(config, customObjects = {}) {
    return deserializeKerasObject(config, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "initializer");
  }
  function serializeInitializer(initializer) {
    return serializeKerasObject(initializer);
  }
  function getInitializer(identifier) {
    if (typeof identifier === "string") {
      const className = identifier in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
      if (className === "GlorotNormal") {
        return new GlorotNormal();
      } else if (className === "GlorotUniform") {
        return new GlorotUniform();
      } else if (className === "HeNormal") {
        return new HeNormal();
      } else if (className === "HeUniform") {
        return new HeUniform();
      } else if (className === "LeCunNormal") {
        return new LeCunNormal();
      } else if (className === "LeCunUniform") {
        return new LeCunUniform();
      } else {
        const config = {};
        config["className"] = className;
        config["config"] = {};
        return deserializeInitializer(config);
      }
    } else if (identifier instanceof Initializer) {
      return identifier;
    } else {
      return deserializeInitializer(identifier);
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/backend/state.js
  var _nextUniqueTensorId = 0;
  function getNextUniqueTensorId() {
    return _nextUniqueTensorId++;
  }
  var _uidPrefixes = {};
  function getUid(prefix = "") {
    if (!(prefix in _uidPrefixes)) {
      _uidPrefixes[prefix] = 0;
    }
    _uidPrefixes[prefix] += 1;
    return prefix + _uidPrefixes[prefix].toString();
  }

  // node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js
  function isArrayOfShapes(x) {
    return Array.isArray(x) && Array.isArray(x[0]);
  }
  function normalizeShapeList(x) {
    if (x.length === 0) {
      return [];
    }
    if (!Array.isArray(x[0])) {
      return [x];
    }
    return x;
  }
  function getExactlyOneTensor(xs) {
    let x;
    if (Array.isArray(xs)) {
      if (xs.length !== 1) {
        throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);
      }
      x = xs[0];
    } else {
      x = xs;
    }
    return x;
  }
  function getExactlyOneShape(shapes) {
    if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
      if (shapes.length === 1) {
        shapes = shapes;
        return shapes[0];
      } else {
        throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`);
      }
    } else {
      return shapes;
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/utils/variable_utils.js
  function countParamsInWeights(weights) {
    let count2 = 0;
    for (const weight of weights) {
      if (weight.shape.length === 0) {
        count2 += 1;
      } else {
        count2 += weight.shape.reduce((a, b) => a * b);
      }
    }
    return count2;
  }

  // node_modules/@tensorflow/tfjs-layers/dist/variables.js
  var DEFAULT_VARIABLE_NAME_PREFIX = "Variable";
  var LayerVariable = class {
    constructor(val, dtype = "float32", name = DEFAULT_VARIABLE_NAME_PREFIX, trainable = true, constraint = null) {
      this.dtype = dtype == null ? "float32" : dtype;
      this.shape = val.shape;
      this.id = getNextUniqueTensorId();
      name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
      this.originalName = getScopedTensorName(name);
      this.name = getUniqueTensorName(this.originalName);
      this.trainable_ = trainable;
      this.constraint = constraint;
      this.val = variable(val, this.trainable_, this.name, this.dtype);
    }
    read() {
      this.assertNotDisposed();
      return this.val;
    }
    write(newVal) {
      this.assertNotDisposed();
      checkShapesMatch(this.val, newVal);
      if (this.val.id !== newVal.id) {
        this.val.assign(newVal);
        if (this.constraint != null) {
          this.val.assign(this.constraint.apply(this.val));
        }
      }
      return this;
    }
    dispose() {
      this.assertNotDisposed();
      this.val.dispose();
    }
    assertNotDisposed() {
      if (this.val.isDisposed) {
        throw new Error(`LayersVariable ${this.name} is already disposed.`);
      }
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(trainable) {
      this.trainable_ = trainable;
      this.val.trainable = trainable;
    }
  };
  function checkShapesMatch(x, y) {
    if (x.shape.toString() !== y.shape.toString()) {
      throw new Error("Shape mismatch: " + JSON.stringify(x.shape) + " vs. " + JSON.stringify(y.shape));
    }
  }
  function batchGetValue(xs) {
    return xs.map((x) => x.read());
  }
  function batchSetValue(variablesAndValues) {
    variablesAndValues.forEach((variableAndValue) => {
      const variable2 = variableAndValue[0];
      variable2.write(variableAndValue[1]);
    });
  }

  // node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js
  var InputSpec = class {
    constructor(args) {
      this.dtype = args.dtype;
      this.shape = args.shape;
      if (args.shape != null) {
        this.ndim = args.shape.length;
      } else {
        this.ndim = args.ndim;
      }
      this.maxNDim = args.maxNDim;
      this.minNDim = args.minNDim;
      this.axes = args.axes || {};
    }
  };
  var SymbolicTensor = class {
    constructor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
      this.dtype = dtype;
      this.shape = shape;
      this.sourceLayer = sourceLayer;
      this.inputs = inputs;
      this.callArgs = callArgs;
      this.outputTensorIndex = outputTensorIndex;
      this.id = getNextUniqueTensorId();
      if (name != null) {
        this.originalName = getScopedTensorName(name);
        this.name = getUniqueTensorName(this.originalName);
      }
      this.rank = shape.length;
    }
  };
  var _nextNodeID = 0;
  var Node = class {
    constructor(args, callArgs) {
      this.callArgs = callArgs;
      this.id = _nextNodeID++;
      this.outboundLayer = args.outboundLayer;
      this.inboundLayers = args.inboundLayers;
      this.nodeIndices = args.nodeIndices;
      this.tensorIndices = args.tensorIndices;
      this.inputTensors = args.inputTensors;
      this.outputTensors = args.outputTensors;
      this.inputMasks = args.inputMasks;
      this.outputMasks = args.outputMasks;
      this.inputShapes = args.inputShapes;
      this.outputShapes = args.outputShapes;
      for (const layer of args.inboundLayers) {
        if (layer != null) {
          layer.outboundNodes.push(this);
        }
      }
      args.outboundLayer.inboundNodes.push(this);
    }
    getConfig() {
      const inboundNames = [];
      for (const layer of this.inboundLayers) {
        if (layer != null) {
          inboundNames.push(layer.name);
        } else {
          inboundNames.push(null);
        }
      }
      return {
        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
        inboundLayers: inboundNames,
        nodeIndices: this.nodeIndices,
        tensorIndices: this.tensorIndices
      };
    }
  };
  var _nextLayerID = 0;
  var Layer = class extends serialization_exports.Serializable {
    constructor(args = {}) {
      super();
      this._callHook = null;
      this._addedWeightNames = [];
      this._stateful = false;
      this.id = _nextLayerID++;
      this.activityRegularizer = null;
      this.inputSpec = null;
      this.supportsMasking = false;
      this._trainableWeights = [];
      this._nonTrainableWeights = [];
      this._losses = [];
      this._updates = [];
      this._built = false;
      this.inboundNodes = [];
      this.outboundNodes = [];
      let name = args.name;
      if (!name) {
        const prefix = this.getClassName();
        name = toSnakeCase(prefix) + "_" + getUid(prefix);
      }
      this.name = name;
      this.trainable_ = args.trainable == null ? true : args.trainable;
      if (args.inputShape != null || args.batchInputShape != null) {
        let batchInputShape;
        if (args.batchInputShape != null) {
          batchInputShape = args.batchInputShape;
        } else if (args.inputShape != null) {
          let batchSize = null;
          if (args.batchSize != null) {
            batchSize = args.batchSize;
          }
          batchInputShape = [batchSize].concat(args.inputShape);
        }
        this.batchInputShape = batchInputShape;
        let dtype = args.dtype;
        if (dtype == null) {
          dtype = args.inputDType;
        }
        if (dtype == null) {
          dtype = "float32";
        }
        this.dtype = dtype;
      }
      if (args.weights != null) {
        this.initialWeights = args.weights;
      } else {
        this.initialWeights = null;
      }
      this._refCount = null;
      this.fastWeightInitDuringBuild = false;
    }
    static nodeKey(layer, nodeIndex) {
      return layer.name + "_ib-" + nodeIndex.toString();
    }
    getNodeAtIndex(nodeIndex, attrName) {
      if (this.inboundNodes.length === 0) {
        throw new RuntimeError(`The layer has never been called and thus has no defined ${attrName}.`);
      }
      if (this.inboundNodes.length <= nodeIndex) {
        throw new ValueError(`Asked to get ${attrName} at node ${nodeIndex}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);
      }
      return this.inboundNodes[nodeIndex];
    }
    getInputAt(nodeIndex) {
      return singletonOrArray(this.getNodeAtIndex(nodeIndex, "input").inputTensors);
    }
    getOutputAt(nodeIndex) {
      return singletonOrArray(this.getNodeAtIndex(nodeIndex, "output").outputTensors);
    }
    get input() {
      if (this.inboundNodes.length > 1) {
        throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);
      } else if (this.inboundNodes.length === 0) {
        throw new AttributeError(`Layer ${this.name} is not connected, no input to return.`);
      }
      return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
    }
    get output() {
      if (this.inboundNodes.length === 0) {
        throw new AttributeError(`Layer ${this.name} has no inbound nodes.`);
      }
      if (this.inboundNodes.length > 1) {
        throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);
      }
      return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
    }
    get losses() {
      return this._losses;
    }
    calculateLosses() {
      return this.losses.map((lossFn) => lossFn());
    }
    get updates() {
      return this._updates;
    }
    get built() {
      return this._built;
    }
    set built(built) {
      this._built = built;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(trainable) {
      this._trainableWeights.forEach((w) => w.trainable = trainable);
      this.trainable_ = trainable;
    }
    get trainableWeights() {
      if (this.trainable_) {
        return this._trainableWeights.filter((w) => w.trainable);
      } else {
        return [];
      }
    }
    set trainableWeights(weights) {
      this._trainableWeights = weights;
    }
    get nonTrainableWeights() {
      if (this.trainable) {
        return this._trainableWeights.filter((w) => !w.trainable).concat(this._nonTrainableWeights);
      } else {
        return this._trainableWeights.concat(this._nonTrainableWeights);
      }
    }
    set nonTrainableWeights(weights) {
      this._nonTrainableWeights = weights;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    get stateful() {
      return this._stateful;
    }
    resetStates() {
      if (!this.stateful) {
        throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.");
      }
    }
    assertInputCompatibility(inputs) {
      inputs = toList(inputs);
      if (this.inputSpec == null || this.inputSpec.length === 0) {
        return;
      }
      const inputSpec = toList(this.inputSpec);
      if (inputs.length !== inputSpec.length) {
        throw new ValueError(`Layer ${this.name} expects ${inputSpec.length} inputs, but it received ${inputs.length} input tensors. Input received: ${inputs}`);
      }
      for (let inputIndex = 0; inputIndex < inputs.length; inputIndex++) {
        const x = inputs[inputIndex];
        const spec = inputSpec[inputIndex];
        if (spec == null) {
          continue;
        }
        const ndim = x.rank;
        if (spec.ndim != null) {
          if (ndim !== spec.ndim) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected ndim=${spec.ndim}, found ndim=${ndim}`);
          }
        }
        if (spec.maxNDim != null) {
          if (ndim > spec.maxNDim) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected max_ndim=${spec.maxNDim}, found ndim=${ndim}`);
          }
        }
        if (spec.minNDim != null) {
          if (ndim < spec.minNDim) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected min_ndim=${spec.minNDim}, found ndim=${ndim}.`);
          }
        }
        if (spec.dtype != null) {
          if (x.dtype !== spec.dtype) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name} : expected dtype=${spec.dtype}, found dtype=${x.dtype}.`);
          }
        }
        if (spec.axes) {
          const xShape = x.shape;
          for (const key in spec.axes) {
            const axis = Number(key);
            const value = spec.axes[key];
            const xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
            if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected axis ${axis} of input shape to have value ${value} but got shape ${xShape}.`);
            }
          }
        }
        if (spec.shape != null) {
          for (let i = 0; i < spec.shape.length; ++i) {
            const specDim = spec.shape[i];
            const dim = x.shape[i];
            if (specDim != null && dim != null) {
              if (specDim !== dim) {
                throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: expected shape=${spec.shape}, found shape=${x.shape}.`);
              }
            }
          }
        }
      }
    }
    call(inputs, kwargs) {
      return inputs;
    }
    invokeCallHook(inputs, kwargs) {
      if (this._callHook != null) {
        this._callHook(inputs, kwargs);
      }
    }
    setCallHook(callHook3) {
      this._callHook = callHook3;
    }
    clearCallHook() {
      this._callHook = null;
    }
    apply(inputs, kwargs) {
      kwargs = kwargs || {};
      this.assertNotDisposed();
      const inputsList = toList(inputs);
      let allAreSymbolic = true;
      for (const input2 of inputsList) {
        if (!(input2 instanceof SymbolicTensor)) {
          allAreSymbolic = false;
          break;
        }
      }
      let noneAreSymbolic = true;
      for (const input2 of inputsList) {
        if (input2 instanceof SymbolicTensor) {
          noneAreSymbolic = false;
          break;
        }
      }
      if (allAreSymbolic === noneAreSymbolic) {
        throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");
      }
      return nameScope(this.name, () => {
        if (!this.built) {
          this.assertInputCompatibility(inputs);
          const inputShapes = [];
          for (const xElem of toList(inputs)) {
            inputShapes.push(xElem.shape);
          }
          this.build(singletonOrArray(inputShapes));
          this.built = true;
          if (this.initialWeights) {
            this.setWeights(this.initialWeights);
          }
          if (this._refCount === null && noneAreSymbolic) {
            this._refCount = 1;
          }
        }
        this.assertInputCompatibility(inputs);
        if (noneAreSymbolic) {
          let output = this.call(inputs, kwargs);
          const outputList = toList(output);
          const outputListCopy = [];
          for (let x of outputList) {
            if (inputsList.indexOf(x) !== -1) {
              x = x.clone();
            }
            outputListCopy.push(x);
          }
          output = singletonOrArray(outputListCopy);
          if (this.activityRegularizer != null) {
            throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          }
          return output;
        } else {
          const inputShape = collectInputShape(inputs);
          const outputShape = this.computeOutputShape(inputShape);
          let output;
          const outputDType = guessOutputDType(inputs);
          this.warnOnIncompatibleInputShape(Array.isArray(inputs) ? inputShape[0] : inputShape);
          if (outputShape != null && outputShape.length > 0 && Array.isArray(outputShape[0])) {
            output = outputShape.map((shape, index) => new SymbolicTensor(outputDType, shape, this, toList(inputs), kwargs, this.name, index));
          } else {
            output = new SymbolicTensor(outputDType, outputShape, this, toList(inputs), kwargs, this.name);
          }
          this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
          this._refCount++;
          if (this.activityRegularizer != null) {
            throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
          }
          return output;
        }
      });
    }
    warnOnIncompatibleInputShape(inputShape) {
      if (this.batchInputShape == null) {
        return;
      } else if (inputShape.length !== this.batchInputShape.length) {
        console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(inputShape)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);
      } else {
        let dimMismatch = false;
        this.batchInputShape.forEach((dimension, i) => {
          if (dimension != null && inputShape[i] != null && inputShape[i] !== dimension) {
            dimMismatch = true;
          }
        });
        if (dimMismatch) {
          console.warn(`The shape of the input tensor (${JSON.stringify(inputShape)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`);
        }
      }
    }
    get outputShape() {
      if (this.inboundNodes == null || this.inboundNodes.length === 0) {
        throw new AttributeError(`The layer ${this.name} has never been called and thus has no defined output shape.`);
      }
      const allOutputShapes = [];
      for (const node of this.inboundNodes) {
        const shapeString = JSON.stringify(node.outputShapes);
        if (allOutputShapes.indexOf(shapeString) === -1) {
          allOutputShapes.push(shapeString);
        }
      }
      if (allOutputShapes.length === 1) {
        const outputShapes = this.inboundNodes[0].outputShapes;
        if (Array.isArray(outputShapes) && Array.isArray(outputShapes[0]) && outputShapes.length === 1) {
          return outputShapes[0];
        } else {
          return outputShapes;
        }
      } else {
        throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`);
      }
    }
    countParams() {
      if (!this.built) {
        throw new RuntimeError(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);
      }
      return countParamsInWeights(this.weights);
    }
    build(inputShape) {
      this.built = true;
    }
    getWeights(trainableOnly = false) {
      return batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
    }
    setWeights(weights) {
      tidy(() => {
        const params = this.weights;
        if (params.length !== weights.length) {
          throw new ValueError(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${weights.length}, but the layer was expecting ${params.length} weights. Provided weights: ${weights}...`);
        }
        if (params.length === 0) {
          return;
        }
        const weightValueTuples = [];
        const paramValues = batchGetValue(params);
        for (let i = 0; i < paramValues.length; ++i) {
          const pv = paramValues[i];
          const p3 = params[i];
          const w = weights[i];
          if (!util_exports2.arraysEqual(pv.shape, w.shape)) {
            throw new ValueError(`Layer weight shape ${pv.shape} not compatible with provided weight shape ${w.shape}`);
          }
          weightValueTuples.push([p3, w]);
        }
        batchSetValue(weightValueTuples);
      });
    }
    addWeight(name, shape, dtype, initializer, regularizer, trainable, constraint, getInitializerFunc) {
      if (this._addedWeightNames.indexOf(name) !== -1) {
        throw new ValueError(`Duplicate weight name ${name} for layer ${this.name}`);
      }
      this._addedWeightNames.push(name);
      if (dtype == null) {
        dtype = "float32";
      }
      if (this.fastWeightInitDuringBuild) {
        initializer = getInitializerFunc != null ? getInitializerFunc() : getInitializer("zeros");
      }
      const initValue = initializer.apply(shape, dtype);
      const weight = new LayerVariable(initValue, dtype, name, trainable, constraint);
      initValue.dispose();
      if (regularizer != null) {
        this.addLoss(() => regularizer.apply(weight.read()));
      }
      if (trainable == null) {
        trainable = true;
      }
      if (trainable) {
        this._trainableWeights.push(weight);
      } else {
        this._nonTrainableWeights.push(weight);
      }
      return weight;
    }
    setFastWeightInitDuringBuild(value) {
      this.fastWeightInitDuringBuild = value;
    }
    addLoss(losses3) {
      if (losses3 == null || Array.isArray(losses3) && losses3.length === 0) {
        return;
      }
      losses3 = toList(losses3);
      if (this._losses !== void 0 && this._losses !== null) {
        this.losses.push(...losses3);
      }
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    computeMask(inputs, mask) {
      if (!this.supportsMasking) {
        if (mask != null) {
          if (Array.isArray(mask)) {
            mask.forEach((maskElement) => {
              if (maskElement != null) {
                throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
              }
            });
          } else {
            throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);
          }
        }
        return null;
      }
      return mask;
    }
    addInboundNode(inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs = null) {
      const inputTensorList = toList(inputTensors);
      outputTensors = toList(outputTensors);
      inputMasks = toList(inputMasks);
      outputMasks = toList(outputMasks);
      inputShapes = normalizeShapeList(inputShapes);
      outputShapes = normalizeShapeList(outputShapes);
      const inboundLayers = [];
      const nodeIndices = [];
      const tensorIndices = [];
      for (const x of inputTensorList) {
        inboundLayers.push(x.sourceLayer);
        nodeIndices.push(x.nodeIndex);
        tensorIndices.push(x.tensorIndex);
      }
      new Node({
        outboundLayer: this,
        inboundLayers,
        nodeIndices,
        tensorIndices,
        inputTensors: inputTensorList,
        outputTensors,
        inputMasks,
        outputMasks,
        inputShapes,
        outputShapes
      }, kwargs);
      for (let i = 0; i < outputTensors.length; i++) {
        outputTensors[i].sourceLayer = this;
        outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
        outputTensors[i].tensorIndex = i;
      }
    }
    getConfig() {
      const config = { name: this.name, trainable: this.trainable };
      if (this.batchInputShape != null) {
        config["batchInputShape"] = this.batchInputShape;
      }
      if (this.dtype != null) {
        config["dtype"] = this.dtype;
      }
      return config;
    }
    disposeWeights() {
      this.weights.forEach((weight) => weight.dispose());
      return this.weights.length;
    }
    assertNotDisposed() {
      if (this._refCount === 0) {
        throw new Error(`Layer '${this.name}' is already disposed.`);
      }
    }
    dispose() {
      if (!this.built) {
        throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);
      }
      if (this._refCount === null) {
        throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);
      }
      this.assertNotDisposed();
      let numDisposedVariables = 0;
      if (--this._refCount === 0) {
        numDisposedVariables = this.disposeWeights();
      }
      return { refCountAfterDispose: this._refCount, numDisposedVariables };
    }
  };
  function collectInputShape(inputTensors) {
    inputTensors = toList(inputTensors);
    const shapes = [];
    for (const x of inputTensors) {
      shapes.push(x.shape);
    }
    return singletonOrArray(shapes);
  }
  function guessOutputDType(inputTensors) {
    return "float32";
  }
  function getSourceInputs(tensor2, layer, nodeIndex) {
    if (layer == null || nodeIndex != null && nodeIndex > 0) {
      layer = tensor2.sourceLayer;
      nodeIndex = tensor2.nodeIndex;
    }
    if (layer.inboundNodes.length === 0) {
      return [tensor2];
    } else {
      const node = layer.inboundNodes[nodeIndex];
      if (node.inboundLayers.length === 0) {
        return node.inputTensors;
      } else {
        const sourceTensors = [];
        for (let i = 0; i < node.inboundLayers.length; i++) {
          const x = node.inputTensors[i];
          const layer2 = node.inboundLayers[i];
          const nodeIndex2 = node.nodeIndices[i];
          const previousSources = getSourceInputs(x, layer2, nodeIndex2);
          for (const x2 of previousSources) {
            if (sourceTensors.indexOf(x2) === -1) {
              sourceTensors.push(x2);
            }
          }
        }
        return sourceTensors;
      }
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js
  var InputLayer = class extends Layer {
    constructor(args) {
      super({
        dtype: args.dtype,
        name: args.name != null ? args.name : getUid("input").toString()
      });
      if (args.batchSize == null) {
        args.batchSize = null;
      }
      if (args.sparse == null) {
        args.sparse = false;
      }
      this.trainable = false;
      this.built = true;
      this.sparse = args.sparse;
      if (args.inputShape != null && args.batchInputShape != null) {
        throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
      }
      let batchInputShape = args.batchInputShape;
      if (batchInputShape == null) {
        if (args.inputShape == null) {
          throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
        } else {
          batchInputShape = [args.batchSize].concat(args.inputShape);
        }
      } else {
        if (args.batchSize != null) {
          throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
        }
      }
      const dtype = args.dtype || "float32";
      this.batchInputShape = batchInputShape;
      this.dtype = dtype;
      this.inputSpec = [{ shape: batchInputShape }];
      const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);
      inputTensor.nodeIndex = 0;
      inputTensor.tensorIndex = 0;
      new Node({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: [inputTensor],
        outputTensors: [inputTensor],
        inputMasks: [null],
        outputMasks: [null],
        inputShapes: [batchInputShape],
        outputShapes: [batchInputShape]
      });
    }
    apply(inputs, kwargs) {
      throw new ValueError(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`);
    }
    dispose() {
      return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
    }
    getConfig() {
      return {
        batchInputShape: this.batchInputShape,
        dtype: this.dtype,
        sparse: this.sparse,
        name: this.name
      };
    }
  };
  InputLayer.className = "InputLayer";
  serialization_exports.registerClass(InputLayer);
  function Input(config) {
    if (config.batchShape == null && config.shape == null) {
      throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
    }
    if (config.batchShape != null && config.shape != null) {
      throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
    }
    let batchShape = config.batchShape;
    if (config.shape != null && batchShape == null) {
      batchShape = [null].concat(config.shape);
    }
    let dtype = config.dtype;
    if (dtype == null) {
      dtype = "float32";
    }
    const inputLayer = new InputLayer({
      batchInputShape: batchShape,
      name: config.name,
      dtype,
      sparse: config.sparse
    });
    const outputs = inputLayer.inboundNodes[0].outputTensors;
    return outputs[0];
  }

  // node_modules/@tensorflow/tfjs-layers/dist/logs.js
  async function resolveScalarsInLogs(logs) {
    if (logs == null) {
      return;
    }
    const promises = [];
    const keys2 = [];
    const scalarsToDispose = [];
    for (const key in logs) {
      const value = logs[key];
      if (typeof value !== "number") {
        const valueScalar = value;
        promises.push(valueScalar.data());
        keys2.push(key);
        scalarsToDispose.push(valueScalar);
      }
    }
    if (promises.length > 0) {
      const values2 = await Promise.all(promises);
      for (let i = 0; i < values2.length; ++i) {
        logs[keys2[i]] = values2[i][0];
      }
      dispose(scalarsToDispose);
    }
  }
  function disposeTensorsInLogs(logs) {
    if (logs == null) {
      return;
    }
    for (const key in logs) {
      const value = logs[key];
      if (typeof value !== "number") {
        value.dispose();
      }
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js
  var ModelLoggingVerbosity;
  (function(ModelLoggingVerbosity2) {
    ModelLoggingVerbosity2[ModelLoggingVerbosity2["SILENT"] = 0] = "SILENT";
    ModelLoggingVerbosity2[ModelLoggingVerbosity2["VERBOSE"] = 1] = "VERBOSE";
  })(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));
  var DEFAULT_YIELD_EVERY_MS = 125;
  var BaseCallback = class {
    constructor() {
      this.validationData = null;
    }
    setParams(params) {
      this.params = params;
    }
    async onEpochBegin(epoch, logs) {
    }
    async onEpochEnd(epoch, logs) {
    }
    async onBatchBegin(batch, logs) {
    }
    async onBatchEnd(batch, logs) {
    }
    async onTrainBegin(logs) {
    }
    async onTrainEnd(logs) {
    }
    setModel(model2) {
    }
  };
  var CallbackList = class {
    constructor(callbacks2, queueLength = 10) {
      if (callbacks2 == null) {
        callbacks2 = [];
      }
      this.callbacks = callbacks2;
      this.queueLength = queueLength;
    }
    append(callback) {
      this.callbacks.push(callback);
    }
    setParams(params) {
      for (const callback of this.callbacks) {
        callback.setParams(params);
      }
    }
    setModel(model2) {
      for (const callback of this.callbacks) {
        callback.setModel(model2);
      }
    }
    async onEpochBegin(epoch, logs) {
      if (logs == null) {
        logs = {};
      }
      for (const callback of this.callbacks) {
        await callback.onEpochBegin(epoch, logs);
      }
    }
    async onEpochEnd(epoch, logs) {
      if (logs == null) {
        logs = {};
      }
      for (const callback of this.callbacks) {
        await callback.onEpochEnd(epoch, logs);
      }
    }
    async onBatchBegin(batch, logs) {
      if (logs == null) {
        logs = {};
      }
      for (const callback of this.callbacks) {
        await callback.onBatchBegin(batch, logs);
      }
    }
    async onBatchEnd(batch, logs) {
      if (logs == null) {
        logs = {};
      }
      for (const callback of this.callbacks) {
        await callback.onBatchEnd(batch, logs);
      }
    }
    async onTrainBegin(logs) {
      if (logs == null) {
        logs = {};
      }
      for (const callback of this.callbacks) {
        await callback.onTrainBegin(logs);
      }
    }
    async onTrainEnd(logs) {
      if (logs == null) {
        logs = {};
      }
      for (const callback of this.callbacks) {
        await callback.onTrainEnd(logs);
      }
    }
  };
  var BaseLogger = class extends BaseCallback {
    constructor() {
      super();
    }
    async onEpochBegin(epoch) {
      this.seen = 0;
      this.totals = {};
    }
    async onBatchEnd(batch, logs) {
      if (logs == null) {
        logs = {};
      }
      const batchSize = logs["size"] == null ? 0 : logs["size"];
      this.seen += batchSize;
      for (const key in logs) {
        const value = logs[key];
        if (typeof value === "number") {
          if (!this.totals.hasOwnProperty(key)) {
            this.totals[key] = 0;
          }
          this.totals[key] = this.totals[key] + value * batchSize;
        } else {
          let oldTotalsToDispose;
          if (key in this.totals) {
            oldTotalsToDispose = this.totals[key];
          } else {
            this.totals[key] = 0;
          }
          const total = tidy(() => add6(this.totals[key], mul4(value, batchSize)));
          this.totals[key] = total;
          if (oldTotalsToDispose != null) {
            oldTotalsToDispose.dispose();
          }
        }
      }
    }
    async onEpochEnd(epoch, logs) {
      if (logs != null) {
        for (const key of this.params["metrics"]) {
          if (this.totals[key] == null) {
            continue;
          }
          if (typeof this.totals[key] === "number") {
            logs[key] = this.totals[key] / this.seen;
          } else {
            tidy(() => {
              const log9 = mul4(div3(1, this.seen), this.totals[key]);
              logs[key] = log9;
              this.totals[key].dispose();
              keep(logs[key]);
            });
          }
        }
      }
    }
  };
  var History = class extends BaseCallback {
    async onTrainBegin(logs) {
      this.epoch = [];
      this.history = {};
    }
    async onEpochEnd(epoch, logs) {
      if (logs == null) {
        logs = {};
      }
      this.epoch.push(epoch);
      for (const key in logs) {
        if (this.history[key] == null) {
          this.history[key] = [];
        }
        this.history[key].push(logs[key]);
      }
    }
    async syncData() {
      const promises = [];
      const keys2 = [];
      const indices = [];
      for (const key in this.history) {
        const valueArray = this.history[key];
        for (let i = 0; i < valueArray.length; ++i) {
          if (typeof valueArray[i] !== "number") {
            const valueScalar = valueArray[i];
            promises.push(valueScalar.data());
            keys2.push(key);
            indices.push(i);
          }
        }
      }
      const values2 = await Promise.all(promises);
      for (let n = 0; n < values2.length; ++n) {
        const tensorToDispose = this.history[keys2[n]][indices[n]];
        tensorToDispose.dispose();
        this.history[keys2[n]][indices[n]] = values2[n][0];
      }
    }
  };
  var CustomCallback = class extends BaseCallback {
    constructor(args, yieldEvery) {
      super();
      this.currentEpoch = 0;
      this.nowFunc = args.nowFunc;
      this.nextFrameFunc = args.nextFrameFunc || nextFrame2;
      this.yieldEvery = yieldEvery || "auto";
      if (this.yieldEvery === "auto") {
        this.yieldEvery = DEFAULT_YIELD_EVERY_MS;
      }
      if (this.yieldEvery === "never" && args.onYield != null) {
        throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
      }
      if (util_exports2.isNumber(this.yieldEvery)) {
        this.maybeWait = debounce2(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);
      }
      this.trainBegin = args.onTrainBegin;
      this.trainEnd = args.onTrainEnd;
      this.epochBegin = args.onEpochBegin;
      this.epochEnd = args.onEpochEnd;
      this.batchBegin = args.onBatchBegin;
      this.batchEnd = args.onBatchEnd;
      this.yield = args.onYield;
    }
    async maybeWait(epoch, batch, logs) {
      const ps = [];
      if (this.yield != null) {
        await resolveScalarsInLogs(logs);
        ps.push(this.yield(epoch, batch, logs));
      }
      ps.push(this.nextFrameFunc());
      await Promise.all(ps);
    }
    async onEpochBegin(epoch, logs) {
      this.currentEpoch = epoch;
      if (this.epochBegin != null) {
        await resolveScalarsInLogs(logs);
        await this.epochBegin(epoch, logs);
      }
    }
    async onEpochEnd(epoch, logs) {
      const ps = [];
      if (this.epochEnd != null) {
        await resolveScalarsInLogs(logs);
        ps.push(this.epochEnd(epoch, logs));
      }
      if (this.yieldEvery === "epoch") {
        ps.push(this.nextFrameFunc());
      }
      await Promise.all(ps);
    }
    async onBatchBegin(batch, logs) {
      if (this.batchBegin != null) {
        await resolveScalarsInLogs(logs);
        await this.batchBegin(batch, logs);
      }
    }
    async onBatchEnd(batch, logs) {
      const ps = [];
      if (this.batchEnd != null) {
        await resolveScalarsInLogs(logs);
        ps.push(this.batchEnd(batch, logs));
      }
      if (this.yieldEvery === "batch") {
        ps.push(this.nextFrameFunc());
      } else if (util_exports2.isNumber(this.yieldEvery)) {
        ps.push(this.maybeWait(this.currentEpoch, batch, logs));
      }
      await Promise.all(ps);
    }
    async onTrainBegin(logs) {
      if (this.trainBegin != null) {
        await resolveScalarsInLogs(logs);
        await this.trainBegin(logs);
      }
    }
    async onTrainEnd(logs) {
      if (this.trainEnd != null) {
        await resolveScalarsInLogs(logs);
        await this.trainEnd(logs);
      }
    }
  };
  function standardizeCallbacks(callbacks2, yieldEvery) {
    if (callbacks2 == null) {
      callbacks2 = {};
    }
    if (callbacks2 instanceof BaseCallback) {
      return [callbacks2];
    }
    if (Array.isArray(callbacks2) && callbacks2[0] instanceof BaseCallback) {
      return callbacks2;
    }
    const callbackConfigs = toList(callbacks2);
    return callbackConfigs.map((callbackConfig) => new CustomCallback(callbackConfig, yieldEvery));
  }
  var CallbackConstructorRegistry = class {
    constructor() {
    }
    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {
      util_exports2.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, but got ${verbosityLevel}`);
      CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);
      if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {
        CallbackConstructorRegistry.constructors[verbosityLevel] = [];
      }
      CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);
    }
    static checkForDuplicate(callbackConstructor) {
      for (const levelName in CallbackConstructorRegistry.constructors) {
        const constructors = CallbackConstructorRegistry.constructors[+levelName];
        constructors.forEach((ctor) => {
          if (ctor === callbackConstructor) {
            throw new ValueError("Duplicate callback constructor.");
          }
        });
      }
    }
    static clear() {
      CallbackConstructorRegistry.constructors = {};
    }
    static createCallbacks(verbosityLevel) {
      const constructors = [];
      for (const levelName in CallbackConstructorRegistry.constructors) {
        const level = +levelName;
        if (verbosityLevel >= level) {
          constructors.push(...CallbackConstructorRegistry.constructors[level]);
        }
      }
      return constructors.map((ctor) => new ctor());
    }
  };
  CallbackConstructorRegistry.constructors = {};
  function configureCallbacks(callbacks2, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {
    const history = new History();
    const actualCallbacks = [
      new BaseLogger(),
      ...CallbackConstructorRegistry.createCallbacks(verbose)
    ];
    if (callbacks2 != null) {
      actualCallbacks.push(...callbacks2);
    }
    actualCallbacks.push(history);
    const callbackList = new CallbackList(actualCallbacks);
    callbackList.setParams({
      epochs,
      initialEpoch,
      samples: numTrainSamples,
      steps: stepsPerEpoch,
      batchSize,
      verbose,
      doValidation,
      metrics: callbackMetrics
    });
    return { callbackList, history };
  }

  // node_modules/@tensorflow/tfjs-layers/dist/layers/serialization.js
  function deserialize(config, customObjects = {}, fastWeightInit = false) {
    return deserializeKerasObject(config, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "layer", fastWeightInit);
  }

  // node_modules/@tensorflow/tfjs-layers/dist/losses.js
  function l2Normalize(x, axis) {
    return tidy(() => {
      if (x.dtype !== "float32") {
        x = cast(x, "float32");
      }
      const squareSum = sum2(square2(x), axis, true);
      const epsilonTensor = fill(squareSum.shape, epsilon());
      const norm2 = sqrt(maximum(squareSum, epsilonTensor));
      return div3(x, norm2);
    });
  }
  function meanSquaredError(yTrue, yPred) {
    return tidy(() => mean(square2(sub4(yPred, yTrue)), -1));
  }
  function meanAbsoluteError(yTrue, yPred) {
    return tidy(() => mean(abs(sub4(yPred, yTrue)), -1));
  }
  function meanAbsolutePercentageError(yTrue, yPred) {
    return tidy(() => {
      const diff2 = sub4(yTrue, yPred);
      const clippedTrue = clipByValue(abs(yTrue), epsilon(), Number.MAX_VALUE);
      const absResult = abs(div3(diff2, clippedTrue));
      return mul4(100, mean(absResult, -1));
    });
  }
  function meanSquaredLogarithmicError(yTrue, yPred) {
    return tidy(() => {
      const clippedPred = clipByValue(yPred, epsilon(), Number.MAX_VALUE);
      const firstLog = log6(add6(1, clippedPred));
      const clippedTrue = clipByValue(yTrue, epsilon(), Number.MAX_VALUE);
      const secondLog = log6(add6(1, clippedTrue));
      return mean(square2(sub4(firstLog, secondLog)), -1);
    });
  }
  function squaredHinge(yTrue, yPred) {
    return tidy(() => {
      const maxResult = maximum(0, sub4(1, mul4(yTrue, yPred)));
      return mean(square2(maxResult), -1);
    });
  }
  function hinge(yTrue, yPred) {
    return tidy(() => {
      const maxResult = maximum(0, sub4(1, mul4(yTrue, yPred)));
      return mean(maxResult, -1);
    });
  }
  function categoricalHinge(yTrue, yPred) {
    return tidy(() => {
      const pos = sum2(mul4(yTrue, yPred), -1);
      const neg4 = max3(mul4(sub4(1, yTrue), yPred), -1);
      return maximum(0, add6(1, sub4(neg4, pos)));
    });
  }
  function logcosh(yTrue, yPred) {
    return tidy(() => {
      const log22 = Math.log(2);
      const predictionDiff = sub4(yPred, yTrue);
      const logcoshResult = sub4(add6(predictionDiff, softplus(mul4(-2, predictionDiff))), log22);
      return mean(logcoshResult, -1);
    });
  }
  function categoricalCrossentropy(target, output, fromLogits = false) {
    return tidy(() => {
      if (fromLogits) {
        output = softmax(output);
      } else {
        const outputSum = sum2(output, output.shape.length - 1, true);
        output = div3(output, outputSum);
      }
      output = clipByValue(output, epsilon(), 1 - epsilon());
      return neg(sum2(mul4(cast(target, "float32"), log6(output)), output.shape.length - 1));
    });
  }
  function sparseCategoricalCrossentropy(target, output, fromLogits = false) {
    return tidy(() => {
      const flatTarget = cast(floor3(flatten3(target)), "int32");
      output = clipByValue(output, epsilon(), 1 - epsilon());
      const outputShape = output.shape;
      const oneHotTarget = reshape(oneHot(flatTarget, outputShape[outputShape.length - 1]), outputShape);
      return categoricalCrossentropy(oneHotTarget, output, fromLogits);
    });
  }
  function sigmoidCrossEntropyWithLogits(labels, logits) {
    if (!util_exports2.arraysEqual(labels.shape, logits.shape)) {
      throw new ValueError(`logits and labels must have the same shape, but got shapes ${JSON.stringify(labels.shape)} and ${JSON.stringify(logits.shape)}`);
    }
    return tidy(() => {
      const reluLogits = relu(logits);
      const negAbsLogits = neg(abs(logits));
      return add6(sub4(reluLogits, mul4(logits, labels)), log1p(exp(negAbsLogits)));
    });
  }
  function binaryCrossentropy(yTrue, yPred) {
    return tidy(() => {
      let y;
      y = clipByValue(yPred, epsilon(), 1 - epsilon());
      y = log6(div3(y, sub4(1, y)));
      return mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);
    });
  }
  function kullbackLeiblerDivergence(yTrue, yPred) {
    return tidy(() => {
      const clippedTrue = clipByValue(yTrue, epsilon(), 1);
      const clippedPred = clipByValue(yPred, epsilon(), 1);
      return sum2(mul4(yTrue, log6(div3(clippedTrue, clippedPred))), -1);
    });
  }
  function poisson(yTrue, yPred) {
    return tidy(() => {
      const logPred = log6(add6(epsilon(), yPred));
      return mean(sub4(yPred, mul4(yTrue, logPred)), -1);
    });
  }
  function cosineProximity(yTrue, yPred) {
    return tidy(() => {
      const trueNormalized = l2Normalize(yTrue, -1);
      const predNormalized = l2Normalize(yPred, -1);
      const trueXPred = mul4(trueNormalized, predNormalized);
      return neg(sum2(trueXPred, -1));
    });
  }
  var lossesMap = {
    meanSquaredError,
    meanAbsoluteError,
    meanAbsolutePercentageError,
    meanSquaredLogarithmicError,
    squaredHinge,
    hinge,
    categoricalHinge,
    logcosh,
    categoricalCrossentropy,
    sparseCategoricalCrossentropy,
    binaryCrossentropy,
    kullbackLeiblerDivergence,
    poisson,
    cosineProximity
  };
  function get2(identifierOrFn) {
    if (typeof identifierOrFn === "string") {
      if (identifierOrFn in lossesMap) {
        return lossesMap[identifierOrFn];
      }
      let errMsg = `Unknown loss ${identifierOrFn}`;
      if (identifierOrFn.toLowerCase().includes("softmaxcrossentropy")) {
        errMsg = `Unknown loss ${identifierOrFn}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`;
      }
      throw new ValueError(errMsg);
    } else {
      return identifierOrFn;
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/metrics.js
  function binaryAccuracy(yTrue, yPred) {
    return tidy(() => {
      const threshold3 = mul4(0.5, onesLike(yPred));
      const yPredThresholded = cast2(greater(yPred, threshold3), yTrue.dtype);
      return mean(equal(yTrue, yPredThresholded), -1);
    });
  }
  function categoricalAccuracy(yTrue, yPred) {
    return tidy(() => cast2(equal(argMax(yTrue, -1), argMax(yPred, -1)), "float32"));
  }
  function truePositives(yTrue, yPred) {
    return tidy(() => {
      return cast(sum2(logicalAnd(equal(yTrue, 1), equal(yPred, 1))), "float32");
    });
  }
  function falsePositives(yTrue, yPred) {
    return tidy(() => {
      return cast(sum2(logicalAnd(equal(yTrue, 0), equal(yPred, 1))), "float32");
    });
  }
  function precision(yTrue, yPred) {
    return tidy(() => {
      const tp = truePositives(yTrue, yPred);
      const fp = falsePositives(yTrue, yPred);
      const denominator = add6(tp, fp);
      return cast(where(greater(denominator, 0), div3(tp, denominator), 0), "float32");
    });
  }
  function binaryCrossentropy2(yTrue, yPred) {
    return binaryCrossentropy(yTrue, yPred);
  }
  function sparseCategoricalAccuracy(yTrue, yPred) {
    if (yTrue.rank === yPred.rank) {
      yTrue = squeeze(yTrue, [yTrue.rank - 1]);
    }
    yPred = argMax(yPred, -1);
    if (yPred.dtype !== yTrue.dtype) {
      yPred = cast(yPred, yTrue.dtype);
    }
    return cast(equal(yTrue, yPred), "float32");
  }
  var mse = meanSquaredError;
  var MSE = meanSquaredError;
  var mae = meanAbsoluteError;
  var MAE = meanAbsoluteError;
  var mape = meanAbsolutePercentageError;
  var MAPE = meanAbsolutePercentageError;
  var categoricalCrossentropy2 = categoricalCrossentropy;
  var cosine = cosineProximity;
  var sparseCategoricalCrossentropy2 = sparseCategoricalCrossentropy;
  var metricsMap = {
    binaryAccuracy,
    categoricalAccuracy,
    precision,
    categoricalCrossentropy: categoricalCrossentropy2,
    sparseCategoricalCrossentropy: sparseCategoricalCrossentropy2,
    mse,
    MSE,
    mae,
    MAE,
    mape,
    MAPE,
    cosine
  };
  function get3(identifier) {
    if (typeof identifier === "string" && identifier in metricsMap) {
      return metricsMap[identifier];
    } else if (typeof identifier !== "string" && identifier != null) {
      return identifier;
    } else {
      throw new ValueError(`Unknown metric ${identifier}`);
    }
  }
  function getLossOrMetricName(fn) {
    assert2(fn !== null, `Unknown LossOrMetricFn ${fn}`);
    if (typeof fn === "string") {
      return fn;
    } else {
      let fnName;
      for (const key of Object.keys(lossesMap)) {
        if (lossesMap[key] === fn) {
          fnName = key;
          break;
        }
      }
      if (fnName !== void 0) {
        return fnName;
      }
      for (const key of Object.keys(metricsMap)) {
        if (metricsMap[key] === fn) {
          fnName = key;
          break;
        }
      }
      if (fnName !== void 0) {
        return fnName;
      }
      return fn.name;
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/optimizers.js
  function getOptimizer(identifier) {
    const optimizerMap = {
      "Adagrad": () => train.adagrad(0.01),
      "Adadelta": () => train.adadelta(1, 0.95, epsilon()),
      "Adam": () => train.adam(1e-3, 0.9, 0.999, epsilon()),
      "Adamax": () => train.adamax(2e-3, 0.9, 0.999, epsilon(), 0),
      "RMSProp": () => train.rmsprop(1e-3, 0.9, 0, epsilon()),
      "SGD": () => train.sgd(0.01)
    };
    optimizerMap["adagrad"] = optimizerMap["Adagrad"];
    optimizerMap["adadelta"] = optimizerMap["Adadelta"];
    optimizerMap["adam"] = optimizerMap["Adam"];
    optimizerMap["adamax"] = optimizerMap["Adamax"];
    optimizerMap["rmsprop"] = optimizerMap["RMSProp"];
    optimizerMap["sgd"] = optimizerMap["SGD"];
    if (identifier in optimizerMap) {
      return optimizerMap[identifier]();
    }
    throw new ValueError(`Unknown Optimizer ${identifier}`);
  }

  // node_modules/@tensorflow/tfjs-layers/dist/user_defined_metadata.js
  var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1 * 1024 * 1024;
  function checkUserDefinedMetadata(userDefinedMetadata, modelName, checkSize = false) {
    if (userDefinedMetadata == null || typeof userDefinedMetadata !== "object" || Object.getPrototypeOf(userDefinedMetadata) !== Object.prototype || !plainObjectCheck(userDefinedMetadata)) {
      throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
    }
    if (checkSize) {
      const out = JSON.stringify(userDefinedMetadata);
      if (out.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH) {
        console.warn(`User-defined metadata of model "${modelName}" is too large in size (length=${out.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`);
      }
    }
  }
  function plainObjectCheck(x) {
    if (x === null) {
      return true;
    } else if (typeof x === "object") {
      if (Object.getPrototypeOf(x) === Object.prototype) {
        const keys2 = Object.keys(x);
        for (const key of keys2) {
          if (typeof key !== "string") {
            return false;
          }
          if (!plainObjectCheck(x[key])) {
            return false;
          }
        }
        return true;
      } else {
        if (Array.isArray(x)) {
          for (const item of x) {
            if (!plainObjectCheck(item)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
    } else {
      const xType = typeof x;
      return xType === "string" || xType === "number" || xType === "boolean";
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/utils/layer_utils.js
  function printSummary(model2, lineLength, positions, printFn = console.log) {
    const sequentialLike = isModelSequentialLike(model2);
    const toDisplay = ["Layer (type)", "Output shape", "Param #"];
    if (sequentialLike) {
      lineLength = lineLength || 65;
      positions = positions || [0.45, 0.85, 1];
    } else {
      lineLength = lineLength || 98;
      positions = positions || [0.33, 0.55, 0.67, 1];
    }
    if (positions[positions.length - 1] <= 1) {
      positions = positions.map((p3) => Math.floor(lineLength * p3));
    }
    let relevantNodes;
    if (!sequentialLike) {
      toDisplay.push("Receives inputs");
      relevantNodes = [];
      for (const depth in model2.nodesByDepth) {
        relevantNodes.push(...model2.nodesByDepth[depth]);
      }
    }
    printFn("_".repeat(lineLength));
    printRow(toDisplay, positions, printFn);
    printFn("=".repeat(lineLength));
    const layers = model2.layers;
    for (let i = 0; i < layers.length; ++i) {
      if (sequentialLike) {
        printLayerSummary(layers[i], positions, printFn);
      } else {
        printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);
      }
      printFn((i === layers.length - 1 ? "=" : "_").repeat(lineLength));
    }
    model2.checkTrainableWeightsConsistency();
    const trainableCount = countTrainableParams(model2);
    const nonTrainableCount = countParamsInWeights(model2.nonTrainableWeights);
    printFn(`Total params: ${trainableCount + nonTrainableCount}`);
    printFn(`Trainable params: ${trainableCount}`);
    printFn(`Non-trainable params: ${nonTrainableCount}`);
    printFn("_".repeat(lineLength));
  }
  function countTrainableParams(model2) {
    let trainableCount;
    if (model2.collectedTrainableWeights != null) {
      trainableCount = countParamsInWeights(model2.collectedTrainableWeights);
    } else {
      trainableCount = countParamsInWeights(model2.trainableWeights);
    }
    return trainableCount;
  }
  function isModelSequentialLike(model2) {
    let sequentialLike = true;
    const nodesByDepth = [];
    const nodes = [];
    for (const depth in model2.nodesByDepth) {
      nodesByDepth.push(model2.nodesByDepth[depth]);
    }
    for (const depthNodes of nodesByDepth) {
      if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {
        sequentialLike = false;
        break;
      }
      nodes.push(...depthNodes);
    }
    if (sequentialLike) {
      for (const layer of model2.layers) {
        let flag = false;
        for (const node of layer.inboundNodes) {
          if (nodes.indexOf(node) !== -1) {
            if (flag) {
              sequentialLike = false;
              break;
            } else {
              flag = true;
            }
          }
        }
        if (!sequentialLike) {
          break;
        }
      }
    }
    return sequentialLike;
  }
  function printRow(fields, positions, printFn = console.log) {
    let line = "";
    for (let i = 0; i < fields.length; ++i) {
      if (i > 0) {
        line = line.slice(0, line.length - 1) + " ";
      }
      line += fields[i];
      line = line.slice(0, positions[i]);
      line += " ".repeat(positions[i] - line.length);
    }
    printFn(line);
  }
  function printLayerSummary(layer, positions, printFn) {
    let outputShape;
    try {
      outputShape = JSON.stringify(layer.outputShape);
    } catch (err) {
      outputShape = "multiple";
    }
    const name = layer.name;
    const className = layer.getClassName();
    const fields = [`${name} (${className})`, outputShape, layer.countParams().toString()];
    printRow(fields, positions, printFn);
  }
  function printLayerSummaryWithConnections(layer, positions, relevantNodes, printFn) {
    let outputShape;
    try {
      outputShape = JSON.stringify(layer.outputShape);
    } catch (err) {
      outputShape = "multiple";
    }
    const connections = [];
    for (const node of layer.inboundNodes) {
      if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {
        continue;
      }
      for (let i = 0; i < node.inboundLayers.length; ++i) {
        const inboundLayer = node.inboundLayers[i].name;
        const inboundLayerIndex = node.nodeIndices[i];
        const inboundTensorIndex = node.tensorIndices[i];
        connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);
      }
    }
    const name = layer.name;
    const className = layer.getClassName();
    const firstConnection = connections.length === 0 ? "" : connections[0];
    const fields = [
      `${name} (${className})`,
      outputShape,
      layer.countParams().toString(),
      firstConnection
    ];
    printRow(fields, positions, printFn);
    for (let i = 1; i < connections.length; ++i) {
      printRow(["", "", "", connections[i]], positions, printFn);
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/utils/serialization_utils.js
  function isArrayItemInputOrOutputName(key, index, value) {
    return (key === "inboundNodes" || key === "outputLayers" || key === "inputLayers") && index === 0 && typeof value === "string";
  }
  function convertPythonicToTs(pythonicConfig, key) {
    if (pythonicConfig === null) {
      return null;
    } else if (typeof pythonicConfig === "string") {
      return toCamelCase(pythonicConfig);
    } else if (typeof pythonicConfig === "number" || typeof pythonicConfig === "boolean") {
      return pythonicConfig;
    } else if (pythonicConfig instanceof Array) {
      const tsArray = [];
      const arrayLength = pythonicConfig.length;
      for (let i = 0; i < arrayLength; ++i) {
        const item = pythonicConfig[i];
        if (isArrayItemInputOrOutputName(key, i, item)) {
          tsArray.push(item);
        } else {
          tsArray.push(convertPythonicToTs(item, key));
        }
      }
      return tsArray;
    } else {
      const tsDict = {};
      for (const pythonicKey of Object.keys(pythonicConfig)) {
        const pythonicValue = pythonicConfig[pythonicKey];
        if (pythonicKey === "name" && typeof pythonicValue === "string") {
          tsDict[pythonicKey] = pythonicValue;
        } else {
          const tsKey = toCamelCase(pythonicKey);
          tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
        }
      }
      return tsDict;
    }
  }
  function convertTsToPythonic(tsConfig, key) {
    if (tsConfig === null || tsConfig === void 0) {
      return null;
    } else if (typeof tsConfig === "string") {
      return toSnakeCase(tsConfig);
    } else if (typeof tsConfig === "number" || typeof tsConfig === "boolean") {
      return tsConfig;
    } else if (tsConfig instanceof Array) {
      const pyArray = [];
      const arrayLength = tsConfig.length;
      for (let i = 0; i < arrayLength; ++i) {
        const item = tsConfig[i];
        if (isArrayItemInputOrOutputName(key, i, item)) {
          pyArray.push(item);
        } else {
          pyArray.push(convertTsToPythonic(item, key));
        }
      }
      return pyArray;
    } else {
      const pyDict = {};
      for (const tsKey of Object.keys(tsConfig)) {
        const tsValue = tsConfig[tsKey];
        const pyKey = toSnakeCase(tsKey);
        if ((tsKey === "name" || tsKey === "className") && typeof tsValue === "string") {
          pyDict[pyKey] = tsValue;
        } else {
          pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
        }
      }
      return pyDict;
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/version.js
  var version4 = "3.11.0";

  // node_modules/@tensorflow/tfjs-layers/dist/engine/executor.js
  function assertFeedCompatibility(key, val) {
    if (key.dtype == null || key.dtype === val.dtype) {
      return val;
    }
    try {
      return cast(val, key.dtype);
    } catch (err) {
      throw new ValueError(`The dtype of the feed (${val.dtype}) can not be cast to the dtype of the key '${key.name}' (${key.dtype}).`);
    }
  }
  var FeedDict = class {
    constructor(feeds) {
      this.id2Value = {};
      this.id2Mask = {};
      this.name2Id = {};
      if (feeds instanceof FeedDict) {
        for (const id in feeds.id2Value) {
          this.id2Value[id] = feeds.id2Value[id];
          if (id in feeds.id2Mask) {
            this.id2Mask[id] = feeds.id2Mask[id];
          }
        }
      } else {
        if (feeds == null) {
          return;
        }
        for (const feed of feeds) {
          this.add(feed.key, feed.value);
        }
      }
    }
    add(key, value, mask) {
      if (this.id2Value[key.id] == null) {
        this.id2Value[key.id] = assertFeedCompatibility(key, value);
        this.name2Id[key.name] = key.id;
        if (mask != null) {
          this.id2Mask[key.id] = mask;
        }
      } else {
        throw new ValueError(`Duplicate key: name=${key.name}, id=${key.id}`);
      }
      return this;
    }
    addFeed(feed) {
      this.add(feed.key, feed.value);
    }
    hasKey(key) {
      return this.id2Value[key.id] != null;
    }
    names() {
      return Object.keys(this.name2Id);
    }
    getValue(key) {
      if (key instanceof SymbolicTensor) {
        if (this.id2Value[key.id] == null) {
          throw new ValueError(`Nonexistent key: ${key.name}`);
        } else {
          return this.id2Value[key.id];
        }
      } else {
        const id = this.name2Id[key];
        if (id == null) {
          throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
        }
        return this.id2Value[id];
      }
    }
    getMask(key) {
      if (key instanceof SymbolicTensor) {
        if (this.id2Value[key.id] == null) {
          throw new ValueError(`Nonexistent key: ${key.name}`);
        } else {
          return this.id2Mask[key.id];
        }
      } else {
        const id = this.name2Id[key];
        if (id == null) {
          throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
        }
        return this.id2Mask[id];
      }
    }
    disposeMasks() {
      if (this.id2Mask != null) {
        dispose(this.id2Mask);
      }
    }
  };
  var cachedSorted = {};
  var cachedRecipientCounts = {};
  function execute(fetches, feedDict, kwargs, probe) {
    const training = kwargs == null ? false : kwargs["training"];
    const arrayFetches = Array.isArray(fetches);
    const fetchArray = arrayFetches ? fetches : [fetches];
    const outputNames = fetchArray.map((t) => t.name);
    const finalOutputs = [];
    const feedNames = feedDict.names();
    for (const outputName of outputNames) {
      if (feedNames.indexOf(outputName) !== -1) {
        finalOutputs.push(feedDict.getValue(outputName));
      } else {
        finalOutputs.push(null);
      }
    }
    if (probe != null) {
      probe.maxNumTensors = -Infinity;
      probe.minNumTensors = Infinity;
    }
    const fetchAndFeedKey = outputNames.join(",") + "|" + feedDict.names().join(",");
    let sorted;
    let recipientCounts;
    if (cachedSorted[fetchAndFeedKey] == null) {
      const out = getTopologicalSortAndRecipientCounts(fetchArray, feedDict);
      sorted = out.sorted;
      recipientCounts = out.recipientCounts;
      cachedSorted[fetchAndFeedKey] = sorted;
      cachedRecipientCounts[fetchAndFeedKey] = recipientCounts;
    }
    sorted = cachedSorted[fetchAndFeedKey];
    recipientCounts = {};
    if (!training) {
      Object.assign(recipientCounts, cachedRecipientCounts[fetchAndFeedKey]);
    }
    const internalFeedDict = new FeedDict(feedDict);
    for (let i = 0; i < sorted.length; ++i) {
      if (probe != null) {
        const numTensors = memory().numTensors;
        if (numTensors > probe.maxNumTensors) {
          probe.maxNumTensors = numTensors;
        }
        if (numTensors < probe.minNumTensors) {
          probe.minNumTensors = numTensors;
        }
      }
      const symbolic = sorted[i];
      const srcLayer = symbolic.sourceLayer;
      if (srcLayer instanceof InputLayer) {
        continue;
      }
      const inputValues = [];
      const inputMasks = [];
      const tensorsToDispose = [];
      let maskExists = false;
      for (const input2 of symbolic.inputs) {
        const value = internalFeedDict.getValue(input2);
        const mask = internalFeedDict.getMask(input2);
        inputValues.push(value);
        inputMasks.push(mask);
        if (mask != null) {
          maskExists = true;
        }
        if (!training) {
          recipientCounts[input2.name]--;
          if (recipientCounts[input2.name] === 0 && !feedDict.hasKey(input2) && outputNames.indexOf(input2.name) === -1 && !value.isDisposed && input2.sourceLayer.stateful !== true) {
            tensorsToDispose.push(value);
          }
        }
      }
      if (maskExists) {
        kwargs = kwargs || {};
        kwargs["mask"] = inputMasks[0];
      }
      const outputTensors = toList(srcLayer.apply(inputValues, kwargs));
      let outputMask = null;
      if (srcLayer.supportsMasking) {
        outputMask = srcLayer.computeMask(inputValues, inputMasks);
      }
      const layerOutputs = getNodeOutputs(symbolic);
      const outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
      for (let i2 = 0; i2 < outputSymbolicTensors.length; ++i2) {
        if (!internalFeedDict.hasKey(outputSymbolicTensors[i2])) {
          internalFeedDict.add(outputSymbolicTensors[i2], outputTensors[i2], Array.isArray(outputMask) ? outputMask[0] : outputMask);
        }
        const index = outputNames.indexOf(outputSymbolicTensors[i2].name);
        if (index !== -1) {
          finalOutputs[index] = outputTensors[i2];
        }
      }
      if (!training) {
        dispose(tensorsToDispose);
      }
    }
    internalFeedDict.disposeMasks();
    return arrayFetches ? finalOutputs : finalOutputs[0];
  }
  function getTopologicalSortAndRecipientCounts(fetches, feedDict) {
    util_exports2.assert(fetches != null && fetches.length > 0, () => `Expected at least one fetch, got none`);
    let finalSorted = [];
    let finalRecipientMap = {};
    if (fetches.length === 1) {
      const out = getTopologicalSortAndRecipientCountsForOneFetch(fetches[0], feedDict);
      finalSorted = out.sorted;
      finalRecipientMap = out.recipientMap;
    } else {
      const visited = new Set();
      for (const fetch4 of fetches) {
        const { sorted, recipientMap } = getTopologicalSortAndRecipientCountsForOneFetch(fetch4, feedDict);
        for (const symbolicTensor of sorted) {
          if (!visited.has(symbolicTensor.name)) {
            finalSorted.push(symbolicTensor);
            visited.add(symbolicTensor.name);
          }
        }
        for (const name in recipientMap) {
          if (finalRecipientMap[name] == null) {
            finalRecipientMap[name] = new Set();
          }
          recipientMap[name].forEach((recipient) => finalRecipientMap[name].add(recipient));
        }
      }
    }
    return {
      sorted: finalSorted,
      recipientCounts: recipientMap2Counts(finalRecipientMap)
    };
  }
  function recipientMap2Counts(recipientMap) {
    const recipientCounts = {};
    for (const name in recipientMap) {
      recipientCounts[name] = recipientMap[name].size;
    }
    return recipientCounts;
  }
  function getTopologicalSortAndRecipientCountsForOneFetch(fetch4, feedDict) {
    const visited = new Set();
    const sorted = [];
    const recipientMap = {};
    for (const key of feedDict.names()) {
      visited.add(key);
    }
    const stack3 = [];
    const marks = [];
    stack3.push(fetch4);
    while (stack3.length > 0) {
      const top = stack3[stack3.length - 1];
      if (visited.has(top.name)) {
        stack3.pop();
        continue;
      }
      const topIsMarked = marks[marks.length - 1] === stack3.length - 1;
      if (top.inputs.length === 0 || topIsMarked) {
        stack3.pop();
        sorted.push(top);
        visited.add(top.name);
        if (topIsMarked) {
          marks.pop();
        }
      } else {
        marks.push(stack3.length - 1);
        for (const input2 of top.inputs) {
          if (recipientMap[input2.name] == null) {
            recipientMap[input2.name] = new Set();
          }
          recipientMap[input2.name].add(top.name);
          if (visited.has(input2.name)) {
            continue;
          }
          stack3.push(input2);
        }
      }
    }
    return { sorted, recipientMap };
  }
  function getNodeOutputs(fetch4) {
    let layerOutputs;
    if (fetch4.sourceLayer.inboundNodes.length === 1) {
      layerOutputs = fetch4.sourceLayer.output;
    } else {
      let nodeIndex = null;
      for (let i = 0; i < fetch4.sourceLayer.inboundNodes.length; ++i) {
        for (const outputTensor of fetch4.sourceLayer.inboundNodes[i].outputTensors) {
          if (outputTensor.id === fetch4.id) {
            nodeIndex = i;
            break;
          }
        }
      }
      layerOutputs = fetch4.sourceLayer.getOutputAt(nodeIndex);
    }
    return layerOutputs;
  }

  // node_modules/@tensorflow/tfjs-layers/dist/engine/container.js
  var Container3 = class extends Layer {
    constructor(args) {
      super({});
      this.containerNodes = new Set();
      this.name = args.name;
      if (this.name == null) {
        const prefix = this.getClassName().toLowerCase();
        this.name = getUid(prefix);
      }
      this.supportsMasking = false;
      this.trainable_ = true;
      if (Array.isArray(args.inputs)) {
        this.inputs = args.inputs.slice();
      } else {
        this.inputs = [args.inputs];
      }
      if (Array.isArray(args.outputs)) {
        this.outputs = args.outputs.slice();
      } else {
        this.outputs = [args.outputs];
      }
      if (unique2(this.inputs).length !== this.inputs.length) {
        throw new ValueError(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((x) => x.name)}`);
      }
      if (unique2(this.outputs).length !== this.outputs.length) {
        console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((x) => x.name)}`);
      }
      this.inputLayers = [];
      this.inputLayersNodeIndices = [];
      this.inputLayersTensorIndices = [];
      this.outputLayers = [];
      this.outputLayersNodeIndices = [];
      this.outputLayersTensorIndices = [];
      this.layers = [];
      this.internalContainerRefs = [];
      for (const x of this.outputs) {
        const layer = x.sourceLayer;
        const nodeIndex = x.nodeIndex;
        const tensorIndex = x.tensorIndex;
        this.outputLayers.push(layer);
        this.outputLayersNodeIndices.push(nodeIndex);
        this.outputLayersTensorIndices.push(tensorIndex);
      }
      for (const x of this.inputs) {
        const layer = x.sourceLayer;
        const nodeIndex = x.nodeIndex;
        const tensorIndex = x.tensorIndex;
        assert2(nodeIndex === 0, "input layer has >1 nodes");
        assert2(tensorIndex === 0, "input layer has >1 tensors");
        this.inputLayers.push(layer);
        this.inputLayersNodeIndices.push(nodeIndex);
        this.inputLayersTensorIndices.push(tensorIndex);
      }
      this.inputNames = [];
      this.outputNames = [];
      this.feedInputShapes = [];
      this.feedInputNames = [];
      this.feedOutputNames = [];
      for (let i = 0; i < this.inputLayers.length; i++) {
        const layer = this.inputLayers[i];
        if (!(layer instanceof InputLayer)) {
          throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${args.inputs}. Input ${i} (0-based) originates from layer type ${layer.getClassName()}.`);
        }
        this.inputNames.push(layer.name);
        this.feedInputShapes.push(layer.batchInputShape);
        this.feedInputNames.push(layer.name);
      }
      for (const layer of this.outputLayers) {
        this.outputNames.push(layer.name);
      }
      this.internalInputShapes = this.inputs.map((x) => x.shape);
      this.internalOutputShapes = this.outputs.map((x) => x.shape);
      const nodesDepths = {};
      const nodeIDToNode = {};
      const layersDepths = {};
      const layerIDToLayer = {};
      const layerIndices = {};
      const nodesInDecreasingDepth = [];
      const buildMapOfGraph = (tensor2, finishedNodes2, nodesInProgress2, layer, nodeIndex, tensorIndex) => {
        if (layer == null || nodeIndex == null || tensorIndex == null) {
          layer = tensor2.sourceLayer;
          nodeIndex = tensor2.nodeIndex;
          tensorIndex = tensor2.tensorIndex;
        }
        const node = layer.inboundNodes[nodeIndex];
        if (nodesInProgress2.indexOf(node) !== -1) {
          throw new RuntimeError(`The tensor ${tensor2.name} at layer "${layer.name}" is part of a cycle.`);
        }
        if (finishedNodes2.indexOf(node) !== -1) {
          return;
        }
        this.containerNodes.add(Container3.nodeKey(layer, nodeIndex));
        if (!(layer.id in layerIndices)) {
          layerIndices[layer.id] = Object.keys(layerIndices).length;
        }
        if (nodesInProgress2.indexOf(node) === -1) {
          nodesInProgress2.push(node);
        }
        const numInboundLayers = node.inboundLayers.length;
        for (let i = 0; i < numInboundLayers; i++) {
          const x = node.inputTensors[i];
          const layer2 = node.inboundLayers[i];
          const nodeIndex2 = node.nodeIndices[i];
          const tensorIndex2 = node.tensorIndices[i];
          buildMapOfGraph(x, finishedNodes2, nodesInProgress2, layer2, nodeIndex2, tensorIndex2);
        }
        finishedNodes2.push(node);
        while (nodesInProgress2.indexOf(node) >= 0) {
          nodesInProgress2.splice(nodesInProgress2.indexOf(node), 1);
        }
        nodesInDecreasingDepth.push(node);
      };
      const finishedNodes = [];
      const nodesInProgress = [];
      for (const x of this.outputs) {
        buildMapOfGraph(x, finishedNodes, nodesInProgress);
      }
      const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
      for (const node of reversedNodesInDecreasingDepth) {
        nodeIDToNode[node.id] = node;
        if (!(node.id in nodesDepths)) {
          nodesDepths[node.id] = 0;
        }
        let depth = nodesDepths[node.id];
        const previousDepth = layersDepths[node.outboundLayer.id] == null ? 0 : layersDepths[node.outboundLayer.id];
        depth = Math.max(depth, previousDepth);
        layersDepths[node.outboundLayer.id] = depth;
        layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
        nodesDepths[node.id] = depth;
        for (let i = 0; i < node.inboundLayers.length; i++) {
          const inboundLayer = node.inboundLayers[i];
          const nodeIndex = node.nodeIndices[i];
          const inboundNode = inboundLayer.inboundNodes[nodeIndex];
          const previousDepth2 = nodesDepths[inboundNode.id] == null ? 0 : nodesDepths[inboundNode.id];
          nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth2);
          nodeIDToNode[inboundNode.id] = inboundNode;
        }
      }
      const nodesByDepth = {};
      for (const nodeID in nodesDepths) {
        const depth = nodesDepths[nodeID];
        if (!(depth in nodesByDepth)) {
          nodesByDepth[depth] = [];
        }
        nodesByDepth[depth].push(nodeIDToNode[nodeID]);
      }
      const layersByDepth = {};
      for (const layerID in layersDepths) {
        const depth = layersDepths[layerID];
        if (!(depth in layersByDepth)) {
          layersByDepth[depth] = [];
        }
        layersByDepth[depth].push(layerIDToLayer[layerID]);
      }
      let depthKeys = Object.keys(layersByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      this.layers = [];
      for (const depth of depthKeys) {
        const layersForDepth = layersByDepth[depth];
        layersForDepth.sort((a, b) => {
          const aIndex = layerIndices[a.id];
          const bIndex = layerIndices[b.id];
          if (aIndex < bIndex) {
            return -1;
          }
          if (aIndex > bIndex) {
            return 1;
          }
          return 0;
        });
        for (const layer of layersForDepth) {
          if (layer instanceof Container3) {
            this.internalContainerRefs.push(layer);
          }
          this.layers.push(layer);
        }
      }
      this.layersByDepth = layersByDepth;
      depthKeys = Object.keys(nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      const computableTensors = this.inputs.slice();
      const layersWithCompleteInput = [];
      for (const depth of depthKeys) {
        for (const node of nodesByDepth[depth]) {
          const layer = node.outboundLayer;
          if (layer != null) {
            for (const x of node.inputTensors) {
              if (computableTensors.indexOf(x) === -1) {
                throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${layer.name}". The following previous layers were accessed without issue: ${layersWithCompleteInput}`);
              }
            }
            for (const x of node.outputTensors) {
              computableTensors.push(x);
            }
            layersWithCompleteInput.push(layer.name);
          }
        }
      }
      this.nodesByDepth = nodesByDepth;
      const allNames = this.layers.map((x) => x.name);
      for (const name of allNames) {
        const numOccurrences = allNames.filter((x) => x === name).length;
        if (numOccurrences !== 1) {
          throw new RuntimeError(`The name "${name}" is used ${numOccurrences} times in the model. All layer names should be unique. Layer names: ` + JSON.stringify(allNames));
        }
      }
      this.outboundNodes = [];
      this.inboundNodes = [];
      new Node({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: this.inputs.map((x) => null),
        outputMasks: this.outputs.map((x) => null),
        inputShapes: this.inputs.map((x) => x.shape),
        outputShapes: this.outputs.map((x) => x.shape)
      });
      this.built = true;
      this._refCount = 1;
    }
    assertNotDisposed() {
      if (this._refCount === 0) {
        throw new Error(`Container '${this.name}' is already disposed.`);
      }
    }
    dispose() {
      this.assertNotDisposed();
      const result = { refCountAfterDispose: null, numDisposedVariables: 0 };
      if (--this._refCount === 0) {
        for (const layer of this.layers) {
          result.numDisposedVariables += layer.dispose().numDisposedVariables;
        }
        for (const container of this.internalContainerRefs) {
          result.numDisposedVariables += container.dispose().numDisposedVariables;
        }
      }
      result.refCountAfterDispose = this._refCount;
      return result;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(trainable) {
      this.layers.forEach((layer) => {
        layer._trainableWeights.forEach((w) => w.trainable = trainable);
      });
      this.trainable_ = trainable;
    }
    get trainableWeights() {
      if (this._trainableWeights.length > 0) {
        throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
      }
      if (!this.trainable) {
        return [];
      }
      let weights = [];
      for (const layer of this.layers) {
        weights = weights.concat(layer.trainableWeights);
      }
      return weights;
    }
    get nonTrainableWeights() {
      const weights = [];
      for (const layer of this.layers) {
        weights.push(...layer.nonTrainableWeights);
      }
      if (!this.trainable) {
        const trainableWeights = [];
        for (const layer of this.layers) {
          trainableWeights.push(...layer.trainableWeights);
        }
        return trainableWeights.concat(weights);
      }
      return weights;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    loadWeights(weights, strict = true) {
      const nameToWeight = {};
      let totalWeightsCount = 0;
      for (const layer of this.layers) {
        for (const weight of layer.weights) {
          if (nameToWeight[weight.originalName] != null) {
            throw new ValueError(`Duplicate weight name: ${weight.originalName}`);
          }
          nameToWeight[weight.originalName] = weight;
          totalWeightsCount++;
        }
      }
      const weightValueTuples = [];
      for (const name in weights) {
        let validatedName = name;
        if (nameToWeight[name] == null) {
          const tokens = name.split("/");
          const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);
          validatedName = shortenNameArray.join("/");
        }
        if (nameToWeight[validatedName] != null) {
          weightValueTuples.push([nameToWeight[validatedName], weights[name]]);
        } else if (strict) {
          throw new ValueError(`Provided weight data has no target variable: ${name}`);
        }
        delete nameToWeight[validatedName];
      }
      if (strict) {
        const unsetNames = [];
        for (const name in nameToWeight) {
          unsetNames.push(name);
        }
        if (unsetNames.length > 0) {
          throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ${unsetNames}`);
        }
      }
      batchSetValue(weightValueTuples);
    }
    updatedConfig() {
      const theConfig = this.getConfig();
      const modelConfig = {};
      modelConfig["className"] = this.getClassName();
      modelConfig["config"] = theConfig;
      modelConfig["kerasVersion"] = `tfjs-layers ${version4}`;
      modelConfig["backend"] = "TensorFlow.js";
      return modelConfig;
    }
    toJSON(unused, returnString = true) {
      const modelConfig = convertTsToPythonic(this.updatedConfig());
      return returnString ? JSON.stringify(modelConfig) : modelConfig;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = toList(inputs);
        const feedDict = new FeedDict();
        for (let i = 0; i < this.inputs.length; ++i) {
          feedDict.add(this.inputs[i], inputs[i]);
        }
        return execute(this.outputs, feedDict, kwargs);
      });
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        inputs = toList(inputs);
        let masks;
        if (mask == null) {
          masks = pyListRepeat(null, inputs.length);
        } else {
          masks = toList(mask);
        }
        return this.runInternalGraph(inputs, masks)[1];
      });
    }
    computeOutputShape(inputShape) {
      const inputShapes = normalizeShapeList(inputShape);
      if (inputShapes.length !== this.inputLayers.length) {
        throw new ValueError(`Invalid inputShape argument ${inputShape}: model has ${this.inputLayers.length} tensor inputs.`);
      }
      const layersToOutputShapes = {};
      for (let i = 0; i < inputShapes.length; i++) {
        const layer = this.inputLayers[i];
        const inputShape2 = inputShapes[i];
        const shapeKey = layer.name + "_0_0";
        layersToOutputShapes[shapeKey] = inputShape2;
      }
      const depthKeys = Object.keys(this.nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      if (depthKeys.length > 1) {
        for (const depth of depthKeys) {
          const nodes = this.nodesByDepth[depth];
          for (const node of nodes) {
            const layer = node.outboundLayer;
            if (this.inputLayers.map((x) => x.id).indexOf(layer.id) !== -1) {
              continue;
            }
            const inputShapes2 = [];
            for (let j = 0; j < node.inboundLayers.length; j++) {
              const inboundLayer = node.inboundLayers[j];
              const nodeIndex2 = node.nodeIndices[j];
              const tensorIndex = node.tensorIndices[j];
              const shapeKey = `${inboundLayer.name}_${nodeIndex2}_${tensorIndex}`;
              const inputShape2 = layersToOutputShapes[shapeKey];
              inputShapes2.push(inputShape2);
            }
            const outputShape = layer.computeOutputShape(singletonOrArray(inputShapes2));
            const outputShapes2 = normalizeShapeList(outputShape);
            const nodeIndex = layer.inboundNodes.indexOf(node);
            for (let j = 0; j < outputShapes2.length; j++) {
              const shapeKey = `${layer.name}_${nodeIndex}_${j}`;
              layersToOutputShapes[shapeKey] = outputShapes2[j];
            }
          }
        }
      }
      const outputShapes = [];
      const outputShapeKeys = [];
      for (let i = 0; i < this.outputLayers.length; i++) {
        const layer = this.outputLayers[i];
        const nodeIndex = this.outputLayersNodeIndices[i];
        const tensorIndex = this.outputLayersTensorIndices[i];
        const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;
        outputShapeKeys.push(shapeKey);
      }
      for (let i = 0; i < outputShapeKeys.length; i++) {
        const key = outputShapeKeys[i];
        assert2(key in layersToOutputShapes);
        outputShapes.push(layersToOutputShapes[key]);
      }
      return singletonOrArray(outputShapes);
    }
    runInternalGraph(inputs, masks) {
      if (masks == null) {
        masks = pyListRepeat(null, inputs.length);
      }
      const tensorMap = {};
      for (let i = 0; i < this.inputs.length; ++i) {
        const x = this.inputs[i];
        const y = inputs[i];
        const mask = masks[i];
        tensorMap[x.id] = [y, mask];
      }
      const depthKeys = Object.keys(this.nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      for (const depth of depthKeys) {
        const nodes = this.nodesByDepth[depth];
        for (const node of nodes) {
          const layer = node.outboundLayer;
          const referenceInputTensors = node.inputTensors;
          const referenceOutputTensors = node.outputTensors;
          const computedData = new Array();
          for (const x of referenceInputTensors) {
            if (x.id in tensorMap) {
              computedData.push(tensorMap[x.id]);
            }
          }
          if (computedData.length === referenceInputTensors.length) {
            let kwargs = {};
            let computedTensors;
            let computedMasks;
            let outputTensors2;
            let outputMasks2;
            if (node.callArgs != null) {
              kwargs = node.callArgs;
            }
            if (computedData.length === 1) {
              const [computedTensor, computedMask] = computedData[0];
              if (kwargs["mask"] == null) {
                kwargs["mask"] = computedMask;
              }
              outputTensors2 = toList(layer.call(computedTensor, kwargs));
              outputMasks2 = toList(layer.computeMask(computedTensor, computedMask));
              computedTensors = [computedTensor];
              computedMasks = [computedMask];
            } else {
              computedTensors = computedData.map((x) => x[0]);
              computedMasks = computedData.map((x) => x[1]);
              if (kwargs["mask"] == null) {
                kwargs["mask"] = computedMasks;
              }
              outputTensors2 = toList(layer.call(computedTensors, kwargs));
              outputMasks2 = toList(layer.computeMask(computedTensors, computedMasks));
            }
            if (layer.activityRegularizer) {
              throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
            }
            for (let i = 0; i < referenceOutputTensors.length; ++i) {
              const x = referenceOutputTensors[i];
              const y = outputTensors2[i];
              const mask = outputMasks2[i];
              tensorMap[x.id] = [y, mask];
            }
          }
        }
      }
      const outputTensors = [];
      const outputMasks = [];
      const outputShapes = [];
      for (const x of this.outputs) {
        assert2(x.id in tensorMap, `Could not compute output ${x.name} : ${x.id}`);
        const [tensor2, mask] = tensorMap[x.id];
        outputShapes.push(tensor2.shape);
        outputTensors.push(tensor2);
        outputMasks.push(mask);
      }
      return [outputTensors, outputMasks, outputShapes];
    }
    buildNodeConversionMap(layers) {
      const nodeConversionMap = {};
      let keptNodes;
      for (const layer of this.layers) {
        keptNodes = layer instanceof Container3 ? 1 : 0;
        for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
          const nodeKey = Container3.nodeKey(layer, originalNodeIndex);
          if (this.containerNodes.has(nodeKey)) {
            nodeConversionMap[nodeKey] = keptNodes;
            keptNodes += 1;
          }
        }
      }
      return nodeConversionMap;
    }
    getLayer(name, index) {
      if (index != null) {
        if (this.layers.length <= index) {
          throw new ValueError(`Was asked to retrieve layer at index ${index}, but model only has ${this.layers.length} layer(s).`);
        } else {
          return this.layers[index];
        }
      } else {
        if (name == null) {
          throw new ValueError("Provide either a layer name or layer index");
        }
      }
      for (const layer of this.layers) {
        if (layer.name === name) {
          return layer;
        }
      }
      throw new ValueError(`No such layer: ${name}`);
    }
    calculateLosses() {
      return tidy(() => {
        const losses3 = [];
        for (const layer of this.layers) {
          for (let nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
            const nodeKey = Container3.nodeKey(layer, nodeIndex);
            if (this.containerNodes.has(nodeKey)) {
              losses3.push(...layer.calculateLosses());
            }
          }
        }
        return losses3;
      });
    }
    getConfig() {
      const config = { name: this.name };
      const nodeConversionMap = this.buildNodeConversionMap(this.layers);
      const layerConfigs = [];
      for (const layer of this.layers) {
        const layerClassName = layer.getClassName();
        const layerConfig = layer.getConfig();
        const filteredInboundNodes = [];
        for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
          const node = layer.inboundNodes[originalNodeIndex];
          const nodeKey = Container3.nodeKey(layer, originalNodeIndex);
          let kwargs = {};
          if (this.containerNodes.has(nodeKey)) {
            if (node.callArgs) {
              try {
                JSON.stringify(node.callArgs);
                kwargs = node.callArgs;
              } catch (err) {
                console.warn(`Layer ${layer.name} was passed non-serializable keyword arguments: ${node.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`);
                kwargs = {};
              }
            }
            if (node.inboundLayers.length > 0) {
              const nodeData = [];
              for (let i = 0; i < node.inboundLayers.length; i++) {
                const inboundLayer = node.inboundLayers[i];
                const nodeIndex = node.nodeIndices[i];
                const tensorIndex = node.tensorIndices[i];
                const nodeKey2 = Container3.nodeKey(inboundLayer, nodeIndex);
                let newNodeIndex = nodeConversionMap[nodeKey2];
                if (newNodeIndex == null) {
                  newNodeIndex = 0;
                }
                nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
              }
              filteredInboundNodes.push(nodeData);
            }
          }
        }
        const dict = {};
        dict["name"] = layer.name;
        dict["className"] = layerClassName;
        dict["config"] = layerConfig;
        dict["inboundNodes"] = filteredInboundNodes;
        layerConfigs.push(dict);
      }
      config["layers"] = layerConfigs;
      const modelInputs = [];
      for (let i = 0; i < this.inputLayers.length; i++) {
        const layer = this.inputLayers[i];
        const nodeIndex = this.inputLayersNodeIndices[i];
        const nodeKey = Container3.nodeKey(layer, nodeIndex);
        if (!this.containerNodes.has(nodeKey)) {
          continue;
        }
        let newNodeIndex = nodeConversionMap[nodeKey];
        if (newNodeIndex === null || newNodeIndex === void 0) {
          newNodeIndex = 0;
        }
        const tensorIndex = this.inputLayersTensorIndices[i];
        modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
      }
      config["inputLayers"] = modelInputs;
      const modelOutputs = [];
      for (let i = 0; i < this.outputLayers.length; i++) {
        const layer = this.outputLayers[i];
        const nodeIndex = this.outputLayersNodeIndices[i];
        const nodeKey = Container3.nodeKey(layer, nodeIndex);
        if (!this.containerNodes.has(nodeKey)) {
          continue;
        }
        let newNodeIndex = nodeConversionMap[nodeKey];
        if (newNodeIndex === null || newNodeIndex === void 0) {
          newNodeIndex = 0;
        }
        const tensorIndex = this.outputLayersTensorIndices[i];
        modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
      }
      config["outputLayers"] = modelOutputs;
      return config;
    }
    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {
      const createdLayers = {};
      const unprocessedNodes = {};
      function addUnprocessedNode(layer, nodeData) {
        if (!(layer.name in unprocessedNodes)) {
          unprocessedNodes[layer.name] = [nodeData];
        } else {
          unprocessedNodes[layer.name].push(nodeData);
        }
      }
      function processNode(layer, nodeData) {
        const inputTensors2 = [];
        let kwargs;
        for (const inputData of nodeData) {
          const inboundLayerName = inputData[0];
          const inboundNodeIndex = inputData[1];
          const inboundTensorIndex = inputData[2];
          kwargs = inputData[3] == null ? {} : inputData[3];
          if (!(inboundLayerName in createdLayers)) {
            addUnprocessedNode(layer, nodeData);
            return;
          }
          const inboundLayer = createdLayers[inboundLayerName];
          if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
            addUnprocessedNode(layer, nodeData);
            return;
          }
          const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
          inputTensors2.push(inboundNode.outputTensors[inboundTensorIndex]);
        }
        if (inputTensors2.length > 0) {
          layer.apply(singletonOrArray(inputTensors2), kwargs);
        }
      }
      function processLayer(layerData) {
        const layerName = layerData["name"];
        const layer = deserialize(layerData, config["customObjects"] != null ? config["customObjects"] : {});
        layer.setFastWeightInitDuringBuild(fastWeightInit);
        createdLayers[layerName] = layer;
        const inboundNodesData = layerData["inboundNodes"];
        inboundNodesData.forEach((nodeData) => {
          if (!(nodeData instanceof Array)) {
            throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);
          }
          addUnprocessedNode(layer, nodeData);
        });
      }
      const name = config["name"];
      const layersFromConfig = config["layers"];
      for (const layerData of layersFromConfig) {
        processLayer(layerData);
      }
      while (!isObjectEmpty(unprocessedNodes)) {
        for (const layerData of layersFromConfig) {
          const layer = createdLayers[layerData["name"]];
          if (layer.name in unprocessedNodes) {
            const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];
            delete unprocessedNodes[layer.name];
            for (const nodeData of currentUnprocessedNodesForLayer) {
              processNode(layer, nodeData);
            }
          }
        }
      }
      const inputTensors = [];
      const outputTensors = [];
      const inputLayersFromConfig = config["inputLayers"];
      for (const layerData of inputLayersFromConfig) {
        const layerName = layerData[0];
        const nodeIndex = layerData[1];
        const tensorIndex = layerData[2];
        assert2(layerName in createdLayers);
        const layer = createdLayers[layerName];
        const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
        inputTensors.push(layerOutputTensors[tensorIndex]);
      }
      const outputLayersFromConfig = config["outputLayers"];
      for (const layerData of outputLayersFromConfig) {
        const layerName = layerData[0];
        const nodeIndex = layerData[1];
        const tensorIndex = layerData[2];
        assert2(layerName in createdLayers);
        const layer = createdLayers[layerName];
        const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
        outputTensors.push(layerOutputTensors[tensorIndex]);
      }
      return new cls({ inputs: inputTensors, outputs: outputTensors, name });
    }
    get stateful() {
      if (this._stateful) {
        throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
      }
      for (const layer of this.layers) {
        if (layer.stateful) {
          return true;
        }
      }
      return false;
    }
    resetStates() {
      tidy(() => {
        this.layers.forEach((layer) => {
          if (layer.stateful) {
            layer.resetStates();
          }
        });
      });
    }
  };

  // node_modules/@tensorflow/tfjs-layers/dist/engine/training_utils.js
  function standardizeSampleOrClassWeights(xWeight, outputNames, weightType) {
    const numOutputs = outputNames.length;
    if (xWeight == null || Array.isArray(xWeight) && xWeight.length === 0) {
      return outputNames.map((name) => null);
    }
    if (numOutputs === 1) {
      if (Array.isArray(xWeight) && xWeight.length === 1) {
        return xWeight;
      } else if (typeof xWeight === "object" && outputNames[0] in xWeight) {
        return [xWeight[outputNames[0]]];
      } else {
        return [xWeight];
      }
    }
    if (Array.isArray(xWeight)) {
      if (xWeight.length !== numOutputs) {
        throw new Error(`Provided ${weightType} is an array of ${xWeight.length} element(s), but the model has ${numOutputs} outputs. Make sure a set of weights is provided for each model output.`);
      }
      return xWeight;
    } else if (typeof xWeight === "object" && Object.keys(xWeight).length > 0 && typeof xWeight[Object.keys(xWeight)[0]] === "object") {
      const output = [];
      outputNames.forEach((outputName) => {
        if (outputName in xWeight) {
          output.push(xWeight[outputName]);
        } else {
          output.push(null);
        }
      });
      return output;
    } else {
      throw new Error(`The model has multiple (${numOutputs}) outputs, so ${weightType} must be either an array with ${numOutputs} elements or an object with ${outputNames} keys. Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`);
    }
  }
  function standardizeClassWeights(classWeight, outputNames) {
    return standardizeSampleOrClassWeights(classWeight, outputNames, "classWeight");
  }
  async function standardizeWeights(y, sampleWeight, classWeight, sampleWeightMode) {
    if (sampleWeight != null || sampleWeightMode != null) {
      throw new Error("Support sampleWeight is not implemented yet");
    }
    if (classWeight != null) {
      const yClasses = tidy(() => {
        if (y.shape.length === 1) {
          return clone5(y);
        } else if (y.shape.length === 2) {
          if (y.shape[1] > 1) {
            const axis = 1;
            return argMax(y, axis);
          } else if (y.shape[1] === 1) {
            return reshape(y, [y.shape[0]]);
          } else {
            throw new Error(`Encountered unexpected last-dimension size (${y.shape[1]}) during handling of class weights. The size is expected to be >= 1.`);
          }
        } else {
          throw new Error(`Unexpected rank of target (y) tensor (${y.rank}) during handling of class weights. The rank is expected to be 1 or 2.`);
        }
      });
      const yClassIndices = Array.from(await yClasses.data());
      dispose(yClasses);
      const classSampleWeight = [];
      yClassIndices.forEach((classIndex) => {
        if (classWeight[classIndex] == null) {
          throw new Error(`classWeight must contain all classes in the training data. The class ${classIndex} exists in the data but not in classWeight`);
        } else {
          classSampleWeight.push(classWeight[classIndex]);
        }
      });
      return tensor1d(classSampleWeight, "float32");
    } else {
      return null;
    }
  }
  function computeWeightedLoss(losses3, sampleWeights) {
    return mul4(losses3, sampleWeights);
  }

  // node_modules/@tensorflow/tfjs-layers/dist/engine/training_dataset.js
  var DEFAULT_VALIDATION_BATCH_SIZE = 32;
  function standardizeDataIteratorOutput(model2, iteratorOut) {
    let xs;
    let ys;
    const iteratorOutObj = iteratorOut;
    xs = iteratorOutObj["xs"];
    ys = iteratorOutObj["ys"];
    util_exports2.assert(xs != null && ys != null, () => `A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${iteratorOut}`);
    const flattenedXs = flattenTensorOrArrayOrMap("input", model2.inputNames, xs);
    const flattenedYs = flattenTensorOrArrayOrMap("output", model2.outputNames, ys);
    const batchSize = flattenedXs[0].shape[0];
    util_exports2.assert(flattenedXs.length === model2.inputs.length, () => `LayersModel has ${model2.inputs.length} inputs, but the dataset provides ${flattenedXs.length} inputs.  (Expected input keys: ${JSON.stringify(model2.inputNames)})`);
    util_exports2.assert(flattenedYs.length === model2.outputs.length, () => `LayersModel has ${model2.outputs.length} outputs, but the dataset provides ${flattenedYs.length} outputs.  (Expected output keys: ${JSON.stringify(model2.outputNames)})`);
    for (let xIndex = 0; xIndex < flattenedXs.length; xIndex++) {
      util_exports2.assert(flattenedXs[xIndex].shape[0] === batchSize, () => `Batch size mismatch: input ${model2.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; expected  ${batchSize} based on input ${model2.inputNames[0]}.`);
    }
    for (let yIndex = 0; yIndex < flattenedYs.length; yIndex++) {
      util_exports2.assert(flattenedYs[yIndex].shape[0] === batchSize, () => `Batch size mismatch: output ${model2.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; expected  ${batchSize} based on input ${model2.inputNames[0]}.`);
    }
    return { xs: flattenedXs, ys: flattenedYs };
  }
  function flattenTensorOrArrayOrMap(inputOrOutput, names, values2) {
    if (values2 instanceof Tensor) {
      return [values2];
    } else if (Array.isArray(values2)) {
      util_exports2.assert(values2.length === names.length, () => `Received an array of ${values2.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`);
      return values2;
    } else {
      const result = [];
      for (const name of names) {
        if (values2[name] == null) {
          throw new ValueError(`The feature data generated by the dataset lacks the required ${inputOrOutput} key '${name}'.`);
        }
        result.push(values2[name]);
      }
      return result;
    }
  }
  function standardizeTensorValidationData(data) {
    if (data.length === 3) {
      throw new NotImplementedError("Validation with sample weights is not implemented yet.");
    }
    return { xs: data[0], ys: data[1] };
  }
  async function fitDataset(model2, dataset, args) {
    const hasBatchesPerEpoch = args.batchesPerEpoch != null;
    util_exports2.assert(model2.optimizer != null, () => "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).");
    util_exports2.assert(args != null, () => `For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.`);
    util_exports2.assert(args.epochs != null && args.epochs > 0 && Number.isInteger(args.epochs), () => `For fitDataset(), config.epochs is expected to be a positive integer, but got ${args.epochs}`);
    util_exports2.assert(!hasBatchesPerEpoch || args.batchesPerEpoch > 0 && Number.isInteger(args.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${args.batchesPerEpoch}`);
    util_exports2.assert(args["validationSplit"] == null, () => "`validationSplit` is not supported by `fitDataset()`. Use validationData instead.");
    if (model2.isTraining) {
      throw new Error("Cannot start training because another fit() call is ongoing.");
    }
    model2.isTraining = true;
    try {
      const doValidation = args.validationData != null;
      let valXs;
      let valYs;
      if (doValidation) {
        if (isDatasetObject(args.validationData)) {
          util_exports2.assert(args.validationBatches == null || args.validationBatches > 0 && Number.isInteger(args.validationBatches), () => `For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${args.validationBatches}`);
        } else {
          const validationData = standardizeTensorValidationData(args.validationData);
          valXs = validationData.xs;
          valYs = validationData.ys;
        }
      }
      const trainFunction = model2.makeTrainFunction();
      const outLabels = model2.getDedupedMetricsNames();
      let callbackMetrics;
      if (doValidation) {
        callbackMetrics = outLabels.slice().concat(outLabels.map((n) => "val_" + n));
      } else {
        callbackMetrics = outLabels.slice();
      }
      const callbacks2 = standardizeCallbacks(args.callbacks, args.yieldEvery);
      const verbose = args.verbose == null ? 1 : args.verbose;
      const { callbackList, history } = configureCallbacks(callbacks2, verbose, args.epochs, null, null, getStepsPerEpoch(dataset, args), null, doValidation, callbackMetrics);
      callbackList.setModel(model2);
      model2.history = history;
      await callbackList.onTrainBegin();
      model2.stopTraining_ = false;
      let epoch = args.initialEpoch == null ? 0 : args.initialEpoch;
      let dataIterator = await dataset.iterator();
      while (epoch < args.epochs) {
        const epochLogs = {};
        await callbackList.onEpochBegin(epoch);
        let stepsDone = 0;
        let batchIndex = 0;
        if (!hasBatchesPerEpoch) {
          dataIterator = await dataset.iterator();
        }
        while (hasBatchesPerEpoch ? stepsDone < args.batchesPerEpoch : true) {
          const iteratorOut = await dataIterator.next();
          if (hasBatchesPerEpoch && iteratorOut.done) {
            console.warn(`You provided \`batchesPerEpoch\` as ${args.batchesPerEpoch}, but your dataset iterator ran out of data after ${stepsDone} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${args.batchesPerEpoch * args.epochs} batches). You may need to use the repeat() function when building your dataset.`);
            break;
          }
          if (iteratorOut.value != null) {
            const { xs, ys } = standardizeDataIteratorOutput(model2, iteratorOut.value);
            const batchLogs = {};
            batchLogs["batch"] = batchIndex;
            batchLogs["size"] = xs[0].shape[0];
            await callbackList.onBatchBegin(batchIndex, batchLogs);
            const sampleWeights = [];
            if (args.classWeight != null) {
              const standardClassWeights = standardizeClassWeights(args.classWeight, model2.outputNames);
              for (let i = 0; i < standardClassWeights.length; ++i) {
                sampleWeights.push(await standardizeWeights(ys[i], null, standardClassWeights[i]));
              }
            }
            const ins = xs.concat(ys).concat(sampleWeights);
            const outs = trainFunction(ins);
            dispose(ins);
            for (let i = 0; i < outLabels.length; ++i) {
              const label = outLabels[i];
              const out = outs[i];
              batchLogs[label] = out;
              keep(out);
            }
            await callbackList.onBatchEnd(batchIndex, batchLogs);
            disposeTensorsInLogs(batchLogs);
            batchIndex++;
            stepsDone++;
          }
          if (hasBatchesPerEpoch ? stepsDone >= args.batchesPerEpoch : iteratorOut.done) {
            if (doValidation) {
              let valOuts;
              if (isDatasetObject(args.validationData)) {
                valOuts = toList(await model2.evaluateDataset(args.validationData, { batches: args.validationBatches }));
              } else {
                valOuts = toList(model2.evaluate(valXs, valYs, {
                  batchSize: args.validationBatchSize == null ? DEFAULT_VALIDATION_BATCH_SIZE : args.validationBatchSize,
                  verbose: 0
                }));
              }
              for (let i = 0; i < model2.metricsNames.length; ++i) {
                epochLogs[`val_${model2.metricsNames[i]}`] = valOuts[i];
              }
            }
            break;
          }
          if (model2.stopTraining_) {
            break;
          }
        }
        await callbackList.onEpochEnd(epoch, epochLogs);
        epoch++;
        if (model2.stopTraining_) {
          break;
        }
      }
      await callbackList.onTrainEnd();
      await model2.history.syncData();
      return model2.history;
    } finally {
      model2.isTraining = false;
    }
  }
  function getStepsPerEpoch(dataset, args) {
    let stepsPerEpoch = null;
    if (args.batchesPerEpoch != null) {
      stepsPerEpoch = args.batchesPerEpoch;
    } else if (Number.isFinite(dataset.size)) {
      stepsPerEpoch = dataset.size;
    }
    return stepsPerEpoch;
  }
  function isDatasetObject(dataset) {
    return typeof dataset.iterator === "function";
  }
  function isLazyIteratorObject(iterator) {
    return typeof iterator.next === "function";
  }
  async function evaluateDataset(model2, dataset, args) {
    args = args || {};
    const hasBatches = args.batches != null;
    const f = model2.testFunction;
    let outs = [];
    if (args.verbose > 0) {
      throw new NotImplementedError("Verbose mode is not implemented yet.");
    }
    util_exports2.assert(!hasBatches || args.batches > 0 && Number.isInteger(args.batches), () => `Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(args.batches)}`);
    const dataIterator = isLazyIteratorObject(dataset) ? dataset : await dataset.iterator();
    let numExamples = 0;
    let batch = 0;
    while (hasBatches ? batch < args.batches : true) {
      const iteratorOut = await dataIterator.next();
      outs = tidy(() => {
        if (iteratorOut.value) {
          const { xs, ys } = standardizeDataIteratorOutput(model2, iteratorOut.value);
          const xsAndYs = xs.concat(ys);
          const batchOuts = tidy(() => f(xsAndYs));
          dispose(xsAndYs);
          if (batch === 0) {
            for (let i = 0; i < batchOuts.length; ++i) {
              outs.push(scalar(0));
            }
          }
          const batchSize = xsAndYs[0].shape[0];
          for (let i = 0; i < batchOuts.length; ++i) {
            const batchOut = batchOuts[i];
            const oldScalar = outs[i];
            outs[i] = tidy(() => add6(outs[i], mul4(batchSize, batchOut)));
            if (batch > 0) {
              dispose(oldScalar);
            }
          }
          dispose(batchOuts);
          numExamples += batchSize;
          ++batch;
        }
        return outs;
      });
      if (iteratorOut.done) {
        if (hasBatches) {
          console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${args.batches} batches). You may need to use the repeat() function when building your dataset.`);
        }
        break;
      }
    }
    for (let i = 0; i < outs.length; ++i) {
      const oldScalar = outs[i];
      outs[i] = div3(outs[i], numExamples);
      dispose(oldScalar);
    }
    return singletonOrArray(outs);
  }

  // node_modules/@tensorflow/tfjs-layers/dist/engine/training_tensors.js
  function checkBatchSize(batchSize) {
    util_exports2.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);
  }
  function sliceArrays(arrays, start, stop2) {
    if (arrays == null) {
      return [null];
    } else if (Array.isArray(arrays)) {
      return arrays.map((array2) => sliceAlongFirstAxis(array2, start, stop2 - start));
    } else {
      return sliceAlongFirstAxis(arrays, start, stop2 - start);
    }
  }
  function sliceArraysByIndices(arrays, indices) {
    return tidy(() => {
      if (arrays == null) {
        return null;
      } else if (Array.isArray(arrays)) {
        return arrays.map((array2) => sliceArraysByIndices(array2, indices));
      } else {
        return gather2(arrays, indices.dtype === "int32" ? indices : cast(indices, "int32"));
      }
    });
  }
  function makeBatches(size3, batchSize) {
    const output = [];
    let batchStart = 0;
    let batchEnd = null;
    while (batchStart < size3) {
      batchEnd = batchStart + batchSize;
      if (batchEnd >= size3) {
        batchEnd = size3;
      }
      output.push([batchStart, batchEnd]);
      batchStart = batchEnd;
    }
    return output;
  }
  async function fitLoop(model2, f, ins, outLabels, batchSize, epochs, verbose, callbacks2, valF, valIns, shuffle2, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
    if (batchSize == null) {
      batchSize = 32;
    }
    if (epochs == null) {
      epochs = 1;
    }
    if (shuffle2 == null) {
      shuffle2 = true;
    }
    if (initialEpoch == null) {
      initialEpoch = 0;
    }
    let doValidation = false;
    if (valF != null && valIns != null) {
      doValidation = true;
    }
    if (validationSteps != null) {
      doValidation = true;
      if (stepsPerEpoch == null) {
        throw new ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
      }
    }
    const numTrainSamples = model2.checkNumSamples(ins, batchSize, stepsPerEpoch, "steps_per_epoch");
    let indexArray;
    if (numTrainSamples != null) {
      indexArray = range2(0, numTrainSamples);
    }
    if (verbose == null) {
      verbose = 1;
    }
    const { callbackList, history } = configureCallbacks(callbacks2, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics);
    callbackList.setModel(model2);
    model2.history = history;
    await callbackList.onTrainBegin();
    model2.stopTraining_ = false;
    for (let epoch = initialEpoch; epoch < epochs; ++epoch) {
      await callbackList.onEpochBegin(epoch);
      const epochLogs = {};
      if (stepsPerEpoch != null) {
        throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");
      } else {
        if (shuffle2 === "batch") {
          throw new NotImplementedError("batch shuffling is not implemneted yet");
        } else if (shuffle2) {
          util_exports2.shuffle(indexArray);
        }
        const epochIndexArray1D = tensor1d(indexArray);
        const batches = makeBatches(numTrainSamples, batchSize);
        for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
          const batchLogs = {};
          await callbackList.onBatchBegin(batchIndex, batchLogs);
          tidy(() => {
            const batchStart = batches[batchIndex][0];
            const batchEnd = batches[batchIndex][1];
            const batchIds = sliceAlongFirstAxis(epochIndexArray1D, batchStart, batchEnd - batchStart);
            batchLogs["batch"] = batchIndex;
            batchLogs["size"] = batchEnd - batchStart;
            const insBatch = sliceArraysByIndices(ins, batchIds);
            const outs = f(insBatch);
            for (let i = 0; i < outLabels.length; ++i) {
              const label = outLabels[i];
              const out = outs[i];
              batchLogs[label] = out;
              keep(out);
            }
            if (batchIndex === batches.length - 1) {
              if (doValidation) {
                const valOuts = model2.testLoop(valF, valIns, batchSize);
                for (let i = 0; i < outLabels.length; ++i) {
                  const label = outLabels[i];
                  const out = valOuts[i];
                  keep(out);
                  epochLogs["val_" + label] = out;
                }
              }
            }
          });
          await callbackList.onBatchEnd(batchIndex, batchLogs);
          disposeTensorsInLogs(batchLogs);
          if (model2.stopTraining_) {
            break;
          }
        }
        epochIndexArray1D.dispose();
      }
      await callbackList.onEpochEnd(epoch, epochLogs);
      if (model2.stopTraining_) {
        break;
      }
    }
    await callbackList.onTrainEnd();
    await model2.history.syncData();
    return model2.history;
  }
  async function fitTensors(model2, x, y, args = {}) {
    if (model2.isTraining) {
      throw new Error("Cannot start training because another fit() call is ongoing.");
    }
    model2.isTraining = true;
    let inputs;
    let targets;
    let inputValX;
    let inputValY;
    let valX;
    let valY;
    let sampleWeights;
    try {
      const batchSize = args.batchSize == null ? 32 : args.batchSize;
      checkBatchSize(batchSize);
      const checkBatchAxis = false;
      const standardizedOuts = await model2.standardizeUserData(x, y, args.sampleWeight, args.classWeight, checkBatchAxis, batchSize);
      inputs = standardizedOuts[0];
      targets = standardizedOuts[1];
      sampleWeights = standardizedOuts[2];
      let doValidation = false;
      let valIns;
      if (args.validationData != null && args.validationData.length > 0) {
        doValidation = true;
        if (args.validationData.length === 2) {
          inputValX = args.validationData[0];
          inputValY = args.validationData[1];
        } else if (args.validationData.length === 3) {
          throw new NotImplementedError("validationData including sample weights is not supported yet.");
        } else {
          throw new ValueError(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${args.validationData} is invalid.`);
        }
        const checkBatchAxis2 = true;
        const valStandardized = await model2.standardizeUserData(inputValX, inputValY, null, null, checkBatchAxis2, batchSize);
        valX = valStandardized[0];
        valY = valStandardized[1];
        valIns = valX.concat(valY);
      } else if (args.validationSplit != null && args.validationSplit > 0 && args.validationSplit < 1) {
        doValidation = true;
        const splitAt = Math.floor(inputs[0].shape[0] * (1 - args.validationSplit));
        const originalBatchSize = inputs[0].shape[0];
        valX = sliceArrays(inputs, splitAt, originalBatchSize);
        inputs = sliceArrays(inputs, 0, splitAt);
        valY = sliceArrays(targets, splitAt, originalBatchSize);
        targets = sliceArrays(targets, 0, splitAt);
        valIns = valX.concat(valY);
      } else if (args.validationSteps != null) {
        doValidation = true;
      }
      const ins = inputs.concat(targets).concat(sampleWeights);
      model2.checkTrainableWeightsConsistency();
      const trainFunction = model2.makeTrainFunction();
      const outLabels = model2.getDedupedMetricsNames();
      let valFunction;
      let callbackMetrics;
      if (doValidation) {
        model2.makeTestFunction();
        valFunction = model2.testFunction;
        callbackMetrics = outLabels.slice().concat(outLabels.map((n) => "val_" + n));
      } else {
        valFunction = null;
        valIns = [];
        callbackMetrics = outLabels.slice();
      }
      const callbacks2 = standardizeCallbacks(args.callbacks, args.yieldEvery);
      const out = await fitLoop(model2, trainFunction, ins, outLabels, batchSize, args.epochs, args.verbose, callbacks2, valFunction, valIns, args.shuffle, callbackMetrics, args.initialEpoch, null, null);
      return out;
    } finally {
      model2.isTraining = false;
      disposeNewTensors(inputs, x);
      disposeNewTensors(targets, y);
      disposeNewTensors(valX, inputValX);
      disposeNewTensors(valY, inputValY);
      if (sampleWeights != null) {
        dispose(sampleWeights);
      }
    }
  }
  function ensureTensorsRank2OrHigher(tensors) {
    const outs = [];
    if (tensors instanceof Tensor) {
      tensors = [tensors];
    }
    for (let i = 0; i < tensors.length; ++i) {
      const tensor2 = tensors[i];
      if (tensor2.rank === 1) {
        outs.push(expandDims2(tensor2, 1));
      } else if (tensor2.rank === 0) {
        throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
      } else {
        outs.push(tensor2);
      }
    }
    return outs;
  }
  function disposeNewTensors(tensors, refTensors) {
    if (tensors == null) {
      return;
    }
    const oldTensorIds = [];
    if (refTensors instanceof Tensor) {
      oldTensorIds.push(refTensors.id);
    } else if (Array.isArray(refTensors)) {
      refTensors.forEach((t) => oldTensorIds.push(t.id));
    } else if (refTensors != null) {
      for (const name in refTensors) {
        const oldTensor = refTensors[name];
        oldTensorIds.push(oldTensor.id);
      }
    }
    const tensorsToDispose = [];
    if (tensors instanceof Tensor) {
      if (oldTensorIds.indexOf(tensors.id) === -1) {
        tensorsToDispose.push(tensors);
      }
    } else if (Array.isArray(tensors)) {
      tensors.forEach((t) => {
        if (oldTensorIds.indexOf(t.id) === -1) {
          tensorsToDispose.push(t);
        }
      });
    } else if (tensors != null) {
      for (const name in tensors) {
        const tensor2 = tensors[name];
        if (oldTensorIds.indexOf(tensor2.id) === -1) {
          tensorsToDispose.push(tensor2);
        }
      }
    }
    tensorsToDispose.forEach((t) => {
      if (!t.isDisposed) {
        t.dispose();
      }
    });
  }

  // node_modules/@tensorflow/tfjs-layers/dist/engine/training.js
  function isDataTensor(x) {
    return x instanceof Tensor;
  }
  function isDataArray(x) {
    return Array.isArray(x);
  }
  function isDataDict(x) {
    return !isDataTensor(x) && !isDataArray(x);
  }
  function standardizeInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
    if (names == null || names.length === 0) {
      if (data != null) {
        let gotUnexpectedData = false;
        if (isDataArray(data) && data.length > 0) {
          gotUnexpectedData = true;
        } else if (isDataDict(data)) {
          for (const key in data) {
            if (data.hasOwnProperty(key)) {
              gotUnexpectedData = true;
              break;
            }
          }
        } else {
          gotUnexpectedData = true;
        }
        if (gotUnexpectedData) {
          throw new ValueError(`Error when checking model ${exceptionPrefix} expected no data, but got ${data}`);
        }
      }
      return [];
    }
    if (data == null) {
      return names.map((name) => null);
    }
    let arrays;
    if (isDataDict(data)) {
      data = data;
      arrays = [];
      for (const name of names) {
        if (data[name] == null) {
          throw new ValueError(`No data provided for "${name}". Need data for each key in: ${names}`);
        }
        arrays.push(data[name]);
      }
    } else if (isDataArray(data)) {
      data = data;
      if (data.length !== names.length) {
        throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${names.length} Tensor(s), but instead got the following list of Tensor(s): ${data}`);
      }
      arrays = data;
    } else {
      data = data;
      if (names.length > 1) {
        throw new ValueError(`The model ${exceptionPrefix} expects ${names.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${data.shape}`);
      }
      arrays = [data];
    }
    arrays = ensureTensorsRank2OrHigher(arrays);
    if (shapes != null) {
      for (let i = 0; i < names.length; ++i) {
        if (shapes[i] == null) {
          continue;
        }
        const array2 = arrays[i];
        if (array2.shape.length !== shapes[i].length) {
          throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have ${shapes[i].length} dimension(s). but got array with shape ${array2.shape}`);
        }
        for (let j = 0; j < shapes[i].length; ++j) {
          if (j === 0 && !checkBatchAxis) {
            continue;
          }
          const dim = array2.shape[j];
          const refDim = shapes[i][j];
          if (refDim != null && refDim >= 0 && dim !== refDim) {
            throw new ValueError(`${exceptionPrefix} expected a batch of elements where each example has shape [${shapes[i].slice(1, shapes[i].length)}] (i.e.,tensor shape [*,${shapes[i].slice(1, shapes[i].length)}]) but the ${exceptionPrefix} received an input with ${array2.shape[0]} examples, each with shape [${array2.shape.slice(1, array2.shape.length)}] (tensor shape [${array2.shape}])`);
          }
        }
      }
    }
    return arrays;
  }
  function checkArrayLengths(inputs, targets, weights) {
    const setX = unique2(inputs.map((input2) => input2.shape[0]));
    setX.sort();
    const setY = unique2(targets.map((target) => target.shape[0]));
    setY.sort();
    if (setX.length > 1) {
      throw new ValueError(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(inputs.map((input2) => input2.shape))}`);
    }
    if (setY.length > 1) {
      throw new ValueError(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(targets.map((target) => target.shape))}`);
    }
    if (setX.length > 0 && setY.length > 0 && !util_exports2.arraysEqual(setX, setY)) {
      throw new ValueError(`Input Tensors should have the same number of samples as target Tensors. Found ${setX[0]} input sample(s) and ${setY[0]} target sample(s).`);
    }
  }
  function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
    const keyLosses = [
      meanSquaredError,
      binaryCrossentropy,
      categoricalCrossentropy
    ];
    for (let i = 0; i < targets.length; ++i) {
      const y = targets[i];
      const loss = lossFns[i];
      const shape = outputShapes[i];
      if (loss == null) {
        continue;
      }
      if (loss === categoricalCrossentropy) {
        if (y.shape[y.shape.length - 1] === 1) {
          throw new ValueError(`You are passing a target array of shape ${y.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);
        }
      }
      if (keyLosses.indexOf(loss) !== -1) {
        const slicedYShape = y.shape.slice(1);
        const slicedShape = shape.slice(1);
        for (let j = 0; j < slicedYShape.length; ++j) {
          const targetDim = slicedYShape[j];
          const outDim = slicedShape[j];
          if (outDim != null && targetDim !== outDim) {
            throw new ValueError(`A target Tensor with shape ${y.shape} was passed for an output of shape ${shape}, while using a loss function that expects targets to have the same shape as the output.`);
          }
        }
      }
    }
  }
  function checkInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
    let arrays;
    if (Array.isArray(data)) {
      if (data.length !== names.length) {
        throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${names.length} Tensor(s), but instead got ${data.length} Tensors(s).`);
      }
      arrays = data;
    } else {
      if (names.length > 1) {
        throw new ValueError(`The model expects ${names.length} ${exceptionPrefix} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(data.shape)}.`);
      }
      arrays = [data];
    }
    if (shapes != null) {
      for (let i = 0; i < names.length; ++i) {
        if (shapes[i] == null) {
          continue;
        }
        const array2 = arrays[i];
        if (array2.shape.length !== shapes[i].length) {
          throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have ${shapes[i].length} dimension(s), but got array with shape ${JSON.stringify(array2.shape)}`);
        }
        for (let j = 0; j < shapes[i].length; ++j) {
          if (j === 0 && !checkBatchAxis) {
            continue;
          }
          const dim = array2.shape[j];
          const refDim = shapes[i][j];
          if (refDim != null) {
            if (refDim !== dim) {
              throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} to have shape ${JSON.stringify(shapes[i])} but got array with shape ${JSON.stringify(array2.shape)}.`);
            }
          }
        }
      }
    }
  }
  function collectMetrics(metrics2, outputNames) {
    if (metrics2 == null || Array.isArray(metrics2) && metrics2.length === 0) {
      return outputNames.map((name) => []);
    }
    let wrappedMetrics;
    if (typeof metrics2 === "string" || typeof metrics2 === "function") {
      wrappedMetrics = [metrics2];
    } else if (Array.isArray(metrics2) || typeof metrics2 === "object") {
      wrappedMetrics = metrics2;
    } else {
      throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${metrics2}`);
    }
    if (Array.isArray(wrappedMetrics)) {
      return outputNames.map((name) => wrappedMetrics);
    } else {
      const nestedMetrics = [];
      for (const name of outputNames) {
        let outputMetrics = wrappedMetrics.hasOwnProperty(name) ? wrappedMetrics[name] : [];
        if (!Array.isArray(outputMetrics)) {
          outputMetrics = [outputMetrics];
        }
        nestedMetrics.push(outputMetrics);
      }
      return nestedMetrics;
    }
  }
  var LAYERS_MODEL_FORMAT_NAME = "layers-model";
  var LayersModel = class extends Container3 {
    constructor(args) {
      super(args);
      this.isTraining = false;
    }
    summary(lineLength, positions, printFn = console.log) {
      if (!this.built) {
        throw new ValueError(`This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).`);
      }
      printSummary(this, lineLength, positions, printFn);
    }
    compile(args) {
      if (args.loss == null) {
        args.loss = [];
      }
      this.loss = args.loss;
      if (typeof args.optimizer === "string") {
        this.optimizer_ = getOptimizer(args.optimizer);
        this.isOptimizerOwned = true;
      } else {
        if (!(args.optimizer instanceof Optimizer)) {
          throw new ValueError(`User-defined optimizer must be an instance of tf.Optimizer.`);
        }
        this.optimizer_ = args.optimizer;
        this.isOptimizerOwned = false;
      }
      let lossFunctions = [];
      if (!Array.isArray(args.loss) && typeof args.loss !== "string" && typeof args.loss !== "function") {
        args.loss = args.loss;
        for (const name in args.loss) {
          if (this.outputNames.indexOf(name) === -1) {
            throw new ValueError(`Unknown entry in loss dictionary: "${name}". Only expected the following keys: ${this.outputNames}`);
          }
        }
        for (const name of this.outputNames) {
          if (args.loss[name] == null) {
            console.warn(`Output "${name}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${name} during training`);
          }
          lossFunctions.push(get2(args.loss[name]));
        }
      } else if (Array.isArray(args.loss)) {
        if (args.loss.length !== this.outputs.length) {
          throw new ValueError(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${args.loss}.`);
        }
        const theLosses = args.loss;
        lossFunctions = theLosses.map((l) => get2(l));
      } else {
        const lossFunction = get2(args.loss);
        this.outputs.forEach((_6) => {
          lossFunctions.push(lossFunction);
        });
      }
      this.lossFunctions = lossFunctions;
      this.feedOutputNames = [];
      this.feedOutputShapes = [];
      this.feedLossFns = [];
      for (let i = 0; i < this.outputs.length; ++i) {
        const shape = this.internalOutputShapes[i];
        const name = this.outputNames[i];
        this.feedOutputNames.push(name);
        this.feedOutputShapes.push(shape);
        this.feedLossFns.push(this.lossFunctions[i]);
      }
      const skipTargetIndices = [];
      this.metrics = args.metrics;
      this.metricsNames = ["loss"];
      this.metricsTensors = [];
      nameScope("loss", () => {
        for (let i = 0; i < this.outputs.length; ++i) {
          if (skipTargetIndices.indexOf(i) !== -1) {
            continue;
          }
          const weightedLoss = this.lossFunctions[i];
          if (this.outputs.length > 1) {
            this.metricsTensors.push([weightedLoss, i]);
            this.metricsNames.push(this.outputNames[i] + "_loss");
          }
        }
      });
      const nestedMetrics = collectMetrics(args.metrics, this.outputNames);
      const appendMetric = (outputIndex, metricName, metricTensor) => {
        if (this.outputNames.length > 1) {
          metricName = this.outputNames[outputIndex] + "_" + metricName;
        }
        this.metricsNames.push(metricName);
        this.metricsTensors.push([metricTensor, outputIndex]);
      };
      nameScope("metric", () => {
        for (let i = 0; i < this.outputs.length; ++i) {
          if (skipTargetIndices.indexOf(i) !== -1) {
            continue;
          }
          const outputMetrics = nestedMetrics[i];
          const handleMetrics = (metrics2) => {
            const metricNamePrefix = "";
            let metricName;
            let accFn;
            let weightedMetricFn;
            for (const metric of metrics2) {
              if (typeof metric === "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(metric) !== -1) {
                const outputShape = this.internalOutputShapes[i];
                if (outputShape[outputShape.length - 1] === 1 || this.lossFunctions[i] === binaryCrossentropy) {
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    accFn = binaryAccuracy;
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    accFn = binaryCrossentropy2;
                  }
                } else if (this.lossFunctions[i] === sparseCategoricalCrossentropy) {
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    accFn = sparseCategoricalAccuracy;
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    accFn = sparseCategoricalCrossentropy2;
                  }
                } else {
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    accFn = categoricalAccuracy;
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    accFn = categoricalCrossentropy2;
                  }
                }
                let suffix;
                if (["accuracy", "acc"].indexOf(metric) !== -1) {
                  suffix = "acc";
                } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                  suffix = "ce";
                }
                weightedMetricFn = accFn;
                metricName = metricNamePrefix + suffix;
              } else {
                const metricFn = get3(metric);
                weightedMetricFn = metricFn;
                metricName = metricNamePrefix + getLossOrMetricName(metric);
              }
              let metricResult;
              nameScope(metricName, () => {
                metricResult = weightedMetricFn;
              });
              appendMetric(i, metricName, metricResult);
            }
          };
          handleMetrics(outputMetrics);
        }
      });
      this.collectedTrainableWeights = this.trainableWeights;
    }
    checkTrainableWeightsConsistency() {
      if (this.collectedTrainableWeights == null) {
        return;
      }
      if (this.trainableWeights.length !== this.collectedTrainableWeights.length) {
        console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?");
      }
    }
    evaluate(x, y, args = {}) {
      const batchSize = args.batchSize == null ? 32 : args.batchSize;
      checkBatchSize(batchSize);
      const checkBatchAxis = true;
      const standardizedOuts = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);
      try {
        const ins = standardizedOuts[0].concat(standardizedOuts[1]);
        this.makeTestFunction();
        const f = this.testFunction;
        const testOuts = this.testLoop(f, ins, batchSize, args.verbose, args.steps);
        return singletonOrArray(testOuts);
      } finally {
        disposeNewTensors(standardizedOuts[0], x);
        disposeNewTensors(standardizedOuts[1], y);
      }
    }
    async evaluateDataset(dataset, args) {
      this.makeTestFunction();
      return evaluateDataset(this, dataset, args);
    }
    checkNumSamples(ins, batchSize, steps, stepsName = "steps") {
      let numSamples;
      if (steps != null) {
        numSamples = null;
        if (batchSize != null) {
          throw new ValueError(`If ${stepsName} is set, batchSize must be null or undefined.Got batchSize = ${batchSize}`);
        }
      } else if (ins != null) {
        if (Array.isArray(ins)) {
          numSamples = ins[0].shape[0];
        } else {
          numSamples = ins.shape[0];
        }
      } else {
        throw new ValueError(`Either the input data should have a defined shape, or ${stepsName} shoud be specified.`);
      }
      return numSamples;
    }
    execute(inputs, outputs) {
      if (Array.isArray(outputs) && outputs.length === 0) {
        throw new ValueError("`outputs` is an empty Array, which is not allowed.");
      }
      const outputsIsArray = Array.isArray(outputs);
      const outputNames = outputsIsArray ? outputs : [outputs];
      const outputSymbolicTensors = this.retrieveSymbolicTensors(outputNames);
      const feedDict = new FeedDict();
      if (inputs instanceof Tensor) {
        inputs = [inputs];
      }
      if (Array.isArray(inputs)) {
        if (inputs.length !== this.inputs.length) {
          throw new ValueError(`The number of inputs provided (${inputs.length}) does not match the number of inputs of this model (${this.inputs.length}).`);
        }
        for (let i = 0; i < this.inputs.length; ++i) {
          feedDict.add(this.inputs[i], inputs[i]);
        }
      } else {
        for (const input2 of this.inputs) {
          const tensorValue = inputs[input2.name];
          if (tensorValue == null) {
            throw new ValueError(`No value is provided for the model's input ${input2.name}`);
          }
          feedDict.add(input2, tensorValue);
        }
      }
      const executeOutputs = execute(outputSymbolicTensors, feedDict);
      return outputsIsArray ? executeOutputs : executeOutputs[0];
    }
    retrieveSymbolicTensors(symbolicTensorNames) {
      const outputSymbolicTensors = pyListRepeat(null, symbolicTensorNames.length);
      let outputsRemaining = symbolicTensorNames.length;
      for (const layer of this.layers) {
        const layerOutputs = Array.isArray(layer.output) ? layer.output : [layer.output];
        const layerOutputNames = layerOutputs.map((output) => output.name);
        for (let i = 0; i < symbolicTensorNames.length; ++i) {
          const index = layerOutputNames.indexOf(symbolicTensorNames[i]);
          if (index !== -1) {
            outputSymbolicTensors[i] = layerOutputs[index];
            outputsRemaining--;
          }
          if (outputsRemaining === 0) {
            break;
          }
        }
        if (outputsRemaining === 0) {
          break;
        }
      }
      if (outputsRemaining > 0) {
        const remainingNames = [];
        outputSymbolicTensors.forEach((tensor2, i) => {
          if (tensor2 == null) {
            remainingNames.push(symbolicTensorNames[i]);
          }
        });
        throw new ValueError(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(remainingNames)}`);
      }
      return outputSymbolicTensors;
    }
    predictLoop(ins, batchSize = 32, verbose = false) {
      return tidy(() => {
        const numSamples = this.checkNumSamples(ins);
        if (verbose) {
          throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");
        }
        const batches = makeBatches(numSamples, batchSize);
        const outsBatches = this.outputs.map((output) => []);
        for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
          const batchOuts = tidy(() => {
            const batchStart = batches[batchIndex][0];
            const batchEnd = batches[batchIndex][1];
            const insBatch = sliceArrays(ins, batchStart, batchEnd);
            const feeds = [];
            if (Array.isArray(insBatch)) {
              for (let i = 0; i < insBatch.length; ++i) {
                feeds.push({ key: this.inputs[i], value: insBatch[i] });
              }
            } else {
              feeds.push({ key: this.inputs[0], value: insBatch });
            }
            const feedDict = new FeedDict(feeds);
            return execute(this.outputs, feedDict);
          });
          batchOuts.forEach((batchOut, i) => outsBatches[i].push(batchOut));
        }
        return singletonOrArray(outsBatches.map((batches2) => concat(batches2, 0)));
      });
    }
    predict(x, args = {}) {
      const xsRank2OrHigher = ensureTensorsRank2OrHigher(x);
      checkInputData(xsRank2OrHigher, this.inputNames, this.feedInputShapes, false);
      try {
        const batchSize = args.batchSize == null ? 32 : args.batchSize;
        checkBatchSize(batchSize);
        return this.predictLoop(xsRank2OrHigher, batchSize);
      } finally {
        disposeNewTensors(xsRank2OrHigher, x);
      }
    }
    predictOnBatch(x) {
      checkInputData(x, this.inputNames, this.feedInputShapes, true);
      const batchSize = (Array.isArray(x) ? x[0] : x).shape[0];
      return this.predictLoop(x, batchSize);
    }
    standardizeUserDataXY(x, y, checkBatchAxis = true, batchSize) {
      if (this.optimizer_ == null) {
        throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
      }
      const outputShapes = [];
      for (let i = 0; i < this.feedOutputShapes.length; ++i) {
        const outputShape = this.feedOutputShapes[i];
        const lossFn = this.feedLossFns[i];
        if (lossFn === sparseCategoricalCrossentropy) {
          outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
        } else {
          outputShapes.push(outputShape);
        }
      }
      x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, "input");
      y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, "target");
      checkArrayLengths(x, y, null);
      checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
      if (this.stateful && batchSize != null && batchSize > 0) {
        if (x[0].shape[0] % batchSize !== 0) {
          throw new ValueError(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${batchSize}. Found: ${x[0].shape[0]} sample(s).`);
        }
      }
      return [x, y];
    }
    async standardizeUserData(x, y, sampleWeight, classWeight, checkBatchAxis = true, batchSize) {
      const [standardXs, standardYs] = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);
      if (sampleWeight != null) {
        throw new Error("sample weight is not supported yet.");
      }
      let standardSampleWeights = null;
      if (classWeight != null) {
        const classWeights = standardizeClassWeights(classWeight, this.outputNames);
        standardSampleWeights = [];
        for (let i = 0; i < classWeights.length; ++i) {
          standardSampleWeights.push(await standardizeWeights(standardYs[i], null, classWeights[i]));
        }
      }
      return [standardXs, standardYs, standardSampleWeights];
    }
    testLoop(f, ins, batchSize, verbose = 0, steps) {
      return tidy(() => {
        const numSamples = this.checkNumSamples(ins, batchSize, steps, "steps");
        const outs = [];
        if (verbose > 0) {
          throw new NotImplementedError("Verbose mode is not implemented yet.");
        }
        if (steps != null) {
          throw new NotImplementedError("steps mode in testLoop() is not implemented yet");
        } else {
          const batches = makeBatches(numSamples, batchSize);
          const indexArray = tensor1d(range2(0, numSamples));
          for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {
            const batchStart = batches[batchIndex][0];
            const batchEnd = batches[batchIndex][1];
            const batchIds = sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
            const insBatch = sliceArraysByIndices(ins, batchIds);
            const batchOuts = f(insBatch);
            if (batchIndex === 0) {
              for (let i = 0; i < batchOuts.length; ++i) {
                outs.push(scalar(0));
              }
            }
            for (let i = 0; i < batchOuts.length; ++i) {
              const batchOut = batchOuts[i];
              outs[i] = add6(outs[i], mul4(batchEnd - batchStart, batchOut));
            }
          }
          for (let i = 0; i < outs.length; ++i) {
            outs[i] = div3(outs[i], numSamples);
          }
        }
        return outs;
      });
    }
    getDedupedMetricsNames() {
      const outLabels = this.metricsNames;
      const dedupedOutLabels = [];
      for (let i = 0; i < outLabels.length; ++i) {
        const label = outLabels[i];
        let newLabel = label;
        if (count(outLabels, label) > 1) {
          const dupIndex = count(outLabels.slice(0, i), label);
          newLabel += `_${dupIndex}`;
        }
        dedupedOutLabels.push(newLabel);
      }
      return dedupedOutLabels;
    }
    makeTrainFunction() {
      return (data) => {
        const lossValues = [];
        const inputs = data.slice(0, this.inputs.length);
        const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);
        const sampleWeights = data.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2);
        const metricsValues = [];
        const totalLossFunction = () => {
          const feeds = [];
          for (let i = 0; i < this.inputs.length; ++i) {
            feeds.push({ key: this.inputs[i], value: inputs[i] });
          }
          const feedDict = new FeedDict(feeds);
          const outputs = execute(this.outputs, feedDict, { "training": true });
          let totalLoss;
          for (let i = 0; i < this.lossFunctions.length; ++i) {
            const lossFunction = this.lossFunctions[i];
            let loss = lossFunction(targets[i], outputs[i]);
            if (sampleWeights[i] != null) {
              loss = computeWeightedLoss(loss, sampleWeights[i]);
            }
            const meanLoss = mean(loss);
            lossValues.push(meanLoss);
            if (i === 0) {
              totalLoss = loss;
            } else {
              totalLoss = add6(totalLoss, loss);
            }
          }
          for (let i = 0; i < this.metricsTensors.length; ++i) {
            let weightedMetric;
            if (this.outputs.length > 1 && i < this.outputs.length) {
              weightedMetric = lossValues[i];
            } else {
              const metric = this.metricsTensors[i][0];
              const outputIndex = this.metricsTensors[i][1];
              weightedMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
            }
            keep(weightedMetric);
            metricsValues.push(weightedMetric);
          }
          totalLoss = mean(totalLoss);
          this.calculateLosses().forEach((regularizerLoss) => {
            totalLoss = add6(totalLoss, regularizerLoss);
          });
          return totalLoss;
        };
        const variables = this.collectedTrainableWeights.map((param) => param.read());
        const returnCost = true;
        const totalLossValue = this.optimizer_.minimize(totalLossFunction, returnCost, variables);
        return [totalLossValue].concat(metricsValues);
      };
    }
    makeTestFunction() {
      this.testFunction = (data) => {
        return tidy(() => {
          const valOutputs = [];
          let totalLoss;
          const inputs = data.slice(0, this.inputs.length);
          const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);
          const feeds = [];
          for (let i = 0; i < this.inputs.length; ++i) {
            feeds.push({ key: this.inputs[i], value: inputs[i] });
          }
          const feedDict = new FeedDict(feeds);
          const outputs = execute(this.outputs, feedDict);
          for (let i = 0; i < this.lossFunctions.length; ++i) {
            const lossFunction = this.lossFunctions[i];
            const loss = mean(lossFunction(targets[i], outputs[i]));
            if (i === 0) {
              totalLoss = loss;
            } else {
              totalLoss = add6(totalLoss, loss);
            }
            valOutputs.push(totalLoss);
          }
          for (let i = 0; i < this.metricsTensors.length; ++i) {
            const metric = this.metricsTensors[i][0];
            const outputIndex = this.metricsTensors[i][1];
            const meanMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
            valOutputs.push(meanMetric);
          }
          return valOutputs;
        });
      };
    }
    async fit(x, y, args = {}) {
      return fitTensors(this, x, y, args);
    }
    async fitDataset(dataset, args) {
      return fitDataset(this, dataset, args);
    }
    async trainOnBatch(x, y) {
      const standardizeOut = await this.standardizeUserData(x, y);
      const inputs = standardizeOut[0];
      const targets = standardizeOut[1];
      const trainFunction = this.makeTrainFunction();
      const losses3 = trainFunction(inputs.concat(targets));
      const lossValues = [];
      for (const loss of losses3) {
        const v = await loss.data();
        lossValues.push(v[0]);
      }
      dispose(losses3);
      return singletonOrArray(lossValues);
    }
    getNamedWeights(config) {
      const namedWeights = [];
      const trainableOnly = config != null && config.trainableOnly;
      const weights = trainableOnly ? this.trainableWeights : this.weights;
      const weightValues = this.getWeights(trainableOnly);
      for (let i = 0; i < weights.length; ++i) {
        if (trainableOnly && !weights[i].trainable) {
          continue;
        }
        namedWeights.push({ name: weights[i].originalName, tensor: weightValues[i] });
      }
      return namedWeights;
    }
    set stopTraining(stop2) {
      this.stopTraining_ = stop2;
    }
    get stopTraining() {
      return this.stopTraining_;
    }
    get optimizer() {
      return this.optimizer_;
    }
    set optimizer(optimizer) {
      if (this.optimizer_ !== optimizer) {
        this.optimizer_ = optimizer;
        this.isOptimizerOwned = false;
      }
    }
    dispose() {
      const result = super.dispose();
      if (result.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
        const numTensorsBeforeOptmizerDisposal = memory().numTensors;
        this.optimizer_.dispose();
        result.numDisposedVariables += numTensorsBeforeOptmizerDisposal - memory().numTensors;
      }
      return result;
    }
    getLossIdentifiers() {
      let lossNames;
      if (typeof this.loss === "string") {
        lossNames = toSnakeCase(this.loss);
      } else if (Array.isArray(this.loss)) {
        for (const loss of this.loss) {
          if (typeof loss !== "string") {
            throw new Error("Serialization of non-string loss is not supported.");
          }
        }
        lossNames = this.loss.map((name) => toSnakeCase(name));
      } else {
        const outputNames = Object.keys(this.loss);
        lossNames = {};
        const losses3 = this.loss;
        for (const outputName of outputNames) {
          if (typeof losses3[outputName] === "string") {
            lossNames[outputName] = toSnakeCase(losses3[outputName]);
          } else {
            throw new Error("Serialization of non-string loss is not supported.");
          }
        }
      }
      return lossNames;
    }
    getMetricIdentifiers() {
      if (typeof this.metrics === "string" || typeof this.metrics === "function") {
        return [toSnakeCase(getLossOrMetricName(this.metrics))];
      } else if (Array.isArray(this.metrics)) {
        return this.metrics.map((metric) => toSnakeCase(getLossOrMetricName(metric)));
      } else {
        const metricsIdentifiers = {};
        for (const key in this.metrics) {
          metricsIdentifiers[key] = toSnakeCase(getLossOrMetricName(this.metrics[key]));
        }
        return metricsIdentifiers;
      }
    }
    getTrainingConfig() {
      return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
          class_name: this.optimizer.getClassName(),
          config: this.optimizer.getConfig()
        }
      };
    }
    loadTrainingConfig(trainingConfig) {
      if (trainingConfig.weighted_metrics != null) {
        throw new Error("Loading weight_metrics is not supported yet.");
      }
      if (trainingConfig.loss_weights != null) {
        throw new Error("Loading loss_weights is not supported yet.");
      }
      if (trainingConfig.sample_weight_mode != null) {
        throw new Error("Loading sample_weight_mode is not supported yet.");
      }
      const tsConfig = convertPythonicToTs(trainingConfig.optimizer_config);
      const optimizer = deserialize(tsConfig);
      let loss;
      if (typeof trainingConfig.loss === "string") {
        loss = toCamelCase(trainingConfig.loss);
      } else if (Array.isArray(trainingConfig.loss)) {
        loss = trainingConfig.loss.map((lossEntry) => toCamelCase(lossEntry));
      } else if (trainingConfig.loss != null) {
        loss = {};
        for (const key in trainingConfig.loss) {
          loss[key] = toCamelCase(trainingConfig.loss[key]);
        }
      }
      let metrics2;
      if (Array.isArray(trainingConfig.metrics)) {
        metrics2 = trainingConfig.metrics.map((metric) => toCamelCase(metric));
      } else if (trainingConfig.metrics != null) {
        metrics2 = {};
        for (const key in trainingConfig.metrics) {
          metrics2[key] = toCamelCase(trainingConfig.metrics[key]);
        }
      }
      this.compile({ loss, metrics: metrics2, optimizer });
    }
    async save(handlerOrURL, config) {
      if (typeof handlerOrURL === "string") {
        const handlers = io_exports.getSaveHandlers(handlerOrURL);
        if (handlers.length === 0) {
          throw new ValueError(`Cannot find any save handlers for URL '${handlerOrURL}'`);
        } else if (handlers.length > 1) {
          throw new ValueError(`Found more than one (${handlers.length}) save handlers for URL '${handlerOrURL}'`);
        }
        handlerOrURL = handlers[0];
      }
      if (handlerOrURL.save == null) {
        throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
      }
      const weightDataAndSpecs = await io_exports.encodeWeights(this.getNamedWeights(config));
      const returnString = false;
      const unusedArg = null;
      const modelConfig = this.toJSON(unusedArg, returnString);
      const modelArtifacts = {
        modelTopology: modelConfig,
        format: LAYERS_MODEL_FORMAT_NAME,
        generatedBy: `TensorFlow.js tfjs-layers v${version4}`,
        convertedBy: null
      };
      const includeOptimizer = config == null ? false : config.includeOptimizer;
      if (includeOptimizer && this.optimizer != null) {
        modelArtifacts.trainingConfig = this.getTrainingConfig();
        const weightType = "optimizer";
        const { data: optimizerWeightData, specs: optimizerWeightSpecs } = await io_exports.encodeWeights(await this.optimizer.getWeights(), weightType);
        weightDataAndSpecs.specs.push(...optimizerWeightSpecs);
        weightDataAndSpecs.data = io_exports.concatenateArrayBuffers([weightDataAndSpecs.data, optimizerWeightData]);
      }
      if (this.userDefinedMetadata != null) {
        const checkSize = true;
        checkUserDefinedMetadata(this.userDefinedMetadata, this.name, checkSize);
        modelArtifacts.userDefinedMetadata = this.userDefinedMetadata;
      }
      modelArtifacts.weightData = weightDataAndSpecs.data;
      modelArtifacts.weightSpecs = weightDataAndSpecs.specs;
      return handlerOrURL.save(modelArtifacts);
    }
    setUserDefinedMetadata(userDefinedMetadata) {
      checkUserDefinedMetadata(userDefinedMetadata, this.name);
      this.userDefinedMetadata = userDefinedMetadata;
    }
    getUserDefinedMetadata() {
      return this.userDefinedMetadata;
    }
  };
  LayersModel.className = "Model";
  serialization_exports.registerClass(LayersModel);
  var Functional = class extends LayersModel {
  };
  Functional.className = "Functional";
  serialization_exports.registerClass(Functional);

  // node_modules/@tensorflow/tfjs-layers/dist/models.js
  var Sequential = class extends LayersModel {
    constructor(args) {
      super({ inputs: [], outputs: [] });
      args = args || {};
      this.trainable = true;
      this.built = false;
      this.name = args.name != null ? args.name : getUid("sequential_");
      if (args.layers != null) {
        for (const layer of args.layers) {
          this.add(layer);
        }
      }
    }
    checkShape(layer) {
      const shape = layer.inboundNodes[0].outputTensors[0].shape;
      if (shape.some((x) => x < 0)) {
        throw new ValueError(`Negative dimension size caused by adding layer ${layer.name} with input shape [${layer.inboundNodes[0].inputTensors[0].shape}]`);
      }
    }
    add(layer) {
      const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;
      let modelLayer;
      if (isLayerModelInstance) {
        modelLayer = layer;
        if (modelLayer.outputs.length !== 1) {
          throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        }
        if (modelLayer.inputs.length !== 1) {
          throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.");
        }
      }
      if (this.outputs.length === 0) {
        if (layer.inboundNodes.length === 0) {
          if (layer.batchInputShape == null) {
            throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
          }
          const x = Input({
            batchShape: layer.batchInputShape,
            dtype: layer.dtype,
            name: layer.name + "_input"
          });
          layer.apply(x);
        }
        if (isLayerModelInstance) {
          this.outputs = modelLayer.outputs;
          this.inputs = modelLayer.inputs;
        } else {
          if (layer.inboundNodes.length !== 1) {
            throw new ValueError(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${layer.name} which has ${layer.inboundNodes.length} pre-existing inbound connections.`);
          }
          if (layer.inboundNodes[0].outputTensors.length !== 1) {
            throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
          }
          this.checkShape(layer);
          this.outputs = [layer.inboundNodes[0].outputTensors[0]];
          this.inputs = getSourceInputs(this.outputs[0]);
        }
        this.inboundNodes = [];
        new Node({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: pyListRepeat(null, this.inputs.length),
          outputMasks: [null],
          inputShapes: this.inputs.map((x) => x.shape),
          outputShapes: this.outputs[0].shape
        });
      } else {
        const outputTensor = layer.apply(this.outputs[0]);
        if (Array.isArray(outputTensor)) {
          throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
        }
        this.checkShape(layer);
        this.outputs = [outputTensor];
        this.inboundNodes[0].outputTensors = this.outputs;
        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
      this.layers.push(layer);
      this.built = false;
    }
    pop() {
      if (this.layers.length === 0) {
        throw new TypeError("There are no layers in the model.");
      }
      this.layers.pop();
      if (this.layers.length === 0) {
        this.outputs = [];
        this.inboundNodes = [];
        this.outboundNodes = [];
      } else {
        const lastLayerIndex = this.layers.length - 1;
        this.layers[lastLayerIndex].outboundNodes = [];
        this.outputs = [this.layers[lastLayerIndex].output];
        this.inboundNodes[0].outputTensors = this.outputs;
        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
    }
    call(inputs, kwargs) {
      if (this.model == null) {
        this.build();
      }
      return this.model.call(inputs, kwargs);
    }
    build(inputShape) {
      getExactlyOneShape(inputShape);
      if (this.inputs.length === 0 || this.outputs.length === 0) {
        throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
      }
      this.model = new LayersModel({
        inputs: this.inputs,
        outputs: this.outputs[0],
        name: this.name + "_model"
      });
      this.model.trainable = this.trainable;
      this.supportsMasking = this.model.supportsMasking;
      this.inputLayers = this.model.inputLayers;
      this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
      this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
      this.outputLayers = this.model.outputLayers;
      this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
      this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
      this.nodesByDepth = this.model.nodesByDepth;
      this.containerNodes = this.model.containerNodes;
      this.outputNames = this.model.outputNames;
      this.inputNames = this.model.inputNames;
      this.built = true;
    }
    countParams() {
      if (!this.built) {
        this.build();
      }
      return super.countParams();
    }
    summary(lineLength, positions, printFn = console.log) {
      if (!this.built) {
        this.build();
      }
      super.summary(lineLength, positions, printFn);
    }
    setWeights(weights) {
      if (this.model == null) {
        this.build();
      }
      this.model.setWeights(weights);
    }
    evaluate(x, y, args = {}) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before being used.");
      }
      return this.model.evaluate(x, y, args);
    }
    async evaluateDataset(dataset, args) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before being used.");
      }
      return this.model.evaluateDataset(dataset, args);
    }
    predict(x, args = {}) {
      if (this.model == null) {
        this.build();
      }
      return this.model.predict(x, args);
    }
    predictOnBatch(x) {
      if (this.model == null) {
        this.build();
      }
      return this.model.predictOnBatch(x);
    }
    compile(args) {
      this.build();
      this.model.compile(args);
      this.optimizer_ = this.model.optimizer;
      this.isOptimizerOwned = this.model.isOptimizerOwned;
      this.loss = this.model.loss;
      this.metrics = this.model.metrics;
      this.metricsTensors = this.model.metricsTensors;
      this.metricsNames = this.model.metricsNames;
    }
    get optimizer() {
      return this.model == null ? void 0 : this.model.optimizer;
    }
    set optimizer(optimizer) {
      this.model.optimizer = optimizer;
    }
    async fit(x, y, args = {}) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before being used.");
      }
      return this.model.fit(x, y, args);
    }
    async fitDataset(dataset, args) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before being used.");
      }
      return this.model.fitDataset(dataset, args);
    }
    async trainOnBatch(x, y) {
      return this.model.trainOnBatch(x, y);
    }
    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {
      let configArray;
      let extraModelConfig = {};
      if (config instanceof Array) {
        if (!(config[0].className != null) || config[0]["className"] === "Merge") {
          throw new ValueError("Legacy serialization format not supported yet.");
        }
        configArray = config;
      } else {
        util_exports2.assert(config["layers"] != null, () => `When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.`);
        configArray = config["layers"];
        delete config["layers"];
        extraModelConfig = config;
      }
      const model2 = new cls(extraModelConfig);
      if (!(model2 instanceof Sequential)) {
        throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model2}`);
      }
      for (const conf of configArray) {
        const customObjects2 = void 0;
        const layer = deserialize(conf, customObjects2, fastWeightInit);
        if (fastWeightInit) {
          layer.setFastWeightInitDuringBuild(true);
        }
        model2.add(layer);
      }
      return model2;
    }
    set stopTraining(stop2) {
      if (this.model == null) {
        throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");
      }
      this.model.stopTraining = stop2;
    }
    get stopTraining() {
      if (this.model == null) {
        throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");
      }
      return this.model.stopTraining;
    }
    getConfig() {
      const layers = [];
      for (const layer of this.layers) {
        const dict = {};
        dict["className"] = layer.getClassName();
        dict["config"] = layer.getConfig();
        layers.push(dict);
      }
      return { name: this.name, layers };
    }
  };
  Sequential.className = "Sequential";
  serialization_exports.registerClass(Sequential);

  // node_modules/@tensorflow/tfjs-layers/dist/activations.js
  var Activation = class extends serialization_exports.Serializable {
    getConfig() {
      return {};
    }
  };
  var Elu2 = class extends Activation {
    apply(x, alpha = 1) {
      return elu2(x, alpha);
    }
  };
  Elu2.className = "elu";
  serialization_exports.registerClass(Elu2);
  var Selu2 = class extends Activation {
    apply(x) {
      return selu(x);
    }
  };
  Selu2.className = "selu";
  serialization_exports.registerClass(Selu2);
  var Relu2 = class extends Activation {
    apply(x) {
      return relu(x);
    }
  };
  Relu2.className = "relu";
  serialization_exports.registerClass(Relu2);
  var Relu62 = class extends Activation {
    apply(x) {
      return tidy(() => minimum(6, relu(x)));
    }
  };
  Relu62.className = "relu6";
  serialization_exports.registerClass(Relu62);
  var Linear2 = class extends Activation {
    apply(x) {
      return x;
    }
  };
  Linear2.className = "linear";
  serialization_exports.registerClass(Linear2);
  var Sigmoid2 = class extends Activation {
    apply(x) {
      return sigmoid(x);
    }
  };
  Sigmoid2.className = "sigmoid";
  serialization_exports.registerClass(Sigmoid2);
  var HardSigmoid = class extends Activation {
    apply(x) {
      return hardSigmoid(x);
    }
  };
  HardSigmoid.className = "hardSigmoid";
  serialization_exports.registerClass(HardSigmoid);
  var Softplus2 = class extends Activation {
    apply(x) {
      return softplus(x);
    }
  };
  Softplus2.className = "softplus";
  serialization_exports.registerClass(Softplus2);
  var Softsign = class extends Activation {
    apply(x) {
      return softsign(x);
    }
  };
  Softsign.className = "softsign";
  serialization_exports.registerClass(Softsign);
  var Tanh2 = class extends Activation {
    apply(x) {
      return tanh2(x);
    }
  };
  Tanh2.className = "tanh";
  serialization_exports.registerClass(Tanh2);
  var Softmax2 = class extends Activation {
    apply(x, axis = -1) {
      return softmax(x, axis);
    }
  };
  Softmax2.className = "softmax";
  serialization_exports.registerClass(Softmax2);
  var LogSoftmax2 = class extends Activation {
    apply(x, axis = -1) {
      return logSoftmax(x, axis);
    }
  };
  LogSoftmax2.className = "logSoftmax";
  serialization_exports.registerClass(LogSoftmax2);
  var Swish = class extends Activation {
    apply(x, alpha = 1) {
      return tidy(() => mul4(sigmoid(mul4(x, alpha)), x));
    }
  };
  Swish.className = "swish";
  serialization_exports.registerClass(Swish);
  var Mish = class extends Activation {
    apply(x) {
      return tidy(() => mul4(x, tanh2(softplus(x))));
    }
  };
  Mish.className = "mish";
  serialization_exports.registerClass(Mish);
  function serializeActivation(activation) {
    return activation.getClassName();
  }
  function deserializeActivation(config, customObjects = {}) {
    return deserializeKerasObject(config, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "activation");
  }
  function getActivation(identifier) {
    if (identifier == null) {
      const config = {};
      config["className"] = "linear";
      config["config"] = {};
      return deserializeActivation(config);
    }
    if (typeof identifier === "string") {
      const config = {};
      config["className"] = identifier;
      config["config"] = {};
      return deserializeActivation(config);
    } else if (identifier instanceof Activation) {
      return identifier;
    } else {
      return deserializeActivation(identifier);
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/regularizers.js
  function assertObjectArgs(args) {
    if (args != null && typeof args !== "object") {
      throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${args}`);
    }
  }
  var Regularizer = class extends serialization_exports.Serializable {
  };
  var L1L2 = class extends Regularizer {
    constructor(args) {
      super();
      assertObjectArgs(args);
      this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;
      this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;
      this.hasL1 = this.l1 !== 0;
      this.hasL2 = this.l2 !== 0;
    }
    apply(x) {
      return tidy(() => {
        let regularization = zeros([1]);
        if (this.hasL1) {
          regularization = add6(regularization, sum2(mul4(this.l1, abs(x))));
        }
        if (this.hasL2) {
          regularization = add6(regularization, sum2(mul4(this.l2, square2(x))));
        }
        return reshape(regularization, []);
      });
    }
    getConfig() {
      return { "l1": this.l1, "l2": this.l2 };
    }
    static fromConfig(cls, config) {
      return new cls({ l1: config["l1"], l2: config["l2"] });
    }
  };
  L1L2.className = "L1L2";
  serialization_exports.registerClass(L1L2);
  var REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    "l1l2": "L1L2"
  };
  function serializeRegularizer(constraint) {
    return serializeKerasObject(constraint);
  }
  function deserializeRegularizer(config, customObjects = {}) {
    return deserializeKerasObject(config, serialization_exports.SerializationMap.getMap().classNameMap, customObjects, "regularizer");
  }
  function getRegularizer(identifier) {
    if (identifier == null) {
      return null;
    }
    if (typeof identifier === "string") {
      const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
      const config = { className, config: {} };
      return deserializeRegularizer(config);
    } else if (identifier instanceof Regularizer) {
      return identifier;
    } else {
      return deserializeRegularizer(identifier);
    }
  }

  // node_modules/@tensorflow/tfjs-layers/dist/layers/advanced_activations.js
  var ReLU = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.supportsMasking = true;
      if (args != null) {
        this.maxValue = args.maxValue;
      }
    }
    call(inputs, kwargs) {
      inputs = getExactlyOneTensor(inputs);
      let output = relu(inputs);
      if (this.maxValue != null) {
        output = clipByValue(output, 0, this.maxValue);
      }
      return output;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { maxValue: this.maxValue };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ReLU.className = "ReLU";
  serialization_exports.registerClass(ReLU);
  var LeakyReLU = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_ALPHA = 0.3;
      if (args == null) {
        args = {};
      }
      this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return leakyRelu(x, this.alpha);
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { alpha: this.alpha };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  LeakyReLU.className = "LeakyReLU";
  serialization_exports.registerClass(LeakyReLU);
  var PReLU = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_ALPHA_INITIALIZER = "zeros";
      if (args == null) {
        args = {};
      }
      this.supportsMasking = true;
      this.alphaInitializer = getInitializer(args.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER);
      this.alphaRegularizer = getRegularizer(args.alphaRegularizer);
      this.alphaConstraint = getConstraint2(args.alphaConstraint);
      if (args.sharedAxes == null) {
        this.sharedAxes = null;
      } else if (Array.isArray(args.sharedAxes)) {
        this.sharedAxes = args.sharedAxes;
      } else if (typeof args.sharedAxes === "number") {
        this.sharedAxes = [args.sharedAxes];
      } else {
        throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, but got ${args.sharedAxes}`);
      }
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const paramShape = inputShape.slice(1);
      if (this.sharedAxes != null) {
        for (const i of this.sharedAxes) {
          paramShape[i - 1] = 1;
        }
      }
      this.alpha = this.addWeight("alpha", paramShape, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
      const axes = {};
      if (this.sharedAxes != null) {
        for (let i = 1; i < inputShape.length; ++i) {
          axes[i] = inputShape[i];
        }
      }
      this.inputSpec = [new InputSpec({
        ndim: inputShape.length,
        axes
      })];
      this.built = true;
    }
    call(inputs, kwargs) {
      inputs = getExactlyOneTensor(inputs);
      return prelu(inputs, this.alpha.read());
    }
    getConfig() {
      const config = {
        alphaInitializer: serializeInitializer(this.alphaInitializer),
        alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
        alphaConstraint: serializeConstraint(this.alphaConstraint),
        sharedAxes: this.sharedAxes
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  PReLU.className = "PReLU";
  serialization_exports.registerClass(PReLU);
  var ELU = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_ALPHA = 1;
      if (args == null) {
        args = {};
      }
      if (args.alpha != null && args.alpha !== this.DEFAULT_ALPHA) {
        throw new NotImplementedError(`Non-default alpha value (${args.alpha}) is not supported by the ELU layer yet.`);
      }
      this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return elu(x);
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { alpha: this.alpha };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ELU.className = "ELU";
  serialization_exports.registerClass(ELU);
  var ThresholdedReLU = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_THETA = 1;
      if (args == null) {
        args = {};
      }
      this.theta = args.theta == null ? this.DEFAULT_THETA : args.theta;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return mul4(x, cast(greater(x, this.theta), "float32"));
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { theta: this.theta };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ThresholdedReLU.className = "ThresholdedReLU";
  serialization_exports.registerClass(ThresholdedReLU);
  var Softmax3 = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_AXIS = 1;
      if (args == null) {
        args = {};
      }
      this.softmax = new Softmax2().apply;
      this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return this.softmax(x, this.axis);
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { axis: this.axis };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Softmax3.className = "Softmax";
  serialization_exports.registerClass(Softmax3);

  // node_modules/@tensorflow/tfjs-layers/dist/utils/conv_utils.js
  function normalizeArray(value, n, name) {
    if (typeof value === "number") {
      return pyListRepeat(value, n);
    } else {
      if (value.length !== n) {
        throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers. Received: ${value.length} elements.`);
      }
      for (let i = 0; i < n; ++i) {
        const singleValue = value[i];
        if (!isInteger2(singleValue)) {
          throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(value)} including a non-integer number ${singleValue}`);
        }
      }
      return value;
    }
  }
  function convOutputLength(inputLength, filterSize, padding, stride, dilation = 1) {
    if (inputLength == null) {
      return inputLength;
    }
    const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
    let outputLength;
    if (padding === "same") {
      outputLength = inputLength;
    } else {
      outputLength = inputLength - dilatedFilterSize + 1;
    }
    return Math.floor((outputLength + stride - 1) / stride);
  }
  function deconvLength(dimSize, strideSize, kernelSize, padding) {
    if (dimSize == null) {
      return null;
    }
    if (padding === "valid") {
      dimSize = dimSize * strideSize + max4([kernelSize - strideSize, 0]);
    } else if (padding === "same") {
      dimSize = dimSize * strideSize;
    } else {
      throw new ValueError(`Unsupport padding mode: ${padding}.`);
    }
    return dimSize;
  }

  // node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional.js
  function preprocessConv2DInput(x, dataFormat) {
    return tidy(() => {
      checkDataFormat(dataFormat);
      if (dataFormat === "channelsFirst") {
        return transpose2(x, [0, 2, 3, 1]);
      } else {
        return x;
      }
    });
  }
  function preprocessConv3DInput(x, dataFormat) {
    return tidy(() => {
      checkDataFormat(dataFormat);
      if (dataFormat === "channelsFirst") {
        return transpose2(x, [0, 2, 3, 4, 1]);
      } else {
        return x;
      }
    });
  }
  function conv1dWithBias(x, kernel, bias, strides = 1, padding = "valid", dataFormat, dilationRate = 1) {
    return tidy(() => {
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      checkDataFormat(dataFormat);
      if (x.shape.length !== 3) {
        throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ${x.shape.length} instead.`);
      }
      if (kernel.shape.length !== 3) {
        throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ${kernel.shape.length} instead`);
      }
      if (bias != null && bias.shape.length !== 1) {
        throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ${kernel.shape.length} instead`);
      }
      if (dataFormat === "channelsFirst") {
        x = transpose2(x, [0, 2, 1]);
      }
      if (padding === "causal") {
        throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      }
      let y = conv1d(x, kernel, strides, padding === "same" ? "same" : "valid", "NWC", dilationRate);
      if (bias != null) {
        y = biasAdd(y, bias);
      }
      return y;
    });
  }
  function conv2dWithBiasActivation(x, kernel, bias, strides = [1, 1], padding = "valid", dataFormat, dilationRate, activation = null) {
    return tidy(() => {
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      checkDataFormat(dataFormat);
      if (x.rank !== 3 && x.rank !== 4) {
        throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${x.rank}.`);
      }
      if (kernel.rank !== 3 && kernel.rank !== 4) {
        throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${x.rank}.`);
      }
      let y = preprocessConv2DInput(x, dataFormat);
      if (padding === "causal") {
        throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
      }
      y = fused_ops_exports.conv2d({
        x: y,
        filter: kernel,
        strides,
        pad: padding === "same" ? "same" : "valid",
        dilations: dilationRate,
        dataFormat: "NHWC",
        bias,
        activation
      });
      if (dataFormat === "channelsFirst") {
        y = transpose2(y, [0, 3, 1, 2]);
      }
      return y;
    });
  }
  function conv3dWithBias(x, kernel, bias, strides = [1, 1, 1], padding = "valid", dataFormat, dilationRate) {
    return tidy(() => {
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      checkDataFormat(dataFormat);
      if (x.rank !== 4 && x.rank !== 5) {
        throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ${x.rank}.`);
      }
      if (kernel.rank !== 4 && kernel.rank !== 5) {
        throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${x.rank}.`);
      }
      let y = preprocessConv3DInput(x, dataFormat);
      if (padding === "causal") {
        throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
      }
      y = conv3d(y, kernel, strides, padding === "same" ? "same" : "valid", "NDHWC", dilationRate);
      if (bias != null) {
        y = biasAdd(y, bias);
      }
      if (dataFormat === "channelsFirst") {
        y = transpose2(y, [0, 4, 1, 2, 3]);
      }
      return y;
    });
  }
  var BaseConv = class extends Layer {
    constructor(rank, args) {
      super(args);
      this.bias = null;
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      BaseConv.verifyArgs(args);
      this.rank = rank;
      assertPositiveInteger(this.rank, "rank");
      if (this.rank !== 1 && this.rank !== 2 && this.rank !== 3) {
        throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);
      }
      this.kernelSize = normalizeArray(args.kernelSize, rank, "kernelSize");
      this.strides = normalizeArray(args.strides == null ? 1 : args.strides, rank, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      checkPaddingMode(this.padding);
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      this.activation = getActivation(args.activation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.biasConstraint = getConstraint2(args.biasConstraint);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.activityRegularizer = getRegularizer(args.activityRegularizer);
      this.dilationRate = normalizeArray(args.dilationRate == null ? 1 : args.dilationRate, rank, "dilationRate");
      if (this.rank === 1 && (Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)) {
        throw new ValueError(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);
      } else if (this.rank === 2) {
        if (typeof this.dilationRate === "number") {
          this.dilationRate = [this.dilationRate, this.dilationRate];
        } else if (this.dilationRate.length !== 2) {
          throw new ValueError(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`);
        }
      } else if (this.rank === 3) {
        if (typeof this.dilationRate === "number") {
          this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
        } else if (this.dilationRate.length !== 3) {
          throw new ValueError(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`);
        }
      }
    }
    static verifyArgs(args) {
      assert2("kernelSize" in args, `required key 'kernelSize' not in config`);
      if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 3)) {
        throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
    getConfig() {
      const config = {
        kernelSize: this.kernelSize,
        strides: this.strides,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        activation: serializeActivation(this.activation),
        useBias: this.useBias,
        biasInitializer: serializeInitializer(this.biasInitializer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        biasConstraint: serializeConstraint(this.biasConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  var Conv = class extends BaseConv {
    constructor(rank, args) {
      super(rank, args);
      this.kernel = null;
      Conv.verifyArgs(args);
      this.filters = args.filters;
      assertPositiveInteger(this.filters, "filters");
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.kernelConstraint = getConstraint2(args.kernelConstraint);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);
      }
      const inputDim = inputShape[channelAxis];
      const kernelShape = this.kernelSize.concat([inputDim, this.filters]);
      this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.inputSpec = [{ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } }];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        let outputs;
        const biasValue = this.bias == null ? null : this.bias.read();
        const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
        if (fusedActivationName != null && this.rank === 2) {
          outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate, fusedActivationName);
        } else {
          if (this.rank === 1) {
            outputs = conv1dWithBias(inputs, this.kernel.read(), biasValue, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
          } else if (this.rank === 2) {
            outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
          } else if (this.rank === 3) {
            outputs = conv3dWithBias(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
          } else {
            throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
          }
          if (this.activation != null) {
            outputs = this.activation.apply(outputs);
          }
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const newSpace = [];
      const space = this.dataFormat === "channelsLast" ? inputShape.slice(1, inputShape.length - 1) : inputShape.slice(2);
      for (let i = 0; i < space.length; ++i) {
        const newDim = convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === "number" ? this.dilationRate : this.dilationRate[i]);
        newSpace.push(newDim);
      }
      let outputShape = [inputShape[0]];
      if (this.dataFormat === "channelsLast") {
        outputShape = outputShape.concat(newSpace);
        outputShape.push(this.filters);
      } else {
        outputShape.push(this.filters);
        outputShape = outputShape.concat(newSpace);
      }
      return outputShape;
    }
    getConfig() {
      const config = {
        filters: this.filters,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    static verifyArgs(args) {
      if (!("filters" in args) || typeof args.filters !== "number" || args.filters < 1) {
        throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(args.filters)}`);
      }
    }
  };
  var Conv2D2 = class extends Conv {
    constructor(args) {
      super(2, args);
      Conv2D2.verifyArgs(args);
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      return config;
    }
    static verifyArgs(args) {
      if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 2)) {
        throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
  };
  Conv2D2.className = "Conv2D";
  serialization_exports.registerClass(Conv2D2);
  var Conv3D2 = class extends Conv {
    constructor(args) {
      super(3, args);
      Conv3D2.verifyArgs(args);
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      return config;
    }
    static verifyArgs(args) {
      if (typeof args.kernelSize !== "number") {
        if (!(Array.isArray(args.kernelSize) && (args.kernelSize.length === 1 || args.kernelSize.length === 3))) {
          throw new ValueError(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(args.kernelSize)}.`);
        }
      }
    }
  };
  Conv3D2.className = "Conv3D";
  serialization_exports.registerClass(Conv3D2);
  var Conv2DTranspose = class extends Conv2D2 {
    constructor(args) {
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 4 })];
      if (this.padding !== "same" && this.padding !== "valid") {
        throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
      }
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length !== 4) {
        throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(inputShape));
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
      }
      const inputDim = inputShape[channelAxis];
      const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
      this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.inputSpec = [new InputSpec({ ndim: 4, axes: { [channelAxis]: inputDim } })];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let input2 = getExactlyOneTensor(inputs);
        if (input2.shape.length !== 4) {
          throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${input2.shape.length}`);
        }
        const inputShape = input2.shape;
        const batchSize = inputShape[0];
        let hAxis;
        let wAxis;
        if (this.dataFormat === "channelsFirst") {
          hAxis = 2;
          wAxis = 3;
        } else {
          hAxis = 1;
          wAxis = 2;
        }
        const height = inputShape[hAxis];
        const width = inputShape[wAxis];
        const kernelH = this.kernelSize[0];
        const kernelW = this.kernelSize[1];
        const strideH = this.strides[0];
        const strideW = this.strides[1];
        const outHeight = deconvLength(height, strideH, kernelH, this.padding);
        const outWidth = deconvLength(width, strideW, kernelW, this.padding);
        const outputShape = [batchSize, outHeight, outWidth, this.filters];
        if (this.dataFormat !== "channelsLast") {
          input2 = transpose2(input2, [0, 2, 3, 1]);
        }
        let outputs = conv2dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
        if (this.dataFormat !== "channelsLast") {
          outputs = transpose2(outputs, [0, 3, 1, 2]);
        }
        if (this.bias != null) {
          outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
        }
        if (this.activation != null) {
          outputs = this.activation.apply(outputs);
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      let channelAxis;
      let heightAxis;
      let widthAxis;
      if (this.dataFormat === "channelsFirst") {
        channelAxis = 1;
        heightAxis = 2;
        widthAxis = 3;
      } else {
        channelAxis = 3;
        heightAxis = 1;
        widthAxis = 2;
      }
      const kernelH = this.kernelSize[0];
      const kernelW = this.kernelSize[1];
      const strideH = this.strides[0];
      const strideW = this.strides[1];
      outputShape[channelAxis] = this.filters;
      outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
      outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
      return outputShape;
    }
    getConfig() {
      const config = super.getConfig();
      delete config["dilationRate"];
      return config;
    }
  };
  Conv2DTranspose.className = "Conv2DTranspose";
  serialization_exports.registerClass(Conv2DTranspose);
  var Conv3DTranspose = class extends Conv3D2 {
    constructor(args) {
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 5 })];
      if (this.padding !== "same" && this.padding !== "valid") {
        throw new ValueError(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`);
      }
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length !== 5) {
        throw new ValueError("Input should have rank 5; Received input shape: " + JSON.stringify(inputShape));
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");
      }
      const inputDim = inputShape[channelAxis];
      const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
      this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.inputSpec = [new InputSpec({ ndim: 5, axes: { [channelAxis]: inputDim } })];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let input2 = getExactlyOneTensor(inputs);
        if (input2.shape.length !== 5) {
          throw new ValueError(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${input2.shape.length}`);
        }
        const inputShape = input2.shape;
        const batchSize = inputShape[0];
        let hAxis;
        let wAxis;
        let dAxis;
        if (this.dataFormat === "channelsFirst") {
          dAxis = 2;
          hAxis = 3;
          wAxis = 4;
        } else {
          dAxis = 1;
          hAxis = 2;
          wAxis = 3;
        }
        const depth = inputShape[dAxis];
        const height = inputShape[hAxis];
        const width = inputShape[wAxis];
        const kernelD = this.kernelSize[0];
        const kernelH = this.kernelSize[1];
        const kernelW = this.kernelSize[2];
        const strideD = this.strides[0];
        const strideH = this.strides[1];
        const strideW = this.strides[2];
        const outDepth = deconvLength(depth, strideD, kernelD, this.padding);
        const outHeight = deconvLength(height, strideH, kernelH, this.padding);
        const outWidth = deconvLength(width, strideW, kernelW, this.padding);
        const outputShape = [batchSize, outDepth, outHeight, outWidth, this.filters];
        if (this.dataFormat !== "channelsLast") {
          input2 = transpose2(input2, [0, 2, 3, 4, 1]);
        }
        let outputs = conv3dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
        if (this.dataFormat !== "channelsLast") {
          outputs = transpose2(outputs, [0, 4, 1, 2, 3]);
        }
        if (this.bias !== null) {
          outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
        }
        if (this.activation !== null) {
          outputs = this.activation.apply(outputs);
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      let channelAxis;
      let depthAxis;
      let heightAxis;
      let widthAxis;
      if (this.dataFormat === "channelsFirst") {
        channelAxis = 1;
        depthAxis = 2;
        heightAxis = 3;
        widthAxis = 4;
      } else {
        channelAxis = 4;
        depthAxis = 1;
        heightAxis = 2;
        widthAxis = 3;
      }
      const kernelD = this.kernelSize[0];
      const kernelH = this.kernelSize[1];
      const kernelW = this.kernelSize[2];
      const strideD = this.strides[0];
      const strideH = this.strides[1];
      const strideW = this.strides[2];
      outputShape[channelAxis] = this.filters;
      outputShape[depthAxis] = deconvLength(outputShape[depthAxis], strideD, kernelD, this.padding);
      outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
      outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
      return outputShape;
    }
    getConfig() {
      const config = super.getConfig();
      delete config["dilationRate"];
      return config;
    }
  };
  Conv3DTranspose.className = "Conv3DTranspose";
  serialization_exports.registerClass(Conv3DTranspose);
  var SeparableConv = class extends Conv {
    constructor(rank, config) {
      super(rank, config);
      this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform";
      this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform";
      this.depthwiseKernel = null;
      this.pointwiseKernel = null;
      if (config.filters == null) {
        throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");
      }
      if (config.kernelInitializer != null || config.kernelRegularizer != null || config.kernelConstraint != null) {
        throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
      }
      if (config.padding != null && config.padding !== "same" && config.padding !== "valid") {
        throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(config.padding)}`);
      }
      this.depthMultiplier = config.depthMultiplier == null ? 1 : config.depthMultiplier;
      this.depthwiseInitializer = getInitializer(config.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER);
      this.depthwiseRegularizer = getRegularizer(config.depthwiseRegularizer);
      this.depthwiseConstraint = getConstraint2(config.depthwiseConstraint);
      this.pointwiseInitializer = getInitializer(config.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER);
      this.pointwiseRegularizer = getRegularizer(config.pointwiseRegularizer);
      this.pointwiseConstraint = getConstraint2(config.pointwiseConstraint);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length < this.rank + 2) {
        throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank + 2}, but received input shape: ${JSON.stringify(inputShape)}`);
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
        throw new ValueError(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(inputShape[channelAxis])}`);
      }
      const inputDim = inputShape[channelAxis];
      const depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
      const pointwiseKernelShape = [];
      for (let i = 0; i < this.rank; ++i) {
        pointwiseKernelShape.push(1);
      }
      pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
      const trainable = true;
      this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
      this.pointwiseKernel = this.addWeight("pointwise_kernel", pointwiseKernelShape, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.inputSpec = [new InputSpec({ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } })];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        let output;
        if (this.rank === 1) {
          throw new NotImplementedError("1D separable convolution is not implemented yet.");
        } else if (this.rank === 2) {
          if (this.dataFormat === "channelsFirst") {
            inputs = transpose2(inputs, [0, 2, 3, 1]);
          }
          output = separableConv2d(inputs, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC");
        }
        if (this.useBias) {
          output = biasAdd(output, this.bias.read(), this.dataFormat);
        }
        if (this.activation != null) {
          output = this.activation.apply(output);
        }
        if (this.dataFormat === "channelsFirst") {
          output = transpose2(output, [0, 3, 1, 2]);
        }
        return output;
      });
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      delete config["kernelInitializer"];
      delete config["kernelRegularizer"];
      delete config["kernelConstraint"];
      config["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
      config["pointwiseInitializer"] = serializeInitializer(this.pointwiseInitializer);
      config["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
      config["pointwiseRegularizer"] = serializeRegularizer(this.pointwiseRegularizer);
      config["depthwiseConstraint"] = serializeConstraint(this.depthwiseConstraint);
      config["pointwiseConstraint"] = serializeConstraint(this.pointwiseConstraint);
      return config;
    }
  };
  SeparableConv.className = "SeparableConv";
  var SeparableConv2D = class extends SeparableConv {
    constructor(args) {
      super(2, args);
    }
  };
  SeparableConv2D.className = "SeparableConv2D";
  serialization_exports.registerClass(SeparableConv2D);
  var Conv1D = class extends Conv {
    constructor(args) {
      super(1, args);
      Conv1D.verifyArgs(args);
      this.inputSpec = [{ ndim: 3 }];
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      delete config["dataFormat"];
      return config;
    }
    static verifyArgs(args) {
      if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 1)) {
        throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
  };
  Conv1D.className = "Conv1D";
  serialization_exports.registerClass(Conv1D);
  var Cropping2D = class extends Layer {
    constructor(args) {
      super(args);
      if (typeof args.cropping === "number") {
        this.cropping = [[args.cropping, args.cropping], [args.cropping, args.cropping]];
      } else if (typeof args.cropping[0] === "number") {
        this.cropping = [
          [args.cropping[0], args.cropping[0]],
          [args.cropping[1], args.cropping[1]]
        ];
      } else {
        this.cropping = args.cropping;
      }
      this.dataFormat = args.dataFormat === void 0 ? "channelsLast" : args.dataFormat;
      this.inputSpec = [{ ndim: 4 }];
    }
    computeOutputShape(inputShape) {
      if (this.dataFormat === "channelsFirst") {
        return [
          inputShape[0],
          inputShape[1],
          inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
          inputShape[3] - this.cropping[1][0] - this.cropping[1][1]
        ];
      } else {
        return [
          inputShape[0],
          inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
          inputShape[2] - this.cropping[1][0] - this.cropping[1][1],
          inputShape[3]
        ];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsLast") {
          const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
          return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
        } else {
          const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
          return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
        }
      });
    }
    getConfig() {
      const config = { cropping: this.cropping, dataFormat: this.dataFormat };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Cropping2D.className = "Cropping2D";
  serialization_exports.registerClass(Cropping2D);
  var UpSampling2D = class extends Layer {
    constructor(args) {
      super(args);
      this.DEFAULT_SIZE = [2, 2];
      this.inputSpec = [{ ndim: 4 }];
      this.size = args.size == null ? this.DEFAULT_SIZE : args.size;
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      this.interpolation = args.interpolation == null ? "nearest" : args.interpolation;
      checkInterpolationFormat(this.interpolation);
    }
    computeOutputShape(inputShape) {
      if (this.dataFormat === "channelsFirst") {
        const height = inputShape[2] == null ? null : this.size[0] * inputShape[2];
        const width = inputShape[3] == null ? null : this.size[1] * inputShape[3];
        return [inputShape[0], inputShape[1], height, width];
      } else {
        const height = inputShape[1] == null ? null : this.size[0] * inputShape[1];
        const width = inputShape[2] == null ? null : this.size[1] * inputShape[2];
        return [inputShape[0], height, width, inputShape[3]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        if (this.dataFormat === "channelsFirst") {
          input2 = transpose2(input2, [0, 2, 3, 1]);
          const height = this.size[0] * inputShape[2];
          const width = this.size[1] * inputShape[3];
          const resized = this.interpolation === "nearest" ? image.resizeNearestNeighbor(input2, [height, width]) : image.resizeBilinear(input2, [height, width]);
          return transpose2(resized, [0, 3, 1, 2]);
        } else {
          const height = this.size[0] * inputShape[1];
          const width = this.size[1] * inputShape[2];
          return this.interpolation === "nearest" ? image.resizeNearestNeighbor(input2, [height, width]) : image.resizeBilinear(input2, [height, width]);
        }
      });
    }
    getConfig() {
      const config = { size: this.size, dataFormat: this.dataFormat };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  UpSampling2D.className = "UpSampling2D";
  serialization_exports.registerClass(UpSampling2D);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_depthwise.js
  function depthwiseConv2d3(x, depthwiseKernel, strides = [1, 1], padding = "valid", dataFormat, dilationRate) {
    return tidy(() => {
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      checkDataFormat(dataFormat);
      let y = preprocessConv2DInput(x, dataFormat);
      if (x.rank !== 4) {
        throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ${x.rank}-D`);
      }
      if (depthwiseKernel.rank !== 4) {
        throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ${depthwiseKernel.rank}-D`);
      }
      y = depthwiseConv2d(y, depthwiseKernel, strides, padding === "same" ? "same" : "valid", "NHWC", dilationRate);
      if (dataFormat === "channelsFirst") {
        y = transpose2(y, [0, 3, 1, 2]);
      }
      return y;
    });
  }
  var DepthwiseConv2D = class extends BaseConv {
    constructor(args) {
      super(2, args);
      this.depthwiseKernel = null;
      this.depthMultiplier = args.depthMultiplier == null ? 1 : args.depthMultiplier;
      this.depthwiseInitializer = getInitializer(args.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.depthwiseConstraint = getConstraint2(args.depthwiseConstraint);
      this.depthwiseRegularizer = getRegularizer(args.depthwiseRegularizer);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length < 4) {
        throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(inputShape)}.`);
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : 3;
      if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
        throw new ValueError(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${inputShape[channelAxis]}).`);
      }
      const inputDim = inputShape[channelAxis];
      const depthwiseKernelShape = [
        this.kernelSize[0],
        this.kernelSize[1],
        inputDim,
        this.depthMultiplier
      ];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        let outputs = depthwiseConv2d3(inputs, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
        if (this.useBias) {
          outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
        }
        if (this.activation != null) {
          outputs = this.activation.apply(outputs);
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
      const cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
      const outFilters = this.dataFormat === "channelsFirst" ? inputShape[1] * this.depthMultiplier : inputShape[3] * this.depthMultiplier;
      const outRows = convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
      const outCols = convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
      if (this.dataFormat === "channelsFirst") {
        return [inputShape[0], outFilters, outRows, outCols];
      } else {
        return [inputShape[0], outRows, outCols, outFilters];
      }
    }
    getConfig() {
      const config = super.getConfig();
      config["depthMultiplier"] = this.depthMultiplier;
      config["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
      config["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
      config["depthwiseConstraint"] = serializeConstraint(this.depthwiseRegularizer);
      return config;
    }
  };
  DepthwiseConv2D.className = "DepthwiseConv2D";
  serialization_exports.registerClass(DepthwiseConv2D);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/recurrent.js
  function standardizeArgs(inputs, initialState, constants, numConstants) {
    if (Array.isArray(inputs)) {
      if (initialState != null || constants != null) {
        throw new ValueError("When inputs is an array, neither initialState or constants should be provided");
      }
      if (numConstants != null) {
        constants = inputs.slice(inputs.length - numConstants, inputs.length);
        inputs = inputs.slice(0, inputs.length - numConstants);
      }
      if (inputs.length > 1) {
        initialState = inputs.slice(1, inputs.length);
      }
      inputs = inputs[0];
    }
    function toListOrNull(x) {
      if (x == null || Array.isArray(x)) {
        return x;
      } else {
        return [x];
      }
    }
    initialState = toListOrNull(initialState);
    constants = toListOrNull(constants);
    return { inputs, initialState, constants };
  }
  function rnn(stepFunction, inputs, initialStates, goBackwards = false, mask, constants, unroll = false, needPerStepOutputs = false) {
    return tidy(() => {
      const ndim = inputs.shape.length;
      if (ndim < 3) {
        throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);
      }
      const axes = [1, 0].concat(range2(2, ndim));
      inputs = transpose2(inputs, axes);
      if (constants != null) {
        throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
      }
      if (unroll) {
        console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend.");
      }
      if (mask != null) {
        mask = cast(cast(mask, "bool"), "float32");
        if (mask.rank === ndim - 1) {
          mask = expandDims(mask, -1);
        }
        mask = transpose2(mask, axes);
      }
      if (goBackwards) {
        inputs = reverse(inputs, 0);
        if (mask != null) {
          mask = reverse(mask, 0);
        }
      }
      const perStepOutputs = [];
      let lastOutput;
      let states = initialStates;
      const timeSteps = inputs.shape[0];
      const perStepInputs = unstack(inputs);
      let perStepMasks;
      if (mask != null) {
        perStepMasks = unstack(mask);
      }
      for (let t = 0; t < timeSteps; ++t) {
        const currentInput = perStepInputs[t];
        const stepOutputs = tidy(() => stepFunction(currentInput, states));
        if (mask == null) {
          lastOutput = stepOutputs[0];
          states = stepOutputs[1];
        } else {
          const maskedOutputs = tidy(() => {
            const stepMask = perStepMasks[t];
            const negStepMask = sub4(onesLike(stepMask), stepMask);
            const output = add6(mul4(stepOutputs[0], stepMask), mul4(states[0], negStepMask));
            const newStates = states.map((state, i) => {
              return add6(mul4(stepOutputs[1][i], stepMask), mul4(state, negStepMask));
            });
            return { output, newStates };
          });
          lastOutput = maskedOutputs.output;
          states = maskedOutputs.newStates;
        }
        if (needPerStepOutputs) {
          perStepOutputs.push(lastOutput);
        }
      }
      let outputs;
      if (needPerStepOutputs) {
        const axis = 1;
        outputs = stack2(perStepOutputs, axis);
      }
      return [lastOutput, outputs, states];
    });
  }
  var RNN = class extends Layer {
    constructor(args) {
      super(args);
      let cell;
      if (args.cell == null) {
        throw new ValueError("cell property is missing for the constructor of RNN.");
      } else if (Array.isArray(args.cell)) {
        cell = new StackedRNNCells({ cells: args.cell });
      } else {
        cell = args.cell;
      }
      if (cell.stateSize == null) {
        throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
      }
      this.cell = cell;
      this.returnSequences = args.returnSequences == null ? false : args.returnSequences;
      this.returnState = args.returnState == null ? false : args.returnState;
      this.goBackwards = args.goBackwards == null ? false : args.goBackwards;
      this._stateful = args.stateful == null ? false : args.stateful;
      this.unroll = args.unroll == null ? false : args.unroll;
      this.supportsMasking = true;
      this.inputSpec = [new InputSpec({ ndim: 3 })];
      this.stateSpec = null;
      this.states_ = null;
      this.numConstants = null;
      this.keptStates = [];
    }
    getStates() {
      if (this.states_ == null) {
        const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        return range2(0, numStates).map((x) => null);
      } else {
        return this.states_;
      }
    }
    setStates(states) {
      this.states_ = states;
    }
    computeOutputShape(inputShape) {
      if (isArrayOfShapes(inputShape)) {
        inputShape = inputShape[0];
      }
      inputShape = inputShape;
      let stateSize = this.cell.stateSize;
      if (!Array.isArray(stateSize)) {
        stateSize = [stateSize];
      }
      const outputDim = stateSize[0];
      let outputShape;
      if (this.returnSequences) {
        outputShape = [inputShape[0], inputShape[1], outputDim];
      } else {
        outputShape = [inputShape[0], outputDim];
      }
      if (this.returnState) {
        const stateShape = [];
        for (const dim of stateSize) {
          stateShape.push([inputShape[0], dim]);
        }
        return [outputShape].concat(stateShape);
      } else {
        return outputShape;
      }
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        if (Array.isArray(mask)) {
          mask = mask[0];
        }
        const outputMask = this.returnSequences ? mask : null;
        if (this.returnState) {
          const stateMask = this.states.map((s) => null);
          return [outputMask].concat(stateMask);
        } else {
          return outputMask;
        }
      });
    }
    get states() {
      if (this.states_ == null) {
        const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        const output = [];
        for (let i = 0; i < numStates; ++i) {
          output.push(null);
        }
        return output;
      } else {
        return this.states_;
      }
    }
    set states(s) {
      this.states_ = s;
    }
    build(inputShape) {
      const constantShape = null;
      if (this.numConstants != null) {
        throw new NotImplementedError("Constants support is not implemented in RNN yet.");
      }
      if (isArrayOfShapes(inputShape)) {
        inputShape = inputShape[0];
      }
      inputShape = inputShape;
      const batchSize = this.stateful ? inputShape[0] : null;
      const inputDim = inputShape.slice(2);
      this.inputSpec[0] = new InputSpec({ shape: [batchSize, null, ...inputDim] });
      const stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
      if (constantShape != null) {
        throw new NotImplementedError("Constants support is not implemented in RNN yet.");
      } else {
        this.cell.build(stepInputShape);
      }
      let stateSize;
      if (Array.isArray(this.cell.stateSize)) {
        stateSize = this.cell.stateSize;
      } else {
        stateSize = [this.cell.stateSize];
      }
      if (this.stateSpec != null) {
        if (!util_exports2.arraysEqual(this.stateSpec.map((spec) => spec.shape[spec.shape.length - 1]), stateSize)) {
          throw new ValueError(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`);
        }
      } else {
        this.stateSpec = stateSize.map((dim) => new InputSpec({ shape: [null, dim] }));
      }
      if (this.stateful) {
        this.resetStates();
      }
    }
    resetStates(states, training = false) {
      tidy(() => {
        if (!this.stateful) {
          throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
        }
        const batchSize = this.inputSpec[0].shape[0];
        if (batchSize == null) {
          throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        }
        if (this.states_ == null) {
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map((dim) => zeros([batchSize, dim]));
          } else {
            this.states_ = [zeros([batchSize, this.cell.stateSize])];
          }
        } else if (states == null) {
          dispose(this.states_);
          if (this.keptStates != null) {
            dispose(this.keptStates);
            this.keptStates = [];
          }
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map((dim) => zeros([batchSize, dim]));
          } else {
            this.states_[0] = zeros([batchSize, this.cell.stateSize]);
          }
        } else {
          if (!Array.isArray(states)) {
            states = [states];
          }
          if (states.length !== this.states_.length) {
            throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);
          }
          if (training === true) {
            this.keptStates.push(this.states_.slice());
          } else {
            dispose(this.states_);
          }
          for (let index = 0; index < this.states_.length; ++index) {
            const value = states[index];
            const dim = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[index] : this.cell.stateSize;
            const expectedShape = [batchSize, dim];
            if (!util_exports2.arraysEqual(value.shape, expectedShape)) {
              throw new ValueError(`State ${index} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);
            }
            this.states_[index] = value;
          }
        }
        this.states_ = this.states_.map((state) => keep(state.clone()));
      });
    }
    apply(inputs, kwargs) {
      let initialState = kwargs == null ? null : kwargs["initialState"];
      let constants = kwargs == null ? null : kwargs["constants"];
      if (kwargs == null) {
        kwargs = {};
      }
      const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
      inputs = standardized.inputs;
      initialState = standardized.initialState;
      constants = standardized.constants;
      let additionalInputs = [];
      let additionalSpecs = [];
      if (initialState != null) {
        kwargs["initialState"] = initialState;
        additionalInputs = additionalInputs.concat(initialState);
        this.stateSpec = [];
        for (const state of initialState) {
          this.stateSpec.push(new InputSpec({ shape: state.shape }));
        }
        additionalSpecs = additionalSpecs.concat(this.stateSpec);
      }
      if (constants != null) {
        kwargs["constants"] = constants;
        additionalInputs = additionalInputs.concat(constants);
        this.numConstants = constants.length;
      }
      const isTensor = additionalInputs[0] instanceof SymbolicTensor;
      if (isTensor) {
        const fullInput = [inputs].concat(additionalInputs);
        const fullInputSpec = this.inputSpec.concat(additionalSpecs);
        const originalInputSpec = this.inputSpec;
        this.inputSpec = fullInputSpec;
        const output = super.apply(fullInput, kwargs);
        this.inputSpec = originalInputSpec;
        return output;
      } else {
        return super.apply(inputs, kwargs);
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const mask = kwargs == null ? null : kwargs["mask"];
        const training = kwargs == null ? null : kwargs["training"];
        let initialState = kwargs == null ? null : kwargs["initialState"];
        inputs = getExactlyOneTensor(inputs);
        if (initialState == null) {
          if (this.stateful) {
            initialState = this.states_;
          } else {
            initialState = this.getInitialState(inputs);
          }
        }
        const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        if (initialState.length !== numStates) {
          throw new ValueError(`RNN Layer has ${numStates} state(s) but was passed ${initialState.length} initial state(s).`);
        }
        if (this.unroll) {
          console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        }
        const cellCallKwargs = { training };
        const step4 = (inputs2, states2) => {
          const outputs2 = this.cell.call([inputs2].concat(states2), cellCallKwargs);
          return [outputs2[0], outputs2.slice(1)];
        };
        const rnnOutputs = rnn(step4, inputs, initialState, this.goBackwards, mask, null, this.unroll, this.returnSequences);
        const lastOutput = rnnOutputs[0];
        const outputs = rnnOutputs[1];
        const states = rnnOutputs[2];
        if (this.stateful) {
          this.resetStates(states, training);
        }
        const output = this.returnSequences ? outputs : lastOutput;
        if (this.returnState) {
          return [output].concat(states);
        } else {
          return output;
        }
      });
    }
    getInitialState(inputs) {
      return tidy(() => {
        let initialState = zeros(inputs.shape);
        initialState = sum2(initialState, [1, 2]);
        initialState = expandDims2(initialState);
        if (Array.isArray(this.cell.stateSize)) {
          return this.cell.stateSize.map((dim) => dim > 1 ? tile2(initialState, [1, dim]) : initialState);
        } else {
          return this.cell.stateSize > 1 ? [tile2(initialState, [1, this.cell.stateSize])] : [initialState];
        }
      });
    }
    get trainableWeights() {
      if (!this.trainable) {
        return [];
      }
      return this.cell.trainableWeights;
    }
    get nonTrainableWeights() {
      if (!this.trainable) {
        return this.cell.weights;
      }
      return this.cell.nonTrainableWeights;
    }
    setFastWeightInitDuringBuild(value) {
      super.setFastWeightInitDuringBuild(value);
      if (this.cell != null) {
        this.cell.setFastWeightInitDuringBuild(value);
      }
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        returnSequences: this.returnSequences,
        returnState: this.returnState,
        goBackwards: this.goBackwards,
        stateful: this.stateful,
        unroll: this.unroll
      };
      if (this.numConstants != null) {
        config["numConstants"] = this.numConstants;
      }
      const cellConfig = this.cell.getConfig();
      if (this.getClassName() === RNN.className) {
        config["cell"] = {
          "className": this.cell.getClassName(),
          "config": cellConfig
        };
      }
      return Object.assign({}, cellConfig, baseConfig, config);
    }
    static fromConfig(cls, config, customObjects = {}) {
      const cellConfig = config["cell"];
      const cell = deserialize(cellConfig, customObjects);
      return new cls(Object.assign(config, { cell }));
    }
  };
  RNN.className = "RNN";
  serialization_exports.registerClass(RNN);
  var RNNCell = class extends Layer {
  };
  var SimpleRNNCell = class extends RNNCell {
    constructor(args) {
      super(args);
      this.DEFAULT_ACTIVATION = "tanh";
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      this.units = args.units;
      assertPositiveInteger(this.units, `units`);
      this.activation = getActivation(args.activation == null ? this.DEFAULT_ACTIVATION : args.activation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.kernelConstraint = getConstraint2(args.kernelConstraint);
      this.recurrentConstraint = getConstraint2(args.recurrentConstraint);
      this.biasConstraint = getConstraint2(args.biasConstraint);
      this.dropout = min4([1, max4([0, args.dropout == null ? 0 : args.dropout])]);
      this.recurrentDropout = min4([
        1,
        max4([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
      ]);
      this.dropoutFunc = args.dropoutFunc;
      this.stateSize = this.units;
      this.dropoutMask = null;
      this.recurrentDropoutMask = null;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      this.kernel = this.addWeight("kernel", [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        if (inputs.length !== 2) {
          throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);
        }
        let prevOutput = inputs[1];
        inputs = inputs[0];
        const training = kwargs["training"] == null ? false : kwargs["training"];
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(inputs),
            rate: this.dropout,
            training,
            dropoutFunc: this.dropoutFunc
          });
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(prevOutput),
            rate: this.recurrentDropout,
            training,
            dropoutFunc: this.dropoutFunc
          });
        }
        let h2;
        const dpMask = this.dropoutMask;
        const recDpMask = this.recurrentDropoutMask;
        if (dpMask != null) {
          h2 = dot5(mul4(inputs, dpMask), this.kernel.read());
        } else {
          h2 = dot5(inputs, this.kernel.read());
        }
        if (this.bias != null) {
          h2 = biasAdd(h2, this.bias.read());
        }
        if (recDpMask != null) {
          prevOutput = mul4(prevOutput, recDpMask);
        }
        let output = add6(h2, dot5(prevOutput, this.recurrentKernel.read()));
        if (this.activation != null) {
          output = this.activation.apply(output);
        }
        return [output, output];
      });
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        recurrentInitializer: serializeInitializer(this.recurrentInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        recurrentConstraint: serializeConstraint(this.recurrentConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout
      };
      return Object.assign({}, baseConfig, config);
    }
  };
  SimpleRNNCell.className = "SimpleRNNCell";
  serialization_exports.registerClass(SimpleRNNCell);
  var SimpleRNN = class extends RNN {
    constructor(args) {
      args.cell = new SimpleRNNCell(args);
      super(args);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training, initialState });
      });
    }
    static fromConfig(cls, config) {
      return new cls(config);
    }
  };
  SimpleRNN.className = "SimpleRNN";
  serialization_exports.registerClass(SimpleRNN);
  var GRUCell = class extends RNNCell {
    constructor(args) {
      super(args);
      this.DEFAULT_ACTIVATION = "tanh";
      this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      if (args.resetAfter) {
        throw new ValueError(`GRUCell does not support reset_after parameter set to true.`);
      }
      this.units = args.units;
      assertPositiveInteger(this.units, "units");
      this.activation = getActivation(args.activation === void 0 ? this.DEFAULT_ACTIVATION : args.activation);
      this.recurrentActivation = getActivation(args.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.kernelConstraint = getConstraint2(args.kernelConstraint);
      this.recurrentConstraint = getConstraint2(args.recurrentConstraint);
      this.biasConstraint = getConstraint2(args.biasConstraint);
      this.dropout = min4([1, max4([0, args.dropout == null ? 0 : args.dropout])]);
      this.recurrentDropout = min4([
        1,
        max4([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
      ]);
      this.dropoutFunc = args.dropoutFunc;
      this.implementation = args.implementation;
      this.stateSize = this.units;
      this.dropoutMask = null;
      this.recurrentDropoutMask = null;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const inputDim = inputShape[inputShape.length - 1];
      this.kernel = this.addWeight("kernel", [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        if (inputs.length !== 2) {
          throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ${inputs.length}.`);
        }
        const training = kwargs["training"] == null ? false : kwargs["training"];
        let hTMinus1 = inputs[1];
        inputs = inputs[0];
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(inputs),
            rate: this.dropout,
            training,
            count: 3,
            dropoutFunc: this.dropoutFunc
          });
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(hTMinus1),
            rate: this.recurrentDropout,
            training,
            count: 3,
            dropoutFunc: this.dropoutFunc
          });
        }
        const dpMask = this.dropoutMask;
        const recDpMask = this.recurrentDropoutMask;
        let z;
        let r;
        let hh;
        if (0 < this.dropout && this.dropout < 1) {
          inputs = mul4(inputs, dpMask[0]);
        }
        let matrixX = dot5(inputs, this.kernel.read());
        if (this.useBias) {
          matrixX = biasAdd(matrixX, this.bias.read());
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
          hTMinus1 = mul4(hTMinus1, recDpMask[0]);
        }
        const recurrentKernelValue = this.recurrentKernel.read();
        const [rk1, rk2] = split(recurrentKernelValue, [2 * this.units, this.units], recurrentKernelValue.rank - 1);
        const matrixInner = dot5(hTMinus1, rk1);
        const [xZ, xR, xH] = split(matrixX, 3, matrixX.rank - 1);
        const [recurrentZ, recurrentR] = split(matrixInner, 2, matrixInner.rank - 1);
        z = this.recurrentActivation.apply(add6(xZ, recurrentZ));
        r = this.recurrentActivation.apply(add6(xR, recurrentR));
        const recurrentH = dot5(mul4(r, hTMinus1), rk2);
        hh = this.activation.apply(add6(xH, recurrentH));
        const h2 = add6(mul4(z, hTMinus1), mul4(add6(1, neg(z)), hh));
        return [h2, h2];
      });
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        recurrentActivation: serializeActivation(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        recurrentInitializer: serializeInitializer(this.recurrentInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        recurrentConstraint: serializeConstraint(this.recurrentConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation,
        resetAfter: false
      };
      return Object.assign({}, baseConfig, config);
    }
  };
  GRUCell.className = "GRUCell";
  serialization_exports.registerClass(GRUCell);
  var GRU = class extends RNN {
    constructor(args) {
      if (args.implementation === 0) {
        console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
      }
      args.cell = new GRUCell(args);
      super(args);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training, initialState });
      });
    }
    static fromConfig(cls, config) {
      if (config["implmentation"] === 0) {
        config["implementation"] = 1;
      }
      return new cls(config);
    }
  };
  GRU.className = "GRU";
  serialization_exports.registerClass(GRU);
  var LSTMCell = class extends RNNCell {
    constructor(args) {
      super(args);
      this.DEFAULT_ACTIVATION = "tanh";
      this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      this.units = args.units;
      assertPositiveInteger(this.units, "units");
      this.activation = getActivation(args.activation === void 0 ? this.DEFAULT_ACTIVATION : args.activation);
      this.recurrentActivation = getActivation(args.recurrentActivation === void 0 ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.unitForgetBias = args.unitForgetBias;
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.kernelConstraint = getConstraint2(args.kernelConstraint);
      this.recurrentConstraint = getConstraint2(args.recurrentConstraint);
      this.biasConstraint = getConstraint2(args.biasConstraint);
      this.dropout = min4([1, max4([0, args.dropout == null ? 0 : args.dropout])]);
      this.recurrentDropout = min4([
        1,
        max4([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
      ]);
      this.dropoutFunc = args.dropoutFunc;
      this.implementation = args.implementation;
      this.stateSize = [this.units, this.units];
      this.dropoutMask = null;
      this.recurrentDropoutMask = null;
    }
    build(inputShape) {
      var _a4;
      inputShape = getExactlyOneShape(inputShape);
      const inputDim = inputShape[inputShape.length - 1];
      this.kernel = this.addWeight("kernel", [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      let biasInitializer;
      if (this.useBias) {
        if (this.unitForgetBias) {
          const capturedBiasInit = this.biasInitializer;
          const capturedUnits = this.units;
          biasInitializer = new (_a4 = class CustomInit extends Initializer {
            apply(shape, dtype) {
              const bI = capturedBiasInit.apply([capturedUnits]);
              const bF = new Ones().apply([capturedUnits]);
              const bCAndH = capturedBiasInit.apply([capturedUnits * 2]);
              return concatAlongFirstAxis(concatAlongFirstAxis(bI, bF), bCAndH);
            }
          }, _a4.className = "CustomInit", _a4)();
        } else {
          biasInitializer = this.biasInitializer;
        }
        this.bias = this.addWeight("bias", [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const training = kwargs["training"] == null ? false : kwargs["training"];
        inputs = inputs;
        if (inputs.length !== 3) {
          throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);
        }
        let hTMinus1 = inputs[1];
        const cTMinus1 = inputs[2];
        inputs = inputs[0];
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(inputs),
            rate: this.dropout,
            training,
            count: 4,
            dropoutFunc: this.dropoutFunc
          });
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(hTMinus1),
            rate: this.recurrentDropout,
            training,
            count: 4,
            dropoutFunc: this.dropoutFunc
          });
        }
        const dpMask = this.dropoutMask;
        const recDpMask = this.recurrentDropoutMask;
        let i;
        let f;
        let c;
        let o;
        if (0 < this.dropout && this.dropout < 1) {
          inputs = mul4(inputs, dpMask[0]);
        }
        let z = dot5(inputs, this.kernel.read());
        if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
          hTMinus1 = mul4(hTMinus1, recDpMask[0]);
        }
        z = add6(z, dot5(hTMinus1, this.recurrentKernel.read()));
        if (this.useBias) {
          z = biasAdd(z, this.bias.read());
        }
        const [z0, z1, z2, z3] = split(z, 4, z.rank - 1);
        i = this.recurrentActivation.apply(z0);
        f = this.recurrentActivation.apply(z1);
        c = add6(mul4(f, cTMinus1), mul4(i, this.activation.apply(z2)));
        o = this.recurrentActivation.apply(z3);
        const h2 = mul4(o, this.activation.apply(c));
        return [h2, h2, c];
      });
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        recurrentActivation: serializeActivation(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        recurrentInitializer: serializeInitializer(this.recurrentInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        recurrentConstraint: serializeConstraint(this.recurrentConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
      };
      return Object.assign({}, baseConfig, config);
    }
  };
  LSTMCell.className = "LSTMCell";
  serialization_exports.registerClass(LSTMCell);
  var LSTM = class extends RNN {
    constructor(args) {
      if (args.implementation === 0) {
        console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call.");
      }
      args.cell = new LSTMCell(args);
      super(args);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training, initialState });
      });
    }
    static fromConfig(cls, config) {
      if (config["implmentation"] === 0) {
        config["implementation"] = 1;
      }
      return new cls(config);
    }
  };
  LSTM.className = "LSTM";
  serialization_exports.registerClass(LSTM);
  var StackedRNNCells = class extends RNNCell {
    constructor(args) {
      super(args);
      this.cells = args.cells;
    }
    get stateSize() {
      const stateSize = [];
      for (const cell of this.cells.slice().reverse()) {
        if (Array.isArray(cell.stateSize)) {
          stateSize.push(...cell.stateSize);
        } else {
          stateSize.push(cell.stateSize);
        }
      }
      return stateSize;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        let states = inputs.slice(1);
        const nestedStates = [];
        for (const cell of this.cells.slice().reverse()) {
          if (Array.isArray(cell.stateSize)) {
            nestedStates.push(states.splice(0, cell.stateSize.length));
          } else {
            nestedStates.push(states.splice(0, 1));
          }
        }
        nestedStates.reverse();
        const newNestedStates = [];
        let callInputs;
        for (let i = 0; i < this.cells.length; ++i) {
          const cell = this.cells[i];
          states = nestedStates[i];
          if (i === 0) {
            callInputs = [inputs[0]].concat(states);
          } else {
            callInputs = [callInputs[0]].concat(states);
          }
          callInputs = cell.call(callInputs, kwargs);
          newNestedStates.push(callInputs.slice(1));
        }
        states = [];
        for (const cellStates of newNestedStates.slice().reverse()) {
          states.push(...cellStates);
        }
        return [callInputs[0]].concat(states);
      });
    }
    build(inputShape) {
      if (isArrayOfShapes(inputShape)) {
        inputShape = inputShape[0];
      }
      inputShape = inputShape;
      let outputDim;
      this.cells.forEach((cell, i) => {
        nameScope(`RNNCell_${i}`, () => {
          cell.build(inputShape);
          if (Array.isArray(cell.stateSize)) {
            outputDim = cell.stateSize[0];
          } else {
            outputDim = cell.stateSize;
          }
          inputShape = [inputShape[0], outputDim];
        });
      });
      this.built = true;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const getCellConfig = (cell) => {
        return {
          "className": cell.getClassName(),
          "config": cell.getConfig()
        };
      };
      const cellConfigs = this.cells.map(getCellConfig);
      const config = { "cells": cellConfigs };
      return Object.assign({}, baseConfig, config);
    }
    static fromConfig(cls, config, customObjects = {}) {
      const cells = [];
      for (const cellConfig of config["cells"]) {
        cells.push(deserialize(cellConfig, customObjects));
      }
      return new cls({ cells });
    }
    get trainableWeights() {
      if (!this.trainable) {
        return [];
      }
      const weights = [];
      for (const cell of this.cells) {
        weights.push(...cell.trainableWeights);
      }
      return weights;
    }
    get nonTrainableWeights() {
      const weights = [];
      for (const cell of this.cells) {
        weights.push(...cell.nonTrainableWeights);
      }
      if (!this.trainable) {
        const trainableWeights = [];
        for (const cell of this.cells) {
          trainableWeights.push(...cell.trainableWeights);
        }
        return trainableWeights.concat(weights);
      }
      return weights;
    }
    getWeights() {
      const weights = [];
      for (const cell of this.cells) {
        weights.push(...cell.weights);
      }
      return batchGetValue(weights);
    }
    setWeights(weights) {
      const tuples = [];
      for (const cell of this.cells) {
        const numParams = cell.weights.length;
        const inputWeights = weights.splice(numParams);
        for (let i = 0; i < cell.weights.length; ++i) {
          tuples.push([cell.weights[i], inputWeights[i]]);
        }
      }
      batchSetValue(tuples);
    }
  };
  StackedRNNCells.className = "StackedRNNCells";
  serialization_exports.registerClass(StackedRNNCells);
  function generateDropoutMask(args) {
    const { ones: ones3, rate, training = false, count: count2 = 1, dropoutFunc } = args;
    const droppedInputs = () => dropoutFunc != null ? dropoutFunc(ones3(), rate) : dropout2(ones3(), rate);
    const createMask = () => inTrainPhase(droppedInputs, ones3, training);
    if (!count2 || count2 <= 1) {
      return keep(createMask().clone());
    }
    const masks = Array(count2).fill(void 0).map(createMask);
    return masks.map((m) => keep(m.clone()));
  }

  // node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js
  var __rest10 = function(s, e) {
    var t = {};
    for (var p3 in s)
      if (Object.prototype.hasOwnProperty.call(s, p3) && e.indexOf(p3) < 0)
        t[p3] = s[p3];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p3 = Object.getOwnPropertySymbols(s); i < p3.length; i++) {
        if (e.indexOf(p3[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i]))
          t[p3[i]] = s[p3[i]];
      }
    return t;
  };
  var ConvRNN2D = class extends RNN {
    constructor(args) {
      if (args.unroll) {
        throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");
      }
      if (Array.isArray(args.cell)) {
        throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");
      }
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 5 })];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        if (kwargs && kwargs["constants"]) {
          throw new ValueError("ConvRNN2D cell does not support constants");
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training, initialState });
      });
    }
    computeOutputShape(inputShape) {
      let outShape = this.computeSingleOutputShape(inputShape);
      if (!this.returnSequences) {
        outShape = [outShape[0], ...outShape.slice(2)];
      }
      if (this.returnState) {
        outShape = [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];
      }
      return outShape;
    }
    getInitialState(inputs) {
      return tidy(() => {
        const { stateSize } = this.cell;
        const inputShape = inputs.shape;
        const outputShape = this.computeSingleOutputShape(inputShape);
        const stateShape = [outputShape[0], ...outputShape.slice(2)];
        const initialState = zeros(stateShape);
        if (Array.isArray(stateSize)) {
          return Array(stateSize.length).fill(initialState);
        }
        return [initialState];
      });
    }
    resetStates(states, training = false) {
      tidy(() => {
        if (!this.stateful) {
          throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
        }
        const inputShape = this.inputSpec[0].shape;
        const outputShape = this.computeSingleOutputShape(inputShape);
        const stateShape = [outputShape[0], ...outputShape.slice(2)];
        const batchSize = inputShape[0];
        if (batchSize == null) {
          throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
        }
        if (this.getStates() == null) {
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map(() => zeros(stateShape));
          } else {
            this.states_ = [zeros(stateShape)];
          }
        } else if (states == null) {
          dispose(this.states_);
          if (this.keptStates != null) {
            dispose(this.keptStates);
            this.keptStates = [];
          }
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map(() => zeros(stateShape));
          } else {
            this.states_[0] = zeros(stateShape);
          }
        } else {
          if (!Array.isArray(states)) {
            states = [states];
          }
          if (states.length !== this.states_.length) {
            throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${states.length} state value(s). Input received: ${states}`);
          }
          if (training) {
            this.keptStates.push(this.states_.slice());
          } else {
            dispose(this.states_);
          }
          for (let index = 0; index < this.states_.length; ++index) {
            const value = states[index];
            const expectedShape = stateShape;
            if (!util_exports2.arraysEqual(value.shape, expectedShape)) {
              throw new ValueError(`State ${index} is incompatible with layer ${this.name}: expected shape=${expectedShape}, received shape=${value.shape}`);
            }
            this.states_[index] = value;
          }
        }
        this.states_ = this.states_.map((state) => keep(state.clone()));
      });
    }
    computeSingleOutputShape(inputShape) {
      const { dataFormat, filters, kernelSize, padding, strides, dilationRate } = this.cell;
      const isChannelsFirst = dataFormat === "channelsFirst";
      const h2 = inputShape[isChannelsFirst ? 3 : 2];
      const w = inputShape[isChannelsFirst ? 4 : 3];
      const hOut = convOutputLength(h2, kernelSize[0], padding, strides[0], dilationRate[0]);
      const wOut = convOutputLength(w, kernelSize[1], padding, strides[1], dilationRate[1]);
      const outShape = [
        ...inputShape.slice(0, 2),
        ...isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters]
      ];
      return outShape;
    }
  };
  ConvRNN2D.className = "ConvRNN2D";
  var ConvLSTM2DCell = class extends LSTMCell {
    constructor(args) {
      const { filters, kernelSize, strides, padding, dataFormat, dilationRate } = args;
      super(Object.assign({}, args, { units: filters }));
      this.filters = filters;
      assertPositiveInteger(this.filters, "filters");
      this.kernelSize = normalizeArray(kernelSize, 2, "kernelSize");
      this.kernelSize.forEach((size3) => assertPositiveInteger(size3, "kernelSize"));
      this.strides = normalizeArray(strides || 1, 2, "strides");
      this.strides.forEach((stride) => assertPositiveInteger(stride, "strides"));
      this.padding = padding || "valid";
      checkPaddingMode(this.padding);
      this.dataFormat = dataFormat || "channelsLast";
      checkDataFormat(this.dataFormat);
      this.dilationRate = normalizeArray(dilationRate || 1, 2, "dilationRate");
      this.dilationRate.forEach((rate) => assertPositiveInteger(rate, "dilationRate"));
    }
    build(inputShape) {
      var _a4;
      inputShape = getExactlyOneShape(inputShape);
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError(`The channel dimension of the input should be defined. Found ${inputShape[channelAxis]}`);
      }
      const inputDim = inputShape[channelAxis];
      const numOfKernels = 4;
      const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);
      this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);
      this.recurrentKernel = this.addWeight("recurrent_kernel", recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      if (this.useBias) {
        let biasInitializer;
        if (this.unitForgetBias) {
          const init = this.biasInitializer;
          const filters = this.filters;
          biasInitializer = new (_a4 = class CustomInit extends Initializer {
            apply(shape, dtype) {
              const biasI = init.apply([filters]);
              const biasF = ones2([filters]);
              const biasCAndO = init.apply([filters * 2]);
              return concatenate([biasI, biasF, biasCAndO]);
            }
          }, _a4.className = "CustomInit", _a4)();
        } else {
          biasInitializer = this.biasInitializer;
        }
        this.bias = this.addWeight("bias", [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (inputs.length !== 3) {
          throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${inputs.length}.`);
        }
        const training = kwargs["training"] || false;
        const x = inputs[0];
        const hTMinus1 = inputs[1];
        const cTMinus1 = inputs[2];
        const numOfKernels = 4;
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(x),
            rate: this.dropout,
            training,
            count: numOfKernels,
            dropoutFunc: this.dropoutFunc
          });
        }
        const dropoutMask = this.dropoutMask;
        const applyDropout = (x2, mask, index) => {
          if (!mask || !mask[index]) {
            return x2;
          }
          return mul4(mask[index], x2);
        };
        let xI = applyDropout(x, dropoutMask, 0);
        let xF = applyDropout(x, dropoutMask, 1);
        let xC = applyDropout(x, dropoutMask, 2);
        let xO = applyDropout(x, dropoutMask, 3);
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(hTMinus1),
            rate: this.recurrentDropout,
            training,
            count: numOfKernels,
            dropoutFunc: this.dropoutFunc
          });
        }
        const recDropoutMask = this.recurrentDropoutMask;
        let hI = applyDropout(hTMinus1, recDropoutMask, 0);
        let hF = applyDropout(hTMinus1, recDropoutMask, 1);
        let hC = applyDropout(hTMinus1, recDropoutMask, 2);
        let hO = applyDropout(hTMinus1, recDropoutMask, 3);
        const kernelChannelAxis = 3;
        const [kernelI, kernelF, kernelC, kernelO] = split(this.kernel.read(), numOfKernels, kernelChannelAxis);
        const [biasI, biasF, biasC, biasO] = this.useBias ? split(this.bias.read(), numOfKernels) : [null, null, null, null];
        xI = this.inputConv(xI, kernelI, biasI, this.padding);
        xF = this.inputConv(xF, kernelF, biasF, this.padding);
        xC = this.inputConv(xC, kernelC, biasC, this.padding);
        xO = this.inputConv(xO, kernelO, biasO, this.padding);
        const [recKernelI, recKernelF, recKernelC, recKernelO] = split(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);
        hI = this.recurrentConv(hI, recKernelI);
        hF = this.recurrentConv(hF, recKernelF);
        hC = this.recurrentConv(hC, recKernelC);
        hO = this.recurrentConv(hO, recKernelO);
        const i = this.recurrentActivation.apply(add6(xI, hI));
        const f = this.recurrentActivation.apply(add6(xF, hF));
        const c = add6(mul4(f, cTMinus1), mul4(i, this.activation.apply(add6(xC, hC))));
        const h2 = mul4(this.recurrentActivation.apply(add6(xO, hO)), this.activation.apply(c));
        return [h2, h2, c];
      });
    }
    getConfig() {
      const _a4 = super.getConfig(), { "units": _6 } = _a4, baseConfig = __rest10(_a4, ["units"]);
      const config = {
        filters: this.filters,
        kernelSize: this.kernelSize,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        strides: this.strides
      };
      return Object.assign({}, baseConfig, config);
    }
    inputConv(x, w, b, padding) {
      const out = conv2d(x, w, this.strides, padding || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
      if (b) {
        return biasAdd(out, b, this.dataFormat);
      }
      return out;
    }
    recurrentConv(x, w) {
      const strides = 1;
      return conv2d(x, w, strides, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
    }
  };
  ConvLSTM2DCell.className = "ConvLSTM2DCell";
  serialization_exports.registerClass(ConvLSTM2DCell);
  var ConvLSTM2D = class extends ConvRNN2D {
    constructor(args) {
      const cell = new ConvLSTM2DCell(args);
      super(Object.assign({}, args, { cell }));
    }
    static fromConfig(cls, config) {
      return new cls(config);
    }
  };
  ConvLSTM2D.className = "ConvLSTM2D";
  serialization_exports.registerClass(ConvLSTM2D);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/core.js
  var Dropout = class extends Layer {
    constructor(args) {
      super(args);
      this.rate = Math.max(Math.min(args.rate, 1), 0);
      this.noiseShape = args.noiseShape;
      this.seed = args.seed;
      this.supportsMasking = true;
    }
    getNoiseShape(input2) {
      if (this.noiseShape == null) {
        return this.noiseShape;
      }
      const inputShape = input2.shape;
      const noiseShape = [];
      for (let i = 0; i < this.noiseShape.length; ++i) {
        noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);
      }
      return noiseShape;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        if (0 < this.rate && this.rate < 1) {
          const training = kwargs["training"] == null ? false : kwargs["training"];
          const noiseShape = this.getNoiseShape(input2);
          const output = inTrainPhase(() => dropout2(input2, this.rate, noiseShape, this.seed), () => input2, training);
          return output;
        }
        return inputs;
      });
    }
    getConfig() {
      const config = {
        rate: this.rate,
        noiseShape: this.noiseShape,
        seed: this.seed
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    dispose() {
      return super.dispose();
    }
  };
  Dropout.className = "Dropout";
  serialization_exports.registerClass(Dropout);
  var SpatialDropout1D = class extends Dropout {
    constructor(args) {
      super(args);
      this.inputSpec = [{ ndim: 3 }];
    }
    getNoiseShape(input2) {
      const inputShape = input2.shape;
      return [inputShape[0], 1, inputShape[2]];
    }
  };
  SpatialDropout1D.className = "SpatialDropout1D";
  serialization_exports.registerClass(SpatialDropout1D);
  var Dense = class extends Layer {
    constructor(args) {
      super(args);
      this.activation = null;
      this.useBias = true;
      this.kernel = null;
      this.bias = null;
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      if (args.batchInputShape == null && args.inputShape == null && args.inputDim != null) {
        let batchSize = null;
        if (args.batchSize != null) {
          batchSize = args.batchSize;
        }
        this.batchInputShape = [batchSize, args.inputDim];
      }
      this.units = args.units;
      assertPositiveInteger(this.units, "units");
      this.activation = getActivation(args.activation);
      if (args.useBias != null) {
        this.useBias = args.useBias;
      }
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.kernelConstraint = getConstraint2(args.kernelConstraint);
      this.biasConstraint = getConstraint2(args.biasConstraint);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.activityRegularizer = getRegularizer(args.activityRegularizer);
      this.supportsMasking = true;
      this.inputSpec = [{ minNDim: 2 }];
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const inputLastDim = inputShape[inputShape.length - 1];
      if (this.kernel == null) {
        this.kernel = this.addWeight("kernel", [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
      }
      this.inputSpec = [{ minNDim: 2, axes: { [-1]: inputLastDim } }];
      this.built = true;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      outputShape[outputShape.length - 1] = this.units;
      return outputShape;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
        let output;
        if (fusedActivationName != null) {
          output = dot5(input2, this.kernel.read(), fusedActivationName, this.bias ? this.bias.read() : null);
        } else {
          output = dot5(input2, this.kernel.read());
          if (this.bias != null) {
            output = biasAdd(output, this.bias.read());
          }
          if (this.activation != null) {
            output = this.activation.apply(output);
          }
        }
        return output;
      });
    }
    getConfig() {
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Dense.className = "Dense";
  serialization_exports.registerClass(Dense);
  var Flatten = class extends Layer {
    constructor(args) {
      args = args || {};
      super(args);
      this.inputSpec = [{ minNDim: 3 }];
      this.dataFormat = args.dataFormat;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      for (const dim of inputShape.slice(1)) {
        if (dim == null) {
          throw new ValueError(`The shape of the input to "Flatten" is not fully defined (got ${inputShape.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);
        }
      }
      return [inputShape[0], arrayProd(inputShape, 1)];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        let input2 = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsFirst" && input2.rank > 1) {
          const permutation = [0];
          for (let i = 2; i < input2.rank; ++i) {
            permutation.push(i);
          }
          permutation.push(1);
          input2 = transpose2(input2, permutation);
        }
        return batchFlatten(input2);
      });
    }
    getConfig() {
      const config = {};
      if (this.dataFormat != null) {
        config["dataFormat"] = this.dataFormat;
      }
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Flatten.className = "Flatten";
  serialization_exports.registerClass(Flatten);
  var Activation2 = class extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.activation = getActivation(args.activation);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        return this.activation.apply(input2);
      });
    }
    getConfig() {
      const config = { activation: serializeActivation(this.activation) };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Activation2.className = "Activation";
  serialization_exports.registerClass(Activation2);
  var RepeatVector = class extends Layer {
    constructor(args) {
      super(args);
      this.n = args.n;
      this.inputSpec = [{ ndim: 2 }];
    }
    computeOutputShape(inputShape) {
      return [inputShape[0], this.n, inputShape[1]];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        return repeat(inputs, this.n);
      });
    }
    getConfig() {
      const config = {
        n: this.n
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  RepeatVector.className = "RepeatVector";
  serialization_exports.registerClass(RepeatVector);
  var Reshape2 = class extends Layer {
    constructor(args) {
      super(args);
      this.targetShape = args.targetShape;
      for (let i = 0; i < this.targetShape.length; ++i) {
        if (this.isUnknown(this.targetShape[i])) {
          this.targetShape[i] = null;
        }
      }
    }
    isUnknown(dim) {
      return dim < 0 || dim == null;
    }
    fixUnknownDimension(inputShape, outputShape) {
      const errorMsg = "Total size of new array must be unchanged.";
      const finalShape = outputShape.slice();
      let known = 1;
      let unknown = null;
      for (let i = 0; i < finalShape.length; ++i) {
        const dim = finalShape[i];
        if (this.isUnknown(dim)) {
          if (unknown === null) {
            unknown = i;
          } else {
            throw new ValueError("Can only specifiy one unknown dimension.");
          }
        } else {
          known *= dim;
        }
      }
      const originalSize = arrayProd(inputShape);
      if (unknown !== null) {
        if (known === 0 || originalSize % known !== 0) {
          throw new ValueError(errorMsg);
        }
        finalShape[unknown] = originalSize / known;
      } else if (originalSize !== known) {
        throw new ValueError(errorMsg);
      }
      return finalShape;
    }
    computeOutputShape(inputShape) {
      let anyUnknownDims = false;
      for (let i = 0; i < inputShape.length; ++i) {
        if (this.isUnknown(inputShape[i])) {
          anyUnknownDims = true;
          break;
        }
      }
      if (anyUnknownDims) {
        return inputShape.slice(0, 1).concat(this.targetShape);
      } else {
        return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        const outputShape = inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
        return reshape(input2, outputShape);
      });
    }
    getConfig() {
      const config = {
        targetShape: this.targetShape
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Reshape2.className = "Reshape";
  serialization_exports.registerClass(Reshape2);
  var Permute = class extends Layer {
    constructor(args) {
      super(args);
      if (args.dims == null) {
        throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
      }
      if (!Array.isArray(args.dims)) {
        throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${args.dims} instead.`);
      }
      const expectedSortedIndices = range2(1, args.dims.length + 1);
      if (!util_exports2.arraysEqual(args.dims.slice().sort(), expectedSortedIndices)) {
        throw new Error("Invalid permutation `dims`: " + JSON.stringify(args.dims) + " `dims` must contain consecutive integers starting from 1.");
      }
      this.dims = args.dims;
      this.dimsIncludingBatch = [0].concat(this.dims);
      this.inputSpec = [new InputSpec({ ndim: this.dims.length + 1 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      this.dims.forEach((dim, i) => {
        outputShape[i + 1] = inputShape[dim];
      });
      return outputShape;
    }
    call(inputs, kwargs) {
      return transpose2(getExactlyOneTensor(inputs), this.dimsIncludingBatch);
    }
    getConfig() {
      const config = {
        dims: this.dims
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Permute.className = "Permute";
  serialization_exports.registerClass(Permute);
  var Masking = class extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.supportsMasking = true;
      if (args != null) {
        this.maskValue = args.maskValue == null ? 0 : args.maskValue;
      } else {
        this.maskValue = 0;
      }
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { maskValue: this.maskValue };
      Object.assign(config, baseConfig);
      return config;
    }
    computeMask(inputs, mask) {
      const input2 = getExactlyOneTensor(inputs);
      const axis = -1;
      return any(notEqual(input2, this.maskValue), axis);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const axis = -1;
        const keepDims = true;
        const booleanMask = any(notEqual(input2, this.maskValue), axis, keepDims);
        const output = mul4(input2, cast(booleanMask, input2.dtype));
        return output;
      });
    }
  };
  Masking.className = "Masking";
  serialization_exports.registerClass(Masking);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/embeddings.js
  var Embedding = class extends Layer {
    constructor(args) {
      super(args);
      this.embeddings = null;
      this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform";
      if (args.batchInputShape == null && args.inputShape == null) {
        let batchSize = null;
        if (args.batchSize != null) {
          batchSize = args.batchSize;
        }
        if (args.inputLength == null) {
          this.batchInputShape = [batchSize, null];
        } else {
          this.batchInputShape = [batchSize].concat(toList(args.inputLength));
        }
      }
      this.inputDim = args.inputDim;
      assertPositiveInteger(this.inputDim, "inputDim");
      this.outputDim = args.outputDim;
      assertPositiveInteger(this.outputDim, "outputDim");
      this.embeddingsInitializer = getInitializer(args.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER);
      this.embeddingsRegularizer = getRegularizer(args.embeddingsRegularizer);
      this.activityRegularizer = getRegularizer(args.activityRegularizer);
      this.embeddingsConstraint = getConstraint2(args.embeddingsConstraint);
      this.maskZero = args.maskZero;
      this.supportsMasking = args.maskZero;
      this.inputLength = args.inputLength;
    }
    build(inputShape) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
      this.built = true;
    }
    warnOnIncompatibleInputShape(inputShape) {
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        if (!this.maskZero) {
          return null;
        } else {
          inputs = getExactlyOneTensor(inputs);
          return notEqual(inputs, zerosLike(inputs));
        }
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (this.inputLength == null) {
        return [...inputShape, this.outputDim];
      }
      const inLens = toList(this.inputLength);
      if (inLens.length !== inputShape.length - 1) {
        throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);
      } else {
        let i = 0;
        for (let k = 0; k < inLens.length; ++k) {
          const s1 = inLens[k];
          const s2 = inputShape[k + 1];
          if (s1 != null && s2 != null && s1 !== s2) {
            throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${inputShape}`);
          } else if (s1 == null) {
            inLens[i] = s2;
          }
          i++;
        }
      }
      return [inputShape[0], ...inLens, this.outputDim];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        let input2 = getExactlyOneTensor(inputs);
        if (input2.dtype !== "int32") {
          input2 = cast2(input2, "int32");
        }
        const output = gather2(this.embeddings.read(), reshape(input2, [input2.size]));
        return reshape(output, getExactlyOneShape(this.computeOutputShape(input2.shape)));
      });
    }
    getConfig() {
      const config = {
        inputDim: this.inputDim,
        outputDim: this.outputDim,
        embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
        embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
        maskZero: this.maskZero,
        inputLength: this.inputLength
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Embedding.className = "Embedding";
  serialization_exports.registerClass(Embedding);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/merge.js
  var Merge = class extends Layer {
    constructor(args) {
      super(args || {});
      this.supportsMasking = true;
    }
    mergeFunction(inputs) {
      throw new NotImplementedError();
    }
    computeElementwiseOpOutputShape(shape1, shape2) {
      if (shape1 == null || shape2 == null) {
        return null;
      } else if (shape1.length < shape2.length) {
        return this.computeElementwiseOpOutputShape(shape2, shape1);
      } else if (shape2.length === 0) {
        return shape1;
      }
      const outputShape = shape1.slice(0, shape1.length - shape2.length);
      for (let k = 0; k < shape2.length; ++k) {
        const i = shape1[shape1.length - shape2.length + k];
        const j = shape2[k];
        if (i == null || j == null || i < 0 || j < 0) {
          outputShape.push(null);
        } else if (i === 1) {
          outputShape.push(j);
        } else if (j === 1) {
          outputShape.push(i);
        } else {
          if (i !== j) {
            throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(shape1) + " " + JSON.stringify(shape2));
          }
          outputShape.push(i);
        }
      }
      return outputShape;
    }
    build(inputShape) {
      if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
        inputShape = [getExactlyOneShape(inputShape)];
      }
      inputShape = inputShape;
      if (inputShape.length < 2) {
        throw new ValueError(`A merge layer should be called on an Array of at least 2 inputs. Got ${inputShape.length} input(s).`);
      }
      let batchSizes = [];
      for (const shape of inputShape) {
        if (shape != null && shape[0] !== null) {
          batchSizes.push(shape[0]);
        }
      }
      batchSizes = unique2(batchSizes);
      if (batchSizes.length > 1) {
        throw new ValueError(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(inputShape)}.`);
      }
      let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
      for (let i = 1; i < inputShape.length; ++i) {
        const shape = inputShape[i] == null ? null : inputShape[i].slice(1);
        outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
      }
      const allRanks = inputShape.map((shape) => shape.length);
      if (inputShape.indexOf(null) === -1 && unique2(allRanks).length === 1) {
        this.reshapeRequired = false;
      } else {
        this.reshapeRequired = true;
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        if (this.reshapeRequired) {
          const reshapedInputs = [];
          const inputDims = inputs.map((input2) => input2.rank);
          if (inputDims.indexOf(null) === -1) {
            const maxNDim = max4(inputDims);
            for (let x of inputs) {
              const xNDim = x.rank;
              for (let k = 0; k < maxNDim - xNDim; ++k) {
                x = expandDims2(x, 1);
              }
              reshapedInputs.push(x);
            }
            return this.mergeFunction(reshapedInputs);
          } else {
            let transposed = false;
            for (const x of inputs) {
              const xNDim = x.rank;
              if (xNDim == null) {
                const xShape = x.shape;
                const batchSize = xShape[0];
                const newShape = xShape.slice(1).concat([batchSize]);
                let xTransposed = reshape(x, [batchSize].concat(arrayProd(xShape.slice(1))));
                xTransposed = transpose2(xTransposed, [1, 0]);
                xTransposed = reshape(xTransposed, newShape);
                reshapedInputs.push(xTransposed);
                transposed = true;
              } else if (xNDim > 1) {
                const dims = range2(1, xNDim).concat([0]);
                reshapedInputs.push(transpose2(x, dims));
                transposed = true;
              } else {
                reshapedInputs.push(x);
              }
            }
            let y = this.mergeFunction(reshapedInputs);
            const yNDim = y.rank;
            if (transposed) {
              if (yNDim == null) {
                const yShape = y.shape;
                const yNDim2 = yShape.length;
                const batchSize = yShape[yNDim2 - 1];
                const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                y = reshape(transpose2(reshape(y, [-1, batchSize]), [1, 0]), newShape);
              } else if (yNDim > 1) {
                const dims = [yNDim - 1].concat(range2(0, yNDim - 1));
                y = transpose2(y, dims);
              }
            }
            return y;
          }
        } else {
          return this.mergeFunction(inputs);
        }
      });
    }
    computeOutputShape(inputShape) {
      inputShape = inputShape;
      let outputShape;
      if (inputShape[0] == null) {
        outputShape = null;
      } else {
        outputShape = inputShape[0].slice(1);
      }
      for (let i = 1; i < inputShape.length; ++i) {
        const shape = inputShape[i] == null ? null : inputShape[i].slice(1);
        outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
      }
      let batchSizes = [];
      for (const shape of inputShape) {
        if (shape != null && shape[0] !== null) {
          batchSizes.push(shape[0]);
        }
      }
      batchSizes = unique2(batchSizes);
      if (batchSizes.length === 1) {
        outputShape = batchSizes.concat(outputShape);
      } else {
        outputShape = [null].concat(outputShape);
      }
      return outputShape;
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        if (mask == null) {
          return null;
        }
        if (!Array.isArray(mask)) {
          throw new ValueError("`mask` should be an Array");
        }
        if (!Array.isArray(inputs)) {
          throw new ValueError("`inputs` should be an Array");
        }
        if (mask.length !== inputs.length) {
          throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${inputs.length} vs ${mask.length})`);
        }
        if (mask.every((m) => m == null)) {
          return null;
        }
        mask = mask.map((m) => m == null ? m : expandDims(m, 0));
        let output = mask[0];
        for (let i = 1; i < mask.length - 1; ++i) {
          output = logicalAnd(output, mask[i]);
        }
        return output;
      });
    }
  };
  var Add2 = class extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0].clone();
        for (let i = 1; i < inputs.length; ++i) {
          output = add6(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Add2.className = "Add";
  serialization_exports.registerClass(Add2);
  var Multiply2 = class extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0].clone();
        for (let i = 1; i < inputs.length; ++i) {
          output = mul4(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Multiply2.className = "Multiply";
  serialization_exports.registerClass(Multiply2);
  var Average = class extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0].clone();
        for (let i = 1; i < inputs.length; ++i) {
          output = add6(output, inputs[i]);
        }
        return mul4(1 / inputs.length, output);
      });
    }
  };
  Average.className = "Average";
  serialization_exports.registerClass(Average);
  var Maximum2 = class extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0];
        for (let i = 1; i < inputs.length; ++i) {
          output = maximum(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Maximum2.className = "Maximum";
  serialization_exports.registerClass(Maximum2);
  var Minimum2 = class extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0];
        for (let i = 1; i < inputs.length; ++i) {
          output = minimum(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Minimum2.className = "Minimum";
  serialization_exports.registerClass(Minimum2);
  var Concatenate = class extends Merge {
    constructor(args) {
      super(args);
      this.DEFAULT_AXIS = -1;
      if (args == null) {
        args = {};
      }
      this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
      this.supportsMasking = true;
      this.reshapeRequired = false;
    }
    build(inputShape) {
      if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {
        throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");
      }
      inputShape = inputShape;
      let allNoneShape = true;
      for (const shape of inputShape) {
        if (shape != null) {
          allNoneShape = false;
          break;
        }
      }
      if (allNoneShape) {
        return;
      }
      const shapeSet = [];
      for (let i = 0; i < inputShape.length; ++i) {
        const shapeWithoutConcatAxis = inputShape[i].slice();
        shapeWithoutConcatAxis.splice(this.axis, 1);
        let exists = false;
        for (const shape of shapeSet) {
          if (util_exports2.arraysEqual(shape, shapeWithoutConcatAxis)) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          shapeSet.push(shapeWithoutConcatAxis);
        }
      }
      if (shapeSet.length > 1) {
        throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(inputShape));
      }
    }
    mergeFunction(inputs) {
      return tidy(() => {
        return concatenate(inputs, this.axis);
      });
    }
    computeOutputShape(inputShape) {
      if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
        throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");
      }
      const inputShapes = inputShape;
      const outputShape = inputShapes[0].slice();
      const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
      for (const shape of inputShapes.slice(1)) {
        if (outputShape[axis] == null || shape[axis] == null) {
          outputShape[axis] = null;
          break;
        }
        outputShape[axis] += shape[axis];
      }
      return outputShape;
    }
    computeMask(inputs, mask) {
      if (mask == null) {
        return null;
      }
      if (!Array.isArray(mask)) {
        throw new ValueError("`mask` should be an array for Concatenate");
      }
      if (!Array.isArray(inputs)) {
        throw new ValueError("`inputs` should be an array for Concatenate");
      }
      if (mask.length !== inputs.length) {
        throw new ValueError(`Mismatch in the length of mask (${mask.length}) and the legnth of inputs (${inputs.length})`);
      }
      return tidy(() => {
        let allNullMasks = true;
        mask.forEach((m) => {
          if (m != null) {
            allNullMasks = false;
            return;
          }
        });
        if (allNullMasks) {
          return null;
        }
        const outputMasks = [];
        for (let i = 0; i < inputs.length; ++i) {
          if (mask[i] == null) {
            outputMasks.push(cast(onesLike(inputs[i]), "bool"));
          } else if (mask[i].rank < inputs[i].rank) {
            outputMasks.push(expandDims(mask[i], -1));
          } else {
            outputMasks.push(mask[i]);
          }
        }
        const concatenatedMasks = concat(outputMasks, this.axis);
        return all(concatenatedMasks, -1, false);
      });
    }
    getConfig() {
      const config = {
        "axis": this.axis
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Concatenate.className = "Concatenate";
  serialization_exports.registerClass(Concatenate);
  function interpretAxis(axis, dim) {
    while (axis < 0) {
      axis += dim;
    }
    return axis;
  }
  function batchDot(x, y, axes) {
    if (x.shape.length > 3 || y.shape.length > 3) {
      throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
    }
    util_exports2.assert(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, but got ${x.shape.length}`);
    util_exports2.assert(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, but got ${y.shape.length}`);
    if (typeof axes === "number") {
      axes = [axes, axes];
    }
    if (x.dtype === "complex64" || y.dtype === "complex64") {
      throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
    }
    const xNDim = x.shape.length;
    const yNDim = y.shape.length;
    if (axes == null) {
      axes = [xNDim - 1, yNDim - 2];
    }
    const axesArray = axes;
    return tidy(() => {
      let diff2;
      if (xNDim > yNDim) {
        diff2 = xNDim - yNDim;
        const diffShape = [];
        for (let i = 0; i < diff2; ++i) {
          diffShape.push(1);
        }
        y = reshape(y, y.shape.concat(diffShape));
      } else if (yNDim > xNDim) {
        diff2 = yNDim - xNDim;
        const diffShape = [];
        for (let i = 0; i < diff2; ++i) {
          diffShape.push(1);
        }
        x = reshape(x, x.shape.concat(diffShape));
      } else {
        diff2 = 0;
      }
      let out;
      if (x.shape.length === 2 && y.shape.length === 2) {
        if (axesArray[0] === axesArray[1]) {
          out = sum2(mul4(x, y), axesArray[0]);
        } else {
          out = sum2(mul4(transpose2(x, [1, 0]), y), axesArray[1]);
        }
      } else {
        const adjX = axesArray[0] !== x.shape.length - 1;
        const adjY = axesArray[1] === y.shape.length - 1;
        out = matMul(x, y, adjX, adjY);
      }
      if (diff2 > 0) {
        let idx;
        if (xNDim > yNDim) {
          idx = xNDim + yNDim - 3;
        } else {
          idx = xNDim - 1;
        }
        const squeezeAxes = [];
        for (let i = idx; i < idx + diff2; ++i) {
          squeezeAxes.push(i);
        }
        out = squeeze(out, squeezeAxes);
      }
      if (out.shape.length === 1) {
        out = expandDims(out, 1);
      }
      return out;
    });
  }
  var Dot = class extends Merge {
    constructor(args) {
      super(args);
      this.axes = args.axes;
      this.normalize = args.normalize == null ? false : args.normalize;
      this.supportsMasking = true;
      this.reshapeRequired = false;
    }
    build(inputShape) {
      util_exports2.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const shape1 = inputShape[0];
      const shape2 = inputShape[1];
      if (shape1.length > 3 || shape2.length > 3) {
        throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
      }
      const axes = this.interpretAxes(shape1, shape2);
      if (shape1[axes[0]] !== shape2[axes[1]]) {
        throw new ValueError(`Dimension incompatibility: ${shape1[axes[0]]} !== ${shape2[axes[1]]}`);
      }
    }
    mergeFunction(inputs) {
      if (inputs.length !== 2) {
        throw new ValueError(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${inputs.length} input(s).`);
      }
      let x1 = inputs[0];
      let x2 = inputs[1];
      let axes;
      if (!Array.isArray(this.axes)) {
        axes = [
          interpretAxis(this.axes, x1.shape.length),
          interpretAxis(this.axes, x2.shape.length)
        ];
      } else {
        axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));
      }
      if (this.normalize) {
        x1 = l2Normalize(x1, axes[0]);
        x2 = l2Normalize(x2, axes[1]);
      }
      return batchDot(x1, x2, axes);
    }
    interpretAxes(shape1, shape2) {
      let axes;
      if (!Array.isArray(this.axes)) {
        axes = [
          interpretAxis(this.axes, shape1.length),
          interpretAxis(this.axes, shape2.length)
        ];
      } else {
        axes = this.axes;
      }
      return axes;
    }
    computeOutputShape(inputShape) {
      util_exports2.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const shape1 = inputShape[0].slice();
      const shape2 = inputShape[1].slice();
      if (shape1.length > 3 || shape2.length > 3) {
        throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
      }
      const axes = this.interpretAxes(shape1, shape2);
      shape1.splice(axes[0], 1);
      shape2.splice(axes[1], 1);
      shape2.splice(0, 1);
      const outputShape = shape1.concat(shape2);
      if (outputShape.length === 1) {
        outputShape.push(1);
      }
      return outputShape;
    }
    computeMask(inputs, mask) {
      return null;
    }
    getConfig() {
      const config = {
        "axes": this.axes,
        "normalize": this.normalize
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Dot.className = "Dot";
  serialization_exports.registerClass(Dot);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/noise.js
  var GaussianNoise = class extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.stddev = args.stddev;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { stddev: this.stddev };
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const noised = () => add6(randomNormal2(input2.shape, 0, this.stddev), input2);
        const output = inTrainPhase(noised, () => input2, kwargs["training"] || false);
        return output;
      });
    }
  };
  GaussianNoise.className = "GaussianNoise";
  serialization_exports.registerClass(GaussianNoise);
  var GaussianDropout = class extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.rate = args.rate;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { rate: this.rate };
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        if (this.rate > 0 && this.rate < 1) {
          const noised = () => {
            const stddev = Math.sqrt(this.rate / (1 - this.rate));
            return mul4(input2, randomNormal2(input2.shape, 1, stddev));
          };
          return inTrainPhase(noised, () => input2, kwargs["training"] || false);
        }
        return input2;
      });
    }
  };
  GaussianDropout.className = "GaussianDropout";
  serialization_exports.registerClass(GaussianDropout);
  var AlphaDropout = class extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.rate = args.rate;
      this.noiseShape = args.noiseShape;
    }
    _getNoiseShape(inputs) {
      return this.noiseShape || getExactlyOneTensor(inputs).shape;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { rate: this.rate };
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.rate < 1 && this.rate > 0) {
          const noiseShape = this._getNoiseShape(inputs);
          const droppedInputs = () => {
            const input2 = getExactlyOneTensor(inputs);
            const alpha = 1.6732632423543772;
            const scale5 = 1.0507009873554805;
            const alphaP = -alpha * scale5;
            let keptIdx = greaterEqual(randomUniform(noiseShape), this.rate);
            keptIdx = cast2(keptIdx, "float32");
            const a = ((1 - this.rate) * (1 + this.rate * alphaP ** 2)) ** -0.5;
            const b = -a * alphaP * this.rate;
            const x = add6(mul4(input2, keptIdx), mul4(add6(keptIdx, -1), alphaP));
            return add6(mul4(x, a), b);
          };
          return inTrainPhase(droppedInputs, () => getExactlyOneTensor(inputs), kwargs["training"] || false);
        }
        return inputs;
      });
    }
  };
  AlphaDropout.className = "AlphaDropout";
  serialization_exports.registerClass(AlphaDropout);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/normalization.js
  function batchNormalization(x, mean3, variance, beta, gamma2, epsilon3 = 1e-3) {
    let out;
    if (x.rank === 2) {
      out = batchNorm2d(x, mean3, variance, beta, gamma2, epsilon3);
    } else if (x.rank === 3) {
      out = batchNorm3d(x, mean3, variance, beta, gamma2, epsilon3);
    } else if (x.rank === 4) {
      out = batchNorm4d(x, mean3, variance, beta, gamma2, epsilon3);
    } else {
      throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${x.rank} yet`);
    }
    return out;
  }
  function regularNormalizeBatchInTraining(x, gamma2, beta, reductionAxes, epsilon3 = 1e-3) {
    return tidy(() => {
      const meanAndVariance = moments(x, reductionAxes);
      const mean3 = meanAndVariance.mean;
      const variance = meanAndVariance.variance;
      const normed = batchNormalization(x, mean3, variance, beta, gamma2, epsilon3);
      return [normed, mean3, variance];
    });
  }
  function broadcastNormalizeBatchInTraining(x, gamma2, beta, reductionAxes, epsilon3 = 1e-3) {
    return tidy(() => {
      const meanAndVariance = moments(x, reductionAxes);
      const mean3 = meanAndVariance.mean;
      const variance = meanAndVariance.variance;
      const targetShape = [];
      for (const axis of range2(0, x.rank)) {
        if (reductionAxes.indexOf(axis) !== -1) {
          targetShape.push(1);
        } else {
          targetShape.push(x.shape[axis]);
        }
      }
      const broadcastMean = reshape(mean3, targetShape);
      const broadcastVariance = reshape(variance, targetShape);
      const broadcastGamma = gamma2 == null ? null : reshape(gamma2, targetShape);
      const broadcastBeta = beta == null ? null : reshape(beta, targetShape);
      const normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon3);
      return [normed, mean3, variance];
    });
  }
  function normalizeBatchInTraining(x, gamma2, beta, reductionAxes, epsilon3 = 1e-3) {
    if (util_exports2.arraysEqual(reductionAxes.slice().sort(), range2(0, x.rank - 1))) {
      return regularNormalizeBatchInTraining(x, gamma2, beta, reductionAxes, epsilon3);
    } else {
      return broadcastNormalizeBatchInTraining(x, gamma2, beta, reductionAxes, epsilon3);
    }
  }
  var BatchNormalization = class extends Layer {
    constructor(args) {
      if (args == null) {
        args = {};
      }
      super(args);
      this.supportsMasking = true;
      this.axis = args.axis == null ? -1 : args.axis;
      this.momentum = args.momentum == null ? 0.99 : args.momentum;
      this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;
      this.center = args.center == null ? true : args.center;
      this.scale = args.scale == null ? true : args.scale;
      this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
      this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
      this.movingMeanInitializer = getInitializer(args.movingMeanInitializer || "zeros");
      this.movingVarianceInitializer = getInitializer(args.movingVarianceInitializer || "ones");
      this.betaConstraint = getConstraint2(args.betaConstraint);
      this.gammaConstraint = getConstraint2(args.gammaConstraint);
      this.betaRegularizer = getRegularizer(args.betaRegularizer);
      this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const axis = this.axis >= 0 ? this.axis : this.axis + inputShape.length;
      const dim = inputShape[axis];
      if (dim == null) {
        throw new ValueError(`Axis ${axis} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(inputShape)}.`);
      }
      this.inputSpec = [new InputSpec({ ndim: inputShape.length, axes: { [axis]: dim } })];
      const shape = [dim];
      if (this.scale) {
        this.gamma = this.addWeight("gamma", shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
      }
      if (this.center) {
        this.beta = this.addWeight("beta", shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
      }
      this.movingMean = this.addWeight("moving_mean", shape, null, this.movingMeanInitializer, null, false);
      this.movingVariance = this.addWeight("moving_variance", shape, null, this.movingVarianceInitializer, null, false);
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const training = kwargs["training"] == null ? false : kwargs["training"];
        const input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        const ndim = inputShape.length;
        const reductionAxes = range2(0, ndim);
        const axis = this.axis >= 0 ? this.axis : this.axis + ndim;
        reductionAxes.splice(axis, 1);
        const broadcastShape = pyListRepeat(1, ndim);
        broadcastShape[axis] = inputShape[axis];
        const sortedReductionAxes = reductionAxes.slice();
        sortedReductionAxes.sort();
        const needsBroadcasting = !util_exports2.arraysEqual(sortedReductionAxes, range2(0, ndim).slice(0, ndim - 1));
        const normalizeInference = () => {
          if (needsBroadcasting) {
            const broadcastMovingMean = reshape(this.movingMean.read(), broadcastShape);
            const broadcastMovingVariance = reshape(this.movingVariance.read(), broadcastShape);
            const broadcastBeta = this.center ? reshape(this.beta.read(), broadcastShape) : null;
            const broadcastGamma = this.scale ? reshape(this.gamma.read(), broadcastShape) : null;
            return batchNormalization(input2, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, this.epsilon);
          } else {
            return batchNormalization(input2, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
          }
        };
        if (!training) {
          return normalizeInference();
        }
        const [normedTraining, mean3, variance] = normalizeBatchInTraining(input2, this.gamma.read(), this.beta.read(), reductionAxes, this.epsilon);
        const doMovingAverage = (variable2, value, momentum) => {
          tidy(() => {
            const decay = 1 - momentum;
            const origValue = variable2.read();
            const updateDelta = mul4(sub4(origValue, value), decay);
            variable2.write(sub4(origValue, updateDelta));
          });
        };
        const updateMovingMeanAndVariance = () => {
          doMovingAverage(this.movingMean, mean3, this.momentum);
          doMovingAverage(this.movingVariance, variance, this.momentum);
        };
        updateMovingMeanAndVariance();
        return normedTraining;
      });
    }
    getConfig() {
      const config = {
        axis: this.axis,
        momentum: this.momentum,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: serializeInitializer(this.betaInitializer),
        gammaInitializer: serializeInitializer(this.gammaInitializer),
        movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
        movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
        betaRegularizer: serializeRegularizer(this.betaRegularizer),
        gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
        betaConstraint: serializeConstraint(this.betaConstraint),
        gammaConstraint: serializeConstraint(this.gammaConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  BatchNormalization.className = "BatchNormalization";
  serialization_exports.registerClass(BatchNormalization);
  var LayerNormalization = class extends Layer {
    constructor(args) {
      if (args == null) {
        args = {};
      }
      super(args);
      this.axis = args.axis == null ? -1 : args.axis;
      if (typeof this.axis === "number") {
        if (!Number.isInteger(this.axis)) {
          throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
        }
      } else if (Array.isArray(this.axis)) {
        for (const axis of this.axis) {
          if (!Number.isInteger(axis)) {
            throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`);
          }
        }
      } else {
        throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);
      }
      this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;
      this.center = args.center == null ? true : args.center;
      this.scale = args.scale == null ? true : args.scale;
      this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
      this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
      this.betaRegularizer = getRegularizer(args.betaRegularizer);
      this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
      this.supportsMasking = true;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const nDims = inputShape.length;
      if (typeof this.axis === "number") {
        this.axis = [this.axis];
      }
      for (let i = 0; i < this.axis.length; ++i) {
        if (this.axis[i] < 0) {
          this.axis[i] += nDims;
        }
      }
      for (const axis of this.axis) {
        if (axis < 0 || axis >= nDims) {
          throw new Error(`Invalid axis: ${axis}`);
        }
      }
      if (this.axis.length !== unique2(this.axis).length) {
        throw new Error(`Found duplicate axes in: ${this.axis}`);
      }
      const paramShape = this.axis.map((axis) => inputShape[axis]);
      const trainable = true;
      if (this.scale) {
        this.gamma = this.addWeight("gamma", paramShape, "float32", this.gammaInitializer, this.gammaRegularizer, trainable);
      } else {
        this.gamma = null;
      }
      if (this.center) {
        this.beta = this.addWeight("beta", paramShape, "float32", this.betaInitializer, this.betaRegularizer, trainable);
      } else {
        this.beta = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      const input2 = getExactlyOneTensor(inputs);
      const inputShape = input2.shape;
      const nDims = inputShape.length;
      return tidy(() => {
        const keepDims = true;
        let { mean: mean3, variance } = moments(input2, this.axis, keepDims);
        const broadcastShape = pyListRepeat(1, nDims);
        for (const dim of this.axis) {
          broadcastShape[dim] = inputShape[dim];
        }
        const broadcast = (v) => {
          if (v != null && v.shape.length !== nDims) {
            return reshape(v, broadcastShape);
          } else {
            return v;
          }
        };
        let scale5 = broadcast(this.gamma.read());
        let offset = broadcast(this.beta.read());
        const momentsTiling = [];
        const scaleOffsetTiling = [];
        for (let i = 0; i < nDims; ++i) {
          if (this.axis.indexOf(i) !== -1) {
            momentsTiling.push(inputShape[i]);
            scaleOffsetTiling.push(1);
          } else {
            momentsTiling.push(1);
            scaleOffsetTiling.push(inputShape[i]);
          }
        }
        mean3 = tile(mean3, momentsTiling);
        variance = tile(variance, momentsTiling);
        scale5 = tile(scale5, scaleOffsetTiling);
        offset = tile(offset, scaleOffsetTiling);
        return batchNormalization(input2, mean3, variance, offset, scale5, this.epsilon);
      });
    }
    getConfig() {
      const config = {
        axis: this.axis,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: serializeInitializer(this.betaInitializer),
        gammaInitializer: serializeInitializer(this.gammaInitializer),
        betaRegularizer: serializeRegularizer(this.betaRegularizer),
        gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  LayerNormalization.className = "LayerNormalization";
  serialization_exports.registerClass(LayerNormalization);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/padding.js
  function spatial2dPadding(x, padding, dataFormat) {
    return tidy(() => {
      if (x.rank !== 4) {
        throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ${x.rank}-D tensor.`);
      }
      if (padding == null) {
        padding = [[1, 1], [1, 1]];
      }
      if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {
        throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
      }
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      if (dataFormat !== "channelsLast" && dataFormat !== "channelsFirst") {
        throw new ValueError(`Unknown data format: ${dataFormat}. Supported data formats are 'channelsLast' and 'channelsFirst.`);
      }
      let pattern;
      if (dataFormat === "channelsFirst") {
        pattern = [[0, 0], [0, 0], padding[0], padding[1]];
      } else {
        pattern = [[0, 0], padding[0], padding[1], [0, 0]];
      }
      return pad2(x, pattern);
    });
  }
  var ZeroPadding2D = class extends Layer {
    constructor(args) {
      if (args == null) {
        args = {};
      }
      super(args);
      this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat;
      if (args.padding == null) {
        this.padding = [[1, 1], [1, 1]];
      } else if (typeof args.padding === "number") {
        this.padding = [[args.padding, args.padding], [args.padding, args.padding]];
      } else {
        args.padding = args.padding;
        if (args.padding.length !== 2) {
          throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${args.padding.length} array.`);
        }
        let heightPadding;
        let widthPadding;
        if (typeof args.padding[0] === "number") {
          heightPadding = [args.padding[0], args.padding[0]];
          widthPadding = [args.padding[1], args.padding[1]];
        } else {
          args.padding = args.padding;
          if (args.padding[0].length !== 2) {
            throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${args.padding[0].length} array.`);
          }
          heightPadding = args.padding[0];
          if (args.padding[1].length !== 2) {
            throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${args.padding[1].length} array.`);
          }
          widthPadding = args.padding[1];
        }
        this.padding = [heightPadding, widthPadding];
      }
      this.inputSpec = [new InputSpec({ ndim: 4 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      let rows;
      let cols;
      if (this.dataFormat === "channelsFirst") {
        if (inputShape[2] != null && inputShape[2] >= 0) {
          rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
        } else {
          rows = null;
        }
        if (inputShape[3] != null && inputShape[3] >= 0) {
          cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
        } else {
          cols = null;
        }
        return [inputShape[0], inputShape[1], rows, cols];
      } else {
        if (inputShape[1] != null && inputShape[1] >= 0) {
          rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
        } else {
          rows = null;
        }
        if (inputShape[2] != null && inputShape[2] >= 0) {
          cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
        } else {
          cols = null;
        }
        return [inputShape[0], rows, cols, inputShape[3]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));
    }
    getConfig() {
      const config = {
        padding: this.padding,
        dataFormat: this.dataFormat
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ZeroPadding2D.className = "ZeroPadding2D";
  serialization_exports.registerClass(ZeroPadding2D);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/pooling.js
  function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
    return tidy(() => {
      checkDataFormat(dataFormat);
      checkPoolMode(poolMode);
      checkPaddingMode(padding);
      if (strides == null) {
        strides = [1, 1];
      }
      if (padding == null) {
        padding = "valid";
      }
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      if (poolMode == null) {
        poolMode = "max";
      }
      x = preprocessConv2DInput(x, dataFormat);
      let y;
      const paddingString = padding === "same" ? "same" : "valid";
      if (poolMode === "max") {
        y = maxPool(x, poolSize, strides, paddingString);
      } else {
        y = avgPool(x, poolSize, strides, paddingString);
      }
      if (dataFormat === "channelsFirst") {
        y = transpose2(y, [0, 3, 1, 2]);
      }
      return y;
    });
  }
  function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {
    return tidy(() => {
      checkDataFormat(dataFormat);
      checkPoolMode(poolMode);
      checkPaddingMode(padding);
      if (strides == null) {
        strides = [1, 1, 1];
      }
      if (padding == null) {
        padding = "valid";
      }
      if (dataFormat == null) {
        dataFormat = imageDataFormat();
      }
      if (poolMode == null) {
        poolMode = "max";
      }
      x = preprocessConv3DInput(x, dataFormat);
      let y;
      const paddingString = padding === "same" ? "same" : "valid";
      if (poolMode === "max") {
        y = maxPool3d(x, poolSize, strides, paddingString);
      } else {
        y = avgPool3d(x, poolSize, strides, paddingString);
      }
      if (dataFormat === "channelsFirst") {
        y = transpose2(y, [0, 4, 1, 2, 3]);
      }
      return y;
    });
  }
  var Pooling1D = class extends Layer {
    constructor(args) {
      if (args.poolSize == null) {
        args.poolSize = 2;
      }
      super(args);
      if (typeof args.poolSize === "number") {
        this.poolSize = [args.poolSize];
      } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === "number") {
        this.poolSize = args.poolSize;
      } else {
        throw new ValueError(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.poolSize)}`);
      }
      assertPositiveInteger(this.poolSize, "poolSize");
      if (args.strides == null) {
        this.strides = this.poolSize;
      } else {
        if (typeof args.strides === "number") {
          this.strides = [args.strides];
        } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === "number") {
          this.strides = args.strides;
        } else {
          throw new ValueError(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(args.strides)}`);
        }
      }
      assertPositiveInteger(this.strides, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      checkPaddingMode(this.padding);
      this.inputSpec = [new InputSpec({ ndim: 3 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const length3 = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
      return [inputShape[0], length3, inputShape[2]];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        inputs = expandDims2(getExactlyOneTensor(inputs), 2);
        const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
        return squeeze(output, [2]);
      });
    }
    getConfig() {
      const config = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  var MaxPooling1D = class extends Pooling1D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "max");
    }
  };
  MaxPooling1D.className = "MaxPooling1D";
  serialization_exports.registerClass(MaxPooling1D);
  var AveragePooling1D = class extends Pooling1D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg");
    }
  };
  AveragePooling1D.className = "AveragePooling1D";
  serialization_exports.registerClass(AveragePooling1D);
  var Pooling2D = class extends Layer {
    constructor(args) {
      if (args.poolSize == null) {
        args.poolSize = [2, 2];
      }
      super(args);
      this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];
      if (args.strides == null) {
        this.strides = this.poolSize;
      } else if (Array.isArray(args.strides)) {
        if (args.strides.length !== 2) {
          throw new ValueError(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${args.strides.length}.`);
        }
        this.strides = args.strides;
      } else {
        this.strides = [args.strides, args.strides];
      }
      assertPositiveInteger(this.poolSize, "poolSize");
      assertPositiveInteger(this.strides, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      checkPaddingMode(this.padding);
      this.inputSpec = [new InputSpec({ ndim: 4 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      let rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
      let cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
      rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
      cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
      if (this.dataFormat === "channelsFirst") {
        return [inputShape[0], inputShape[1], rows, cols];
      } else {
        return [inputShape[0], rows, cols, inputShape[3]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
      });
    }
    getConfig() {
      const config = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  var MaxPooling2D = class extends Pooling2D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "max");
    }
  };
  MaxPooling2D.className = "MaxPooling2D";
  serialization_exports.registerClass(MaxPooling2D);
  var AveragePooling2D = class extends Pooling2D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg");
    }
  };
  AveragePooling2D.className = "AveragePooling2D";
  serialization_exports.registerClass(AveragePooling2D);
  var Pooling3D = class extends Layer {
    constructor(args) {
      if (args.poolSize == null) {
        args.poolSize = [2, 2, 2];
      }
      super(args);
      this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];
      if (args.strides == null) {
        this.strides = this.poolSize;
      } else if (Array.isArray(args.strides)) {
        if (args.strides.length !== 3) {
          throw new ValueError(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${args.strides.length}.`);
        }
        this.strides = args.strides;
      } else {
        this.strides = [args.strides, args.strides, args.strides];
      }
      assertPositiveInteger(this.poolSize, "poolSize");
      assertPositiveInteger(this.strides, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      checkPaddingMode(this.padding);
      this.inputSpec = [new InputSpec({ ndim: 5 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      let depths = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
      let rows = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
      let cols = this.dataFormat === "channelsFirst" ? inputShape[4] : inputShape[3];
      depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);
      rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);
      cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);
      if (this.dataFormat === "channelsFirst") {
        return [inputShape[0], inputShape[1], depths, rows, cols];
      } else {
        return [inputShape[0], depths, rows, cols, inputShape[4]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
      });
    }
    getConfig() {
      const config = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  var MaxPooling3D = class extends Pooling3D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool3d(inputs, poolSize, strides, padding, dataFormat, "max");
    }
  };
  MaxPooling3D.className = "MaxPooling3D";
  serialization_exports.registerClass(MaxPooling3D);
  var AveragePooling3D = class extends Pooling3D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool3d(inputs, poolSize, strides, padding, dataFormat, "avg");
    }
  };
  AveragePooling3D.className = "AveragePooling3D";
  serialization_exports.registerClass(AveragePooling3D);
  var GlobalPooling1D = class extends Layer {
    constructor(args) {
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 3 })];
    }
    computeOutputShape(inputShape) {
      return [inputShape[0], inputShape[2]];
    }
    call(inputs, kwargs) {
      throw new NotImplementedError();
    }
  };
  var GlobalAveragePooling1D = class extends GlobalPooling1D {
    constructor(args) {
      super(args || {});
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        return mean(input2, 1);
      });
    }
  };
  GlobalAveragePooling1D.className = "GlobalAveragePooling1D";
  serialization_exports.registerClass(GlobalAveragePooling1D);
  var GlobalMaxPooling1D = class extends GlobalPooling1D {
    constructor(args) {
      super(args || {});
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        return max3(input2, 1);
      });
    }
  };
  GlobalMaxPooling1D.className = "GlobalMaxPooling1D";
  serialization_exports.registerClass(GlobalMaxPooling1D);
  var GlobalPooling2D = class extends Layer {
    constructor(args) {
      super(args);
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      this.inputSpec = [new InputSpec({ ndim: 4 })];
    }
    computeOutputShape(inputShape) {
      inputShape = inputShape;
      if (this.dataFormat === "channelsLast") {
        return [inputShape[0], inputShape[3]];
      } else {
        return [inputShape[0], inputShape[1]];
      }
    }
    call(inputs, kwargs) {
      throw new NotImplementedError();
    }
    getConfig() {
      const config = { dataFormat: this.dataFormat };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  var GlobalAveragePooling2D = class extends GlobalPooling2D {
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsLast") {
          return mean(input2, [1, 2]);
        } else {
          return mean(input2, [2, 3]);
        }
      });
    }
  };
  GlobalAveragePooling2D.className = "GlobalAveragePooling2D";
  serialization_exports.registerClass(GlobalAveragePooling2D);
  var GlobalMaxPooling2D = class extends GlobalPooling2D {
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsLast") {
          return max3(input2, [1, 2]);
        } else {
          return max3(input2, [2, 3]);
        }
      });
    }
  };
  GlobalMaxPooling2D.className = "GlobalMaxPooling2D";
  serialization_exports.registerClass(GlobalMaxPooling2D);

  // node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js
  var Wrapper = class extends Layer {
    constructor(args) {
      super(args);
      this.layer = args.layer;
    }
    build(inputShape) {
      this.built = true;
    }
    get trainable() {
      if (this.layer != null) {
        return this.layer.trainable;
      } else {
        return false;
      }
    }
    set trainable(value) {
      if (this.layer != null) {
        this.layer.trainable = value;
      }
    }
    get trainableWeights() {
      return this.layer.trainableWeights;
    }
    get nonTrainableWeights() {
      return this.layer.nonTrainableWeights;
    }
    get updates() {
      return this.layer._updates;
    }
    get losses() {
      return this.layer.losses;
    }
    getWeights() {
      return this.layer.getWeights();
    }
    setWeights(weights) {
      this.layer.setWeights(weights);
    }
    getConfig() {
      const config = {
        "layer": {
          "className": this.layer.getClassName(),
          "config": this.layer.getConfig()
        }
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    setFastWeightInitDuringBuild(value) {
      super.setFastWeightInitDuringBuild(value);
      if (this.layer != null) {
        this.layer.setFastWeightInitDuringBuild(value);
      }
    }
    static fromConfig(cls, config, customObjects = {}) {
      const layerConfig = config["layer"];
      const layer = deserialize(layerConfig, customObjects);
      delete config["layer"];
      const newConfig = { layer };
      Object.assign(newConfig, config);
      return new cls(newConfig);
    }
  };
  var TimeDistributed = class extends Wrapper {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length < 3) {
        throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(inputShape)}`);
      }
      this.inputSpec = [{ shape: inputShape }];
      const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
      if (!this.layer.built) {
        this.layer.build(childInputShape);
        this.layer.built = true;
      }
      super.build(inputShape);
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
      const childOutputShape = this.layer.computeOutputShape(childInputShape);
      const timesteps = inputShape[1];
      return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        const step4 = (inputs2, states) => {
          const output = getExactlyOneTensor(this.layer.call(inputs2, kwargs));
          return [output, []];
        };
        const rnnOutputs = rnn(step4, inputs, [], false, null, null, false, true);
        const y = rnnOutputs[1];
        return y;
      });
    }
  };
  TimeDistributed.className = "TimeDistributed";
  serialization_exports.registerClass(TimeDistributed);
  function checkBidirectionalMergeMode(value) {
    checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", value);
  }
  var DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat";
  var Bidirectional = class extends Wrapper {
    constructor(args) {
      super(args);
      const layerConfig = args.layer.getConfig();
      const forwDict = {};
      forwDict["className"] = args.layer.getClassName();
      forwDict["config"] = layerConfig;
      this.forwardLayer = deserialize(forwDict);
      layerConfig["goBackwards"] = layerConfig["goBackwards"] === true ? false : true;
      const backDict = {};
      backDict["className"] = args.layer.getClassName();
      backDict["config"] = layerConfig;
      this.backwardLayer = deserialize(backDict);
      this.forwardLayer.name = "forward_" + this.forwardLayer.name;
      this.backwardLayer.name = "backward_" + this.backwardLayer.name;
      this.mergeMode = args.mergeMode === void 0 ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : args.mergeMode;
      checkBidirectionalMergeMode(this.mergeMode);
      if (args.weights) {
        throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
      }
      this._stateful = args.layer.stateful;
      this.returnSequences = args.layer.returnSequences;
      this.returnState = args.layer.returnState;
      this.supportsMasking = true;
      this._trainable = true;
      this.inputSpec = args.layer.inputSpec;
      this.numConstants = null;
    }
    get trainable() {
      return this._trainable;
    }
    set trainable(value) {
      this._trainable = value;
      if (this.forwardLayer != null) {
        this.forwardLayer.trainable = value;
      }
      if (this.backwardLayer != null) {
        this.backwardLayer.trainable = value;
      }
    }
    getWeights() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }
    setWeights(weights) {
      const numWeights = weights.length;
      const numeightsOver2 = Math.floor(numWeights / 2);
      this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
      this.backwardLayer.setWeights(weights.slice(numeightsOver2));
    }
    computeOutputShape(inputShape) {
      let layerShapes = this.forwardLayer.computeOutputShape(inputShape);
      if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
        layerShapes = [layerShapes];
      }
      layerShapes = layerShapes;
      let outputShape;
      let outputShapes;
      let stateShape;
      if (this.returnState) {
        stateShape = layerShapes.slice(1);
        outputShape = layerShapes[0];
      } else {
        outputShape = layerShapes[0];
      }
      outputShape = outputShape;
      if (this.mergeMode === "concat") {
        outputShape[outputShape.length - 1] *= 2;
        outputShapes = [outputShape];
      } else if (this.mergeMode == null) {
        outputShapes = [outputShape, outputShape.slice()];
      } else {
        outputShapes = [outputShape];
      }
      if (this.returnState) {
        if (this.mergeMode == null) {
          return outputShapes.concat(stateShape).concat(stateShape.slice());
        }
        return [outputShape].concat(stateShape).concat(stateShape.slice());
      }
      return singletonOrArray(outputShapes);
    }
    apply(inputs, kwargs) {
      let initialState = kwargs == null ? null : kwargs["initialState"];
      let constants = kwargs == null ? null : kwargs["constants"];
      if (kwargs == null) {
        kwargs = {};
      }
      const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
      inputs = standardized.inputs;
      initialState = standardized.initialState;
      constants = standardized.constants;
      if (Array.isArray(inputs)) {
        initialState = inputs.slice(1);
        inputs = inputs[0];
      }
      if ((initialState == null || initialState.length === 0) && constants == null) {
        return super.apply(inputs, kwargs);
      }
      const additionalInputs = [];
      const additionalSpecs = [];
      if (initialState != null) {
        const numStates = initialState.length;
        if (numStates % 2 > 0) {
          throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
        }
        kwargs["initialState"] = initialState;
        additionalInputs.push(...initialState);
        const stateSpecs = initialState.map((state) => new InputSpec({ shape: state.shape }));
        this.forwardLayer.stateSpec = stateSpecs.slice(0, numStates / 2);
        this.backwardLayer.stateSpec = stateSpecs.slice(numStates / 2);
        additionalSpecs.push(...stateSpecs);
      }
      if (constants != null) {
        throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");
      }
      const isSymbolicTensor = additionalInputs[0] instanceof SymbolicTensor;
      for (const tensor2 of additionalInputs) {
        if (tensor2 instanceof SymbolicTensor !== isSymbolicTensor) {
          throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");
        }
      }
      if (isSymbolicTensor) {
        const fullInput = [inputs].concat(additionalInputs);
        const fullInputSpec = this.inputSpec.concat(additionalSpecs);
        const originalInputSpec = this.inputSpec;
        this.inputSpec = fullInputSpec;
        const output = super.apply(fullInput, kwargs);
        this.inputSpec = originalInputSpec;
        return output;
      } else {
        return super.apply(inputs, kwargs);
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const initialState = kwargs["initialState"];
        let y;
        let yRev;
        if (initialState == null) {
          y = this.forwardLayer.call(inputs, kwargs);
          yRev = this.backwardLayer.call(inputs, kwargs);
        } else {
          const forwardState = initialState.slice(0, initialState.length / 2);
          const backwardState = initialState.slice(initialState.length / 2);
          y = this.forwardLayer.call(inputs, Object.assign(kwargs, { initialState: forwardState }));
          yRev = this.backwardLayer.call(inputs, Object.assign(kwargs, { initialState: backwardState }));
        }
        let states;
        if (this.returnState) {
          if (Array.isArray(y)) {
            states = y.slice(1).concat(yRev.slice(1));
          } else {
          }
          y = y[0];
          yRev = yRev[0];
        }
        if (this.returnSequences) {
          yRev = reverse(yRev, 1);
        }
        let output;
        if (this.mergeMode === "concat") {
          output = concatenate([y, yRev]);
        } else if (this.mergeMode === "sum") {
          output = add6(y, yRev);
        } else if (this.mergeMode === "ave") {
          output = mul4(0.5, add6(y, yRev));
        } else if (this.mergeMode === "mul") {
          output = mul4(y, yRev);
        } else if (this.mergeMode == null) {
          output = [y, yRev];
        }
        if (this.returnState) {
          if (this.mergeMode == null) {
            return output.concat(states);
          }
          return [output].concat(states);
        }
        return output;
      });
    }
    resetStates(states) {
      this.forwardLayer.resetStates();
      this.backwardLayer.resetStates();
    }
    build(inputShape) {
      nameScope(this.forwardLayer.name, () => {
        this.forwardLayer.build(inputShape);
      });
      nameScope(this.backwardLayer.name, () => {
        this.backwardLayer.build(inputShape);
      });
      this.built = true;
    }
    computeMask(inputs, mask) {
      if (Array.isArray(mask)) {
        mask = mask[0];
      }
      let outputMask;
      if (this.returnSequences) {
        if (this.mergeMode == null) {
          outputMask = [mask, mask];
        } else {
          outputMask = mask;
        }
      } else {
        if (this.mergeMode == null) {
          outputMask = [null, null];
        } else {
          outputMask = null;
        }
      }
      if (this.returnState) {
        const states = this.forwardLayer.states;
        const stateMask = states.map((state) => null);
        if (Array.isArray(outputMask)) {
          return outputMask.concat(stateMask).concat(stateMask);
        } else {
          return [outputMask].concat(stateMask).concat(stateMask);
        }
      } else {
        return outputMask;
      }
    }
    get trainableWeights() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }
    get nonTrainableWeights() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }
    setFastWeightInitDuringBuild(value) {
      super.setFastWeightInitDuringBuild(value);
      if (this.forwardLayer != null) {
        this.forwardLayer.setFastWeightInitDuringBuild(value);
      }
      if (this.backwardLayer != null) {
        this.backwardLayer.setFastWeightInitDuringBuild(value);
      }
    }
    getConfig() {
      const config = {
        "mergeMode": this.mergeMode
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    static fromConfig(cls, config) {
      const rnnLayer = deserialize(config["layer"]);
      delete config["layer"];
      if (config["numConstants"] != null) {
        throw new NotImplementedError(`Deserialization of a Bidirectional layer with numConstants present is not supported yet.`);
      }
      const newConfig = config;
      newConfig["layer"] = rnnLayer;
      return new cls(newConfig);
    }
  };
  Bidirectional.className = "Bidirectional";
  serialization_exports.registerClass(Bidirectional);

  // node_modules/@tensorflow/tfjs-converter/dist/data/compiled_api.js
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
    DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
    DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
    DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
    DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
    DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
    DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
    DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
    DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
    DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
    DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
    DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
    DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
    DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
    DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
    DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
    DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
    DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
    DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
    DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
    DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
    DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
    DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
    DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
    DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
    DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
    DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
    DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
    DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
  })(DataType || (DataType = {}));
  var SaverDef;
  (function(SaverDef2) {
    let CheckpointFormatVersion;
    (function(CheckpointFormatVersion2) {
      CheckpointFormatVersion2[CheckpointFormatVersion2["LEGACY"] = 0] = "LEGACY";
      CheckpointFormatVersion2[CheckpointFormatVersion2["V1"] = 1] = "V1";
      CheckpointFormatVersion2[CheckpointFormatVersion2["V2"] = 2] = "V2";
    })(CheckpointFormatVersion = SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
  })(SaverDef || (SaverDef = {}));

  // node_modules/@tensorflow/tfjs-data/dist/dataset.js
  var seedrandom3 = __toModule(require_seedrandom4());

  // node_modules/@tensorflow/tfjs-data/dist/iterators/lazy_iterator.js
  var seedrandom2 = __toModule(require_seedrandom4());

  // node_modules/@tensorflow/tfjs-data/dist/util/deep_map.js
  function deepMap(input2, mapFn) {
    return deepMapInternal(input2, mapFn);
  }
  function deepMapInternal(input2, mapFn, seen = new Map(), containedIn = new Set()) {
    if (input2 == null) {
      return null;
    }
    if (typeof Blob === "function" && input2 instanceof Blob) {
      return input2.slice();
    }
    if (containedIn.has(input2)) {
      throw new Error("Circular references are not supported.");
    }
    if (seen.has(input2)) {
      return seen.get(input2);
    }
    const result = mapFn(input2);
    if (result.recurse && result.value !== null) {
      throw new Error("A deep map function may not return both a value and recurse=true.");
    }
    if (!result.recurse) {
      seen.set(input2, result.value);
      return result.value;
    } else if (isIterable2(input2)) {
      const mappedIterable = Array.isArray(input2) ? [] : {};
      containedIn.add(input2);
      for (const k in input2) {
        const child = input2[k];
        const childResult = deepMapInternal(child, mapFn, seen, containedIn);
        mappedIterable[k] = childResult;
      }
      containedIn.delete(input2);
      if (input2.__proto__) {
        mappedIterable.__proto__ = input2.__proto__;
      }
      return mappedIterable;
    } else {
      throw new Error(`Can't recurse into non-iterable type: ${input2}`);
    }
  }
  function deepZip(inputs, zipFn = zipToList) {
    return deepZipInternal(inputs, zipFn);
  }
  function deepZipInternal(inputs, zipFn, containedIn = new Set()) {
    const input2 = inputs[0];
    if (containedIn.has(input2)) {
      throw new Error("Circular references are not supported.");
    }
    const result = zipFn(inputs);
    if (result.recurse && result.value !== null) {
      throw new Error("A deep zip function may not return both a value and recurse=true.");
    }
    if (!result.recurse) {
      return result.value;
    } else if (isIterable2(input2)) {
      const mappedIterable = Array.isArray(input2) ? [] : {};
      containedIn.add(input2);
      for (const k in input2) {
        const children = inputs.map((x) => x[k]);
        const childResult = deepZipInternal(children, zipFn, containedIn);
        mappedIterable[k] = childResult;
      }
      containedIn.delete(input2);
      return mappedIterable;
    } else {
      throw new Error(`Can't recurse into non-iterable type: ${input2}`);
    }
  }
  function zipToList(x) {
    if (x === null) {
      return null;
    }
    if (isIterable2(x[0])) {
      return { value: null, recurse: true };
    } else {
      return { value: x, recurse: false };
    }
  }
  function isIterable2(obj) {
    let isTextDecoder = false;
    if (env().get("IS_BROWSER")) {
      isTextDecoder = obj instanceof TextDecoder;
    } else {
      const { StringDecoder } = require_string_decoder();
      isTextDecoder = obj instanceof StringDecoder;
    }
    return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === "object" && !(obj instanceof Tensor) && !(obj instanceof Promise) && !isTextDecoder);
  }
  function canTensorify(obj) {
    return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === "object" && obj instanceof Tensor || util_exports2.isTypedArray(obj);
  }
  function isPrimitive(value) {
    return value === null || typeof value !== "object" && typeof value !== "function";
  }

  // node_modules/@tensorflow/tfjs-data/dist/util/deep_clone.js
  function deepClone(container) {
    return deepMap(container, cloneIfTensor);
  }
  function cloneIfTensor(item) {
    if (item instanceof Tensor) {
      return { value: item.clone(), recurse: false };
    } else if (isIterable2(item)) {
      return { value: null, recurse: true };
    } else {
      return { value: item, recurse: false };
    }
  }

  // node_modules/@tensorflow/tfjs-data/dist/util/ring_buffer.js
  var RingBuffer = class {
    constructor(capacity) {
      this.capacity = capacity;
      this.begin = 0;
      this.end = 0;
      if (capacity == null) {
        throw new RangeError("Can't create a ring buffer of unknown capacity.");
      }
      if (capacity < 1) {
        throw new RangeError("Can't create ring buffer of capacity < 1.");
      }
      this.data = new Array(capacity);
      this.doubledCapacity = 2 * capacity;
    }
    wrap(index) {
      while (index < 0) {
        index += this.doubledCapacity;
      }
      return index % this.doubledCapacity;
    }
    get(index) {
      if (index < 0) {
        throw new RangeError("Can't get item at a negative index.");
      }
      return this.data[index % this.capacity];
    }
    set(index, value) {
      if (index < 0) {
        throw new RangeError("Can't set item at a negative index.");
      }
      this.data[index % this.capacity] = value;
    }
    length() {
      let length3 = this.end - this.begin;
      if (length3 < 0) {
        length3 = this.doubledCapacity + length3;
      }
      return length3;
    }
    isFull() {
      return this.length() === this.capacity;
    }
    isEmpty() {
      return this.length() === 0;
    }
    push(value) {
      if (this.isFull()) {
        throw new RangeError("Ring buffer is full.");
      }
      this.set(this.end, value);
      this.end = this.wrap(this.end + 1);
    }
    pushAll(values2) {
      for (const value of values2) {
        this.push(value);
      }
    }
    pop() {
      if (this.isEmpty()) {
        throw new RangeError("Ring buffer is empty.");
      }
      this.end = this.wrap(this.end - 1);
      const result = this.get(this.end);
      this.set(this.end, void 0);
      return result;
    }
    unshift(value) {
      if (this.isFull()) {
        throw new RangeError("Ring buffer is full.");
      }
      this.begin = this.wrap(this.begin - 1);
      this.set(this.begin, value);
    }
    shift() {
      if (this.isEmpty()) {
        throw new RangeError("Ring buffer is empty.");
      }
      const result = this.get(this.begin);
      this.set(this.begin, void 0);
      this.begin = this.wrap(this.begin + 1);
      return result;
    }
    shuffleExcise(relativeIndex) {
      if (this.isEmpty()) {
        throw new RangeError("Ring buffer is empty.");
      }
      const index = this.wrap(this.begin + relativeIndex);
      const result = this.get(index);
      this.set(index, this.pop());
      return result;
    }
  };

  // node_modules/@tensorflow/tfjs-data/dist/util/growing_ring_buffer.js
  var GrowingRingBuffer = class extends RingBuffer {
    constructor() {
      super(GrowingRingBuffer.INITIAL_CAPACITY);
    }
    isFull() {
      return false;
    }
    push(value) {
      if (super.isFull()) {
        this.expand();
      }
      super.push(value);
    }
    unshift(value) {
      if (super.isFull()) {
        this.expand();
      }
      super.unshift(value);
    }
    expand() {
      const newCapacity = this.capacity * 2;
      const newData = new Array(newCapacity);
      const len3 = this.length();
      for (let i = 0; i < len3; i++) {
        newData[i] = this.get(this.wrap(this.begin + i));
      }
      this.data = newData;
      this.capacity = newCapacity;
      this.doubledCapacity = 2 * this.capacity;
      this.begin = 0;
      this.end = len3;
    }
  };
  GrowingRingBuffer.INITIAL_CAPACITY = 32;

  // node_modules/@tensorflow/tfjs-data/dist/iterators/lazy_iterator.js
  function iteratorFromItems(items) {
    return new ArrayIterator(items);
  }
  function iteratorFromFunction(func2) {
    return new FunctionCallIterator(func2);
  }
  function iteratorFromConcatenated(baseIterators, baseErrorHandler) {
    return new ChainedIterator(baseIterators, baseErrorHandler);
  }
  var LazyIterator = class {
    async toArray() {
      const result = [];
      let x = await this.next();
      while (!x.done) {
        result.push(x.value);
        x = await this.next();
      }
      return result;
    }
    async toArrayForTest() {
      const stream = this.prefetch(100);
      const result = [];
      let x = await stream.next();
      while (!x.done) {
        result.push(x.value);
        x = await stream.next();
      }
      return result;
    }
    async resolveFully() {
      let x = await this.next();
      while (!x.done) {
        x = await this.next();
      }
    }
    async resolveWhile(predicate) {
      let x = await this.next();
      let shouldContinue = predicate(x.value);
      while (!x.done && shouldContinue) {
        x = await this.next();
        shouldContinue = predicate(x.value);
      }
    }
    handleErrors(handler) {
      return new ErrorHandlingLazyIterator(this, handler);
    }
    filter(predicate) {
      return new FilterIterator(this, predicate);
    }
    map(transform9) {
      return new MapIterator(this, transform9);
    }
    mapAsync(transform9) {
      return new AsyncMapIterator(this, transform9);
    }
    serialMapAsync(transform9) {
      return new AsyncMapIterator(this, transform9).serial();
    }
    flatmap(transform9) {
      return new FlatmapIterator(this, transform9);
    }
    async forEachAsync(f) {
      return this.map(f).resolveFully();
    }
    async serialForEach(f) {
      return this.serialMapAsync(f).resolveWhile((x) => x === true);
    }
    rowMajorBatch(batchSize, smallLastBatch = true) {
      return new RowMajorBatchIterator(this, batchSize, smallLastBatch);
    }
    columnMajorBatch(batchSize, smallLastBatch = true, zipFn = zipToList) {
      const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);
      return rowBatches.map((x) => deepZip(x, zipFn));
    }
    concatenate(iterator, baseErrorHandler) {
      return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);
    }
    take(count2) {
      if (count2 < 0 || count2 == null) {
        return this;
      }
      return new TakeIterator(this, count2);
    }
    skip(count2) {
      if (count2 < 0 || count2 == null) {
        return this;
      }
      return new SkipIterator(this, count2);
    }
    prefetch(bufferSize) {
      return new PrefetchIterator(this, bufferSize);
    }
    shuffle(windowSize, seed) {
      return new ShuffleIterator(this, windowSize, seed);
    }
    serial() {
      return new SerialIterator(this);
    }
  };
  var ArrayIterator = class extends LazyIterator {
    constructor(items) {
      super();
      this.items = items;
      this.trav = 0;
    }
    summary() {
      return `Array of ${this.items.length} items`;
    }
    async next() {
      if (this.trav >= this.items.length) {
        return { value: null, done: true };
      }
      const item = this.items[this.trav];
      this.trav++;
      return { value: deepClone(item), done: false };
    }
  };
  var FunctionCallIterator = class extends LazyIterator {
    constructor(nextFn) {
      super();
      this.nextFn = nextFn;
    }
    summary() {
      return `Function call`;
    }
    async next() {
      try {
        return this.nextFn();
      } catch (e) {
        e.message = `Error thrown while iterating through a dataset: ${e.message}`;
        throw e;
      }
    }
  };
  var SerialIterator = class extends LazyIterator {
    constructor(upstream) {
      super();
      this.upstream = upstream;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Serial`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      return this.upstream.next();
    }
  };
  var SkipIterator = class extends LazyIterator {
    constructor(upstream, maxCount) {
      super();
      this.upstream = upstream;
      this.maxCount = maxCount;
      this.count = 0;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Skip`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (this.count++ < this.maxCount) {
        const skipped = await this.upstream.next();
        if (skipped.done) {
          return skipped;
        }
        dispose(skipped.value);
      }
      return this.upstream.next();
    }
  };
  var TakeIterator = class extends LazyIterator {
    constructor(upstream, maxCount) {
      super();
      this.upstream = upstream;
      this.maxCount = maxCount;
      this.count = 0;
    }
    summary() {
      return `${this.upstream.summary()} -> Take`;
    }
    async next() {
      if (this.count++ >= this.maxCount) {
        return { value: null, done: true };
      }
      return this.upstream.next();
    }
  };
  var RowMajorBatchIterator = class extends LazyIterator {
    constructor(upstream, batchSize, enableSmallLastBatch = true) {
      super();
      this.upstream = upstream;
      this.batchSize = batchSize;
      this.enableSmallLastBatch = enableSmallLastBatch;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> RowMajorBatch`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      const batch = [];
      while (batch.length < this.batchSize) {
        const item = await this.upstream.next();
        if (item.done) {
          if (this.enableSmallLastBatch && batch.length > 0) {
            return { value: batch, done: false };
          }
          return { value: null, done: true };
        }
        batch.push(item.value);
      }
      return { value: batch, done: false };
    }
  };
  var FilterIterator = class extends LazyIterator {
    constructor(upstream, predicate) {
      super();
      this.upstream = upstream;
      this.predicate = predicate;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Filter`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (true) {
        const item = await this.upstream.next();
        if (item.done || this.predicate(item.value)) {
          return item;
        }
        dispose(item.value);
      }
    }
  };
  var MapIterator = class extends LazyIterator {
    constructor(upstream, transform9) {
      super();
      this.upstream = upstream;
      this.transform = transform9;
    }
    summary() {
      return `${this.upstream.summary()} -> Map`;
    }
    async next() {
      const item = await this.upstream.next();
      if (item.done) {
        return { value: null, done: true };
      }
      const inputTensors = tensor_util_exports.getTensorsInContainer(item.value);
      const mapped = this.transform(item.value);
      const outputTensors = tensor_util_exports.getTensorsInContainer(mapped);
      for (const t of inputTensors) {
        if (!tensor_util_exports.isTensorInList(t, outputTensors)) {
          t.dispose();
        }
      }
      return { value: mapped, done: false };
    }
  };
  var ErrorHandlingLazyIterator = class extends LazyIterator {
    constructor(upstream, handler) {
      super();
      this.upstream = upstream;
      this.handler = handler;
      this.count = 0;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> handleErrors`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (true) {
        try {
          return await this.upstream.next();
        } catch (e) {
          if (!this.handler(e)) {
            return { value: null, done: true };
          }
        }
      }
    }
  };
  var AsyncMapIterator = class extends LazyIterator {
    constructor(upstream, transform9) {
      super();
      this.upstream = upstream;
      this.transform = transform9;
    }
    summary() {
      return `${this.upstream.summary()} -> AsyncMap`;
    }
    async next() {
      const item = await this.upstream.next();
      if (item.done) {
        return { value: null, done: true };
      }
      const inputTensors = tensor_util_exports.getTensorsInContainer(item.value);
      const mapped = await this.transform(item.value);
      const outputTensors = tensor_util_exports.getTensorsInContainer(mapped);
      for (const t of inputTensors) {
        if (!tensor_util_exports.isTensorInList(t, outputTensors)) {
          t.dispose();
        }
      }
      return { value: mapped, done: false };
    }
  };
  var OneToManyIterator = class extends LazyIterator {
    constructor() {
      super();
      this.outputQueue = new GrowingRingBuffer();
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (this.outputQueue.length() === 0) {
        if (!await this.pump()) {
          return { value: null, done: true };
        }
      }
      return { value: this.outputQueue.shift(), done: false };
    }
  };
  var FlatmapIterator = class extends OneToManyIterator {
    constructor(upstream, transform9) {
      super();
      this.upstream = upstream;
      this.transform = transform9;
    }
    summary() {
      return `${this.upstream.summary()} -> Flatmap`;
    }
    async pump() {
      const item = await this.upstream.next();
      if (item.done) {
        return false;
      }
      const inputTensors = tensor_util_exports.getTensorsInContainer(item.value);
      const mappedArray = this.transform(item.value);
      const outputTensors = tensor_util_exports.getTensorsInContainer(mappedArray);
      this.outputQueue.pushAll(mappedArray);
      for (const t of inputTensors) {
        if (!tensor_util_exports.isTensorInList(t, outputTensors)) {
          t.dispose();
        }
      }
      return true;
    }
  };
  var ChainedIterator = class extends LazyIterator {
    constructor(iterators, baseErrorHandler) {
      super();
      this.baseErrorHandler = baseErrorHandler;
      this.lastRead = null;
      this.iterator = null;
      this.moreIterators = iterators;
    }
    summary() {
      const upstreamSummaries = "TODO: fill in upstream of chained summaries";
      return `${upstreamSummaries} -> Chained`;
    }
    async next() {
      this.lastRead = this.readFromChain(this.lastRead);
      return this.lastRead;
    }
    async readFromChain(lastRead) {
      await lastRead;
      if (this.iterator == null) {
        const iteratorResult = await this.moreIterators.next();
        if (iteratorResult.done) {
          return { value: null, done: true };
        }
        this.iterator = iteratorResult.value;
        if (this.baseErrorHandler != null) {
          this.iterator = this.iterator.handleErrors(this.baseErrorHandler);
        }
      }
      const itemResult = await this.iterator.next();
      if (itemResult.done) {
        this.iterator = null;
        return this.readFromChain(lastRead);
      }
      return itemResult;
    }
  };
  var ZipMismatchMode;
  (function(ZipMismatchMode2) {
    ZipMismatchMode2[ZipMismatchMode2["FAIL"] = 0] = "FAIL";
    ZipMismatchMode2[ZipMismatchMode2["SHORTEST"] = 1] = "SHORTEST";
    ZipMismatchMode2[ZipMismatchMode2["LONGEST"] = 2] = "LONGEST";
  })(ZipMismatchMode || (ZipMismatchMode = {}));
  var PrefetchIterator = class extends LazyIterator {
    constructor(upstream, bufferSize) {
      super();
      this.upstream = upstream;
      this.bufferSize = bufferSize;
      this.buffer = new RingBuffer(bufferSize);
    }
    summary() {
      return `${this.upstream.summary()} -> Prefetch`;
    }
    refill() {
      while (!this.buffer.isFull()) {
        const v = this.upstream.next();
        this.buffer.push(v);
      }
    }
    next() {
      this.refill();
      return this.buffer.shift();
    }
  };
  var ShuffleIterator = class extends PrefetchIterator {
    constructor(upstream, windowSize, seed) {
      super(upstream, windowSize);
      this.upstream = upstream;
      this.windowSize = windowSize;
      this.upstreamExhausted = false;
      this.random = seedrandom2.alea(seed || util_exports2.now().toString());
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    randomInt(max7) {
      return Math.floor(this.random() * max7);
    }
    chooseIndex() {
      return this.randomInt(this.buffer.length());
    }
    async serialNext() {
      if (!this.upstreamExhausted) {
        this.refill();
      }
      while (!this.buffer.isEmpty()) {
        const chosenIndex = this.chooseIndex();
        const result = await this.buffer.shuffleExcise(chosenIndex);
        if (result.done) {
          this.upstreamExhausted = true;
        } else {
          this.refill();
          return result;
        }
      }
      return { value: null, done: true };
    }
  };

  // node_modules/@tensorflow/tfjs-data/dist/dataset.js
  var Dataset = class {
    constructor() {
      this.size = null;
    }
    batch(batchSize, smallLastBatch = true) {
      const base2 = this;
      util_exports2.assert(batchSize > 0, () => `batchSize needs to be positive, but it is
      ${batchSize}`);
      let size3;
      if (this.size === Infinity || this.size == null) {
        size3 = this.size;
      } else if (smallLastBatch) {
        size3 = Math.ceil(this.size / batchSize);
      } else {
        size3 = Math.floor(this.size / batchSize);
      }
      return datasetFromIteratorFn(async () => {
        return (await base2.iterator()).columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat);
      }, size3);
    }
    concatenate(dataset) {
      const base2 = this;
      let size3;
      if (this.size === Infinity || dataset.size === Infinity) {
        size3 = Infinity;
      } else if (this.size != null && dataset.size != null) {
        size3 = this.size + dataset.size;
      } else {
        size3 = null;
      }
      return datasetFromIteratorFn(async () => (await base2.iterator()).concatenate(await dataset.iterator()), size3);
    }
    filter(predicate) {
      const base2 = this;
      let size3;
      if (this.size === Infinity) {
        size3 = Infinity;
      } else {
        size3 = null;
      }
      return datasetFromIteratorFn(async () => {
        return (await base2.iterator()).filter((x) => tidy(() => predicate(x)));
      }, size3);
    }
    async forEachAsync(f) {
      return (await this.iterator()).forEachAsync(f);
    }
    map(transform9) {
      const base2 = this;
      return datasetFromIteratorFn(async () => {
        return (await base2.iterator()).map((x) => tidy(() => transform9(x)));
      }, this.size);
    }
    mapAsync(transform9) {
      const base2 = this;
      return datasetFromIteratorFn(async () => {
        return (await base2.iterator()).mapAsync(transform9);
      }, this.size);
    }
    prefetch(bufferSize) {
      if (bufferSize == null) {
        throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
      }
      const base2 = this;
      return datasetFromIteratorFn(async () => (await base2.iterator()).prefetch(bufferSize), this.size);
    }
    repeat(count2) {
      const base2 = this;
      let size3;
      if (this.size != null && count2 > 0) {
        size3 = this.size * count2;
      } else if (count2 === 0) {
        size3 = 0;
      } else if (this.size != null && (count2 === void 0 || count2 < 0)) {
        size3 = Infinity;
      } else {
        size3 = null;
      }
      return datasetFromIteratorFn(async () => {
        const iteratorIterator = iteratorFromFunction(async () => ({ value: await base2.iterator(), done: false }));
        return iteratorFromConcatenated(iteratorIterator.take(count2));
      }, size3);
    }
    skip(count2) {
      const base2 = this;
      let size3;
      if (this.size != null && count2 >= 0 && this.size >= count2) {
        size3 = this.size - count2;
      } else if (this.size != null && (this.size < count2 || count2 === void 0 || count2 < 0)) {
        size3 = 0;
      } else {
        size3 = null;
      }
      return datasetFromIteratorFn(async () => (await base2.iterator()).skip(count2), size3);
    }
    shuffle(bufferSize, seed, reshuffleEachIteration = true) {
      if (bufferSize == null || bufferSize < 0) {
        if (this.size == null) {
          throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");
        } else {
          throw new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);
        }
      }
      const base2 = this;
      const random3 = seedrandom3.alea(seed || util_exports2.now().toString());
      return datasetFromIteratorFn(async () => {
        let seed2 = random3.int32();
        if (reshuffleEachIteration) {
          seed2 += random3.int32();
        }
        return (await base2.iterator()).shuffle(bufferSize, seed2.toString());
      }, this.size);
    }
    take(count2) {
      const base2 = this;
      let size3;
      if (this.size != null && this.size > count2) {
        size3 = count2;
      } else if (this.size != null && this.size <= count2) {
        size3 = this.size;
      } else {
        size3 = null;
      }
      return datasetFromIteratorFn(async () => (await base2.iterator()).take(count2), size3);
    }
    async toArray() {
      if (this.size === Infinity) {
        throw new Error("Can not convert infinite data stream to array.");
      }
      return (await this.iterator()).toArray();
    }
    async toArrayForTest() {
      if (this.size === Infinity) {
        throw new Error("Can not convert infinite data stream to array.");
      }
      return (await this.iterator()).toArrayForTest();
    }
  };
  Dataset.MAX_BUFFER_SIZE = 1e4;
  function datasetFromIteratorFn(iteratorFn, size3 = null) {
    return new class extends Dataset {
      constructor() {
        super(...arguments);
        this.size = size3;
      }
      async iterator() {
        return iteratorFn();
      }
    }();
  }
  function deepBatchConcat(rows) {
    if (rows === null) {
      return null;
    }
    const exampleRow = rows[0];
    if (canTensorify(exampleRow)) {
      const value = batchConcat(rows);
      return { value, recurse: false };
    }
    return { value: null, recurse: true };
  }
  function batchConcat(arrays) {
    if (arrays.length === 0) {
      throw new Error("Can't make a batch of zero elements.");
    }
    if (arrays[0] instanceof Tensor) {
      return stack2(arrays);
    } else {
      return tensor(arrays);
    }
  }

  // node_modules/@tensorflow/tfjs-data/dist/datasets/csv_dataset.js
  var STATE_OUT = Symbol("out");
  var STATE_FIELD = Symbol("field");
  var STATE_QUOTE = Symbol("quote");
  var STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote");
  var STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote");

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js
  function assertNotComplex(tensor2, opName) {
    if (!Array.isArray(tensor2)) {
      tensor2 = [tensor2];
    }
    tensor2.forEach((t) => {
      if (t != null) {
        util_exports2.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the CPU backend.`);
      }
    });
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js
  var whereImpl2 = kernel_impls_exports.whereImpl;
  var MathBackendCPU = class extends KernelBackend {
    constructor() {
      super();
      this.blockSize = 48;
      this.firstUse = true;
      this.data = new DataStorage(this, engine());
    }
    nextDataId() {
      return MathBackendCPU.nextDataId++;
    }
    write(values2, shape, dtype) {
      if (this.firstUse) {
        this.firstUse = false;
        if (env().get("IS_NODE")) {
          backend_util_exports.warn("\n============================\nHi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================");
        }
      }
      const dataId = { id: this.nextDataId() };
      this.data.set(dataId, { values: values2, dtype, refCount: 1 });
      return dataId;
    }
    makeTensorInfo(shape, dtype, values2) {
      let outId;
      if (dtype === "string" && values2 != null && values2.length > 0 && util_exports2.isString(values2[0])) {
        const encodedValues = values2.map((d) => util_exports2.encodeString(d));
        outId = this.write(encodedValues, shape, dtype);
      } else {
        outId = this.write(values2, shape, dtype);
      }
      return { dataId: outId, shape, dtype };
    }
    refCount(dataId) {
      if (this.data.has(dataId)) {
        const tensorData = this.data.get(dataId);
        return tensorData.refCount;
      }
      return 0;
    }
    incRef(dataId) {
      const tensorData = this.data.get(dataId);
      tensorData.refCount++;
    }
    decRef(dataId) {
      if (this.data.has(dataId)) {
        const tensorData = this.data.get(dataId);
        tensorData.refCount--;
      }
    }
    move(dataId, values2, shape, dtype, refCount) {
      this.data.set(dataId, { values: values2, dtype, refCount });
    }
    numDataIds() {
      return this.data.numDataIds();
    }
    async read(dataId) {
      return this.readSync(dataId);
    }
    readSync(dataId) {
      const { dtype, complexTensorInfos } = this.data.get(dataId);
      if (dtype === "complex64") {
        const realValues = this.readSync(complexTensorInfos.real.dataId);
        const imagValues = this.readSync(complexTensorInfos.imag.dataId);
        return backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
      }
      return this.data.get(dataId).values;
    }
    bufferSync(t) {
      const data = this.readSync(t.dataId);
      let decodedData = data;
      if (t.dtype === "string") {
        try {
          decodedData = data.map((d) => util_exports2.decodeString(d));
        } catch (_a4) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      }
      return buffer2(t.shape, t.dtype, decodedData);
    }
    makeOutput(values2, shape, dtype) {
      const dataId = this.write(values2, shape, dtype);
      return engine().makeTensorFromDataId(dataId, shape, dtype, this);
    }
    disposeData(dataId, force = false) {
      if (this.data.has(dataId)) {
        this.data.get(dataId).refCount--;
        if (!force && this.data.get(dataId).refCount > 0) {
          return false;
        }
        const { complexTensorInfos } = this.data.get(dataId);
        if (complexTensorInfos != null) {
          this.disposeData(complexTensorInfos.real.dataId, true);
          this.disposeData(complexTensorInfos.imag.dataId, true);
        }
        this.data.delete(dataId);
      }
      return true;
    }
    disposeIntermediateTensorInfo(tensorInfo) {
      this.disposeData(tensorInfo.dataId);
    }
    async time(f) {
      const start = util_exports2.now();
      f();
      const kernelMs = util_exports2.now() - start;
      return { kernelMs };
    }
    memory() {
      return {
        unreliable: true,
        reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
      };
    }
    where(condition) {
      assertNotComplex([condition], "where");
      const condVals = this.readSync(condition.dataId);
      return whereImpl2(condition.shape, condVals);
    }
    dispose() {
    }
    floatPrecision() {
      return 32;
    }
    epsilon() {
      return super.epsilon();
    }
  };
  MathBackendCPU.nextDataId = 0;

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js
  var shared_exports = {};
  __export(shared_exports, {
    addImpl: () => addImpl,
    bincountImpl: () => bincountImpl,
    bincountReduceImpl: () => bincountReduceImpl,
    ceilImpl: () => ceilImpl,
    concatImpl: () => concatImpl,
    equalImpl: () => equalImpl,
    expImpl: () => expImpl,
    expm1Impl: () => expm1Impl,
    floorImpl: () => floorImpl,
    gatherNdImpl: () => gatherNdImpl,
    gatherV2Impl: () => gatherV2Impl,
    greaterEqualImpl: () => greaterEqualImpl,
    greaterImpl: () => greaterImpl,
    lessEqualImpl: () => lessEqualImpl,
    lessImpl: () => lessImpl,
    linSpaceImpl: () => linSpaceImpl,
    logImpl: () => logImpl,
    maxImpl: () => maxImpl,
    maximumImpl: () => maximumImpl,
    minimumImpl: () => minimumImpl,
    multiplyImpl: () => multiplyImpl,
    negImpl: () => negImpl,
    notEqualImpl: () => notEqualImpl,
    prodImpl: () => prodImpl,
    rangeImpl: () => rangeImpl,
    rsqrtImpl: () => rsqrtImpl,
    sigmoidImpl: () => sigmoidImpl,
    simpleAbsImpl: () => simpleAbsImpl,
    sliceImpl: () => sliceImpl,
    sparseFillEmptyRowsImpl: () => sparseFillEmptyRowsImpl,
    sparseReshapeImpl: () => sparseReshapeImpl,
    sparseSegmentReductionImpl: () => sparseSegmentReductionImpl,
    sqrtImpl: () => sqrtImpl,
    squaredDifferenceImpl: () => squaredDifferenceImpl,
    stridedSliceImpl: () => stridedSliceImpl,
    stringNGramsImpl: () => stringNGramsImpl,
    stringSplitImpl: () => stringSplitImpl,
    stringToHashBucketFastImpl: () => stringToHashBucketFastImpl,
    subImpl: () => subImpl,
    tileImpl: () => tileImpl,
    topKImpl: () => topKImpl,
    transposeImpl: () => transposeImpl,
    uniqueImpl: () => uniqueImpl
  });

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js
  function simpleAbsImpl(vals) {
    const resultValues = new Float32Array(vals.length);
    for (let i = 0; i < vals.length; ++i) {
      resultValues[i] = Math.abs(vals[i]);
    }
    return resultValues;
  }
  var abs2 = (args) => {
    const { x } = args.inputs;
    const cpuBackend = args.backend;
    assertNotComplex(x, "abs");
    let resultValues = new Float32Array(util_exports2.sizeFromShape(x.shape));
    const values2 = cpuBackend.data.get(x.dataId).values;
    resultValues = simpleAbsImpl(values2);
    return cpuBackend.makeOutput(resultValues, x.shape, x.dtype);
  };
  var absConfig = {
    kernelName: Abs,
    backendName: "cpu",
    kernelFunc: abs2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js
  function createSimpleBinaryKernelImpl(op2) {
    return (aShape, bShape, aVals, bVals, dtype) => {
      const newShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      const resultRank = newShape.length;
      const resultStrides = util_exports2.computeStrides(newShape);
      const resultSize = util_exports2.sizeFromShape(newShape);
      const result = util_exports2.getTypedArrayFromDType(dtype, resultSize);
      const aRank = aShape.length;
      const bRank = bShape.length;
      const aStrides = util_exports2.computeStrides(aShape);
      const bStrides = util_exports2.computeStrides(bShape);
      const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, newShape);
      const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, newShape);
      if (aBroadcastDims.length + bBroadcastDims.length === 0) {
        for (let i = 0; i < result.length; ++i) {
          result[i] = op2(aVals[i % aVals.length], bVals[i % bVals.length]);
        }
      } else {
        for (let i = 0; i < result.length; ++i) {
          const loc = util_exports2.indexToLoc(i, resultRank, resultStrides);
          const aLoc = loc.slice(-aRank);
          aBroadcastDims.forEach((d) => aLoc[d] = 0);
          const aIndex = util_exports2.locToIndex(aLoc, aRank, aStrides);
          const bLoc = loc.slice(-bRank);
          bBroadcastDims.forEach((d) => bLoc[d] = 0);
          const bIndex = util_exports2.locToIndex(bLoc, bRank, bStrides);
          result[i] = op2(aVals[aIndex], bVals[bIndex]);
        }
      }
      return [result, newShape];
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js
  function complex2(args) {
    const { inputs, backend: backend2 } = args;
    const { real: real4, imag: imag4 } = inputs;
    const realVals = backend2.data.get(real4.dataId).values;
    const imagVals = backend2.data.get(imag4.dataId).values;
    const complexInfo = backend2.makeTensorInfo(real4.shape, "complex64");
    const complex4 = backend2.data.get(complexInfo.dataId);
    complex4.complexTensorInfos = {
      real: backend2.makeTensorInfo(real4.shape, "float32", realVals),
      imag: backend2.makeTensorInfo(imag4.shape, "float32", imagVals)
    };
    return complexInfo;
  }
  var complexConfig = {
    kernelName: Complex,
    backendName: "cpu",
    kernelFunc: complex2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js
  function zeros2(backend2, shape, dtype = "float32") {
    if (dtype === "complex64") {
      const real4 = zeros2(backend2, shape, "float32");
      const imag4 = zeros2(backend2, shape, "float32");
      return complex2({ inputs: { real: real4, imag: imag4 }, backend: backend2 });
    }
    const values2 = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(shape), dtype);
    return backend2.makeTensorInfo(shape, dtype, values2);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js
  function identity3(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    backend2.incRef(x.dataId);
    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
  }
  var identityConfig = {
    kernelName: Identity2,
    backendName: "cpu",
    kernelFunc: identity3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js
  function real2(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    const real4 = backend2.data.get(input2.dataId).complexTensorInfos.real;
    const realVal = backend2.data.get(real4.dataId).values;
    return backend2.makeTensorInfo(real4.shape, real4.dtype, realVal);
  }
  var realConfig = {
    kernelName: Real,
    backendName: "cpu",
    kernelFunc: real2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js
  function cast3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { dtype } = attrs;
    if (dtype === "complex64") {
      if (x.dtype === "complex64") {
        return identity3({ inputs: { x }, backend: backend2 });
      }
      const zerosTensorInfo = zeros2(backend2, x.shape, x.dtype);
      const floatX = cast3({ inputs: { x }, backend: backend2, attrs: { dtype: "float32" } });
      const result = complex2({ inputs: { real: floatX, imag: zerosTensorInfo }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(zerosTensorInfo);
      backend2.disposeIntermediateTensorInfo(floatX);
      return result;
    }
    if (x.dtype === "complex64") {
      const realPart = real2({ inputs: { input: x }, backend: backend2 });
      const result = cast3({ inputs: { x: realPart }, backend: backend2, attrs: { dtype } });
      backend2.disposeIntermediateTensorInfo(realPart);
      return result;
    }
    if (!util_exports2.hasEncodingLoss(x.dtype, dtype)) {
      const result = identity3({ inputs: { x }, backend: backend2 });
      return { dataId: result.dataId, shape: result.shape, dtype };
    }
    if (dtype === "int32") {
      const values2 = backend2.data.get(x.dataId).values;
      const resultValues = Int32Array.from(values2);
      return backend2.makeTensorInfo(x.shape, "int32", resultValues);
    }
    if (dtype === "bool") {
      const xVals = backend2.data.get(x.dataId).values;
      const zero4 = util_exports2.toTypedArray([0], x.dtype);
      const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0)(x.shape, [], xVals, zero4, "bool");
      return backend2.makeTensorInfo(resultShape, "bool", resultData);
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
  }
  var castConfig = {
    kernelName: Cast,
    backendName: "cpu",
    kernelFunc: cast3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js
  function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
    if (complexImpl == null) {
      return ({ inputs, backend: backend2 }) => {
        const { a, b } = inputs;
        const cpuBackend = backend2;
        assertNotComplex([a, b], name);
        const aVals = cpuBackend.data.get(a.dataId).values;
        const bVals = cpuBackend.data.get(b.dataId).values;
        const decodedAVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aVals) : aVals;
        const decodedBVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bVals) : bVals;
        const $dtype = dtype || a.dtype;
        const [resultData, resultShape] = simpleImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
        return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
      };
    }
    return ({ inputs, backend: backend2 }) => {
      const { a, b } = inputs;
      const cpuBackend = backend2;
      if (a.dtype === "complex64" || b.dtype === "complex64") {
        const $aComplex = cast3({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: "complex64" } });
        const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
        const aReal = $aComplexVals.complexTensorInfos.real;
        const aImag = $aComplexVals.complexTensorInfos.imag;
        const aRealVals = cpuBackend.data.get(aReal.dataId).values;
        const aImagVals = cpuBackend.data.get(aImag.dataId).values;
        const $bComplex = cast3({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: "complex64" } });
        const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
        const bReal = $bComplexVals.complexTensorInfos.real;
        const bImag = $bComplexVals.complexTensorInfos.imag;
        const bRealVals = cpuBackend.data.get(bReal.dataId).values;
        const bImagVals = cpuBackend.data.get(bImag.dataId).values;
        const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);
        const resultReal = cpuBackend.makeTensorInfo(resultShape, "float32", resultRealData);
        const resultImag = cpuBackend.makeTensorInfo(resultShape, "float32", resultImagData);
        const result = complex2({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });
        cpuBackend.disposeIntermediateTensorInfo($aComplex);
        cpuBackend.disposeIntermediateTensorInfo($bComplex);
        cpuBackend.disposeIntermediateTensorInfo(resultReal);
        cpuBackend.disposeIntermediateTensorInfo(resultImag);
        return result;
      } else {
        const aVals = cpuBackend.data.get(a.dataId).values;
        const bVals = cpuBackend.data.get(b.dataId).values;
        const $dtype = dtype || a.dtype;
        const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
        return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
      }
    };
  }
  function createComplexBinaryKernelImpl(op2) {
    return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
      const resultShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      const resultSize = util_exports2.sizeFromShape(resultShape);
      const resultRank = resultShape.length;
      const resultStrides = util_exports2.computeStrides(resultShape);
      const resultRealVals = util_exports2.getTypedArrayFromDType("float32", resultSize);
      const resultImagVals = util_exports2.getTypedArrayFromDType("float32", resultSize);
      const aBroadcastDims = backend_util_exports.getBroadcastDims(aShape, resultShape);
      const bBroadcastDims = backend_util_exports.getBroadcastDims(bShape, resultShape);
      const aVals = backend_util_exports.mergeRealAndImagArrays(aRealVals, aImagVals);
      const bVals = backend_util_exports.mergeRealAndImagArrays(bRealVals, bImagVals);
      const aRank = aShape.length;
      const aStrides = util_exports2.computeStrides(aShape);
      const bRank = bShape.length;
      const bStrides = util_exports2.computeStrides(bShape);
      if (aBroadcastDims.length + bBroadcastDims.length === 0) {
        for (let i = 0; i < resultRealVals.length; i++) {
          const aIdx = i % aVals.length;
          const bIdx = i % bVals.length;
          const result = op2(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
          resultRealVals[i] = result.real;
          resultImagVals[i] = result.imag;
        }
      } else {
        for (let i = 0; i < resultRealVals.length; i++) {
          const loc = util_exports2.indexToLoc(i, resultRank, resultStrides);
          const aLoc = loc.slice(-aRank);
          aBroadcastDims.forEach((d) => aLoc[d] = 0);
          const aIndex = util_exports2.locToIndex(aLoc, aRank, aStrides);
          const bLoc = loc.slice(-bRank);
          bBroadcastDims.forEach((d) => bLoc[d] = 0);
          const bIndex = util_exports2.locToIndex(bLoc, bRank, bStrides);
          const opResult = op2(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
          resultRealVals[i] = opResult.real;
          resultImagVals[i] = opResult.imag;
        }
      }
      return [resultRealVals, resultImagVals, resultShape];
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js
  var addImpl = createSimpleBinaryKernelImpl((a, b) => a + b);
  var addComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return { real: aReal + bReal, imag: aImag + bImag };
  });
  var add7 = binaryKernelFunc(Add, addImpl, addComplexImpl);
  var addConfig = {
    kernelName: Add,
    backendName: "cpu",
    kernelFunc: add7
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js
  function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size3) {
    const weightsSize = util_exports2.sizeFromShape(weightsShape);
    const outVals = util_exports2.makeZerosTypedArray(size3, weightsDtype);
    for (let i = 0; i < xVals.length; i++) {
      const value = xVals[i];
      if (value < 0) {
        throw new Error("Input x must be non-negative!");
      }
      if (value >= size3) {
        continue;
      }
      if (weightsSize > 0) {
        outVals[value] += weightsVals[i];
      } else {
        outVals[value] += 1;
      }
    }
    return outVals;
  }
  function bincountReduceImpl(xBuf, weightsBuf, size3, binaryOutput = false) {
    const numRows = xBuf.shape[0];
    const numCols = xBuf.shape[1];
    const outBuf = buffer2([numRows, size3], weightsBuf.dtype);
    for (let i = 0; i < numRows; i++) {
      for (let j = 0; j < numCols; j++) {
        const value = xBuf.get(i, j);
        if (value < 0) {
          throw new Error("Input x must be non-negative!");
        }
        if (value >= size3) {
          continue;
        }
        if (binaryOutput) {
          outBuf.set(1, i, value);
        } else {
          if (weightsBuf.size > 0) {
            outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);
          } else {
            outBuf.set(outBuf.get(i, value) + 1, i, value);
          }
        }
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js
  function createSimpleUnaryImpl(op2) {
    return (values2, dtype, attrs) => {
      const newValues = util_exports2.getTypedArrayFromDType(dtype, values2.length);
      for (let i = 0; i < values2.length; ++i) {
        newValues[i] = op2(values2[i], attrs);
      }
      return newValues;
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js
  function unaryKernelFunc(name, op2, dtype) {
    return ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      assertNotComplex(x, name);
      if (x.dtype === "string" || dtype === "string") {
        throw new Error("unaryKernelFunc does not support string input/output");
      }
      const cpuBackend = backend2;
      const values2 = cpuBackend.data.get(x.dataId).values;
      const xSize = util_exports2.sizeFromShape(x.shape);
      const $dtype = dtype || x.dtype;
      const newValues = util_exports2.getArrayFromDType($dtype, xSize);
      for (let i = 0; i < xSize; ++i) {
        newValues[i] = op2(values2[i], attrs);
      }
      return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
    };
  }
  function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
    return ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      assertNotComplex(x, name);
      if (x.dtype === "string" || dtype === "string") {
        throw new Error("unaryKernelFunc does not support string input/output");
      }
      const cpuBackend = backend2;
      const values2 = cpuBackend.data.get(x.dataId).values;
      const $dtype = dtype || x.dtype;
      const newValues = unaryImpl(values2, $dtype, attrs);
      return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js
  var ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));
  var ceil4 = unaryKernelFuncFromImpl(Ceil, ceilImpl);
  var ceilConfig = {
    kernelName: Ceil,
    backendName: "cpu",
    kernelFunc: ceil4
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js
  function concatImpl(inputs, outShape, dtype, simplyConcat) {
    const outVals = util_exports2.getArrayFromDType(dtype, util_exports2.sizeFromShape(outShape));
    if (simplyConcat && dtype !== "string") {
      let offset = 0;
      inputs.forEach((input2) => {
        const size3 = util_exports2.sizeFromShape(input2.shape);
        outVals.set(input2.vals, offset);
        offset += size3;
      });
    } else {
      let colOffset = 0;
      inputs.forEach((input2) => {
        const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(input2.vals) : input2.vals;
        let tIdx = 0;
        for (let row = 0; row < input2.shape[0]; ++row) {
          const resIdx = row * outShape[1] + colOffset;
          for (let col = 0; col < input2.shape[1]; ++col) {
            outVals[resIdx + col] = decodedData[tIdx++];
          }
        }
        colOffset += input2.shape[1];
      });
    }
    return outVals;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Equal.js
  var equalImpl = createSimpleBinaryKernelImpl((a, b) => a === b ? 1 : 0);
  var equal2 = binaryKernelFunc(Equal, equalImpl, null, "bool");
  var equalConfig = {
    kernelName: Equal,
    backendName: "cpu",
    kernelFunc: equal2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js
  var expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));
  var exp2 = unaryKernelFuncFromImpl(Exp, expImpl, "float32");
  var expConfig = {
    kernelName: Exp,
    backendName: "cpu",
    kernelFunc: exp2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js
  var expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));
  var expm12 = unaryKernelFuncFromImpl(Expm1, expm1Impl);
  var expm1Config = {
    kernelName: Expm1,
    backendName: "cpu",
    kernelFunc: expm12
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js
  var floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));
  var floor4 = unaryKernelFuncFromImpl(Floor, floorImpl);
  var floorConfig = {
    kernelName: Floor,
    backendName: "cpu",
    kernelFunc: floor4
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd_Impl.js
  function gatherNdImpl(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
    const outBuf = buffer2([numSlices, sliceSize], dtype);
    for (let i = 0; i < numSlices; i++) {
      const index = [];
      let flattenIndex = 0;
      for (let j = 0; j < sliceRank; j++) {
        const dim = indicesData[i * sliceRank + j];
        flattenIndex += dim * strides[j];
        index.push(dim);
      }
      if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {
        throw new Error(`Invalid indices: ${index} does not index into ${paramsShape}`);
      }
      for (let k = 0; k < sliceSize; k++) {
        outBuf.values[i * sliceSize + k] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k));
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js
  function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
    const outBuf = buffer2(flattenOutputShape, xBuf.dtype);
    for (let i = 0; i < outBuf.size; ++i) {
      const newLoc = outBuf.indexToLoc(i);
      const originalLoc = newLoc.slice();
      const batchIdx = originalLoc[0];
      const indicesIdx = originalLoc[2];
      const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
      originalLoc[2] = indicesBuf.values[indicesIndex];
      const originalIndex = xBuf.locToIndex(originalLoc);
      outBuf.values[i] = xBuf.values[originalIndex];
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js
  var greaterImpl = createSimpleBinaryKernelImpl((a, b) => a > b ? 1 : 0);
  var greater2 = binaryKernelFunc(Greater, greaterImpl, null, "bool");
  var greaterConfig = {
    kernelName: Greater,
    backendName: "cpu",
    kernelFunc: greater2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GreaterEqual.js
  var greaterEqualImpl = createSimpleBinaryKernelImpl((a, b) => a >= b ? 1 : 0);
  var greaterEqual2 = binaryKernelFunc(GreaterEqual, greaterEqualImpl, null, "bool");
  var greaterEqualConfig = {
    kernelName: GreaterEqual,
    backendName: "cpu",
    kernelFunc: greaterEqual2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js
  var lessImpl = createSimpleBinaryKernelImpl((a, b) => a < b ? 1 : 0);
  var less2 = binaryKernelFunc(Less, lessImpl, null, "bool");
  var lessConfig = {
    kernelName: Less,
    backendName: "cpu",
    kernelFunc: less2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LessEqual.js
  var lessEqualImpl = createSimpleBinaryKernelImpl((a, b) => a <= b ? 1 : 0);
  var lessEqual2 = binaryKernelFunc(LessEqual, lessEqualImpl, null, "bool");
  var lessEqualConfig = {
    kernelName: LessEqual,
    backendName: "cpu",
    kernelFunc: lessEqual2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js
  function linSpaceImpl(start, stop2, num) {
    const step4 = (stop2 - start) / (num - 1);
    const values2 = util_exports2.makeZerosTypedArray(num, "float32");
    values2[0] = start;
    for (let i = 1; i < values2.length; i++) {
      values2[i] = values2[i - 1] + step4;
    }
    return values2;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js
  var logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));
  var log7 = unaryKernelFuncFromImpl(Log2, logImpl);
  var logConfig = {
    kernelName: Log2,
    backendName: "cpu",
    kernelFunc: log7
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js
  function maxImpl(aVals, reduceSize, outShape, dtype) {
    const vals = util_exports2.getTypedArrayFromDType(dtype, util_exports2.sizeFromShape(outShape));
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let max7 = aVals[offset];
      for (let j = 0; j < reduceSize; ++j) {
        const value = aVals[offset + j];
        if (Number.isNaN(value) || value > max7) {
          max7 = value;
        }
      }
      vals[i] = max7;
    }
    return vals;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js
  var maximumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.max(aValue, bValue));
  var maximum2 = binaryKernelFunc(Maximum, maximumImpl);
  var maximumConfig = {
    kernelName: Maximum,
    backendName: "cpu",
    kernelFunc: maximum2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js
  var minimumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.min(aValue, bValue));
  var minimum2 = binaryKernelFunc(Minimum, minimumImpl);
  var minimumConfig = {
    kernelName: Minimum,
    backendName: "cpu",
    kernelFunc: minimum2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js
  var multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
  var multiplyComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return {
      real: aReal * bReal - aImag * bImag,
      imag: aReal * bImag + aImag * bReal
    };
  });
  var multiply4 = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);
  var multiplyConfig = {
    kernelName: Multiply,
    backendName: "cpu",
    kernelFunc: multiply4
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js
  function negImpl(xVals, xShape, xDtype) {
    const minusOne = util_exports2.createScalarValue(-1, xDtype);
    return multiplyImpl([], xShape, minusOne, xVals, xDtype);
  }
  function neg2(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    assertNotComplex(x, "neg");
    const xVals = backend2.data.get(x.dataId).values;
    const [res, newShape] = negImpl(xVals, x.shape, x.dtype);
    return backend2.makeTensorInfo(newShape, x.dtype, res);
  }
  var negConfig = {
    kernelName: Neg,
    backendName: "cpu",
    kernelFunc: neg2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js
  var notEqualImpl = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0);
  var notEqual2 = binaryKernelFunc(NotEqual, notEqualImpl, null, "bool");
  var notEqualConfig = {
    kernelName: NotEqual,
    backendName: "cpu",
    kernelFunc: notEqual2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js
  function transposeImpl(xVals, xShape, dtype, perm, newShape) {
    const xRank = xShape.length;
    const xSize = util_exports2.sizeFromShape(xShape);
    const xStrides = util_exports2.computeStrides(xShape);
    const newStrides = util_exports2.computeStrides(newShape);
    const result = util_exports2.getTypedArrayFromDType(dtype, util_exports2.sizeFromShape(newShape));
    for (let i = 0; i < xSize; ++i) {
      const loc = util_exports2.indexToLoc(i, xRank, xStrides);
      const newLoc = new Array(loc.length);
      for (let i2 = 0; i2 < newLoc.length; i2++) {
        newLoc[i2] = loc[perm[i2]];
      }
      const newIndex = util_exports2.locToIndex(newLoc, xRank, newStrides);
      result[newIndex] = xVals[i];
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js
  function transpose3(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { x } = inputs;
    const { perm } = attrs;
    assertNotComplex(x, "transpose");
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for (let i = 0; i < newShape.length; i++) {
      newShape[i] = x.shape[perm[i]];
    }
    const values2 = backend2.data.get(x.dataId).values;
    const result = transposeImpl(values2, x.shape, x.dtype, perm, newShape);
    const dataId = backend2.write(result, newShape, x.dtype);
    return { dataId, shape: newShape, dtype: x.dtype };
  }
  var transposeConfig = {
    kernelName: Transpose,
    backendName: "cpu",
    kernelFunc: transpose3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js
  function prodImpl(xShape, xDtype, xVals, reductionAxes) {
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xShape, reductionAxes);
    const outDtype = upcastType(xDtype, "int32");
    const outVals = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(outShape), outDtype);
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    for (let i = 0; i < outVals.length; ++i) {
      const offset = i * reduceSize;
      let prod4 = 1;
      for (let j = 0; j < reduceSize; ++j) {
        prod4 *= xVals[offset + j];
      }
      outVals[i] = prod4;
    }
    return { outVals, outShape, outDtype };
  }
  function prod2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    assertNotComplex(x, "prod");
    const xRank = x.shape.length;
    const axes = util_exports2.parseAxisParam(axis, x.shape);
    const permutation = backend_util_exports.getAxesPermutation(axes, xRank);
    let reductionAxes = axes;
    let permutedX = x;
    const intermediateTensorInfos = [];
    if (permutation != null) {
      permutedX = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutation } });
      intermediateTensorInfos.push(permutedX);
      reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, xRank);
    }
    const xVals = backend2.data.get(permutedX.dataId).values;
    const { outVals, outShape, outDtype } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);
    let resultShape = outShape;
    if (keepDims) {
      resultShape = backend_util_exports.expandShapeToKeepDim(outShape, axes);
    }
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return backend2.makeTensorInfo(resultShape, outDtype, outVals);
  }
  var prodConfig = {
    kernelName: Prod,
    backendName: "cpu",
    kernelFunc: prod2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js
  function rangeImpl(start, stop2, step4, dtype) {
    const sameStartStop = start === stop2;
    const increasingRangeNegativeStep = start < stop2 && step4 < 0;
    const decreasingRangePositiveStep = stop2 < start && step4 > 1;
    if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
      return util_exports2.makeZerosTypedArray(0, dtype);
    }
    const numElements = Math.abs(Math.ceil((stop2 - start) / step4));
    const values2 = util_exports2.makeZerosTypedArray(numElements, dtype);
    if (stop2 < start && step4 === 1) {
      step4 = -1;
    }
    values2[0] = start;
    for (let i = 1; i < values2.length; i++) {
      values2[i] = values2[i - 1] + step4;
    }
    return values2;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js
  var rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));
  var rsqrt2 = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);
  var rsqrtConfig = {
    kernelName: Rsqrt,
    backendName: "cpu",
    kernelFunc: rsqrt2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sigmoid.js
  var sigmoidImpl = createSimpleUnaryImpl((xi) => 1 / (1 + Math.exp(-xi)));
  var sigmoid2 = unaryKernelFunc(Sigmoid, (xi) => 1 / (1 + Math.exp(-xi)));
  var sigmoidConfig = {
    kernelName: Sigmoid,
    backendName: "cpu",
    kernelFunc: sigmoid2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js
  function sliceImpl(vals, begin, size3, shape, dtype) {
    const isContinous = slice_util_exports.isSliceContinous(shape, begin, size3);
    const length3 = util_exports2.sizeFromShape(size3);
    const xStrides = util_exports2.computeStrides(shape);
    if (isContinous) {
      const flatOffset = slice_util_exports.computeFlatOffset(begin, xStrides);
      if (dtype === "string") {
        return vals.slice(flatOffset, flatOffset + length3);
      }
      return vals.subarray(flatOffset, flatOffset + length3);
    }
    const decodedData = dtype === "string" ? backend_util_exports.fromUint8ToStringArray(vals) : vals;
    const inBuf = buffer2(shape, dtype, decodedData);
    const outBuf = buffer2(size3, dtype);
    for (let i = 0; i < outBuf.size; ++i) {
      const outLoc = outBuf.indexToLoc(i);
      const inLoc = outLoc.map((idx, j) => idx + begin[j]);
      outBuf.set(inBuf.get(...inLoc), ...outLoc);
    }
    if (dtype === "string") {
      return backend_util_exports.fromStringArrayToUint8(outBuf.values);
    }
    return outBuf.values;
  }
  function slice2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { begin, size: size3 } = attrs;
    assertNotComplex(x, "slice");
    const [$begin, $size] = slice_util_exports.parseSliceParams(x, begin, size3);
    slice_util_exports.assertParamsValid(x, $begin, $size);
    const vals = backend2.data.get(x.dataId).values;
    const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);
    return backend2.makeTensorInfo($size, x.dtype, outVals);
  }
  var sliceConfig = {
    kernelName: Slice,
    backendName: "cpu",
    kernelFunc: slice2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js
  function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values2, valuesDType, denseShape, defaultValue) {
    const indicesCount = indicesShape[0];
    const denseRows = denseShape[0];
    const emptyRowIndicator = new Array(denseRows);
    const reverseIndexMap = new Array(indicesCount);
    const rank = indicesShape[1];
    if (denseRows === 0) {
      if (indicesCount !== 0) {
        throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${indicesCount}`);
      }
      const outputIndices = util_exports2.getArrayFromDType(indicesDType, 0);
      const outputValues = util_exports2.getArrayFromDType(valuesDType, 0);
      return [
        outputIndices,
        [0, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
    let rowsAreOrdered = true;
    let lastIndicesRow = 0;
    const csrOffset = new Array(denseRows).fill(0);
    for (let i = 0; i < indicesCount; ++i) {
      const row = indices[i * rank];
      if (row < 0) {
        throw new Error(`indices(${i}, 0) is invalid: ${row} < 0`);
      }
      if (row >= denseRows) {
        throw new Error(`indices(${i}, 0) is invalid: ${row} >= ${denseRows}`);
      }
      ++csrOffset[row];
      rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
      lastIndicesRow = row;
    }
    let allRowsFull = true;
    for (let row = 0; row < denseRows; ++row) {
      const rowEmpty = csrOffset[row] === 0;
      emptyRowIndicator[row] = rowEmpty;
      allRowsFull = allRowsFull && !rowEmpty;
      csrOffset[row] = Math.max(csrOffset[row], 1);
      if (row > 0) {
        csrOffset[row] += csrOffset[row - 1];
      }
    }
    if (allRowsFull && rowsAreOrdered) {
      const outputIndices = indices;
      const outputValues = values2;
      for (let i = 0; i < indicesCount; ++i) {
        reverseIndexMap[i] = i;
      }
      return [
        outputIndices,
        [indicesCount, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    } else {
      const fullIndicesCount = csrOffset[denseRows - 1];
      const outputIndices = util_exports2.getArrayFromDType(indicesDType, fullIndicesCount * rank);
      const outputValues = util_exports2.getArrayFromDType(valuesDType, fullIndicesCount);
      const filledCount = new Array(denseRows).fill(0);
      for (let i = 0; i < indicesCount; ++i) {
        const row = indices[i * rank];
        const offset = filledCount[row];
        const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
        filledCount[row]++;
        for (let j = 0; j < rank; ++j) {
          outputIndices[outputI * rank + j] = indices[i * rank + j];
        }
        outputValues[outputI] = values2[i];
        reverseIndexMap[i] = outputI;
      }
      for (let row = 0; row < denseRows; ++row) {
        const rowCount = filledCount[row];
        if (rowCount === 0) {
          const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
          outputIndices[startingIndex * rank + 0] = row;
          for (let col = 1; col < rank; ++col) {
            outputIndices[startingIndex * rank + col] = 0;
          }
          outputValues[startingIndex] = defaultValue;
        }
      }
      return [
        outputIndices,
        [fullIndicesCount, rank],
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js
  function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
    const denseSize = util_exports2.sizeFromShape(inputShape);
    const nnz = inputIndicesShape[0];
    const outputRank = targetShape.length;
    const outputShape = [];
    let product = 1;
    let unknownIndex = -1;
    for (let d = 0; d < outputRank; ++d) {
      const size3 = targetShape[d];
      if (size3 === -1) {
        if (unknownIndex !== -1) {
          throw new Error(`only one output dimension may be -1, not both ${unknownIndex} and ${d}`);
        }
        unknownIndex = d;
        outputShape.push(1);
      } else {
        if (size3 < 0) {
          throw new Error(`size ${d} must be non-negative, not ${size3}`);
        }
        product *= size3;
        outputShape.push(size3);
      }
    }
    if (unknownIndex !== -1) {
      if (product <= 0) {
        throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
      }
      const missing = Math.trunc(denseSize / product);
      if (product * missing !== denseSize) {
        throw new Error(`Input to reshape is a SparseTensor with ${denseSize}
          dense values, but the requested shape requires a multiple of ${product}. inputShape=${inputShape} outputShape= ${outputShape}`);
      }
      outputShape[unknownIndex] = missing;
    }
    const outputSize = util_exports2.sizeFromShape(outputShape);
    if (outputSize !== denseSize) {
      throw new Error(`Input to reshape is a tensor with ${denseSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`);
    }
    const inputRank = inputShape.length;
    const inputStrides = [];
    if (inputRank > 0) {
      inputStrides[inputRank - 1] = 1;
      for (let d = inputRank - 2; d >= 0; --d) {
        inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];
      }
    }
    const outputStrides = [];
    if (outputRank > 0) {
      outputStrides[outputRank - 1] = 1;
      for (let d = outputRank - 2; d >= 0; --d) {
        outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];
      }
    }
    const newIndices = util_exports2.getArrayFromDType(inputDType, nnz * outputRank);
    for (let i = 0; i < nnz; ++i) {
      let id = 0;
      for (let j = 0; j < inputRank; ++j) {
        id += inputIndices[i * inputRank + j] * inputStrides[j];
      }
      for (let j = 0; j < outputRank; ++j) {
        newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);
        id %= outputStrides[j];
      }
    }
    return [newIndices, [nnz, outputRank], outputShape];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js
  function sparseSegmentReductionImpl(input2, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
    const numIndices = indices.length;
    if (numIndices !== segmentIds.length) {
      throw new Error(`segmentIds and indices should have same size.`);
    }
    const inputFlat = [inputShape[0], input2.length / inputShape[0]];
    const numCol = inputFlat[1];
    const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
    const outputRows = lastSegmentIdPlusOne;
    if (outputRows < 0) {
      throw new Error(`segment ids must be >= 0`);
    }
    const outputShape = inputShape.slice();
    outputShape[0] = outputRows;
    const outputLength = outputShape.reduce((product, value) => product * value, 1);
    const output = util_exports2.getArrayFromDType(inputDType, outputLength);
    if (numIndices === 0) {
      if (outputRows > 0) {
        output.fill(defaultValue);
      }
      return [output, outputShape];
    }
    if (outputRows <= 0) {
      throw new Error(`segment ids must be >= 0`);
    }
    let start = 0, end = 1;
    let uninitializedIndex = 0;
    let outIndex = segmentIds[start];
    while (true) {
      let nextIndex = 0;
      if (end < numIndices) {
        nextIndex = segmentIds[end];
        if (outIndex === nextIndex) {
          ++end;
          continue;
        }
        if (outIndex >= nextIndex) {
          throw new Error(`segment ids are not increasing`);
        }
      }
      if (outIndex < 0 || outIndex >= outputRows) {
        throw new Error(`Segment id ${outIndex} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`);
      }
      if (outIndex > uninitializedIndex) {
        output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
      }
      for (let i = start; i < end; ++i) {
        const index = indices[i];
        if (index < 0 || index >= inputFlat[0]) {
          throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${inputFlat[0]})`);
        }
        for (let j = 0; j < numCol; j++) {
          output[outIndex * numCol + j] += input2[index * numCol + j];
        }
      }
      if (isMean) {
        for (let j = 0; j < numCol; j++) {
          output[outIndex * numCol + j] /= end - start;
        }
      }
      start = end;
      ++end;
      uninitializedIndex = outIndex + 1;
      outIndex = nextIndex;
      if (end > numIndices) {
        break;
      }
    }
    if (uninitializedIndex < outputRows) {
      output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
    }
    return [output, outputShape];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sqrt.js
  var sqrtImpl = createSimpleUnaryImpl((xi) => Math.sqrt(xi));
  var sqrt2 = unaryKernelFunc(Sqrt, (xi) => Math.sqrt(xi));
  var sqrtConfig = {
    kernelName: Sqrt,
    backendName: "cpu",
    kernelFunc: sqrt2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js
  var squaredDifferenceImpl = createSimpleBinaryKernelImpl((a, b) => {
    const diff2 = a - b;
    return diff2 * diff2;
  });
  var squaredDifference2 = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);
  var squaredDifferenceConfig = {
    kernelName: SquaredDifference,
    backendName: "cpu",
    kernelFunc: squaredDifference2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js
  function stridedSliceImpl(outShape, xBuf, strides, begin) {
    const outBuf = buffer2(outShape, xBuf.dtype);
    for (let i = 0; i < outBuf.size; i++) {
      const loc = outBuf.indexToLoc(i);
      const newLoc = new Array(loc.length);
      for (let j = 0; j < newLoc.length; j++) {
        newLoc[j] = loc[j] * strides[j] + begin[j];
      }
      outBuf.set(xBuf.get(...newLoc), ...loc);
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js
  var StringNGramsOp = class {
    constructor(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
      this.separator = util_exports2.encodeString(separator);
      this.nGramWidths = nGramWidths;
      this.leftPad = util_exports2.encodeString(leftPad);
      this.rightPad = util_exports2.encodeString(rightPad2);
      this.padWidth = padWidth;
      this.preserveShort = preserveShortSequences;
    }
    getPadWidth(nGramWidth) {
      return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
    }
    getNumNGrams(length3, nGramWidth) {
      const padWidth = this.getPadWidth(nGramWidth);
      return Math.max(0, length3 + 2 * padWidth - nGramWidth + 1);
    }
    createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
      for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {
        const padWidth = this.getPadWidth(nGramWidth);
        const leftPadding = Math.max(0, padWidth - nGramIndex);
        const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
        const numTokens = nGramWidth - (leftPadding + rightPadding);
        const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
        let nGramSize = 0;
        nGramSize += leftPadding * this.leftPad.length;
        for (let n = 0; n < numTokens; ++n) {
          nGramSize += data[dataStartIndex + n].length;
        }
        nGramSize += rightPadding * this.rightPad.length;
        const numSeparators = leftPadding + rightPadding + numTokens - 1;
        nGramSize += numSeparators * this.separator.length;
        output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
        const nGram = output[outputStartIndex + nGramIndex];
        let nextNGramIndex = 0;
        const appendToNGram = (str4) => str4.forEach((value) => nGram[nextNGramIndex++] = value);
        for (let n = 0; n < leftPadding; ++n) {
          appendToNGram(this.leftPad);
          appendToNGram(this.separator);
        }
        for (let n = 0; n < numTokens - 1; ++n) {
          appendToNGram(data[dataStartIndex + n]);
          appendToNGram(this.separator);
        }
        if (numTokens > 0) {
          appendToNGram(data[dataStartIndex + numTokens - 1]);
          for (let n = 0; n < rightPadding; ++n) {
            appendToNGram(this.separator);
            appendToNGram(this.rightPad);
          }
        } else {
          for (let n = 0; n < rightPadding - 1; ++n) {
            appendToNGram(this.rightPad);
            appendToNGram(this.separator);
          }
          appendToNGram(this.rightPad);
        }
      }
    }
    compute(data, splits) {
      const inputDataSize = data.length;
      const splitsSize = splits.length;
      if (splitsSize > 0) {
        let prevSplit = splits[0];
        if (prevSplit !== 0) {
          throw new Error(`First split value must be 0, got ${prevSplit}`);
        }
        for (let i = 1; i < splitsSize; ++i) {
          let validSplits = splits[i] >= prevSplit;
          validSplits = validSplits && splits[i] <= inputDataSize;
          if (!validSplits) {
            throw new Error(`Invalid split value ${splits[i]}, must be in [${prevSplit}, ${inputDataSize}]`);
          }
          prevSplit = splits[i];
        }
        if (prevSplit !== inputDataSize) {
          throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
        }
      }
      const numBatchItems = splitsSize - 1;
      const nGramsSplits = util_exports2.getArrayFromDType("int32", splitsSize);
      if (inputDataSize === 0 || splitsSize === 0) {
        const empty = new Array(inputDataSize);
        for (let i = 0; i <= numBatchItems; ++i) {
          nGramsSplits[i] = 0;
        }
        return [empty, nGramsSplits];
      }
      nGramsSplits[0] = 0;
      for (let i = 1; i <= numBatchItems; ++i) {
        const length3 = splits[i] - splits[i - 1];
        let numNGrams = 0;
        this.nGramWidths.forEach((nGramWidth) => {
          numNGrams += this.getNumNGrams(length3, nGramWidth);
        });
        if (this.preserveShort && length3 > 0 && numNGrams === 0) {
          numNGrams = 1;
        }
        nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;
      }
      const nGrams = new Array(nGramsSplits[numBatchItems]);
      for (let i = 0; i < numBatchItems; ++i) {
        const splitIndex = splits[i];
        let outputStartIdx = nGramsSplits[i];
        this.nGramWidths.forEach((nGramWidth) => {
          const length3 = splits[i + 1] - splits[i];
          const numNGrams = this.getNumNGrams(length3, nGramWidth);
          this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
          outputStartIdx += numNGrams;
        });
        if (this.preserveShort && outputStartIdx === nGramsSplits[i]) {
          const dataLength = splits[i + 1] - splits[i];
          if (dataLength === 0) {
            continue;
          }
          const nGramWidth = dataLength + 2 * this.padWidth;
          const numNGrams = 1;
          this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
        }
      }
      return [nGrams, nGramsSplits];
    }
  };
  function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences).compute(data, dataSplits);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js
  function split3(str4, delimiters, skipEmpty, result) {
    if (!str4.length) {
      return;
    }
    if (delimiters.length === 0) {
      for (let i = 0; i < str4.length; ++i) {
        result.push(str4.subarray(i, i + 1));
      }
      return;
    }
    if (delimiters.length === 1) {
      const delimiter = delimiters[0];
      let f = str4.indexOf(delimiter);
      while (f !== -1) {
        const token2 = str4.subarray(0, f);
        if (!skipEmpty || token2.length !== 0) {
          result.push(token2);
        }
        str4 = str4.subarray(f + 1);
        f = str4.indexOf(delimiter);
      }
      if (!skipEmpty || str4.length !== 0) {
        result.push(str4);
      }
      return;
    }
    let tokenStart = 0;
    for (let i = 0; i < str4.length + 1; i++) {
      if (i === str4.length || delimiters.indexOf(str4[i]) !== -1) {
        const token2 = str4.subarray(tokenStart, i);
        if (!skipEmpty || token2.length !== 0) {
          result.push(token2);
        }
        tokenStart = i + 1;
      }
    }
  }
  function stringSplitImpl(input2, delimiter, skipEmpty) {
    const batchSize = input2.length;
    const tokens = [];
    let outputSize = 0;
    let maxNumEntries = 0;
    const numIndices = new Array(batchSize);
    for (let i = 0; i < batchSize; ++i) {
      const prevTokensLength = tokens.length;
      split3(input2[i], delimiter, skipEmpty, tokens);
      const nEntries = tokens.length - prevTokensLength;
      numIndices[i] = nEntries;
      outputSize += nEntries;
      maxNumEntries = Math.max(maxNumEntries, nEntries);
    }
    const indices = util_exports2.getArrayFromDType("int32", outputSize * 2);
    const values2 = new Array(outputSize);
    const shape = [batchSize, maxNumEntries];
    let c = 0;
    for (let i = 0; i < batchSize; ++i) {
      for (let j = 0; j < numIndices[i]; ++j) {
        indices[c * 2] = i;
        indices[c * 2 + 1] = j;
        values2[c] = tokens[c];
        ++c;
      }
    }
    return [indices, values2, shape];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js
  function stringToHashBucketFastImpl(input2, numBuckets) {
    const output = util_exports2.getArrayFromDType("int32", input2.length);
    for (let i = 0; i < input2.length; ++i) {
      output[i] = util_exports2.fingerPrint64(input2[i]).modulo(numBuckets).getLowBitsUnsigned();
    }
    return output;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js
  var subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
  var subComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return { real: aReal - bReal, imag: aImag - bImag };
  });
  var sub5 = binaryKernelFunc(Sub, subImpl, subComplexImpl);
  var subConfig = {
    kernelName: Sub,
    backendName: "cpu",
    kernelFunc: sub5
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js
  function tileImpl(xBuf, reps) {
    const newShape = new Array(xBuf.rank);
    for (let i = 0; i < newShape.length; i++) {
      newShape[i] = xBuf.shape[i] * reps[i];
    }
    const result = buffer2(newShape, xBuf.dtype);
    for (let i = 0; i < result.values.length; ++i) {
      const newLoc = result.indexToLoc(i);
      const originalLoc = new Array(xBuf.rank);
      for (let j = 0; j < originalLoc.length; j++) {
        originalLoc[j] = newLoc[j] % xBuf.shape[j];
      }
      const originalIndex = xBuf.locToIndex(originalLoc);
      result.values[i] = xBuf.values[originalIndex];
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js
  var comparePair = (a, b) => {
    const valueDiff = b.value - a.value;
    return valueDiff === 0 ? a.index - b.index : valueDiff;
  };
  function select(array2, k, left = 0, right = array2.length - 1) {
    while (right > left) {
      if (right - left > 600) {
        const n = right - left + 1;
        const i2 = k - left + 1;
        const z = Math.log(n);
        const s = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * Math.sign(i2 - n / 2);
        const newLeft = Math.max(left, Math.floor(k - i2 * s / n + sd));
        const newRight = Math.min(right, Math.floor(k + (n - i2) * s / n + sd));
        select(array2, k, newLeft, newRight);
      }
      const t = array2[k];
      let i = left;
      let j = right;
      util_exports2.swap(array2, left, k);
      if (comparePair(array2[right], t) > 0) {
        util_exports2.swap(array2, left, right);
      }
      while (i < j) {
        util_exports2.swap(array2, i, j);
        i++;
        j--;
        while (comparePair(array2[i], t) < 0) {
          i = i + 1;
        }
        while (comparePair(array2[j], t) > 0) {
          j = j - 1;
        }
      }
      if (comparePair(array2[left], t) === 0) {
        util_exports2.swap(array2, left, j);
      } else {
        j = j + 1;
        util_exports2.swap(array2, j, right);
      }
      if (j <= k) {
        left = j + 1;
      }
      if (k <= j) {
        right = j - 1;
      }
    }
  }
  function topKImpl(x, xShape, xDtype, k, sorted) {
    const lastDim = xShape[xShape.length - 1];
    const [batch, size3] = [x.length / lastDim, lastDim];
    const allTopKVals = util_exports2.getTypedArrayFromDType(xDtype, batch * k);
    const allTopKIndices = util_exports2.getTypedArrayFromDType("int32", batch * k);
    for (let b = 0; b < batch; b++) {
      const offset = b * size3;
      const vals = x.subarray(offset, offset + size3);
      let valAndInd = new Array(vals.length);
      vals.forEach((value, index) => valAndInd[index] = { value, index });
      if (k < valAndInd.length) {
        select(valAndInd, k);
        valAndInd = valAndInd.slice(0, k);
      }
      if (sorted) {
        valAndInd.sort(comparePair);
      }
      const outOffset = b * k;
      const topKVals = allTopKVals.subarray(outOffset, outOffset + k);
      const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
      for (let i = 0; i < k; i++) {
        topKVals[i] = valAndInd[i].value;
        topKIndices[i] = valAndInd[i].index;
      }
    }
    const outputShape = xShape.slice();
    outputShape[outputShape.length - 1] = k;
    return [
      buffer2(outputShape, xDtype, allTopKVals),
      buffer2(outputShape, "int32", allTopKIndices)
    ];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js
  function uniqueImpl(values2, axis, shape, dtype) {
    const $axis = util_exports2.parseAxisParam(axis, shape)[0];
    const newShape = [1, shape[0], 1];
    for (let i = 0; i < $axis; i++) {
      newShape[0] *= shape[i];
    }
    newShape[1] = shape[$axis];
    for (let i = $axis + 1; i < shape.length; i++) {
      newShape[2] *= shape[i];
    }
    const uniqueElements = {};
    const indices = new Int32Array(shape[$axis]);
    const inputBuffer = new TensorBuffer(newShape, dtype, values2);
    const uniqueIndices = [];
    const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
    for (let i = 0; i < shape[$axis]; i++) {
      let element;
      if (is1DTensor) {
        element = values2[i].toString();
      } else {
        const axisValues = [];
        for (let m = 0; m < newShape[0]; m++) {
          for (let n = 0; n < newShape[2]; n++) {
            axisValues.push(inputBuffer.get(m, i, n));
          }
        }
        element = axisValues.join(",");
      }
      if (uniqueElements[element] !== void 0) {
        indices[i] = uniqueElements[element];
      } else {
        const uniqueIndex = Object.keys(uniqueElements).length;
        uniqueElements[element] = uniqueIndex;
        indices[i] = uniqueIndex;
        uniqueIndices.push(i);
      }
    }
    const outputTmpShape = newShape.slice();
    outputTmpShape[1] = Object.keys(uniqueElements).length;
    const outputBuffer = new TensorBuffer(outputTmpShape, dtype);
    uniqueIndices.forEach((uniqueElementIndex, i) => {
      for (let m = 0; m < newShape[0]; m++) {
        for (let n = 0; n < newShape[2]; n++) {
          outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
        }
      }
    });
    const outputShape = shape.slice();
    outputShape[$axis] = outputTmpShape[1];
    return {
      outputValues: outputBuffer.values,
      outputShape,
      indices
    };
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/base.js
  registerBackend("cpu", () => new MathBackendCPU(), 1);

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Elu.js
  var elu3 = unaryKernelFunc(Elu, (xi) => xi >= 0 ? xi : Math.exp(xi) - 1);
  var eluConfig = {
    kernelName: Elu,
    backendName: "cpu",
    kernelFunc: elu3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LeakyRelu.js
  function leakyRelu2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { alpha } = attrs;
    assertNotComplex([x], "leakyRelu");
    const xSize = util_exports2.sizeFromShape(x.shape);
    const xVals = backend2.data.get(x.dataId).values;
    const outVals = util_exports2.getTypedArrayFromDType("float32", xSize);
    for (let i = 0; i < xVals.length; i++) {
      outVals[i] = xVals[i] < 0 ? alpha * xVals[i] : xVals[i];
    }
    return backend2.makeTensorInfo(x.shape, "float32", outVals);
  }
  var leakyReluConfig = {
    kernelName: LeakyRelu,
    backendName: "cpu",
    kernelFunc: leakyRelu2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prelu.js
  var preluImpl = createSimpleBinaryKernelImpl((xValue, aValue) => xValue < 0 ? aValue * xValue : xValue);
  function prelu2(args) {
    const { inputs, backend: backend2 } = args;
    const { x, alpha } = inputs;
    assertNotComplex([x, alpha], "prelu");
    const aVals = backend2.data.get(x.dataId).values;
    const bVals = backend2.data.get(alpha.dataId).values;
    const [resultData, resultShape] = preluImpl(x.shape, alpha.shape, aVals, bVals, "float32");
    return backend2.makeTensorInfo(resultShape, "float32", resultData);
  }
  var preluConfig = {
    kernelName: Prelu,
    backendName: "cpu",
    kernelFunc: prelu2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Relu.js
  var relu2 = unaryKernelFunc(Relu, (xi) => Math.max(0, xi));
  var reluConfig = {
    kernelName: Relu,
    backendName: "cpu",
    kernelFunc: relu2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Relu6.js
  var relu62 = unaryKernelFunc(Relu6, (xi) => Math.min(Math.max(0, xi), 6));
  var relu6Config = {
    kernelName: Relu6,
    backendName: "cpu",
    kernelFunc: relu62
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fused_utils.js
  function applyActivation2(backend2, x, activation, preluActivationWeights, leakyreluAlpha) {
    if (activation === "linear") {
      return identity3({ inputs: { x }, backend: backend2 });
    } else if (activation === "relu") {
      return relu2({ inputs: { x }, backend: backend2 });
    } else if (activation === "elu") {
      return elu3({ inputs: { x }, backend: backend2 });
    } else if (activation === "relu6") {
      return relu62({ inputs: { x }, backend: backend2 });
    } else if (activation === "prelu") {
      return prelu2({ inputs: { x, alpha: preluActivationWeights }, backend: backend2 });
    } else if (activation === "leakyrelu") {
      return leakyRelu2({ inputs: { x }, backend: backend2, attrs: { alpha: leakyreluAlpha } });
    } else if (activation === "sigmoid") {
      return sigmoid2({ inputs: { x }, backend: backend2 });
    }
    throw new Error(`Activation ${activation} has not been implemented for the CPU backend.`);
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Reshape.js
  function reshape2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { shape } = attrs;
    const xSize = util_exports2.sizeFromShape(x.shape);
    const $shape = util_exports2.inferFromImplicitShape(shape, xSize);
    const $xSize = util_exports2.sizeFromShape($shape);
    util_exports2.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
    backend2.incRef(x.dataId);
    const xData = backend2.data.get(x.dataId);
    if (xData.complexTensorInfos != null) {
      const real4 = xData.complexTensorInfos.real;
      const imag4 = xData.complexTensorInfos.imag;
      real4.shape = $shape;
      imag4.shape = $shape;
    }
    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
  }
  var reshapeConfig = {
    kernelName: Reshape,
    backendName: "cpu",
    kernelFunc: reshape2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchMatMul.js
  function batchMatMul(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { a, b } = inputs;
    const { transposeA, transposeB } = attrs;
    assertNotComplex([a, b], "matMul");
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = util_exports2.sizeFromShape(outerDimsA);
    const batchDimB = util_exports2.sizeFromShape(outerDimsB);
    const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
    util_exports2.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
    const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    util_exports2.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
    const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
    const a3d = reshape2({ inputs: { x: a }, backend: backend2, attrs: { shape: a3dShape } });
    const b3d = reshape2({ inputs: { x: b }, backend: backend2, attrs: { shape: b3dShape } });
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
    const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
    const batchDim = Math.max(batchDimA, batchDimB);
    const a3dValues = backend2.data.get(a3d.dataId).values;
    const b3dValues = backend2.data.get(b3d.dataId).values;
    const a3dStrides = util_exports2.computeStrides(a3d.shape);
    const b3dStrides = util_exports2.computeStrides(b3d.shape);
    const [aBatch, aOuterStep, aInnerStep] = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1];
    const [bInnerStep, bOuterStep, bBatch] = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]];
    const size3 = leftDim * rightDim;
    const result = buffer2([batchDim, leftDim, rightDim], a3d.dtype);
    const resVals = result.values;
    const blockSize = backend2.blockSize;
    for (let bi = 0; bi < batchDim; bi++) {
      for (let i0 = 0; i0 < leftDim; i0 += blockSize) {
        for (let j0 = 0; j0 < rightDim; j0 += blockSize) {
          for (let k02 = 0; k02 < sharedDim; k02 += blockSize) {
            const iBlock = Math.min(i0 + blockSize, leftDim);
            const jBlock = Math.min(j0 + blockSize, rightDim);
            const kBlock = Math.min(k02 + blockSize, sharedDim);
            for (let i = i0; i < iBlock; i++) {
              for (let j = j0; j < jBlock; j++) {
                let sum5 = 0;
                for (let k = k02; k < kBlock; k++) {
                  const batchOffsetA = Math.min(bi, batchDimA - 1) * aBatch;
                  const batchOffsetB = Math.min(bi, batchDimB - 1) * bBatch;
                  const aVal = a3dValues[batchOffsetA + i * aOuterStep + k * aInnerStep];
                  const bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchOffsetB];
                  sum5 += aVal * bVal;
                }
                resVals[bi * size3 + (i * rightDim + j)] += sum5;
              }
            }
          }
        }
      }
    }
    backend2.disposeIntermediateTensorInfo(a3d);
    backend2.disposeIntermediateTensorInfo(b3d);
    return backend2.makeTensorInfo(outShape, result.dtype, result.values);
  }
  var batchMatMulConfig = {
    kernelName: BatchMatMul,
    backendName: "cpu",
    kernelFunc: batchMatMul
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/_FusedMatMul.js
  function _fusedMatMul(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { a, b, bias, preluActivationWeights } = inputs;
    const { transposeA, transposeB, activation, leakyreluAlpha } = attrs;
    let current;
    let addRes;
    let activationRes;
    const intermediates = [];
    const matMulRes = batchMatMul({ inputs: { a, b }, attrs: { transposeA, transposeB }, backend: backend2 });
    current = matMulRes;
    if (bias) {
      addRes = add7({ inputs: { a: current, b: bias }, backend: backend2 });
      intermediates.push(current);
      current = addRes;
    }
    if (activation) {
      activationRes = applyActivation2(backend2, current, activation, preluActivationWeights, leakyreluAlpha);
      intermediates.push(current);
      current = activationRes;
    }
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return current;
  }
  var _fusedMatMulConfig = {
    kernelName: _FusedMatMul,
    backendName: "cpu",
    kernelFunc: _fusedMatMul
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Acos.js
  var acos2 = unaryKernelFunc(Acos, (xi) => Math.acos(xi));
  var acosConfig = {
    kernelName: Acos,
    backendName: "cpu",
    kernelFunc: acos2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Acosh.js
  var acosh2 = unaryKernelFunc(Acosh, (xi) => Math.acosh(xi));
  var acoshConfig = {
    kernelName: Acosh,
    backendName: "cpu",
    kernelFunc: acosh2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AddN.js
  function addN(args) {
    const { inputs, backend: backend2 } = args;
    const tensors = inputs;
    assertNotComplex(inputs, "addN");
    const vals = tensors.map((t) => backend2.data.get(t.dataId).values);
    const outBuf = buffer2(tensors[0].shape, tensors[0].dtype);
    const outVals = outBuf.values;
    for (let i = 0; i < tensors.length; i++) {
      const currVals = vals[i];
      for (let j = 0; j < outVals.length; j++) {
        outVals[j] += currVals[j];
      }
    }
    return backend2.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  var addNConfig = {
    kernelName: AddN,
    backendName: "cpu",
    kernelFunc: addN
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/All.js
  function all2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    assertNotComplex(x, "all");
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    if (permutedAxes != null) {
      $x = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("all", axes, $x.shape.length);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const vals = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(outShape), $x.dtype);
    const aVals = backend2.data.get($x.dataId).values;
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let all4 = aVals[offset];
      for (let j = 0; j < reduceSize; ++j) {
        const value = aVals[offset + j];
        all4 = all4 && value;
      }
      vals[i] = all4;
    }
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo($x);
    }
    const result = backend2.makeTensorInfo(outShape, $x.dtype, vals);
    if (keepDims) {
      const expandedShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      const reshapedResult = reshape2({ inputs: { x: result }, backend: backend2, attrs: { shape: expandedShape } });
      backend2.disposeIntermediateTensorInfo(result);
      return reshapedResult;
    }
    return result;
  }
  var allConfig = {
    kernelName: All,
    backendName: "cpu",
    kernelFunc: all2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Any.js
  function any2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    assertNotComplex(x, "any");
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    if (permutedAxes != null) {
      $x = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("any", axes, $x.shape.length);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const vals = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(outShape), $x.dtype);
    const aVals = backend2.data.get($x.dataId).values;
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let anyVal = aVals[offset];
      for (let j = 0; j < reduceSize; ++j) {
        const value = aVals[offset + j];
        anyVal = anyVal || value;
      }
      vals[i] = anyVal;
    }
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo($x);
    }
    const result = backend2.makeTensorInfo(outShape, $x.dtype, vals);
    if (keepDims) {
      const expandedShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      const reshapedResult = reshape2({ inputs: { x: result }, backend: backend2, attrs: { shape: expandedShape } });
      backend2.disposeIntermediateTensorInfo(result);
      return reshapedResult;
    }
    return result;
  }
  var anyConfig = {
    kernelName: Any,
    backendName: "cpu",
    kernelFunc: any2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ArgMax.js
  function argMax2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    assertNotComplex(x, "argMax");
    let axes = util_exports2.parseAxisParam(axis, x.shape);
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    axes = [axes[0]];
    backend_util_exports.assertAxesAreInnerMostDims("argMax", axes, $x.shape.length);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
    const outSize = util_exports2.sizeFromShape(outShape);
    const vals = util_exports2.makeZerosTypedArray(outSize, "int32");
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const aVals = backend2.data.get($x.dataId).values;
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let max7 = aVals[offset];
      let maxIndex = 0;
      for (let j = 0; j < reduceSize; ++j) {
        const value = aVals[offset + j];
        if (value > max7) {
          max7 = value;
          maxIndex = j;
        }
      }
      vals[i] = maxIndex;
    }
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return backend2.makeTensorInfo(outShape, "int32", vals);
  }
  var argMaxConfig = {
    kernelName: ArgMax,
    backendName: "cpu",
    kernelFunc: argMax2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ArgMin.js
  function argMin2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    assertNotComplex(x, "argMin");
    let axes = util_exports2.parseAxisParam(axis, x.shape);
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    axes = [axes[0]];
    backend_util_exports.assertAxesAreInnerMostDims("argMin", axes, $x.shape.length);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
    const outSize = util_exports2.sizeFromShape(outShape);
    const vals = util_exports2.makeZerosTypedArray(outSize, "int32");
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const aVals = backend2.data.get($x.dataId).values;
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let min7 = aVals[offset];
      let minIndex = 0;
      for (let j = 0; j < reduceSize; ++j) {
        const value = aVals[offset + j];
        if (value < min7) {
          min7 = value;
          minIndex = j;
        }
      }
      vals[i] = minIndex;
    }
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return backend2.makeTensorInfo(outShape, "int32", vals);
  }
  var argMinConfig = {
    kernelName: ArgMin,
    backendName: "cpu",
    kernelFunc: argMin2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Asin.js
  var asin2 = unaryKernelFunc(Asin, (xi) => Math.asin(xi));
  var asinConfig = {
    kernelName: Asin,
    backendName: "cpu",
    kernelFunc: asin2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Asinh.js
  var asinh2 = unaryKernelFunc(Asinh, (xi) => Math.asinh(xi));
  var asinhConfig = {
    kernelName: Asinh,
    backendName: "cpu",
    kernelFunc: asinh2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Atan.js
  var atan3 = unaryKernelFunc(Atan, (xi) => Math.atan(xi));
  var atanConfig = {
    kernelName: Atan,
    backendName: "cpu",
    kernelFunc: atan3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Atan2.js
  var atan2Impl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.atan2(aValue, bValue));
  var atan23 = binaryKernelFunc(Atan2, atan2Impl);
  var atan2Config = {
    kernelName: Atan2,
    backendName: "cpu",
    kernelFunc: atan23
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Atanh.js
  var atanh2 = unaryKernelFunc(Atanh, (xi) => Math.atanh(xi));
  var atanhConfig = {
    kernelName: Atanh,
    backendName: "cpu",
    kernelFunc: atanh2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/pool_utils.js
  function pool2(xValues, xShape, dtype, strides, convInfo, poolType) {
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    const output = buffer2(convInfo.outShape, dtype);
    const outputVals = output.values;
    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];
    const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];
    const outputColStrides = convInfo.outShape[3];
    for (let b = 0; b < convInfo.batchSize; ++b) {
      const outputBatchOffset = b * outputBatchStrides;
      const inputBatchOffset = b * strides[0];
      for (let d = 0; d < convInfo.inChannels; ++d) {
        for (let yR = 0; yR < convInfo.outHeight; ++yR) {
          const xRCorner = yR * strideHeight - padTop;
          const xRMin = Math.max(0, xRCorner);
          const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
          const outputRowOffset = outputBatchOffset + yR * outputRowStrides;
          for (let yC = 0; yC < convInfo.outWidth; ++yC) {
            const xCCorner = yC * strideWidth - padLeft;
            const xCMin = Math.max(0, xCCorner);
            const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
            let minMaxValue = initialValue;
            let avgValue = 0;
            let count2 = 0;
            for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {
              const xROffset = inputBatchOffset + xR * strides[1];
              for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {
                const xCOffset = xROffset + xC * strides[2];
                const pixel = xValues[xCOffset + d];
                if (poolType === "max" && pixel > minMaxValue) {
                  minMaxValue = pixel;
                } else if (poolType === "avg") {
                  avgValue += pixel;
                  count2++;
                }
              }
              if (isNaN(minMaxValue)) {
                break;
              }
            }
            const outputOffset = outputRowOffset + yC * outputColStrides + d;
            outputVals[outputOffset] = poolType === "avg" ? avgValue / count2 : minMaxValue;
          }
        }
      }
    }
    return output;
  }
  function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {
    const maxPositions = buffer2(convInfo.outShape, "int32");
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const xBuf = buffer2(xShape, dtype, xValues);
    for (let b = 0; b < convInfo.batchSize; ++b) {
      for (let d = 0; d < convInfo.inChannels; ++d) {
        for (let yR = 0; yR < convInfo.outHeight; ++yR) {
          const xRCorner = yR * strideHeight - padTop;
          let xRMin = xRCorner;
          while (xRMin < 0) {
            xRMin += dilationHeight;
          }
          const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
          for (let yC = 0; yC < convInfo.outWidth; ++yC) {
            const xCCorner = yC * strideWidth - padLeft;
            let xCMin = xCCorner;
            while (xCMin < 0) {
              xCMin += dilationWidth;
            }
            const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
            let maxValue = Number.NEGATIVE_INFINITY;
            let maxPosition = -1;
            for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {
              const wR = xR - xRCorner;
              for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {
                const wC = xC - xCCorner;
                const pixel = xBuf.get(b, xR, xC, d);
                if (pixel > maxValue) {
                  maxValue = pixel;
                  if (flattenPositions) {
                    maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;
                  } else {
                    maxPosition = wR * effectiveFilterWidth + wC;
                  }
                }
              }
            }
            maxPositions.set(maxPosition, b, yR, yC, d);
          }
        }
      }
    }
    return maxPositions;
  }
  function pool3d2(xValues, xShape, dtype, strides, convInfo, poolType) {
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
    const output = buffer2(convInfo.outShape, dtype);
    const outputVals = output.values;
    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
    const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
    const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];
    const outputColStrides = convInfo.outShape[4];
    for (let batch = 0; batch < convInfo.batchSize; ++batch) {
      const outputBatchOffset = batch * outputBatchStrides;
      const inputBatchOffset = batch * strides[0];
      for (let channel = 0; channel < convInfo.inChannels; ++channel) {
        for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {
          const xDepthCorner = yDepth * strideDepth - padFront;
          let xDepthMin = xDepthCorner;
          while (xDepthMin < 0) {
            xDepthMin += dilationDepth;
          }
          const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
          const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;
          for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {
            const xRowCorner = yRow * strideHeight - padTop;
            let xRowMin = xRowCorner;
            while (xRowMin < 0) {
              xRowMin += dilationHeight;
            }
            const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
            const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;
            for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {
              const xColCorner = yCol * strideWidth - padLeft;
              let xColMin = xColCorner;
              while (xColMin < 0) {
                xColMin += dilationWidth;
              }
              const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
              const outputColOffset = outputRowOffset + yCol * outputColStrides;
              let minMaxValue = initialValue;
              let avgValue = 0;
              let count2 = 0;
              for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {
                const xDepthOffset = inputBatchOffset + xDepth * strides[1];
                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {
                  const xRowOffset = xDepthOffset + xRow * strides[2];
                  for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {
                    const xColOffset = xRowOffset + xCol * strides[3];
                    const pixel = xValues[xColOffset + channel];
                    if (poolType === "max" && pixel > minMaxValue) {
                      minMaxValue = pixel;
                    } else if (poolType === "avg") {
                      avgValue += pixel;
                      count2++;
                    }
                    if (isNaN(minMaxValue)) {
                      break;
                    }
                  }
                  if (isNaN(minMaxValue)) {
                    break;
                  }
                }
                if (isNaN(minMaxValue)) {
                  break;
                }
              }
              const outputOffset = outputColOffset + channel;
              outputVals[outputOffset] = poolType === "avg" ? avgValue / count2 : minMaxValue;
            }
          }
        }
      }
    }
    return output;
  }
  function maxPool3dPositions(xBuf, convInfo) {
    const maxPositions = buffer2(convInfo.outShape, "int32");
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    for (let batch = 0; batch < convInfo.batchSize; ++batch) {
      for (let channel = 0; channel < convInfo.inChannels; ++channel) {
        for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {
          const xDepthCorner = yDepth * strideDepth - padFront;
          let xDepthMin = xDepthCorner;
          while (xDepthMin < 0) {
            xDepthMin += dilationDepth;
          }
          const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
          for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {
            const xRowCorner = yRow * strideHeight - padTop;
            let xRowMin = xRowCorner;
            while (xRowMin < 0) {
              xRowMin += dilationHeight;
            }
            const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
            for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {
              const xColCorner = yCol * strideWidth - padLeft;
              let xColMin = xColCorner;
              while (xColMin < 0) {
                xColMin += dilationWidth;
              }
              const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
              let maxValue = Number.NEGATIVE_INFINITY;
              let maxPosition = -1;
              for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {
                const wDepth = xDepth - xDepthCorner;
                for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {
                  const wRow = xRow - xRowCorner;
                  for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {
                    const wCol = xCol - xColCorner;
                    const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);
                    if (pixel >= maxValue) {
                      maxValue = pixel;
                      maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;
                    }
                  }
                }
              }
              maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);
            }
          }
        }
      }
    }
    return maxPositions;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool.js
  function avgPool2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    assertNotComplex(x, "avgPool");
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const dilations = 1;
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
    let res;
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports2.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      res = identity3({ inputs: { x }, backend: backend2 });
    } else {
      const xValues = backend2.data.get(x.dataId).values;
      const strides2 = util_exports2.computeStrides(x.shape);
      const buffer3 = pool2(xValues, x.shape, x.dtype, strides2, convInfo, "avg");
      res = backend2.makeTensorInfo(convInfo.outShape, x.dtype, buffer3.values);
    }
    return res;
  }
  var avgPoolConfig = {
    kernelName: AvgPool,
    backendName: "cpu",
    kernelFunc: avgPool2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool3D.js
  function avgPool3D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat } = attrs;
    assertNotComplex(x, "avgPool3d");
    const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, 1, pad3, dimRoundingMode, dataFormat);
    const xValues = backend2.data.get(x.dataId).values;
    const outBuf = pool3d2(xValues, x.shape, x.dtype, util_exports2.computeStrides(x.shape), convInfo, "avg");
    return backend2.makeTensorInfo(outBuf.shape, "float32", outBuf.values);
  }
  var avgPool3DConfig = {
    kernelName: AvgPool3D,
    backendName: "cpu",
    kernelFunc: avgPool3D
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool3DGrad.js
  function avgPool3DGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2 } = inputs;
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    assertNotComplex([dy, input2], "avgPool3DGrad");
    const convInfo = backend_util_exports.computePool3DInfo(input2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = buffer2(input2.shape, "float32");
    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
    const dyBuf = backend2.bufferSync(dy);
    for (let batch = 0; batch < convInfo.batchSize; ++batch) {
      for (let channel = 0; channel < convInfo.inChannels; ++channel) {
        for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {
          for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {
            for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {
              const dyDepthCorner = dxDepth - padFront;
              const dyRowCorner = dxRow - padTop;
              const dyColCorner = dxCol - padLeft;
              let dotProd = 0;
              for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
                if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                  continue;
                }
                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {
                  const dyRow = (dyRowCorner + wRow) / strideHeight;
                  if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                    continue;
                  }
                  for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {
                    const dyCol = (dyColCorner + wCol) / strideWidth;
                    if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                      continue;
                    }
                    const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                    dotProd += pixel;
                  }
                }
              }
              dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var avgPool3DGradConfig2 = {
    kernelName: AvgPool3DGrad,
    backendName: "cpu",
    kernelFunc: avgPool3DGrad
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPoolGrad.js
  function avgPoolGrad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x = input2;
    assertNotComplex([dy, input2], "avgPoolGrad");
    const { filterSize, strides, pad: pad3 } = attrs;
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad3);
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = buffer2(x.shape, "float32");
    const avgMultiplier = 1 / (filterHeight * filterWidth);
    const dyData = backend2.data.get(dy.dataId).values;
    const dyBuf = buffer2(dy.shape, "float32", dyData);
    for (let b = 0; b < convInfo.batchSize; ++b) {
      for (let d = 0; d < convInfo.inChannels; ++d) {
        for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {
          for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {
            const dyRCorner = dxR - padTop;
            const dyCCorner = dxC - padLeft;
            let dotProd = 0;
            for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {
              const dyR = (dyRCorner + wR) / strideHeight;
              if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
                continue;
              }
              for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {
                const dyC = (dyCCorner + wC) / strideWidth;
                if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                  continue;
                }
                const pixel = dyBuf.get(b, dyR, dyC, d);
                dotProd += pixel;
              }
            }
            dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var avgPoolGradConfig2 = {
    kernelName: AvgPoolGrad,
    backendName: "cpu",
    kernelFunc: avgPoolGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchNorm.js
  function batchNorm2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, scale: scale5, offset, mean: mean3, variance } = inputs;
    util_exports2.assert(mean3.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    util_exports2.assert(offset == null || mean3.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    util_exports2.assert(scale5 == null || mean3.shape.length === scale5.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    assertNotComplex([x, mean3, variance, scale5, offset], "batchNorm");
    let { varianceEpsilon } = attrs;
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const xVals = backend2.data.get(x.dataId).values;
    const mVals = backend2.data.get(mean3.dataId).values;
    const varVals = backend2.data.get(variance.dataId).values;
    const sVals = scale5 ? backend2.data.get(scale5.dataId).values : new Float32Array([1]);
    const offVals = offset ? backend2.data.get(offset.dataId).values : new Float32Array([0]);
    const outVals = new Float32Array(xVals.length);
    const offValsLength = offVals.length;
    const sValsLength = sVals.length;
    const varValsLength = varVals.length;
    const mValsLength = mVals.length;
    let offi = 0;
    let mi = 0;
    let si = 0;
    let vi = 0;
    for (let i = 0; i < xVals.length; ++i) {
      outVals[i] = offVals[offi++] + (xVals[i] - mVals[mi++]) * sVals[si++] / Math.sqrt(varVals[vi++] + varianceEpsilon);
      if (offi >= offValsLength) {
        offi = 0;
      }
      if (mi >= mValsLength) {
        mi = 0;
      }
      if (si >= sValsLength) {
        si = 0;
      }
      if (vi >= varValsLength) {
        vi = 0;
      }
    }
    return backend2.makeTensorInfo(x.shape, x.dtype, outVals);
  }
  var batchNormConfig = {
    kernelName: FusedBatchNorm,
    backendName: "cpu",
    kernelFunc: batchNorm2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchToSpaceND.js
  function batchToSpaceND2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockShape, crops } = attrs;
    assertNotComplex([x], "batchToSpaceND");
    const prod4 = blockShape.reduce((a, b) => a * b);
    const reshaped = backend_util_exports.getReshaped(x.shape, blockShape, prod4);
    const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = backend_util_exports.getReshapedPermuted(x.shape, blockShape, prod4);
    const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const xReshaped = reshape2({ inputs: { x }, backend: backend2, attrs: { shape: reshaped } });
    const xTransposed = transpose3({ inputs: { x: xReshaped }, backend: backend2, attrs: { perm: permuted } });
    const xTransposedReshaped = reshape2({ inputs: { x: xTransposed }, backend: backend2, attrs: { shape: reshapedPermuted } });
    const result = slice2({
      inputs: { x: xTransposedReshaped },
      backend: backend2,
      attrs: { begin: sliceBeginCoords, size: sliceSize }
    });
    backend2.disposeIntermediateTensorInfo(xReshaped);
    backend2.disposeIntermediateTensorInfo(xTransposed);
    backend2.disposeIntermediateTensorInfo(xTransposedReshaped);
    return result;
  }
  var batchToSpaceNDConfig = {
    kernelName: BatchToSpaceND,
    backendName: "cpu",
    kernelFunc: batchToSpaceND2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount.js
  function bincount2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, weights } = inputs;
    const { size: size3 } = attrs;
    const xVals = backend2.data.get(x.dataId).values;
    const weightsVals = backend2.data.get(weights.dataId).values;
    const outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size3);
    return backend2.makeTensorInfo([size3], weights.dtype, outVals);
  }
  var bincountConfig = {
    kernelName: Bincount,
    backendName: "cpu",
    kernelFunc: bincount2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BroadcastArgs.js
  function broadcastArgs(args) {
    const { inputs, backend: backend2 } = args;
    const { s0, s1 } = inputs;
    const s0Vals = backend2.data.get(s0.dataId).values;
    const s1Vals = backend2.data.get(s1.dataId).values;
    const broadcastShape = backend_util_exports.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend2.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
  }
  var broadcastArgsConfig = {
    kernelName: BroadcastArgs,
    backendName: "cpu",
    kernelFunc: broadcastArgs
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Clip.js
  var clip = unaryKernelFunc(ClipByValue, (xi, attrs) => {
    const clipAttrs = attrs;
    if (xi > clipAttrs.clipValueMax) {
      return clipAttrs.clipValueMax;
    }
    return xi < clipAttrs.clipValueMin ? clipAttrs.clipValueMin : xi;
  });
  var clipConfig = {
    kernelName: ClipByValue,
    backendName: "cpu",
    kernelFunc: clip
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ComplexAbs.js
  var complexAbs = (args) => {
    const { x } = args.inputs;
    const cpuBackend = args.backend;
    const resultValues = new Float32Array(util_exports2.sizeFromShape(x.shape));
    const complexVals = cpuBackend.data.get(x.dataId);
    const real4 = complexVals.complexTensorInfos.real;
    const imag4 = complexVals.complexTensorInfos.imag;
    const realVals = cpuBackend.data.get(real4.dataId).values;
    const imagVals = cpuBackend.data.get(imag4.dataId).values;
    for (let i = 0; i < realVals.length; i++) {
      const real5 = realVals[i];
      const imag5 = imagVals[i];
      resultValues[i] = Math.hypot(real5, imag5);
    }
    return cpuBackend.makeOutput(resultValues, x.shape, "float32");
  };
  var complexAbsConfig = {
    kernelName: ComplexAbs,
    backendName: "cpu",
    kernelFunc: complexAbs
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Imag.js
  function imag2(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    const imag4 = backend2.data.get(input2.dataId).complexTensorInfos.imag;
    const imagVal = backend2.data.get(imag4.dataId).values;
    return backend2.makeTensorInfo(imag4.shape, imag4.dtype, imagVal);
  }
  var imagConfig = {
    kernelName: Imag,
    backendName: "cpu",
    kernelFunc: imag2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat.js
  function concat2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { axis } = attrs;
    const $axis = util_exports2.parseAxisParam(axis, inputs[0].shape)[0];
    let outShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), $axis);
    if (util_exports2.sizeFromShape(outShape) === 0) {
      return backend2.makeTensorInfo(outShape, inputs[0].dtype, []);
    }
    const $inputs = inputs.filter((t) => util_exports2.sizeFromShape(t.shape) > 0);
    if ($inputs.length === 1) {
      return identity3({ inputs: { x: $inputs[0] }, backend: backend2 });
    }
    const shapes = $inputs.map((t) => t.shape);
    backend_util_exports.assertParamsConsistent(shapes, $axis);
    if ($inputs[0].dtype === "complex64") {
      const reals = $inputs.map((t) => real2({ inputs: { input: t }, backend: backend2 }));
      const imags = $inputs.map((t) => imag2({ inputs: { input: t }, backend: backend2 }));
      const realConcated = concat2({ inputs: reals, backend: backend2, attrs: { axis: $axis } });
      const imagConcated = concat2({ inputs: imags, backend: backend2, attrs: { axis: $axis } });
      const result = complex2({ inputs: { real: realConcated, imag: imagConcated }, backend: backend2 });
      reals.forEach((r) => backend2.disposeIntermediateTensorInfo(r));
      imags.forEach((i) => backend2.disposeIntermediateTensorInfo(i));
      backend2.disposeIntermediateTensorInfo(realConcated);
      backend2.disposeIntermediateTensorInfo(imagConcated);
      return result;
    }
    const inputs2D = $inputs.map((t) => {
      const innerSize = util_exports2.sizeFromShape(t.shape.slice($axis));
      const shape = [-1, innerSize];
      return reshape2({ inputs: { x: t }, backend: backend2, attrs: { shape } });
    });
    const inputsValShapes = inputs2D.map((t) => {
      return { vals: backend2.data.get(t.dataId).values, shape: t.shape };
    });
    outShape = backend_util_exports.computeOutShape(inputs2D.map((t) => t.shape), 1);
    const simplyConcat = inputs2D[0].shape[0] === 1;
    const outVals = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);
    const finalOutShape = backend_util_exports.computeOutShape($inputs.map((t) => t.shape), $axis);
    const outInfo = backend2.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);
    inputs2D.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return outInfo;
  }
  var concatConfig = {
    kernelName: Concat,
    backendName: "cpu",
    kernelFunc: concat2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2D.js
  function conv2D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode } = attrs;
    assertNotComplex([x, filter2], "conv2d");
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter2.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const padLeft = convInfo.padInfo.left;
    const padTop = convInfo.padInfo.top;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const y = new TensorBuffer(convInfo.outShape, x.dtype);
    const xStrides = util_exports2.computeStrides(x.shape);
    const filterStrides = util_exports2.computeStrides(filter2.shape);
    const xBatchStride = xStrides[0];
    const xRowStride = isChannelsLast ? xStrides[1] : xStrides[2];
    const xColStride = isChannelsLast ? xStrides[2] : 1;
    const xChannelStride = isChannelsLast ? 1 : xStrides[1];
    const yBatchStride = y.strides[0];
    const yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];
    const yColStride = isChannelsLast ? y.strides[2] : 1;
    const yChannelStride = isChannelsLast ? 1 : y.strides[1];
    const xVals = backend2.data.get(x.dataId).values;
    const wVals = backend2.data.get(filter2.dataId).values;
    const yVals = y.values;
    for (let b = 0; b < convInfo.batchSize; ++b) {
      const xOffset1 = b * xBatchStride;
      const yOffset1 = b * yBatchStride;
      for (let yR = 0; yR < convInfo.outHeight; ++yR) {
        const yOffset2 = yOffset1 + yR * yRowStride;
        const xRCorner = yR * convInfo.strideHeight - padTop;
        for (let wR = 0; wR < filterHeight; ++wR) {
          const xR = xRCorner + wR * dilationHeight;
          if (xR < 0 || xR >= convInfo.inHeight) {
            continue;
          }
          const wOffset1 = wR * filterStrides[0];
          const xOffset2 = xOffset1 + xR * xRowStride;
          for (let yC = 0; yC < convInfo.outWidth; ++yC) {
            const yOffset3 = yOffset2 + yC * yColStride;
            const xCCorner = yC * convInfo.strideWidth - padLeft;
            for (let wC = 0; wC < filterWidth; ++wC) {
              const xC = xCCorner + wC * dilationWidth;
              if (xC < 0 || xC >= convInfo.inWidth) {
                continue;
              }
              const wOffset2 = wOffset1 + wC * filterStrides[1];
              const xOffset3 = xOffset2 + xC * xColStride;
              let wOffset3 = wOffset2;
              for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                const xVal = xVals[xOffset3 + d1 * xChannelStride];
                for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                  yVals[yOffset3 + d2 * yChannelStride] += xVal * wVals[wOffset3 + d2];
                }
                wOffset3 += convInfo.outChannels;
              }
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(y.shape, y.dtype, yVals);
  }
  var conv2DConfig = {
    kernelName: Conv2D,
    backendName: "cpu",
    kernelFunc: conv2D
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2DBackpropFilter.js
  function conv2DBackpropFilter2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad: pad3, dataFormat, dimRoundingMode, filterShape } = attrs;
    assertNotComplex([x, dy], "conv2dBackpropFilter");
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filterShape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
    const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const dW = new TensorBuffer(convInfo.filterShape, "float32");
    const leftPad = convInfo.padInfo.left;
    const topPad = convInfo.padInfo.top;
    const xVals = backend2.data.get(x.dataId).values;
    const dyVals = backend2.data.get(dy.dataId).values;
    const xBuf = new TensorBuffer(x.shape, x.dtype, xVals);
    const dyBuf = new TensorBuffer(dy.shape, dy.dtype, dyVals);
    for (let wR = 0; wR < filterHeight; ++wR) {
      const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
      const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
      for (let wC = 0; wC < filterWidth; ++wC) {
        const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
        const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
        for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
          for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
            let dotProd = 0;
            for (let b = 0; b < convInfo.batchSize; ++b) {
              for (let yR = yRMin; yR < yRMax; ++yR) {
                const xR = wR + yR * strideHeight - topPad;
                for (let yC = yCMin; yC < yCMax; ++yC) {
                  const xC = wC + yC * strideWidth - leftPad;
                  if (isChannelsLast) {
                    dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
                  } else {
                    dotProd += xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);
                  }
                }
              }
            }
            dW.set(dotProd, wR, wC, d1, d2);
          }
        }
      }
    }
    return backend2.makeTensorInfo(dW.shape, dW.dtype, dW.values);
  }
  var conv2DBackpropFilterConfig = {
    kernelName: Conv2DBackpropFilter,
    backendName: "cpu",
    kernelFunc: conv2DBackpropFilter2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2DBackpropInput.js
  function conv2DBackpropInput2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter: filter2 } = inputs;
    const { inputShape, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
    assertNotComplex([dy, filter2], "conv2dBackpropInput");
    const filterStrides = util_exports2.computeStrides(filter2.shape);
    const dyStrides = util_exports2.computeStrides(dy.shape);
    let $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter2.shape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
    const dx = new TensorBuffer(convInfo.inShape, "float32");
    const dxValues = dx.values;
    const dyValues = backend2.data.get(dy.dataId).values;
    const fltValues = backend2.data.get(filter2.dataId).values;
    const [fltS0, fltS1, fltS2] = filterStrides;
    const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
    $dataFormat = convInfo.dataFormat;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    const isChannelsLast = $dataFormat === "channelsLast";
    const xBatchStride = dx.strides[0];
    const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];
    const xColStride = isChannelsLast ? dx.strides[2] : 1;
    const xChannelStride = isChannelsLast ? 1 : dx.strides[1];
    const yBatchStride = dyStrides[0];
    const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
    const yColStride = isChannelsLast ? dyStrides[2] : 1;
    const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
    for (let b = 0; b < batchSize; ++b) {
      for (let d1 = 0; d1 < inChannels; ++d1) {
        for (let xR = 0; xR < inHeight; ++xR) {
          const xRCorner = xR - topPad;
          const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
          const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
          for (let xC = 0; xC < inWidth; ++xC) {
            const xCCorner = xC - leftPad;
            const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
            const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
            let dotProd = 0;
            for (let yR = xRMin; yR < yRMax; ++yR) {
              const wR = yR * strideHeight - xRCorner;
              for (let yC = xCMin; yC < yCMax; ++yC) {
                const wC = yC * strideWidth - xCCorner;
                const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;
                const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                for (let d2 = 0; d2 < outChannels; ++d2) {
                  const pixel = dyValues[dyOffset + yChannelStride * d2];
                  const weight = fltValues[fltOffset + d2];
                  dotProd += pixel * weight;
                }
              }
            }
            const dxOffset = xBatchStride * b + xRowStride * xR + xColStride * xC + xChannelStride * d1;
            dxValues[dxOffset] = dotProd;
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var conv2DBackpropInputConfig = {
    kernelName: Conv2DBackpropInput,
    backendName: "cpu",
    kernelFunc: conv2DBackpropInput2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3D.js
  function conv3D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dilations } = attrs;
    assertNotComplex([x, filter2], "conv3d");
    const convInfo = backend_util_exports.computeConv3DInfo(x.shape, filter2.shape, strides, dilations, pad3);
    const { filterDepth, filterHeight, filterWidth, dilationDepth, dilationHeight, dilationWidth, padInfo } = convInfo;
    const padFront = padInfo.front;
    const padLeft = padInfo.left;
    const padTop = padInfo.top;
    const y = new TensorBuffer(convInfo.outShape, x.dtype);
    const xVals = backend2.data.get(x.dataId).values;
    const wVals = backend2.data.get(filter2.dataId).values;
    const yVals = y.values;
    const xStrides = util_exports2.computeStrides(x.shape);
    const filterStrides = util_exports2.computeStrides(filter2.shape);
    for (let b = 0; b < convInfo.batchSize; ++b) {
      const xOffset1 = b * xStrides[0];
      const yOffset1 = b * y.strides[0];
      for (let yF = 0; yF < convInfo.outDepth; ++yF) {
        const yOffset2 = yOffset1 + yF * y.strides[1];
        const xFCorner = yF * convInfo.strideDepth - padFront;
        for (let wF = 0; wF < filterDepth; ++wF) {
          const xF = xFCorner + wF * dilationDepth;
          if (xF < 0 || xF >= convInfo.inDepth) {
            continue;
          }
          const wOffset1 = wF * filterStrides[0];
          const xOffset2 = xOffset1 + xF * xStrides[1];
          for (let yR = 0; yR < convInfo.outHeight; ++yR) {
            const yOffset3 = yOffset2 + yR * y.strides[2];
            const xRCorner = yR * convInfo.strideHeight - padTop;
            for (let wR = 0; wR < filterHeight; ++wR) {
              const xR = xRCorner + wR * dilationHeight;
              if (xR < 0 || xR >= convInfo.inHeight) {
                continue;
              }
              const wOffset2 = wOffset1 + wR * filterStrides[1];
              const xOffset3 = xOffset2 + xR * xStrides[2];
              for (let yC = 0; yC < convInfo.outWidth; ++yC) {
                const yOffset4 = yOffset3 + yC * convInfo.outChannels;
                const xCCorner = yC * convInfo.strideWidth - padLeft;
                for (let wC = 0; wC < filterWidth; ++wC) {
                  const xC = xCCorner + wC * dilationWidth;
                  if (xC < 0 || xC >= convInfo.inWidth) {
                    continue;
                  }
                  const wOffset3 = wOffset2 + wC * filterStrides[2];
                  const xOffset4 = xOffset3 + xC * convInfo.inChannels;
                  let wOffset4 = wOffset3;
                  for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                    const xVal = xVals[xOffset4 + d1];
                    for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
                      yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];
                    }
                    wOffset4 += convInfo.outChannels;
                  }
                }
              }
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  var conv3DConfig = {
    kernelName: Conv3D,
    backendName: "cpu",
    kernelFunc: conv3D
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3DBackpropFilterV2.js
  function conv3DBackpropFilterV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad: pad3, filterShape } = attrs;
    assertNotComplex([x, dy], "conv3dBackpropFilterV2");
    const xStrides = util_exports2.computeStrides(x.shape);
    const dyStrides = util_exports2.computeStrides(dy.shape);
    const convInfo = backend_util_exports.computeConv3DInfo(x.shape, filterShape, strides, 1, pad3);
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const dw = new TensorBuffer(convInfo.filterShape, "float32");
    const dwValues = dw.values;
    const [dwS0, dwS1, dwS2, dwS3] = dw.strides;
    const dyValues = backend2.data.get(dy.dataId).values;
    const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
    const xValues = backend2.data.get(x.dataId).values;
    const [xS0, xS1, xS2, xS3] = xStrides;
    const frontPad = convInfo.padInfo.front;
    const leftPad = convInfo.padInfo.left;
    const topPad = convInfo.padInfo.top;
    for (let wF = 0; wF < filterDepth; ++wF) {
      const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));
      const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);
      const wOffset1 = wF * dwS0;
      for (let wR = 0; wR < filterHeight; ++wR) {
        const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
        const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
        const wOffset2 = wR * dwS1 + wOffset1;
        for (let wC = 0; wC < filterWidth; ++wC) {
          const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
          const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
          const wOffset3 = wC * dwS2 + wOffset2;
          for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
            const wOffset4 = d1 * dwS3 + wOffset3;
            for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
              let dotProd = 0;
              for (let b = 0; b < convInfo.batchSize; ++b) {
                const xOffset1 = b * xS0;
                const yOffset1 = b * dyS0;
                for (let yF = yFMin; yF < yFMax; ++yF) {
                  const xF = wF + yF * strideDepth - frontPad;
                  const xOffset2 = xF * xS1 + xOffset1;
                  const yOffset2 = yF * dyS1 + yOffset1;
                  for (let yR = yRMin; yR < yRMax; ++yR) {
                    const xR = wR + yR * strideHeight - topPad;
                    const xOffset3 = xR * xS2 + xOffset2;
                    const yOffset3 = yR * dyS2 + yOffset2;
                    for (let yC = yCMin; yC < yCMax; ++yC) {
                      const xC = wC + yC * strideWidth - leftPad;
                      const xOffset4 = xC * xS3 + xOffset3;
                      const yOffset4 = yC * dyS3 + yOffset3;
                      dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];
                    }
                  }
                }
              }
              dwValues[wOffset4 + d2] = dotProd;
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(dw.shape, dw.dtype, dw.values);
  }
  var conv3DBackpropFilterV2Config = {
    kernelName: Conv3DBackpropFilterV2,
    backendName: "cpu",
    kernelFunc: conv3DBackpropFilterV2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3DBackpropInputV2.js
  function conv3DBackpropInputV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter: filter2 } = inputs;
    const { pad: pad3, strides, inputShape } = attrs;
    assertNotComplex([dy], "conv3dBackpropInputV2");
    const dyStrides = util_exports2.computeStrides(dy.shape);
    const filterStrides = util_exports2.computeStrides(filter2.shape);
    const convInfo = backend_util_exports.computeConv3DInfo(inputShape, filter2.shape, strides, 1, pad3);
    const dx = new TensorBuffer(convInfo.inShape, "float32");
    const dxValues = dx.values;
    const [dxS0, dxS1, dxS2, dxS3] = dx.strides;
    const dyValues = backend2.data.get(dy.dataId).values;
    const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
    const fltValues = backend2.data.get(filter2.dataId).values;
    const [fltS0, fltS1, fltS2, fltS3] = filterStrides;
    const { batchSize, filterDepth, filterHeight, filterWidth, inChannels, inDepth, inHeight, inWidth, outChannels, outDepth, outHeight, outWidth, strideDepth, strideHeight, strideWidth } = convInfo;
    const frontPad = filterDepth - 1 - convInfo.padInfo.front;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    for (let b = 0; b < batchSize; ++b) {
      for (let d1 = 0; d1 < inChannels; ++d1) {
        for (let xF = 0; xF < inDepth; ++xF) {
          const xFCorner = xF - frontPad;
          const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));
          const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);
          for (let xR = 0; xR < inHeight; ++xR) {
            const xRCorner = xR - topPad;
            const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
            const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
            for (let xC = 0; xC < inWidth; ++xC) {
              const xCCorner = xC - leftPad;
              const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
              const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
              let dotProd = 0;
              for (let yF = xFMin; yF < yFMax; ++yF) {
                const wF = yF * strideDepth - xFCorner;
                for (let yR = xRMin; yR < yRMax; ++yR) {
                  const wR = yR * strideHeight - xRCorner;
                  for (let yC = xCMin; yC < yCMax; ++yC) {
                    const wC = yC * strideWidth - xCCorner;
                    const dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;
                    const fltOffset = fltS0 * (filterDepth - 1 - wF) + fltS1 * (filterHeight - 1 - wR) + fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;
                    for (let d2 = 0; d2 < outChannels; ++d2) {
                      const pixel = dyValues[dyOffset + d2];
                      const weight = fltValues[fltOffset + d2];
                      dotProd += pixel * weight;
                    }
                  }
                }
              }
              dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] = dotProd;
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var conv3DBackpropInputV2Config = {
    kernelName: Conv3DBackpropInputV2,
    backendName: "cpu",
    kernelFunc: conv3DBackpropInputV2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cos.js
  var cos3 = unaryKernelFunc(Cos, (xi) => Math.cos(xi));
  var cosConfig = {
    kernelName: Cos,
    backendName: "cpu",
    kernelFunc: cos3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cosh.js
  var cosh2 = unaryKernelFunc(Cosh, (xi) => Math.cosh(xi));
  var coshConfig = {
    kernelName: Cosh,
    backendName: "cpu",
    kernelFunc: cosh2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/CropAndResize.js
  function cropAndResize2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { image: image3, boxes, boxInd } = inputs;
    const { cropSize, method, extrapolationValue } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
    const numBoxes = boxes.shape[0];
    const [cropHeight, cropWidth] = cropSize;
    const output = buffer2([numBoxes, cropHeight, cropWidth, numChannels], "float32");
    const boxVals = backend2.data.get(boxes.dataId).values;
    const boxIndVals = backend2.data.get(boxInd.dataId).values;
    const imageVals = backend2.data.get(image3.dataId).values;
    const inStride = util_exports2.computeStrides(image3.shape);
    const outStride = util_exports2.computeStrides(output.shape);
    for (let b = 0; b < numBoxes; b++) {
      const startInd = b * 4;
      const y1 = boxVals[startInd];
      const x1 = boxVals[startInd + 1];
      const y2 = boxVals[startInd + 2];
      const x2 = boxVals[startInd + 3];
      const bInd = boxIndVals[b];
      if (bInd >= batch) {
        continue;
      }
      const heightScale = cropHeight > 1 ? (y2 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;
      const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;
      for (let y = 0; y < cropHeight; y++) {
        const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y2) * (imageHeight - 1);
        if (yInd < 0 || yInd > imageHeight - 1) {
          for (let x = 0; x < cropWidth; x++) {
            for (let c = 0; c < numChannels; c++) {
              const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
              output.values[ind] = extrapolationValue;
            }
          }
          continue;
        }
        if (method === "bilinear") {
          const topInd = Math.floor(yInd);
          const bottomInd = Math.ceil(yInd);
          const yLerp = yInd - topInd;
          for (let x = 0; x < cropWidth; x++) {
            const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
            if (xInd < 0 || xInd > imageWidth - 1) {
              for (let c = 0; c < numChannels; c++) {
                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                output.values[ind] = extrapolationValue;
              }
              continue;
            }
            const leftInd = Math.floor(xInd);
            const rightInd = Math.ceil(xInd);
            const xLerp = xInd - leftInd;
            for (let c = 0; c < numChannels; c++) {
              let ind = c + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
              const topLeft = imageVals[ind];
              ind = c + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
              const topRight = imageVals[ind];
              ind = c + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
              const bottomLeft = imageVals[ind];
              ind = c + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
              const bottomRight = imageVals[ind];
              const top = topLeft + (topRight - topLeft) * xLerp;
              const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;
              ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
              output.values[ind] = top + (bottom - top) * yLerp;
            }
          }
        } else {
          for (let x = 0; x < cropWidth; ++x) {
            const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
            if (xInd < 0 || xInd > imageWidth - 1) {
              for (let c = 0; c < numChannels; c++) {
                const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
                output.values[ind] = extrapolationValue;
              }
              continue;
            }
            const closestX = Math.round(xInd);
            const closestY = Math.round(yInd);
            for (let c = 0; c < numChannels; c++) {
              const inInd = c + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];
              const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
              output.values[outInd] = imageVals[inInd];
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(output.shape, output.dtype, output.values);
  }
  var cropAndResizeConfig = {
    kernelName: CropAndResize,
    backendName: "cpu",
    kernelFunc: cropAndResize2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cumsum.js
  function cumsum2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, exclusive, reverse: reverse4 } = attrs;
    assertNotComplex(x, "cumsum");
    const permutation = backend_util_exports.getAxesPermutation([axis], x.shape.length);
    let $x = x;
    if (permutation != null) {
      $x = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutation } });
    }
    const permutedAxis = backend_util_exports.getInnerMostAxes(1, x.shape.length)[0];
    if (permutedAxis !== $x.shape.length - 1) {
      throw new Error(`backend.cumsum in CPU expects an inner-most axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);
    }
    const resultDtype = upcastType($x.dtype, "int32");
    const vals = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape($x.shape), resultDtype);
    const aVals = backend2.data.get($x.dataId).values;
    const finalDim = $x.shape[$x.shape.length - 1];
    const indexAdjuster = reverse4 ? (i, j) => i + finalDim - j - 1 : (i, j) => i + j;
    for (let i = 0; i < aVals.length; i += finalDim) {
      for (let j = 0; j < finalDim; j++) {
        const idx = indexAdjuster(i, j);
        if (j === 0) {
          vals[idx] = exclusive ? 0 : aVals[idx];
        } else {
          const prevIdx = indexAdjuster(i, j - 1);
          vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];
        }
      }
    }
    const result = backend2.makeTensorInfo($x.shape, resultDtype, vals);
    if (permutation != null) {
      const reversePermutation = backend_util_exports.getUndoAxesPermutation(permutation);
      const reverseTransposedResult = transpose3({ inputs: { x: result }, backend: backend2, attrs: { perm: reversePermutation } });
      backend2.disposeIntermediateTensorInfo(result);
      backend2.disposeIntermediateTensorInfo($x);
      return reverseTransposedResult;
    }
    return result;
  }
  var cumsumConfig = {
    kernelName: Cumsum,
    backendName: "cpu",
    kernelFunc: cumsum2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DenseBincount.js
  function denseBincount(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, weights } = inputs;
    const { size: size3, binaryOutput } = attrs;
    if (x.shape.length === 1) {
      const xVals = backend2.data.get(x.dataId).values;
      const weightsVals = backend2.data.get(weights.dataId).values;
      const outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size3);
      return backend2.makeTensorInfo([size3], weights.dtype, outVals);
    } else if (x.shape.length === 2) {
      const xBuf = backend2.bufferSync(x);
      const weightsBuf = backend2.bufferSync(weights);
      const outBuf = bincountReduceImpl(xBuf, weightsBuf, size3, binaryOutput);
      return backend2.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x.shape.length}.`);
  }
  var denseBincountConfig = {
    kernelName: DenseBincount,
    backendName: "cpu",
    kernelFunc: denseBincount
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthToSpace.js
  function depthToSpace2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockSize, dataFormat } = attrs;
    util_exports2.assert(dataFormat === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);
    const batchSize = x.shape[0];
    const inputHeight = x.shape[1];
    const inputWidth = x.shape[2];
    const inputDepth = x.shape[3];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const xValues = backend2.data.get(x.dataId).values;
    const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);
    let outputIdx = 0;
    for (let b = 0; b < batchSize; ++b) {
      for (let h2 = 0; h2 < outputHeight; ++h2) {
        const inH = Math.floor(h2 / blockSize);
        const offsetH = h2 % blockSize;
        for (let w = 0; w < outputWidth; ++w) {
          const inW = Math.floor(w / blockSize);
          const offsetW = w % blockSize;
          const offsetD = (offsetH * blockSize + offsetW) * outputDepth;
          for (let d = 0; d < outputDepth; ++d) {
            const inD = d + offsetD;
            const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));
            result[outputIdx++] = xValues[inputIdx];
          }
        }
      }
    }
    return backend2.makeTensorInfo([batchSize, outputHeight, outputWidth, outputDepth], x.dtype, result);
  }
  var depthToSpaceConfig = {
    kernelName: DepthToSpace,
    backendName: "cpu",
    kernelFunc: depthToSpace2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNative.js
  function depthwiseConv2dNative(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dilations, dimRoundingMode } = attrs;
    assertNotComplex([x, filter2], "depthwiseConv2DNative");
    const xStrides = util_exports2.computeStrides(x.shape);
    const filterStrides = util_exports2.computeStrides(filter2.shape);
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter2.shape, strides, $dilations, pad3, dimRoundingMode, true);
    const { filterHeight, filterWidth, dilationHeight, dilationWidth, padInfo } = convInfo;
    const padLeft = padInfo.left;
    const padTop = padInfo.top;
    const chMul = convInfo.outChannels / convInfo.inChannels;
    const y = new TensorBuffer(convInfo.outShape, x.dtype);
    const xVals = backend2.data.get(x.dataId).values;
    const wVals = backend2.data.get(filter2.dataId).values;
    const yVals = y.values;
    for (let b = 0; b < convInfo.batchSize; ++b) {
      const xOffset1 = b * xStrides[0];
      const yOffset1 = b * y.strides[0];
      for (let yR = 0; yR < convInfo.outHeight; ++yR) {
        const yOffset2 = yOffset1 + yR * y.strides[1];
        const xRCorner = yR * convInfo.strideHeight - padTop;
        for (let wR = 0; wR < filterHeight; ++wR) {
          const xR = xRCorner + wR * dilationHeight;
          if (xR < 0 || xR >= convInfo.inHeight) {
            continue;
          }
          const wOffset1 = wR * filterStrides[0];
          const xOffset2 = xOffset1 + xR * xStrides[1];
          for (let yC = 0; yC < convInfo.outWidth; ++yC) {
            const yOffset3 = yOffset2 + yC * y.strides[2];
            const xCCorner = yC * convInfo.strideWidth - padLeft;
            for (let wC = 0; wC < filterWidth; ++wC) {
              const xC = xCCorner + wC * dilationWidth;
              if (xC < 0 || xC >= convInfo.inWidth) {
                continue;
              }
              const wOffset2 = wOffset1 + wC * filterStrides[1];
              const xOffset3 = xOffset2 + xC * convInfo.inChannels;
              let yOffset4 = yOffset3;
              let wOffset3 = wOffset2;
              for (let d1 = 0; d1 < convInfo.inChannels; ++d1) {
                const xVal = xVals[xOffset3 + d1];
                for (let q = 0; q < chMul; ++q) {
                  yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];
                }
                yOffset4 += chMul;
                wOffset3 += chMul;
              }
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(y.shape, y.dtype, y.values);
  }
  var depthwiseConv2dNativeConfig = {
    kernelName: DepthwiseConv2dNative,
    backendName: "cpu",
    kernelFunc: depthwiseConv2dNative
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
  function depthwiseConv2dNativeBackpropFilter2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, dilations, pad: pad3, dimRoundingMode, filterShape } = attrs;
    assertNotComplex([x, dy], "depthwiseConv2dNativeBackpropFilter");
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad3, dimRoundingMode, true);
    const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;
    const dW = new TensorBuffer(convInfo.filterShape, "float32");
    const leftPad = convInfo.padInfo.left;
    const topPad = convInfo.padInfo.top;
    const chMul = convInfo.outChannels / convInfo.inChannels;
    const xVals = backend2.data.get(x.dataId).values;
    const xBuf = new TensorBuffer(x.shape, x.dtype, xVals);
    const dyVals = backend2.data.get(dy.dataId).values;
    const dyBuf = new TensorBuffer(dy.shape, dy.dtype, dyVals);
    for (let wR = 0; wR < filterHeight; ++wR) {
      const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
      const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
      for (let wC = 0; wC < filterWidth; ++wC) {
        const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
        const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
        for (let d2 = 0; d2 < convInfo.outChannels; ++d2) {
          const d1 = Math.trunc(d2 / chMul);
          const dm = d2 % chMul;
          let dotProd = 0;
          for (let b = 0; b < convInfo.batchSize; ++b) {
            for (let yR = yRMin; yR < yRMax; ++yR) {
              const xR = wR + yR * strideHeight - topPad;
              for (let yC = yCMin; yC < yCMax; ++yC) {
                const xC = wC + yC * strideWidth - leftPad;
                dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
              }
            }
          }
          dW.set(dotProd, wR, wC, d1, dm);
        }
      }
    }
    return backend2.makeTensorInfo(dW.shape, dW.dtype, dW.values);
  }
  var depthwiseConv2dNativeBackpropFilterConfig = {
    kernelName: DepthwiseConv2dNativeBackpropFilter,
    backendName: "cpu",
    kernelFunc: depthwiseConv2dNativeBackpropFilter2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
  function depthwiseConv2dNativeBackpropInput2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter: filter2 } = inputs;
    const { strides, dilations, pad: pad3, dimRoundingMode, inputShape } = attrs;
    assertNotComplex([dy, filter2], "depthwiseConv2DNativeBackpropInput");
    const dyStrides = util_exports2.computeStrides(dy.shape);
    const filterStrides = util_exports2.computeStrides(filter2.shape);
    const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter2.shape, strides, dilations, pad3, dimRoundingMode, true);
    const dx = new TensorBuffer(convInfo.inShape, "float32");
    const dxValues = dx.values;
    const [dxS0, dxS1, dxS2] = dx.strides;
    const dyValues = backend2.data.get(dy.dataId).values;
    const [dyS0, dyS1, dyS2] = dyStrides;
    const fltValues = backend2.data.get(filter2.dataId).values;
    const [fltS0, fltS1, fltS2] = filterStrides;
    const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
    const topPad = filterHeight - 1 - convInfo.padInfo.top;
    const leftPad = filterWidth - 1 - convInfo.padInfo.left;
    const chMul = outChannels / inChannels;
    for (let b = 0; b < batchSize; ++b) {
      for (let d1 = 0; d1 < inChannels; ++d1) {
        for (let xR = 0; xR < inHeight; ++xR) {
          const xRCorner = xR - topPad;
          const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
          const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
          for (let xC = 0; xC < inWidth; ++xC) {
            const xCCorner = xC - leftPad;
            const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
            const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
            let dotProd = 0;
            for (let yR = xRMin; yR < yRMax; ++yR) {
              const wR = yR * strideHeight - xRCorner;
              for (let yC = xCMin; yC < yCMax; ++yC) {
                const wC = yC * strideWidth - xCCorner;
                const dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
                const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
                for (let dm = 0; dm < chMul; ++dm) {
                  const d2 = d1 * chMul + dm;
                  const pixel = dyValues[dyOffset + d2];
                  const weight = fltValues[fltOffset + dm];
                  dotProd += pixel * weight;
                }
              }
            }
            dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var depthwiseConv2dNativeBackpropInputConfig = {
    kernelName: DepthwiseConv2dNativeBackpropInput,
    backendName: "cpu",
    kernelFunc: depthwiseConv2dNativeBackpropInput2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Diag.js
  function diag(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    const xSize = util_exports2.sizeFromShape(x.shape);
    const xVals = backend2.data.get(x.dataId).values;
    const outBuf = buffer2([xSize, xSize], x.dtype);
    const vals = outBuf.values;
    for (let i = 0; i < xVals.length; i++) {
      vals[i * xSize + i] = xVals[i];
    }
    const outShape = [...x.shape, ...x.shape];
    return backend2.makeTensorInfo(outShape, outBuf.dtype, outBuf.values);
  }
  var diagConfig = {
    kernelName: Diag,
    backendName: "cpu",
    kernelFunc: diag
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2D.js
  var dilation2dConfig = {
    kernelName: Dilation2D,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend2, attrs }) => {
      const { x, filter: filter2 } = inputs;
      const { strides, pad: pad3, dilations } = attrs;
      const cpuBackend = backend2;
      const xVals = cpuBackend.data.get(x.dataId).values;
      const xRank = x.shape.length;
      const filterVals = cpuBackend.data.get(filter2.dataId).values;
      const filterRank = filter2.shape.length;
      const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = backend_util_exports.computeDilation2DInfo(x.shape, filter2.shape, strides, pad3, "NHWC", dilations);
      const outSize = util_exports2.sizeFromShape(outShape);
      const outRank = outShape.length;
      const outputVals = util_exports2.getArrayFromDType(x.dtype, outSize);
      for (let b = 0; b < batchSize; ++b) {
        for (let hOut = 0; hOut < outHeight; ++hOut) {
          const hBeg = hOut * strideHeight - padInfo.top;
          for (let wOut = 0; wOut < outWidth; ++wOut) {
            const wBeg = wOut * strideWidth - padInfo.left;
            for (let d = 0; d < inChannels; ++d) {
              let curVal = Number.MIN_SAFE_INTEGER;
              for (let h2 = 0; h2 < filterHeight; ++h2) {
                const hIn = hBeg + h2 * dilationHeight;
                if (hIn >= 0 && hIn < inHeight) {
                  for (let w = 0; w < filterWidth; ++w) {
                    const wIn = wBeg + w * dilationWidth;
                    if (wIn >= 0 && wIn < inWidth) {
                      const xIndex = util_exports2.locToIndex([b, hIn, wIn, d], xRank, util_exports2.computeStrides(x.shape));
                      const filterIndex = util_exports2.locToIndex([h2, w, d], filterRank, util_exports2.computeStrides(filter2.shape));
                      const val = xVals[xIndex] + filterVals[filterIndex];
                      if (val > curVal) {
                        curVal = val;
                      }
                    }
                  }
                }
              }
              const outputIndex = util_exports2.locToIndex([b, hOut, wOut, d], outRank, util_exports2.computeStrides(outShape));
              outputVals[outputIndex] = curVal;
            }
          }
        }
      }
      const dataId = cpuBackend.write(util_exports2.toTypedArray(outputVals, x.dtype), outShape, x.dtype);
      return { dataId, shape: outShape, dtype: x.dtype };
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2DBackpropFilter.js
  var dilation2dBackpropFilterConfig = {
    kernelName: Dilation2DBackpropFilter,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend2, attrs }) => {
      const { x, filter: filter2, dy } = inputs;
      const { strides, pad: pad3, dilations } = attrs;
      const cpuBackend = backend2;
      const $x = util_exports2.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);
      const $filter = util_exports2.toNestedArray(filter2.shape, cpuBackend.data.get(filter2.dataId).values);
      const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = backend_util_exports.computeDilation2DInfo(x.shape, filter2.shape, strides, pad3, "NHWC", dilations);
      util_exports2.assert(dy.rank === outShape.length, () => `Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);
      const $dy = util_exports2.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);
      const gradients = util_exports2.makeZerosNestedTypedArray(filter2.shape, filter2.dtype);
      for (let b = 0; b < batchSize; ++b) {
        for (let hOut = 0; hOut < outHeight; ++hOut) {
          const hBeg = hOut * strideHeight - padInfo.top;
          for (let wOut = 0; wOut < outWidth; ++wOut) {
            const wBeg = wOut * strideWidth - padInfo.left;
            for (let d = 0; d < inChannels; ++d) {
              let curVal = Number.MIN_SAFE_INTEGER;
              let hMax = 0;
              let wMax = 0;
              for (let h2 = 0; h2 < filterHeight; ++h2) {
                const hIn = hBeg + h2 * dilationHeight;
                if (hIn >= 0 && hIn < inHeight) {
                  for (let w = 0; w < filterWidth; ++w) {
                    const wIn = wBeg + w * dilationWidth;
                    if (wIn >= 0 && wIn < inWidth) {
                      const val = $x[b][hIn][wIn][d] + $filter[h2][w][d];
                      if (val > curVal) {
                        curVal = val;
                        hMax = h2;
                        wMax = w;
                      }
                    }
                  }
                }
              }
              gradients[hMax][wMax][d] += $dy[b][hOut][wOut][d];
            }
          }
        }
      }
      const dataId = cpuBackend.write(util_exports2.toTypedArray(gradients, x.dtype), filter2.shape, filter2.dtype);
      return { dataId, shape: filter2.shape, dtype: filter2.dtype };
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2DBackpropInput.js
  var dilation2dBackpropInputConfig = {
    kernelName: Dilation2DBackpropInput,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend2, attrs }) => {
      const { x, filter: filter2, dy } = inputs;
      const { strides, pad: pad3, dilations } = attrs;
      const cpuBackend = backend2;
      const $x = util_exports2.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);
      const $filter = util_exports2.toNestedArray(filter2.shape, cpuBackend.data.get(filter2.dataId).values);
      const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = backend_util_exports.computeDilation2DInfo(x.shape, filter2.shape, strides, pad3, "NHWC", dilations);
      util_exports2.assert(dy.rank === outShape.length, () => `Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${outShape.length}, but got ${dy.rank}`);
      const $dy = util_exports2.toNestedArray(outShape, cpuBackend.data.get(dy.dataId).values);
      const gradients = util_exports2.makeZerosNestedTypedArray(x.shape, x.dtype);
      for (let b = 0; b < batchSize; ++b) {
        for (let hOut = 0; hOut < outHeight; ++hOut) {
          const hBeg = hOut * strideHeight - padInfo.top;
          for (let wOut = 0; wOut < outWidth; ++wOut) {
            const wBeg = wOut * strideWidth - padInfo.left;
            for (let d = 0; d < inChannels; ++d) {
              let curVal = Number.MIN_SAFE_INTEGER;
              let hInMax = hBeg < 0 ? 0 : hBeg;
              let wInMax = wBeg < 0 ? 0 : wBeg;
              for (let h2 = 0; h2 < filterHeight; ++h2) {
                const hIn = hBeg + h2 * dilationHeight;
                if (hIn >= 0 && hIn < inHeight) {
                  for (let w = 0; w < filterWidth; ++w) {
                    const wIn = wBeg + w * dilationWidth;
                    if (wIn >= 0 && wIn < inWidth) {
                      const val = $x[b][hIn][wIn][d] + $filter[h2][w][d];
                      if (val > curVal) {
                        curVal = val;
                        hInMax = hIn;
                        wInMax = wIn;
                      }
                    }
                  }
                }
              }
              gradients[b][hInMax][wInMax][d] += $dy[b][hOut][wOut][d];
            }
          }
        }
      }
      const dataId = cpuBackend.write(util_exports2.toTypedArray(gradients, x.dtype), x.shape, x.dtype);
      return { dataId, shape: x.shape, dtype: x.dtype };
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sum.js
  function sum3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    assertNotComplex(x, "sum");
    let $x;
    if (x.dtype === "bool") {
      $x = cast3({ inputs: { x }, backend: backend2, attrs: { dtype: "int32" } });
    } else {
      $x = identity3({ inputs: { x }, backend: backend2 });
    }
    const xRank = $x.shape.length;
    const axes = util_exports2.parseAxisParam(axis, $x.shape);
    const permutation = backend_util_exports.getAxesPermutation(axes, xRank);
    let reductionAxes = axes;
    let permutedX = $x;
    if (permutation != null) {
      permutedX = transpose3({ inputs: { x: $x }, backend: backend2, attrs: { perm: permutation } });
      reductionAxes = backend_util_exports.getInnerMostAxes(reductionAxes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("sum", reductionAxes, permutedX.shape.length);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, reductionAxes);
    const resultDtype = backend_util_exports.upcastType(permutedX.dtype, "int32");
    let result = zeros2(backend2, outShape, resultDtype);
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const vals = backend2.data.get(result.dataId).values;
    const aVals = backend2.data.get(permutedX.dataId).values;
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let sum5 = 0;
      for (let j = 0; j < reduceSize; ++j) {
        sum5 += aVals[offset + j];
      }
      vals[i] = sum5;
    }
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(result.shape, axes);
      const oldResult = result;
      result = reshape2({ inputs: { x: result }, backend: backend2, attrs: { shape: newShape } });
      backend2.disposeIntermediateTensorInfo(oldResult);
    }
    backend2.disposeIntermediateTensorInfo($x);
    if (permutation != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return result;
  }
  var sumConfig = {
    kernelName: Sum,
    backendName: "cpu",
    kernelFunc: sum3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Einsum.js
  function einsum(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { equation } = attrs;
    const tensors = inputs;
    const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
    backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
    const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
    const nSteps = steps.length;
    let out = null;
    let numDimsRemaining = allDims.length;
    const tensorsToDispose = [];
    for (let i = 0; i < nSteps; ++i) {
      for (const idTerm of steps[i]) {
        const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
        let x;
        if (backend_util_exports.isIdentityPermutation(perm)) {
          x = tensors[idTerm];
        } else {
          x = transpose3({ inputs: { x: tensors[idTerm] }, backend: backend2, attrs: { perm } });
          tensorsToDispose.push(x);
        }
        const targetShape = x.shape.slice();
        for (let k = 0; k < dimsToExpand.length; ++k) {
          targetShape.splice(dimsToExpand[k], 0, 1);
        }
        if (!util_exports2.arraysEqual(x.shape, targetShape)) {
          x = reshape2({ inputs: { x }, backend: backend2, attrs: { shape: targetShape } });
          tensorsToDispose.push(x);
        }
        if (out === null) {
          out = x;
        } else {
          out = multiply4({ inputs: { a: x, b: out }, backend: backend2 });
          tensorsToDispose.push(out);
        }
      }
      if (i < nSteps - 1) {
        if (path[i] >= 0) {
          out = sum3({
            inputs: { x: out },
            backend: backend2,
            attrs: {
              axis: path[i] - (allDims.length - numDimsRemaining),
              keepDims: false
            }
          });
          tensorsToDispose.push(out);
        }
        numDimsRemaining--;
      }
    }
    for (const tensorInfo of tensorsToDispose) {
      if (tensorInfo === out) {
        continue;
      }
      backend2.disposeIntermediateTensorInfo(tensorInfo);
    }
    return out;
  }
  var einsumConfig = {
    kernelName: Einsum,
    backendName: "cpu",
    kernelFunc: einsum
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/EluGrad.js
  function eluGrad(args) {
    const { inputs, backend: backend2 } = args;
    const { dy, y } = inputs;
    assertNotComplex([dy, y], "eluGrad");
    const resultValues = new Float32Array(util_exports2.sizeFromShape(y.shape));
    const values2 = backend2.data.get(y.dataId).values;
    const dyValues = backend2.data.get(dy.dataId).values;
    for (let i = 0; i < values2.length; ++i) {
      const v = values2[i];
      if (v >= 1) {
        resultValues[i] = dyValues[i];
      } else {
        resultValues[i] = dyValues[i] * (v + 1);
      }
    }
    return backend2.makeTensorInfo(y.shape, "float32", resultValues);
  }
  var eluGradConfig2 = {
    kernelName: EluGrad,
    backendName: "cpu",
    kernelFunc: eluGrad
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Erf.js
  var p2 = backend_util_exports.ERF_P;
  var a1 = backend_util_exports.ERF_A1;
  var a2 = backend_util_exports.ERF_A2;
  var a3 = backend_util_exports.ERF_A3;
  var a4 = backend_util_exports.ERF_A4;
  var a5 = backend_util_exports.ERF_A5;
  var erf2 = unaryKernelFunc(Erf, (xi) => {
    const sign4 = Math.sign(xi);
    const v = Math.abs(xi);
    const t = 1 / (1 + p2 * v);
    return sign4 * (1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-v * v));
  });
  var erfConfig = {
    kernelName: Erf,
    backendName: "cpu",
    kernelFunc: erf2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ExpandDims.js
  function expandDims3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { input: input2 } = inputs;
    const { dim } = attrs;
    const inputRank = input2.shape.length;
    const newShape = input2.shape.slice();
    let $dim = dim;
    if (dim < 0) {
      util_exports2.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
      $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return reshape2({ inputs: { x: input2 }, backend: backend2, attrs: { shape: newShape } });
  }
  var expandDimsConfig = {
    kernelName: ExpandDims,
    backendName: "cpu",
    kernelFunc: expandDims3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RealDiv.js
  var realDivImpl = createSimpleBinaryKernelImpl((a, b) => a / b);
  var div4 = binaryKernelFunc(RealDiv, realDivImpl);
  var realDivConfig = {
    kernelName: RealDiv,
    backendName: "cpu",
    kernelFunc: div4
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fft_utils.js
  function fftBatch(input2, inverse3, cpuBackend) {
    const inputShape = input2.shape;
    const batch = inputShape[0];
    const innerDim = inputShape[1];
    const inputVals = cpuBackend.data.get(input2.dataId);
    const real2D = inputVals.complexTensorInfos.real;
    const imag2D = inputVals.complexTensorInfos.imag;
    const resultShape = [batch, innerDim];
    const resultSize = util_exports2.sizeFromShape(resultShape);
    const resultReal = util_exports2.getTypedArrayFromDType("float32", resultSize);
    const resultImag = util_exports2.getTypedArrayFromDType("float32", resultSize);
    for (let b = 0; b < batch; b++) {
      const r = slice2({
        inputs: { x: real2D },
        backend: cpuBackend,
        attrs: { begin: [b, 0], size: [1, innerDim] }
      });
      const i = slice2({
        inputs: { x: imag2D },
        backend: cpuBackend,
        attrs: { begin: [b, 0], size: [1, innerDim] }
      });
      const input3 = complex2({ inputs: { real: r, imag: i }, backend: cpuBackend });
      const { real: real4, imag: imag4 } = fftImpl(input3, inverse3, cpuBackend);
      const res = backend_util_exports.mergeRealAndImagArrays(real4, imag4);
      for (let d = 0; d < innerDim; d++) {
        const c = backend_util_exports.getComplexWithIndex(res, d);
        resultReal[b * innerDim + d] = c.real;
        resultImag[b * innerDim + d] = c.imag;
      }
      cpuBackend.disposeIntermediateTensorInfo(r);
      cpuBackend.disposeIntermediateTensorInfo(i);
      cpuBackend.disposeIntermediateTensorInfo(input3);
    }
    const $realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultReal);
    const $imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultImag);
    const result = complex2({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });
    cpuBackend.disposeIntermediateTensorInfo($realInfo);
    cpuBackend.disposeIntermediateTensorInfo($imagInfo);
    return result;
  }
  function fftImpl(input2, inverse3, cpuBackend) {
    const inputSize = util_exports2.sizeFromShape(input2.shape);
    const inputVals = cpuBackend.data.get(input2.dataId);
    const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;
    const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;
    if (isExponentOf2(inputSize)) {
      const result = fftRadix2(realVals, imagVals, inputSize, inverse3, cpuBackend);
      const resultShape = [input2.shape[0], input2.shape[1]];
      if (inverse3) {
        const realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.real);
        const imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.imag);
        const sizeInfo = cpuBackend.makeTensorInfo([], "float32", util_exports2.createScalarValue(inputSize, "float32"));
        const sizeInfoCopy = identity3({ inputs: { x: sizeInfo }, backend: cpuBackend });
        const divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });
        const divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });
        const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;
        const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;
        cpuBackend.disposeIntermediateTensorInfo(realInfo);
        cpuBackend.disposeIntermediateTensorInfo(imagInfo);
        cpuBackend.disposeIntermediateTensorInfo(sizeInfo);
        cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);
        cpuBackend.disposeIntermediateTensorInfo(divRealInfo);
        cpuBackend.disposeIntermediateTensorInfo(divImagInfo);
        return { real: divRealVals, imag: divImagVals };
      }
      return result;
    } else {
      const data = backend_util_exports.mergeRealAndImagArrays(realVals, imagVals);
      const rawOutput = fourierTransformByMatmul(data, inputSize, inverse3);
      return backend_util_exports.splitRealAndImagArrays(rawOutput);
    }
  }
  function isExponentOf2(size3) {
    return (size3 & size3 - 1) === 0;
  }
  function fftRadix2(realVals, imagVals, size3, inverse3, cpuBackend) {
    if (size3 === 1) {
      return { real: realVals, imag: imagVals };
    }
    const data = backend_util_exports.mergeRealAndImagArrays(realVals, imagVals);
    const half = size3 / 2;
    const evenComplex = backend_util_exports.complexWithEvenIndex(data);
    const evenRealVals = evenComplex.real;
    const evenImagVals = evenComplex.imag;
    const evenShape = [evenRealVals.length];
    const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenRealVals);
    const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenImagVals);
    const evenTensorInfo = complex2({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });
    const oddComplex = backend_util_exports.complexWithOddIndex(data);
    const oddRealVals = oddComplex.real;
    const oddImagVals = oddComplex.imag;
    const oddShape = [oddRealVals.length];
    const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddRealVals);
    const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddImagVals);
    const oddTensorInfo = complex2({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });
    const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse3, cpuBackend);
    const $evenRealVals = $evenComplex.real;
    const $evenImagVals = $evenComplex.imag;
    const $evenShape = [$evenRealVals.length];
    const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenRealVals);
    const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenImagVals);
    const $evenTensorInfo = complex2({
      inputs: { real: $evenRealInfo, imag: $evenImagInfo },
      backend: cpuBackend
    });
    const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse3, cpuBackend);
    const $oddRealVals = $oddComplex.real;
    const $oddImagVals = $oddComplex.imag;
    const $oddShape = [$oddRealVals.length];
    const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddRealVals);
    const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddImagVals);
    const $oddTensorInfo = complex2({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });
    const e = backend_util_exports.exponents(size3, inverse3);
    const eShape = [e.real.length];
    const eRealInfo = cpuBackend.makeTensorInfo(eShape, "float32", e.real);
    const eImagInfo = cpuBackend.makeTensorInfo(eShape, "float32", e.imag);
    const complexInfo = complex2({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });
    const exponentInfo = multiply4({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });
    const addPart = add7({
      inputs: { a: $evenTensorInfo, b: exponentInfo },
      backend: cpuBackend
    });
    const subPart = sub5({
      inputs: { a: $evenTensorInfo, b: exponentInfo },
      backend: cpuBackend
    });
    const addPartReal = real2({ inputs: { input: addPart }, backend: cpuBackend });
    const subPartReal = real2({ inputs: { input: subPart }, backend: cpuBackend });
    const addPartImag = imag2({ inputs: { input: addPart }, backend: cpuBackend });
    const subPartImag = imag2({ inputs: { input: subPart }, backend: cpuBackend });
    const $real = concat2({
      inputs: [addPartReal, subPartReal],
      backend: cpuBackend,
      attrs: { axis: 0 }
    });
    const $imag = concat2({
      inputs: [addPartImag, subPartImag],
      backend: cpuBackend,
      attrs: { axis: 0 }
    });
    const $realVals = cpuBackend.data.get($real.dataId).values;
    const $imagVals = cpuBackend.data.get($imag.dataId).values;
    cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);
    cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);
    cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);
    cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);
    cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);
    cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);
    cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);
    cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);
    cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);
    cpuBackend.disposeIntermediateTensorInfo(eRealInfo);
    cpuBackend.disposeIntermediateTensorInfo(eImagInfo);
    cpuBackend.disposeIntermediateTensorInfo(complexInfo);
    cpuBackend.disposeIntermediateTensorInfo(exponentInfo);
    cpuBackend.disposeIntermediateTensorInfo(addPart);
    cpuBackend.disposeIntermediateTensorInfo(subPart);
    cpuBackend.disposeIntermediateTensorInfo(addPartReal);
    cpuBackend.disposeIntermediateTensorInfo(addPartImag);
    cpuBackend.disposeIntermediateTensorInfo(subPartReal);
    cpuBackend.disposeIntermediateTensorInfo(subPartImag);
    cpuBackend.disposeIntermediateTensorInfo($real);
    cpuBackend.disposeIntermediateTensorInfo($imag);
    return { real: $realVals, imag: $imagVals };
  }
  function fourierTransformByMatmul(data, size3, inverse3) {
    const ret = new Float32Array(size3 * 2);
    for (let r = 0; r < size3; r++) {
      let real4 = 0;
      let imag4 = 0;
      for (let c = 0; c < size3; c++) {
        const e = backend_util_exports.exponent(r * c, size3, inverse3);
        const term = backend_util_exports.getComplexWithIndex(data, c);
        real4 += term.real * e.real - term.imag * e.imag;
        imag4 += term.real * e.imag + term.imag * e.real;
      }
      if (inverse3) {
        real4 /= size3;
        imag4 /= size3;
      }
      backend_util_exports.assignToTypedArray(ret, real4, imag4, r);
    }
    return ret;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FFT.js
  function fft2(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    const inputSize = util_exports2.sizeFromShape(input2.shape);
    const innerDimensionSize = input2.shape[input2.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = reshape2({
      inputs: { x: input2 },
      backend: backend2,
      attrs: { shape: [batch, innerDimensionSize] }
    });
    const result = fftBatch(input2D, false, backend2);
    const resultReshaped = reshape2({ inputs: { x: result }, backend: backend2, attrs: { shape: input2.shape } });
    backend2.disposeIntermediateTensorInfo(input2D);
    backend2.disposeIntermediateTensorInfo(result);
    return resultReshaped;
  }
  var fftConfig = {
    kernelName: FFT,
    backendName: "cpu",
    kernelFunc: fft2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Fill.js
  function fill2(args) {
    const { backend: backend2, attrs } = args;
    const { shape, value, dtype } = attrs;
    const $dtype = dtype || util_exports2.inferDtype(value);
    const values2 = util_exports2.getArrayFromDType($dtype, util_exports2.sizeFromShape(shape));
    fillValues(values2, value, $dtype);
    return backend2.makeTensorInfo(shape, $dtype, values2);
  }
  var fillConfig = {
    kernelName: Fill,
    backendName: "cpu",
    kernelFunc: fill2
  };
  function fillValues(values2, value, dtype) {
    if (dtype === "string") {
      values2.fill(value);
    } else {
      values2.fill(value);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FlipLeftRight.js
  var flipLeftRightConfig = {
    kernelName: FlipLeftRight,
    backendName: "cpu",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { image: image3 } = inputs;
      const cpuBackend = backend2;
      const output = util_exports2.getTypedArrayFromDType(image3.dtype, util_exports2.sizeFromShape(image3.shape));
      const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
      const imageVals = cpuBackend.data.get(image3.dataId).values;
      for (let batchIdx = 0; batchIdx < batch; batchIdx++) {
        const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
        for (let row = 0; row < imageHeight; row++) {
          const rowOffset = row * (imageWidth * numChannels);
          for (let col = 0; col < imageWidth; col++) {
            const colOffset = col * numChannels;
            for (let channel = 0; channel < numChannels; channel++) {
              const coordX = Math.round(imageWidth - col - 1);
              const outIdx = batchOffset + rowOffset + colOffset + channel;
              let outputValue = imageVals[outIdx];
              if (coordX >= 0 && coordX < imageWidth) {
                const rotatedColOffset = coordX * numChannels;
                const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;
                outputValue = imageVals[imageIdx];
              }
              output[outIdx] = outputValue;
            }
          }
        }
      }
      const dataId = cpuBackend.write(output, image3.shape, image3.dtype);
      return { dataId, shape: image3.shape, dtype: image3.dtype };
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FloorDiv.js
  var floorDivImpl = createSimpleBinaryKernelImpl((a, b) => Math.floor(a / b));
  var floorDiv2 = binaryKernelFunc(FloorDiv, floorDivImpl, null, "int32");
  var floorDivConfig = {
    kernelName: FloorDiv,
    backendName: "cpu",
    kernelFunc: floorDiv2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FusedConv2D.js
  function fusedConv2D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    let result = conv2D({
      inputs: { x, filter: filter2 },
      backend: backend2,
      attrs: { strides, pad: pad3, dataFormat, dilations, dimRoundingMode }
    });
    if (bias) {
      const resultOld = result;
      result = add7({ inputs: { a: result, b: bias }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(resultOld);
    }
    if (activation) {
      const resultOld = result;
      result = applyActivation2(backend2, result, activation, preluActivationWeights, leakyreluAlpha);
      backend2.disposeIntermediateTensorInfo(resultOld);
    }
    return result;
  }
  var fusedConv2DConfig = {
    kernelName: FusedConv2D,
    backendName: "cpu",
    kernelFunc: fusedConv2D
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FusedDepthwiseConv2D.js
  function fusedDepthwiseConv2D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    let result = depthwiseConv2dNative({
      inputs: { x, filter: filter2 },
      backend: backend2,
      attrs: { strides, pad: pad3, dataFormat, dilations, dimRoundingMode }
    });
    if (bias) {
      const oldResult = result;
      result = add7({ inputs: { a: result, b: bias }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(oldResult);
    }
    if (activation) {
      const oldResult = result;
      result = applyActivation2(backend2, result, activation, preluActivationWeights, leakyreluAlpha);
      backend2.disposeIntermediateTensorInfo(oldResult);
    }
    return result;
  }
  var fusedDepthwiseConv2DConfig = {
    kernelName: FusedDepthwiseConv2D,
    backendName: "cpu",
    kernelFunc: fusedDepthwiseConv2D
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd.js
  function gatherNd(args) {
    const { inputs, backend: backend2 } = args;
    const { params, indices } = inputs;
    const paramsSize = util_exports2.sizeFromShape(params.shape);
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
    if (numSlices === 0) {
      return backend2.makeTensorInfo(resultShape, params.dtype, []);
    }
    const indicesData = backend2.data.get(indices.dataId).values;
    const paramsBuf = backend2.bufferSync(params);
    const outBuf = gatherNdImpl(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
    return backend2.makeTensorInfo(resultShape, params.dtype, outBuf.values);
  }
  var gatherNdConfig = {
    kernelName: GatherNd,
    backendName: "cpu",
    kernelFunc: gatherNd
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2.js
  function gatherV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, indices } = inputs;
    const { axis, batchDims } = attrs;
    assertNotComplex([x, indices], "gatherV2");
    const parsedAxis = util_exports2.parseAxisParam(axis, x.shape)[0];
    const indicesVals = backend2.data.get(indices.dataId).values;
    const axisDim = x.shape[parsedAxis];
    for (let i = 0; i < indicesVals.length; ++i) {
      const index = indicesVals[i];
      util_exports2.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);
    }
    let $batchDims = batchDims;
    if (batchDims == null) {
      $batchDims = 0;
    }
    const indicesSize = util_exports2.sizeFromShape(indices.shape);
    const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, $batchDims);
    const flattenX = reshape2({
      inputs: { x },
      backend: backend2,
      attrs: {
        shape: [
          shapeInfo.batchSize,
          shapeInfo.outerSize,
          shapeInfo.dimSize,
          shapeInfo.sliceSize
        ]
      }
    });
    const flattenIndex = reshape2({
      inputs: { x: indices },
      backend: backend2,
      attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
    });
    const flattenOutputShape = [
      shapeInfo.batchSize,
      shapeInfo.outerSize,
      indicesSize / shapeInfo.batchSize,
      shapeInfo.sliceSize
    ];
    const indicesBuf = backend2.bufferSync(flattenIndex);
    const xBuf = backend2.bufferSync(flattenX);
    const outBuf = gatherV2Impl(xBuf, indicesBuf, flattenOutputShape);
    backend2.disposeIntermediateTensorInfo(flattenX);
    backend2.disposeIntermediateTensorInfo(flattenIndex);
    return backend2.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
  }
  var gatherV2Config = {
    kernelName: GatherV2,
    backendName: "cpu",
    kernelFunc: gatherV2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IFFT.js
  function ifft2(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    const inputSize = util_exports2.sizeFromShape(input2.shape);
    const innerDimensionSize = input2.shape[input2.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = reshape2({
      inputs: { x: input2 },
      backend: backend2,
      attrs: { shape: [batch, innerDimensionSize] }
    });
    const result = fftBatch(input2D, true, backend2);
    const resultReshaped = reshape2({ inputs: { x: result }, backend: backend2, attrs: { shape: input2.shape } });
    backend2.disposeIntermediateTensorInfo(input2D);
    backend2.disposeIntermediateTensorInfo(result);
    return resultReshaped;
  }
  var ifftConfig = {
    kernelName: IFFT,
    backendName: "cpu",
    kernelFunc: ifft2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IsFinite.js
  var isFinite3 = unaryKernelFunc(IsFinite, (xi) => Number.isFinite(xi) ? 1 : 0, "bool");
  var isFiniteConfig = {
    kernelName: IsFinite,
    backendName: "cpu",
    kernelFunc: isFinite3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IsInf.js
  var isInf2 = unaryKernelFunc(IsInf, (xi) => Math.abs(xi) === Infinity ? 1 : 0, "bool");
  var isInfConfig = {
    kernelName: IsInf,
    backendName: "cpu",
    kernelFunc: isInf2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IsNaN.js
  var isNaN3 = unaryKernelFunc(IsNan, (xi) => Number.isNaN(xi) ? 1 : 0, "bool");
  var isNaNConfig = {
    kernelName: IsNan,
    backendName: "cpu",
    kernelFunc: isNaN3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace.js
  function linSpace(args) {
    const { backend: backend2, attrs } = args;
    const { start, stop: stop2, num } = attrs;
    const outVals = linSpaceImpl(start, stop2, num);
    return backend2.makeTensorInfo([outVals.length], "float32", outVals);
  }
  var linSpaceConfig = {
    kernelName: LinSpace,
    backendName: "cpu",
    kernelFunc: linSpace
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log1p.js
  var log1p2 = unaryKernelFunc(Log1p, (xi) => Math.log1p(xi));
  var log1pConfig = {
    kernelName: Log1p,
    backendName: "cpu",
    kernelFunc: log1p2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalAnd.js
  var logicalAndImpl = createSimpleBinaryKernelImpl((a, b) => a && b);
  var logicalAnd2 = binaryKernelFunc(LogicalAnd, logicalAndImpl, null, "bool");
  var logicalAndConfig = {
    kernelName: LogicalAnd,
    backendName: "cpu",
    kernelFunc: logicalAnd2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalNot.js
  var logicalNot2 = unaryKernelFunc(LogicalNot, (xi) => xi ? 0 : 1, "bool");
  var logicalNotConfig = {
    kernelName: LogicalNot,
    backendName: "cpu",
    kernelFunc: logicalNot2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalOr.js
  var logicalOrImpl = createSimpleBinaryKernelImpl((a, b) => a || b);
  var logicalOr2 = binaryKernelFunc(LogicalOr, logicalOrImpl, null, "bool");
  var logicalOrConfig = {
    kernelName: LogicalOr,
    backendName: "cpu",
    kernelFunc: logicalOr2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LRN.js
  function lRN(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    assertNotComplex(x, "LRN");
    const channels = x.shape[3];
    const maxD = channels - 1;
    const xValues = backend2.data.get(x.dataId).values;
    const size3 = util_exports2.sizeFromShape(x.shape);
    const result = new Float32Array(size3);
    function sumAcrossChannels(offset) {
      const currentChannel = offset % channels;
      let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
      const endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);
      let sum5 = 0;
      for (; beginSumOffset <= endSumOffset; beginSumOffset++) {
        const z = xValues[beginSumOffset];
        sum5 += z * z;
      }
      return sum5;
    }
    for (let offset = 0; offset < size3; offset++) {
      const sum5 = sumAcrossChannels(offset);
      const val = xValues[offset] * Math.pow(bias + alpha * sum5, -beta);
      result[offset] = val;
    }
    return backend2.makeTensorInfo(x.shape, x.dtype, result);
  }
  var lRNConfig = {
    kernelName: LRN,
    backendName: "cpu",
    kernelFunc: lRN
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LRNGrad.js
  function lRNGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, y, dy } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    assertNotComplex(dy, "LRNGrad");
    const dySize = util_exports2.sizeFromShape(dy.shape);
    const channels = dy.shape[3];
    const dyValues = backend2.data.get(dy.dataId).values;
    const xValues = backend2.data.get(x.dataId).values;
    const yValues = backend2.data.get(y.dataId).values;
    const result = new Float32Array(dySize);
    const size3 = dySize;
    for (let offset = 0; offset < size3; offset++) {
      const currentChannel = offset % channels;
      const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
      const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);
      let norm2 = 0;
      for (let k = depthBegin; k < depthEnd; k++) {
        norm2 += Math.pow(xValues[k], 2);
      }
      norm2 = alpha * norm2 + bias;
      for (let k = depthBegin; k < depthEnd; k++) {
        let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm2;
        if (offset === k) {
          dyi += Math.pow(norm2, -beta);
        }
        dyi *= dyValues[offset];
        result[k] += dyi;
      }
    }
    return backend2.makeTensorInfo(dy.shape, x.dtype, result);
  }
  var lRNGradConfig = {
    kernelName: LRNGrad,
    backendName: "cpu",
    kernelFunc: lRNGrad
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max.js
  function max5(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { reductionIndices, keepDims } = attrs;
    const cpuBackend = backend2;
    let xShape = x.shape;
    const xRank = xShape.length;
    const origAxes = util_exports2.parseAxisParam(reductionIndices, xShape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let xVals = cpuBackend.data.get(x.dataId).values;
    if (permutedAxes != null) {
      const newShape = new Array(xRank);
      for (let i = 0; i < newShape.length; i++) {
        newShape[i] = xShape[permutedAxes[i]];
      }
      xVals = transposeImpl(xVals, xShape, x.dtype, permutedAxes, newShape);
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      xShape = newShape;
    }
    assertNotComplex(x, "max");
    backend_util_exports.assertAxesAreInnerMostDims("max", axes, xRank);
    const [maxOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xShape, axes);
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const result = maxImpl(xVals, reduceSize, maxOutShape, x.dtype);
    const dataId = cpuBackend.write(result, maxOutShape, x.dtype);
    let outShape = maxOutShape;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(maxOutShape, origAxes);
      outShape = newShape;
    }
    return { dataId, shape: outShape, dtype: x.dtype };
  }
  var maxConfig = {
    kernelName: Max,
    backendName: "cpu",
    kernelFunc: max5
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool.js
  function maxPool2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    assertNotComplex(x, "maxPool");
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const dilations = 1;
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
    let res;
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports2.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      res = identity3({ inputs: { x }, backend: backend2 });
    } else {
      const xValues = backend2.data.get(x.dataId).values;
      const strides2 = util_exports2.computeStrides(x.shape);
      const buffer3 = pool2(xValues, x.shape, x.dtype, strides2, convInfo, "max");
      res = backend2.makeTensorInfo(convInfo.outShape, x.dtype, buffer3.values);
    }
    return res;
  }
  var maxPoolConfig = {
    kernelName: MaxPool,
    backendName: "cpu",
    kernelFunc: maxPool2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool3D.js
  function maxPool3D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat } = attrs;
    assertNotComplex(x, "maxPool3d");
    const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, 1, pad3, dimRoundingMode, dataFormat);
    const xValues = backend2.data.get(x.dataId).values;
    const outBuf = pool3d2(xValues, x.shape, x.dtype, util_exports2.computeStrides(x.shape), convInfo, "max");
    return backend2.makeTensorInfo(outBuf.shape, "float32", outBuf.values);
  }
  var maxPool3DConfig = {
    kernelName: MaxPool3D,
    backendName: "cpu",
    kernelFunc: maxPool3D
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool3DGrad.js
  function maxPool3DGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2 } = inputs;
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    assertNotComplex([dy, input2], "maxPool3DGrad");
    const convInfo = backend_util_exports.computePool3DInfo(input2.shape, filterSize, strides, 1, pad3, dimRoundingMode);
    const inputBuf = backend2.bufferSync(input2);
    const maxPosBuf = maxPool3dPositions(inputBuf, convInfo);
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = buffer2(input2.shape, "float32");
    const dyBuf = backend2.bufferSync(dy);
    for (let batch = 0; batch < convInfo.batchSize; ++batch) {
      for (let channel = 0; channel < convInfo.inChannels; ++channel) {
        for (let dxDepth = 0; dxDepth < convInfo.inDepth; ++dxDepth) {
          for (let dxRow = 0; dxRow < convInfo.inHeight; ++dxRow) {
            for (let dxCol = 0; dxCol < convInfo.inWidth; ++dxCol) {
              const dyDepthCorner = dxDepth - padFront;
              const dyRowCorner = dxRow - padTop;
              const dyColCorner = dxCol - padLeft;
              let dotProd = 0;
              for (let wDepth = 0; wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
                const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
                if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                  continue;
                }
                for (let wRow = 0; wRow < effectiveFilterHeight; wRow += dilationHeight) {
                  const dyRow = (dyRowCorner + wRow) / strideHeight;
                  if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                    continue;
                  }
                  for (let wCol = 0; wCol < effectiveFilterWidth; wCol += dilationWidth) {
                    const dyCol = (dyColCorner + wCol) / strideWidth;
                    if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                      continue;
                    }
                    const maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                    const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;
                    const mask = maxPos === curPos ? 1 : 0;
                    if (mask === 0) {
                      continue;
                    }
                    const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                    dotProd += pixel * mask;
                  }
                }
              }
              dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);
            }
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var maxPool3DGradConfig2 = {
    kernelName: MaxPool3DGrad,
    backendName: "cpu",
    kernelFunc: maxPool3DGrad
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolGrad.js
  function maxPoolGrad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2, output } = inputs;
    const x = input2;
    assertNotComplex([input2, output], "maxPoolGrad");
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad3, dimRoundingMode);
    const xValues = backend2.data.get(x.dataId).values;
    const maxPosBuf = buffer2(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const dx = buffer2(x.shape, "float32");
    const dyData = backend2.data.get(dy.dataId).values;
    const dyBuf = buffer2(dy.shape, "float32", dyData);
    for (let b = 0; b < convInfo.batchSize; ++b) {
      for (let d = 0; d < convInfo.inChannels; ++d) {
        for (let dxR = 0; dxR < convInfo.inHeight; ++dxR) {
          for (let dxC = 0; dxC < convInfo.inWidth; ++dxC) {
            const dyRCorner = dxR - padTop;
            const dyCCorner = dxC - padLeft;
            let dotProd = 0;
            for (let wR = 0; wR < effectiveFilterHeight; wR += dilationHeight) {
              const dyR = (dyRCorner + wR) / strideHeight;
              if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
                continue;
              }
              for (let wC = 0; wC < effectiveFilterWidth; wC += dilationWidth) {
                const dyC = (dyCCorner + wC) / strideWidth;
                if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                  continue;
                }
                const maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(b, dyR, dyC, d);
                const curPos = wR * effectiveFilterWidth + wC;
                const mask = maxPos === curPos ? 1 : 0;
                if (mask === 0) {
                  continue;
                }
                const pixel = dyBuf.get(b, dyR, dyC, d);
                dotProd += pixel * mask;
              }
            }
            dx.set(dotProd, b, dxR, dxC, d);
          }
        }
      }
    }
    return backend2.makeTensorInfo(dx.shape, dx.dtype, dx.values);
  }
  var maxPoolGradConfig2 = {
    kernelName: MaxPoolGrad,
    backendName: "cpu",
    kernelFunc: maxPoolGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolWithArgmax_impl.js
  function maxPoolWithArgmaxImpl(xValues, xShape, dtype, includeBatchInIndex, convInfo) {
    const strides = util_exports2.computeStrides(xShape);
    const maxPools = pool2(xValues, xShape, dtype, strides, convInfo, "max");
    const maxPositions = maxPoolPositions(xValues, xShape, dtype, convInfo, true, includeBatchInIndex);
    return [maxPools.values, maxPositions.values];
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolWithArgmax.js
  var maxPoolWithArgmaxConfig = {
    kernelName: MaxPoolWithArgmax,
    backendName: "cpu",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      const { filterSize, strides, pad: pad3, includeBatchInIndex } = attrs;
      const cpuBackend = backend2;
      assertNotComplex(x, "MaxPoolWithArgmax");
      const values2 = cpuBackend.data.get(x.dataId).values;
      const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, [1, 1], pad3);
      const [pooled, indexes] = maxPoolWithArgmaxImpl(values2, x.shape, x.dtype, includeBatchInIndex, convInfo);
      const pooledDataId = cpuBackend.write(pooled, convInfo.outShape, x.dtype);
      const indexesDataId = cpuBackend.write(indexes, convInfo.outShape, x.dtype);
      return [
        { dataId: pooledDataId, shape: convInfo.outShape, dtype: x.dtype },
        { dataId: indexesDataId, shape: convInfo.outShape, dtype: "int32" }
      ];
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Mean.js
  function mean2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const axes = util_exports2.parseAxisParam(axis, x.shape);
    const shapes = backend_util_exports.computeOutAndReduceShapes(x.shape, axes);
    const reduceShape = shapes[1];
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const toDispose = [];
    const reduceSizeScalar = backend2.makeTensorInfo([], "float32", new Float32Array([reduceSize]));
    toDispose.push(reduceSizeScalar);
    const $x = cast3({ inputs: { x }, backend: backend2, attrs: { dtype: "float32" } });
    toDispose.push($x);
    const res = div4({ inputs: { a: $x, b: reduceSizeScalar }, backend: backend2 });
    toDispose.push(res);
    const result = sum3({ inputs: { x: res }, backend: backend2, attrs: { axis, keepDims } });
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  var meanConfig = {
    kernelName: Mean,
    backendName: "cpu",
    kernelFunc: mean2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Min.js
  function min5(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    assertNotComplex(x, "min");
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    if (permutedAxes != null) {
      $x = transpose3({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("min", axes, $x.shape.length);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes($x.shape, axes);
    const reduceSize = util_exports2.sizeFromShape(reduceShape);
    const vals = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(outShape), $x.dtype);
    const aVals = backend2.data.get($x.dataId).values;
    for (let i = 0; i < vals.length; ++i) {
      const offset = i * reduceSize;
      let min7 = aVals[offset];
      for (let j = 0; j < reduceSize; ++j) {
        const value = aVals[offset + j];
        if (Number.isNaN(value) || value < min7) {
          min7 = value;
        }
      }
      vals[i] = min7;
    }
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo($x);
    }
    const result = backend2.makeTensorInfo(outShape, $x.dtype, vals);
    if (keepDims) {
      const expandedShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      const reshapedResult = reshape2({ inputs: { x: result }, backend: backend2, attrs: { shape: expandedShape } });
      backend2.disposeIntermediateTensorInfo(result);
      return reshapedResult;
    }
    return result;
  }
  var minConfig = {
    kernelName: Min,
    backendName: "cpu",
    kernelFunc: min5
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MirrorPad.js
  function mirrorPad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { paddings, mode } = attrs;
    assertNotComplex(x, "mirrorPad");
    const outShape = paddings.map((p3, i) => p3[0] + x.shape[i] + p3[1]);
    const start = paddings.map((p3) => p3[0]);
    const end = paddings.map((p3, i) => p3[0] + x.shape[i]);
    const offset = mode === "reflect" ? 0 : 1;
    const xVals = backend2.data.get(x.dataId).values;
    const xRank = x.shape.length;
    const xStrides = util_exports2.computeStrides(x.shape);
    const resultSize = util_exports2.sizeFromShape(outShape);
    const resultRank = outShape.length;
    const resultStrides = util_exports2.computeStrides(outShape);
    const resVals = util_exports2.getTypedArrayFromDType(x.dtype, resultSize);
    for (let i = 0; i < resultSize; i++) {
      let coords2 = util_exports2.indexToLoc(i, resultRank, resultStrides);
      for (let i2 = 0; i2 < resultRank; i2++) {
        if (coords2[i2] < start[i2]) {
          coords2[i2] = start[i2] * 2 - coords2[i2] - offset;
        } else if (coords2[i2] >= end[i2]) {
          coords2[i2] = (end[i2] - 1) * 2 - coords2[i2] + offset;
        }
      }
      coords2 = coords2.map((c, i2) => c - start[i2]);
      const inIndex = util_exports2.locToIndex(coords2, xRank, xStrides);
      resVals[i] = xVals[inIndex];
    }
    const outId = backend2.write(resVals, outShape, x.dtype);
    return { dataId: outId, shape: outShape, dtype: x.dtype };
  }
  var mirrorPadConfig = {
    kernelName: MirrorPad,
    backendName: "cpu",
    kernelFunc: mirrorPad2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Mod.js
  var modImpl = createSimpleBinaryKernelImpl((aValue, bValue) => {
    const rem = aValue % bValue;
    if (aValue < 0 && bValue < 0 || aValue >= 0 && bValue >= 0) {
      return rem;
    } else {
      return (rem + bValue) % bValue;
    }
  });
  var mod4 = binaryKernelFunc(Mod, modImpl);
  var modConfig = {
    kernelName: Mod,
    backendName: "cpu",
    kernelFunc: mod4
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multinomial.js
  var seedrandom4 = __toModule(require_seedrandom6());

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Softmax.js
  function softmax2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { logits } = inputs;
    const { dim } = attrs;
    const logitsRank = logits.shape.length;
    let $dim = dim;
    if ($dim === -1) {
      $dim = logitsRank - 1;
    }
    if ($dim !== logitsRank - 1) {
      throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${logitsRank} and dim was ${$dim}`);
    }
    const axes = util_exports2.parseAxisParam([$dim], logits.shape);
    const maxLogit = max5({
      inputs: { x: logits },
      backend: backend2,
      attrs: { reductionIndices: axes, keepDims: false }
    });
    const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitReshaped = reshape2({ inputs: { x: maxLogit }, backend: backend2, attrs: { shape: expandedShape } });
    const a = sub5({ inputs: { a: logits, b: maxLogitReshaped }, backend: backend2 });
    const b = exp2({ inputs: { x: a }, backend: backend2 });
    const sumExp = sum3({ inputs: { x: b }, backend: backend2, attrs: { axis: axes, keepDims: false } });
    const sumReshaped = reshape2({ inputs: { x: sumExp }, backend: backend2, attrs: { shape: expandedShape } });
    const result = div4({ inputs: { a: b, b: sumReshaped }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(maxLogit);
    backend2.disposeIntermediateTensorInfo(maxLogitReshaped);
    backend2.disposeIntermediateTensorInfo(a);
    backend2.disposeIntermediateTensorInfo(b);
    backend2.disposeIntermediateTensorInfo(sumExp);
    backend2.disposeIntermediateTensorInfo(sumReshaped);
    return result;
  }
  var softmaxConfig = {
    kernelName: Softmax,
    backendName: "cpu",
    kernelFunc: softmax2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multinomial.js
  function multinomial(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { logits } = inputs;
    const { numSamples, seed, normalized } = attrs;
    assertNotComplex(logits, "multinomial");
    const probabilities = normalized ? logits : softmax2({ inputs: { logits }, backend: backend2, attrs: { dim: -1 } });
    const batchSize = probabilities.shape[0];
    const numEvents = probabilities.shape[1];
    const probVals = backend2.data.get(probabilities.dataId).values;
    const resShape = [batchSize, numSamples];
    const resVals = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(resShape), "int32");
    for (let b = 0; b < batchSize; ++b) {
      const offset = b * numEvents;
      const cdf = new Float32Array(numEvents - 1);
      cdf[0] = probVals[offset];
      for (let event = 1; event < cdf.length; ++event) {
        cdf[event] = cdf[event - 1] + probVals[offset + event];
      }
      const random3 = seedrandom4.alea(seed.toString());
      const outOffset = b * numSamples;
      for (let sampleId = 0; sampleId < numSamples; ++sampleId) {
        const r = random3();
        resVals[outOffset + sampleId] = cdf.length;
        for (let event = 0; event < cdf.length; event++) {
          if (r < cdf[event]) {
            resVals[outOffset + sampleId] = event;
            break;
          }
        }
      }
    }
    if (!normalized) {
      backend2.disposeIntermediateTensorInfo(probabilities);
    }
    return backend2.makeTensorInfo(resShape, "int32", resVals);
  }
  var multinomialConfig = {
    kernelName: Multinomial,
    backendName: "cpu",
    kernelFunc: multinomial
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV3.js
  var nonMaxSuppressionV3Impl2 = kernel_impls_exports.nonMaxSuppressionV3Impl;
  function nonMaxSuppressionV3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
    assertNotComplex(boxes, "NonMaxSuppression");
    const boxesVals = backend2.data.get(boxes.dataId).values;
    const scoresVals = backend2.data.get(scores.dataId).values;
    const { selectedIndices } = nonMaxSuppressionV3Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
  }
  var nonMaxSuppressionV3Config = {
    kernelName: NonMaxSuppressionV3,
    backendName: "cpu",
    kernelFunc: nonMaxSuppressionV3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV4.js
  var nonMaxSuppressionV4Impl2 = kernel_impls_exports.nonMaxSuppressionV4Impl;
  function nonMaxSuppressionV4(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
    assertNotComplex(boxes, "NonMaxSuppressionPadded");
    const boxesVals = backend2.data.get(boxes.dataId).values;
    const scoresVals = backend2.data.get(scores.dataId).values;
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
      backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend2.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
    ];
  }
  var nonMaxSuppressionV4Config = {
    kernelName: NonMaxSuppressionV4,
    backendName: "cpu",
    kernelFunc: nonMaxSuppressionV4
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV5.js
  var nonMaxSuppressionV5Impl2 = kernel_impls_exports.nonMaxSuppressionV5Impl;
  function nonMaxSuppressionV5(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
    assertNotComplex(boxes, "NonMaxSuppressionWithScore");
    const boxesVals = backend2.data.get(boxes.dataId).values;
    const scoresVals = backend2.data.get(scores.dataId).values;
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl2(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
      backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend2.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
    ];
  }
  var nonMaxSuppressionV5Config = {
    kernelName: NonMaxSuppressionV5,
    backendName: "cpu",
    kernelFunc: nonMaxSuppressionV5
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/OneHot.js
  function oneHot2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { indices } = inputs;
    const { depth, onValue, offValue } = attrs;
    assertNotComplex(indices, "oneHot");
    const indicesSize = util_exports2.sizeFromShape(indices.shape);
    const res = new Float32Array(indicesSize * depth);
    res.fill(offValue);
    const indicesVal = backend2.data.get(indices.dataId).values;
    for (let event = 0; event < indicesSize; ++event) {
      if (indicesVal[event] >= 0 && indicesVal[event] < depth) {
        res[event * depth + indicesVal[event]] = onValue;
      }
    }
    return backend2.makeTensorInfo([...indices.shape, depth], "int32", res);
  }
  var oneHotConfig = {
    kernelName: OneHot,
    backendName: "cpu",
    kernelFunc: oneHot2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ZerosLike.js
  function zerosLike2(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (x.dtype === "string") {
      throw new Error("zerosLike is not supported for string tensors");
    } else if (x.dtype === "complex64") {
      const realPart = real2({ inputs: { input: x }, backend: backend2 });
      const r = zerosLike2({ inputs: { x: realPart }, backend: backend2 });
      const imagPart = imag2({ inputs: { input: x }, backend: backend2 });
      const i = zerosLike2({ inputs: { x: imagPart }, backend: backend2 });
      const result = complex2({ inputs: { real: r, imag: i }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(r);
      backend2.disposeIntermediateTensorInfo(imagPart);
      backend2.disposeIntermediateTensorInfo(i);
      return result;
    } else {
      return fill2({ backend: backend2, attrs: { shape: x.shape, value: 0, dtype: x.dtype } });
    }
  }
  var zerosLikeConfig = {
    kernelName: ZerosLike,
    backendName: "cpu",
    kernelFunc: zerosLike2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/OnesLike.js
  function onesLike2(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (x.dtype === "string") {
      throw new Error("onesLike is not supported for string tensors");
    } else if (x.dtype === "complex64") {
      const realPart = real2({ inputs: { input: x }, backend: backend2 });
      const r = onesLike2({ inputs: { x: realPart }, backend: backend2 });
      const imagPart = imag2({ inputs: { input: x }, backend: backend2 });
      const i = zerosLike2({ inputs: { x: imagPart }, backend: backend2 });
      const result = complex2({ inputs: { real: r, imag: i }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(r);
      backend2.disposeIntermediateTensorInfo(imagPart);
      backend2.disposeIntermediateTensorInfo(i);
      return result;
    } else {
      return fill2({ backend: backend2, attrs: { shape: x.shape, value: 1, dtype: x.dtype } });
    }
  }
  var onesLikeConfig = {
    kernelName: OnesLike,
    backendName: "cpu",
    kernelFunc: onesLike2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Pack.js
  function pack(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { axis } = attrs;
    if (inputs.length === 1) {
      return expandDims3({ inputs: { input: inputs[0] }, backend: backend2, attrs: { dim: axis } });
    }
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t) => {
      util_exports2.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
      util_exports2.assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t) => {
      const expandedT = expandDims3({ inputs: { input: t }, backend: backend2, attrs: { dim: axis } });
      intermediateTensorInfos.push(expandedT);
      return expandedT;
    });
    const result = concat2({ inputs: expandedTensors, backend: backend2, attrs: { axis } });
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  var packConfig = {
    kernelName: Pack,
    backendName: "cpu",
    kernelFunc: pack
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/PadV2.js
  function padV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { paddings, constantValue } = attrs;
    assertNotComplex(x, "pad");
    const outShape = paddings.map((p3, i) => p3[0] + x.shape[i] + p3[1]);
    const start = paddings.map((p3) => p3[0]);
    const xVals = backend2.data.get(x.dataId).values;
    const xSize = util_exports2.sizeFromShape(x.shape);
    const xRank = x.shape.length;
    const xStrides = util_exports2.computeStrides(x.shape);
    const resultSize = util_exports2.sizeFromShape(outShape);
    const resultRank = outShape.length;
    const resultStrides = util_exports2.computeStrides(outShape);
    const resVals = util_exports2.getTypedArrayFromDType(x.dtype, resultSize);
    if (constantValue !== 0) {
      resVals.fill(constantValue);
    }
    for (let i = 0; i < xSize; i++) {
      const coords2 = util_exports2.indexToLoc(i, xRank, xStrides);
      const outCoords = coords2.map((c, i2) => c + start[i2]);
      const outIndex = util_exports2.locToIndex(outCoords, resultRank, resultStrides);
      resVals[outIndex] = xVals[i];
    }
    const outId = backend2.write(resVals, outShape, x.dtype);
    return { dataId: outId, shape: outShape, dtype: x.dtype };
  }
  var padV2Config = {
    kernelName: PadV2,
    backendName: "cpu",
    kernelFunc: padV2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Pow.js
  var powImpl = createSimpleBinaryKernelImpl((a, b) => Math.pow(a, b));
  var pow2 = binaryKernelFunc(Pow2, powImpl);
  var powConfig = {
    kernelName: Pow2,
    backendName: "cpu",
    kernelFunc: pow2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range.js
  function range3(args) {
    const { backend: backend2, attrs } = args;
    const { start, stop: stop2, dtype, step: step4 } = attrs;
    const values2 = rangeImpl(start, stop2, step4, dtype);
    return backend2.makeTensorInfo([values2.length], dtype, values2);
  }
  var rangeConfig = {
    kernelName: Range,
    backendName: "cpu",
    kernelFunc: range3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Reciprocal.js
  var reciprocal2 = unaryKernelFunc(Reciprocal, (xi) => 1 / xi);
  var reciprocalConfig = {
    kernelName: Reciprocal,
    backendName: "cpu",
    kernelFunc: reciprocal2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinear.js
  function resizeBilinear2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size: size3 } = attrs;
    assertNotComplex(images, "resizeBilinear");
    const imagesStrides = util_exports2.computeStrides(images.shape);
    const [newHeight, newWidth] = size3;
    const [batch, oldHeight, oldWidth, numChannels] = images.shape;
    const xValues = backend2.data.get(images.dataId).values;
    const result = new Float32Array(util_exports2.sizeFromShape([batch, newHeight, newWidth, numChannels]));
    const effectiveInputSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutputSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    let outputIdx = 0;
    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
    for (let b = 0; b < batch; b++) {
      for (let r = 0; r < newHeight; r++) {
        let sourceFracRow;
        if (halfPixelCenters) {
          sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;
        } else {
          sourceFracRow = effectiveRowSizeRatio * r;
        }
        const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));
        const rowFrac = sourceFracRow - sourceRowFloor;
        const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
        const topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];
        const botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];
        for (let c = 0; c < newWidth; c++) {
          let sourceFracCol;
          if (halfPixelCenters) {
            sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;
          } else {
            sourceFracCol = effectiveColSizeRatio * c;
          }
          const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));
          const colFrac = sourceFracCol - sourceColFloor;
          const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
          const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];
          const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];
          const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];
          const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];
          for (let d = 0; d < numChannels; d++) {
            const topLeft = xValues[topLeftOffest + d];
            const bottomLeft = xValues[botLeftOffset + d];
            const topRight = xValues[topRightOffset + d];
            const bottomRight = xValues[botRightOffest + d];
            const top = topLeft + (topRight - topLeft) * colFrac;
            const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
            const newValue = top + (bottom - top) * rowFrac;
            result[outputIdx++] = newValue;
          }
        }
      }
    }
    return backend2.makeTensorInfo([batch, newHeight, newWidth, numChannels], "float32", result);
  }
  var resizeBilinearConfig = {
    kernelName: ResizeBilinear,
    backendName: "cpu",
    kernelFunc: resizeBilinear2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinearGrad.js
  function resizeBilinearGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    assertNotComplex([dy, images], "resizeBilinearGrad");
    const imagesStrides = util_exports2.computeStrides(images.shape);
    const [batch, xHeight, xWidth, depth] = images.shape;
    const [, yHeight, yWidth] = dy.shape;
    const output = new Float32Array(batch * xHeight * xWidth * depth);
    const effectiveXSize = [
      alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
      alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
      alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
      alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const dyValues = backend2.data.get(dy.dataId).values;
    let offset = 0;
    for (let b = 0; b < batch; b++) {
      const bOffset = b * imagesStrides[0];
      for (let r = 0; r < yHeight; r++) {
        const dxR = r * heightScale;
        const topDxRIndex = Math.floor(dxR);
        const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
        const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];
        const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];
        const dxRLerp = dxR - topDxRIndex;
        const inverseDxRLerp = 1 - dxRLerp;
        for (let c = 0; c < yWidth; c++) {
          const dxC = c * widthScale;
          const leftDxCIndex = Math.floor(dxC);
          const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
          const dxCLerp = dxC - leftDxCIndex;
          const inverseDxCLerp = 1 - dxCLerp;
          const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];
          const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];
          const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];
          const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];
          const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;
          const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;
          const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;
          const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;
          for (let d = 0; d < depth; d++) {
            const dyVal = dyValues[offset++];
            output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;
            output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;
            output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;
            output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;
          }
        }
      }
    }
    return backend2.makeTensorInfo([batch, xWidth, xHeight, depth], "float32", output);
  }
  var resizeBilinearGradConfig2 = {
    kernelName: ResizeBilinearGrad,
    backendName: "cpu",
    kernelFunc: resizeBilinearGrad
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighbor.js
  function resizeNearestNeighbor2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size: size3 } = attrs;
    assertNotComplex(images, "resizeNearestNeighbor");
    const imagesStrides = util_exports2.computeStrides(images.shape);
    const [newHeight, newWidth] = size3;
    const [batch, oldHeight, oldWidth, numChannels] = images.shape;
    const xValues = backend2.data.get(images.dataId).values;
    const output = new Float32Array(batch * newHeight * newWidth * numChannels);
    const effectiveInputSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutputSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
    const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
    let outputOffset = 0;
    for (let b = 0; b < batch; b++) {
      const batchOffset = b * imagesStrides[0];
      for (let r = 0; r < newHeight; r++) {
        const sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r + 0.5) : effectiveRowSizeRatio * r;
        let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
        if (halfPixelCenters) {
          sourceNearestRow = Math.max(0, sourceNearestRow);
        }
        const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];
        for (let c = 0; c < newWidth; c++) {
          const sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c + 0.5) : effectiveColSizeRatio * c;
          let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
          if (halfPixelCenters) {
            sourceNearestCol = Math.max(0, sourceNearestCol);
          }
          const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];
          for (let d = 0; d < numChannels; d++) {
            const newVal = xValues[colOffset + d];
            output[outputOffset++] = newVal;
          }
        }
      }
    }
    return backend2.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);
  }
  var resizeNearestNeighborConfig = {
    kernelName: ResizeNearestNeighbor,
    backendName: "cpu",
    kernelFunc: resizeNearestNeighbor2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighborGrad.js
  function resizeNearestNeighborGrad(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    assertNotComplex([dy, images], "resizeNearestNeighborGrad");
    const imagesStrides = util_exports2.computeStrides(images.shape);
    const dyStrides = util_exports2.computeStrides(dy.shape);
    const [batch, xHeight, xWidth, depth] = images.shape;
    const [, yHeight, yWidth] = dy.shape;
    const output = new Float32Array(batch * xHeight * xWidth * depth);
    const dyValues = backend2.data.get(dy.dataId).values;
    const effectiveXSize = [
      alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
      alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
      alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
      alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    const winHeight = Math.ceil(invHeightScale) * 2 + 2;
    const winWidth = Math.ceil(invWidthScale) * 2 + 2;
    for (let b = 0; b < batch; b++) {
      const batchOffset = b * imagesStrides[0];
      for (let r = 0; r < xHeight; r++) {
        const rowOffset = batchOffset + r * imagesStrides[1];
        const startRLerp = Math.floor(r * invHeightScale);
        const startDyR = Math.floor(startRLerp - winHeight / 2);
        for (let c = 0; c < xWidth; c++) {
          const colOffset = rowOffset + c * imagesStrides[2];
          const startCLerp = Math.floor(c * invWidthScale);
          const startDyC = Math.floor(startCLerp - winWidth / 2);
          for (let d = 0; d < depth; d++) {
            let accum = 0;
            for (let dyRIndex = 0; dyRIndex < winHeight; dyRIndex++) {
              const dyR = dyRIndex + startDyR;
              if (dyR < 0 || dyR >= yHeight) {
                continue;
              }
              const dyROffset = batchOffset + dyR * dyStrides[1];
              const sourceFracRow = dyR * heightScale;
              const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
              if (r !== sourceNearestRow) {
                continue;
              }
              for (let dyCIndex = 0; dyCIndex < winWidth; dyCIndex++) {
                const dyC = dyCIndex + startDyC;
                if (dyC < 0 || dyC >= yWidth) {
                  continue;
                }
                const dyCOffset = dyROffset + dyC * dyStrides[2];
                const sourceFracCol = dyC * widthScale;
                const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
                if (c === sourceNearestCol) {
                  accum += dyValues[dyCOffset + d];
                }
              }
            }
            output[colOffset + d] = accum;
          }
        }
      }
    }
    return backend2.makeTensorInfo(images.shape, images.dtype, output);
  }
  var resizeNearestNeighborGradConfig2 = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: "cpu",
    kernelFunc: resizeNearestNeighborGrad
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Reverse.js
  function reverse2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { dims } = attrs;
    assertNotComplex(x, "reverse");
    const xRank = x.shape.length;
    const $dims = util_exports2.parseAxisParam(dims, x.shape);
    if (xRank === 0) {
      return identity3({ inputs: { x }, backend: backend2 });
    }
    const outBuf = new TensorBuffer(x.shape, x.dtype);
    const xBuf = backend2.bufferSync(x);
    for (let i = 0; i < outBuf.size; i++) {
      const outLoc = outBuf.indexToLoc(i);
      const inLoc = outLoc.slice();
      $dims.forEach((d) => inLoc[d] = x.shape[d] - 1 - inLoc[d]);
      outBuf.set(xBuf.get(...inLoc), ...outLoc);
    }
    return backend2.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  var reverseConfig = {
    kernelName: Reverse,
    backendName: "cpu",
    kernelFunc: reverse2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RotateWithOffset.js
  var rotateWithOffsetConfig = {
    kernelName: RotateWithOffset,
    backendName: "cpu",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { image: image3 } = inputs;
      const { radians, fillValue, center } = attrs;
      const cpuBackend = backend2;
      const output = util_exports2.getTypedArrayFromDType(image3.dtype, util_exports2.sizeFromShape(image3.shape));
      const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
      const [centerX, centerY] = backend_util_exports.getImageCenter(center, imageHeight, imageWidth);
      const fullOpacityValue = 255;
      const sinFactor = Math.sin(radians);
      const cosFactor = Math.cos(radians);
      const imageVals = cpuBackend.data.get(image3.dataId).values;
      for (let batchIdx = 0; batchIdx < batch; batchIdx++) {
        const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
        for (let row = 0; row < imageHeight; row++) {
          const rowOffset = row * (imageWidth * numChannels);
          for (let col = 0; col < imageWidth; col++) {
            const colOffset = col * numChannels;
            for (let channel = 0; channel < numChannels; channel++) {
              const coords2 = [batch, row, col, channel];
              const x = coords2[2];
              const y = coords2[1];
              let coordX = (x - centerX) * cosFactor - (y - centerY) * sinFactor;
              let coordY = (x - centerX) * sinFactor + (y - centerY) * cosFactor;
              coordX = Math.round(coordX + centerX);
              coordY = Math.round(coordY + centerY);
              let outputValue = fillValue;
              if (typeof fillValue !== "number") {
                if (channel === 3) {
                  outputValue = fullOpacityValue;
                } else {
                  outputValue = fillValue[channel];
                }
              }
              if (coordX >= 0 && coordX < imageWidth && coordY >= 0 && coordY < imageHeight) {
                const rotatedRowOffset = coordY * (imageWidth * numChannels);
                const rotatedColOffset = coordX * numChannels;
                const imageIdx = batchOffset + rotatedRowOffset + rotatedColOffset + channel;
                outputValue = imageVals[imageIdx];
              }
              const outIdx = batchOffset + rowOffset + colOffset + channel;
              output[outIdx] = outputValue;
            }
          }
        }
      }
      const dataId = cpuBackend.write(output, image3.shape, image3.dtype);
      return { dataId, shape: image3.shape, dtype: image3.dtype };
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Round.js
  var round6 = unaryKernelFunc(Round, (xi) => {
    const base2 = Math.floor(xi);
    if (xi - base2 < 0.5) {
      return Math.floor(xi);
    } else if (xi - base2 > 0.5) {
      return Math.ceil(xi);
    } else {
      if (base2 % 2 === 0) {
        return base2;
      } else {
        return base2 + 1;
      }
    }
  });
  var roundConfig = {
    kernelName: Round,
    backendName: "cpu",
    kernelFunc: round6
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Scatter_impl.js
  function scatterImpl(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
    const flattenShape = [outputSize / sliceSize, sliceSize];
    const indicesData = indices.values;
    const updatesData = updates.values;
    if (outputSize === 0) {
      return buffer2(shape, updates.dtype);
    }
    const outBuf = buffer2(flattenShape, updates.dtype);
    outBuf.values.fill(defaultValue);
    for (let i = 0; i < numUpdates; i++) {
      const index = [];
      let flattenIndex = 0;
      for (let j = 0; j < sliceRank; j++) {
        const dim = indicesData[i * sliceRank + j];
        index.push(dim);
        flattenIndex += dim * strides[j];
      }
      if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {
        throw new Error(`Invalid indices: ${index} does not index into ${shape}`);
      }
      for (let k = 0; k < sliceSize; k++) {
        if (sumDupeIndices) {
          outBuf.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];
        } else {
          outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];
        }
      }
    }
    return outBuf;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ScatterNd.js
  function scatterNd(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { indices, updates } = inputs;
    const { shape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util_exports.calculateShapes(updates, indices, shape);
    const sumDupeIndices = true;
    const indicesBuf = backend2.bufferSync(indices);
    const updatesBuf = backend2.bufferSync(updates);
    const outBuf = scatterImpl(indicesBuf, updatesBuf, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, 0, sumDupeIndices);
    return backend2.makeTensorInfo(shape, outBuf.dtype, outBuf.values);
  }
  var scatterNdConfig = {
    kernelName: ScatterNd,
    backendName: "cpu",
    kernelFunc: scatterNd
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Select.js
  function select2(args) {
    const { inputs, backend: backend2 } = args;
    const { condition, t, e } = inputs;
    assertNotComplex([condition, t, e], "select");
    const conditionRank = condition.shape.length;
    const values2 = backend2.data.get(condition.dataId).values;
    const tValues = backend2.data.get(t.dataId).values;
    const eValues = backend2.data.get(e.dataId).values;
    const resultDtype = upcastType(t.dtype, e.dtype);
    const newValues = util_exports2.makeZerosTypedArray(util_exports2.sizeFromShape(t.shape), resultDtype);
    let index = 0;
    const offset = conditionRank === 0 || conditionRank > 1 || t.shape.length === 1 ? 1 : util_exports2.sizeFromShape(t.shape.slice(1));
    for (let i = 0; i < values2.length; i++) {
      for (let j = 0; j < offset; j++) {
        if (values2[i] === 1) {
          newValues[index++] = tValues[i];
        } else {
          newValues[index++] = eValues[i];
        }
      }
    }
    return backend2.makeTensorInfo(t.shape, resultDtype, newValues);
  }
  var selectConfig = {
    kernelName: Select,
    backendName: "cpu",
    kernelFunc: select2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Selu.js
  var scaleAlpha = backend_util_exports.SELU_SCALEALPHA;
  var scale4 = backend_util_exports.SELU_SCALE;
  var selu2 = unaryKernelFunc(Selu, (xi) => {
    if (xi >= 0) {
      return scale4 * xi;
    } else {
      return scaleAlpha * (Math.exp(xi) - 1);
    }
  });
  var seluConfig = {
    kernelName: Selu,
    backendName: "cpu",
    kernelFunc: selu2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sign.js
  var sign2 = unaryKernelFunc(Sign, (xi) => {
    if (xi < 0) {
      return -1;
    } else if (xi > 0) {
      return 1;
    } else {
      return 0;
    }
  });
  var signConfig = {
    kernelName: Sign,
    backendName: "cpu",
    kernelFunc: sign2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sin.js
  var sin3 = unaryKernelFunc(Sin, (xi) => Math.sin(xi));
  var sinConfig = {
    kernelName: Sin,
    backendName: "cpu",
    kernelFunc: sin3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sinh.js
  var sinh2 = unaryKernelFunc(Sinh, (xi) => Math.sinh(xi));
  var sinhConfig = {
    kernelName: Sinh,
    backendName: "cpu",
    kernelFunc: sinh2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Softplus.js
  var epsilon2 = 11920928955078125e-23;
  var threshold2 = Math.log(epsilon2) + 2;
  var softplus2 = unaryKernelFunc(Softplus, (xi) => {
    const tooLarge = xi > -threshold2;
    const tooSmall = xi < threshold2;
    const expX = Math.exp(xi);
    let result;
    if (tooSmall) {
      result = expX;
    } else if (tooLarge) {
      result = xi;
    } else {
      result = Math.log(1 + expX);
    }
    return result;
  });
  var softplusConfig = {
    kernelName: Softplus,
    backendName: "cpu",
    kernelFunc: softplus2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SpaceToBatchND.js
  function spaceToBatchND2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockShape, paddings } = attrs;
    assertNotComplex([x], "spaceToBatchND");
    const prod4 = util_exports2.sizeFromShape(blockShape);
    const completePaddings = [[0, 0]];
    completePaddings.push(...paddings);
    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
      completePaddings.push([0, 0]);
    }
    const paddedX = padV2Config.kernelFunc({
      inputs: { x },
      backend: backend2,
      attrs: { paddings: completePaddings, constantValue: 0 }
    });
    const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod4, false);
    const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod4, false);
    const reshapeInputs = { x: paddedX };
    const reshapeAttrs = { shape: reshapedPaddedShape };
    const paddedXReshaped = reshape2({ inputs: reshapeInputs, backend: backend2, attrs: reshapeAttrs });
    const transposeInputs = { x: paddedXReshaped };
    const transposeAttrs = { perm: permutedReshapedPaddedPermutation };
    const paddedXT = transpose3({ inputs: transposeInputs, backend: backend2, attrs: transposeAttrs });
    const resultReshapeInputs = { x: paddedXT };
    const resultReshapeAttrs = { shape: flattenShape };
    const result = reshape2({ inputs: resultReshapeInputs, backend: backend2, attrs: resultReshapeAttrs });
    backend2.disposeIntermediateTensorInfo(paddedX);
    backend2.disposeIntermediateTensorInfo(paddedXReshaped);
    backend2.disposeIntermediateTensorInfo(paddedXT);
    return result;
  }
  var spaceToBatchNDConfig = {
    kernelName: SpaceToBatchND,
    backendName: "cpu",
    kernelFunc: spaceToBatchND2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows.js
  function sparseFillEmptyRows(args) {
    const { inputs, backend: backend2 } = args;
    const { indices, values: values2, denseShape, defaultValue } = inputs;
    if (denseShape.shape.length !== 1) {
      throw new Error(`Dense shape must be a vector, saw:
        ${denseShape.shape}`);
    }
    if (indices.shape.length !== 2) {
      throw new Error(`Indices must be a matrix, saw:
        ${indices.shape}`);
    }
    if (values2.shape.length !== 1) {
      throw new Error(`Values must be a vector, saw:
        ${values2.shape}`);
    }
    if (defaultValue.shape.length !== 0) {
      throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
    }
    const $indices = backend2.data.get(indices.dataId).values;
    const $values = backend2.data.get(values2.dataId).values;
    const $denseShape = backend2.data.get(denseShape.dataId).values;
    const $defaultValue = backend2.data.get(defaultValue.dataId).values[0];
    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values2.dtype, $denseShape, $defaultValue);
    return [
      backend2.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
      backend2.makeTensorInfo([outputIndicesShape[0]], values2.dtype, outputValues),
      backend2.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
      backend2.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
    ];
  }
  var sparseFillEmptyRowsConfig = {
    kernelName: SparseFillEmptyRows,
    backendName: "cpu",
    kernelFunc: sparseFillEmptyRows
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape.js
  function sparseReshape(args) {
    const { inputs, backend: backend2 } = args;
    const { inputIndices, inputShape, newShape } = inputs;
    if (inputIndices.shape.length !== 2) {
      throw new Error(`Input indices should be a matrix but received shape
        ${inputIndices.shape}`);
    }
    if (inputShape.shape.length !== 1) {
      throw new Error(`Input shape should be a vector but received shape
        ${inputShape.shape}`);
    }
    if (newShape.shape.length !== 1) {
      throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    }
    const $inputShape = Array.from(backend2.data.get(inputShape.dataId).values);
    const $inputIndices = backend2.data.get(inputIndices.dataId).values;
    const targetShape = Array.from(backend2.data.get(newShape.dataId).values);
    const [newIndices, indicesShape, outputShape] = sparseReshapeImpl($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
    return [
      backend2.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
      backend2.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
    ];
  }
  var sparseReshapeConfig = {
    kernelName: SparseReshape,
    backendName: "cpu",
    kernelFunc: sparseReshape
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentMean.js
  function sparseSegmentMean(args) {
    const { inputs, backend: backend2 } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
          ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
          ${segmentIds.shape}`);
    }
    const $data = backend2.data.get(data.dataId).values;
    const $indices = backend2.data.get(indices.dataId).values;
    const $segmentIds = backend2.data.get(segmentIds.dataId).values;
    const [outputData, outputDataShape] = sparseSegmentReductionImpl($data, data.shape, data.dtype, $indices, $segmentIds, true);
    return backend2.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  var sparseSegmentMeanConfig = {
    kernelName: SparseSegmentMean,
    backendName: "cpu",
    kernelFunc: sparseSegmentMean
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentSum.js
  function sparseSegmentSum(args) {
    const { inputs, backend: backend2 } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
         ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
         ${segmentIds.shape}`);
    }
    const $data = backend2.data.get(data.dataId).values;
    const $indices = backend2.data.get(indices.dataId).values;
    const $segmentIds = backend2.data.get(segmentIds.dataId).values;
    const [outputData, outputDataShape] = sparseSegmentReductionImpl($data, data.shape, data.dtype, $indices, $segmentIds);
    return backend2.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  var sparseSegmentSumConfig = {
    kernelName: SparseSegmentSum,
    backendName: "cpu",
    kernelFunc: sparseSegmentSum
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseToDense.js
  function sparseToDense(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { sparseIndices, sparseValues, defaultValue } = inputs;
    const { outputShape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    const indicesBuf = backend2.bufferSync(sparseIndices);
    const updatesBuf = backend2.bufferSync(sparseValues);
    const $defaultValue = backend2.data.get(defaultValue.dataId).values[0];
    const outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
    return backend2.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
  }
  var sparseToDenseConfig = {
    kernelName: SparseToDense,
    backendName: "cpu",
    kernelFunc: sparseToDense
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SplitV.js
  function splitV(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { numOrSizeSplits, axis } = attrs;
    const $axis = util_exports2.parseAxisParam(axis, x.shape)[0];
    const splitSizes = backend_util_exports.prepareSplitSize(x, numOrSizeSplits, $axis);
    const begin = new Array(x.shape.length).fill(0);
    const size3 = x.shape.slice();
    return splitSizes.map((s) => {
      const sliceSize = [...size3];
      sliceSize[$axis] = s;
      const sliceT = slice2({ inputs: { x }, backend: backend2, attrs: { begin, size: sliceSize } });
      begin[$axis] += s;
      return sliceT;
    });
  }
  var splitVConfig = {
    kernelName: SplitV,
    backendName: "cpu",
    kernelFunc: splitV
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Square.js
  var squareConfig = {
    kernelName: Square,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend2 }) => {
      const { x } = inputs;
      const cpuBackend = backend2;
      assertNotComplex(x, "square");
      const values2 = cpuBackend.data.get(x.dataId).values;
      const newValues = new Float32Array(values2.length);
      for (let i = 0; i < values2.length; ++i) {
        const value = values2[i];
        newValues[i] = value * value;
      }
      const dataId = cpuBackend.write(newValues, x.shape, x.dtype);
      return { dataId, shape: x.shape, dtype: x.dtype };
    }
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Step.js
  var step2 = unaryKernelFunc(Step, (xi, attrs) => {
    const stepAttrs = attrs;
    if (isNaN(xi)) {
      return NaN;
    } else {
      return xi > 0 ? 1 : stepAttrs.alpha;
    }
  });
  var stepConfig = {
    kernelName: Step,
    backendName: "cpu",
    kernelFunc: step2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice.js
  function stridedSlice2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
    assertNotComplex(x, "stridedSlice");
    const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = slice_util_exports.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    if (isIdentity) {
      result = reshape2({ inputs: { x }, backend: backend2, attrs: { shape: finalShape } });
    } else if (sliceDim0 || isSimpleSlice) {
      util_exports2.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);
      const size3 = slice_util_exports.computeOutShape($begin, $end, $strides);
      const sliced = slice2({ inputs: { x }, backend: backend2, attrs: { begin: $begin, size: size3 } });
      result = reshape2({ inputs: { x: sliced }, backend: backend2, attrs: { shape: finalShape } });
      backend2.disposeIntermediateTensorInfo(sliced);
    } else {
      const xBuf = backend2.bufferSync(x);
      const outBuf = stridedSliceImpl(finalShapeSparse, xBuf, $strides, $begin);
      result = backend2.makeTensorInfo(finalShape, outBuf.dtype, outBuf.values);
    }
    return result;
  }
  var stridedSliceConfig = {
    kernelName: StridedSlice,
    backendName: "cpu",
    kernelFunc: stridedSlice2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams.js
  function stringNGrams(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
    const { data, dataSplits } = inputs;
    const $data = backend2.data.get(data.dataId).values;
    const $dataSplits = backend2.data.get(dataSplits.dataId).values;
    const [nGrams, nGramsSplits] = stringNGramsImpl($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
    return [
      backend2.makeTensorInfo([nGrams.length], "string", nGrams),
      backend2.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
    ];
  }
  var stringNGramsConfig = {
    kernelName: StringNGrams,
    backendName: "cpu",
    kernelFunc: stringNGrams
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit.js
  function stringSplit(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { skipEmpty } = attrs;
    const { input: input2, delimiter } = inputs;
    if (input2.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (input2.shape.length !== 1) {
      throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
    }
    if (delimiter.shape.length !== 0) {
      throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
    }
    const $input = backend2.data.get(input2.dataId).values;
    const $delimiter = backend2.data.get(delimiter.dataId).values[0];
    const [indices, values2, shape] = stringSplitImpl($input, $delimiter, skipEmpty);
    const outputSize = values2.length;
    return [
      backend2.makeTensorInfo([outputSize, 2], "int32", indices),
      backend2.makeTensorInfo([outputSize], "string", values2),
      backend2.makeTensorInfo([2], "int32", new Int32Array(shape))
    ];
  }
  var stringSplitConfig = {
    kernelName: StringSplit,
    backendName: "cpu",
    kernelFunc: stringSplit
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast.js
  function stringToHashBucketFast(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { numBuckets } = attrs;
    const { input: input2 } = inputs;
    if (input2.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (numBuckets <= 0) {
      throw new Error(`Number of buckets must be at least 1`);
    }
    const $input = backend2.data.get(input2.dataId).values;
    const output = stringToHashBucketFastImpl($input, numBuckets);
    return backend2.makeTensorInfo(input2.shape, "int32", output);
  }
  var stringToHashBucketFastConfig = {
    kernelName: StringToHashBucketFast,
    backendName: "cpu",
    kernelFunc: stringToHashBucketFast
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tan.js
  var tan2 = unaryKernelFunc(Tan, (xi) => Math.tan(xi));
  var tanConfig = {
    kernelName: Tan,
    backendName: "cpu",
    kernelFunc: tan2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tanh.js
  var tanh3 = unaryKernelFunc(Tanh, (xi) => Math.tanh(xi));
  var tanhConfig = {
    kernelName: Tanh,
    backendName: "cpu",
    kernelFunc: tanh3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile.js
  function tile3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { reps } = attrs;
    assertNotComplex(x, "tile");
    const outBuf = tileImpl(backend2.bufferSync(x), reps);
    return backend2.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  var tileConfig = {
    kernelName: Tile,
    backendName: "cpu",
    kernelFunc: tile3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK.js
  function topK(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { k, sorted } = attrs;
    assertNotComplex(x, "topk");
    const xVals = backend2.data.get(x.dataId).values;
    const [allTopKVals, allTopKIndices] = topKImpl(xVals, x.shape, x.dtype, k, sorted);
    return [
      backend2.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
      backend2.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
    ];
  }
  var topKConfig = {
    kernelName: TopK,
    backendName: "cpu",
    kernelFunc: topK
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transform.js
  function transform7(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { image: image3, transforms } = inputs;
    const { interpolation, fillMode, fillValue, outputShape } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
    const outShape = [batch, outHeight, outWidth, numChannels];
    const strides = util_exports2.computeStrides(image3.shape);
    const batchStride = strides[0];
    const rowStride = strides[1];
    const colStride = strides[2];
    const outVals = util_exports2.getTypedArrayFromDType(image3.dtype, util_exports2.sizeFromShape(outShape));
    outVals.fill(fillValue);
    const imageVals = backend2.data.get(image3.dataId).values;
    const transformVals = backend2.data.get(transforms.dataId).values;
    for (let b = 0; b < batch; ++b) {
      const transform9 = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);
      for (let outY = 0; outY < outHeight; ++outY) {
        for (let outX = 0; outX < outWidth; ++outX) {
          for (let channel = 0; channel < numChannels; ++channel) {
            let val;
            const projection2 = transform9[6] * outX + transform9[7] * outY + 1;
            if (projection2 === 0) {
              continue;
            }
            const inX = (transform9[0] * outX + transform9[1] * outY + transform9[2]) / projection2;
            const inY = (transform9[3] * outX + transform9[4] * outY + transform9[5]) / projection2;
            const x = mapCoord(inX, imageWidth, fillMode);
            const y = mapCoord(inY, imageHeight, fillMode);
            switch (interpolation) {
              case "nearest":
                val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);
                break;
              case "bilinear":
                val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, b, y, x, channel, fillValue);
                break;
              default:
                throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${interpolation}`);
            }
            const ind = b * batchStride + outY * rowStride + outX * colStride + channel;
            outVals[ind] = val;
          }
        }
      }
      return backend2.makeTensorInfo(outShape, image3.dtype, outVals);
    }
    const dataId = backend2.write(outVals, outShape, image3.dtype);
    return { dataId, shape: image3.shape, dtype: image3.dtype };
  }
  var transformConfig = {
    kernelName: Transform,
    backendName: "cpu",
    kernelFunc: transform7
  };
  function mapCoord(outCoord, len3, mode) {
    switch (mode) {
      case "reflect":
        return mapCoordReflect(outCoord, len3);
      case "wrap":
        return mapCoordWrap(outCoord, len3);
      case "nearest":
        return mapCoordNearest(outCoord, len3);
      case "constant":
      default:
        return mapCoordConstant(outCoord, len3);
    }
  }
  function mapCoordReflect(outCoord, len3) {
    let inCoord = outCoord;
    if (inCoord < 0) {
      if (len3 <= 1) {
        inCoord = 0;
      } else {
        const sz2 = 2 * len3;
        if (inCoord < sz2) {
          inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;
        }
        inCoord = inCoord < -len3 ? inCoord + sz2 : -inCoord - 1;
      }
    } else if (inCoord > len3 - 1) {
      if (len3 <= 1) {
        inCoord = 0;
      } else {
        const sz2 = 2 * len3;
        inCoord -= sz2 * Math.trunc(inCoord / sz2);
        if (inCoord >= len3) {
          inCoord = sz2 - inCoord - 1;
        }
      }
    }
    return util_exports2.clamp(0, inCoord, len3 - 1);
  }
  function mapCoordWrap(outCoord, len3) {
    let inCoord = outCoord;
    if (inCoord < 0) {
      if (len3 <= 1) {
        inCoord = 0;
      } else {
        const sz = len3 - 1;
        inCoord += len3 * (Math.trunc(-inCoord / sz) + 1);
      }
    } else if (inCoord > len3 - 1) {
      if (len3 <= 1) {
        inCoord = 0;
      } else {
        const sz = len3 - 1;
        inCoord -= len3 * Math.trunc(inCoord / sz);
      }
    }
    return util_exports2.clamp(0, inCoord, len3 - 1);
  }
  function mapCoordConstant(outCoord, len3) {
    return outCoord;
  }
  function mapCoordNearest(outCoord, len3) {
    return util_exports2.clamp(0, outCoord, len3 - 1);
  }
  function readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
    const ind = batch * batchStride + y * rowStride + x * colStride + channel;
    if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {
      return imageVals[ind];
    } else {
      return fillValue;
    }
  }
  function nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
    const $y = Math.round(y);
    const $x = Math.round(x);
    return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);
  }
  function bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
    const yFloor = Math.floor(y);
    const xFloor = Math.floor(x);
    const yCeil = yFloor + 1;
    const xCeil = xFloor + 1;
    const valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);
    const valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);
    return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;
  }

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique.js
  function unique3(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { axis } = attrs;
    const { x } = inputs;
    assertNotComplex(x, "unique");
    const values2 = backend2.data.get(x.dataId).values;
    const { outputValues, outputShape, indices } = uniqueImpl(values2, axis, x.shape, x.dtype);
    return [
      backend2.makeTensorInfo(outputShape, x.dtype, outputValues),
      backend2.makeTensorInfo([indices.length], "int32", indices)
    ];
  }
  var uniqueConfig = {
    kernelName: Unique,
    backendName: "cpu",
    kernelFunc: unique3
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unpack.js
  function unpack(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { value } = inputs;
    let { axis } = attrs;
    if (axis < 0) {
      axis += value.shape.length;
    }
    const valueRank = value.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(valueRank - 1);
    let outIndex = 0;
    for (let i = 0; i < valueRank; i++) {
      if (i !== axis) {
        outShape[outIndex++] = value.shape[i];
      }
    }
    const begin = new Array(valueRank).fill(0);
    const size3 = value.shape.slice();
    size3[axis] = 1;
    const res = new Array(num);
    for (let i = 0; i < res.length; i++) {
      begin[axis] = i;
      const tempRes = slice2({ inputs: { x: value }, backend: backend2, attrs: { begin, size: size3 } });
      res[i] = reshape2({ inputs: { x: tempRes }, backend: backend2, attrs: { shape: outShape } });
      backend2.disposeIntermediateTensorInfo(tempRes);
    }
    return res;
  }
  var unpackConfig = {
    kernelName: Unpack,
    backendName: "cpu",
    kernelFunc: unpack
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/UnsortedSegmentSum.js
  function unsortedSegmentSum2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, segmentIds } = inputs;
    const { numSegments } = attrs;
    assertNotComplex(x, "unsortedSegmentSum");
    const xRank = x.shape.length;
    const segmentIdsRank = segmentIds.shape.length;
    const res = [];
    const intermediates = [];
    const numIters = xRank - segmentIdsRank;
    let $segmentIds = segmentIds;
    for (let i = 0; i < numIters; ++i) {
      const expanded = expandDims3({ inputs: { input: $segmentIds }, backend: backend2, attrs: { dim: i + 1 } });
      $segmentIds = expanded;
      intermediates.push(expanded);
    }
    for (let i = 0; i < numSegments; ++i) {
      const scalarValue = util_exports2.createScalarValue(i, "int32");
      const segmentId = backend2.makeTensorInfo([], "int32", scalarValue);
      const mask = equal2({ inputs: { a: segmentId, b: $segmentIds }, backend: backend2 });
      const maskCasted = cast3({ inputs: { x: mask }, backend: backend2, attrs: { dtype: "float32" } });
      const mul5 = multiply4({ inputs: { a: maskCasted, b: x }, backend: backend2 });
      const sumTensorInfo = sum3({ inputs: { x: mul5 }, backend: backend2, attrs: { axis: 0, keepDims: false } });
      res.push(sumTensorInfo);
      intermediates.push(segmentId);
      intermediates.push(mask);
      intermediates.push(maskCasted);
      intermediates.push(mul5);
      intermediates.push(sumTensorInfo);
    }
    const result = pack({ inputs: res, backend: backend2, attrs: { axis: 0 } });
    intermediates.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  var unsortedSegmentSumConfig = {
    kernelName: UnsortedSegmentSum,
    backendName: "cpu",
    kernelFunc: unsortedSegmentSum2
  };

  // node_modules/@tensorflow/tfjs-backend-cpu/dist/register_all_kernels.js
  var kernelConfigs = [
    _fusedMatMulConfig,
    absConfig,
    acosConfig,
    acoshConfig,
    addConfig,
    addNConfig,
    allConfig,
    anyConfig,
    argMaxConfig,
    argMinConfig,
    asinConfig,
    asinhConfig,
    atanConfig,
    atan2Config,
    atanhConfig,
    avgPoolConfig,
    avgPool3DConfig,
    avgPool3DGradConfig2,
    avgPoolGradConfig2,
    batchMatMulConfig,
    batchNormConfig,
    batchToSpaceNDConfig,
    bincountConfig,
    broadcastArgsConfig,
    castConfig,
    ceilConfig,
    clipConfig,
    complexConfig,
    complexAbsConfig,
    concatConfig,
    conv2DBackpropFilterConfig,
    conv2DBackpropInputConfig,
    conv2DConfig,
    conv3DBackpropFilterV2Config,
    conv3DBackpropInputV2Config,
    conv3DConfig,
    cosConfig,
    coshConfig,
    cropAndResizeConfig,
    cumsumConfig,
    denseBincountConfig,
    depthToSpaceConfig,
    depthwiseConv2dNativeConfig,
    depthwiseConv2dNativeBackpropFilterConfig,
    depthwiseConv2dNativeBackpropInputConfig,
    diagConfig,
    dilation2dConfig,
    dilation2dBackpropInputConfig,
    dilation2dBackpropFilterConfig,
    realDivConfig,
    einsumConfig,
    eluConfig,
    eluGradConfig2,
    equalConfig,
    erfConfig,
    expConfig,
    expandDimsConfig,
    expm1Config,
    fftConfig,
    fillConfig,
    flipLeftRightConfig,
    floorConfig,
    floorDivConfig,
    fusedConv2DConfig,
    fusedDepthwiseConv2DConfig,
    gatherNdConfig,
    gatherV2Config,
    greaterConfig,
    greaterEqualConfig,
    identityConfig,
    ifftConfig,
    imagConfig,
    isFiniteConfig,
    isInfConfig,
    isNaNConfig,
    leakyReluConfig,
    lessConfig,
    lessEqualConfig,
    linSpaceConfig,
    logConfig,
    log1pConfig,
    logicalAndConfig,
    logicalNotConfig,
    logicalOrConfig,
    lRNConfig,
    lRNGradConfig,
    maximumConfig,
    maxPoolConfig,
    maxPool3DConfig,
    maxPool3DGradConfig2,
    maxPoolGradConfig2,
    maxPoolWithArgmaxConfig,
    maxConfig,
    meanConfig,
    minConfig,
    minimumConfig,
    mirrorPadConfig,
    modConfig,
    multinomialConfig,
    multiplyConfig,
    negConfig,
    nonMaxSuppressionV3Config,
    nonMaxSuppressionV4Config,
    nonMaxSuppressionV5Config,
    notEqualConfig,
    oneHotConfig,
    onesLikeConfig,
    packConfig,
    padV2Config,
    powConfig,
    preluConfig,
    prodConfig,
    rangeConfig,
    realConfig,
    reciprocalConfig,
    reluConfig,
    relu6Config,
    reshapeConfig,
    resizeBilinearConfig,
    resizeBilinearGradConfig2,
    resizeNearestNeighborConfig,
    resizeNearestNeighborGradConfig2,
    reverseConfig,
    rotateWithOffsetConfig,
    roundConfig,
    rsqrtConfig,
    scatterNdConfig,
    selectConfig,
    seluConfig,
    sigmoidConfig,
    signConfig,
    sinConfig,
    sinhConfig,
    sliceConfig,
    softmaxConfig,
    softplusConfig,
    spaceToBatchNDConfig,
    sparseFillEmptyRowsConfig,
    sparseReshapeConfig,
    sparseSegmentMeanConfig,
    sparseSegmentSumConfig,
    sparseToDenseConfig,
    splitVConfig,
    sqrtConfig,
    squareConfig,
    squaredDifferenceConfig,
    stepConfig,
    stridedSliceConfig,
    stringNGramsConfig,
    stringSplitConfig,
    stringToHashBucketFastConfig,
    subConfig,
    sumConfig,
    tanConfig,
    tanhConfig,
    tileConfig,
    topKConfig,
    transposeConfig,
    transformConfig,
    uniqueConfig,
    unpackConfig,
    unsortedSegmentSumConfig,
    zerosLikeConfig
  ];
  for (const kernelConfig of kernelConfigs) {
    registerKernel(kernelConfig);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js
  var contexts = {};
  var WEBGL_ATTRIBUTES = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
  function setWebGLContext(webGLVersion, gl) {
    contexts[webGLVersion] = gl;
  }
  function getWebGLContext(webGLVersion) {
    if (!(webGLVersion in contexts)) {
      const newCtx = getWebGLRenderingContext(webGLVersion);
      if (newCtx !== null) {
        contexts[webGLVersion] = newCtx;
      } else {
        console.log("Could not get context for WebGL version", webGLVersion);
        return null;
      }
    }
    const gl = contexts[webGLVersion];
    if (gl.isContextLost()) {
      delete contexts[webGLVersion];
      return getWebGLContext(webGLVersion);
    }
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.DITHER);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SAMPLE_COVERAGE);
    gl.enable(gl.SCISSOR_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    return contexts[webGLVersion];
  }
  function createCanvas(webGLVersion) {
    if (typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
      return new OffscreenCanvas(300, 150);
    } else if (typeof document !== "undefined") {
      return document.createElement("canvas");
    } else {
      throw new Error("Cannot create a canvas in this context");
    }
  }
  function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion !== 1 && webGLVersion !== 2) {
      throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
    }
    const canvas = createCanvas(webGLVersion);
    canvas.addEventListener("webglcontextlost", (ev) => {
      ev.preventDefault();
      delete contexts[webGLVersion];
    }, false);
    if (webGLVersion === 1) {
      return canvas.getContext("webgl", WEBGL_ATTRIBUTES) || canvas.getContext("experimental-webgl", WEBGL_ATTRIBUTES);
    }
    return canvas.getContext("webgl2", WEBGL_ATTRIBUTES);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js
  var PackingScheme;
  (function(PackingScheme2) {
    PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
    PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
  })(PackingScheme || (PackingScheme = {}));
  var TextureUsage;
  (function(TextureUsage2) {
    TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
    TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
    TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
    TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
  })(TextureUsage || (TextureUsage = {}));
  var PhysicalTextureType;
  (function(PhysicalTextureType2) {
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
  })(PhysicalTextureType || (PhysicalTextureType = {}));
  function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
  }
  function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
  }
  function getDenseTexShape(shape) {
    const size3 = util_exports2.sizeFromShape(shape);
    const texelsNeeded = Math.ceil(size3 / 4);
    return util_exports2.sizeToSquarishShape(texelsNeeded);
  }
  function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [
      Math.max(1, Math.ceil(columns / 2)),
      Math.max(1, Math.ceil(rows / 2))
    ];
  }
  function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    const [w, h2] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return w * h2 * 4;
  }
  function getTextureConfig(gl, textureHalfFloatExtension) {
    const glany = gl;
    let internalFormatFloat;
    let internalFormatHalfFloat;
    let internalFormatPackedHalfFloat;
    let internalFormatPackedFloat;
    let textureFormatFloat;
    let downloadTextureFormat;
    let downloadUnpackNumChannels;
    let defaultNumChannels;
    let textureTypeHalfFloat;
    let textureTypeFloat;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      internalFormatFloat = glany.R32F;
      internalFormatHalfFloat = glany.R16F;
      internalFormatPackedHalfFloat = glany.RGBA16F;
      internalFormatPackedFloat = glany.RGBA32F;
      textureFormatFloat = glany.RED;
      downloadUnpackNumChannels = 4;
      defaultNumChannels = 1;
      textureTypeHalfFloat = glany.HALF_FLOAT;
      textureTypeFloat = glany.FLOAT;
    } else {
      internalFormatFloat = gl.RGBA;
      internalFormatHalfFloat = gl.RGBA;
      internalFormatPackedHalfFloat = gl.RGBA;
      internalFormatPackedFloat = glany.RGBA;
      textureFormatFloat = gl.RGBA;
      downloadUnpackNumChannels = 4;
      defaultNumChannels = 4;
      textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
      textureTypeFloat = gl.FLOAT;
    }
    downloadTextureFormat = gl.RGBA;
    return {
      internalFormatFloat,
      internalFormatHalfFloat,
      internalFormatPackedHalfFloat,
      internalFormatPackedFloat,
      textureFormatFloat,
      downloadTextureFormat,
      downloadUnpackNumChannels,
      defaultNumChannels,
      textureTypeHalfFloat,
      textureTypeFloat
    };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js
  function callAndCheck(gl, func2) {
    const returnValue = func2();
    if (env().getBool("DEBUG")) {
      checkWebGLError(gl);
    }
    return returnValue;
  }
  function checkWebGLError(gl) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
      throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error));
    }
  }
  var MIN_FLOAT16 = 596e-10;
  var MAX_FLOAT16 = 65504;
  function canBeRepresented(num) {
    if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
      return true;
    }
    return false;
  }
  function getWebGLErrorMessage(gl, status) {
    switch (status) {
      case gl.NO_ERROR:
        return "NO_ERROR";
      case gl.INVALID_ENUM:
        return "INVALID_ENUM";
      case gl.INVALID_VALUE:
        return "INVALID_VALUE";
      case gl.INVALID_OPERATION:
        return "INVALID_OPERATION";
      case gl.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";
      case gl.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";
      case gl.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";
      default:
        return `Unknown error code ${status}`;
    }
  }
  function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
  }
  function createVertexShader(gl, vertexShaderSource) {
    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
    callAndCheck(gl, () => gl.compileShader(vertexShader));
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
      console.log(gl.getShaderInfoLog(vertexShader));
      throw new Error("Failed to compile vertex shader.");
    }
    return vertexShader;
  }
  function createFragmentShader(gl, fragmentShaderSource) {
    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
    callAndCheck(gl, () => gl.compileShader(fragmentShader));
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
      logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
      throw new Error("Failed to compile fragment shader.");
    }
    return fragmentShader;
  }
  var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
  function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
      console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
      console.log(shaderSource);
      return;
    }
    const lineNumber = +lineNumberRegexResult[1];
    const shaderLines = shaderSource.split("\n");
    const pad3 = shaderLines.length.toString().length + 2;
    const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => util_exports2.rightPad((lineNumber2 + 1).toString(), pad3) + line);
    let maxLineLength = 0;
    for (let i = 0; i < linesWithLineNumbers.length; i++) {
      maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join("\n"));
    console.log(shaderInfoLog.split("\n")[0]);
    console.log(`%c ${util_exports2.rightPad(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
    console.log(afterErrorLines.join("\n"));
  }
  function createProgram(gl) {
    return throwIfNull(gl, () => gl.createProgram(), "Unable to create WebGLProgram.");
  }
  function linkProgram(gl, program) {
    callAndCheck(gl, () => gl.linkProgram(program));
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
      console.log(gl.getProgramInfoLog(program));
      throw new Error("Failed to link vertex and fragment shaders.");
    }
  }
  function validateProgram(gl, program) {
    callAndCheck(gl, () => gl.validateProgram(program));
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
      console.log(gl.getProgramInfoLog(program));
      throw new Error("Shader program validation failed.");
    }
  }
  function createStaticVertexBuffer(gl, data) {
    const buffer3 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer3));
    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));
    return buffer3;
  }
  function createStaticIndexBuffer(gl, data) {
    const buffer3 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer3));
    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));
    return buffer3;
  }
  function createTexture(gl) {
    return throwIfNull(gl, () => gl.createTexture(), "Unable to create WebGLTexture.");
  }
  function validateTextureSize(width, height) {
    const maxTextureSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (width <= 0 || height <= 0) {
      const requested = `[${width}x${height}]`;
      throw new Error("Requested texture size " + requested + " is invalid.");
    }
    if (width > maxTextureSize || height > maxTextureSize) {
      const requested = `[${width}x${height}]`;
      const max7 = `[${maxTextureSize}x${maxTextureSize}]`;
      throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max7 + ".");
    }
  }
  function createFramebuffer(gl) {
    return throwIfNull(gl, () => gl.createFramebuffer(), "Unable to create WebGLFramebuffer.");
  }
  function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer3, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    const loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
      return false;
    }
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer3));
    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
    return true;
  }
  function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
  }
  function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
  }
  function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
  }
  function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
  }
  function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
  }
  function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
  }
  function validateFramebuffer(gl) {
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status));
    }
  }
  function getFramebufferErrorMessage(gl, status) {
    switch (status) {
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      case gl.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";
      default:
        return `unknown error ${status}`;
    }
  }
  function throwIfNull(gl, returnTOrNull, failureMessage) {
    const tOrNull = callAndCheck(gl, () => returnTOrNull());
    if (tOrNull == null) {
      throw new Error(failureMessage);
    }
    return tOrNull;
  }
  function validateTextureUnit(gl, textureUnit) {
    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    const glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
      const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
      throw new Error(`textureUnit must be in ${textureUnitRange}.`);
    }
  }
  function getBatchDim(shape, dimsToSkip = 2) {
    return util_exports2.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
  }
  function getRowsCols(shape) {
    if (shape.length === 0) {
      throw Error("Cannot get rows and columns of an empty shape array.");
    }
    return [
      shape.length > 1 ? shape[shape.length - 2] : 1,
      shape[shape.length - 1]
    ];
  }
  function getShapeAs3D(shape) {
    let shapeAs3D = [1, 1, 1];
    const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
    if (!isScalar) {
      shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
    }
    return shapeAs3D;
  }
  function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
    let maxTexSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (isPacked) {
      maxTexSize = maxTexSize * 2;
      logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util_exports2.nearestLargerEven(logShape[i]) : logShape[i]);
      if (logShape.length === 1) {
        logShape = [2, logShape[0]];
      }
    }
    if (logShape.length !== 2) {
      const squeezeResult = util_exports2.squeezeShape(logShape);
      logShape = squeezeResult.newShape;
    }
    let size3 = util_exports2.sizeFromShape(logShape);
    if (logShape.length <= 1 && size3 <= maxTexSize) {
      return [1, size3];
    } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
      return logShape;
    } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
      return [logShape[0] * logShape[1], logShape[2]];
    } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
      return [logShape[0], logShape[1] * logShape[2]];
    } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
      return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
    } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
      return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    } else {
      if (isPacked) {
        const batchDim = getBatchDim(logShape);
        let rows = 2, cols = 2;
        if (logShape.length) {
          [rows, cols] = getRowsCols(logShape);
        }
        size3 = batchDim * (rows / 2) * (cols / 2);
        return util_exports2.sizeToSquarishShape(size3).map((d) => d * 2);
      }
      return util_exports2.sizeToSquarishShape(size3);
    }
  }
  function isEven(n) {
    return n % 2 === 0;
  }
  function isReshapeFree(shape1, shape2) {
    shape1 = shape1.slice(-2);
    shape2 = shape2.slice(-2);
    if (util_exports2.arraysEqual(shape1, shape2)) {
      return true;
    }
    if (!shape1.length || !shape2.length) {
      return true;
    }
    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
      return true;
    }
    if (shape1.length !== shape2.length) {
      const shape1Cols = shape1.slice(-1)[0];
      const shape2Cols = shape2.slice(-1)[0];
      if (shape1Cols === shape2Cols) {
        return true;
      }
      if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
        return true;
      }
    }
    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
  }
  var MAX_TEXTURE_SIZE;
  var MAX_TEXTURES_IN_SHADER;
  function getWebGLMaxTextureSize(webGLVersion) {
    if (MAX_TEXTURE_SIZE == null) {
      const gl = getWebGLContext(webGLVersion);
      MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    }
    return MAX_TEXTURE_SIZE;
  }
  function getMaxTexturesInShader(webGLVersion) {
    if (MAX_TEXTURES_IN_SHADER == null) {
      const gl = getWebGLContext(webGLVersion);
      MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, MAX_TEXTURES_IN_SHADER);
  }
  function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
      return 0;
    }
    let queryTimerVersion;
    const gl = getWebGLContext(webGLVersion);
    if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
      queryTimerVersion = 2;
    } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
      queryTimerVersion = 1;
    } else {
      queryTimerVersion = 0;
    }
    return queryTimerVersion;
  }
  function hasExtension(gl, extensionName) {
    const ext = gl.getExtension(extensionName);
    return ext != null;
  }
  function isWebGLVersionEnabled(webGLVersion) {
    try {
      const gl = getWebGLContext(webGLVersion);
      if (gl != null) {
        return true;
      }
    } catch (e) {
      console.log("Error when getting WebGL context: ", e);
      return false;
    }
    return false;
  }
  function isCapableOfRenderingToFloatTexture(webGLVersion) {
    if (webGLVersion === 0) {
      return false;
    }
    const gl = getWebGLContext(webGLVersion);
    if (webGLVersion === 1) {
      if (!hasExtension(gl, "OES_texture_float")) {
        return false;
      }
    } else {
      if (!hasExtension(gl, "EXT_color_buffer_float")) {
        return false;
      }
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
  }
  function isDownloadFloatTextureEnabled(webGLVersion) {
    if (webGLVersion === 0) {
      return false;
    }
    const gl = getWebGLContext(webGLVersion);
    if (webGLVersion === 1) {
      if (!hasExtension(gl, "OES_texture_float")) {
        return false;
      }
      if (!hasExtension(gl, "WEBGL_color_buffer_float")) {
        return false;
      }
    } else {
      if (hasExtension(gl, "EXT_color_buffer_float")) {
        return createFloatTextureAndBindToFramebuffer(gl);
      }
      const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
      if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
        const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
        return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
      }
      return false;
    }
    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
    return isFrameBufferComplete;
  }
  function createFloatTextureAndBindToFramebuffer(gl) {
    const texConfig = getTextureConfig(gl);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
  }
  function createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {
    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const width = 1;
    const height = 1;
    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
    const frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(frameBuffer);
    return isFrameBufferComplete;
  }
  function isWebGLFenceEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
      return false;
    }
    const gl = getWebGLContext(webGLVersion);
    const isEnabled = gl.fenceSync != null;
    return isEnabled;
  }
  function assertNotComplex2(tensor2, opName) {
    if (!Array.isArray(tensor2)) {
      tensor2 = [tensor2];
    }
    tensor2.forEach((t) => {
      if (t != null) {
        util_exports2.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the WebGL backend.`);
      }
    });
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js
  var ENV3 = env();
  ENV3.registerFlag("HAS_WEBGL", () => ENV3.getNumber("WEBGL_VERSION") > 0);
  ENV3.registerFlag("WEBGL_VERSION", () => {
    if (isWebGLVersionEnabled(2)) {
      return 2;
    } else if (isWebGLVersionEnabled(1)) {
      return 1;
    }
    return 0;
  });
  ENV3.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  ENV3.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV3.get("WEBGL_VERSION") === 2);
  ENV3.registerFlag("WEBGL_CPU_FORWARD", () => true);
  ENV3.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  ENV3.registerFlag("WEBGL_PACK", () => ENV3.getBool("HAS_WEBGL"));
  ENV3.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_CLIP", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_PACK_REDUCE", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_CONV_IM2COL", () => ENV3.getBool("WEBGL_PACK"));
  ENV3.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    const webGLVersion = ENV3.getNumber("WEBGL_VERSION");
    if (webGLVersion === 0) {
      return 0;
    }
    return getWebGLDisjointQueryTimerVersion(webGLVersion);
  });
  ENV3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV3.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !device_util_exports.isMobile());
  ENV3.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
    return ENV3.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV3.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
  });
  ENV3.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV3.getNumber("WEBGL_VERSION")));
  ENV3.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
    const useUniforms = ENV3.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
    return useUniforms ? 4 : 0;
  });
  ENV3.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
    return -1;
  }, (threshold3) => {
    if (threshold3 < 0 && threshold3 !== -1) {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${threshold3}.`);
    }
  });
  ENV3.registerFlag("WEBGL_FLUSH_THRESHOLD", () => {
    return device_util_exports.isMobile() ? 1 : -1;
  }, (threshold3) => {
    if (threshold3 < 0 && threshold3 !== -1) {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${threshold3}.`);
    }
  });
  ENV3.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  ENV3.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  ENV3.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  ENV3.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js
  function getGlslDifferences() {
    let version11;
    let attribute;
    let varyingVs;
    let varyingFs;
    let texture2D;
    let output;
    let defineOutput;
    let defineSpecialNaN;
    let defineSpecialInf;
    let defineRound;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      version11 = "#version 300 es";
      attribute = "in";
      varyingVs = "out";
      varyingFs = "in";
      texture2D = "texture";
      output = "outputColor";
      defineOutput = "out vec4 outputColor;";
      defineSpecialNaN = `
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `;
      defineSpecialInf = ``;
      defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    } else {
      version11 = "";
      attribute = "attribute";
      varyingVs = "varying";
      varyingFs = "varying";
      texture2D = "texture2D";
      output = "gl_FragColor";
      defineOutput = "";
      defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
      defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
      defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
    }
    return {
      version: version11,
      attribute,
      varyingVs,
      varyingFs,
      texture2D,
      output,
      defineOutput,
      defineSpecialNaN,
      defineSpecialInf,
      defineRound
    };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js
  function getLogicalCoordinatesFromFlatIndex(coords2, shape, index = "index") {
    const strides = util_exports2.computeStrides(shape);
    return strides.map((stride, i) => {
      const line1 = `int ${coords2[i]} = ${index} / ${stride}`;
      const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index} - ${coords2[i]} * ${stride}` : `index -= ${coords2[i]} * ${stride}`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords2, shape, index = "index") {
    const strides = util_exports2.computeStrides(shape);
    return strides.map((_6, i) => {
      const line1 = `int ${coords2[i]} = ${index} / outShapeStrides[${i}]`;
      const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index} - ${coords2[i]} * outShapeStrides[${i}]` : `index -= ${coords2[i]} * outShapeStrides[${i}]`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function symbolicallyComputeStrides(indicesArr, variableName) {
    const numCoords = indicesArr.length;
    const shape = indicesArr.map((d) => `${variableName}[${d}]`);
    const strides = new Array(numCoords - 1);
    strides[numCoords - 2] = shape[numCoords - 1];
    for (let i = numCoords - 3; i >= 0; --i) {
      strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;
    }
    return strides;
  }
  function getLogicalCoordinatesFromFlatIndexByUniform(coords2, variableName, index = "index") {
    const indicesArray = coords2.map((_6, i) => i);
    const strides = symbolicallyComputeStrides(indicesArray, variableName);
    return strides.map((_6, i) => {
      const line1 = `int ${coords2[i]} = ${index} / ${strides[i]}`;
      const line2 = i === strides.length - 1 ? `int ${coords2[i + 1]} = ${index} - ${coords2[i]} * ${strides[i]}` : `index -= ${coords2[i]} * ${strides[i]}`;
      return `${line1}; ${line2};`;
    }).join("");
  }
  function getFlatIndexFrom3D(shape) {
    const strides = util_exports2.computeStrides(shape).map((d) => d.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
  }
  function getFlatIndexFrom3DOutput() {
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
  }
  var ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js
  var { getBroadcastDims: getBroadcastDims2 } = backend_util_exports;
  function makeShader(inputsInfo, outputShape, program) {
    const prefixSnippets = [];
    inputsInfo.forEach((x) => {
      const size3 = util_exports2.sizeFromShape(x.shapeInfo.logicalShape);
      if (x.shapeInfo.isUniform) {
        prefixSnippets.push(`uniform float ${x.name}${size3 > 1 ? `[${size3}]` : ""};`);
      } else {
        prefixSnippets.push(`uniform sampler2D ${x.name};`);
        prefixSnippets.push(`uniform int offset${x.name};`);
      }
      if (program.enableShapeUniforms) {
        const { uniformShape } = getUniformInfoFromShape(program.packedInputs, x.shapeInfo.logicalShape, x.shapeInfo.texShape);
        switch (uniformShape.length) {
          case 1:
            prefixSnippets.push(`uniform int ${x.name}Shape;`);
            break;
          case 2:
            prefixSnippets.push(`uniform ivec2 ${x.name}Shape;`);
            break;
          case 3:
            prefixSnippets.push(`uniform ivec3 ${x.name}Shape;`);
            break;
          case 4:
            prefixSnippets.push(`uniform ivec4 ${x.name}Shape;`);
            break;
          default:
            break;
        }
        prefixSnippets.push(`uniform ivec2 ${x.name}TexShape;`);
      }
    });
    if (program.enableShapeUniforms) {
      switch (outputShape.logicalShape.length) {
        case 1:
          prefixSnippets.push(`uniform int outShape;`);
          break;
        case 2:
          prefixSnippets.push(`uniform ivec2 outShape;`);
          prefixSnippets.push(`uniform int outShapeStrides;`);
          break;
        case 3:
          prefixSnippets.push(`uniform ivec3 outShape;`);
          prefixSnippets.push(`uniform ivec2 outShapeStrides;`);
          break;
        case 4:
          prefixSnippets.push(`uniform ivec4 outShape;`);
          prefixSnippets.push(`uniform ivec3 outShapeStrides;`);
          break;
        default:
          break;
      }
      prefixSnippets.push(`uniform ivec2 outTexShape;`);
    }
    if (program.customUniforms) {
      program.customUniforms.forEach((d) => {
        prefixSnippets.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ""};`);
      });
    }
    const inputPrefixSnippet = prefixSnippets.join("\n");
    const inputSamplingSnippet = inputsInfo.map((x) => getInputSamplingSnippet(x, outputShape, program.packedInputs, program.enableShapeUniforms)).join("\n");
    const outTexShape = outputShape.texShape;
    const glsl = getGlslDifferences();
    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
    let outputSamplingSnippet;
    let floatTextureSetOutputSnippet;
    let shaderPrefix = getShaderPrefix(glsl);
    if (outputShape.isPacked) {
      outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
      floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
    } else {
      outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
      floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
    }
    if (program.packedInputs) {
      shaderPrefix += SHADER_PACKED_PREFIX;
    }
    const source = [
      shaderPrefix,
      floatTextureSampleSnippet,
      floatTextureSetOutputSnippet,
      inputPrefixSnippet,
      outputSamplingSnippet,
      inputSamplingSnippet,
      program.userCode
    ].join("\n");
    return source;
  }
  function getSamplerFromInInfo(inInfo, enableShapeUniforms = false) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
      case 0:
        return getSamplerScalar(inInfo, enableShapeUniforms);
      case 1:
        return getSampler1D(inInfo, enableShapeUniforms);
      case 2:
        return getSampler2D(inInfo, enableShapeUniforms);
      case 3:
        return getSampler3D(inInfo, enableShapeUniforms);
      case 4:
        return getSampler4D(inInfo, enableShapeUniforms);
      case 5:
        return getSampler5D(inInfo);
      case 6:
        return getSampler6D(inInfo);
      default:
        throw new Error(`${shape.length}-D input sampling is not yet supported`);
    }
  }
  function getPackedSamplerFromInInfo(inInfo, enableShapeUniforms) {
    const shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
      case 0:
        return getPackedSamplerScalar(inInfo);
      case 1:
        return getPackedSampler1D(inInfo, enableShapeUniforms);
      case 2:
        return getPackedSampler2D(inInfo, enableShapeUniforms);
      case 3:
        return getPackedSampler3D(inInfo, enableShapeUniforms);
      default:
        return getPackedSamplerND(inInfo, enableShapeUniforms);
    }
  }
  function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false, enableShapeUniforms) {
    let res = "";
    if (usesPackedTextures) {
      res += getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);
    } else {
      res += getSamplerFromInInfo(inInfo, enableShapeUniforms);
    }
    const inShape = inInfo.shapeInfo.logicalShape;
    const outShape = outShapeInfo.logicalShape;
    if (inShape.length <= outShape.length) {
      if (usesPackedTextures) {
        res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
      } else {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
      }
    }
    return res;
  }
  function getPackedOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch (outShape.length) {
      case 0:
        return getOutputScalarCoords();
      case 1:
        return getOutputPacked1DCoords(outShape, outTexShape, enableShapeUniforms);
      case 2:
        return getOutputPacked2DCoords(outShape, outTexShape, enableShapeUniforms);
      case 3:
        return getOutputPacked3DCoords(outShape, outTexShape, enableShapeUniforms);
      default:
        return getOutputPackedNDCoords(outShape, outTexShape, enableShapeUniforms);
    }
  }
  function getOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
    switch (outShape.length) {
      case 0:
        return getOutputScalarCoords();
      case 1:
        return getOutput1DCoords(outShape, outTexShape, enableShapeUniforms);
      case 2:
        return getOutput2DCoords(outShape, outTexShape, enableShapeUniforms);
      case 3:
        return getOutput3DCoords(outShape, outTexShape, enableShapeUniforms);
      case 4:
        return getOutput4DCoords(outShape, outTexShape, enableShapeUniforms);
      case 5:
        return getOutput5DCoords(outShape, outTexShape);
      case 6:
        return getOutput6DCoords(outShape, outTexShape);
      default:
        throw new Error(`${outShape.length}-D output sampling is not yet supported`);
    }
  }
  function getFloatTextureSampleSnippet(glsl) {
    return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
  }
  function getFloatTextureSetRSnippet(glsl) {
    return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
  }
  function getFloatTextureSetRGBASnippet(glsl) {
    return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
  }
  function getShaderPrefix(glsl) {
    const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
    return SHADER_PREFIX;
  }
  var SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`;
  var SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
  function getOutputScalarCoords() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
  }
  function getOutputPacked1DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (packedTexShape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
    }
    if (packedTexShape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
  }
  function getOutput1DCoords(shape, texShape, enableShapeUniforms) {
    if (texShape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
    }
    if (texShape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `;
      }
      return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `;
    }
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
  }
  function getOutputPacked3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  function getOutput3DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], shape);
      return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${coordsFromIndexSnippet2}
    return ivec3(r, c, d);
  }
`;
    }
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
    return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
  }
  function getOutputPackedNDCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
    let texelsInBatchN = texelsInBatch;
    let batches = ``;
    let coords2 = "b, r, c";
    for (let b = 2; b < shape.length - 1; b++) {
      texelsInBatchN *= shape[shape.length - b - 1];
      batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
      coords2 = `b${b}, ` + coords2;
    }
    return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords2});
    }
  `;
  }
  function getOutput4DCoords(shape, texShape, enableShapeUniforms) {
    if (enableShapeUniforms) {
      const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d", "d2"], shape);
      return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${coordsFromIndexSnippet2}
      return ivec4(r, c, d, d2);
    }
  `;
    }
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  function getOutput5DCoords(shape, texShape) {
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
    return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
  }
  function getOutput6DCoords(shape, texShape) {
    const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
    return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
  }
  function getOutputPacked2DCoords(shape, texShape, enableShapeUniforms) {
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (util_exports2.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
    }
    const texelsInLogicalRow = Math.ceil(shape[1] / 2);
    if (enableShapeUniforms) {
      return `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
  }
  function getOutput2DCoords(shape, texShape, enableShapeUniforms) {
    if (util_exports2.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
    }
    if (shape[1] === 1) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    if (shape[0] === 1) {
      if (enableShapeUniforms) {
        return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `;
      }
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `;
    }
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
  }
  function getFlatOffsetUniformName(texName) {
    return `offset${texName}`;
  }
  function getPackedSamplerScalar(inputInfo) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = getGlslDifferences();
    return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
  }
  function getSamplerScalar(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
      return `float ${funcName}() {return ${texName};}`;
    }
    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
    if (texNumR === 1 && texNumC === 1) {
      return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getPackedSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler1D(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const tNumR = texShape[0];
    const tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
      return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (tNumC === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (tNumR === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getPackedSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const glsl = getGlslDifferences();
    if (texShape != null && util_exports2.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
      }
      return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const valuesPerRow = Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler2D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    if (texShape != null && util_exports2.arraysEqual(shape, texShape)) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      const texNumR2 = texShape[0];
      const texNumC2 = texShape[1];
      return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const { newShape, keptDims } = util_exports2.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["row", "col"];
      return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const offset = getFlatOffsetUniformName(texName);
    if (texNumC === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (texNumR === 1) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${texName}Shape[1] + col + ${offset};
        vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
  }
  function getPackedSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    if (shape[0] === 1) {
      const squeezedShape = shape.slice(1);
      const keptDims = [1, 2];
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["b", "row", "col"];
      return `
        ${getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[2] / 2);
    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
    return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler3D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride0 = shape[1] * shape[2];
    const stride1 = shape[2];
    const { newShape, keptDims } = util_exports2.squeezeShape(shape);
    const squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
      const params = ["row", "col", "depth"];
      return `
        ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    if (texNumC === stride0 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth) {
        int stride1 = ${texName}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
    }
    if (texNumC === stride1 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];
      int stride1 = ${texName}Shape[2];
      int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
      return sampleTexture(${texName}, uv);
    }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
  }
  function getPackedSamplerND(inputInfo, enableShapeUniforms) {
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const glsl = getGlslDifferences();
    if (enableShapeUniforms) {
      return `
    vec4 ${funcName}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${texName}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${glsl.texture2D}(${texName}, uv);
    }
  `;
    }
    const shape = inputInfo.shapeInfo.logicalShape;
    const rank = shape.length;
    const texShape = inputInfo.shapeInfo.texShape;
    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
    const texNumR = packedTexShape[0];
    const texNumC = packedTexShape[1];
    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
    let params = `int b, int row, int col`;
    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
    for (let b = 2; b < rank - 1; b++) {
      params = `int b${b}, ` + params;
      texelsInBatch *= shape[rank - b - 1];
      index = `b${b} * ${texelsInBatch} + ` + index;
    }
    return `
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  function getSampler4D(inputInfo, enableShapeUniforms) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride2 = shape[3];
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = util_exports2.squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2"];
      return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    const stride2Str = `int stride2 = ${texName}Shape[3];`;
    const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;
    const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;
    if (texNumC === stride0 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        ${stride2Str}
        ${stride1Str}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride2 && flatOffset == null) {
      if (enableShapeUniforms) {
        return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${texName}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
      }
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    if (enableShapeUniforms) {
      return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${stride2Str}
      ${stride1Str}
      ${stride0Str}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
    }
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getSampler5D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const stride3 = shape[4];
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    const { newShape, keptDims } = util_exports2.squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2", "depth3"];
      return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride3 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getSampler6D(inputInfo) {
    const shape = inputInfo.shapeInfo.logicalShape;
    const texName = inputInfo.name;
    const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
    const { newShape, keptDims } = util_exports2.squeezeShape(shape);
    if (newShape.length < shape.length) {
      const newInputInfo = squeezeInputInfo(inputInfo, newShape);
      const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
      return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
    }
    const stride4 = shape[5];
    const stride3 = shape[4] * stride4;
    const stride2 = shape[3] * stride3;
    const stride1 = shape[2] * stride2;
    const stride0 = shape[1] * stride1;
    if (inputInfo.shapeInfo.isUniform) {
      return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
    }
    const flatOffset = inputInfo.shapeInfo.flatOffset;
    const texShape = inputInfo.shapeInfo.texShape;
    const texNumR = texShape[0];
    const texNumC = texShape[1];
    if (texNumC === stride0 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    if (texNumC === stride4 && flatOffset == null) {
      return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const offset = getFlatOffsetUniformName(texName);
    return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  function getUniformSampler(inputInfo) {
    const texName = inputInfo.name;
    const inSize = util_exports2.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    if (inSize < 2) {
      return `return ${texName};`;
    }
    return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
  }
  function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = "get" + texFuncSnippet + "AtOutCoords";
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const type = getCoordsDataType(outRank);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ["x", "y", "z", "w", "u", "v"];
    if (inRank === 0) {
      coordsSnippet = "";
    } else if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
    }
    let unpackedCoordsSnippet = "";
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
    }
    let output = `return outputValue;`;
    const inSize = util_exports2.sizeFromShape(inputInfo.shapeInfo.logicalShape);
    const isInputScalar = inSize === 1;
    const outSize = util_exports2.sizeFromShape(outShapeInfo.logicalShape);
    const isOutputScalar = outSize === 1;
    if (inRank === 1 && !isInputScalar && !isOutputScalar) {
      output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
    } else if (isInputScalar && !isOutputScalar) {
      if (outRank === 1) {
        output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
      } else {
        output = `
        return vec4(outputValue.x);
      `;
      }
    } else if (broadcastDims.length) {
      const rows = inRank - 2;
      const cols = inRank - 1;
      if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
        output = `return vec4(outputValue.x);`;
      } else if (broadcastDims.indexOf(rows) > -1) {
        output = `return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);`;
      } else if (broadcastDims.indexOf(cols) > -1) {
        output = `return vec4(outputValue.xx, outputValue.zz);`;
      }
    }
    return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
  }
  function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = "get" + texFuncSnippet + "AtOutCoords";
    const outTexShape = outShapeInfo.texShape;
    const inTexShape = inputInfo.shapeInfo.texShape;
    const inRank = inputInfo.shapeInfo.logicalShape.length;
    const outRank = outShapeInfo.logicalShape.length;
    if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && util_exports2.arraysEqual(inTexShape, outTexShape)) {
      return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
    }
    const type = getCoordsDataType(outRank);
    const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet;
    const fields = ["x", "y", "z", "w", "u", "v"];
    if (inRank === 0) {
      coordsSnippet = "";
    } else if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
    }
    let unpackedCoordsSnippet = "";
    if (outRank < 2 && inRank > 0) {
      unpackedCoordsSnippet = "coords";
    } else {
      unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
    }
    return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
  }
  function getCoordsDataType(rank) {
    if (rank <= 1) {
      return "int";
    } else if (rank === 2) {
      return "ivec2";
    } else if (rank === 3) {
      return "ivec3";
    } else if (rank === 4) {
      return "ivec4";
    } else if (rank === 5) {
      return "ivec5";
    } else if (rank === 6) {
      return "ivec6";
    } else {
      throw Error(`GPU for rank ${rank} is not yet supported`);
    }
  }
  function getUniformInfoFromShape(isPacked, shape, texShape) {
    const { newShape, keptDims } = util_exports2.squeezeShape(shape);
    const rank = shape.length;
    const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;
    const squeezeShape2 = useSqueezePackedShape ? shape.slice(1) : newShape;
    const useSqueezeShape = !isPacked && rank > 1 && !util_exports2.arraysEqual(shape, texShape) && newShape.length < rank || useSqueezePackedShape;
    const uniformShape = useSqueezeShape ? squeezeShape2 : shape;
    return { useSqueezeShape, uniformShape, keptDims };
  }
  function squeezeInputInfo(inInfo, squeezedShape) {
    const newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
  }
  function getSqueezedParams(params, keptDims) {
    return keptDims.map((d) => params[d]).join(", ");
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js
  function compileProgram(gpgpu, program, inputs, output) {
    const inputInfos = inputs.map((input2, i) => {
      const shapeInfo = {
        logicalShape: input2.shape,
        texShape: input2.isUniform ? null : input2.texData.texShape,
        isUniform: input2.isUniform,
        isPacked: input2.isUniform ? false : input2.texData.isPacked,
        flatOffset: null
      };
      if (input2.texData != null && input2.texData.slice != null && input2.texData.slice.flatOffset > 0) {
        shapeInfo.flatOffset = input2.texData.slice.flatOffset;
      }
      return { name: program.variableNames[i], shapeInfo };
    });
    const inShapeInfos = inputInfos.map((x) => x.shapeInfo);
    const outShapeInfo = {
      logicalShape: output.shape,
      texShape: output.texData.texShape,
      isUniform: false,
      isPacked: output.texData.isPacked,
      flatOffset: null
    };
    const source = makeShader(inputInfos, outShapeInfo, program);
    const webGLProgram = gpgpu.createProgram(source);
    let infLoc = null;
    const nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
    if (env().getNumber("WEBGL_VERSION") === 1) {
      infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
    }
    const shouldThrow = false;
    const uniformLocations = {};
    const inShapesLocations = {};
    const inTexShapesLocations = {};
    for (let i = 0; i < program.variableNames.length; i++) {
      const varName = program.variableNames[i];
      uniformLocations[varName] = gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);
      uniformLocations[`offset${varName}`] = gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);
      if (program.enableShapeUniforms) {
        inShapesLocations[`${varName}Shape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
        inTexShapesLocations[`${varName}TexShape`] = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
      }
    }
    let outShapeLocation;
    let outTexShapeLocation;
    let outShapeStridesLocation;
    if (program.enableShapeUniforms) {
      outShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outShape", shouldThrow);
      outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, "outShapeStrides", shouldThrow);
      outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outTexShape", shouldThrow);
    }
    const customUniformLocations = [];
    if (program.customUniforms) {
      program.customUniforms.forEach((d, i) => {
        customUniformLocations[i] = gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow);
      });
    }
    return {
      program,
      source,
      webGLProgram,
      uniformLocations,
      customUniformLocations,
      inShapeInfos,
      outShapeInfo,
      infLoc,
      nanLoc,
      inShapesLocations,
      inTexShapesLocations,
      outShapeLocation,
      outShapeStridesLocation,
      outTexShapeLocation
    };
  }
  function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
      throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but was executed with ${inputs.length} inputs`);
    }
    shapeInfos.forEach((s, i) => {
      const shapeA = s.logicalShape;
      const input2 = inputs[i];
      const shapeB = input2.shape;
      if (!util_exports2.arraysEqual(shapeA, shapeB)) {
        throw Error(`Binary was compiled with different shapes than the current args. Shapes ${shapeA} and ${shapeB} must match`);
      }
      if (s.isUniform && input2.isUniform) {
        return;
      }
      const texShapeA = s.texShape;
      const texShapeB = input2.isUniform ? null : input2.texData.texShape;
      if (!util_exports2.arraysEqual(texShapeA, texShapeB)) {
        throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${texShapeA} and ${texShapeB} must match`);
      }
    });
  }
  function runProgram(gpgpu, binary, inputs, output, customUniformValues) {
    if (!binary.program.enableShapeUniforms) {
      validateBinaryAndProgram(binary.inShapeInfos, inputs);
      validateBinaryAndProgram([binary.outShapeInfo], [output]);
    }
    const outTex = output.texData.texture;
    const outTexShape = output.texData.texShape;
    if (output.texData.isPacked) {
      gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    } else {
      gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    }
    gpgpu.setProgram(binary.webGLProgram);
    if (env().getNumber("WEBGL_VERSION") === 1) {
      if (binary.infLoc !== null) {
        gpgpu.gl.uniform1f(binary.infLoc, Infinity);
      }
    }
    if (binary.nanLoc !== null) {
      gpgpu.gl.uniform1f(binary.nanLoc, NaN);
    }
    inputs.forEach((input2, i) => {
      const varName = binary.program.variableNames[i];
      const varLoc = binary.uniformLocations[varName];
      const varOffsetLoc = binary.uniformLocations[`offset${varName}`];
      const varShapeLoc = binary.inShapesLocations[`${varName}Shape`];
      const varTexShapeLoc = binary.inTexShapesLocations[`${varName}TexShape`];
      if (varShapeLoc) {
        const { uniformShape } = getUniformInfoFromShape(binary.program.packedInputs, input2.shape, input2.texData.texShape);
        switch (uniformShape.length) {
          case 1:
            gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 2:
            gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 3:
            gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          case 4:
            gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
            break;
          default:
            break;
        }
      }
      if (varTexShapeLoc) {
        gpgpu.gl.uniform2i(varTexShapeLoc, input2.texData.texShape[0], input2.texData.texShape[1]);
      }
      if (varLoc == null) {
        return;
      }
      if (input2.isUniform) {
        if (util_exports2.sizeFromShape(input2.shape) < 2) {
          gpgpu.gl.uniform1f(varLoc, input2.uniformValues[0]);
        } else {
          let vals = input2.uniformValues;
          if (!(vals instanceof Float32Array)) {
            vals = new Float32Array(vals);
          }
          gpgpu.gl.uniform1fv(varLoc, vals);
        }
        return;
      }
      if (input2.texData.slice != null && varOffsetLoc != null) {
        gpgpu.gl.uniform1i(varOffsetLoc, input2.texData.slice.flatOffset);
      }
      gpgpu.setInputMatrixTexture(input2.texData.texture, varLoc, i);
    });
    const outShapeLoc = binary.outShapeLocation;
    if (outShapeLoc) {
      switch (output.shape.length) {
        case 1:
          gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 2:
          gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 3:
          gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
          break;
        case 4:
          gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
          break;
        default:
          break;
      }
    }
    if (binary.outShapeStridesLocation) {
      const strides = util_exports2.computeStrides(output.shape);
      switch (output.shape.length) {
        case 2:
          gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        case 3:
          gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        case 4:
          gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
          break;
        default:
          break;
      }
    }
    if (binary.outTexShapeLocation) {
      gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
    }
    if (binary.program.customUniforms && customUniformValues) {
      binary.program.customUniforms.forEach((d, i) => {
        const customLoc = binary.customUniformLocations[i];
        const customValue = customUniformValues[i];
        if (d.type === "float") {
          gpgpu.gl.uniform1fv(customLoc, customValue);
        } else if (d.type === "vec2") {
          gpgpu.gl.uniform2fv(customLoc, customValue);
        } else if (d.type === "vec3") {
          gpgpu.gl.uniform3fv(customLoc, customValue);
        } else if (d.type === "vec4") {
          gpgpu.gl.uniform4fv(customLoc, customValue);
        } else if (d.type === "int") {
          gpgpu.gl.uniform1iv(customLoc, customValue);
        } else if (d.type === "ivec2") {
          gpgpu.gl.uniform2iv(customLoc, customValue);
        } else if (d.type === "ivec3") {
          gpgpu.gl.uniform3iv(customLoc, customValue);
        } else if (d.type === "ivec4") {
          gpgpu.gl.uniform4iv(customLoc, customValue);
        } else {
          throw Error(`uniform type ${d.type} is not supported yet.`);
        }
      });
    }
    gpgpu.executeProgram();
  }
  function makeShaderKey(program, inputs, output) {
    let keyInputs = "";
    inputs.concat(output).forEach((x) => {
      const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;
      if (program.enableShapeUniforms && !x.isUniform) {
        const xTexShape = x.texData.texShape;
        const { useSqueezeShape, uniformShape, keptDims } = getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape);
        let rank1 = "", rank2 = "", rank34 = "";
        if (uniformShape.length === 1 && program.packedInputs) {
          const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];
          rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
        } else if (uniformShape.length === 2 && !program.packedInputs) {
          rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
        } else if (uniformShape.length > 2 && !program.packedInputs) {
          const strides = util_exports2.computeStrides(uniformShape);
          rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
        }
        const xRank = x.shape.length;
        const isLogicalShapTexShapeEqual = uniformShape.length === 2 && util_exports2.arraysEqual(x.shape, xTexShape);
        const isScalar = util_exports2.sizeFromShape(x.shape) === 1;
        const broadcastDims = backend_util_exports.getBroadcastDims(x.shape, output.shape);
        const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && util_exports2.arraysEqual(xTexShape, output.texData.texShape);
        const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? "" : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
        keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ""}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
      } else {
        const texShape = x.isUniform ? "uniform" : x.texData.texShape;
        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
      }
    });
    const keyUserCode = program.userCode;
    let key = program.constructor.name;
    key += "_" + keyInputs + "_" + keyUserCode + `${env().getNumber("WEBGL_VERSION")}`;
    return key;
  }
  function useShapeUniforms(rank) {
    return env().getBool("WEBGL_USE_SHAPES_UNIFORMS") && rank <= 4;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js
  var DecodeMatrixProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outPackingScheme = PackingScheme.DENSE;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js
  var DecodeMatrixPackedProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outPackingScheme = PackingScheme.DENSE;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js
  var EncodeFloatProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.outTexUsage = TextureUsage.DOWNLOAD;
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js
  var EncodeFloatPackedProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = false;
      this.outTexUsage = TextureUsage.DOWNLOAD;
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js
  var EncodeMatrixProgram = class {
    constructor(outputShape, inputIsUnsignedByte = false) {
      this.variableNames = ["A"];
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let output = `result`;
      if (inputIsUnsignedByte) {
        output = `floor(result * 255. + 0.5)`;
      }
      this.userCode = `
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${glsl.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js
  var EncodeMatrixPackedProgram = class {
    constructor(outputShape, inputIsUnsignedByte = false) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.customUniforms = [{ name: "texShape", type: "ivec2" }];
      const glsl = getGlslDifferences();
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let mainLoop = "";
      let output = "result";
      if (inputIsUnsignedByte) {
        output = "floor(result * 255. + 0.5)";
      }
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          const channel = row * 2 + col;
          mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${this.enableShapeUniforms ? "outShape[2]" : `${outputShape[2]}`}) {
          localCoords[2] += ${col};
          if (localCoords[1] + ${row} < ${this.enableShapeUniforms ? "outShape[1]" : `${outputShape[1]}`}) {
            localCoords[1] += ${row};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${glsl.texture2D}(A, uv);

            if (offset == 0) {
              result[${channel}] = values[0];
            } else if (offset == 1) {
              result[${channel}] = values[1];
            } else if (offset == 2) {
              result[${channel}] = values[2];
            } else {
              result[${channel}] = values[3];
            }
          }
        }
        `;
        }
      }
      this.userCode = `
        ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${mainLoop}

          ${glsl.output} = ${output};
        }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js
  function createVertexShader2(gl) {
    const glsl = getGlslDifferences();
    const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
    return createVertexShader(gl, vertexShaderSource);
  }
  function createVertexBuffer(gl) {
    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return createStaticVertexBuffer(gl, vertexArray);
  }
  function createIndexBuffer(gl) {
    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return createStaticIndexBuffer(gl, triangleVertexIndices);
  }
  function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
    validateTextureSize(width, height);
    const texture = createTexture(gl);
    const tex2d = gl.TEXTURE_2D;
    callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
    callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
    callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
    return texture;
  }
  function getInternalFormatForFloat32MatrixTexture(textureConfig) {
    return textureConfig.internalFormatFloat;
  }
  function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
  }
  function getInternalFormatForFloat16MatrixTexture(textureConfig) {
    return textureConfig.internalFormatHalfFloat;
  }
  function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
  }
  function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
    return textureConfig.downloadTextureFormat;
  }
  function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
  }
  function getInternalFormatForPackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedFloat;
  }
  function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
  }
  function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
    return textureConfig.internalFormatPackedHalfFloat;
  }
  function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
  }
  function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    const posOffset = 0;
    const uvOffset = 3 * 4;
    const stride = 3 * 4 + 2 * 4;
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
    const success = bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
    return success && bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset);
  }
  function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    let dataForUpload, texelDataType, internalFormat;
    if (data instanceof Uint8Array) {
      dataForUpload = new Uint8Array(width * height * 4);
      texelDataType = gl.UNSIGNED_BYTE;
      internalFormat = gl.RGBA;
    } else {
      dataForUpload = new Float32Array(width * height * 4);
      texelDataType = gl.FLOAT;
      internalFormat = textureConfig.internalFormatPackedFloat;
    }
    dataForUpload.set(data);
    callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  }
  function uploadPixelDataToTexture(gl, texture, pixels) {
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
    if (pixels.data instanceof Uint8Array) {
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
    } else {
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
    }
    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  }
  function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
    const buffer3 = gl2.createBuffer();
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer3));
    const bytesPerFloat = 4;
    const valuesPerTexel = 4;
    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
    callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
    callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
    callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
    return buffer3;
  }
  function downloadFloat32MatrixFromBuffer(gl, buffer3, size3) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(size3);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer3);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
  }
  function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
    const [w, h2] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
    const numChannels = 4;
    const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
    callAndCheck(gl, () => gl.readPixels(0, 0, w, h2, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
    return new Float32Array(downloadTarget.buffer);
  }
  function downloadPackedMatrixFromBuffer(gl, buffer3, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
    const gl2 = gl;
    const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer3);
    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
    return downloadTarget;
  }
  function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
    callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
    return packedRGBA;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js
  var GPGPUContext = class {
    constructor(gl) {
      this.outputTexture = null;
      this.program = null;
      this.disposed = false;
      this.vertexAttrsAreBound = false;
      this.itemsToPoll = [];
      const glVersion = env().getNumber("WEBGL_VERSION");
      if (gl != null) {
        this.gl = gl;
        setWebGLContext(glVersion, gl);
      } else {
        this.gl = getWebGLContext(glVersion);
      }
      let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
      const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
      if (env().getNumber("WEBGL_VERSION") === 1) {
        const TEXTURE_FLOAT = "OES_texture_float";
        const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
        this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
        if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
          this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
        } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
        if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
          this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
        } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
          throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        }
      } else {
        COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
        if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
          this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
        } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
          this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
        } else {
          throw new Error("GL context does not support color renderable floats");
        }
      }
      this.vertexBuffer = createVertexBuffer(this.gl);
      this.indexBuffer = createIndexBuffer(this.gl);
      this.framebuffer = createFramebuffer(this.gl);
      this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
      return env().getBool("DEBUG");
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (this.program != null) {
        console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.");
      }
      if (this.outputTexture != null) {
        console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
      }
      const gl = this.gl;
      callAndCheck(gl, () => gl.finish());
      callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
      callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
      callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
      callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
      callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
      this.disposed = true;
    }
    createFloat32MatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createFloat16MatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    uploadPixelDataToTexture(texture, pixels) {
      this.throwIfDisposed();
      uploadPixelDataToTexture(this.gl, texture, pixels);
    }
    uploadDenseMatrixToTexture(texture, width, height, data) {
      this.throwIfDisposed();
      uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    createPackedMatrixTexture(rows, columns) {
      this.throwIfDisposed();
      return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
    }
    deleteMatrixTexture(texture) {
      this.throwIfDisposed();
      if (this.outputTexture === texture) {
        unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        this.outputTexture = null;
      }
      callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
      return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(buffer3, batch, rows, columns, physicalRows, physicalCols) {
      return downloadPackedMatrixFromBuffer(this.gl, buffer3, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(buffer3, size3) {
      return downloadFloat32MatrixFromBuffer(this.gl, buffer3, size3);
    }
    createBufferFromTexture(texture, rows, columns) {
      this.bindTextureToFrameBuffer(texture);
      const result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
      this.unbindTextureToFrameBuffer();
      return result;
    }
    createAndWaitForFence() {
      const fenceContext = this.createFence(this.gl);
      return this.pollFence(fenceContext);
    }
    createFence(gl) {
      let query;
      let isFencePassed;
      if (env().getBool("WEBGL_FENCE_API_ENABLED")) {
        const gl2 = gl;
        const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl.flush();
        isFencePassed = () => {
          const status = gl2.clientWaitSync(sync, 0, 0);
          return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
        };
        query = sync;
      } else if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
        query = this.beginQuery();
        this.endQuery();
        isFencePassed = () => this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
      } else {
        isFencePassed = () => true;
      }
      return { query, isFencePassed };
    }
    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
      return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
    }
    createProgram(fragmentShaderSource) {
      this.throwIfDisposed();
      const gl = this.gl;
      const fragmentShader = createFragmentShader(gl, fragmentShaderSource);
      if (this.vertexShader == null) {
        this.vertexShader = createVertexShader2(gl);
      }
      const program = createProgram(gl);
      callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));
      callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
      linkProgram(gl, program);
      if (this.debug) {
        validateProgram(gl, program);
      }
      if (!this.vertexAttrsAreBound) {
        this.setProgram(program);
        this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
      }
      return program;
    }
    deleteProgram(program) {
      this.throwIfDisposed();
      if (program === this.program) {
        this.program = null;
      }
      if (program != null) {
        callAndCheck(this.gl, () => this.gl.deleteProgram(program));
      }
    }
    setProgram(program) {
      this.throwIfDisposed();
      this.program = program;
      if (this.program != null && this.debug) {
        validateProgram(this.gl, this.program);
      }
      callAndCheck(this.gl, () => this.gl.useProgram(program));
    }
    getUniformLocation(program, uniformName, shouldThrow = true) {
      this.throwIfDisposed();
      if (shouldThrow) {
        return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
      } else {
        return getProgramUniformLocation(this.gl, program, uniformName);
      }
    }
    getAttributeLocation(program, attribute) {
      this.throwIfDisposed();
      return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
    }
    getUniformLocationNoThrow(program, uniformName) {
      this.throwIfDisposed();
      return this.gl.getUniformLocation(program, uniformName);
    }
    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
      this.throwIfDisposed();
      this.throwIfNoProgram();
      bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
    }
    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
      this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    }
    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
      this.throwIfDisposed();
      const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
      this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    }
    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
      this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    }
    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
      throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
      if (this.program != null) {
        validateProgram(this.gl, this.program);
      }
      validateFramebuffer(this.gl);
    }
    executeProgram() {
      this.throwIfDisposed();
      this.throwIfNoProgram();
      const gl = this.gl;
      if (this.debug) {
        this.debugValidate();
      }
      callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
      this.throwIfDisposed();
      callAndCheck(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
      if (this.disjointQueryTimerExtension == null) {
        this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
      }
      return this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
      return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
      return this.getQueryTimerExtension();
    }
    beginQuery() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const gl2 = this.gl;
        const ext2 = this.getQueryTimerExtensionWebGL2();
        const query2 = gl2.createQuery();
        gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
        return query2;
      }
      const ext = this.getQueryTimerExtensionWebGL1();
      const query = ext.createQueryEXT();
      ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
      return query;
    }
    endQuery() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
        const gl2 = this.gl;
        const ext2 = this.getQueryTimerExtensionWebGL2();
        gl2.endQuery(ext2.TIME_ELAPSED_EXT);
        return;
      }
      const ext = this.getQueryTimerExtensionWebGL1();
      ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(query) {
      await util_exports2.repeatedTry(() => this.disposed || this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
      return this.getQueryTime(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(query, queryTimerVersion) {
      if (queryTimerVersion === 0) {
        return null;
      }
      if (queryTimerVersion === 2) {
        const gl2 = this.gl;
        const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
        return timeElapsedNanos / 1e6;
      } else {
        const ext = this.getQueryTimerExtensionWebGL1();
        const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
        return timeElapsedNanos / 1e6;
      }
    }
    isQueryAvailable(query, queryTimerVersion) {
      if (queryTimerVersion === 0) {
        return true;
      }
      if (queryTimerVersion === 2) {
        const gl2 = this.gl;
        const ext = this.getQueryTimerExtensionWebGL2();
        const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
        }
        return available && !this.disjoint;
      } else {
        const ext = this.getQueryTimerExtensionWebGL1();
        const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
        if (this.disjoint == null) {
          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
        }
        return available && !this.disjoint;
      }
    }
    pollFence(fenceContext) {
      return new Promise((resolve) => {
        this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
      });
    }
    pollItems() {
      const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
      for (let i = 0; i <= index; ++i) {
        const { resolveFn } = this.itemsToPoll[i];
        resolveFn();
      }
      this.itemsToPoll = this.itemsToPoll.slice(index + 1);
    }
    addItemToPoll(isDoneFn, resolveFn) {
      this.itemsToPoll.push({ isDoneFn, resolveFn });
      if (this.itemsToPoll.length > 1) {
        return;
      }
      util_exports2.repeatedTry(() => {
        this.pollItems();
        return this.itemsToPoll.length === 0;
      });
    }
    bindTextureToFrameBuffer(texture) {
      this.throwIfDisposed();
      bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(this.gl);
      }
    }
    unbindTextureToFrameBuffer() {
      if (this.outputTexture != null) {
        bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
        if (this.debug) {
          validateFramebuffer(this.gl);
        }
      } else {
        unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
      }
    }
    downloadMatrixDriver(texture, downloadAndDecode) {
      this.bindTextureToFrameBuffer(texture);
      const result = downloadAndDecode();
      this.unbindTextureToFrameBuffer();
      return result;
    }
    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
      this.throwIfDisposed();
      const gl = this.gl;
      bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(gl);
      }
      this.outputTexture = outputMatrixTextureMaybePacked;
      callAndCheck(gl, () => gl.viewport(0, 0, width, height));
      callAndCheck(gl, () => gl.scissor(0, 0, width, height));
    }
    setOutputMatrixWriteRegionDriver(x, y, width, height) {
      this.throwIfDisposed();
      callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));
    }
    throwIfDisposed() {
      if (this.disposed) {
        throw new Error("Attempted to use disposed GPGPUContext.");
      }
    }
    throwIfNoProgram() {
      if (this.program == null) {
        throw new Error("No GPU program is currently set.");
      }
    }
  };
  function linearSearchLastTrue(arr) {
    let i = 0;
    for (; i < arr.length; ++i) {
      const isDone = arr[i]();
      if (!isDone) {
        break;
      }
    }
    return i - 1;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js
  var { addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, equalImpl: equalImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherNdImpl: gatherNdImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, greaterEqualImpl: greaterEqualImplCPU, lessImpl: lessImplCPU, lessEqualImpl: lessEqualImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, notEqualImpl: notEqualImplCPU, prodImpl: prodImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, sigmoidImpl: sigmoidImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU, sparseReshapeImpl: sparseReshapeImplCPU, sparseSegmentReductionImpl: sparseSegmentReductionImplCPU, sqrtImpl: sqrtImplCPU, stridedSliceImpl: stridedSliceImplCPU, stringNGramsImpl: stringNGramsImplCPU, stringSplitImpl: stringSplitImplCPU, stringToHashBucketFastImpl: stringToHashBucketFastImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU } = shared_exports;

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js
  function getVecChannels(name, rank) {
    return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d) => `${name}.${d}`);
  }
  function getChannels(name, rank) {
    if (rank === 1) {
      return [name];
    }
    return getVecChannels(name, rank);
  }
  function getSourceCoords(rank, dims) {
    if (rank === 1) {
      return "rc";
    }
    let coords2 = "";
    for (let i = 0; i < rank; i++) {
      coords2 += dims[i];
      if (i < rank - 1) {
        coords2 += ",";
      }
    }
    return coords2;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js
  var PackProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      this.outputShape = outputShape;
      const rank = outputShape.length;
      if (rank === 0) {
        this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
      } else {
        const channels = getChannels("rc", rank);
        const dtype = getCoordsDataType(rank);
        const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);
        const setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);
        const output = getOutput(outputShape, channels);
        this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `;
      }
    }
  };
  function getSourceCoordsArr(rank, dims) {
    const coords2 = [];
    for (let row = 0; row <= 1; row++) {
      for (let col = 0; col <= 1; col++) {
        let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
        for (let d = 2; d < rank; d++) {
          coord = `${dims[dims.length - 1 - d]},` + coord;
        }
        coords2.push(coord);
      }
    }
    return coords2;
  }
  function getOutOfBoundsCondition(rank, shape, dims) {
    if (rank === 1) {
      return `rc > ${shape[0]}`;
    }
    let cond = "";
    for (let i = rank - 2; i < rank; i++) {
      cond += `${dims[i]} >= ${shape[i]}`;
      if (i < rank - 1) {
        cond += "||";
      }
    }
    return cond;
  }
  function getSetup(rank, cols, rows, dims) {
    if (rank === 1) {
      return "";
    }
    const innerDims = dims.slice(-2);
    return `
    int r = ${innerDims[0]};
    int c = ${innerDims[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${cols};
    bool rEdge = rp1 >= ${rows};
  `;
  }
  function getOutput(shape, dims) {
    const rank = shape.length;
    const sourceCoords = getSourceCoordsArr(rank, dims);
    if (rank === 1) {
      return `getA(rc),
            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),
            0, 0`;
    }
    return `getA(${sourceCoords[0]}),
          cEdge ? 0. : getA(${sourceCoords[1]}),
          rEdge ? 0. : getA(${sourceCoords[2]}),
          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js
  var ReshapePackedProgram = class {
    constructor(outputShape, inputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [{ name: "inputShape", type: "ivec3" }];
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      let mainLoop = ``;
      for (let i = 0; i < 4; i++) {
        let thisRC = `thisRC = rc;`;
        if (i % 2 === 1) {
          thisRC += `thisRC.z += 1;`;
        }
        if (i > 1) {
          thisRC += `thisRC.y += 1;`;
        }
        mainLoop += `
        ${thisRC}
        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
      }
      this.userCode = `
      ${getReshapedInputCoords(inputShape, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : outputShape[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
    }
  };
  function getReshapedInputCoords(shape, enableShapeUniforms) {
    const coordsFromIndexSnippet = enableShapeUniforms ? getLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], "inputShape") : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
    return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js
  var TextureManager = class {
    constructor(gpgpu) {
      this.gpgpu = gpgpu;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
      this.freeTextures = {};
      this.logEnabled = false;
      this.usedTextures = {};
    }
    acquireTexture(shapeRC, usage, isPacked) {
      const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
      const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
      if (!(shapeKey in this.freeTextures)) {
        this.freeTextures[shapeKey] = [];
      }
      if (!(shapeKey in this.usedTextures)) {
        this.usedTextures[shapeKey] = [];
      }
      const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
      if (this.freeTextures[shapeKey].length > 0) {
        this.numFreeTextures--;
        this.numUsedTextures++;
        this._numBytesFree -= texBytes;
        this.log();
        const newTexture2 = this.freeTextures[shapeKey].shift();
        this.usedTextures[shapeKey].push(newTexture2);
        return newTexture2;
      }
      let newTexture;
      if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
        newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
        newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
        newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
        newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
      } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
        newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
      }
      this.usedTextures[shapeKey].push(newTexture);
      this.numUsedTextures++;
      this._numBytesAllocated += texBytes;
      this.log();
      return newTexture;
    }
    releaseTexture(texture, shape, logicalTexType, isPacked) {
      if (this.freeTextures == null) {
        return;
      }
      const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
      const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
      if (!(shapeKey in this.freeTextures)) {
        this.freeTextures[shapeKey] = [];
      }
      const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
      const deleteTexThreshold = env().get("WEBGL_DELETE_TEXTURE_THRESHOLD");
      if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
        this.gpgpu.deleteMatrixTexture(texture);
        this._numBytesAllocated -= texBytes;
      } else {
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this._numBytesFree += texBytes;
      }
      this.numUsedTextures--;
      const texList = this.usedTextures[shapeKey];
      const texIndex = texList.indexOf(texture);
      if (texIndex < 0) {
        throw new Error("Cannot release a texture that was never provided by this texture manager");
      }
      texList.splice(texIndex, 1);
      this.log();
    }
    log() {
      if (!this.logEnabled) {
        return;
      }
      const total = this.numFreeTextures + this.numUsedTextures;
      console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
      const freeRatio = this._numBytesFree / this._numBytesAllocated;
      console.log(`Bytes allocated: ${this._numBytesAllocated}`);
      console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
    }
    get numBytesAllocated() {
      return this._numBytesAllocated;
    }
    get numBytesFree() {
      return this._numBytesFree;
    }
    getNumUsedTextures() {
      return this.numUsedTextures;
    }
    getNumFreeTextures() {
      return this.numFreeTextures;
    }
    dispose() {
      if (this.freeTextures == null) {
        return;
      }
      for (const texShape in this.freeTextures) {
        this.freeTextures[texShape].forEach((tex) => {
          this.gpgpu.deleteMatrixTexture(tex);
        });
      }
      for (const texShape in this.usedTextures) {
        this.usedTextures[texShape].forEach((tex) => {
          this.gpgpu.deleteMatrixTexture(tex);
        });
      }
      this.freeTextures = null;
      this.usedTextures = null;
      this.numUsedTextures = 0;
      this.numFreeTextures = 0;
      this._numBytesAllocated = 0;
      this._numBytesFree = 0;
    }
  };
  function numBytesForInternalFormat(gl, internalFormat) {
    const glany = gl;
    if (internalFormat === glany.R32F) {
      return 4;
    } else if (internalFormat === glany.R16F) {
      return 2;
    } else if (internalFormat === glany.RGBA32F) {
      return 16;
    } else if (internalFormat === gl.RGBA) {
      return 16;
    } else if (internalFormat === glany.RGBA16F) {
      return 8;
    }
    throw new Error(`Unknown internal format ${internalFormat}`);
  }
  function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
    let numElements;
    if (isPacked) {
      const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
      numElements = packedWidth * packedHeight;
    } else {
      const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
      numElements = width * height;
    }
    const bytesPerElement2 = numBytesForInternalFormat(gl, internalFormat);
    return numElements * bytesPerElement2;
  }
  function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
    switch (physicalTexType) {
      case PhysicalTextureType.PACKED_2X2_FLOAT32:
        return getInternalFormatForPackedMatrixTexture(textureConfig);
      case PhysicalTextureType.PACKED_2X2_FLOAT16:
        return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
      case PhysicalTextureType.UNPACKED_FLOAT32:
        return getInternalFormatForFloat32MatrixTexture(textureConfig);
      case PhysicalTextureType.UNPACKED_FLOAT16:
        return getInternalFormatForFloat16MatrixTexture(textureConfig);
      case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
        return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
      default:
        throw new Error(`Unknown physical texture type ${physicalTexType}`);
    }
  }
  function getPhysicalTextureForRendering(isPacked) {
    if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
      if (isPacked) {
        return PhysicalTextureType.PACKED_2X2_FLOAT32;
      }
      return PhysicalTextureType.UNPACKED_FLOAT32;
    }
    if (isPacked) {
      return PhysicalTextureType.PACKED_2X2_FLOAT16;
    }
    return PhysicalTextureType.UNPACKED_FLOAT16;
  }
  function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
    if (logicalTexType === TextureUsage.UPLOAD) {
      return PhysicalTextureType.PACKED_2X2_FLOAT32;
    } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
      return getPhysicalTextureForRendering(isPacked);
    } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
      return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
    }
    throw new Error(`Unknown logical texture type ${logicalTexType}`);
  }
  function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js
  var UnaryOpProgram = class {
    constructor(aShape, opSnippet) {
      this.variableNames = ["A"];
      this.outputShape = aShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };
  var CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;
  var LINEAR = `return x;`;
  var ABS = `return abs(x);`;
  var ELU2 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
  var RELU = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
  var RELU6 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var CLONE = "return x;";
  var SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js
  var LINEAR2 = `return x;`;
  var ELU3 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var RELU2 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var RELU62 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var SIGMOID2 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
  var UnaryOpPackedProgram = class {
    constructor(aShape, opSnippet) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = aShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js
  var UnpackProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = false;
      this.outputShape = outputShape;
      const rank = outputShape.length;
      const channels = getChannels("rc", rank);
      const dtype = getCoordsDataType(rank);
      const sourceCoords = getSourceCoords(rank, channels);
      const innerDims = channels.slice(-2);
      const coords2 = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
      this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords2}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js
  var whereImpl3 = kernel_impls_exports.whereImpl;
  var EPSILON_FLOAT322 = 1e-7;
  var EPSILON_FLOAT162 = 1e-4;
  var binaryCaches = {};
  function getBinaryCache(webGLVersion) {
    if (webGLVersion in binaryCaches) {
      return binaryCaches[webGLVersion];
    }
    binaryCaches[webGLVersion] = {};
    return binaryCaches[webGLVersion];
  }
  var CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  var BEFORE_PAGING_CONSTANT = 600;
  function numMBBeforeWarning() {
    if (env().global.screen == null) {
      return 1024;
    }
    return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
  }
  var MathBackendWebGL = class extends KernelBackend {
    constructor(gpgpu) {
      super();
      this.pendingRead = new WeakMap();
      this.pendingDisposal = new WeakSet();
      this.dataRefCount = new WeakMap();
      this.numBytesInGPU = 0;
      this.uploadWaitMs = 0;
      this.downloadWaitMs = 0;
      this.lastGlFlushTime = 0;
      this.warnedAboutMemory = false;
      this.pendingDeletes = 0;
      this.disposed = false;
      if (!env().getBool("HAS_WEBGL")) {
        throw new Error("WebGL is not supported on this device");
      }
      if (gpgpu == null) {
        const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"));
        this.binaryCache = getBinaryCache(env().getNumber("WEBGL_VERSION"));
        this.gpgpu = new GPGPUContext(gl);
        this.canvas = gl.canvas;
        this.gpgpuCreatedLocally = true;
      } else {
        this.gpgpu = gpgpu;
        this.binaryCache = {};
        this.gpgpuCreatedLocally = false;
        this.canvas = gpgpu.gl.canvas;
      }
      this.textureManager = new TextureManager(this.gpgpu);
      this.numMBBeforeWarning = numMBBeforeWarning();
      this.texData = new DataStorage(this, engine());
    }
    nextDataId() {
      return MathBackendWebGL.nextDataId++;
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    write(values2, shape, dtype) {
      if (env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env().getBool("DEBUG")) {
        this.checkNumericalProblems(values2);
      }
      if (dtype === "complex64" && values2 != null) {
        throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
      }
      const dataId = { id: this.nextDataId() };
      this.texData.set(dataId, { shape, dtype, values: values2, usage: TextureUsage.UPLOAD, refCount: 1 });
      return dataId;
    }
    refCount(dataId) {
      if (this.texData.has(dataId)) {
        const tensorData = this.texData.get(dataId);
        return tensorData.refCount;
      }
      return 0;
    }
    incRef(dataId) {
      const texData = this.texData.get(dataId);
      texData.refCount++;
    }
    decRef(dataId) {
      if (this.texData.has(dataId)) {
        const texData = this.texData.get(dataId);
        texData.refCount--;
      }
    }
    move(dataId, values2, shape, dtype, refCount) {
      if (env().getBool("DEBUG")) {
        this.checkNumericalProblems(values2);
      }
      if (dtype === "complex64") {
        throw new Error(`Cannot write to a complex64 dtype. Please use tf.complex(real, imag).`);
      }
      this.texData.set(dataId, { shape, dtype, values: values2, usage: TextureUsage.UPLOAD, refCount });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
      this.disposeData(tensorInfo.dataId);
    }
    readSync(dataId) {
      const texData = this.texData.get(dataId);
      const { values: values2, dtype, complexTensorInfos, slice: slice4, shape, isPacked } = texData;
      if (slice4 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.readSync(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values2 != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (dtype === "string") {
        return values2;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = util_exports2.now();
      }
      let result;
      if (dtype === "complex64") {
        const realValues = this.readSync(complexTensorInfos.real.dataId);
        const imagValues = this.readSync(complexTensorInfos.imag.dataId);
        result = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
      } else {
        result = this.getValuesFromTexture(dataId);
      }
      if (shouldTimeProgram) {
        this.downloadWaitMs += util_exports2.now() - start;
      }
      return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
      if (this.pendingRead.has(dataId)) {
        const subscribers2 = this.pendingRead.get(dataId);
        return new Promise((resolve) => subscribers2.push(resolve));
      }
      const texData = this.texData.get(dataId);
      const { values: values2, shape, slice: slice4, dtype, complexTensorInfos, isPacked } = texData;
      if (slice4 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.read(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values2 != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env().getNumber("WEBGL_VERSION") === 2) {
        throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.`);
      }
      let buffer3 = null;
      let tmpDownloadTarget;
      if (dtype !== "complex64" && env().get("WEBGL_BUFFER_SUPPORTED")) {
        tmpDownloadTarget = this.decode(dataId);
        const tmpData = this.texData.get(tmpDownloadTarget.dataId);
        buffer3 = this.gpgpu.createBufferFromTexture(tmpData.texture, ...getDenseTexShape(shape));
      }
      this.pendingRead.set(dataId, []);
      if (dtype !== "complex64") {
        await this.gpgpu.createAndWaitForFence();
      }
      let vals;
      if (dtype === "complex64") {
        const ps = await Promise.all([
          this.read(complexTensorInfos.real.dataId),
          this.read(complexTensorInfos.imag.dataId)
        ]);
        const realValues = ps[0];
        const imagValues = ps[1];
        vals = backend_util_exports.mergeRealAndImagArrays(realValues, imagValues);
      } else if (buffer3 == null) {
        vals = this.getValuesFromTexture(dataId);
      } else {
        const size3 = util_exports2.sizeFromShape(shape);
        vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer3, size3);
      }
      if (tmpDownloadTarget != null) {
        this.disposeIntermediateTensorInfo(tmpDownloadTarget);
      }
      if (buffer3 != null) {
        const gl = this.gpgpu.gl;
        callAndCheck(gl, () => gl.deleteBuffer(buffer3));
      }
      const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
      const subscribers = this.pendingRead.get(dataId);
      this.pendingRead.delete(dataId);
      subscribers.forEach((resolve) => resolve(dTypeVals));
      if (this.pendingDisposal.has(dataId)) {
        this.pendingDisposal.delete(dataId);
        if (this.disposeData(dataId)) {
          engine().removeDataId(dataId, this);
        }
        this.pendingDeletes--;
      }
      return dTypeVals;
    }
    bufferSync(t) {
      const data = this.readSync(t.dataId);
      let decodedData = data;
      if (t.dtype === "string") {
        try {
          decodedData = data.map((d) => util_exports2.decodeString(d));
        } catch (_a4) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      }
      return buffer2(t.shape, t.dtype, decodedData);
    }
    checkNumericalProblems(values2) {
      if (values2 == null) {
        return;
      }
      for (let i = 0; i < values2.length; i++) {
        const num = values2[i];
        if (!canBeRepresented(num)) {
          if (env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
            throw Error(`The value ${num} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
          }
          throw Error(`The value ${num} cannot be represented on this device.`);
        }
      }
    }
    getValuesFromTexture(dataId) {
      const { shape, dtype, isPacked } = this.texData.get(dataId);
      const size3 = util_exports2.sizeFromShape(shape);
      if (env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        const tmpTarget = this.decode(dataId);
        const tmpData2 = this.texData.get(tmpTarget.dataId);
        const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture, ...getDenseTexShape(shape)).subarray(0, size3);
        this.disposeIntermediateTensorInfo(tmpTarget);
        return vals2;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK") && isPacked === true;
      const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
      const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
      const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], "float32");
      const tmpData = this.texData.get(output.dataId);
      const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size3);
      this.disposeIntermediateTensorInfo(output);
      return vals;
    }
    timerAvailable() {
      return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    async time(f) {
      const oldActiveTimers = this.activeTimers;
      const newActiveTimers = [];
      let outerMostTime = false;
      if (this.programTimersStack == null) {
        this.programTimersStack = newActiveTimers;
        outerMostTime = true;
      } else {
        this.activeTimers.push(newActiveTimers);
      }
      this.activeTimers = newActiveTimers;
      f();
      const flattenedActiveTimerQueries = util_exports2.flatten(this.activeTimers.map((d) => d.query)).filter((d) => d != null);
      const flattenedActiveTimerNames = util_exports2.flatten(this.activeTimers.map((d) => d.name)).filter((d) => d != null);
      this.activeTimers = oldActiveTimers;
      if (outerMostTime) {
        this.programTimersStack = null;
      }
      const res = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      };
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        const kernelMs = await Promise.all(flattenedActiveTimerQueries);
        res["kernelMs"] = util_exports2.sum(kernelMs);
        res["getExtraProfileInfo"] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d })).map((d) => `${d.name}: ${d.ms}`).join(", ");
      } else {
        res["kernelMs"] = {
          error: "WebGL query timers are not supported in this environment."
        };
      }
      this.uploadWaitMs = 0;
      this.downloadWaitMs = 0;
      return res;
    }
    memory() {
      return {
        unreliable: false,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
    startTimer() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.beginQuery();
      }
      return { startMs: util_exports2.now(), endMs: null };
    }
    endTimer(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        this.gpgpu.endQuery();
        return query;
      }
      query.endMs = util_exports2.now();
      return query;
    }
    async getQueryTime(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.waitForQueryAndGetTime(query);
      }
      const timerQuery = query;
      return timerQuery.endMs - timerQuery.startMs;
    }
    disposeData(dataId, force = false) {
      if (this.pendingDisposal.has(dataId)) {
        return false;
      }
      if (!this.texData.has(dataId)) {
        return true;
      }
      if (force) {
        this.texData.get(dataId).refCount = 0;
      } else {
        this.texData.get(dataId).refCount--;
      }
      if (!force && this.texData.get(dataId).refCount > 0) {
        return false;
      }
      if (this.pendingRead.has(dataId)) {
        this.pendingDisposal.add(dataId);
        this.pendingDeletes++;
        return false;
      }
      this.releaseGPUData(dataId);
      const { complexTensorInfos } = this.texData.get(dataId);
      if (complexTensorInfos != null) {
        this.disposeData(complexTensorInfos.real.dataId, force);
        this.disposeData(complexTensorInfos.imag.dataId, force);
      }
      this.texData.delete(dataId);
      return true;
    }
    releaseGPUData(dataId) {
      const { texture, dtype, texShape, usage, isPacked, slice: slice4 } = this.texData.get(dataId);
      const key = slice4 && slice4.origDataId || dataId;
      const refCount = this.dataRefCount.get(key);
      if (refCount > 1) {
        this.dataRefCount.set(key, refCount - 1);
      } else {
        this.dataRefCount.delete(key);
        if (texture != null) {
          this.numBytesInGPU -= this.computeBytes(texShape, dtype);
          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
        }
      }
      const texData = this.texData.get(dataId);
      texData.texture = null;
      texData.texShape = null;
      texData.isPacked = false;
      texData.slice = null;
    }
    getTexture(dataId) {
      this.uploadToGPU(dataId);
      return this.texData.get(dataId).texture;
    }
    getDataInfo(dataId) {
      return this.texData.get(dataId);
    }
    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
      return env().getBool("WEBGL_CPU_FORWARD") && inputs.every((input2) => this.texData.get(input2.dataId).texture == null && util_exports2.sizeFromShape(input2.shape) < sizeThreshold);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(condition) {
      backend_util_exports.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
      const condVals = condition.dataSync();
      return whereImpl3(condition.shape, condVals);
    }
    packedUnaryOp(x, op2, dtype) {
      const program = new UnaryOpPackedProgram(x.shape, op2);
      const outInfo = this.compileAndRun(program, [x], dtype);
      return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
    }
    abs(x) {
      if (this.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
        const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);
        return this.makeOutput(x.shape, x.dtype, outValues);
      }
      if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
        return this.packedUnaryOp(x, ABS, x.dtype);
      }
      const program = new UnaryOpProgram(x.shape, ABS);
      const outInfo = this.compileAndRun(program, [x]);
      return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);
    }
    makeTensorInfo(shape, dtype, values2) {
      let dataId;
      if (dtype === "string" && values2 != null && values2.length > 0 && util_exports2.isString(values2[0])) {
        const encodedValues = values2.map((d) => util_exports2.encodeString(d));
        dataId = this.write(encodedValues, shape, dtype);
      } else {
        dataId = this.write(values2, shape, dtype);
      }
      this.texData.get(dataId).usage = null;
      return { dataId, shape, dtype };
    }
    makeOutput(shape, dtype, values2) {
      const { dataId } = this.makeTensorInfo(shape, dtype, values2);
      return engine().makeTensorFromDataId(dataId, shape, dtype, this);
    }
    unpackTensor(input2) {
      const program = new UnpackProgram(input2.shape);
      return this.runWebGLProgram(program, [input2], input2.dtype);
    }
    packTensor(input2) {
      const program = new PackProgram(input2.shape);
      const preventEagerUnpackingOutput = true;
      return this.runWebGLProgram(program, [input2], input2.dtype, null, preventEagerUnpackingOutput);
    }
    packedReshape(input2, afterShape) {
      const input3DShape = [
        getBatchDim(input2.shape),
        ...getRowsCols(input2.shape)
      ];
      const input3D = {
        dtype: input2.dtype,
        shape: input3DShape,
        dataId: input2.dataId
      };
      const afterShapeAs3D = [
        getBatchDim(afterShape),
        ...getRowsCols(afterShape)
      ];
      const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
      const preventEagerUnpackingOfOutput = true;
      const customValues = [input3DShape];
      const output = this.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
      return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
    decode(dataId) {
      const texData = this.texData.get(dataId);
      const { isPacked, shape, dtype } = texData;
      const shapeAs3D = getShapeAs3D(shape);
      let program;
      const denseTexShape = getDenseTexShape(shapeAs3D);
      if (isPacked) {
        program = new DecodeMatrixPackedProgram(shapeAs3D);
      } else {
        program = new DecodeMatrixProgram(shapeAs3D);
      }
      const preventEagerUnpackingOfOutput = true;
      const customValues = [denseTexShape];
      const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, customValues, preventEagerUnpackingOfOutput);
      return { dtype, shape, dataId: out.dataId };
    }
    runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
      const output = this.makeTensorInfo(program.outputShape, outputDtype);
      const outData = this.texData.get(output.dataId);
      if (program.packedOutput) {
        outData.isPacked = true;
      }
      if (program.outPackingScheme === PackingScheme.DENSE) {
        const texelShape = getDenseTexShape(program.outputShape);
        outData.texShape = texelShape.map((d) => d * 2);
      }
      if (program.outTexUsage != null) {
        outData.usage = program.outTexUsage;
      }
      if (util_exports2.sizeFromShape(output.shape) === 0) {
        outData.values = util_exports2.getTypedArrayFromDType(output.dtype, 0);
        return output;
      }
      const dataToDispose = [];
      const inputsData = inputs.map((input2) => {
        if (input2.dtype === "complex64") {
          throw new Error(`GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.`);
        }
        let texData = this.texData.get(input2.dataId);
        if (texData.texture == null) {
          if (!program.packedInputs && util_exports2.sizeFromShape(input2.shape) <= env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
            return {
              shape: input2.shape,
              texData: null,
              isUniform: true,
              uniformValues: texData.values
            };
          }
          if (program.packedInputs) {
            texData.isPacked = true;
            texData.shape = input2.shape;
          }
        } else if (!!texData.isPacked !== !!program.packedInputs) {
          input2 = texData.isPacked ? this.unpackTensor(input2) : this.packTensor(input2);
          dataToDispose.push(input2);
          texData = this.texData.get(input2.dataId);
        } else if (texData.isPacked && !isReshapeFree(texData.shape, input2.shape)) {
          const savedInput = input2;
          const targetShape = input2.shape;
          input2.shape = texData.shape;
          input2 = this.packedReshape(input2, targetShape);
          dataToDispose.push(input2);
          texData = this.texData.get(input2.dataId);
          savedInput.shape = targetShape;
        }
        this.uploadToGPU(input2.dataId);
        return { shape: input2.shape, texData, isUniform: false };
      });
      this.uploadToGPU(output.dataId);
      const outputData = { shape: output.shape, texData: outData, isUniform: false };
      const key = makeShaderKey(program, inputsData, outputData);
      const binary = this.getAndSaveBinary(key, () => {
        return compileProgram(this.gpgpu, program, inputsData, outputData);
      });
      const shouldTimeProgram = this.activeTimers != null;
      let query;
      if (shouldTimeProgram) {
        query = this.startTimer();
      }
      runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);
      dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
      if (shouldTimeProgram) {
        query = this.endTimer(query);
        this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
      }
      const glFlushThreshold = env().get("WEBGL_FLUSH_THRESHOLD");
      if (glFlushThreshold > 0) {
        const time = util_exports2.now();
        if (time - this.lastGlFlushTime > glFlushThreshold) {
          this.gpgpu.gl.flush();
          this.lastGlFlushTime = time;
        }
      }
      if (!env().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
        const unpacked = this.unpackTensor(output);
        this.disposeIntermediateTensorInfo(output);
        return unpacked;
      }
      return output;
    }
    compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
      outputDtype = outputDtype || inputs[0].dtype;
      const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
      return outInfo;
    }
    getAndSaveBinary(key, getBinary) {
      if (!(key in this.binaryCache)) {
        this.binaryCache[key] = getBinary();
      }
      return this.binaryCache[key];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (!env().getBool("IS_TEST")) {
        const allKeys = Object.keys(this.binaryCache);
        allKeys.forEach((key) => {
          this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
          delete this.binaryCache[key];
        });
      }
      this.textureManager.dispose();
      if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
        this.canvas.remove();
      } else {
        this.canvas = null;
      }
      if (this.gpgpuCreatedLocally) {
        this.gpgpu.program = null;
        this.gpgpu.dispose();
      }
      this.disposed = true;
    }
    floatPrecision() {
      if (this.floatPrecisionValue == null) {
        this.floatPrecisionValue = tidy(() => {
          if (!env().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
            const debugFlag = env().getBool("DEBUG");
            env().set("DEBUG", false);
            const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];
            env().set("DEBUG", debugFlag);
            if (underflowCheckValue > 0) {
              return 32;
            }
          }
          return 16;
        });
      }
      return this.floatPrecisionValue;
    }
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT322 : EPSILON_FLOAT162;
    }
    uploadToGPU(dataId) {
      const texData = this.texData.get(dataId);
      const { shape, dtype, values: values2, texture, usage, isPacked } = texData;
      if (texture != null) {
        return;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = util_exports2.now();
      }
      let texShape = texData.texShape;
      if (texShape == null) {
        texShape = getTextureShapeFromLogicalShape(shape, isPacked);
        texData.texShape = texShape;
      }
      if (values2 != null) {
        const shapeAs3D = getShapeAs3D(shape);
        let program;
        let width = texShape[1], height = texShape[0];
        const isByteArray = values2 instanceof Uint8Array || values2 instanceof Uint8ClampedArray;
        if (isPacked) {
          [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);
        } else {
          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);
        }
        const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);
        if (isByteArray) {
          this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.PIXELS;
        } else {
          this.texData.get(tempDenseInputHandle.dataId).usage = TextureUsage.UPLOAD;
        }
        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values2);
        const customValues = [[height, width]];
        const preventEagerUnpacking = true;
        const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);
        const outputTexData = this.texData.get(encodedOutputTarget.dataId);
        texData.texture = outputTexData.texture;
        texData.texShape = outputTexData.texShape;
        texData.isPacked = outputTexData.isPacked;
        texData.usage = outputTexData.usage;
        this.disposeIntermediateTensorInfo(tempDenseInputHandle);
        this.texData.delete(encodedOutputTarget.dataId);
        texData.values = null;
        if (shouldTimeProgram) {
          this.uploadWaitMs += util_exports2.now() - start;
        }
      } else {
        const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
        texData.texture = newTexture;
      }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
      const texData = this.texData.get(dataId);
      const { dtype } = texData;
      this.releaseGPUData(dataId);
      if (float32Values != null) {
        texData.values = float32ToTypedArray(float32Values, dtype);
      }
      return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
      this.numBytesInGPU += this.computeBytes(texShape, dtype);
      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true;
        console.warn(`High memory usage in GPU: ${mb} MB, most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
      return shape[0] * shape[1] * util_exports2.bytesPerElement(dtype);
    }
  };
  MathBackendWebGL.nextDataId = 0;
  function float32ToTypedArray(a, dtype) {
    if (dtype === "float32" || dtype === "complex64") {
      return a;
    } else if (dtype === "int32" || dtype === "bool") {
      const result = dtype === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length);
      for (let i = 0; i < result.length; ++i) {
        result[i] = Math.round(a[i]);
      }
      return result;
    } else {
      throw new Error(`Unknown dtype ${dtype}`);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js
  if (device_util_exports.isBrowser()) {
    registerBackend("webgl", () => new MathBackendWebGL(), 2);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js
  var CHECK_NAN_SNIPPET2 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  var BinaryOpProgram = class {
    constructor(op2, aShape, bShape) {
      this.variableNames = ["A", "B"];
      this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      this.userCode = `
      float binaryOperation(float a, float b) {
        ${op2}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js
  var CHECK_NAN_SNIPPET3 = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
  var BinaryOpPackedProgram = class {
    constructor(op2, aShape, bShape, checkOutOfBounds = false) {
      this.variableNames = ["A", "B"];
      this.supportsBroadcasting = true;
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      const rank = this.outputShape.length;
      this.enableShapeUniforms = useShapeUniforms(rank);
      let checkOutOfBoundsString = "";
      if (checkOutOfBounds) {
        if (rank === 0 || util_exports2.sizeFromShape(this.outputShape) === 1) {
          checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
        } else {
          const dtype = getCoordsDataType(rank);
          checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
          if (rank === 1) {
            if (this.enableShapeUniforms) {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            } else {
              checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
            }
          } else {
            const channels = getChannels("coords", rank);
            if (this.enableShapeUniforms) {
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            } else {
              checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
            }
          }
        }
      }
      this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op2}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js
  function identity4(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    backend2.incRef(x.dataId);
    return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
  }
  var identityConfig2 = {
    kernelName: Identity2,
    backendName: "webgl",
    kernelFunc: identity4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js
  function complex3(args) {
    const { inputs, backend: backend2 } = args;
    const { real: real4, imag: imag4 } = inputs;
    const complexInfo = backend2.makeTensorInfo(real4.shape, "complex64");
    const complex4 = backend2.texData.get(complexInfo.dataId);
    const realTensorInfo = identity4({ inputs: { x: real4 }, backend: backend2 });
    const imagTensorInfo = identity4({ inputs: { x: imag4 }, backend: backend2 });
    complex4.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
    return complexInfo;
  }
  var complexConfig2 = {
    kernelName: Complex,
    backendName: "webgl",
    kernelFunc: complex3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js
  var LEAKYRELU = `return (a < 0.) ? b * a : a;`;
  var LEAKYRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function leakyRelu3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { alpha } = attrs;
    const $alpha = backend2.makeTensorInfo([], "float32", util_exports2.createScalarValue(alpha, "float32"));
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) : new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);
    const result = backend2.runWebGLProgram(program, [x, $alpha], "float32");
    backend2.disposeIntermediateTensorInfo($alpha);
    return result;
  }
  var leakyReluConfig2 = {
    kernelName: LeakyRelu,
    backendName: "webgl",
    kernelFunc: leakyRelu3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js
  var PRELU = `return (a < 0.) ? b * a : a;`;
  var PRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;
  function prelu3(args) {
    const { inputs, backend: backend2 } = args;
    const { x, alpha } = inputs;
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) : new BinaryOpProgram(PRELU, x.shape, alpha.shape);
    return backend2.runWebGLProgram(program, [x, alpha], "float32");
  }
  var preluConfig2 = {
    kernelName: Prelu,
    backendName: "webgl",
    kernelFunc: prelu3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js
  var CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
  var CHECK_NAN_SNIPPET_BINARY = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
  var CHECK_NAN_SNIPPET_BINARY_PACKED = `
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;
  function unaryKernelFunc2({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
    return ({ inputs, backend: backend2 }) => {
      const { x } = inputs;
      const webglBackend = backend2;
      const $dtype = dtype || x.dtype;
      if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {
        const xData = webglBackend.texData.get(x.dataId);
        const outValues = cpuKernelImpl(xData.values, $dtype);
        return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK_UNARY_OPERATIONS") && packedOpSnippet != null;
      let program;
      if (shouldUsePackedProgram) {
        program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);
      } else {
        program = new UnaryOpProgram(x.shape, opSnippet);
      }
      return webglBackend.runWebGLProgram(program, [x], $dtype);
    };
  }
  function binaryKernelFunc2({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
    return ({ inputs, backend: backend2 }) => {
      const { a, b } = inputs;
      const webglBackend = backend2;
      if (supportsComplex && a.dtype === "complex64") {
        const aData = webglBackend.texData.get(a.dataId);
        const bData = webglBackend.texData.get(b.dataId);
        const [real4, imag4] = [
          [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
          [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
        ].map((complexParts) => {
          const [aPart, bPart] = complexParts;
          const aHandle = {
            dataId: aPart.dataId,
            dtype: aPart.dtype,
            shape: a.shape
          };
          const bHandle = {
            dataId: bPart.dataId,
            dtype: bPart.dtype,
            shape: b.shape
          };
          const program2 = new BinaryOpProgram(opSnippet, a.shape, b.shape);
          return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
        });
        const complexOutput = complex3({ inputs: { real: real4, imag: imag4 }, backend: webglBackend });
        webglBackend.disposeIntermediateTensorInfo(real4);
        webglBackend.disposeIntermediateTensorInfo(imag4);
        return complexOutput;
      }
      const $dtype = dtype || upcastType(a.dtype, b.dtype);
      if ((a.dtype === "string" || b.dtype === "string" || webglBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {
        const aVals = webglBackend.texData.get(a.dataId).values;
        const bVals = webglBackend.texData.get(b.dataId).values;
        const decodedAVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(aVals) : aVals;
        const decodedBVals = a.dtype === "string" ? backend_util_exports.fromUint8ToStringArray(bVals) : bVals;
        const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
        const out = webglBackend.makeTensorInfo(outShape, $dtype);
        const outData = webglBackend.texData.get(out.dataId);
        outData.values = outValues;
        return out;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
      let program;
      if (shouldUsePackedProgram) {
        program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
      } else {
        program = new BinaryOpProgram(opSnippet, a.shape, b.shape);
      }
      return webglBackend.runWebGLProgram(program, [a, b], $dtype);
    };
  }
  function mapActivationToShaderProgram(activation, packed = false) {
    if (activation === "linear") {
      if (packed) {
        return LINEAR2;
      }
      return LINEAR;
    } else if (activation === "relu") {
      if (packed) {
        return RELU2;
      }
      return RELU;
    } else if (activation === "elu") {
      if (packed) {
        return ELU3;
      }
      return ELU2;
    } else if (activation === "relu6") {
      if (packed) {
        return RELU62;
      }
      return RELU6;
    } else if (activation === "prelu") {
      if (packed) {
        return PRELU_PACKED;
      }
      return PRELU;
    } else if (activation === "leakyrelu") {
      if (packed) {
        return LEAKYRELU_PACKED;
      }
      return LEAKYRELU;
    } else if (activation === "sigmoid") {
      if (packed) {
        return SIGMOID2;
      }
      return SIGMOID;
    }
    throw new Error(`Activation ${activation} has not been implemented for the WebGL backend.`);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js
  var MatMulPackedProgram = class {
    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
      this.variableNames = ["matrixA", "matrixB"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const sharedDim = transposeA ? aShape[1] : aShape[2];
      const sharedDimensionPacked = Math.ceil(sharedDim / 2);
      const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
      const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
      const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
      const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyreluActivation) {
        this.variableNames.push("leakyreluAlpha");
      }
      let batchASnippet = "rc.x";
      let batchBSnippet = "rc.x";
      if (aShape[0] < bShape[0]) {
        batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;
      } else if (bShape[0] < aShape[0]) {
        batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;
      }
      this.userCode = `
      ${activationSnippet}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          int batchA = ${batchASnippet};
          int batchB = ${batchBSnippet};
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js
  var COMPLEX_MULTIPLY = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
  };
  var BinaryOpComplexProgram = class {
    constructor(op2, aShape, bShape) {
      this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
      this.outputShape = backend_util_exports.assertAndGetBroadcastShape(aShape, bShape);
      this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op2}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js
  var MUL = "return a * b;";
  function multiply5(args) {
    const { inputs, backend: backend2 } = args;
    const { a, b } = inputs;
    const dtype = backend_util_exports.upcastType(a.dtype, b.dtype);
    if (a.dtype === "complex64") {
      const aData = backend2.texData.get(a.dataId);
      const bData = backend2.texData.get(b.dataId);
      const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
      const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
      const inputs2 = [
        {
          dataId: aData.complexTensorInfos.real.dataId,
          dtype: aData.complexTensorInfos.real.dtype,
          shape: a.shape
        },
        {
          dataId: aData.complexTensorInfos.imag.dataId,
          dtype: aData.complexTensorInfos.imag.dtype,
          shape: a.shape
        },
        {
          dataId: bData.complexTensorInfos.real.dataId,
          dtype: bData.complexTensorInfos.real.dtype,
          shape: b.shape
        },
        {
          dataId: bData.complexTensorInfos.imag.dataId,
          dtype: bData.complexTensorInfos.imag.dtype,
          shape: b.shape
        }
      ];
      const realPart = backend2.runWebGLProgram(realProgram, inputs2, "float32");
      const imagPart = backend2.runWebGLProgram(imagProgram, inputs2, "float32");
      const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(imagPart);
      return complexOutput;
    }
    if (backend2.shouldExecuteOnCPU([a, b])) {
      const aData = backend2.texData.get(a.dataId);
      const bData = backend2.texData.get(b.dataId);
      const [outValues, outShape] = multiplyImplCPU(a.shape, b.shape, aData.values, bData.values, dtype);
      const out = backend2.makeTensorInfo(outShape, dtype);
      const outData = backend2.texData.get(out.dataId);
      outData.values = outValues;
      return out;
    }
    let program;
    if (env().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
      program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);
    } else {
      program = new BinaryOpProgram(MUL, a.shape, b.shape);
    }
    return backend2.runWebGLProgram(program, [a, b], dtype);
  }
  var multiplyConfig2 = {
    kernelName: Multiply,
    backendName: "webgl",
    kernelFunc: multiply5
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js
  function packedReshape(input2, afterShape, backend2) {
    const input3DShape = [
      getBatchDim(input2.shape),
      ...getRowsCols(input2.shape)
    ];
    const input3D = {
      dtype: input2.dtype,
      shape: input3DShape,
      dataId: input2.dataId
    };
    const afterShapeAs3D = [
      getBatchDim(afterShape),
      ...getRowsCols(afterShape)
    ];
    const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
    const preventEagerUnpackingOfOutput = true;
    const customValues = [input3DShape];
    const output = backend2.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
    return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js
  function reshape3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { shape } = attrs;
    const webglBackend = backend2;
    const xSize = util_exports2.sizeFromShape(x.shape);
    const $shape = util_exports2.inferFromImplicitShape(shape, xSize);
    const $xSize = util_exports2.sizeFromShape($shape);
    util_exports2.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old shape (${x.shape}) has ${xSize} elements. The new shape and old shape must have the same number of elements.`);
    const xTexData = webglBackend.texData.get(x.dataId);
    if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
      return packedReshape(x, $shape, webglBackend);
    }
    webglBackend.incRef(x.dataId);
    return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
  }
  var reshapeConfig2 = {
    kernelName: Reshape,
    backendName: "webgl",
    kernelFunc: reshape3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js
  var MeanProgram = class {
    constructor(reduceInfo, divisor) {
      this.variableNames = ["x"];
      const { windowSize, batchSize, inSize, outSize } = reduceInfo;
      this.outputShape = [batchSize, outSize];
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      let updateSnippet = `sumValue += dot(values, ones);`;
      if (divisor != null) {
        const denominator = 1 / divisor;
        updateSnippet = `sumValue += dot(values * ${util_exports2.isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
      }
      let checkOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
      }
      this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js
  var ReduceProgram = class {
    constructor(reduceInfo, reduceType) {
      this.variableNames = ["x"];
      const { windowSize, batchSize, inSize, outSize } = reduceInfo;
      this.outputShape = [batchSize, outSize];
      let initializationValue = "0.0";
      let compareOp = ``;
      if (reduceType === "prod") {
        initializationValue = "1.0";
      } else if (reduceType === "min") {
        initializationValue = "1.0 / 1e-20";
        compareOp = `min`;
      } else if (reduceType === "max") {
        initializationValue = "-1.0 / 1e-20";
        compareOp = `max`;
      }
      let returnValue = `${reduceType}(${reduceType}(${reduceType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (reduceType === "sum") {
        returnValue = `sumValue`;
      } else if (reduceType === "prod") {
        returnValue = `prodValue`;
      } else if (reduceType === "all") {
        returnValue = `allValue`;
      } else if (reduceType === "any") {
        returnValue = `anyValue`;
      }
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      let updateSnippet = `
      if (${reduceType === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
        if (${reduceType === "min"} || ${reduceType === "max"}) {
          minMaxValue = ${compareOp}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
      let vecType = `vec4`;
      if (reduceType === "all") {
        initializationValue = "1.0";
        updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
        vecType = `bvec4`;
      } else if (reduceType === "any") {
        initializationValue = "0.0";
        updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
        vecType = `bvec4`;
      }
      let checkOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
      }
      this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js
  function getReductionStages(inShape) {
    const stages = [];
    while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
      const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
      const windowSize = backend_util_exports.computeOptimalWindowSize(outSize);
      stages.push({
        inSize: outSize,
        windowSize,
        outSize: Math.ceil(outSize / windowSize)
      });
    }
    return stages;
  }
  function reduce2(x, dtype, reductionType, backend2) {
    const reductionStages = getReductionStages(x.shape);
    let result = x;
    for (let i = 0; i < reductionStages.length; i++) {
      const { inSize, windowSize, outSize } = reductionStages[i];
      let program;
      let previousResult;
      if (reductionType === "mean") {
        program = i === 0 ? new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, inSize) : new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize });
      } else {
        program = new ReduceProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, reductionType);
      }
      previousResult = result;
      result = backend2.runWebGLProgram(program, [result], dtype);
      if (previousResult.dataId !== x.dataId) {
        backend2.disposeIntermediateTensorInfo(previousResult);
      }
    }
    return result;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js
  var TransposeProgram = class {
    constructor(aShape, newDim) {
      this.variableNames = ["A"];
      const outputShape = new Array(aShape.length);
      for (let i = 0; i < outputShape.length; i++) {
        outputShape[i] = aShape[newDim[i]];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const switched = getSwitchedCoords(newDim);
      this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
    }
  };
  function getSwitchedCoords(newDim) {
    const rank = newDim.length;
    if (rank > 6) {
      throw Error(`Transpose for rank ${rank} is not yet supported`);
    }
    const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
    const switchedCoords = new Array(rank);
    for (let i = 0; i < newDim.length; i++) {
      switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js
  var TransposePackedProgram = class {
    constructor(aShape, newDim) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      const outputShape = new Array(aShape.length);
      for (let i = 0; i < outputShape.length; i++) {
        outputShape[i] = aShape[newDim[i]];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      if (this.rank > 6) {
        throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
      }
      const dtype = getCoordsDataType(this.rank);
      const outputOrder = getVecChannels("rc", this.rank);
      const switchedOrder = new Array(this.rank);
      for (let i = 0; i < newDim.length; i++) {
        switchedOrder[newDim[i]] = outputOrder[i];
      }
      const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
      const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
      const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
      this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js
  function transposeImpl2(x, perm, backend2) {
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x.shape, perm) : new TransposeProgram(x.shape, perm);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js
  function sumImpl(x, axis, keepDims, backend2) {
    const reductionIndices = axis;
    const xRank = x.shape.length;
    const origAxes = util_exports2.parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    const sumInputIsTransposed = permutedAxes != null;
    let sumInput = x;
    if (sumInputIsTransposed) {
      sumInput = transposeImpl2(x, permutedAxes, backend2);
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
    const [sumOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(sumInput.shape, axes);
    let outShape = sumOutShape;
    if (keepDims) {
      outShape = backend_util_exports.expandShapeToKeepDim(sumOutShape, origAxes);
    }
    const inSize = util_exports2.sizeFromShape(reduceShape);
    const xSize = util_exports2.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape3({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend: backend2 });
    const outType = sumOutType(x.dtype);
    const reduced = reduce2(reshapedInput, outType, "sum", backend2);
    const out = reshape3({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(reshapedInput);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (sumInputIsTransposed) {
      backend2.disposeIntermediateTensorInfo(sumInput);
    }
    return out;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js
  function sum4(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    return sumImpl(x, axis, keepDims, backend2);
  }
  var sumConfig2 = {
    kernelName: Sum,
    backendName: "webgl",
    kernelFunc: sum4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js
  function transpose4(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { perm } = attrs;
    const webglBackend = backend2;
    const xRank = x.shape.length;
    const newShape = new Array(xRank);
    for (let i = 0; i < newShape.length; i++) {
      newShape[i] = x.shape[perm[i]];
    }
    let out;
    if (webglBackend.shouldExecuteOnCPU([x])) {
      const xTexData = webglBackend.texData.get(x.dataId);
      const values2 = xTexData.values;
      const outValues = transposeImplCPU(values2, x.shape, x.dtype, perm, newShape);
      out = webglBackend.makeTensorInfo(newShape, x.dtype);
      const outData = webglBackend.texData.get(out.dataId);
      outData.values = outValues;
    } else {
      out = transposeImpl2(x, perm, webglBackend);
    }
    return out;
  }
  var transposeConfig2 = {
    kernelName: Transpose,
    backendName: "webgl",
    kernelFunc: transpose4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js
  var MATMUL_SHARED_DIM_THRESHOLD = 1e3;
  function batchMatMulImpl({ a, b, transposeA, transposeB, backend: backend2, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const aRank = a.shape.length;
    const bRank = b.shape.length;
    const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
    const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
    const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
    const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
    const outerDimsA = a.shape.slice(0, -2);
    const outerDimsB = b.shape.slice(0, -2);
    const batchDimA = util_exports2.sizeFromShape(outerDimsA);
    const batchDimB = util_exports2.sizeFromShape(outerDimsB);
    const batchDimsCompatible = batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;
    util_exports2.assert(aRank >= 2 && bRank >= 2 && batchDimsCompatible, () => `Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);
    const outShapeOuterDims = batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);
    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
    util_exports2.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
    const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
    const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
    const a3d = reshape3({ inputs: { x: a }, backend: backend2, attrs: { shape: a3dShape } });
    const b3d = reshape3({ inputs: { x: b }, backend: backend2, attrs: { shape: b3dShape } });
    const intermediates = [a3d, b3d];
    const batchDim = Math.max(batchDimA, batchDimB);
    const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    const fusedActivation = activation != null ? mapActivationToShaderProgram(activation, true) : null;
    const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
    let out;
    if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
      let aVec = a3d;
      let bVec = b3d;
      if (transposeA) {
        aVec = transpose4({ inputs: { x: a3d }, backend: backend2, attrs: { perm: [0, 2, 1] } });
        intermediates.push(aVec);
      }
      if (transposeB) {
        bVec = transpose4({ inputs: { x: b3d }, backend: backend2, attrs: { perm: [0, 2, 1] } });
        intermediates.push(bVec);
      }
      const shouldReshapeA = outerShapeB !== 1;
      const shouldReshapeB = outerShapeB === 1;
      let aVec3d = aVec;
      if (shouldReshapeA) {
        aVec3d = reshape3({
          inputs: { x: aVec },
          backend: backend2,
          attrs: { shape: [batchDim, sharedDim, 1] }
        });
        intermediates.push(aVec3d);
      }
      const axis = outerShapeB === 1 ? 2 : 1;
      let bVec3d = bVec;
      if (shouldReshapeB) {
        bVec3d = reshape3({
          inputs: { x: bVec },
          backend: backend2,
          attrs: { shape: [batchDim, 1, sharedDim] }
        });
        intermediates.push(bVec3d);
      }
      const product = multiply5({ inputs: { a: aVec3d, b: bVec3d }, backend: backend2 });
      out = sum4({ inputs: { x: product }, backend: backend2, attrs: { axis, keepDims: true } });
      intermediates.push(product);
    } else {
      const dtype = upcastType(a.dtype, b.dtype);
      const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs = [a3d, b3d];
      if (bias != null) {
        inputs.push(bias);
      }
      if (hasPreluActivationWeights) {
        inputs.push(preluActivationWeights);
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", util_exports2.createScalarValue(leakyreluAlpha, "float32"));
        inputs.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      out = backend2.runWebGLProgram(program, inputs, dtype);
    }
    const outReshaped = reshape3({ inputs: { x: out }, backend: backend2, attrs: { shape: outShape } });
    intermediates.push(out);
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return outReshaped;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js
  function _fusedMatMul2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { a, b, bias, preluActivationWeights } = inputs;
    const { transposeA, transposeB, activation, leakyreluAlpha } = attrs;
    return batchMatMulImpl({
      a,
      b,
      transposeA,
      transposeB,
      backend: backend2,
      bias,
      preluActivationWeights,
      leakyreluAlpha,
      activation
    });
  }
  var _fusedMatMulConfig2 = {
    kernelName: _FusedMatMul,
    backendName: "webgl",
    kernelFunc: _fusedMatMul2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js
  var ABS2 = `return abs(x);`;
  function abs3(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (backend2.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
      const xData = backend2.texData.get(x.dataId);
      const outValues = simpleAbsImplCPU(xData.values);
      return backend2.makeTensorInfo(x.shape, x.dtype, outValues);
    }
    let program;
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      program = new UnaryOpPackedProgram(x.shape, ABS2);
    } else {
      program = new UnaryOpProgram(x.shape, ABS2);
    }
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  var absConfig2 = {
    kernelName: Abs,
    backendName: "webgl",
    kernelFunc: abs3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js
  var ACOS = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
  var acos3 = unaryKernelFunc2({ opSnippet: ACOS });
  var acosConfig2 = {
    kernelName: Acos,
    backendName: "webgl",
    kernelFunc: acos3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js
  var ACOSH = CHECK_NAN_SNIPPET + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
  var acosh3 = unaryKernelFunc2({ opSnippet: ACOSH });
  var acoshConfig2 = {
    kernelName: Acosh,
    backendName: "webgl",
    kernelFunc: acosh3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js
  var ADD = "return a + b;";
  var addKernelFunc = binaryKernelFunc2({
    opSnippet: ADD,
    packedOpSnippet: ADD,
    supportsComplex: true,
    cpuKernelImpl: addImplCPU
  });
  var addConfig2 = {
    kernelName: Add,
    backendName: "webgl",
    kernelFunc: addKernelFunc
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js
  var AddNProgram = class {
    constructor(outputShape, shapes) {
      this.outputShape = [];
      this.outputShape = outputShape;
      this.variableNames = shapes.map((_6, i) => `T${i}`);
      const snippets = [];
      this.variableNames.forEach((variable2) => {
        snippets.push(`float v${variable2} = get${variable2}AtOutCoords();`);
      });
      const operation = this.variableNames.map((variable2) => {
        return `v${variable2}`;
      }).join(" + ");
      this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        float result = ${operation};
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js
  var AddNPackedProgram = class {
    constructor(outputShape, shapes) {
      this.outputShape = [];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = outputShape;
      this.variableNames = shapes.map((_6, i) => `T${i}`);
      const snippets = [];
      this.variableNames.forEach((variable2) => {
        snippets.push(`vec4 v${variable2} = get${variable2}AtOutCoords();`);
      });
      const operation = this.variableNames.map((variable2) => {
        return `v${variable2}`;
      }).join(" + ");
      this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        vec4 result = ${operation};
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js
  function addN2(args) {
    const { inputs, backend: backend2 } = args;
    const tensors = inputs;
    if (tensors.length === 1) {
      return identity4({ inputs: { x: tensors[0] }, backend: backend2 });
    }
    if (tensors.length > env().get("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      const midIndex = Math.floor(tensors.length / 2);
      const leftSide = addN2({ inputs: tensors.slice(0, midIndex), backend: backend2 });
      const rightSide = addN2({ inputs: tensors.slice(midIndex), backend: backend2 });
      return addN2({ inputs: [leftSide, rightSide], backend: backend2 });
    }
    const dtype = tensors.map((t) => t.dtype).reduce((d1, d2) => upcastType(d1, d2));
    const shapes = tensors.map((t) => t.shape);
    const usePackedOp = env().getBool("WEBGL_PACK");
    const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
    return backend2.runWebGLProgram(program, tensors, dtype);
  }
  var addNConfig2 = {
    kernelName: AddN,
    backendName: "webgl",
    kernelFunc: addN2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js
  function all3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("all", axes, xRank);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports2.sizeFromShape(reduceShape);
    const a2D = reshape3({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    const reduced = reduce2(a2D, a2D.dtype, "all", backend2);
    let res;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: newShape } });
    } else {
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
    }
    backend2.disposeIntermediateTensorInfo(a2D);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  var allConfig2 = {
    kernelName: All,
    backendName: "webgl",
    kernelFunc: all3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js
  function any3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("any", axes, xRank);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports2.sizeFromShape(reduceShape);
    const a2D = reshape3({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    const reduced = reduce2(a2D, a2D.dtype, "any", backend2);
    let res;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: newShape } });
    } else {
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
    }
    backend2.disposeIntermediateTensorInfo(a2D);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  var anyConfig2 = {
    kernelName: Any,
    backendName: "webgl",
    kernelFunc: any3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js
  var ArgMinMaxProgram = class {
    constructor(reduceInfo, op2, firstPass) {
      this.variableNames = ["A"];
      const { windowSize, batchSize, outSize } = reduceInfo;
      if (!firstPass) {
        this.variableNames.push("bestIndicesA");
      }
      this.outputShape = [batchSize, outSize];
      const compOp = op2 === "max" ? ">" : "<";
      const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js
  var ArgMinMaxPackedProgram = class {
    constructor(shape, windowSize, op2, firstPass) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      util_exports2.assert(shape.length > 2, () => `Packed arg${op2.charAt(0).toUpperCase() + op2.slice(1)} supports only inputs with rank above 2.`);
      const inSize = shape[shape.length - 1];
      const outSize = Math.ceil(inSize / windowSize);
      this.outputShape = shape.slice(0, -1);
      if (outSize > 1) {
        this.outputShape.push(outSize);
      }
      if (!firstPass) {
        this.variableNames.push("bestIndicesA");
      }
      const outShape = this.outputShape;
      const rank = outShape.length;
      const dtype = getCoordsDataType(rank);
      const coords2 = getChannels("coords", rank);
      let sourceLocSetup;
      let sourceRank;
      if (outSize === 1) {
        sourceRank = rank + 1;
        const sourceLocDType = getCoordsDataType(sourceRank);
        sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords2.join()}, 0);
        ++${coords2[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords2.join()}, 0);
        --${coords2[rank - 2]};`;
      } else {
        sourceRank = rank;
        sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords2[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords2[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords2[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords2[rank - 2]};`;
      }
      const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
      const inChannel = "." + channels[sourceRank - 1];
      const intChannels = channels.map((x) => "int " + x);
      const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
      const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
      const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
      const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
      const compOp = op2 === "max" ? "greaterThan" : "lessThan";
      const fetchCandidateIdx = firstPass ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
      const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
      const getBestIndicesAChannelSnippet = firstPass ? "" : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
      this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords2[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords2[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js
  function argReduce(backend2, x, reduceType, bestIndicesA = null) {
    let batchSize = x.shape[0];
    let inSize = x.shape[1];
    if (bestIndicesA != null) {
      batchSize = bestIndicesA.shape[0];
      inSize = bestIndicesA.shape[1];
    }
    const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
    const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
    const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
    const inputs = [x];
    if (bestIndicesA != null) {
      inputs.push(bestIndicesA);
    }
    const output = backend2.runWebGLProgram(program, inputs, "int32");
    if (output.shape[1] === 1) {
      return output;
    }
    const result = argReduce(backend2, x, reduceType, output);
    backend2.disposeIntermediateTensorInfo(output);
    return result;
  }
  function argReducePacked(backend2, x, reduceType, bestIndicesA = null) {
    const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
    const inSize = inShape[inShape.length - 1];
    const windowSize = backend_util_exports.computeOptimalWindowSize(inSize);
    const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
    const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];
    const output = backend2.runWebGLProgram(program, inputs, "int32");
    if (output.shape.length === x.shape.length) {
      const result = argReducePacked(backend2, x, reduceType, output);
      backend2.disposeIntermediateTensorInfo(output);
      return result;
    }
    return output;
  }
  function argMinMaxReduce(backend2, x, axis, reduceType) {
    const axes = [axis];
    backend_util_exports.assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);
    if (!env().getBool("WEBGL_PACK_REDUCE") || x.shape.length <= 2) {
      const intermediateTensorInfos = [];
      const xtexData = backend2.texData.get(x.dataId);
      const xIsPacked = xtexData !== null && xtexData.isPacked;
      let xUnPacked = x;
      if (xIsPacked) {
        xUnPacked = backend2.unpackTensor(x);
        intermediateTensorInfos.push(xUnPacked);
      }
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(xUnPacked.shape, axes);
      const inSize = util_exports2.sizeFromShape(reduceShape);
      const a2D = reshape3({ inputs: { x: xUnPacked }, backend: backend2, attrs: { shape: [-1, inSize] } });
      intermediateTensorInfos.push(a2D);
      const reduced = argReduce(backend2, a2D, reduceType);
      intermediateTensorInfos.push(reduced);
      const reshaped = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
      intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
      return reshaped;
    }
    return argReducePacked(backend2, x, reduceType);
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js
  function argMax3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    let axes = util_exports2.parseAxisParam(axis, x.shape);
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
    const out = argMinMaxReduce(backend2, $x, axes[0], "max");
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return out;
  }
  var argMaxConfig2 = {
    kernelName: ArgMax,
    backendName: "webgl",
    kernelFunc: argMax3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js
  function argMin3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis } = attrs;
    let axes = util_exports2.parseAxisParam(axis, x.shape);
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, x.shape.length);
    let $x = x;
    const intermediateTensorInfos = [];
    if (permutedAxes != null) {
      $x = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      intermediateTensorInfos.push($x);
      axes = backend_util_exports.getInnerMostAxes(axes.length, $x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
    const out = argMinMaxReduce(backend2, $x, axes[0], "min");
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return out;
  }
  var argMinConfig2 = {
    kernelName: ArgMin,
    backendName: "webgl",
    kernelFunc: argMin3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js
  var ASIN = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
  var asin3 = unaryKernelFunc2({ opSnippet: ASIN });
  var asinConfig2 = {
    kernelName: Asin,
    backendName: "webgl",
    kernelFunc: asin3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js
  var ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;
  var asinh3 = unaryKernelFunc2({ opSnippet: ASINH });
  var asinhConfig2 = {
    kernelName: Asinh,
    backendName: "webgl",
    kernelFunc: asinh3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js
  var ATAN = CHECK_NAN_SNIPPET + `
  return atan(x);
`;
  var atan4 = unaryKernelFunc2({ opSnippet: ATAN });
  var atanConfig2 = {
    kernelName: Atan,
    backendName: "webgl",
    kernelFunc: atan4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js
  var ATAN2 = CHECK_NAN_SNIPPET_BINARY + `
  return atan(a, b);
`;
  var ATAN2_PACKED = `
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET_BINARY_PACKED + `
  return result;
`;
  var atan24 = binaryKernelFunc2({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
  var atan2Config2 = {
    kernelName: Atan2,
    backendName: "webgl",
    kernelFunc: atan24
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js
  var ATANH = CHECK_NAN_SNIPPET + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
  var atanh3 = unaryKernelFunc2({ opSnippet: ATANH });
  var atanhConfig2 = {
    kernelName: Atanh,
    backendName: "webgl",
    kernelFunc: atanh3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js
  var Pool2DProgram = class {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
      this.variableNames = ["x"];
      if (poolType === "avg" && computePositions) {
        throw new Error("Cannot compute positions for average pool.");
      }
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.outputShape = convInfo.outShape;
      const isAvgPool = poolType === "avg";
      const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
      const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
      let initializationValue = "0.0";
      if (!isAvgPool) {
        initializationValue = "-1.0 / 1e-20";
      }
      if (computePositions) {
        const compareOp2 = ">=";
        this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const compareOp = "max";
      let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (poolType === "avg") {
        returnValue = `avgValue / count`;
      }
      const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
      const filterWidthVec4Remainder = filterWidth % 4;
      const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
    }
  };
  var Pool3DProgram = class {
    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
      this.variableNames = ["x"];
      if (poolType === "avg" && computePositions) {
        throw new Error("Cannot compute positions for average pool.");
      }
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.outputShape = convInfo.outShape;
      const isAvgPool = poolType === "avg";
      let initializationValue = "0.0";
      if (!isAvgPool) {
        initializationValue = "-1.0 / 1e-20";
      }
      if (computePositions) {
        const compareOp2 = ">=";
        this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
        return;
      }
      const compareOp = "max";
      let returnValue = `${poolType}(${poolType}(${poolType}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
      if (poolType === "avg") {
        returnValue = `avgValue / count`;
      }
      const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
      const filterWidthVec4Remainder = filterWidth % 4;
      const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
      this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
          setOutput(${returnValue});
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js
  function avgPool3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    assertNotComplex2(x, "avgPool");
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const dilations = 1;
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports2.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity4({ inputs: { x }, backend: backend2 });
    }
    const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
    return backend2.runWebGLProgram(avgPoolProgram, [x], "float32");
  }
  var avgPoolConfig2 = {
    kernelName: AvgPool,
    backendName: "webgl",
    kernelFunc: avgPool3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js
  function avgPool3D2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad: pad3, dimRoundingMode, dataFormat } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode, dataFormat);
    const avgPoolProgram = new Pool3DProgram(convInfo, "avg", false);
    return backend2.runWebGLProgram(avgPoolProgram, [x], "float32");
  }
  var avgPool3DConfig2 = {
    kernelName: AvgPool3D,
    backendName: "webgl",
    kernelFunc: avgPool3D2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js
  var AvgPool2DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const avgMultiplier = 1 / (filterHeight * filterWidth);
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var AvgPool3DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy"];
      this.outputShape = convInfo.inShape;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js
  function avgPool3DGrad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x = input2;
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
    const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
    return backend2.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
  }
  var avgPoolGrad3DConfig = {
    kernelName: AvgPool3DGrad,
    backendName: "webgl",
    kernelFunc: avgPool3DGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js
  function avgPoolGrad3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x = input2;
    assertNotComplex2([dy, input2], "avgPoolGrad");
    const { filterSize, strides, pad: pad3 } = attrs;
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad3);
    const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
    return backend2.runWebGLProgram(avgPoolBackpropProgram, [dy], x.dtype);
  }
  var avgPoolGradConfig3 = {
    kernelName: AvgPoolGrad,
    backendName: "webgl",
    kernelFunc: avgPoolGrad3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js
  function batchMatMul2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { a, b } = inputs;
    const { transposeA, transposeB } = attrs;
    return batchMatMulImpl({ a, b, transposeA, transposeB, backend: backend2 });
  }
  var batchMatMulConfig2 = {
    kernelName: BatchMatMul,
    backendName: "webgl",
    kernelFunc: batchMatMul2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js
  var BatchNormProgram = class {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
      this.outputShape = [];
      this.variableNames = ["x", "mean", "variance"];
      backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
      backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
      let offsetSnippet = "0.0";
      if (offsetShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
        this.variableNames.push("offset");
        offsetSnippet = "getOffsetAtOutCoords()";
      }
      let scaleSnippet = "1.0";
      if (scaleShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
        this.variableNames.push("scale");
        scaleSnippet = "getScaleAtOutCoords()";
      }
      this.outputShape = xShape;
      this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js
  var BatchNormPackedProgram = class {
    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
      this.packedInputs = true;
      this.packedOutput = true;
      this.variableNames = ["x", "mean", "variance"];
      backend_util_exports.assertAndGetBroadcastShape(xShape, meanShape);
      backend_util_exports.assertAndGetBroadcastShape(xShape, varianceShape);
      let offsetSnippet = "vec4(0.0)";
      if (offsetShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, offsetShape);
        this.variableNames.push("offset");
        offsetSnippet = "getOffsetAtOutCoords()";
      }
      let scaleSnippet = "vec4(1.0)";
      if (scaleShape != null) {
        backend_util_exports.assertAndGetBroadcastShape(xShape, scaleShape);
        this.variableNames.push("scale");
        scaleSnippet = "getScaleAtOutCoords()";
      }
      this.outputShape = xShape;
      this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js
  var batchNorm3 = ({ inputs, backend: backend2, attrs }) => {
    const { x, mean: mean3, variance, offset, scale: scale5 } = inputs;
    util_exports2.assert(mean3.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
    util_exports2.assert(offset == null || mean3.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
    util_exports2.assert(scale5 == null || mean3.shape.length === scale5.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
    let { varianceEpsilon } = attrs;
    if (varianceEpsilon == null) {
      varianceEpsilon = 1e-3;
    }
    const finalInputs = [x, mean3, variance];
    let offsetShape = null;
    if (offset != null) {
      offsetShape = offset.shape;
      finalInputs.push(offset);
    }
    let scaleShape = null;
    if (scale5 != null) {
      scaleShape = scale5.shape;
      finalInputs.push(scale5);
    }
    const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x.shape, mean3.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x.shape, mean3.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
    const output = backend2.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
    return output;
  };
  var batchNormConfig2 = {
    kernelName: FusedBatchNorm,
    backendName: "webgl",
    kernelFunc: batchNorm3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js
  var SliceProgram = class {
    constructor(destSize) {
      this.variableNames = ["source"];
      this.outputShape = destSize;
      this.rank = destSize.length;
      const dtype = getCoordsDataType(this.rank);
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      const sourceCoords = getCoords(this.rank);
      let body;
      const coordSum = destSize.map((_6, i) => {
        return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;
      });
      body = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join("\n")}
      `;
      this.userCode = `
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `;
    }
  };
  var coords = ["x", "y", "z", "w", "u", "v"];
  function getCoords(rank) {
    if (rank === 1) {
      return "sourceLoc";
    } else if (rank <= 6) {
      return coords.slice(0, rank).map((x) => "sourceLoc." + x).join(",");
    } else {
      throw Error(`Slicing for rank ${rank} is not yet supported`);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js
  var SlicePackedProgram = class {
    constructor(destSize) {
      this.variableNames = ["source"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = destSize;
      this.rank = destSize.length;
      this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
      const dtype = getCoordsDataType(this.rank);
      const coords2 = getChannels("coords", this.rank);
      const sourceLoc = getChannels("sourceLoc", this.rank);
      const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
      const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
      const upperRow = `
      result.x = ${getChannel};
      if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
      const lowerRow = this.rank === 1 ? "" : `
      --${coords2[this.rank - 1]};
      if (++${coords2[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
      const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_6, i) => `start[${i}]`).join()});` : destSize.map((_6, i) => `${sourceLoc[i]} = ${coords2[i]} + start[${i}];`).join("\n");
      this.userCode = `
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js
  function shallowSlice(x, begin, size3, backend2) {
    const xTexData = backend2.texData.get(x.dataId);
    const t = backend2.makeTensorInfo(size3, x.dtype);
    const newTexData = backend2.texData.get(t.dataId);
    Object.assign(newTexData, xTexData);
    newTexData.refCount = 1;
    newTexData.shape = size3;
    newTexData.dtype = x.dtype;
    let flatOffset = slice_util_exports.computeFlatOffset(begin, util_exports2.computeStrides(x.shape));
    if (xTexData.slice) {
      flatOffset += xTexData.slice.flatOffset;
    }
    newTexData.slice = {
      flatOffset,
      origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
    };
    const refCount = backend2.dataRefCount.get(newTexData.slice.origDataId) || 1;
    backend2.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
    return t;
  }
  function slice3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { begin, size: size3 } = attrs;
    const [$begin, $size] = slice_util_exports.parseSliceParams(x, begin, size3);
    slice_util_exports.assertParamsValid(x, $begin, $size);
    if (util_exports2.sizeFromShape($size) === 0) {
      return backend2.makeTensorInfo($size, x.dtype, []);
    }
    if (backend2.shouldExecuteOnCPU([x]) || x.dtype === "string") {
      const xTexData = backend2.texData.get(x.dataId);
      const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);
      return backend2.makeTensorInfo($size, x.dtype, outValues);
    }
    const { isPacked } = backend2.texData.get(x.dataId);
    const isContinous = slice_util_exports.isSliceContinous(x.shape, $begin, $size);
    if (isPacked || !isContinous) {
      const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram($size) : new SliceProgram($size);
      const customValues = [$begin];
      return backend2.runWebGLProgram(program, [x], x.dtype, customValues);
    }
    backend2.uploadToGPU(x.dataId);
    return shallowSlice(x, $begin, $size, backend2);
  }
  var sliceConfig2 = {
    kernelName: Slice,
    backendName: "webgl",
    kernelFunc: slice3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js
  var batchToSpaceND3 = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockShape, crops } = attrs;
    util_exports2.assert(x.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
    const prod4 = blockShape.reduce((a, b) => a * b);
    const reshaped = backend_util_exports.getReshaped(x.shape, blockShape, prod4);
    const permuted = backend_util_exports.getPermuted(reshaped.length, blockShape.length);
    const reshapedPermuted = backend_util_exports.getReshapedPermuted(x.shape, blockShape, prod4);
    const sliceBeginCoords = backend_util_exports.getSliceBeginCoords(crops, blockShape.length);
    const sliceSize = backend_util_exports.getSliceSize(reshapedPermuted, crops, blockShape.length);
    const toDispose = [];
    const reshapedIntermediate = reshape3({ inputs: { x }, backend: backend2, attrs: { shape: reshaped } });
    const transposedIntermediate = transpose4({ inputs: { x: reshapedIntermediate }, backend: backend2, attrs: { perm: permuted } });
    const reshapedIntermediate2 = reshape3({
      inputs: { x: transposedIntermediate },
      backend: backend2,
      attrs: { shape: reshapedPermuted }
    });
    const sliced = slice3({
      inputs: { x: reshapedIntermediate2 },
      backend: backend2,
      attrs: { begin: sliceBeginCoords, size: sliceSize }
    });
    toDispose.push(reshapedIntermediate);
    toDispose.push(transposedIntermediate);
    toDispose.push(reshapedIntermediate2);
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return sliced;
  };
  var batchToSpaceNDConfig2 = {
    kernelName: BatchToSpaceND,
    backendName: "webgl",
    kernelFunc: batchToSpaceND3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js
  function bincount3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, weights } = inputs;
    const { size: size3 } = attrs;
    const xVals = backend2.readSync(x.dataId);
    const weightsVals = backend2.readSync(weights.dataId);
    const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size3);
    return backend2.makeTensorInfo([size3], weights.dtype, outVals);
  }
  var bincountConfig2 = {
    kernelName: Bincount,
    backendName: "webgl",
    kernelFunc: bincount3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BroadcastArgs.js
  function broadcastArgs2(args) {
    const { inputs, backend: backend2 } = args;
    const { s0, s1 } = inputs;
    const s0Vals = backend2.readSync(s0.dataId);
    const s1Vals = backend2.readSync(s1.dataId);
    const broadcastShape = backend_util_exports.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend2.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
  }
  var broadcastArgsConfig2 = {
    kernelName: BroadcastArgs,
    backendName: "webgl",
    kernelFunc: broadcastArgs2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js
  var NOT_EQUAL = `return float(a != b);`;
  var notEqual3 = binaryKernelFunc2({ opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: "bool" });
  var notEqualConfig2 = {
    kernelName: NotEqual,
    backendName: "webgl",
    kernelFunc: notEqual3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js
  function real3(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    const inputData = backend2.texData.get(input2.dataId);
    return identity4({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend2 });
  }
  var realConfig2 = {
    kernelName: Real,
    backendName: "webgl",
    kernelFunc: real3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js
  var TO_INT = `return float(int(x));`;
  function int(input2, backend2) {
    const program = new UnaryOpProgram(input2.shape, TO_INT);
    const output = backend2.runWebGLProgram(program, [input2], "int32");
    return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js
  function cast4(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { dtype } = attrs;
    if (dtype === "complex64") {
      if (x.dtype === "complex64") {
        return identity4({ inputs: { x }, backend: backend2 });
      }
      const zerosTensor = zeros(x.shape);
      const floatX = cast4({ inputs: { x }, backend: backend2, attrs: { dtype: "float32" } });
      const result = complex3({ inputs: { real: floatX, imag: zerosTensor }, backend: backend2 });
      zerosTensor.dispose();
      backend2.disposeIntermediateTensorInfo(floatX);
      return result;
    }
    if (x.dtype === "complex64") {
      const realPart = real3({ inputs: { input: x }, backend: backend2 });
      const result = cast4({ inputs: { x: realPart }, backend: backend2, attrs: { dtype } });
      backend2.disposeIntermediateTensorInfo(realPart);
      return result;
    }
    if (!util_exports2.hasEncodingLoss(x.dtype, dtype)) {
      const result = identity4({ inputs: { x }, backend: backend2 });
      return { dataId: result.dataId, shape: result.shape, dtype };
    }
    if (dtype === "int32") {
      return int(x, backend2);
    }
    if (dtype === "bool") {
      const zerosTensorInfo = backend2.makeTensorInfo([], "bool", util_exports2.getTypedArrayFromDType("bool", 1));
      const binaryInputs = { a: x, b: zerosTensorInfo };
      const result = notEqual3({ inputs: binaryInputs, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(zerosTensorInfo);
      return result;
    }
    throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
  }
  var castConfig2 = {
    kernelName: Cast,
    backendName: "webgl",
    kernelFunc: cast4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js
  var CEIL = `return ceil(x);`;
  var ceil5 = unaryKernelFunc2({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });
  var ceilConfig2 = {
    kernelName: Ceil,
    backendName: "webgl",
    kernelFunc: ceil5
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js
  var ClipProgram = class {
    constructor(aShape) {
      this.variableNames = ["A"];
      this.customUniforms = [
        { name: "minVal", type: "float" },
        { name: "maxVal", type: "float" }
      ];
      this.outputShape = aShape;
      this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js
  var ClipPackedProgram = class {
    constructor(aShape) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "minVal", type: "float" },
        { name: "maxVal", type: "float" }
      ];
      this.outputShape = aShape;
      this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js
  function clipByValue2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { clipValueMin, clipValueMax } = attrs;
    let program;
    if (env().getBool("WEBGL_PACK_CLIP")) {
      program = new ClipPackedProgram(x.shape);
    } else {
      program = new ClipProgram(x.shape);
    }
    const customValues = [[clipValueMin], [clipValueMax]];
    return backend2.runWebGLProgram(program, [x], x.dtype, customValues);
  }
  var clipByValueConfig = {
    kernelName: ClipByValue,
    backendName: "webgl",
    kernelFunc: clipByValue2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js
  var ComplexAbsProgram = class {
    constructor(shape) {
      this.variableNames = ["real", "imag"];
      this.outputShape = shape;
      this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js
  function makeComplexComponentTensorInfo(complexTensor, complexPart) {
    return {
      dataId: complexPart.dataId,
      dtype: complexPart.dtype,
      shape: complexTensor.shape
    };
  }
  function complexAbs2(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    const xData = backend2.texData.get(x.dataId);
    const program = new ComplexAbsProgram(x.shape);
    const programInputs = [
      makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
      makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag)
    ];
    return backend2.runWebGLProgram(program, programInputs, programInputs[0].dtype);
  }
  var complexAbsConfig2 = {
    kernelName: ComplexAbs,
    backendName: "webgl",
    kernelFunc: complexAbs2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js
  var ConcatProgram = class {
    constructor(shapes) {
      this.outputShape = [];
      this.outputShape = backend_util_exports.computeOutShape(shapes, 1);
      this.variableNames = shapes.map((_6, i) => `T${i}`);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][1];
      for (let i = 1; i < offsets.length; i++) {
        offsets[i] = offsets[i - 1] + shapes[i][1];
      }
      const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
      for (let i = 1; i < offsets.length; i++) {
        const shift = offsets[i - 1];
        snippets.push(`else if (yC < ${offsets[i]}) setOutput(getT${i}(yR, yC-${shift}));`);
      }
      const lastIndex = offsets.length;
      const lastShift = offsets[offsets.length - 1];
      snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join("\n        ")}
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js
  var ConcatPackedProgram = class {
    constructor(shapes, axis) {
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      this.outputShape = backend_util_exports.computeOutShape(shapes, axis);
      const shape = this.outputShape;
      const rank = shape.length;
      const dtype = getCoordsDataType(rank);
      const coords2 = getChannels("coords", rank);
      const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
      this.variableNames = shapes.map((_6, i) => `T${i}`);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][axis];
      for (let i = 1; i < offsets.length; i++) {
        offsets[i] = offsets[i - 1] + shapes[i][axis];
      }
      const channel = channels[axis];
      const lastChannels = channels.slice(-2);
      const allChannels = channels.join();
      let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
      for (let i = 1; i < offsets.length; i++) {
        const shift2 = offsets[i - 1];
        getValueSnippet += `
        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
          return getChannel(
            getT${i}(${shiftedChannels(channels, channel, shift2)}),
            vec2(${shiftedChannels(lastChannels, channel, shift2)}));
        }`;
      }
      const lastIndex = offsets.length;
      const shift = offsets[offsets.length - 1];
      getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
      this.userCode = `
      float getValue(${channels.map((x) => "int " + x)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);

        ${coords2[rank - 1]} = ${coords2[rank - 1]} + 1;
        if (${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords2});
        }

        ${coords2[rank - 2]} = ${coords2[rank - 2]} + 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords2});
        }

        ${coords2[rank - 1]} = ${coords2[rank - 1]} - 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]} &&
            ${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords2});
        }
        setOutput(result);
      }
    `;
    }
  };
  function shiftedChannels(channels, channel, shift) {
    const channelIdx = channels.indexOf(channel);
    const res = channels.map((c, idx) => {
      if (idx === channelIdx) {
        return `${c} - ${shift}`;
      } else {
        return c;
      }
    });
    return res.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js
  function imag3(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    const inputData = backend2.texData.get(input2.dataId);
    return identity4({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend2 });
  }
  var imagConfig2 = {
    kernelName: Imag,
    backendName: "webgl",
    kernelFunc: imag3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js
  function concatImpl2(inputs, axis, backend2) {
    const dtype = inputs[0].dtype;
    if (dtype === "complex64") {
      const reals = inputs.map((t) => real3({ inputs: { input: t }, backend: backend2 }));
      const imags = inputs.map((t) => imag3({ inputs: { input: t }, backend: backend2 }));
      const realConcated = concatImpl2(reals, axis, backend2);
      const imagConcated = concatImpl2(imags, axis, backend2);
      const result2 = complex3({ inputs: { real: realConcated, imag: imagConcated }, backend: backend2 });
      reals.forEach((r) => backend2.disposeIntermediateTensorInfo(r));
      imags.forEach((i) => backend2.disposeIntermediateTensorInfo(i));
      backend2.disposeIntermediateTensorInfo(realConcated);
      backend2.disposeIntermediateTensorInfo(imagConcated);
      return result2;
    }
    let runOnCpu = backend2.shouldExecuteOnCPU(inputs);
    if (dtype === "string") {
      runOnCpu = true;
    }
    if (runOnCpu) {
      const tensors2D2 = inputs.map((t) => {
        const innerSize = util_exports2.sizeFromShape(t.shape.slice(axis));
        const shape = [-1, innerSize];
        return reshape3({ inputs: { x: t }, backend: backend2, attrs: { shape } });
      });
      const inputsValShapes = tensors2D2.map((t) => {
        return { vals: backend2.readSync(t.dataId), shape: t.shape };
      });
      const outShape2 = backend_util_exports.computeOutShape(tensors2D2.map((t) => t.shape), 1);
      const simplyConcat = tensors2D2[0].shape[0] === 1;
      const outVals = concatImplCPU(inputsValShapes, outShape2, dtype, simplyConcat);
      const finalOutShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), axis);
      const outInfo = backend2.makeTensorInfo(finalOutShape, dtype, outVals);
      tensors2D2.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
      return outInfo;
    }
    if (inputs.length > env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
      const midIndex = Math.floor(inputs.length / 2);
      const leftSide = concatImpl2(inputs.slice(0, midIndex), axis, backend2);
      const rightSide = concatImpl2(inputs.slice(midIndex), axis, backend2);
      const result2 = concatImpl2([leftSide, rightSide], axis, backend2);
      backend2.disposeIntermediateTensorInfo(leftSide);
      backend2.disposeIntermediateTensorInfo(rightSide);
      return result2;
    }
    if (env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && inputs[0].shape.length > 1) {
      const program2 = new ConcatPackedProgram(inputs.map((t) => t.shape), axis);
      return backend2.runWebGLProgram(program2, inputs, dtype);
    }
    const { tensors2D, outShape } = computeTensors2D(inputs, axis, backend2);
    const program = new ConcatProgram(tensors2D.map((t) => t.shape));
    const result = backend2.runWebGLProgram(program, tensors2D, dtype);
    tensors2D.forEach((r) => backend2.disposeIntermediateTensorInfo(r));
    const reshapedResult = reshape3({ inputs: { x: result }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  function computeTensors2D(inputs, axis, backend2) {
    const outShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), axis);
    const tensors2D = inputs.map((x) => reshape3({
      inputs: { x },
      attrs: { shape: [-1, util_exports2.sizeFromShape(x.shape.slice(axis))] },
      backend: backend2
    }));
    return { tensors2D, outShape };
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js
  function concat3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { axis } = attrs;
    const $axis = util_exports2.parseAxisParam(axis, inputs[0].shape)[0];
    const outShape = backend_util_exports.computeOutShape(inputs.map((t) => t.shape), $axis);
    if (util_exports2.sizeFromShape(outShape) === 0) {
      return backend2.makeTensorInfo(outShape, inputs[0].dtype, []);
    }
    const $inputs = inputs.filter((t) => util_exports2.sizeFromShape(t.shape) > 0);
    if ($inputs.length === 1) {
      return identity4({ inputs: { x: $inputs[0] }, backend: backend2 });
    }
    const shapes = $inputs.map((t) => t.shape);
    backend_util_exports.assertParamsConsistent(shapes, $axis);
    return concatImpl2($inputs, $axis, backend2);
  }
  var concatConfig2 = {
    kernelName: Concat,
    backendName: "webgl",
    kernelFunc: concat3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js
  var Conv2DProgram = class {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
      const inputDepthVec4Remainder = convInfo.inChannels % 4;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivationWeights) {
          activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyreluAlpha) {
          activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivationWeights) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyreluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  };
  var Conv3DProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
      const inputDepthVec4Remainder = convInfo.inChannels % 4;
      this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js
  var Im2ColPackedProgram = class {
    constructor(outputShape, convInfo) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "inputShape", type: "ivec3" },
        { name: "pad", type: "ivec2" },
        { name: "stride", type: "ivec2" },
        { name: "dilation", type: "ivec2" },
        { name: "inChannels", type: "int" },
        { name: "itemsPerBlockRow", type: "int" },
        { name: "outWidth", type: "int" }
      ];
      this.outputShape = outputShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const { dataFormat } = convInfo;
      const glsl = getGlslDifferences();
      const isChannelsLast = dataFormat === "channelsLast";
      const rowDim = isChannelsLast ? 0 : 1;
      const colDim = isChannelsLast ? 1 : 2;
      const boundsCheckingSnippet = this.enableShapeUniforms ? "if(blockIndex < outShape[1] && pos < outShape[0]) {" : `if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {`;
      let unrolled = ``;
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          unrolled += `
          blockIndex = rc.y + ${col};
          pos = rc.x + ${row};

          ${boundsCheckingSnippet}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${rowDim}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${colDim}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
        }
      }
      this.userCode = `
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js
  function conv2dByMatMul({ x, filter: filter2, convInfo, backend: backend2, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const xShape = x.shape;
    const xTexData = backend2.texData.get(x.dataId);
    const sharedMatMulDim = convInfo.inChannels;
    const outerShapeX = xShape[0] * xShape[1] * xShape[2];
    const outerShapeFilter = convInfo.outChannels;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const transposeA = false;
    const transposeB = false;
    let out;
    const intermediates = [];
    const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
    const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked && isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 && util_exports2.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
    if (canOptimize) {
      const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
      const xReshaped = {
        dataId: x.dataId,
        shape: [1, targetShape, convInfo.inChannels],
        dtype: x.dtype
      };
      const originalXTexDataShape = xTexData.shape;
      xTexData.shape = xTexData.shape.slice();
      xTexData.shape[xTexData.shape.length - 2]++;
      util_exports2.assert(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
      const filterReshaped = reshape3({
        inputs: { x: filter2 },
        backend: backend2,
        attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
      });
      intermediates.push(filterReshaped);
      const pointwiseConv = batchMatMulImpl({
        a: xReshaped,
        b: filterReshaped,
        backend: backend2,
        transposeA,
        transposeB,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
      const pointwiseConvTexData = backend2.texData.get(pointwiseConv.dataId);
      util_exports2.assert(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
      xTexData.shape = originalXTexDataShape;
      pointwiseConvTexData.shape = convInfo.outShape;
      out = identity4({ inputs: { x: pointwiseConv }, backend: backend2 });
      out.shape = convInfo.outShape;
      intermediates.push(pointwiseConv);
    } else {
      const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] : xShape[0] * xShape[2] * xShape[3];
      const xReshaped = reshape3({
        inputs: { x },
        backend: backend2,
        attrs: { shape: [1, targetShape, convInfo.inChannels] }
      });
      const filterReshaped = reshape3({
        inputs: { x: filter2 },
        backend: backend2,
        attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
      });
      const result = batchMatMulImpl({
        a: xReshaped,
        b: filterReshaped,
        transposeA,
        transposeB,
        backend: backend2,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
      out = reshape3({ inputs: { x: result }, backend: backend2, attrs: { shape: convInfo.outShape } });
      intermediates.push(xReshaped);
      intermediates.push(filterReshaped);
      intermediates.push(result);
    }
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return out;
  }
  function conv2dWithIm2Row({ x, filter: filter2, convInfo, backend: backend2, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation = null }) {
    const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
    const isChannelsLast = dataFormat === "channelsLast";
    const sharedDim = filterWidth * filterHeight * inChannels;
    const numCols = outHeight * outWidth;
    const x2ColShape = [sharedDim, numCols];
    const transposeA = true;
    const transposeB = false;
    const intermediates = [];
    const xSqueezed = reshape3({ inputs: { x }, backend: backend2, attrs: { shape: x.shape.slice(1) } });
    const w2Row = reshape3({
      inputs: { x: filter2 },
      backend: backend2,
      attrs: { shape: [1, sharedDim, util_exports2.sizeFromShape(filter2.shape) / sharedDim] }
    });
    intermediates.push(xSqueezed);
    intermediates.push(w2Row);
    const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
    const customValues = [
      xSqueezed.shape,
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inChannels],
      [convInfo.filterWidth * convInfo.inChannels],
      [convInfo.outWidth]
    ];
    const im2Col = backend2.runWebGLProgram(im2ColProgram, [xSqueezed], "float32", customValues);
    const im2ColReshaped = reshape3({
      inputs: { x: im2Col },
      backend: backend2,
      attrs: { shape: [1, x2ColShape[0], x2ColShape[1]] }
    });
    intermediates.push(im2Col);
    intermediates.push(im2ColReshaped);
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    const fusedActivation = activation ? mapActivationToShaderProgram(activation, true) : null;
    const matmulProgram = new MatMulPackedProgram(im2ColReshaped.shape, w2Row.shape, [1, numCols, convInfo.outChannels], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [im2ColReshaped, w2Row];
    if (bias) {
      inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", util_exports2.createScalarValue(leakyreluAlpha, "float32"));
      inputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    const product = backend2.runWebGLProgram(matmulProgram, inputs, "float32");
    const outShape = isChannelsLast ? [1, outHeight, outWidth, convInfo.outChannels] : [1, convInfo.outChannels, outHeight, outWidth];
    const out = reshape3({ inputs: { x: product }, backend: backend2, attrs: { shape: outShape } });
    intermediates.push(product);
    for (const i of intermediates) {
      backend2.disposeIntermediateTensorInfo(i);
    }
    return out;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js
  function conv2d3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter2.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
    let out;
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
      out = conv2dByMatMul({ x, filter: filter2, convInfo, backend: backend2 });
    } else if (env().getBool("WEBGL_CONV_IM2COL") && x.shape[0] === 1) {
      out = conv2dWithIm2Row({ x, filter: filter2, convInfo, backend: backend2 });
    } else {
      const program = new Conv2DProgram(convInfo);
      out = backend2.runWebGLProgram(program, [x, filter2], "float32");
    }
    const outReshaped = reshape3({ inputs: { x: out }, backend: backend2, attrs: { shape: convInfo.outShape } });
    backend2.disposeIntermediateTensorInfo(out);
    return outReshaped;
  }
  var conv2DConfig2 = {
    kernelName: Conv2D,
    backendName: "webgl",
    kernelFunc: conv2d3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js
  var Conv2DDerFilterProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              if (${isChannelsLast}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Conv2DDerInputProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const isChannelsLast = convInfo.dataFormat === "channelsLast";
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Conv3DDerFilterProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padFront = convInfo.padInfo.front;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var Conv3DDerInputProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterDepth = convInfo.filterDepth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padFront = filterDepth - 1 - convInfo.padInfo.front;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js
  function conv2DBackpropFilter3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad: pad3, dataFormat, dimRoundingMode, filterShape } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filterShape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
    const program = new Conv2DDerFilterProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, dy], "float32");
  }
  var conv2DBackpropFilterConfig2 = {
    kernelName: Conv2DBackpropFilter,
    backendName: "webgl",
    kernelFunc: conv2DBackpropFilter3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js
  function conv2DBackpropInput3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter: filter2 } = inputs;
    const { inputShape, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter2.shape, strides, 1, pad3, dimRoundingMode, false, $dataFormat);
    const program = new Conv2DDerInputProgram(convInfo);
    return backend2.runWebGLProgram(program, [dy, filter2], "float32");
  }
  var conv2DBackpropInputConfig2 = {
    kernelName: Conv2DBackpropInput,
    backendName: "webgl",
    kernelFunc: conv2DBackpropInput3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js
  function conv3D2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dilations } = attrs;
    const convInfo = backend_util_exports.computeConv3DInfo(x.shape, filter2.shape, strides, dilations, pad3);
    const program = new Conv3DProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, filter2], "float32");
  }
  var conv3DConfig2 = {
    kernelName: Conv3D,
    backendName: "webgl",
    kernelFunc: conv3D2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js
  function conv3DBackpropFilterV22(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, pad: pad3, filterShape } = attrs;
    const convInfo = backend_util_exports.computeConv3DInfo(x.shape, filterShape, strides, 1, pad3);
    const program = new Conv3DDerFilterProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, dy], "float32");
  }
  var conv3DBackpropFilterV2Config2 = {
    kernelName: Conv3DBackpropFilterV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropFilterV22
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js
  function conv3DBackpropInput2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter: filter2 } = inputs;
    const { pad: pad3, strides, inputShape } = attrs;
    const convInfo = backend_util_exports.computeConv3DInfo(inputShape, filter2.shape, strides, 1, pad3);
    const program = new Conv3DDerInputProgram(convInfo);
    return backend2.runWebGLProgram(program, [dy, filter2], "float32");
  }
  var conv3DBackpropInputConfig = {
    kernelName: Conv3DBackpropInputV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropInput2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js
  var COS = CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
  var cos4 = unaryKernelFunc2({ opSnippet: COS });
  var cosConfig2 = {
    kernelName: Cos,
    backendName: "webgl",
    kernelFunc: cos4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js
  var COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`;
  var cosh3 = unaryKernelFunc2({ opSnippet: COSH });
  var coshConfig2 = {
    kernelName: Cosh,
    backendName: "webgl",
    kernelFunc: cosh3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js
  var CropAndResizeProgram = class {
    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
      this.variableNames = ["Image", "Boxes", "BoxInd"];
      this.outputShape = [];
      const [batch, imageHeight, imageWidth, depth] = imageShape;
      const [numBoxes] = boxShape;
      const [cropHeight, cropWidth] = cropSize;
      this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
      const methodId = method === "bilinear" ? 1 : 0;
      const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
      const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
        `${(imageHeight - 1) / (cropHeight - 1)}`,
        "(y2-y1) * height_ratio",
        `y1*${inputHeightFloat} + float(y)*(height_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (y1+y2) * ${inputHeightFloat}`
      ];
      const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
        `${(imageWidth - 1) / (cropWidth - 1)}`,
        "(x2-x1) * width_ratio",
        `x1*${inputWidthFloat} + float(x)*(width_scale)`
      ] : [
        "0.0",
        "0.0",
        `0.5 * (x1+x2) * ${inputWidthFloat}`
      ];
      this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js
  var cropAndResize3 = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { image: image3, boxes, boxInd } = inputs;
    const { cropSize, method, extrapolationValue } = attrs;
    const program = new CropAndResizeProgram(image3.shape, boxes.shape, cropSize, method, extrapolationValue);
    return backend2.runWebGLProgram(program, [image3, boxes, boxInd], "float32");
  };
  var cropAndResizeConfig2 = {
    kernelName: CropAndResize,
    backendName: "webgl",
    kernelFunc: cropAndResize3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/cumsum_gpu.js
  var CumSumProgram = class {
    constructor(shape, exclusive, reverse4) {
      this.variableNames = ["x"];
      this.customUniforms = [{ name: "index", type: "float" }];
      this.outputShape = shape;
      const rank = shape.length;
      const val = exclusive ? "0.0" : `getX(${getCoords2(rank, "coords")})`;
      const length3 = shape[shape.length - 1];
      let condition = "";
      let idxString = "";
      if (exclusive) {
        condition = reverse4 ? `end != ${length3 - 1}` : "end != 0";
        idxString = reverse4 ? "end + 1" : "end - 1";
      } else {
        condition = reverse4 ? `end + pow2 < ${length3}` : "end >= pow2";
        idxString = reverse4 ? "end + pow2" : "end - pow2";
      }
      this.userCode = `
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, "coords")};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, "coords")} = idx;
          val += getX(${getCoords2(rank, "coords")});
        }
        setOutput(val);
      }
    `;
    }
  };
  function getCoords2(rank, name) {
    if (rank === 1) {
      return `${name}`;
    } else if (rank === 2) {
      return `${name}.x, ${name}.y`;
    } else if (rank === 3) {
      return `${name}.x, ${name}.y, ${name}.z`;
    } else if (rank === 4) {
      return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
    } else {
      throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
    }
  }
  function getFinalCoord(rank, name) {
    if (rank === 1) {
      return `${name}`;
    } else if (rank === 2) {
      return `${name}.y`;
    } else if (rank === 3) {
      return `${name}.z`;
    } else if (rank === 4) {
      return `${name}.w`;
    } else {
      throw Error(`Cumulative sum for rank ${rank} is not yet supported`);
    }
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js
  function cumsum3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, exclusive, reverse: reverse4 } = attrs;
    const xRank = x.shape.length;
    const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
    let permutedX = x;
    if (permutation != null) {
      permutedX = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutation } });
    }
    const permutedAxis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
    if (permutedAxis !== xRank - 1) {
      throw new Error(`WebGL cumsum shader expects an inner-most axis=${x.shape.length - 1} but got axis=${axis}`);
    }
    const size3 = permutedX.shape[permutedAxis];
    let result = identity4({ inputs: { x: permutedX }, backend: backend2 });
    for (let i = 0; i <= Math.ceil(Math.log2(size3)) - 1; i++) {
      const program = new CumSumProgram(permutedX.shape, false, reverse4);
      const customValues = [[i]];
      const prevResult = result;
      result = backend2.runWebGLProgram(program, [result], result.dtype, customValues);
      backend2.disposeIntermediateTensorInfo(prevResult);
    }
    if (exclusive) {
      const program = new CumSumProgram(permutedX.shape, exclusive, reverse4);
      const prevResult = result;
      result = backend2.runWebGLProgram(program, [result], result.dtype);
      backend2.disposeIntermediateTensorInfo(prevResult);
    }
    if (permutation != null) {
      const reversePermutation = backend_util_exports.getUndoAxesPermutation(permutation);
      const reverseTransposedResult = transpose4({ inputs: { x: result }, backend: backend2, attrs: { perm: reversePermutation } });
      backend2.disposeIntermediateTensorInfo(result);
      backend2.disposeIntermediateTensorInfo(permutedX);
      return reverseTransposedResult;
    }
    return result;
  }
  var cumsumConfig2 = {
    kernelName: Cumsum,
    backendName: "webgl",
    kernelFunc: cumsum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js
  function denseBincount2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, weights } = inputs;
    const { size: size3, binaryOutput } = attrs;
    if (x.shape.length === 1) {
      const xVals = backend2.readSync(x.dataId);
      const weightsVals = backend2.readSync(weights.dataId);
      const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size3);
      return backend2.makeTensorInfo([size3], weights.dtype, outVals);
    } else if (x.shape.length === 2) {
      const xBuf = backend2.bufferSync(x);
      const weightsBuf = backend2.bufferSync(weights);
      const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size3, binaryOutput);
      return backend2.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
    }
    throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${x.shape.length}.`);
  }
  var denseBincountConfig2 = {
    kernelName: DenseBincount,
    backendName: "webgl",
    kernelFunc: denseBincount2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js
  var DepthToSpaceProgram = class {
    constructor(outputShape, blockSize, dataFormat) {
      this.variableNames = ["x"];
      this.outputShape = [];
      this.outputShape = outputShape;
      this.blockSize = blockSize;
      this.dataFormat = dataFormat;
      this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[1]`;
      } else {
        return `coords[2]`;
      }
    }
    getWidthCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[2]`;
      } else {
        return `coords[3]`;
      }
    }
    getDepthCoordString() {
      if (this.dataFormat === "NHWC") {
        return `coords[3]`;
      } else {
        return `coords[1]`;
      }
    }
    getOutputDepthSize() {
      if (this.dataFormat === "NHWC") {
        return this.outputShape[3];
      } else {
        return this.outputShape[1];
      }
    }
    getInputSamplingString() {
      if (this.dataFormat === "NHWC") {
        return `getX(b, in_h, in_w, in_d)`;
      } else {
        return `getX(b, in_d, in_h, in_w)`;
      }
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js
  function depthToSpace3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockSize, dataFormat } = attrs;
    const batchSize = x.shape[0];
    const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
    const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
    const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
    const outputHeight = inputHeight * blockSize;
    const outputWidth = inputWidth * blockSize;
    const outputDepth = inputDepth / (blockSize * blockSize);
    const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
    const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  var depthToSpaceConfig2 = {
    kernelName: DepthToSpace,
    backendName: "webgl",
    kernelFunc: depthToSpace3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js
  var DepthwiseConv2DProgram = class {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `
          float activation(float x) {
            ${activation}
          }
        `;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js
  var DepthwiseConvPacked2DProgram = class {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
      this.variableNames = ["x", "W"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [
        { name: "pads", type: "ivec2" },
        { name: "strides", type: "ivec2" },
        { name: "dilations", type: "ivec2" },
        { name: "inDims", type: "ivec2" }
      ];
      this.outputShape = convInfo.outShape;
      this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      const padLeft = convInfo.padInfo.left;
      const strideWidth = convInfo.strideWidth;
      const dilationWidth = convInfo.dilationWidth;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const texelsAcross = filterWidth;
      let mainLoop = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
      for (let c = 0; c < filterWidth; c++) {
        mainLoop += `
          vec4 xTexelC${c * 2};
          int xTexelC${c * 2}Ready;
          vec4 xTexelC${c * 2 + 1};
          int xTexelC${c * 2 + 1}Ready;
          vec4 xC${c};`;
      }
      mainLoop += `
    for (int r = 0; r < ${filterHeight}; r++) {
      `;
      for (let c = 0; c < filterWidth; c++) {
        mainLoop += `
          xTexelC${c * 2} = vec4(0.0);
          xTexelC${c * 2}Ready = 0;
          xTexelC${c * 2 + 1} = vec4(0.0);
          xTexelC${c * 2 + 1}Ready = 0;
          xC${c} = vec4(0.0);`;
      }
      mainLoop += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
      for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {
        const colIndex = texelC * 2;
        mainLoop += `
          xC = xCCorner + ${colIndex * dilationWidth};
          `;
        if (strideWidth === 1) {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }
              `;
              if (dilationWidth === 1 && colIndex > 0) {
                mainLoop += `
                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                `;
              } else {
                mainLoop += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                  } else {
                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                  }
                  `;
              }
            } else {
              mainLoop += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xC${colIndex} = xTexelC${colIndex};
                `;
            }
            if (colIndex + 1 < filterWidth) {
              const nextTexelOffset = padLeft % 2 === 0 ? util_exports2.nearestLargerEven(dilationWidth) : dilationWidth;
              if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
                mainLoop += `
                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${colIndex + 1}.zw = vec2(0.0);
                    }
                    xTexelC${colIndex + 1}Ready = 1;
                  }
                  `;
                if (dilationWidth > 1) {
                  mainLoop += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                      xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                      xTexelC${colIndex}Ready = 1;
                    }
                    `;
                }
                mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                  `;
              } else {
                if (nextTexelOffset === 1) {
                  mainLoop += `
                    xC${colIndex + 1} = xTexelC${colIndex};
                    `;
                } else {
                  mainLoop += `
                    xCOffset = xC + ${nextTexelOffset};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${colIndex + 1}.zw = vec2(0.0);
                      }
                      xTexelC${colIndex + 1}Ready = 1;
                    }

                    xC${colIndex + 1} = xTexelC${colIndex + 1};
                    `;
                }
              }
            }
          }
        } else {
          if (colIndex < filterWidth) {
            if (padLeft % 2 === 1) {
              mainLoop += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                `;
              }
            } else {
              mainLoop += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(
                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
              `;
              if (colIndex + 1 < filterWidth) {
                mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                `;
              }
            }
          }
        }
        if (colIndex < filterWidth) {
          mainLoop += `
            wTexel = getW(r, ${colIndex}, d1, q);
            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
          `;
          if (colIndex + 1 < filterWidth) {
            mainLoop += `
              wTexel = getW(r, ${colIndex + 1}, d1, q);
              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
          }
        }
      }
      mainLoop += `
    }
  `;
      mainLoop += `
      }
    `;
      let activationSnippet = "", applyActivationSnippet = "";
      if (activation) {
        if (hasPreluActivation) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation}
        }`;
        } else if (hasLeakyReluAlpha) {
          activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation}
        }`;
        } else {
          activationSnippet = `vec4 activation(vec4 x) {
          ${activation}
        }`;
        }
        applyActivationSnippet = `result = activation(result);`;
      }
      const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivation) {
        this.variableNames.push("preluActivationWeights");
      }
      if (hasLeakyReluAlpha) {
        this.variableNames.push("leakyreluAlpha");
      }
      this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${mainLoop}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js
  function depthwiseConv2dNative2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dilations, dimRoundingMode } = attrs;
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter2.shape, strides, $dilations, pad3, dimRoundingMode, true);
    let program;
    if (env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
      program = new DepthwiseConvPacked2DProgram(convInfo);
    } else {
      program = new DepthwiseConv2DProgram(convInfo);
    }
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    return backend2.runWebGLProgram(program, [x, filter2], "float32", customValues);
  }
  var depthwiseConv2dNativeConfig2 = {
    kernelName: DepthwiseConv2dNative,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNative2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js
  var DepthwiseConv2DDerFilterProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "dy"];
      this.outputShape = convInfo.filterShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = convInfo.padInfo.top;
      const padLeft = convInfo.padInfo.left;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var DepthwiseConv2DDerInputProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "W"];
      this.outputShape = convInfo.inShape;
      const filterHeight = convInfo.filterHeight;
      const filterWidth = convInfo.filterWidth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const padTop = filterHeight - 1 - convInfo.padInfo.top;
      const padLeft = filterWidth - 1 - convInfo.padInfo.left;
      const channelMul = convInfo.outChannels / convInfo.inChannels;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
  function depthwiseConv2dNativeBackpropFilter3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, dy } = inputs;
    const { strides, dilations, pad: pad3, dimRoundingMode, filterShape } = attrs;
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad3, dimRoundingMode, true);
    const program = new DepthwiseConv2DDerFilterProgram(convInfo);
    return backend2.runWebGLProgram(program, [x, dy], "float32");
  }
  var depthwiseConv2dNativeBackpropFilterConfig2 = {
    kernelName: DepthwiseConv2dNativeBackpropFilter,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropFilter3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
  function depthwiseConv2dNativeBackpropInput3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, filter: filter2 } = inputs;
    const { strides, dilations, pad: pad3, dimRoundingMode, inputShape } = attrs;
    const convInfo = backend_util_exports.computeConv2DInfo(inputShape, filter2.shape, strides, dilations, pad3, dimRoundingMode, true);
    const program = new DepthwiseConv2DDerInputProgram(convInfo);
    return backend2.runWebGLProgram(program, [dy, filter2], "float32");
  }
  var depthwiseConv2dNativeBackpropInputConfig2 = {
    kernelName: DepthwiseConv2dNativeBackpropInput,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropInput3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js
  var DiagProgram = class {
    constructor(size3) {
      this.variableNames = ["X"];
      this.outputShape = [size3, size3];
      this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js
  function diag2(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    const outShape = [...x.shape, ...x.shape];
    const xSize = util_exports2.sizeFromShape(x.shape);
    const flat = reshape3({ inputs: { x }, backend: backend2, attrs: { shape: [xSize] } });
    const program = new DiagProgram(xSize);
    const res = backend2.runWebGLProgram(program, [flat], flat.dtype);
    const out = reshape3({ inputs: { x: res }, backend: backend2, attrs: { shape: outShape } });
    backend2.disposeIntermediateTensorInfo(flat);
    backend2.disposeIntermediateTensorInfo(res);
    return out;
  }
  var diagConfig2 = {
    kernelName: Diag,
    backendName: "webgl",
    kernelFunc: diag2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js
  var Dilation2DProgram = class {
    constructor(convInfo) {
      this.variableNames = ["x", "W"];
      this.outputShape = convInfo.outShape;
      const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
      const { top: padTop, left: padLeft } = padInfo;
      this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js
  function dilation2D(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2 } = inputs;
    const { strides, pad: pad3, dilations } = attrs;
    const convInfo = backend_util_exports.computeDilation2DInfo(x.shape, filter2.shape, strides, pad3, "NHWC", dilations);
    let out;
    const program = new Dilation2DProgram(convInfo);
    out = backend2.runWebGLProgram(program, [x, filter2], "float32");
    const outReshaped = reshape3({ inputs: { x: out }, backend: backend2, attrs: { shape: convInfo.outShape } });
    backend2.disposeIntermediateTensorInfo(out);
    return outReshaped;
  }
  var dilation2DConfig = {
    kernelName: Dilation2D,
    backendName: "webgl",
    kernelFunc: dilation2D
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Einsum.js
  function einsum2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { equation } = attrs;
    const tensors = inputs;
    const { allDims, summedDims, idDims } = backend_util_exports.decodeEinsumEquation(equation, tensors.length);
    backend_util_exports.checkEinsumDimSizes(allDims.length, idDims, tensors);
    const { path, steps } = backend_util_exports.getEinsumComputePath(summedDims, idDims);
    const nSteps = steps.length;
    let out = null;
    let numDimsRemaining = allDims.length;
    const tensorsToDispose = [];
    for (let i = 0; i < nSteps; ++i) {
      for (const idTerm of steps[i]) {
        const { permutationIndices: perm, expandDims: dimsToExpand } = backend_util_exports.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
        let x;
        if (backend_util_exports.isIdentityPermutation(perm)) {
          x = tensors[idTerm];
        } else {
          x = transpose4({ inputs: { x: tensors[idTerm] }, backend: backend2, attrs: { perm } });
          tensorsToDispose.push(x);
        }
        const targetShape = x.shape.slice();
        for (let k = 0; k < dimsToExpand.length; ++k) {
          targetShape.splice(dimsToExpand[k], 0, 1);
        }
        if (!util_exports2.arraysEqual(x.shape, targetShape)) {
          x = reshape3({ inputs: { x }, backend: backend2, attrs: { shape: targetShape } });
          tensorsToDispose.push(x);
        }
        if (out === null) {
          out = x;
        } else {
          out = multiply5({ inputs: { a: x, b: out }, backend: backend2 });
          tensorsToDispose.push(out);
        }
      }
      if (i < nSteps - 1) {
        if (path[i] >= 0) {
          out = sum4({
            inputs: { x: out },
            backend: backend2,
            attrs: {
              axis: path[i] - (allDims.length - numDimsRemaining),
              keepDims: false
            }
          });
          tensorsToDispose.push(out);
        }
        numDimsRemaining--;
      }
    }
    for (const tensorInfo of tensorsToDispose) {
      if (tensorInfo === out) {
        continue;
      }
      backend2.disposeIntermediateTensorInfo(tensorInfo);
    }
    return out;
  }
  var einsumConfig2 = {
    kernelName: Einsum,
    backendName: "webgl",
    kernelFunc: einsum2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js
  var ELU4 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;
  var ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;
  var elu4 = unaryKernelFunc2({ opSnippet: ELU4, packedOpSnippet: ELU_PACKED });
  var eluConfig2 = {
    kernelName: Elu,
    backendName: "webgl",
    kernelFunc: elu4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js
  var ELU_DER = `return (b >= 1.0) ? a : a * (b + 1.0);`;
  var ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`;
  var eluGrad2 = (args) => {
    const { inputs, backend: backend2 } = args;
    const { dy, y } = inputs;
    const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER_PACKED, dy.shape, y.shape) : new BinaryOpProgram(ELU_DER, dy.shape, y.shape);
    return backend2.runWebGLProgram(program, [dy, y], dy.dtype);
  };
  var eluGradConfig3 = {
    kernelName: EluGrad,
    backendName: "webgl",
    kernelFunc: eluGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js
  var PACKED_EQUAL = `
  return vec4(equal(a, b));
`;
  var EQUAL = `return float(a == b);`;
  var equal3 = binaryKernelFunc2({
    opSnippet: EQUAL,
    packedOpSnippet: PACKED_EQUAL,
    dtype: "bool",
    cpuKernelImpl: equalImplCPU
  });
  var equalConfig2 = {
    kernelName: Equal,
    backendName: "webgl",
    kernelFunc: equal3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js
  var ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${backend_util_exports.ERF_P};
  float a1 = ${backend_util_exports.ERF_A1};
  float a2 = ${backend_util_exports.ERF_A2};
  float a3 = ${backend_util_exports.ERF_A3};
  float a4 = ${backend_util_exports.ERF_A4};
  float a5 = ${backend_util_exports.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
  var erf3 = unaryKernelFunc2({ opSnippet: ERF });
  var erfConfig2 = {
    kernelName: Erf,
    backendName: "webgl",
    kernelFunc: erf3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js
  var EXP = `return exp(x);`;
  var exp3 = unaryKernelFunc2({
    opSnippet: EXP,
    packedOpSnippet: EXP,
    cpuKernelImpl: expImplCPU,
    dtype: "float32"
  });
  var expConfig2 = {
    kernelName: Exp,
    backendName: "webgl",
    kernelFunc: exp3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js
  function expandDims4(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { dim } = attrs;
    const { input: input2 } = inputs;
    const inputRank = input2.shape.length;
    const newShape = input2.shape.slice();
    let $dim = dim;
    if (dim < 0) {
      util_exports2.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
      $dim = inputRank + dim + 1;
    }
    newShape.splice($dim, 0, 1);
    return reshape3({ inputs: { x: input2 }, backend: backend2, attrs: { shape: newShape } });
  }
  var expandDimsConfig2 = {
    kernelName: ExpandDims,
    backendName: "webgl",
    kernelFunc: expandDims4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js
  var EXPM1 = `return exp(x) - 1.0;`;
  var expm13 = unaryKernelFunc2({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });
  var expm1Config2 = {
    kernelName: Expm1,
    backendName: "webgl",
    kernelFunc: expm13
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js
  var FFTProgram = class {
    constructor(component, inputShape, inverse3) {
      this.variableNames = ["real", "imag"];
      const innerDim = inputShape[1];
      this.outputShape = inputShape;
      const exponentMultiplierSnippet = inverse3 ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
      const resultDenominator = inverse3 ? `${innerDim}.0` : "1.0";
      let opString;
      if (component === "real") {
        opString = "return real * expR - imag * expI;";
      } else if (component === "imag") {
        opString = "return real * expI + imag * expR;";
      } else {
        throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
      }
      this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js
  function fftImpl2(x, inverse3, backend2) {
    const xData = backend2.texData.get(x.dataId);
    const inputSize = util_exports2.sizeFromShape(x.shape);
    const innerDimensionSize = x.shape[x.shape.length - 1];
    const batch = inputSize / innerDimensionSize;
    const input2D = reshape3({ inputs: { x }, backend: backend2, attrs: { shape: [batch, innerDimensionSize] } });
    const xShape = input2D.shape;
    const realProgram = new FFTProgram("real", xShape, inverse3);
    const imagProgram = new FFTProgram("imag", xShape, inverse3);
    const inputs = [
      {
        dataId: xData.complexTensorInfos.real.dataId,
        dtype: xData.complexTensorInfos.real.dtype,
        shape: xShape
      },
      {
        dataId: xData.complexTensorInfos.imag.dataId,
        dtype: xData.complexTensorInfos.imag.dtype,
        shape: xShape
      }
    ];
    const realPart = backend2.runWebGLProgram(realProgram, inputs, "float32");
    const imagPart = backend2.runWebGLProgram(imagProgram, inputs, "float32");
    const complexOutput = complex3({ inputs: { real: realPart, imag: imagPart }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(realPart);
    backend2.disposeIntermediateTensorInfo(imagPart);
    const complexOutputReshaped = reshape3({ inputs: { x: complexOutput }, backend: backend2, attrs: { shape: x.shape } });
    backend2.disposeIntermediateTensorInfo(input2D);
    backend2.disposeIntermediateTensorInfo(complexOutput);
    return complexOutputReshaped;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js
  function fft3(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    return fftImpl2(input2, false, backend2);
  }
  var fftConfig2 = {
    kernelName: FFT,
    backendName: "webgl",
    kernelFunc: fft3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js
  var FillProgram = class {
    constructor(shape, value) {
      this.outputShape = [];
      this.customUniforms = [{ name: "value", type: "float" }];
      this.variableNames = ["x"];
      this.outputShape = shape;
      this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js
  function fill3(args) {
    const { backend: backend2, attrs } = args;
    const { shape, value } = attrs;
    let { dtype } = attrs;
    dtype = dtype || util_exports2.inferDtype(value);
    if (dtype === "string") {
      const values2 = util_exports2.getArrayFromDType(dtype, util_exports2.sizeFromShape(shape));
      values2.fill(value);
      return backend2.makeTensorInfo(shape, dtype, values2);
    } else {
      const program = new FillProgram(shape, value);
      const customValues = [[value]];
      return backend2.runWebGLProgram(program, [], dtype, customValues);
    }
  }
  var fillConfig2 = {
    kernelName: Fill,
    backendName: "webgl",
    kernelFunc: fill3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js
  var FlipLeftRightProgram = class {
    constructor(imageShape) {
      this.variableNames = ["Image"];
      this.outputShape = [];
      const imageWidth = imageShape[2];
      this.outputShape = imageShape;
      this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js
  var flipLeftRightConfig2 = {
    kernelName: FlipLeftRight,
    backendName: "webgl",
    kernelFunc: ({ inputs, backend: backend2 }) => {
      const { image: image3 } = inputs;
      const webglBackend = backend2;
      const program = new FlipLeftRightProgram(image3.shape);
      const output = webglBackend.runWebGLProgram(program, [image3], image3.dtype);
      return output;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js
  var FLOOR = `return floor(x);`;
  var floor5 = unaryKernelFunc2({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });
  var floorConfig2 = {
    kernelName: Floor,
    backendName: "webgl",
    kernelFunc: floor5
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js
  var INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`;
  var INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`;
  var floorDiv3 = binaryKernelFunc2({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: "int32" });
  var floorDivConfig2 = {
    kernelName: FloorDiv,
    backendName: "webgl",
    kernelFunc: floorDiv3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js
  var FromPixelsProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      const glsl = getGlslDifferences();
      const [height, width] = outputShape;
      this.outputShape = outputShape;
      this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js
  var FromPixelsPackedProgram = class {
    constructor(outputShape) {
      this.variableNames = ["A"];
      this.packedInputs = false;
      this.packedOutput = true;
      const glsl = getGlslDifferences();
      const [height, width] = outputShape;
      this.outputShape = outputShape;
      this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js
  var fromPixelsConfig = {
    kernelName: FromPixels,
    backendName: "webgl",
    kernelFunc: fromPixels
  };
  var fromPixels2DContext;
  function fromPixels(args) {
    const { inputs, backend: backend2, attrs } = args;
    let { pixels } = inputs;
    const { numChannels } = attrs;
    const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
    const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
    const [width, height] = isVideo ? [
      pixels.videoWidth,
      pixels.videoHeight
    ] : [pixels.width, pixels.height];
    const texShape = [height, width];
    const outShape = [height, width, numChannels];
    if (isImage || isVideo) {
      if (fromPixels2DContext == null) {
        fromPixels2DContext = document.createElement("canvas").getContext("2d");
      }
      fromPixels2DContext.canvas.width = width;
      fromPixels2DContext.canvas.height = height;
      fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
      pixels = fromPixels2DContext.canvas;
    }
    const tempPixelHandle = backend2.makeTensorInfo(texShape, "int32");
    backend2.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
    backend2.gpgpu.uploadPixelDataToTexture(backend2.getTexture(tempPixelHandle.dataId), pixels);
    const program = env().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
    const res = backend2.runWebGLProgram(program, [tempPixelHandle], "int32");
    backend2.disposeData(tempPixelHandle.dataId);
    return res;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js
  function fusedConv2d(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad3, dataFormat, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    const $dataFormat = backend_util_exports.convertConv2DDataFormat(dataFormat);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter2.shape, strides, dilations, pad3, dimRoundingMode, false, $dataFormat);
    let out;
    const intermediates = [];
    if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
      out = conv2dByMatMul({
        x,
        filter: filter2,
        convInfo,
        backend: backend2,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
    } else if (env().getBool("WEBGL_CONV_IM2COL") && x.shape[0] === 1) {
      out = conv2dWithIm2Row({
        x,
        filter: filter2,
        convInfo,
        backend: backend2,
        bias,
        activation,
        preluActivationWeights,
        leakyreluAlpha
      });
    } else {
      const hasBias = bias != null;
      const hasPreluActivationWeights = preluActivationWeights != null;
      const hasLeakyreluAlpha = activation === "leakyrelu";
      const fusedActivation = activation ? mapActivationToShaderProgram(activation, false) : null;
      const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
      const inputs2 = [x, filter2];
      if (bias) {
        inputs2.push(bias);
      }
      if (preluActivationWeights) {
        inputs2.push(preluActivationWeights);
      }
      if (hasLeakyreluAlpha) {
        const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", util_exports2.createScalarValue(leakyreluAlpha, "float32"));
        inputs2.push($leakyreluAlpha);
        intermediates.push($leakyreluAlpha);
      }
      out = backend2.runWebGLProgram(program, inputs2, "float32");
    }
    const outReshaped = reshape3({ inputs: { x: out }, backend: backend2, attrs: { shape: convInfo.outShape } });
    intermediates.push(out);
    intermediates.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return outReshaped;
  }
  var fusedConv2DConfig2 = {
    kernelName: FusedConv2D,
    backendName: "webgl",
    kernelFunc: fusedConv2d
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js
  function fusedDepthwiseConv2D2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, filter: filter2, bias, preluActivationWeights } = inputs;
    const { strides, pad: pad3, dilations, dimRoundingMode, activation, leakyreluAlpha } = attrs;
    const intermediates = [];
    let $dilations = dilations;
    if ($dilations == null) {
      $dilations = [1, 1];
    }
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, $dilations), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${$dilations}'`);
    const convInfo = backend_util_exports.computeConv2DInfo(x.shape, filter2.shape, strides, $dilations, pad3, dimRoundingMode, true);
    const shouldPackDepthwiseConv = env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
    const fusedActivation = activation ? mapActivationToShaderProgram(activation, shouldPackDepthwiseConv) : null;
    const programInputs = [x, filter2];
    const hasBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    const hasLeakyreluAlpha = activation === "leakyrelu";
    if (hasBias) {
      programInputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      programInputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend2.makeTensorInfo([], "float32", util_exports2.createScalarValue(leakyreluAlpha, "float32"));
      programInputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    let program;
    if (shouldPackDepthwiseConv) {
      program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    } else {
      program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    }
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    const result = backend2.runWebGLProgram(program, programInputs, "float32", customValues);
    intermediates.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  var fusedDepthwiseConv2DConfig2 = {
    kernelName: FusedDepthwiseConv2D,
    backendName: "webgl",
    kernelFunc: fusedDepthwiseConv2D2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js
  var GatherNDProgram = class {
    constructor(sliceDim, strides, shape) {
      this.sliceDim = sliceDim;
      this.strides = strides;
      this.variableNames = ["x", "indices"];
      this.outputShape = shape;
      const stridesType = getCoordsDataType(strides.length);
      const dtype = getCoordsDataType(shape.length);
      const strideString = this.sliceDim > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${stridesType} strides = ${stridesType}(${this.strides});
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${strideString};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js
  function gatherNd2(args) {
    const { inputs, backend: backend2 } = args;
    const { params, indices } = inputs;
    const indicesShape = indices.shape;
    const sliceRank = indicesShape[indicesShape.length - 1];
    const paramsSize = util_exports2.sizeFromShape(params.shape);
    const [resultShape, numSlices, sliceSize, strides] = backend_util_exports.prepareAndValidate(params, indices);
    const flattenIndices = reshape3({ inputs: { x: indices }, backend: backend2, attrs: { shape: [numSlices, sliceRank] } });
    const flattenX = reshape3({
      inputs: { x: params },
      backend: backend2,
      attrs: { shape: [util_exports2.sizeFromShape(params.shape) / sliceSize, sliceSize] }
    });
    if (backend2.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
      const indicesData = backend2.readSync(indices.dataId);
      const paramsBuf = backend2.bufferSync(params);
      const outValue = gatherNdImplCPU(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
      return backend2.makeTensorInfo(resultShape, params.dtype, outValue.values);
    }
    const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize]);
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
    const reshaped = reshape3({ inputs: { x: res }, backend: backend2, attrs: { shape: resultShape } });
    backend2.disposeIntermediateTensorInfo(flattenIndices);
    backend2.disposeIntermediateTensorInfo(flattenX);
    backend2.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  var gatherNdConfig2 = {
    kernelName: GatherNd,
    backendName: "webgl",
    kernelFunc: gatherNd2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js
  var GatherProgram = class {
    constructor(aShape, outputShape) {
      this.variableNames = ["A", "indices"];
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const sourceCoords = getSourceCoords2(aShape, 2);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
  };
  function getSourceCoords2(aShape, axis) {
    const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
    const sourceCoords = [];
    for (let i = 0; i < aShape.length; i++) {
      if (i === 2) {
        sourceCoords.push("int(getIndices(resRC.x, resRC.z))");
      } else {
        sourceCoords.push(`${currentCoords[i]}`);
      }
    }
    return sourceCoords.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js
  function gatherV22(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, indices } = inputs;
    const { axis, batchDims } = attrs;
    const parsedAxis = util_exports2.parseAxisParam(axis, x.shape)[0];
    const indicesVals = backend2.readSync(indices.dataId);
    const axisDim = x.shape[parsedAxis];
    for (let i = 0; i < indicesVals.length; ++i) {
      const index = indicesVals[i];
      util_exports2.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);
    }
    const shapeInfo = backend_util_exports.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
    const indicesSize = util_exports2.sizeFromShape(indices.shape);
    const toDispose = [];
    const flattenX = reshape3({
      inputs: { x },
      backend: backend2,
      attrs: {
        shape: [
          shapeInfo.batchSize,
          shapeInfo.outerSize,
          shapeInfo.dimSize,
          shapeInfo.sliceSize
        ]
      }
    });
    const flattenIndex = reshape3({
      inputs: { x: indices },
      backend: backend2,
      attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
    });
    toDispose.push(flattenX);
    toDispose.push(flattenIndex);
    const flattenOutputShape = [
      shapeInfo.batchSize,
      shapeInfo.outerSize,
      indicesSize / shapeInfo.batchSize,
      shapeInfo.sliceSize
    ];
    if (backend2.shouldExecuteOnCPU([x, indices]) || x.dtype === "string") {
      const indicesBuf = backend2.bufferSync(flattenIndex);
      const xBuf = backend2.bufferSync(flattenX);
      const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);
      toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
      return backend2.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
    }
    const program = new GatherProgram(flattenX.shape, flattenOutputShape);
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
    toDispose.push(res);
    const reshaped = reshape3({ inputs: { x: res }, backend: backend2, attrs: { shape: shapeInfo.outputShape } });
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return reshaped;
  }
  var gatherV2Config2 = {
    kernelName: GatherV2,
    backendName: "webgl",
    kernelFunc: gatherV22
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js
  var GREATER = `return float(a > b);`;
  var GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`;
  var greater3 = binaryKernelFunc2({
    opSnippet: GREATER,
    packedOpSnippet: GREATER_PACKED,
    cpuKernelImpl: greaterImplCPU,
    dtype: "bool"
  });
  var greaterConfig2 = {
    kernelName: Greater,
    backendName: "webgl",
    kernelFunc: greater3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js
  var GREATER_EQUAL = `return float(a >= b);`;
  var GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`;
  var greaterEqual3 = binaryKernelFunc2({
    opSnippet: GREATER_EQUAL,
    packedOpSnippet: GREATER_EQUAL_PACKED,
    dtype: "bool",
    cpuKernelImpl: greaterEqualImplCPU
  });
  var greaterEqualConfig2 = {
    kernelName: GreaterEqual,
    backendName: "webgl",
    kernelFunc: greaterEqual3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js
  function ifft3(args) {
    const { inputs, backend: backend2 } = args;
    const { input: input2 } = inputs;
    return fftImpl2(input2, true, backend2);
  }
  var ifftConfig2 = {
    kernelName: IFFT,
    backendName: "webgl",
    kernelFunc: ifft3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js
  var IS_FINITE = `return float(!isnan(x) && !isinf(x));`;
  var isFinite4 = unaryKernelFunc2({ opSnippet: IS_FINITE, dtype: "bool" });
  var isFiniteConfig2 = {
    kernelName: IsFinite,
    backendName: "webgl",
    kernelFunc: isFinite4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js
  var IS_INF = `return float(isinf(x));`;
  var isInf3 = unaryKernelFunc2({ opSnippet: IS_INF, dtype: "bool" });
  var isInfConfig2 = {
    kernelName: IsInf,
    backendName: "webgl",
    kernelFunc: isInf3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js
  var IS_NAN = `return float(isnan(x));`;
  var isNaN4 = unaryKernelFunc2({ opSnippet: IS_NAN, dtype: "bool" });
  var isNaNConfig2 = {
    kernelName: IsNan,
    backendName: "webgl",
    kernelFunc: isNaN4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js
  var LESS = `return float(a < b);`;
  var LESS_PACKED = `
  return vec4(lessThan(a, b));
`;
  var less3 = binaryKernelFunc2({
    opSnippet: LESS,
    packedOpSnippet: LESS_PACKED,
    cpuKernelImpl: lessImplCPU,
    dtype: "bool"
  });
  var lessConfig2 = {
    kernelName: Less,
    backendName: "webgl",
    kernelFunc: less3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js
  var LESS_EQUAL = `return float(a <= b);`;
  var LESS_EQUAL_PACKED = `
  return vec4(lessThanEqual(a, b));
`;
  var lessEqual3 = binaryKernelFunc2({
    opSnippet: LESS_EQUAL,
    packedOpSnippet: LESS_EQUAL_PACKED,
    cpuKernelImpl: lessEqualImplCPU,
    dtype: "bool"
  });
  var lessEqualConfig2 = {
    kernelName: LessEqual,
    backendName: "webgl",
    kernelFunc: lessEqual3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js
  function linSpace2(args) {
    const { backend: backend2, attrs } = args;
    const { start, stop: stop2, num } = attrs;
    const outVals = linSpaceImplCPU(start, stop2, num);
    return backend2.makeTensorInfo([outVals.length], "float32", outVals);
  }
  var linSpaceConfig2 = {
    kernelName: LinSpace,
    backendName: "webgl",
    kernelFunc: linSpace2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js
  var LOG = `if (x < 0.0) return NAN;
  return log(x);`;
  var LOG_PACKED = `
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`;
  var log8 = unaryKernelFunc2({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });
  var logConfig2 = {
    kernelName: Log2,
    backendName: "webgl",
    kernelFunc: log8
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js
  var LOG1P = `return log(1.0 + x);`;
  var log1p3 = unaryKernelFunc2({ opSnippet: LOG1P });
  var log1pConfig2 = {
    kernelName: Log1p,
    backendName: "webgl",
    kernelFunc: log1p3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js
  var LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`;
  var LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`;
  var logicalAnd3 = binaryKernelFunc2({
    opSnippet: LOGICAL_AND,
    packedOpSnippet: LOGICAL_AND_PACKED,
    dtype: "bool"
  });
  var logicalAndConfig2 = {
    kernelName: LogicalAnd,
    backendName: "webgl",
    kernelFunc: logicalAnd3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js
  var LOGICAL_NOT = `return float(!(x >= 1.0));`;
  var logicalNot3 = unaryKernelFunc2({ opSnippet: LOGICAL_NOT });
  var logicalNotConfig2 = {
    kernelName: LogicalNot,
    backendName: "webgl",
    kernelFunc: logicalNot3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js
  var LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`;
  var LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`;
  var logicalOr3 = binaryKernelFunc2({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: "bool" });
  var logicalOrConfig2 = {
    kernelName: LogicalOr,
    backendName: "webgl",
    kernelFunc: logicalOr3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js
  var LRNProgram = class {
    constructor(xShape, radius, bias, alpha, beta) {
      this.variableNames = ["x"];
      this.outputShape = [];
      const rad = radius;
      const maxD = xShape[3] - 1;
      this.outputShape = xShape;
      let powOperator;
      const basis2 = `float(${bias}) + float(${alpha}) * sum`;
      if (beta === 0.5) {
        powOperator = `inversesqrt(${basis2})`;
      } else if (beta === 1) {
        powOperator = `1.0/(${basis2})`;
      } else {
        powOperator = `exp(log(${basis2}) * float(-${beta}));`;
      }
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js
  var LRNPackedProgram = class {
    constructor(xShape, radius, bias, alpha, beta) {
      this.variableNames = ["x"];
      this.outputShape = [];
      this.packedInputs = true;
      this.packedOutput = true;
      const rad = radius;
      const maxD = xShape[3] - 1;
      this.outputShape = xShape;
      let powOperator;
      const basis2 = `float(${bias}) + float(${alpha}) * sum`;
      if (beta === 0.5) {
        powOperator = `inversesqrt(${basis2})`;
      } else if (beta === 1) {
        powOperator = `1.0/(${basis2})`;
      } else {
        powOperator = `exp(log(${basis2}) * float(-${beta}));`;
      }
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js
  var lrn = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) : new LRNProgram(x.shape, depthRadius, bias, alpha, beta);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  };
  var LRNConfig = {
    kernelName: LRN,
    backendName: "webgl",
    kernelFunc: lrn
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js
  var LRNGradProgram = class {
    constructor(inputShape, depthRadius, bias, alpha, beta) {
      this.variableNames = ["inputImage", "outputImage", "dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      this.depth = inputShape[3];
      this.depthRadius = depthRadius;
      this.bias = bias;
      this.alpha = alpha;
      this.beta = beta;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js
  var lrnGrad = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x, y, dy } = inputs;
    const { depthRadius, bias, alpha, beta } = attrs;
    const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);
    return backend2.runWebGLProgram(program, [x, y, dy], x.dtype);
  };
  var LRNGradConfig = {
    kernelName: LRNGrad,
    backendName: "webgl",
    kernelFunc: lrnGrad
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js
  function maxImpl2(x, reduceShape, outShape, backend2) {
    const inSize = util_exports2.sizeFromShape(reduceShape);
    const xSize = util_exports2.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape3({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend: backend2 });
    const reduced = reduce2(reshapedInput, x.dtype, "max", backend2);
    const reshapedOutput = reshape3({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(reshapedInput);
    backend2.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js
  function max6(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { reductionIndices, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = util_exports2.parseAxisParam(reductionIndices, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    const maxInputIsTransposed = permutedAxes != null;
    const shouldExecuteOnCPU = backend2.shouldExecuteOnCPU([x]);
    let maxInput = x;
    if (maxInputIsTransposed) {
      if (shouldExecuteOnCPU) {
        const xTexData = backend2.texData.get(maxInput.dataId);
        const values2 = xTexData.values;
        const newShape = new Array(xRank);
        for (let i = 0; i < newShape.length; i++) {
          newShape[i] = x.shape[permutedAxes[i]];
        }
        const maxInputValues = transposeImplCPU(values2, x.shape, x.dtype, permutedAxes, newShape);
        maxInput = backend2.makeTensorInfo(newShape, x.dtype);
        const maxInputData = backend2.texData.get(maxInput.dataId);
        maxInputData.values = maxInputValues;
      } else {
        maxInput = transposeImpl2(x, permutedAxes, backend2);
      }
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
    }
    backend_util_exports.assertAxesAreInnerMostDims("max", axes, xRank);
    const [maxOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(maxInput.shape, axes);
    let outShape = maxOutShape;
    if (keepDims) {
      outShape = backend_util_exports.expandShapeToKeepDim(maxOutShape, origAxes);
    }
    let out;
    if (shouldExecuteOnCPU) {
      const xTexData = backend2.texData.get(maxInput.dataId);
      const values2 = xTexData.values;
      const outValues = maxImplCPU(values2, util_exports2.sizeFromShape(reduceShape), outShape, x.dtype);
      out = backend2.makeTensorInfo(outShape, x.dtype);
      const outData = backend2.texData.get(out.dataId);
      outData.values = outValues;
    } else {
      out = maxImpl2(maxInput, reduceShape, outShape, backend2);
    }
    if (maxInputIsTransposed) {
      backend2.disposeIntermediateTensorInfo(maxInput);
    }
    return out;
  }
  var maxConfig2 = {
    kernelName: Max,
    backendName: "webgl",
    kernelFunc: max6
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js
  var MAXIMUM = CHECK_NAN_SNIPPET2 + `
  return max(a, b);
`;
  var MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
  var maximum3 = binaryKernelFunc2({
    opSnippet: MAXIMUM,
    packedOpSnippet: MAXIMUM_PACKED,
    cpuKernelImpl: maximumImplCPU
  });
  var maximumConfig2 = {
    kernelName: Maximum,
    backendName: "webgl",
    kernelFunc: maximum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js
  function maxPool3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    assertNotComplex2(x, "maxPool");
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const dilations = 1;
    util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
    if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && util_exports2.arraysEqual(convInfo.inShape, convInfo.outShape)) {
      return identity4({ inputs: { x }, backend: backend2 });
    }
    const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
    return backend2.runWebGLProgram(maxPoolProgram, [x], x.dtype);
  }
  var maxPoolConfig2 = {
    kernelName: MaxPool,
    backendName: "webgl",
    kernelFunc: maxPool3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js
  function maxPool3d2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { filterSize, strides, pad: pad3, dataFormat, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode, dataFormat);
    const maxPoolProgram = new Pool3DProgram(convInfo, "max", false);
    return backend2.runWebGLProgram(maxPoolProgram, [x], x.dtype);
  }
  var maxPool3DConfig2 = {
    kernelName: MaxPool3D,
    backendName: "webgl",
    kernelFunc: maxPool3d2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js
  var MaxPool2DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "maxPos"];
      this.outputShape = convInfo.inShape;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationHeight = convInfo.dilationHeight;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
      this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };
  var MaxPool3DBackpropProgram = class {
    constructor(convInfo) {
      this.variableNames = ["dy", "maxPos"];
      this.outputShape = convInfo.inShape;
      const strideDepth = convInfo.strideDepth;
      const strideHeight = convInfo.strideHeight;
      const strideWidth = convInfo.strideWidth;
      const dilationDepth = convInfo.dilationDepth;
      const dilationHeight = convInfo.dilationHeight;
      const dilationWidth = convInfo.dilationWidth;
      const effectiveFilterDepth = convInfo.effectiveFilterDepth;
      const effectiveFilterHeight = convInfo.effectiveFilterHeight;
      const effectiveFilterWidth = convInfo.effectiveFilterWidth;
      const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
      const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
      const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
      const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
      this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js
  function maxPool3DGrad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2 } = inputs;
    const x = input2;
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const dilations = [1, 1, 1];
    const convInfo = backend_util_exports.computePool3DInfo(x.shape, filterSize, strides, dilations, pad3, dimRoundingMode);
    const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, "max", true);
    const maxPool3dPositions2 = backend2.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);
    const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);
    const result = backend2.runWebGLProgram(maxPoolBackpropProgram, [dy, maxPool3dPositions2], x.dtype);
    backend2.disposeIntermediateTensorInfo(maxPool3dPositions2);
    return result;
  }
  var maxPoolGrad3DConfig = {
    kernelName: MaxPool3DGrad,
    backendName: "webgl",
    kernelFunc: maxPool3DGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js
  function maxPoolGrad3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { dy, input: input2, output } = inputs;
    const x = input2;
    assertNotComplex2([input2, output], "maxPoolGrad");
    const { filterSize, strides, pad: pad3, dimRoundingMode } = attrs;
    const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, 1, pad3, dimRoundingMode);
    const getPositions = true;
    const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
    const maxPoolPositions2 = backend2.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);
    const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
    const result = backend2.runWebGLProgram(maxPoolBackPropProgram, [dy, maxPoolPositions2], x.dtype);
    backend2.disposeIntermediateTensorInfo(maxPoolPositions2);
    return result;
  }
  var maxPoolGradConfig3 = {
    kernelName: MaxPoolGrad,
    backendName: "webgl",
    kernelFunc: maxPoolGrad3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js
  function maxPoolWithArgmaxImpl2(x, includeBatchInIndex, convInfo, backend2) {
    let program = new Pool2DProgram(convInfo, "max", false);
    const poolOutput = backend2.runWebGLProgram(program, [x], "float32");
    program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
    const indexOutput = backend2.runWebGLProgram(program, [x], "float32");
    return [poolOutput, indexOutput];
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js
  var maxPoolWithArgmaxConfig2 = {
    kernelName: MaxPoolWithArgmax,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      const { filterSize, strides, pad: pad3, includeBatchInIndex } = attrs;
      const webglBackend = backend2;
      util_exports2.assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
      const dilations = [1, 1];
      util_exports2.assert(backend_util_exports.eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = backend_util_exports.computePool2DInfo(x.shape, filterSize, strides, dilations, pad3);
      const [result, indexes] = maxPoolWithArgmaxImpl2(x, includeBatchInIndex, convInfo, webglBackend);
      return [result, indexes];
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js
  function meanImpl(x, reduceShape, outShape, backend2) {
    const inSize = util_exports2.sizeFromShape(reduceShape);
    const xSize = util_exports2.sizeFromShape(x.shape);
    const batchSize = xSize / inSize;
    const reshapedInput = reshape3({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend: backend2 });
    const reduced = reduce2(reshapedInput, "float32", "mean", backend2);
    const reshapedOutput = reshape3({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(reshapedInput);
    backend2.disposeIntermediateTensorInfo(reduced);
    return reshapedOutput;
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js
  var meanConfig2 = {
    kernelName: Mean,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { x } = inputs;
      const { keepDims, axis } = attrs;
      const webglBackend = backend2;
      const xRank = x.shape.length;
      const origAxes = util_exports2.parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
      const meanInputIsTransposed = permutedAxes != null;
      const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
      const intermediates = [];
      let meanInput = x;
      if (meanInputIsTransposed) {
        if (shouldExecuteOnCPU) {
          const xTexData = webglBackend.texData.get(meanInput.dataId);
          const values2 = xTexData.values;
          const newShape = new Array(xRank);
          for (let i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[permutedAxes[i]];
          }
          const meanInputValues = transposeImplCPU(values2, x.shape, x.dtype, permutedAxes, newShape);
          meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
          const meanInputData = webglBackend.texData.get(meanInput.dataId);
          meanInputData.values = meanInputValues;
        } else {
          meanInput = transposeImpl2(x, permutedAxes, webglBackend);
        }
        intermediates.push(meanInput);
        axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      }
      backend_util_exports.assertAxesAreInnerMostDims("sum", axes, xRank);
      const [meanOutShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(meanInput.shape, axes);
      let outShape = meanOutShape;
      if (keepDims) {
        outShape = backend_util_exports.expandShapeToKeepDim(meanOutShape, origAxes);
      }
      const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
      for (const i of intermediates) {
        webglBackend.disposeIntermediateTensorInfo(i);
      }
      return out;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js
  function min6(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, x.shape.length);
    }
    backend_util_exports.assertAxesAreInnerMostDims("min", axes, xRank);
    const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = util_exports2.sizeFromShape(reduceShape);
    const a2D = reshape3({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    const reduced = reduce2(a2D, a2D.dtype, "min", backend2);
    let res;
    if (keepDims) {
      const newShape = backend_util_exports.expandShapeToKeepDim(outShape, origAxes);
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: newShape } });
    } else {
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
    }
    backend2.disposeIntermediateTensorInfo(a2D);
    backend2.disposeIntermediateTensorInfo(reduced);
    if (permutedAxes != null) {
      backend2.disposeIntermediateTensorInfo(permutedX);
    }
    return res;
  }
  var minConfig2 = {
    kernelName: Min,
    backendName: "webgl",
    kernelFunc: min6
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js
  var MINIMUM = CHECK_NAN_SNIPPET2 + `
  return min(a, b);
`;
  var MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
  var minimum3 = binaryKernelFunc2({
    opSnippet: MINIMUM,
    packedOpSnippet: MINIMUM_PACKED,
    cpuKernelImpl: minimumImplCPU
  });
  var minimumConfig2 = {
    kernelName: Minimum,
    backendName: "webgl",
    kernelFunc: minimum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js
  var MirrorPadProgram = class {
    constructor(xShape, paddings, mode) {
      this.variableNames = ["x"];
      this.outputShape = paddings.map((p3, i) => p3[0] + xShape[i] + p3[1]);
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p3) => p3[0]).join(",");
      const end = paddings.map((p3, i) => p3[0] + xShape[i]).join(",");
      const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
      const offset = mode === "reflect" ? 0 : 1;
      if (rank === 1) {
        this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
        return;
      }
      this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js
  var MirrorPadPackedProgram = class {
    constructor(xShape, paddings, mode) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = paddings.map((p3, i) => p3[0] + xShape[i] + p3[1]);
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p3) => p3[0]).join(",");
      const end = paddings.map((p3, i) => p3[0] + xShape[i]).join(",");
      const coords2 = getChannels("rc", rank);
      const source = getChannels("source", rank);
      const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
      const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
      const offset = mode === "reflect" ? 0 : 1;
      let mainLoop = "";
      if (rank === 1) {
        const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
        mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
      } else {
        const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
        mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords2[rank - 2]} += 1;
        if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
      }
      this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js
  var mirrorPadKernelFunc = ({ inputs, backend: backend2, attrs }) => {
    const { x } = inputs;
    const { paddings, mode } = attrs;
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x.shape, paddings, mode) : new MirrorPadProgram(x.shape, paddings, mode);
    const output = backend2.runWebGLProgram(program, [x], x.dtype);
    return output;
  };
  var mirrorPadConfig2 = {
    kernelName: MirrorPad,
    backendName: "webgl",
    kernelFunc: mirrorPadKernelFunc
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js
  var MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`;
  var MOD_PACKED = `
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
  var mod5 = binaryKernelFunc2({
    opSnippet: MOD,
    packedOpSnippet: MOD_PACKED
  });
  var modConfig2 = {
    kernelName: Mod,
    backendName: "webgl",
    kernelFunc: mod5
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js
  var MultinomialProgram = class {
    constructor(batchSize, numOutcomes, numSamples) {
      this.variableNames = ["probs"];
      this.customUniforms = [{ name: "seed", type: "float" }];
      this.outputShape = [batchSize, numSamples];
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js
  var DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`;
  var DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`;
  var realDiv = binaryKernelFunc2({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
  var realDivConfig2 = {
    kernelName: RealDiv,
    backendName: "webgl",
    kernelFunc: realDiv
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js
  var SUB = "return a - b;";
  var sub6 = binaryKernelFunc2({
    opSnippet: SUB,
    packedOpSnippet: SUB,
    supportsComplex: true,
    cpuKernelImpl: subImplCPU
  });
  var subConfig2 = {
    kernelName: Sub,
    backendName: "webgl",
    kernelFunc: sub6
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js
  function softmax3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { logits } = inputs;
    const { dim } = attrs;
    const axes = util_exports2.parseAxisParam([dim], logits.shape);
    const maxLogit = max6({
      inputs: { x: logits },
      backend: backend2,
      attrs: { reductionIndices: axes, keepDims: false }
    });
    const expandedShape = backend_util_exports.expandShapeToKeepDim(maxLogit.shape, axes);
    const maxLogitsReshaped = reshape3({ inputs: { x: maxLogit }, backend: backend2, attrs: { shape: expandedShape } });
    const a = sub6({ inputs: { a: logits, b: maxLogitsReshaped }, backend: backend2 });
    const b = exp3({ inputs: { x: a }, backend: backend2 });
    const sumExp = sum4({ inputs: { x: b }, backend: backend2, attrs: { axis: axes, keepDims: false } });
    const sumExpReshaped = reshape3({ inputs: { x: sumExp }, backend: backend2, attrs: { shape: expandedShape } });
    const res = realDiv({ inputs: { a: b, b: sumExpReshaped }, backend: backend2 });
    backend2.disposeIntermediateTensorInfo(maxLogit);
    backend2.disposeIntermediateTensorInfo(maxLogitsReshaped);
    backend2.disposeIntermediateTensorInfo(a);
    backend2.disposeIntermediateTensorInfo(b);
    backend2.disposeIntermediateTensorInfo(sumExp);
    backend2.disposeIntermediateTensorInfo(sumExpReshaped);
    return res;
  }
  var softmaxConfig2 = {
    kernelName: Softmax,
    backendName: "webgl",
    kernelFunc: softmax3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js
  function multinomial2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { logits } = inputs;
    const { numSamples, seed, normalized } = attrs;
    const probs = normalized ? logits : softmax3({ inputs: { logits }, backend: backend2, attrs: { dim: logits.shape.length - 1 } });
    const batchSize = probs.shape[0];
    const numOutcomes = probs.shape[1];
    const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
    const customValues = [[seed]];
    const res = backend2.runWebGLProgram(program, [probs], "int32", customValues);
    if (!normalized) {
      backend2.disposeIntermediateTensorInfo(probs);
    }
    return res;
  }
  var multinomialConfig2 = {
    kernelName: Multinomial,
    backendName: "webgl",
    kernelFunc: multinomial2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js
  var NEG = `return -x;`;
  function neg3(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (backend2.shouldExecuteOnCPU([x])) {
      const xData = backend2.texData.get(x.dataId);
      const [outValues, newShape] = negImplCPU(xData.values, x.shape, x.dtype);
      return backend2.makeTensorInfo(newShape, x.dtype, outValues);
    }
    let program;
    if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
      program = new UnaryOpPackedProgram(x.shape, NEG);
    } else {
      program = new UnaryOpProgram(x.shape, NEG);
    }
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  var negConfig2 = {
    kernelName: Neg,
    backendName: "webgl",
    kernelFunc: neg3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js
  var nonMaxSuppressionV3Impl3 = kernel_impls_exports.nonMaxSuppressionV3Impl;
  function nonMaxSuppressionV32(args) {
    backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
    const boxesVals = backend2.readSync(boxes.dataId);
    const scoresVals = backend2.readSync(scores.dataId);
    const { selectedIndices } = nonMaxSuppressionV3Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
    return backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
  }
  var nonMaxSuppressionV3Config2 = {
    kernelName: NonMaxSuppressionV3,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV32
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js
  var nonMaxSuppressionV4Impl3 = kernel_impls_exports.nonMaxSuppressionV4Impl;
  function nonMaxSuppressionV42(args) {
    backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
    const boxesVals = backend2.readSync(boxes.dataId);
    const scoresVals = backend2.readSync(scores.dataId);
    const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
    return [
      backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend2.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
    ];
  }
  var nonMaxSuppressionV4Config2 = {
    kernelName: NonMaxSuppressionV4,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV42
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js
  var nonMaxSuppressionV5Impl3 = kernel_impls_exports.nonMaxSuppressionV5Impl;
  function nonMaxSuppressionV52(args) {
    backend_util_exports.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
    const { inputs, backend: backend2, attrs } = args;
    const { boxes, scores } = inputs;
    const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
    const boxesVals = backend2.readSync(boxes.dataId);
    const scoresVals = backend2.readSync(scores.dataId);
    const maxOutputSizeVal = maxOutputSize;
    const iouThresholdVal = iouThreshold;
    const scoreThresholdVal = scoreThreshold;
    const softNmsSigmaVal = softNmsSigma;
    const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl3(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
    return [
      backend2.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
      backend2.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
    ];
  }
  var nonMaxSuppressionV5Config2 = {
    kernelName: NonMaxSuppressionV5,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV52
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js
  var OneHotProgram = class {
    constructor(numIndices, depth, onValue, offValue) {
      this.variableNames = ["indices"];
      this.outputShape = [numIndices, depth];
      this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js
  var oneHot3 = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { indices } = inputs;
    const { depth, onValue, offValue } = attrs;
    const indicesSize = util_exports2.sizeFromShape(indices.shape);
    const program = new OneHotProgram(indicesSize, depth, onValue, offValue);
    const reshaped = reshape3({ inputs: { x: indices }, backend: backend2, attrs: { shape: [indicesSize] } });
    const result = backend2.runWebGLProgram(program, [reshaped], indices.dtype);
    backend2.disposeIntermediateTensorInfo(reshaped);
    const outShape = [...indices.shape, depth];
    const out = reshape3({ inputs: { x: result }, backend: backend2, attrs: { shape: outShape } });
    backend2.disposeIntermediateTensorInfo(result);
    return out;
  };
  var oneHotConfig2 = {
    kernelName: OneHot,
    backendName: "webgl",
    kernelFunc: oneHot3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js
  function zerosLike3(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (x.dtype === "complex64") {
      const realPart = real3({ inputs: { input: x }, backend: backend2 });
      const r = zerosLike3({ inputs: { x: realPart }, backend: backend2 });
      const imagPart = imag3({ inputs: { input: x }, backend: backend2 });
      const i = zerosLike3({ inputs: { x: imagPart }, backend: backend2 });
      const result = complex3({ inputs: { real: r, imag: i }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(r);
      backend2.disposeIntermediateTensorInfo(imagPart);
      backend2.disposeIntermediateTensorInfo(i);
      return result;
    } else {
      return fill3({
        attrs: {
          shape: x.shape,
          dtype: x.dtype,
          value: x.dtype === "string" ? "" : 0
        },
        backend: backend2
      });
    }
  }
  var zerosLikeConfig2 = {
    kernelName: ZerosLike,
    backendName: "webgl",
    kernelFunc: zerosLike3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js
  function onesLike3(args) {
    const { inputs, backend: backend2 } = args;
    const { x } = inputs;
    if (x.dtype === "string") {
      throw new Error("onesLike is not supported under string dtype");
    } else if (x.dtype === "complex64") {
      const realPart = real3({ inputs: { input: x }, backend: backend2 });
      const r = onesLike3({ inputs: { x: realPart }, backend: backend2 });
      const imagPart = imag3({ inputs: { input: x }, backend: backend2 });
      const i = zerosLike3({ inputs: { x: imagPart }, backend: backend2 });
      const result = complex3({ inputs: { real: r, imag: i }, backend: backend2 });
      backend2.disposeIntermediateTensorInfo(realPart);
      backend2.disposeIntermediateTensorInfo(r);
      backend2.disposeIntermediateTensorInfo(imagPart);
      backend2.disposeIntermediateTensorInfo(i);
      return result;
    } else {
      return fill3({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend: backend2 });
    }
  }
  var onesLikeConfig2 = {
    kernelName: OnesLike,
    backendName: "webgl",
    kernelFunc: onesLike3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js
  function pack2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { axis } = attrs;
    if (inputs.length === 1) {
      return expandDims4({ inputs: { input: inputs[0] }, backend: backend2, attrs: { dim: axis } });
    }
    const shape = inputs[0].shape;
    const dtype = inputs[0].dtype;
    inputs.forEach((t) => {
      util_exports2.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
      util_exports2.assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    const intermediateTensorInfos = [];
    const expandedTensors = inputs.map((t) => {
      const expandedT = expandDims4({ inputs: { input: t }, backend: backend2, attrs: { dim: axis } });
      intermediateTensorInfos.push(expandedT);
      return expandedT;
    });
    const result = concat3({ inputs: expandedTensors, backend: backend2, attrs: { axis } });
    intermediateTensorInfos.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  var packConfig2 = {
    kernelName: Pack,
    backendName: "webgl",
    kernelFunc: pack2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js
  var PadProgram = class {
    constructor(xShape, paddings, constantValue) {
      this.variableNames = ["x"];
      this.customUniforms = [{ name: "value", type: "float" }];
      this.outputShape = paddings.map((p3, i) => p3[0] + xShape[i] + p3[1]);
      const rank = xShape.length;
      const type = getCoordsDataType(rank);
      const start = paddings.map((p3) => p3[0]).join(",");
      const end = paddings.map((p3, i) => p3[0] + xShape[i]).join(",");
      const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
      if (rank === 1) {
        this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
        return;
      }
      this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js
  var PadPackedProgram = class {
    constructor(xShape, paddings, constantValue) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.customUniforms = [{ name: "value", type: "float" }];
      this.outputShape = paddings.map((p3, i) => p3[0] + xShape[i] + p3[1]);
      const rank = xShape.length;
      const dtype = getCoordsDataType(rank);
      const start = paddings.map((p3) => p3[0]).join(",");
      const end = paddings.map((p3, i) => p3[0] + xShape[i]).join(",");
      const coords2 = getChannels("rc", rank);
      const source = getChannels("source", rank);
      const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
      const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
      const componentSetup = [
        `${dtype} rc = outputLoc;`,
        `${coords2[rank - 1]} += 1;
       if(${cLimit}) {
      `,
        rank === 1 ? "" : `}
       rc = outputLoc;
       ${coords2[rank - 2]} += 1;
       if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
        rank === 1 ? "" : `  ${coords2[rank - 1]} += 1;
         if(${cLimit}) {`
      ];
      const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
      let mainLoop = "";
      for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {
        mainLoop += `
        ${componentSetup[i]}
        if (${paddingArea}) {
          result[${i}] = float(value);
        } else {
          ${dtype} source = rc - start;
          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
      }
      mainLoop += rank === 1 ? `} ` : `}}`;
      this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js
  var padV22 = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { paddings, constantValue } = attrs;
    if (util_exports2.sizeFromShape(x.shape) === 0) {
      const outputShape = paddings.map((p3, i) => p3[0] + x.shape[i] + p3[1]);
      return fill3({
        backend: backend2,
        attrs: { shape: outputShape, value: constantValue, dtype: x.dtype }
      });
    }
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x.shape, paddings, constantValue) : new PadProgram(x.shape, paddings, constantValue);
    const customValues = [[constantValue]];
    return backend2.runWebGLProgram(program, [x], x.dtype, customValues);
  };
  var padV2Config2 = {
    kernelName: PadV2,
    backendName: "webgl",
    kernelFunc: padV22
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js
  var POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`;
  var POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  ` + CHECK_NAN_SNIPPET3 + `
  return result;
`;
  var pow3 = binaryKernelFunc2({ opSnippet: POW, packedOpSnippet: POW_PACKED });
  var powConfig2 = {
    kernelName: Pow2,
    backendName: "webgl",
    kernelFunc: pow3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js
  function prod3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { axis, keepDims } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    const origAxes = util_exports2.parseAxisParam(axis, x.shape);
    let axes = origAxes;
    const permutedAxes = backend_util_exports.getAxesPermutation(axes, xRank);
    let permutedX = x;
    if (permutedAxes != null) {
      permutedX = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutedAxes } });
      axes = backend_util_exports.getInnerMostAxes(axes.length, xRank);
      toDispose.push(permutedX);
    }
    backend_util_exports.assertAxesAreInnerMostDims("prod", axes, xRank);
    let res;
    if (backend2.shouldExecuteOnCPU([permutedX])) {
      const xVals = backend2.texData.get(permutedX.dataId).values;
      const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);
      res = backend2.makeTensorInfo(outShape, outDtype, outVals);
    } else {
      const [outShape, reduceShape] = backend_util_exports.computeOutAndReduceShapes(permutedX.shape, axes);
      const inSize = util_exports2.sizeFromShape(reduceShape);
      const a2D = reshape3({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
      const outputDType = sumOutType(x.dtype);
      const reduced = reduce2(a2D, outputDType, "prod", backend2);
      res = reshape3({ inputs: { x: reduced }, backend: backend2, attrs: { shape: outShape } });
      toDispose.push(a2D);
      toDispose.push(reduced);
    }
    if (keepDims) {
      toDispose.push(res);
      const newShape = backend_util_exports.expandShapeToKeepDim(res.shape, origAxes);
      res = reshape3({ inputs: { x: res }, backend: backend2, attrs: { shape: newShape } });
    }
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return res;
  }
  var prodConfig2 = {
    kernelName: Prod,
    backendName: "webgl",
    kernelFunc: prod3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js
  var range4 = (args) => {
    const { backend: backend2, attrs } = args;
    const { start, stop: stop2, step: step4, dtype } = attrs;
    const values2 = rangeImplCPU(start, stop2, step4, dtype);
    return backend2.makeTensorInfo([values2.length], dtype, values2);
  };
  var rangeConfig2 = {
    kernelName: Range,
    backendName: "webgl",
    kernelFunc: range4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js
  var RECIPROCAL = `return 1.0 / x;`;
  var reciprocal3 = unaryKernelFunc2({ opSnippet: RECIPROCAL });
  var reciprocalConfig2 = {
    kernelName: Reciprocal,
    backendName: "webgl",
    kernelFunc: reciprocal3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js
  var RELU3 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
  var RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var relu3 = unaryKernelFunc2({ opSnippet: RELU3, packedOpSnippet: RELU_PACKED });
  var reluConfig2 = {
    kernelName: Relu,
    backendName: "webgl",
    kernelFunc: relu3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js
  var RELU63 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  var RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;
  var relu63 = unaryKernelFunc2({ opSnippet: RELU63, packedOpSnippet: RELU6_PACKED });
  var relu6Config2 = {
    kernelName: Relu6,
    backendName: "webgl",
    kernelFunc: relu63
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js
  var ResizeBilinearProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)`;
      } else {
        sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js
  var ResizeBilinearPackedProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)`;
      } else {
        sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js
  function resizeBilinear3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size: size3 } = attrs;
    const [newHeight, newWidth] = size3;
    const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend2.runWebGLProgram(program, [images], "float32");
  }
  var resizeBilinearConfig2 = {
    kernelName: ResizeBilinear,
    backendName: "webgl",
    kernelFunc: resizeBilinear3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js
  var ResizeBilinearBackpropProgram = class {
    constructor(dyShape, inputShape, alignCorners) {
      this.variableNames = ["dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      const [, xHeight, xWidth] = inputShape;
      const [, yHeight, yWidth] = dyShape;
      const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
      ];
      const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
      ];
      const heightScale = effectiveXSize[0] / effectiveYSize[0];
      const widthScale = effectiveXSize[1] / effectiveYSize[1];
      const invHeightScale = 1 / heightScale;
      const invWidthScale = 1 / widthScale;
      const winHeight = Math.ceil(invHeightScale) * 2 + 2;
      const winWidth = Math.ceil(invWidthScale) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js
  function resizeBilinearGrad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new ResizeBilinearBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend2.runWebGLProgram(program, [dy], dy.dtype);
  }
  var resizeBilinearGradConfig3 = {
    kernelName: ResizeBilinearGrad,
    backendName: "webgl",
    kernelFunc: resizeBilinearGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js
  var ResizeNearestNeighborProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      const roundBase = alignCorners ? "0.5" : "0.0";
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))`;
      } else {
        sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js
  var ResizeNearestNeighborPackedProgram = class {
    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
      this.variableNames = ["A"];
      this.packedInputs = true;
      this.packedOutput = true;
      this.outputShape = [];
      const [batch, oldHeight, oldWidth, depth] = inputShape;
      this.outputShape = [batch, newHeight, newWidth, depth];
      const effectiveInSize = [
        alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
        alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
      ];
      const effectiveOutSize = [
        alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
        alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
      ];
      const roundBase = alignCorners ? "0.5" : "0.0";
      let sourceFracIndexRC;
      if (halfPixelCenters) {
        sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))`;
      } else {
        sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
      }
      this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js
  function resizeNearestNeighbor3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images } = inputs;
    const { alignCorners, halfPixelCenters, size: size3 } = attrs;
    const [newHeight, newWidth] = size3;
    const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeNearestNeighborPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
    return backend2.runWebGLProgram(program, [images], images.dtype);
  }
  var resizeNearestNeighborConfig2 = {
    kernelName: ResizeNearestNeighbor,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighbor3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js
  var ResizeNearestNeigborBackpropProgram = class {
    constructor(dyShape, inputShape, alignCorners) {
      this.variableNames = ["dy"];
      this.outputShape = [];
      this.outputShape = inputShape;
      const [, xHeight, xWidth] = inputShape;
      const [, yHeight, yWidth] = dyShape;
      const effectiveXSize = [
        alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
        alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
      ];
      const effectiveYSize = [
        alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
        alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
      ];
      const heightScale = effectiveXSize[0] / effectiveYSize[0];
      const widthScale = effectiveXSize[1] / effectiveYSize[1];
      const invHeightScale = 1 / heightScale;
      const invWidthScale = 1 / widthScale;
      const winHeight = Math.ceil(invHeightScale) * 2 + 2;
      const winWidth = Math.ceil(invWidthScale) * 2 + 2;
      this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js
  function resizeNearestNeighborGrad2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { images, dy } = inputs;
    const { alignCorners } = attrs;
    const program = new ResizeNearestNeigborBackpropProgram(dy.shape, images.shape, alignCorners);
    return backend2.runWebGLProgram(program, [dy], dy.dtype);
  }
  var resizeNearestNeighborGradConfig3 = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighborGrad2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js
  var ReverseProgram = class {
    constructor(xShape, axis) {
      this.variableNames = ["x"];
      const rank = xShape.length;
      if (rank > 4) {
        throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
      }
      this.outputShape = xShape;
      if (rank === 1) {
        this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
        return;
      }
      const getInCoord = (i) => {
        if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
          return `${xShape[i]} - coords[${i}] - 1`;
        }
        return `coords[${i}]`;
      };
      const inCoords = xShape.map((_6, i) => getInCoord(i)).join(",");
      const type = getCoordsDataType(rank);
      this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js
  var ReversePackedProgram = class {
    constructor(xShape, axis) {
      this.variableNames = ["x"];
      this.packedInputs = true;
      this.packedOutput = true;
      const rank = xShape.length;
      if (rank > 4) {
        throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
      }
      this.outputShape = xShape;
      const channels = getChannels("rc", rank);
      const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
      const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
      const type = getCoordsDataType(rank);
      if (rank === 1) {
        this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
      } else {
        this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
      }
      function getR(channels2) {
        return getChannel(channels2);
      }
      function getG(channels2) {
        channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
        return getChannel(channels2);
      }
      function getB(channels2) {
        channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
        return getChannel(channels2);
      }
      function getA(channels2) {
        channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
        channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
        return getChannel(channels2);
      }
      function getChannel(channels2) {
        const inCoordsArray = xShape.map((_6, i) => getInCoord(i, channels2));
        const inCoords = inCoordsArray.join(",");
        const innerDims = inCoordsArray.slice(-2).join(",");
        return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
      }
      function getInCoord(i, channels1) {
        if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
          return `${xShape[i]} - ${channels1[i]} - 1`;
        } else {
          return `${channels1[i]}`;
        }
      }
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js
  function reverse3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { dims } = attrs;
    const xRank = x.shape.length;
    const $dims = util_exports2.parseAxisParam(dims, x.shape);
    if (xRank === 0) {
      return identity4({ inputs: { x }, backend: backend2 });
    }
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x.shape, $dims) : new ReverseProgram(x.shape, $dims);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  var reverseConfig2 = {
    kernelName: Reverse,
    backendName: "webgl",
    kernelFunc: reverse3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js
  var RotateProgram = class {
    constructor(imageShape, fillValue) {
      this.variableNames = ["Image"];
      this.outputShape = [];
      this.customUniforms = [{ name: "params", type: "vec4" }];
      const imageHeight = imageShape[1];
      const imageWidth = imageShape[2];
      this.outputShape = imageShape;
      let fillSnippet = "";
      if (typeof fillValue === "number") {
        fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
      } else {
        fillSnippet = `
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`;
      }
      this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js
  var rotateWithOffsetConfig2 = {
    kernelName: RotateWithOffset,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend2 }) => {
      const { image: image3 } = inputs;
      const { radians, fillValue, center } = attrs;
      const webglBackend = backend2;
      const program = new RotateProgram(image3.shape, fillValue);
      const [centerX, centerY] = backend_util_exports.getImageCenter(center, image3.shape[1], image3.shape[2]);
      const customValues = [[centerX, centerY, Math.sin(radians), Math.cos(radians)]];
      const output = webglBackend.runWebGLProgram(program, [image3], image3.dtype, customValues);
      return output;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js
  var ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`;
  var round7 = unaryKernelFunc2({ opSnippet: ROUND });
  var roundConfig2 = {
    kernelName: Round,
    backendName: "webgl",
    kernelFunc: round7
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js
  var RSQRT = `return inversesqrt(x);`;
  var rsqrt3 = unaryKernelFunc2({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });
  var rsqrtConfig2 = {
    kernelName: Rsqrt,
    backendName: "webgl",
    kernelFunc: rsqrt3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js
  var ScatterProgram = class {
    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {
      this.variableNames = ["updates", "indices", "defaultValue"];
      this.outputShape = shape;
      const stridesType = getCoordsDataType(strides.length);
      const dtype = getCoordsDataType(shape.length);
      let indicesString = "";
      if (indicesRank === 1) {
        indicesString = "i";
      } else if (indicesRank === 2) {
        indicesString = "i, j";
      }
      const indicesSnippet = `getIndices(${indicesString})`;
      let updatesString = "";
      if (updatesRank === 1) {
        updatesString = "i";
      } else if (updatesRank === 2) {
        updatesString = "i, coords[1]";
      }
      const updatesSnippet = `getUpdates(${updatesString})`;
      const strideString = sliceDim > 1 ? "strides[j]" : "strides";
      this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js
  function scatterNd2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { indices, updates } = inputs;
    const { shape } = attrs;
    const { sliceRank, numUpdates, sliceSize, strides, outputSize } = backend_util_exports.calculateShapes(updates, indices, shape);
    const flattenShape = [outputSize / sliceSize, sliceSize];
    if (outputSize === 0) {
      return backend2.makeTensorInfo(shape, indices.dtype);
    }
    const flattenIndices = reshape3({ inputs: { x: indices }, backend: backend2, attrs: { shape: [numUpdates, sliceRank] } });
    const flattenX = reshape3({ inputs: { x: updates }, backend: backend2, attrs: { shape: [numUpdates, sliceSize] } });
    const defaultValue = backend2.makeTensorInfo([], "float32", new Float32Array([0]));
    const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
    const res = backend2.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
    const reshaped = reshape3({ inputs: { x: res }, backend: backend2, attrs: { shape } });
    backend2.disposeIntermediateTensorInfo(flattenIndices);
    backend2.disposeIntermediateTensorInfo(flattenX);
    backend2.disposeIntermediateTensorInfo(res);
    backend2.disposeIntermediateTensorInfo(defaultValue);
    return reshaped;
  }
  var scatterNdConfig2 = {
    kernelName: ScatterNd,
    backendName: "webgl",
    kernelFunc: scatterNd2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js
  var SelectProgram = class {
    constructor(cRank, shape, rank) {
      this.variableNames = ["c", "a", "b"];
      this.outputShape = shape;
      let cCoords;
      let abCoords;
      if (rank > 4) {
        throw Error(`Where for rank ${rank} is not yet supported`);
      }
      if (rank === 1) {
        abCoords = `resRC`;
        cCoords = `resRC`;
      } else {
        const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
        const cCoordVars = [];
        const abCoordVars = [];
        for (let i = 0; i < shape.length; i++) {
          abCoordVars.push(`${currentCoords[i]}`);
          if (i < cRank) {
            cCoordVars.push(`${currentCoords[i]}`);
          }
        }
        cCoords = cCoordVars.join();
        abCoords = abCoordVars.join();
      }
      const dtype = getCoordsDataType(rank);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js
  function select3(args) {
    const { inputs, backend: backend2 } = args;
    const { condition, t, e } = inputs;
    const program = new SelectProgram(condition.shape.length, t.shape, t.shape.length);
    return backend2.runWebGLProgram(program, [condition, t, e], upcastType(t.dtype, e.dtype));
  }
  var selectConfig2 = {
    kernelName: Select,
    backendName: "webgl",
    kernelFunc: select3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js
  var SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${backend_util_exports.SELU_SCALEALPHA};
  float scale = ${backend_util_exports.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
  var selu3 = unaryKernelFunc2({ opSnippet: SELU });
  var seluConfig2 = {
    kernelName: Selu,
    backendName: "webgl",
    kernelFunc: selu3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js
  var SIGMOID3 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
  var sigmoid3 = unaryKernelFunc2({
    opSnippet: SIGMOID3,
    packedOpSnippet: SIGMOID3,
    cpuKernelImpl: sigmoidImplCPU
  });
  var sigmoidConfig2 = {
    kernelName: Sigmoid,
    backendName: "webgl",
    kernelFunc: sigmoid3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js
  var SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`;
  var sign3 = unaryKernelFunc2({ opSnippet: SIGN });
  var signConfig2 = {
    kernelName: Sign,
    backendName: "webgl",
    kernelFunc: sign3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js
  var SIN = CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
  var sin4 = unaryKernelFunc2({ opSnippet: SIN });
  var sinConfig2 = {
    kernelName: Sin,
    backendName: "webgl",
    kernelFunc: sin4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js
  var SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`;
  var sinh3 = unaryKernelFunc2({ opSnippet: SINH });
  var sinhConfig2 = {
    kernelName: Sinh,
    backendName: "webgl",
    kernelFunc: sinh3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js
  var SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`;
  var softplus3 = unaryKernelFunc2({ opSnippet: SOFTPLUS });
  var softplusConfig2 = {
    kernelName: Softplus,
    backendName: "webgl",
    kernelFunc: softplus3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js
  var spaceToBatchND3 = (args) => {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { blockShape, paddings } = attrs;
    util_exports2.assert(x.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
    const prod4 = blockShape.reduce((a, b) => a * b);
    const completePaddings = [[0, 0]];
    completePaddings.push(...paddings);
    for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {
      completePaddings.push([0, 0]);
    }
    const toDispose = [];
    const paddedX = padV22({
      inputs: { x },
      backend: backend2,
      attrs: { paddings: completePaddings, constantValue: 0 }
    });
    const reshapedPaddedShape = backend_util_exports.getReshaped(paddedX.shape, blockShape, prod4, false);
    const permutedReshapedPaddedPermutation = backend_util_exports.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
    const flattenShape = backend_util_exports.getReshapedPermuted(paddedX.shape, blockShape, prod4, false);
    const reshapedPaddedX = reshape3({ inputs: { x: paddedX }, backend: backend2, attrs: { shape: reshapedPaddedShape } });
    const paddedXT = transpose4({
      inputs: { x: reshapedPaddedX },
      backend: backend2,
      attrs: { perm: permutedReshapedPaddedPermutation }
    });
    const result = reshape3({ inputs: { x: paddedXT }, backend: backend2, attrs: { shape: flattenShape } });
    toDispose.push(paddedX);
    toDispose.push(reshapedPaddedX);
    toDispose.push(paddedXT);
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  };
  var spaceToBatchNDConfig2 = {
    kernelName: SpaceToBatchND,
    backendName: "webgl",
    kernelFunc: spaceToBatchND3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseFillEmptyRows.js
  function sparseFillEmptyRows2(args) {
    const { inputs, backend: backend2 } = args;
    const { indices, values: values2, denseShape, defaultValue } = inputs;
    if (denseShape.shape.length !== 1) {
      throw new Error(`Dense shape must be a vector, saw:
         ${denseShape.shape}`);
    }
    if (indices.shape.length !== 2) {
      throw new Error(`Indices must be a matrix, saw:
         ${indices.shape}`);
    }
    if (values2.shape.length !== 1) {
      throw new Error(`Values must be a vector, saw:
         ${values2.shape}`);
    }
    if (defaultValue.shape.length !== 0) {
      throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
    }
    const $indices = backend2.readSync(indices.dataId);
    const $values = backend2.readSync(values2.dataId);
    const $denseShape = backend2.readSync(denseShape.dataId);
    const $defaultValue = backend2.readSync(defaultValue.dataId)[0];
    const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values2.dtype, $denseShape, $defaultValue);
    return [
      backend2.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
      backend2.makeTensorInfo([outputIndicesShape[0]], values2.dtype, outputValues),
      backend2.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
      backend2.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
    ];
  }
  var sparseFillEmptyRowsConfig2 = {
    kernelName: SparseFillEmptyRows,
    backendName: "webgl",
    kernelFunc: sparseFillEmptyRows2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseReshape.js
  function sparseReshape2(args) {
    const { inputs, backend: backend2 } = args;
    const { inputIndices, inputShape, newShape } = inputs;
    if (inputIndices.shape.length !== 2) {
      throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
    }
    if (inputShape.shape.length !== 1) {
      throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
    }
    if (newShape.shape.length !== 1) {
      throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
    }
    const $inputShape = Array.from(backend2.readSync(inputShape.dataId));
    const $inputIndices = backend2.readSync(inputIndices.dataId);
    const targetShape = Array.from(backend2.readSync(newShape.dataId));
    const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
    return [
      backend2.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
      backend2.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
    ];
  }
  var sparseReshapeConfig2 = {
    kernelName: SparseReshape,
    backendName: "webgl",
    kernelFunc: sparseReshape2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentMean.js
  function sparseSegmentMean2(args) {
    const { inputs, backend: backend2 } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
              ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
              ${segmentIds.shape}`);
    }
    const $data = backend2.readSync(data.dataId);
    const $indices = backend2.readSync(indices.dataId);
    const $segmentIds = backend2.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds, true);
    return backend2.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  var sparseSegmentMeanConfig2 = {
    kernelName: SparseSegmentMean,
    backendName: "webgl",
    kernelFunc: sparseSegmentMean2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentSum.js
  function sparseSegmentSum2(args) {
    const { inputs, backend: backend2 } = args;
    const { data, indices, segmentIds } = inputs;
    if (data.shape.length < 1) {
      throw new Error(`Data should be at least 1 dimensional but received scalar`);
    }
    if (indices.shape.length !== 1) {
      throw new Error(`Indices should be a vector but received shape
             ${indices.shape}`);
    }
    if (segmentIds.shape.length !== 1) {
      throw new Error(`Segment ids should be a vector but received shape
             ${segmentIds.shape}`);
    }
    const $data = backend2.readSync(data.dataId);
    const $indices = backend2.readSync(indices.dataId);
    const $segmentIds = backend2.readSync(segmentIds.dataId);
    const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds);
    return backend2.makeTensorInfo(outputDataShape, data.dtype, outputData);
  }
  var sparseSegmentSumConfig2 = {
    kernelName: SparseSegmentSum,
    backendName: "webgl",
    kernelFunc: sparseSegmentSum2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js
  function sparseToDense2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { sparseIndices, sparseValues, defaultValue } = inputs;
    const { outputShape } = attrs;
    const { sliceRank, numUpdates, strides, outputSize } = backend_util_exports.calculateShapes(sparseValues, sparseIndices, outputShape);
    const sumDupeIndices = false;
    const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);
    const res = backend2.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
    const reshaped = reshape3({ inputs: { x: res }, backend: backend2, attrs: { shape: outputShape } });
    backend2.disposeIntermediateTensorInfo(res);
    return reshaped;
  }
  var sparseToDenseConfig2 = {
    kernelName: SparseToDense,
    backendName: "webgl",
    kernelFunc: sparseToDense2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js
  function splitV2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { numOrSizeSplits, axis } = attrs;
    const $axis = util_exports2.parseAxisParam(axis, x.shape)[0];
    const splitSizes = backend_util_exports.prepareSplitSize(x, numOrSizeSplits, $axis);
    const xRank = x.shape.length;
    const begin = new Array(xRank).fill(0);
    const size3 = x.shape.slice();
    return splitSizes.map((s) => {
      const sliceSize = [...size3];
      sliceSize[$axis] = s;
      const sliceT = slice3({ inputs: { x }, backend: backend2, attrs: { begin, size: sliceSize } });
      begin[$axis] += s;
      return sliceT;
    });
  }
  var splitVConfig2 = {
    kernelName: SplitV,
    backendName: "webgl",
    kernelFunc: splitV2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js
  var SQRT = `return sqrt(x);`;
  var sqrt3 = unaryKernelFunc2({ opSnippet: SQRT, packedOpSnippet: SQRT, cpuKernelImpl: sqrtImplCPU });
  var sqrtConfig2 = {
    kernelName: Sqrt,
    backendName: "webgl",
    kernelFunc: sqrt3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js
  var SQUARE = `return x * x;`;
  var square3 = unaryKernelFunc2({ opSnippet: SQUARE });
  var squareConfig2 = {
    kernelName: Square,
    backendName: "webgl",
    kernelFunc: square3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js
  var SQUARED_DIFFERENCE = "return (a - b) * (a - b);";
  var squaredDifference3 = binaryKernelFunc2({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
  var squaredDifferenceConfig2 = {
    kernelName: SquaredDifference,
    backendName: "webgl",
    kernelFunc: squaredDifference3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js
  function step3({ inputs, attrs, backend: backend2 }) {
    const { x } = inputs;
    const opSnippet = CHECK_NAN_SNIPPET + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
    const program = new UnaryOpProgram(x.shape, opSnippet);
    return backend2.runWebGLProgram(program, [x], x.dtype);
  }
  var stepConfig2 = {
    kernelName: Step,
    backendName: "webgl",
    kernelFunc: step3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js
  var StridedSliceProgram = class {
    constructor(begin, strides, size3) {
      this.variableNames = ["x"];
      this.outputShape = size3;
      const rank = size3.length;
      const inputDtype = getCoordsDataType(size3.length);
      const dtype = getCoordsDataType(size3.length);
      let newCoords = "";
      if (rank === 1) {
        newCoords = "coords * strides + begin";
      } else {
        let outputAxis = 0;
        newCoords = size3.map((_6, i) => {
          outputAxis++;
          return size3.length === 1 ? `coords * strides[${i}] + begin[${i}]` : `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
        }).join(",");
      }
      this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js
  function stridedSlice3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
    const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = slice_util_exports.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
    let result;
    if (isIdentity) {
      result = reshape3({ inputs: { x }, backend: backend2, attrs: { shape: finalShape } });
    } else if (sliceDim0 || isSimpleSlice) {
      util_exports2.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);
      const size3 = slice_util_exports.computeOutShape($begin, $end, $strides);
      const sliced = slice3({ inputs: { x }, backend: backend2, attrs: { begin: $begin, size: size3 } });
      result = reshape3({ inputs: { x: sliced }, backend: backend2, attrs: { shape: finalShape } });
      backend2.disposeIntermediateTensorInfo(sliced);
    } else {
      const shouldExecuteOnCPU = backend2.shouldExecuteOnCPU([x]);
      if (shouldExecuteOnCPU) {
        const values2 = backend2.readSync(x.dataId);
        const xBuf = buffer2(x.shape, x.dtype, values2);
        const resultValues = stridedSliceImplCPU(finalShapeSparse, xBuf, $strides, $begin);
        result = backend2.makeTensorInfo(finalShape, x.dtype, resultValues.values);
      } else {
        const program = new StridedSliceProgram($begin, $strides, finalShapeSparse);
        result = backend2.runWebGLProgram(program, [x], x.dtype);
      }
    }
    const resultReshaped = reshape3({ inputs: { x: result }, backend: backend2, attrs: { shape: finalShape } });
    backend2.disposeIntermediateTensorInfo(result);
    return resultReshaped;
  }
  var stridedSliceConfig2 = {
    kernelName: StridedSlice,
    backendName: "webgl",
    kernelFunc: stridedSlice3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringNGrams.js
  function stringNGrams2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
    const { data, dataSplits } = inputs;
    const $data = backend2.readSync(data.dataId);
    const $dataSplits = backend2.readSync(dataSplits.dataId);
    const [nGrams, nGramsSplits] = stringNGramsImplCPU($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
    return [
      backend2.makeTensorInfo([nGrams.length], "string", nGrams),
      backend2.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
    ];
  }
  var stringNGramsConfig2 = {
    kernelName: StringNGrams,
    backendName: "webgl",
    kernelFunc: stringNGrams2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringSplit.js
  function stringSplit2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { skipEmpty } = attrs;
    const { input: input2, delimiter } = inputs;
    if (input2.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (input2.shape.length !== 1) {
      throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
    }
    if (delimiter.shape.length !== 0) {
      throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
    }
    const $input = backend2.readSync(input2.dataId);
    const $delimiter = backend2.readSync(delimiter.dataId)[0];
    const [indices, values2, shape] = stringSplitImplCPU($input, $delimiter, skipEmpty);
    const outputSize = values2.length;
    return [
      backend2.makeTensorInfo([outputSize, 2], "int32", indices),
      backend2.makeTensorInfo([outputSize], "string", values2),
      backend2.makeTensorInfo([2], "int32", new Int32Array(shape))
    ];
  }
  var stringSplitConfig2 = {
    kernelName: StringSplit,
    backendName: "webgl",
    kernelFunc: stringSplit2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringToHashBucketFast.js
  function stringToHashBucketFast2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { numBuckets } = attrs;
    const { input: input2 } = inputs;
    if (input2.dtype !== "string") {
      throw new Error("Input must be of datatype string");
    }
    if (numBuckets <= 0) {
      throw new Error(`Number of buckets must be at least 1`);
    }
    const $input = backend2.readSync(input2.dataId);
    const output = stringToHashBucketFastImplCPU($input, numBuckets);
    return backend2.makeTensorInfo(input2.shape, "int32", output);
  }
  var stringToHashBucketFastConfig2 = {
    kernelName: StringToHashBucketFast,
    backendName: "webgl",
    kernelFunc: stringToHashBucketFast2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js
  var TAN = `return tan(x);`;
  var tan3 = unaryKernelFunc2({ opSnippet: TAN });
  var tanConfig2 = {
    kernelName: Tan,
    backendName: "webgl",
    kernelFunc: tan3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js
  var TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`;
  var tanh4 = unaryKernelFunc2({ opSnippet: TANH });
  var tanhConfig2 = {
    kernelName: Tanh,
    backendName: "webgl",
    kernelFunc: tanh4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js
  var TileProgram = class {
    constructor(aShape, reps) {
      this.variableNames = ["A"];
      const outputShape = new Array(aShape.length);
      for (let i = 0; i < outputShape.length; i++) {
        outputShape[i] = aShape[i] * reps[i];
      }
      this.outputShape = outputShape;
      this.rank = outputShape.length;
      const dtype = getCoordsDataType(this.rank);
      const sourceCoords = getSourceCoords3(aShape);
      this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
    }
  };
  function getSourceCoords3(aShape) {
    const rank = aShape.length;
    if (rank > 5) {
      throw Error(`Tile for rank ${rank} is not yet supported`);
    }
    if (rank === 1) {
      return `imod(resRC, ${aShape[0]})`;
    }
    const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
    const sourceCoords = [];
    for (let i = 0; i < aShape.length; i++) {
      sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
    }
    return sourceCoords.join();
  }

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js
  function tile4(params) {
    const { inputs, backend: backend2, attrs } = params;
    const { x } = inputs;
    const { reps } = attrs;
    if (x.dtype === "string" || x.shape.length > 5) {
      const data = backend2.readSync(x.dataId);
      const value = x.dtype === "string" ? data.map((d) => util_exports2.decodeString(d)) : data;
      const buf = buffer2(x.shape, x.dtype, value);
      const outBuf = tileImplCPU(buf, reps);
      return backend2.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
    }
    const program = new TileProgram(x.shape, reps);
    const output = backend2.runWebGLProgram(program, [x], x.dtype);
    return output;
  }
  var tileConfig2 = {
    kernelName: Tile,
    backendName: "webgl",
    kernelFunc: tile4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/top_k_gpu.js
  var SwapProgram = class {
    constructor(shape) {
      this.variableNames = ["x", "indices"];
      this.customUniforms = [
        { name: "n", type: "int" },
        { name: "firstPass", type: "int" },
        { name: "negativeInf", type: "float" },
        { name: "dir", type: "int" },
        { name: "inc", type: "int" }
      ];
      this.outputShape = shape;
      this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
  };
  var MergeProgram = class {
    constructor(shape) {
      this.variableNames = ["x", "indices"];
      this.customUniforms = [
        { name: "n", type: "int" },
        { name: "firstPass", type: "int" },
        { name: "k", type: "int" }
      ];
      this.outputShape = shape;
      this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js
  function disposeIntermediateTensorInfoOrNull(backend2, tensorInfo) {
    if (tensorInfo !== null) {
      backend2.disposeIntermediateTensorInfo(tensorInfo);
    }
  }
  function roundUpToPow2(num) {
    let pow22 = 1;
    while (pow22 < num) {
      pow22 *= 2;
    }
    return pow22;
  }
  function topK2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x } = inputs;
    const { k, sorted } = attrs;
    const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");
    const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");
    const xShape = x.shape;
    const lastDim = xShape[xShape.length - 1];
    if (backend2.shouldExecuteOnCPU([x]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k > TOPK_K_CPU_HANDOFF_THRESHOLD) {
      const xVals = backend2.readSync(x.dataId);
      const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k, sorted);
      return [
        backend2.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
        backend2.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
      ];
    }
    if (k === 0) {
      xShape[xShape.length - 1] = 0;
      return [
        backend2.makeTensorInfo(xShape, x.dtype, []),
        backend2.makeTensorInfo(xShape, "int32", [])
      ];
    }
    if (lastDim === 1) {
      return [
        x,
        fill3({ attrs: { shape: xShape, dtype: "int32", value: 0 }, backend: backend2 })
      ];
    }
    const xtexData = backend2.texData.get(x.dataId);
    const xIsPacked = xtexData !== null && xtexData.isPacked;
    const xUnPacked = xIsPacked ? backend2.unpackTensor(x) : x;
    const xSize = util_exports2.sizeFromShape(xShape);
    const batch = xSize / lastDim;
    const x2D = reshape3({ inputs: { x: xUnPacked }, attrs: { shape: [batch, lastDim] }, backend: backend2 });
    if (xIsPacked) {
      disposeIntermediateTensorInfoOrNull(backend2, xUnPacked);
    }
    const kPow2 = roundUpToPow2(k);
    const lastDimPow2 = roundUpToPow2(lastDim);
    let indices = null;
    const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
    const runSwap = (dir, inc, shape) => {
      const inputs2 = getInputs();
      const program = new SwapProgram(shape);
      const fistPass = indices === null ? 1 : 0;
      const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];
      const prevIndices2 = indices;
      indices = backend2.runWebGLProgram(program, inputs2, "int32", customValues);
      disposeIntermediateTensorInfoOrNull(backend2, prevIndices2);
    };
    for (let len3 = 1; len3 < kPow2; len3 *= 2) {
      const dir = len3 * 2;
      for (let inc = len3; inc >= 1; inc /= 2) {
        runSwap(dir, inc, [batch, lastDimPow2]);
      }
    }
    for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {
      const inputs2 = getInputs();
      const mergeProgram = new MergeProgram([batch, indicesSize / 2]);
      const firstPass = indices === null ? 1 : 0;
      const customValues = [[lastDim], [firstPass], [kPow2]];
      const prevIndices2 = indices;
      indices = backend2.runWebGLProgram(mergeProgram, inputs2, "int32", customValues);
      disposeIntermediateTensorInfoOrNull(backend2, prevIndices2);
      const len3 = kPow2 / 2;
      const dir = len3 * 2;
      for (let inc = len3; inc >= 1; inc /= 2) {
        runSwap(dir, inc, indices.shape);
      }
    }
    let prevIndices = indices;
    indices = slice3({ inputs: { x: indices }, backend: backend2, attrs: { begin: 0, size: [batch, k] } });
    disposeIntermediateTensorInfoOrNull(backend2, prevIndices);
    let values2 = gatherV22({ inputs: { x: x2D, indices }, backend: backend2, attrs: { axis: 1, batchDims: 1 } });
    disposeIntermediateTensorInfoOrNull(backend2, x2D);
    const newShape = xShape.slice(0, -1);
    newShape.push(k);
    prevIndices = indices;
    indices = reshape3({ inputs: { x: indices }, attrs: { shape: newShape }, backend: backend2 });
    disposeIntermediateTensorInfoOrNull(backend2, prevIndices);
    const prevValues = values2;
    values2 = reshape3({ inputs: { x: values2 }, attrs: { shape: newShape }, backend: backend2 });
    disposeIntermediateTensorInfoOrNull(backend2, prevValues);
    return [values2, indices];
  }
  var topKConfig2 = {
    kernelName: TopK,
    backendName: "webgl",
    kernelFunc: topK2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/transform_gpu.js
  var TransformProgram = class {
    constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {
      this.variableNames = ["Image", "Transforms"];
      this.outputShape = outShape;
      const interpolationModeId = interpolation === "nearest" ? 1 : 2;
      let fillModeId;
      switch (fillMode) {
        case "constant":
          fillModeId = 1;
          break;
        case "reflect":
          fillModeId = 2;
          break;
        case "wrap":
          fillModeId = 3;
          break;
        case "nearest":
          fillModeId = 4;
          break;
        default:
          fillModeId = 1;
          break;
      }
      this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${fillModeId} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${fillValue});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${fillValue});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${imageWidth}));
                float mapY = mapCoord(inY, float(${imageHeight}));

                if (${interpolationModeId} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transform.js
  function transform8(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { image: image3, transforms } = inputs;
    const { interpolation, fillMode, fillValue, outputShape } = attrs;
    const [batch, imageHeight, imageWidth, numChannels] = image3.shape;
    const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
    const outShape = [
      batch,
      outHeight,
      outWidth,
      numChannels
    ];
    const program = new TransformProgram(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
    return backend2.runWebGLProgram(program, [image3, transforms], "float32");
  }
  var transformConfig2 = {
    kernelName: Transform,
    backendName: "webgl",
    kernelFunc: transform8
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js
  function unique4(args) {
    const { inputs, attrs, backend: backend2 } = args;
    const { axis } = attrs;
    const { x } = inputs;
    assertNotComplex2(x, "unique");
    console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
    const values2 = backend2.readSync(x.dataId);
    const { outputValues, outputShape, indices } = uniqueImplCPU(values2, axis, x.shape, x.dtype);
    return [
      backend2.makeTensorInfo(outputShape, x.dtype, outputValues),
      backend2.makeTensorInfo([indices.length], "int32", indices)
    ];
  }
  var uniqueConfig2 = {
    kernelName: Unique,
    backendName: "webgl",
    kernelFunc: unique4
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js
  function unpack2(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { value } = inputs;
    let { axis } = attrs;
    if (axis < 0) {
      axis += value.shape.length;
    }
    const x = value;
    const xRank = x.shape.length;
    const num = value.shape[axis];
    const outShape = new Array(xRank - 1);
    let outIndex = 0;
    for (let i = 0; i < xRank; i++) {
      if (i !== axis) {
        outShape[outIndex++] = x.shape[i];
      }
    }
    const toDispose = [];
    const begin = new Array(xRank).fill(0);
    const size3 = x.shape.slice();
    size3[axis] = 1;
    const res = new Array(num);
    for (let i = 0; i < res.length; i++) {
      begin[axis] = i;
      const sliced = slice3({ inputs: { x }, backend: backend2, attrs: { begin, size: size3 } });
      const reshaped = reshape3({ inputs: { x: sliced }, backend: backend2, attrs: { shape: outShape } });
      res[i] = reshaped;
      toDispose.push(sliced);
    }
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return res;
  }
  var unpackConfig2 = {
    kernelName: Unpack,
    backendName: "webgl",
    kernelFunc: unpack2
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js
  var SegmentOpProgram = class {
    constructor(segOpInfo, segOpType) {
      this.variableNames = ["x", "segmentIds"];
      const windowSize = segOpInfo.windowSize;
      const batchSize = segOpInfo.batchSize;
      const inSize = segOpInfo.inSize;
      const numSegments = segOpInfo.numSegments;
      const outSize = numSegments * Math.ceil(inSize / windowSize);
      this.outputShape = [batchSize, outSize];
      const initializationValue = "0.0";
      const returnValue = `sumValue`;
      const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
      const windowSizeVec4Remainder = windowSize % 4;
      const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
      let checkValueOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
      }
      let checkSegmentIdOutOfBounds = "";
      if (inSize % windowSize > 0) {
        checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
      }
      this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
    }
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js
  function unsortedSegmentSum3(args) {
    const { inputs, backend: backend2, attrs } = args;
    const { x, segmentIds } = inputs;
    const { numSegments } = attrs;
    const xRank = x.shape.length;
    const toDispose = [];
    let axis = 0;
    const permutation = backend_util_exports.getAxesPermutation([axis], xRank);
    let permutedX = x;
    if (permutation != null) {
      permutedX = transpose4({ inputs: { x }, backend: backend2, attrs: { perm: permutation } });
      toDispose.push(permutedX);
      axis = backend_util_exports.getInnerMostAxes(1, xRank)[0];
    }
    const outShape = backend_util_exports.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
    const inSize = util_exports2.sizeFromShape([permutedX.shape[axis]]);
    const a2D = reshape3({ inputs: { x: permutedX }, backend: backend2, attrs: { shape: [-1, inSize] } });
    toDispose.push(a2D);
    const outputDType = sumOutType(x.dtype);
    const segOpCompute = (x2, segOpType, segmentIds2, dtype, numSegments2) => {
      const batchSize = x2.shape[0];
      const inSize2 = x2.shape[1];
      const windowSize = backend_util_exports.segment_util.segOpComputeOptimalWindowSize(inSize2, numSegments2);
      const segOpInfo = { windowSize, inSize: inSize2, batchSize, numSegments: numSegments2 };
      const program = new SegmentOpProgram(segOpInfo, segOpType);
      const output = backend2.compileAndRun(program, [x2, segmentIds2], dtype);
      toDispose.push(output);
      if (output.shape[1] === numSegments2) {
        return output;
      }
      const rangeInfo = range4({
        backend: backend2,
        attrs: { start: 0, stop: numSegments2, step: 1, dtype: "float32" }
      });
      const tileInfo = tile4({
        inputs: { x: rangeInfo },
        backend: backend2,
        attrs: { reps: [inSize2 / windowSize] }
      });
      toDispose.push(rangeInfo);
      toDispose.push(tileInfo);
      const result2 = segOpCompute(output, segOpType, tileInfo, dtype, numSegments2);
      return result2;
    };
    const segOpResult = segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments);
    const reshaped = reshape3({ inputs: { x: segOpResult }, backend: backend2, attrs: { shape: outShape } });
    let result = reshaped;
    if (permutation != null) {
      toDispose.push(reshaped);
      const perm = backend_util_exports.getUndoAxesPermutation(permutation);
      result = transpose4({ inputs: { x: result }, backend: backend2, attrs: { perm } });
    }
    toDispose.forEach((t) => backend2.disposeIntermediateTensorInfo(t));
    return result;
  }
  var unsortedSegmentSumConfig2 = {
    kernelName: UnsortedSegmentSum,
    backendName: "webgl",
    kernelFunc: unsortedSegmentSum3
  };

  // node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js
  var kernelConfigs2 = [
    LRNConfig,
    LRNGradConfig,
    _fusedMatMulConfig2,
    absConfig2,
    acosConfig2,
    acoshConfig2,
    addConfig2,
    addNConfig2,
    allConfig2,
    anyConfig2,
    argMaxConfig2,
    argMinConfig2,
    asinConfig2,
    asinhConfig2,
    atan2Config2,
    atanConfig2,
    atanhConfig2,
    avgPool3DConfig2,
    avgPoolConfig2,
    avgPoolGrad3DConfig,
    avgPoolGradConfig3,
    batchMatMulConfig2,
    batchNormConfig2,
    batchToSpaceNDConfig2,
    bincountConfig2,
    broadcastArgsConfig2,
    castConfig2,
    ceilConfig2,
    clipByValueConfig,
    complexAbsConfig2,
    complexConfig2,
    concatConfig2,
    conv2DBackpropFilterConfig2,
    conv2DBackpropInputConfig2,
    conv2DConfig2,
    conv3DBackpropFilterV2Config2,
    conv3DBackpropInputConfig,
    conv3DConfig2,
    cosConfig2,
    coshConfig2,
    cropAndResizeConfig2,
    cumsumConfig2,
    denseBincountConfig2,
    depthToSpaceConfig2,
    depthwiseConv2dNativeBackpropFilterConfig2,
    depthwiseConv2dNativeBackpropInputConfig2,
    depthwiseConv2dNativeConfig2,
    diagConfig2,
    dilation2DConfig,
    einsumConfig2,
    eluConfig2,
    eluGradConfig3,
    equalConfig2,
    erfConfig2,
    expConfig2,
    expandDimsConfig2,
    expm1Config2,
    fftConfig2,
    fillConfig2,
    flipLeftRightConfig2,
    floorConfig2,
    floorDivConfig2,
    fromPixelsConfig,
    fusedConv2DConfig2,
    fusedDepthwiseConv2DConfig2,
    gatherNdConfig2,
    gatherV2Config2,
    greaterConfig2,
    greaterEqualConfig2,
    identityConfig2,
    ifftConfig2,
    imagConfig2,
    isFiniteConfig2,
    isInfConfig2,
    isNaNConfig2,
    leakyReluConfig2,
    lessConfig2,
    lessEqualConfig2,
    linSpaceConfig2,
    log1pConfig2,
    logConfig2,
    logicalAndConfig2,
    logicalNotConfig2,
    logicalOrConfig2,
    maxConfig2,
    maxPool3DConfig2,
    maxPoolConfig2,
    maxPoolGrad3DConfig,
    maxPoolGradConfig3,
    maxPoolWithArgmaxConfig2,
    maximumConfig2,
    meanConfig2,
    minConfig2,
    minimumConfig2,
    mirrorPadConfig2,
    modConfig2,
    multinomialConfig2,
    multiplyConfig2,
    negConfig2,
    nonMaxSuppressionV3Config2,
    nonMaxSuppressionV4Config2,
    nonMaxSuppressionV5Config2,
    notEqualConfig2,
    oneHotConfig2,
    onesLikeConfig2,
    packConfig2,
    padV2Config2,
    powConfig2,
    preluConfig2,
    prodConfig2,
    rangeConfig2,
    realConfig2,
    realDivConfig2,
    reciprocalConfig2,
    relu6Config2,
    reluConfig2,
    reshapeConfig2,
    resizeBilinearConfig2,
    resizeBilinearGradConfig3,
    resizeNearestNeighborConfig2,
    resizeNearestNeighborGradConfig3,
    reverseConfig2,
    rotateWithOffsetConfig2,
    roundConfig2,
    rsqrtConfig2,
    scatterNdConfig2,
    selectConfig2,
    seluConfig2,
    sigmoidConfig2,
    signConfig2,
    sinConfig2,
    sinhConfig2,
    sliceConfig2,
    softmaxConfig2,
    softplusConfig2,
    spaceToBatchNDConfig2,
    sparseFillEmptyRowsConfig2,
    sparseReshapeConfig2,
    sparseSegmentMeanConfig2,
    sparseSegmentSumConfig2,
    sparseToDenseConfig2,
    splitVConfig2,
    sqrtConfig2,
    squareConfig2,
    squaredDifferenceConfig2,
    stepConfig2,
    stridedSliceConfig2,
    stringNGramsConfig2,
    stringSplitConfig2,
    stringToHashBucketFastConfig2,
    subConfig2,
    sumConfig2,
    tanConfig2,
    tanhConfig2,
    tileConfig2,
    topKConfig2,
    transformConfig2,
    transposeConfig2,
    uniqueConfig2,
    unpackConfig2,
    unsortedSegmentSumConfig2,
    zerosLikeConfig2
  ];
  for (const kernelConfig of kernelConfigs2) {
    registerKernel(kernelConfig);
  }

  // hw3/client/dev/app.tsx
  var ZipfChart = defineComponent((_6, { slots }) => {
    const chartRef = ref(null);
    let chart;
    const tokenNum = ref(1);
    const range5 = ref({ min: 1, max: 1 });
    const useStemmer = ref(true);
    let zipf = [];
    onMounted(() => {
      chart = new chart_default({
        container: chartRef.value,
        autoFit: true,
        height: 200
      });
      changeStemmer(true);
    });
    const inputMin = (e) => {
      range5.value = { min: Number(e.target.value), max: range5.value.max };
      chart.data(zipf.slice(range5.value.min - 1, range5.value.max));
      chart.render();
    };
    const inputMax = (e) => {
      range5.value = { max: Number(e.target.value), min: range5.value.min };
      chart.data(zipf.slice(range5.value.min - 1, range5.value.max));
      chart.render();
    };
    const changeStemmer = (_useStemmer) => {
      useStemmer.value = _useStemmer;
      slots.changeStemmer(useStemmer.value);
      fetch(`./zipf/${_useStemmer}`).then((res) => res.json()).then((zipfData) => {
        zipf = zipfData;
        tokenNum.value = zipf.length;
        range5.value = {
          min: Math.ceil(tokenNum.value * 0.01),
          max: Math.ceil(tokenNum.value * 0.05)
        };
        chart.data(zipf.slice(range5.value.min - 1, range5.value.max));
        chart.scale("count", {
          nice: true
        });
        chart.tooltip({
          showMarkers: false
        });
        chart.interaction("active-region");
        chart.interval().position("token*count");
        chart.render();
      });
    };
    return () => /* @__PURE__ */ h("div", {
      style: "position: relative;"
    }, /* @__PURE__ */ h("div", {
      ref: chartRef
    }), /* @__PURE__ */ h("br", null), /* @__PURE__ */ h("input", {
      type: "number",
      value: range5.value.min,
      max: range5.value.max,
      min: "1",
      step: "1",
      onChange: inputMin
    }), /* @__PURE__ */ h("button", {
      style: [
        "position: absolute;",
        "left: 50%;",
        "transform: translate(-50%,0%);"
      ],
      class: [useStemmer.value ? "on" : ""],
      onClick: () => changeStemmer(!useStemmer.value)
    }, "stemmer"), /* @__PURE__ */ h("input", {
      type: "number",
      value: range5.value.max,
      max: tokenNum.value,
      min: range5.value.min,
      step: "1",
      onChange: inputMax,
      style: "right:0px; position: absolute;"
    }));
  });
  var App = defineComponent((_6, { slots }) => {
    let keyWord = ref("");
    let targetKeyWord = ref("");
    let embBook = [];
    let vocab = [];
    let candidate = ref([]);
    let targetCandidate = ref([]);
    let showingCand = ref(false);
    let showingTargetCand = ref(false);
    let showingTargetSearch = ref(false);
    const chartRef = ref(null);
    let chart;
    const range5 = ref({ start: 1, win: 100 });
    let sortedSims;
    let tokenNum = ref(0);
    let simWithTarget = ref(NaN);
    onMounted(() => {
      chart = new chart_default({
        container: chartRef.value,
        autoFit: true,
        height: 200
      });
    });
    const inputStart = (e) => {
      range5.value = { start: Number(e.target.value), win: range5.value.win };
      chart.data(sortedSims.slice(range5.value.start, range5.value.start + range5.value.win));
      chart.render();
    };
    const inputWin = (e) => {
      range5.value = { win: Number(e.target.value), start: range5.value.start };
      chart.data(sortedSims.slice(range5.value.start, range5.value.start + range5.value.win));
      chart.render();
    };
    let search = (e) => {
      showingTargetCand.value = false;
      showingTargetSearch.value = false;
      if (e.target.value != "") {
        keyWord.value = e.target.value;
        showingCand.value = true;
        candidate.value = vocab.map((token2) => ({
          token: token2,
          distance: levenshteinDistance3(keyWord.value.toLowerCase(), token2.toLowerCase())
        })).sort((a, b) => a.distance - b.distance).slice(0, 10).map(({ token: token2 }) => token2);
        console.log("search");
      }
    };
    let searchTarget = (e) => {
      if (e.target.value != "") {
        targetKeyWord.value = e.target.value;
        showingTargetCand.value = true;
        targetCandidate.value = vocab.map((token2) => ({
          token: token2,
          distance: levenshteinDistance3(targetKeyWord.value.toLowerCase(), token2.toLowerCase())
        })).sort((a, b) => a.distance - b.distance).slice(0, 10).map(({ token: token2 }) => token2);
        console.log("search target");
      }
    };
    let calcEmbSimWithVocab = (query) => {
      let idx = vocab.findIndex((target) => target.toLowerCase() == query.toLowerCase());
      if (idx != -1) {
        let sims = tidy(() => {
          let a = tensor2d([embBook[idx]]);
          let b = tensor2d(embBook);
          return a.mul(b).sum(1).divNoNan(a.square().sum(1).sqrt().mul(b.square().sum(1).sqrt())).arraySync();
        });
        sortedSims = sims.map((sim, idx2) => ({ token: vocab[idx2], sim })).sort((a, b) => b.sim - a.sim);
        console.log(sortedSims);
        chart.data(sortedSims.slice(range5.value.start, range5.value.start + range5.value.win));
        chart.scale("sim", {
          nice: true
        });
        chart.tooltip({
          showMarkers: false
        });
        chart.interaction("active-region");
        chart.interval().position("token*sim");
        chart.render();
      }
    };
    let calcEmbSim = (query, target) => {
      let qidx = vocab.findIndex((token2) => token2.toLowerCase() == query.toLowerCase());
      let tidx = vocab.findIndex((token2) => token2.toLowerCase() == target.toLowerCase());
      if (qidx != -1 && tidx != -1) {
        simWithTarget.value = tidy(() => {
          let a = tensor1d(embBook[qidx]);
          let b = tensor1d(embBook[tidx]);
          return a.mul(b).sum().divNoNan(a.square().sum().sqrt().mul(b.square().sum().sqrt())).arraySync();
        });
      }
    };
    const loadEmbedding = () => {
      console.log("embedding");
      let load = document.createElement("input");
      load.type = "file";
      load.accept = ".tsv";
      load.onchange = (event) => {
        const files = load.files;
        var reader = new FileReader();
        reader.addEventListener("loadend", () => {
          embBook = parserVector(reader.result);
          console.log("embedding loadend");
        });
        reader.readAsText(files[0]);
      };
      load.click();
    };
    const loadMetadata = () => {
      console.log("matedata");
      let load = document.createElement("input");
      load.type = "file";
      load.accept = ".tsv";
      load.onchange = (event) => {
        const files = load.files;
        var reader = new FileReader();
        reader.addEventListener("loadend", () => {
          vocab = parserMetadata(reader.result);
          tokenNum.value = vocab.length;
          console.log("matedata loadend");
        });
        reader.readAsText(files[0]);
      };
      load.click();
    };
    return () => /* @__PURE__ */ h("div", {
      class: "app"
    }, /* @__PURE__ */ h("div", {
      style: "position: relative;"
    }, /* @__PURE__ */ h("div", {
      ref: chartRef
    }), /* @__PURE__ */ h("br", null), /* @__PURE__ */ h("input", {
      type: "number",
      value: range5.value.start,
      max: tokenNum.value,
      min: "1",
      step: "1",
      onInput: inputStart
    }), /* @__PURE__ */ h("input", {
      type: "number",
      value: range5.value.win,
      max: tokenNum.value,
      min: "1",
      step: "1",
      onInput: inputWin,
      style: "right:0px; position: absolute;"
    })), /* @__PURE__ */ h("br", null), /* @__PURE__ */ h("button", {
      style: "display: block; margin-left: auto; margin-right: auto;",
      onClick: loadEmbedding
    }, "load embedding"), /* @__PURE__ */ h("button", {
      style: "display: block; margin-left: auto; margin-right: auto;",
      onClick: loadMetadata
    }, "load metadata"), /* @__PURE__ */ h("input", {
      type: "text",
      onInput: search,
      placeholder: "Search",
      value: keyWord.value
    }), /* @__PURE__ */ h("ol", {
      style: [showingCand.value ? "" : "display:none;"]
    }, candidate.value.map((token2) => /* @__PURE__ */ h("li", null, /* @__PURE__ */ h("a", {
      onClick: () => {
        console.log(token2);
        keyWord.value = token2;
        showingCand.value = false;
        showingTargetSearch.value = true;
        calcEmbSimWithVocab(token2);
        simWithTarget.value = NaN;
      }
    }, token2)))), /* @__PURE__ */ h("input", {
      style: [showingTargetSearch.value ? "" : "display:none;"],
      class: "small",
      type: "text",
      onInput: searchTarget,
      placeholder: "Target",
      value: targetKeyWord.value
    }), /* @__PURE__ */ h("ol", {
      style: [showingTargetCand.value ? "" : "display:none;"]
    }, targetCandidate.value.map((token2) => /* @__PURE__ */ h("li", null, /* @__PURE__ */ h("a", {
      onClick: () => {
        console.log(token2);
        targetKeyWord.value = token2;
        showingTargetCand.value = false;
        calcEmbSim(keyWord.value, token2);
      }
    }, token2)))), /* @__PURE__ */ h("p", {
      style: "font-size: 1.5rem;text-align: center;"
    }, Number.isNaN(simWithTarget.value) ? "" : `cosine similarity: ${Math.round(simWithTarget.value * 1e3) / 1e3}`));
  });
  createApp(App).mount(document.body);
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
//# sourceMappingURL=index.js.map
